<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: MathematicalProgram Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1solvers_1_1_mathematical_program.html','','classdrake_1_1solvers_1_1_mathematical_program-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">MathematicalProgram Class Reference<div class="ingroups"><a class="el" href="group__solvers.html">Formulating and Solving Optimization Problems</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> stores the decision variables, the constraints and costs of an optimization problem. </p>
<p>The user can solve the problem by calling <a class="el" href="namespacedrake_1_1solvers.html#ae34d0e7febfca6328561574df6ce91d5" title="Solves an optimization program, with optional initial guess and solver options.">solvers::Solve()</a> function, and obtain the results of the optimization. </p>
</div>
<p><code>#include &lt;drake/solvers/mathematical_program.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a407fb21fc13a5122994e71a05a6a0818" id="r_a407fb21fc13a5122994e71a05a6a0818"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> { <a class="el" href="#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">kSos</a> = 1
, <a class="el" href="#a407fb21fc13a5122994e71a05a6a0818a28b23c4ed46cc23775486c764a920e29">kSdsos</a>
, <a class="el" href="#a407fb21fc13a5122994e71a05a6a0818a26e1dbaa56329cec4d3ba803424aed81">kDsos</a>
 }</td></tr>
<tr class="memdesc:a407fb21fc13a5122994e71a05a6a0818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of non-negative polynomial that can be found through conic optimization.  <a href="#a407fb21fc13a5122994e71a05a6a0818">More...</a><br /></td></tr>
<tr class="memitem:aaed05d048d1ac7b1d4960e328c20d02f" id="r_aaed05d048d1ac7b1d4960e328c20d02f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaed05d048d1ac7b1d4960e328c20d02f">VarType</a> = <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">symbolic::Variable::Type</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac577d0f44c9c07256230cf2642ec6822" id="r_ac577d0f44c9c07256230cf2642ec6822"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> ()</td></tr>
<tr class="memitem:a4793d463ad85b0e169fef6a974df5323" id="r_a4793d463ad85b0e169fef6a974df5323"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4793d463ad85b0e169fef6a974df5323">~MathematicalProgram</a> ()</td></tr>
<tr class="memitem:a8bf8eca4db252695b1950209857df07a" id="r_a8bf8eca4db252695b1950209857df07a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bf8eca4db252695b1950209857df07a">Clone</a> () const</td></tr>
<tr class="memdesc:a8bf8eca4db252695b1950209857df07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones an optimization program.  <br /></td></tr>
<tr class="memitem:aac993ecccd3d88aafefb6b8e3caa1dee" id="r_aac993ecccd3d88aafefb6b8e3caa1dee"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac993ecccd3d88aafefb6b8e3caa1dee">to_string</a> () const</td></tr>
<tr class="memdesc:aac993ecccd3d88aafefb6b8e3caa1dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string representation of this program, listing the decision variables, costs, and constraints.  <br /></td></tr>
<tr class="memitem:acde760e4bedab593fdf328530467fa4d" id="r_acde760e4bedab593fdf328530467fa4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acde760e4bedab593fdf328530467fa4d">IsThreadSafe</a> () const</td></tr>
<tr class="memdesc:acde760e4bedab593fdf328530467fa4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether it is safe to solve this mathematical program concurrently.  <br /></td></tr>
<tr class="memitem:aab8a2c8699234750a5ed6ccaac8da198" id="r_aab8a2c8699234750a5ed6ccaac8da198"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab8a2c8699234750a5ed6ccaac8da198">ToLatex</a> (int precision=3)</td></tr>
<tr class="memdesc:aab8a2c8699234750a5ed6ccaac8da198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of this program in LaTeX.  <br /></td></tr>
<tr class="memitem:a53949966a66a6f53ba90596fc5a439ef" id="r_a53949966a66a6f53ba90596fc5a439ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53949966a66a6f53ba90596fc5a439ef">NewContinuousVariables</a> (int rows, const std::string &amp;name=&quot;x&quot;)</td></tr>
<tr class="memdesc:a53949966a66a6f53ba90596fc5a439ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds continuous variables, appending them to an internal vector of any existing vars.  <br /></td></tr>
<tr class="memitem:ac4289eb81e87e5ba7ebd0769439afe1e" id="r_ac4289eb81e87e5ba7ebd0769439afe1e"><td class="memTemplParams" colspan="2">template&lt;int Rows = Eigen::Dynamic, int Cols = Eigen::Dynamic&gt; </td></tr>
<tr class="memitem:ac4289eb81e87e5ba7ebd0769439afe1e template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; Rows, Cols &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4289eb81e87e5ba7ebd0769439afe1e">NewContinuousVariables</a> (int rows, int cols, const std::string &amp;name=&quot;X&quot;)</td></tr>
<tr class="memdesc:ac4289eb81e87e5ba7ebd0769439afe1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds continuous variables, appending them to an internal vector of any existing vars.  <br /></td></tr>
<tr class="memitem:a2bf2905bcc0613bc5055e13f6ed4ff1b" id="r_a2bf2905bcc0613bc5055e13f6ed4ff1b"><td class="memTemplParams" colspan="2">template&lt;int Rows, int Cols = 1&gt; </td></tr>
<tr class="memitem:a2bf2905bcc0613bc5055e13f6ed4ff1b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; Rows, Cols &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bf2905bcc0613bc5055e13f6ed4ff1b">NewContinuousVariables</a> (const std::string &amp;name=&quot;X&quot;)</td></tr>
<tr class="memdesc:a2bf2905bcc0613bc5055e13f6ed4ff1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds continuous variables, appending them to an internal vector of any existing vars.  <br /></td></tr>
<tr class="memitem:a7b23670884fad3013a08886ad21ab297" id="r_a7b23670884fad3013a08886ad21ab297"><td class="memTemplParams" colspan="2">template&lt;int Rows = Eigen::Dynamic, int Cols = Eigen::Dynamic&gt; </td></tr>
<tr class="memitem:a7b23670884fad3013a08886ad21ab297 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; Rows, Cols &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b23670884fad3013a08886ad21ab297">NewBinaryVariables</a> (int rows, int cols, const std::string &amp;name)</td></tr>
<tr class="memdesc:a7b23670884fad3013a08886ad21ab297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds binary variables, appending them to an internal vector of any existing vars.  <br /></td></tr>
<tr class="memitem:aef5bd1296de2515ce750f5ebe441a15a" id="r_aef5bd1296de2515ce750f5ebe441a15a"><td class="memTemplParams" colspan="2">template&lt;int Rows, int Cols = 1&gt; </td></tr>
<tr class="memitem:aef5bd1296de2515ce750f5ebe441a15a template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; Rows, Cols &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef5bd1296de2515ce750f5ebe441a15a">NewBinaryVariables</a> (const std::string &amp;name=&quot;b&quot;)</td></tr>
<tr class="memdesc:aef5bd1296de2515ce750f5ebe441a15a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a matrix of binary variables into the optimization program.  <br /></td></tr>
<tr class="memitem:a30759ec657805673fd0ce5e9edc166a2" id="r_a30759ec657805673fd0ce5e9edc166a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30759ec657805673fd0ce5e9edc166a2">NewBinaryVariables</a> (int rows, const std::string &amp;name=&quot;b&quot;)</td></tr>
<tr class="memdesc:a30759ec657805673fd0ce5e9edc166a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds binary variables to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <br /></td></tr>
<tr class="memitem:a8f718351922bc149cb6e7fa6d82288a5" id="r_a8f718351922bc149cb6e7fa6d82288a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f718351922bc149cb6e7fa6d82288a5">NewSymmetricContinuousVariables</a> (int rows, const std::string &amp;name=&quot;Symmetric&quot;)</td></tr>
<tr class="memdesc:a8f718351922bc149cb6e7fa6d82288a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a runtime sized symmetric matrix as decision variables to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <br /></td></tr>
<tr class="memitem:a70518c4015597117ed5981c729917312" id="r_a70518c4015597117ed5981c729917312"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a70518c4015597117ed5981c729917312 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; rows, rows &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70518c4015597117ed5981c729917312">NewSymmetricContinuousVariables</a> (const std::string &amp;name=&quot;Symmetric&quot;)</td></tr>
<tr class="memdesc:a70518c4015597117ed5981c729917312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a static sized symmetric matrix as decision variables to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <br /></td></tr>
<tr class="memitem:af436a548cfc2a209dc21427b328232b2" id="r_af436a548cfc2a209dc21427b328232b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af436a548cfc2a209dc21427b328232b2">AddDecisionVariables</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt; &amp;<a class="el" href="#a8edf415633915556308470787995a6a0">decision_variables</a>)</td></tr>
<tr class="memdesc:af436a548cfc2a209dc21427b328232b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends new variables to the end of the existing variables.  <br /></td></tr>
<tr class="memitem:ae6a71c1f6466e5dedbd2cd73372dfcd5" id="r_ae6a71c1f6466e5dedbd2cd73372dfcd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6a71c1f6466e5dedbd2cd73372dfcd5">NewFreePolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;<a class="el" href="#a42256b8f076fda109cf611d3b45e2e5e">indeterminates</a>, int degree, const std::string &amp;coeff_name=&quot;a&quot;)</td></tr>
<tr class="memdesc:ae6a71c1f6466e5dedbd2cd73372dfcd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a free polynomial in a monomial basis over <code class="param">indeterminates</code> of a given <code class="param">degree</code>.  <br /></td></tr>
<tr class="memitem:a4892d2259256cc4aff04a354391eae77" id="r_a4892d2259256cc4aff04a354391eae77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4892d2259256cc4aff04a354391eae77">NewEvenDegreeFreePolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;<a class="el" href="#a42256b8f076fda109cf611d3b45e2e5e">indeterminates</a>, int degree, const std::string &amp;coeff_name=&quot;a&quot;)</td></tr>
<tr class="memdesc:a4892d2259256cc4aff04a354391eae77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a free polynomial that only contains even degree monomials.  <br /></td></tr>
<tr class="memitem:aa65f91d84b3f2f0a5354def05ddb51e4" id="r_aa65f91d84b3f2f0a5354def05ddb51e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa65f91d84b3f2f0a5354def05ddb51e4">NewOddDegreeFreePolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;<a class="el" href="#a42256b8f076fda109cf611d3b45e2e5e">indeterminates</a>, int degree, const std::string &amp;coeff_name=&quot;a&quot;)</td></tr>
<tr class="memdesc:aa65f91d84b3f2f0a5354def05ddb51e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a free polynomial that only contains odd degree monomials.  <br /></td></tr>
<tr class="memitem:a7959d174df7776311b5520c2ab0b698b" id="r_a7959d174df7776311b5520c2ab0b698b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7959d174df7776311b5520c2ab0b698b">NewSosPolynomial</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt; &gt; &amp;monomial_basis, <a class="el" href="#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> type=<a class="el" href="#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a>, const std::string &amp;gram_name=&quot;S&quot;)</td></tr>
<tr class="memdesc:a7959d174df7776311b5520c2ab0b698b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair of a SOS polynomial p = mᵀQm and the Gramian matrix Q, where m is the <code class="param">monomial</code> basis.  <br /></td></tr>
<tr class="memitem:a27dc3e26c390f156079b2380ade4a28a" id="r_a27dc3e26c390f156079b2380ade4a28a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27dc3e26c390f156079b2380ade4a28a">NewSosPolynomial</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &amp;gramian, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt; &gt; &amp;monomial_basis, <a class="el" href="#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> type=<a class="el" href="#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a>)</td></tr>
<tr class="memdesc:a27dc3e26c390f156079b2380ade4a28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads NewSosPolynomial, except the Gramian matrix Q is an input instead of an output.  <br /></td></tr>
<tr class="memitem:afe6d3a84c9a6e47773fc5950cfc6956b" id="r_afe6d3a84c9a6e47773fc5950cfc6956b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe6d3a84c9a6e47773fc5950cfc6956b">NewSosPolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;<a class="el" href="#a42256b8f076fda109cf611d3b45e2e5e">indeterminates</a>, int degree, <a class="el" href="#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> type=<a class="el" href="#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a>, const std::string &amp;gram_name=&quot;S&quot;)</td></tr>
<tr class="memdesc:afe6d3a84c9a6e47773fc5950cfc6956b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads NewSosPolynomial.  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment.</div></td></tr>
<tr class="memitem:a6d281d024510ccc0f7787ebbb1e534ee" id="r_a6d281d024510ccc0f7787ebbb1e534ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> (const MathematicalProgram &amp;)=delete</td></tr>
<tr class="memitem:a52818d384c5209004e28e368159dc3f8" id="r_a52818d384c5209004e28e368159dc3f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52818d384c5209004e28e368159dc3f8">operator=</a> (const <a class="el" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> &amp;)=delete</td></tr>
<tr class="memitem:a1935f9e12a11b66c67eda33fd165b4d3" id="r_a1935f9e12a11b66c67eda33fd165b4d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1935f9e12a11b66c67eda33fd165b4d3">MathematicalProgram</a> (MathematicalProgram &amp;&amp;)=delete</td></tr>
<tr class="memitem:aeb492b0c14e1ddab97608e6ebdc0cb58" id="r_aeb492b0c14e1ddab97608e6ebdc0cb58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb492b0c14e1ddab97608e6ebdc0cb58">operator=</a> (<a class="el" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> &amp;&amp;)=delete</td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Matrix log determinant</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="log_determinant"></a> Represents the log-determinant of <span class="tt">X</span> by introducing slack variables t, and a lower triangular matrix Z and imposing the constraints</p>
<p>⌈X Z⌉ is positive semidifinite. ⌊Zᵀ diag(Z)⌋</p>
<p>log(Z(i, i)) &gt;= t(i)</p>
<p>Since log(det(X)) is a concave function of X, we can either lower bound it's value by imposing the constraint <span class="tt">∑ᵢt(i) &gt;= lower</span> or maximize its value by adding the cost -∑ᵢt(i) using convex optimization. </p><dl class="section note"><dt>Note</dt><dd>The constraint log(Z(i, i)) &gt;= t(i) is imposed as an exponential cone constraint. Please make sure your have a solver that supports exponential cone constraint (currently SCS and Mosek do). </dd>
<dd>
The constraint that <pre class="fragment">⌈X         Z⌉ is positive semidifinite.
⌊Zᵀ  diag(Z)⌋
</pre></dd></dl>
<p>already implies that X is positive semidefinite. The user DO NOT need to separately impose the constraint that X being psd.</p>
<p>Refer to <a href="https://docs.mosek.com/modeling-cookbook/sdo.html#log-determinant">https://docs.mosek.com/modeling-cookbook/sdo.html#log-determinant</a> for more details. </p>
</div></td></tr>
<tr class="memitem:af41ff66fc4e80a37fafb623ee8b9ae73" id="r_af41ff66fc4e80a37fafb623ee8b9ae73"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af41ff66fc4e80a37fafb623ee8b9ae73">AddMaximizeLogDeterminantCost</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;X)</td></tr>
<tr class="memdesc:af41ff66fc4e80a37fafb623ee8b9ae73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximize the log determinant.  <br /></td></tr>
<tr class="memitem:a49456fc8e174f6f6b3e74f901b2ca5b8" id="r_a49456fc8e174f6f6b3e74f901b2ca5b8"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49456fc8e174f6f6b3e74f901b2ca5b8">AddLogDeterminantLowerBoundConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;X, <a class="el" href="classdouble.html">double</a> lower)</td></tr>
<tr class="memdesc:a49456fc8e174f6f6b3e74f901b2ca5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose the constraint log(det(X)) &gt;= lower.  <br /></td></tr>
<tr id="pub-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Maximize geometric mean</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="maximize_geometric_mean"></a> Adds the cost to maximize the geometric mean of z = Ax+b, i.e.</p>
<p>power(∏ᵢz(i), 1/n), where z ∈ ℝⁿ, z(i) &gt;= 0. Mathematically, the cost we add is -power(∏ᵢz(i), 1/r), where r = power(2, ceil(log₂n)), namely r is the smallest power of 2 that is no smaller than the size of z. For example, if z ∈ ℝ², then the added cost is -power(z(0)*z(1), 1/2) if z ∈ ℝ³, then the added cost is -power(z(0)*z(1)*z(2), 1/4).</p>
<p>In order to add this cost, we need to introduce a set of second-order cone constraints. For example, to maximize power(z(0) * z(1), 1/2), we introduce the slack variable w(0), together with the second order cone constraint w(0)² ≤ z(0) * z(1), z(0) ≥ 0, z(1) ≥ 0, and we maximize w(0).</p>
<p>To maximize power(z(0) * z(1) * z(2), 1/ 4), we introduce the slack variable w(0), w(1), w(2), together with the second order cone constraints </p><pre>
w(0)² ≤ z(0) * z(1), z(0) ≥ 0, z(1) ≥ 0
w(1)² ≤ z(2), z(2) ≥ 0
w(2)² ≤ w(0) * w(1), w(0) ≥ 0, w(1) ≥ 0
</pre><p> and we maximize w(2). </p>
</div></td></tr>
<tr class="memitem:a81a184723f3b7f8171f549d7163a9f5b" id="r_a81a184723f3b7f8171f549d7163a9f5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81a184723f3b7f8171f549d7163a9f5b">AddMaximizeGeometricMeanCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &amp;x)</td></tr>
<tr class="memdesc:a81a184723f3b7f8171f549d7163a9f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overloaded version of <a class="el" href="#maximize_geometric_mean">maximize_geometric_mean</a>.  <br /></td></tr>
<tr class="memitem:ae88f4bd8b4b118589406e4221313817c" id="r_ae88f4bd8b4b118589406e4221313817c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae88f4bd8b4b118589406e4221313817c">AddMaximizeGeometricMeanCost</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &amp;x, <a class="el" href="classdouble.html">double</a> c=1.0)</td></tr>
<tr class="memdesc:ae88f4bd8b4b118589406e4221313817c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overloaded version of <a class="el" href="#maximize_geometric_mean">maximize_geometric_mean</a>.  <br /></td></tr>
<tr class="memitem:af05fa6863859ca8be0153e10c29def11" id="r_af05fa6863859ca8be0153e10c29def11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af05fa6863859ca8be0153e10c29def11">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:af05fa6863859ca8be0153e10c29def11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a generic constraint to the program.  <br /></td></tr>
<tr class="memitem:ab94e40b82b4d9d62a702cf6636493416" id="r_ab94e40b82b4d9d62a702cf6636493416"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab94e40b82b4d9d62a702cf6636493416">AddConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, <a class="el" href="classdouble.html">double</a> lb, <a class="el" href="classdouble.html">double</a> ub)</td></tr>
<tr class="memdesc:ab94e40b82b4d9d62a702cf6636493416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one row of constraint lb &lt;= e &lt;= ub where <code class="param">e</code> is a symbolic expression.  <br /></td></tr>
<tr class="memitem:a13da3f2f6edd0fd8b67178a75c29cbb5" id="r_a13da3f2f6edd0fd8b67178a75c29cbb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13da3f2f6edd0fd8b67178a75c29cbb5">AddConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;v, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;ub)</td></tr>
<tr class="memitem:ae8d9bfe34ef20a9f343e518fccc40bd6" id="r_ae8d9bfe34ef20a9f343e518fccc40bd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8d9bfe34ef20a9f343e518fccc40bd6">AddConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;f)</td></tr>
<tr class="memdesc:ae8d9bfe34ef20a9f343e518fccc40bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a constraint represented by a symbolic formula to the program.  <br /></td></tr>
<tr class="memitem:ace80ac92eb39cb00aeccd45c7b572cba" id="r_ace80ac92eb39cb00aeccd45c7b572cba"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:ace80ac92eb39cb00aeccd45c7b572cba template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt; Derived, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace80ac92eb39cb00aeccd45c7b572cba">AddConstraint</a> (const Eigen::DenseBase&lt; Derived &gt; &amp;formulas)</td></tr>
<tr class="memitem:a0c28156f900997a8fb1b0079e30fce6d" id="r_a0c28156f900997a8fb1b0079e30fce6d"><td class="memTemplParams" colspan="2">template&lt;typename C&gt; </td></tr>
<tr class="memitem:a0c28156f900997a8fb1b0079e30fce6d template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c28156f900997a8fb1b0079e30fce6d">AddConstraint</a> (std::shared_ptr&lt; C &gt; con, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a0c28156f900997a8fb1b0079e30fce6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a generic constraint to the program.  <br /></td></tr>
<tr class="memitem:a8d26f3d31c9cfba7144b9a0d96aebdd0" id="r_a8d26f3d31c9cfba7144b9a0d96aebdd0"><td class="memTemplParams" colspan="2">template&lt;typename C&gt; </td></tr>
<tr class="memitem:a8d26f3d31c9cfba7144b9a0d96aebdd0 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d26f3d31c9cfba7144b9a0d96aebdd0">AddConstraint</a> (std::shared_ptr&lt; C &gt; con, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a8d26f3d31c9cfba7144b9a0d96aebdd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a generic constraint to the program.  <br /></td></tr>
<tr class="memitem:adb35904c3fd69181dba1a7f185662473" id="r_adb35904c3fd69181dba1a7f185662473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb35904c3fd69181dba1a7f185662473">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:adb35904c3fd69181dba1a7f185662473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear constraints referencing potentially a subset of the decision variables (defined in the vars parameter).  <br /></td></tr>
<tr class="memitem:ae73446f6e62cec6b42e8331a63fecd80" id="r_ae73446f6e62cec6b42e8331a63fecd80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae73446f6e62cec6b42e8331a63fecd80">AddLinearConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:ae73446f6e62cec6b42e8331a63fecd80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear constraints referencing potentially a subset of the decision variables (defined in the vars parameter).  <br /></td></tr>
<tr class="memitem:abae6b3bdbb778be79abe20f3f977b1a9" id="r_abae6b3bdbb778be79abe20f3f977b1a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abae6b3bdbb778be79abe20f3f977b1a9">AddLinearConstraint</a> (const Eigen::SparseMatrix&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:abae6b3bdbb778be79abe20f3f977b1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds sparse linear constraints referencing potentially a subset of the decision variables (defined in the vars parameter).  <br /></td></tr>
<tr class="memitem:ae78a44ed429e0dea8964470adbb46218" id="r_ae78a44ed429e0dea8964470adbb46218"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae78a44ed429e0dea8964470adbb46218">AddLinearConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:ae78a44ed429e0dea8964470adbb46218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear constraints referencing potentially a subset of the decision variables (defined in the vars parameter).  <br /></td></tr>
<tr class="memitem:a04044b1066ad9f2b70e24e283551d900" id="r_a04044b1066ad9f2b70e24e283551d900"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04044b1066ad9f2b70e24e283551d900">AddLinearConstraint</a> (const Eigen::SparseMatrix&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a04044b1066ad9f2b70e24e283551d900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds sparse linear constraints referencing potentially a subset of the decision variables (defined in the vars parameter).  <br /></td></tr>
<tr class="memitem:ab33fe7b6e2383345d0293ab53cb08cf9" id="r_ab33fe7b6e2383345d0293ab53cb08cf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab33fe7b6e2383345d0293ab53cb08cf9">AddLinearConstraint</a> (const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;a, <a class="el" href="classdouble.html">double</a> lb, <a class="el" href="classdouble.html">double</a> ub, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:ab33fe7b6e2383345d0293ab53cb08cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one row of linear constraint referencing potentially a subset of the decision variables (defined in the vars parameter).  <br /></td></tr>
<tr class="memitem:a02f751c03b19f886921c96bce594708f" id="r_a02f751c03b19f886921c96bce594708f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02f751c03b19f886921c96bce594708f">AddLinearConstraint</a> (const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;a, <a class="el" href="classdouble.html">double</a> lb, <a class="el" href="classdouble.html">double</a> ub, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a02f751c03b19f886921c96bce594708f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one row of linear constraint referencing potentially a subset of the decision variables (defined in the vars parameter).  <br /></td></tr>
<tr class="memitem:a11440aef6df9ddedfd6675ce56fe6e16" id="r_a11440aef6df9ddedfd6675ce56fe6e16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11440aef6df9ddedfd6675ce56fe6e16">AddLinearConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, <a class="el" href="classdouble.html">double</a> lb, <a class="el" href="classdouble.html">double</a> ub)</td></tr>
<tr class="memdesc:a11440aef6df9ddedfd6675ce56fe6e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one row of linear constraint lb &lt;= e &lt;= ub where <code class="param">e</code> is a symbolic expression.  <br /></td></tr>
<tr class="memitem:adf32b3d53ae76435192532f9c013014d" id="r_adf32b3d53ae76435192532f9c013014d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf32b3d53ae76435192532f9c013014d">AddLinearConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;v, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;ub)</td></tr>
<tr class="memdesc:adf32b3d53ae76435192532f9c013014d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear constraints represented by symbolic expressions to the program.  <br /></td></tr>
<tr class="memitem:a1ecde2056d0658ea4dac1c0e632ad353" id="r_a1ecde2056d0658ea4dac1c0e632ad353"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ecde2056d0658ea4dac1c0e632ad353">AddLinearConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a1ecde2056d0658ea4dac1c0e632ad353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a linear constraint represented by a symbolic formula to the program.  <br /></td></tr>
<tr class="memitem:ae6ce8aa8d46b8d82cb7f8f5b10e7e83d" id="r_ae6ce8aa8d46b8d82cb7f8f5b10e7e83d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6ce8aa8d46b8d82cb7f8f5b10e7e83d">AddLinearConstraint</a> (const Eigen::Ref&lt; const Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &gt; &amp;formulas)</td></tr>
<tr class="memdesc:ae6ce8aa8d46b8d82cb7f8f5b10e7e83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a linear constraint represented by an Eigen::Array&lt;symbolic::Formula&gt; to the program.  <br /></td></tr>
<tr class="memitem:a9673db3dce831cddef02eb3345a5f809" id="r_a9673db3dce831cddef02eb3345a5f809"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9673db3dce831cddef02eb3345a5f809">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a9673db3dce831cddef02eb3345a5f809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear equality constraints referencing potentially a subset of the decision variables.  <br /></td></tr>
<tr class="memitem:adce9200575be00912b9f62ee4ea53599" id="r_adce9200575be00912b9f62ee4ea53599"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adce9200575be00912b9f62ee4ea53599">AddLinearEqualityConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, <a class="el" href="classdouble.html">double</a> b)</td></tr>
<tr class="memdesc:adce9200575be00912b9f62ee4ea53599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one row of linear constraint e = b where <code class="param">e</code> is a symbolic expression.  <br /></td></tr>
<tr class="memitem:a51f626f98cede0db08541462de301bf9" id="r_a51f626f98cede0db08541462de301bf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51f626f98cede0db08541462de301bf9">AddLinearEqualityConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a51f626f98cede0db08541462de301bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear equality constraint represented by a symbolic formula to the program.  <br /></td></tr>
<tr class="memitem:a8a21f874c214118c63e2b954eb330e60" id="r_a8a21f874c214118c63e2b954eb330e60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a21f874c214118c63e2b954eb330e60">AddLinearEqualityConstraint</a> (const Eigen::Ref&lt; const Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &gt; &amp;formulas)</td></tr>
<tr class="memdesc:a8a21f874c214118c63e2b954eb330e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear equality constraint represented by an Eigen::Array&lt;symbolic::Formula&gt; to the program.  <br /></td></tr>
<tr class="memitem:a52e173057b32bdbc6cd4c0a91273155a" id="r_a52e173057b32bdbc6cd4c0a91273155a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV, typename DerivedB&gt; </td></tr>
<tr class="memitem:a52e173057b32bdbc6cd4c0a91273155a template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__vector__expression__double__pair.html">is_eigen_vector_expression_double_pair</a>&lt; DerivedV, DerivedB &gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52e173057b32bdbc6cd4c0a91273155a">AddLinearEqualityConstraint</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;v, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:a52e173057b32bdbc6cd4c0a91273155a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear equality constraints \( v = b \), where <code class="param">v(i)</code> is a symbolic linear expression.  <br /></td></tr>
<tr class="memitem:af564a395db829d7ef259f7e0fda590d1" id="r_af564a395db829d7ef259f7e0fda590d1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV, typename DerivedB&gt; </td></tr>
<tr class="memitem:af564a395db829d7ef259f7e0fda590d1 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__nonvector__expression__double__pair.html">is_eigen_nonvector_expression_double_pair</a>&lt; DerivedV, DerivedB &gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af564a395db829d7ef259f7e0fda590d1">AddLinearEqualityConstraint</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B, bool lower_triangle=false)</td></tr>
<tr class="memdesc:af564a395db829d7ef259f7e0fda590d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear equality constraint for a matrix of linear expression <code class="param">V</code>, such that V(i, j) = B(i, j).  <br /></td></tr>
<tr class="memitem:a9de4ad8b35749c5d243bc7d7d30c9cce" id="r_a9de4ad8b35749c5d243bc7d7d30c9cce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9de4ad8b35749c5d243bc7d7d30c9cce">AddLinearEqualityConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Aeq, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;beq, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a9de4ad8b35749c5d243bc7d7d30c9cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">AddLinearEqualityConstraint.  <br /></td></tr>
<tr class="memitem:aed0a437321c66db371e91c105278cbdb" id="r_aed0a437321c66db371e91c105278cbdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed0a437321c66db371e91c105278cbdb">AddLinearEqualityConstraint</a> (const Eigen::SparseMatrix&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;Aeq, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;beq, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:aed0a437321c66db371e91c105278cbdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">AddLinearEqualityConstraint.  <br /></td></tr>
<tr class="memitem:ae7cd4f274bef65432200b7af16fd9547" id="r_ae7cd4f274bef65432200b7af16fd9547"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7cd4f274bef65432200b7af16fd9547">AddLinearEqualityConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Aeq, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;beq, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:ae7cd4f274bef65432200b7af16fd9547"><td class="mdescLeft">&#160;</td><td class="mdescRight">AddLinearEqualityConstraint.  <br /></td></tr>
<tr class="memitem:a7686a606e69b00659edb6bf58c6f359a" id="r_a7686a606e69b00659edb6bf58c6f359a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7686a606e69b00659edb6bf58c6f359a">AddLinearEqualityConstraint</a> (const Eigen::SparseMatrix&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;Aeq, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;beq, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a7686a606e69b00659edb6bf58c6f359a"><td class="mdescLeft">&#160;</td><td class="mdescRight">AddLinearEqualityConstraint.  <br /></td></tr>
<tr class="memitem:a9655ba551c55797c1e8f09726df7cd83" id="r_a9655ba551c55797c1e8f09726df7cd83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9655ba551c55797c1e8f09726df7cd83">AddLinearEqualityConstraint</a> (const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;a, <a class="el" href="classdouble.html">double</a> beq, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a9655ba551c55797c1e8f09726df7cd83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one row of linear equality constraint referencing potentially a subset of decision variables.  <br /></td></tr>
<tr class="memitem:aea3c78c0bceb34690aeb9c1bc4623a08" id="r_aea3c78c0bceb34690aeb9c1bc4623a08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea3c78c0bceb34690aeb9c1bc4623a08">AddLinearEqualityConstraint</a> (const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;a, <a class="el" href="classdouble.html">double</a> beq, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:aea3c78c0bceb34690aeb9c1bc4623a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one row of linear equality constraint referencing potentially a subset of decision variables.  <br /></td></tr>
<tr class="memitem:a3e23aa9a8116a05e5ef8c9dd6d7fa5e3" id="r_a3e23aa9a8116a05e5ef8c9dd6d7fa5e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e23aa9a8116a05e5ef8c9dd6d7fa5e3">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a3e23aa9a8116a05e5ef8c9dd6d7fa5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds bounding box constraints referencing potentially a subest of the decision variables.  <br /></td></tr>
<tr class="memitem:aced7aa6413bd59c13621dc20250f9bbb" id="r_aced7aa6413bd59c13621dc20250f9bbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aced7aa6413bd59c13621dc20250f9bbb">AddBoundingBoxConstraint</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:aced7aa6413bd59c13621dc20250f9bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">AddBoundingBoxConstraint.  <br /></td></tr>
<tr class="memitem:a7d9354ce0d9623dd53f01ecb80b3cfe2" id="r_a7d9354ce0d9623dd53f01ecb80b3cfe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d9354ce0d9623dd53f01ecb80b3cfe2">AddBoundingBoxConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;ub, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a7d9354ce0d9623dd53f01ecb80b3cfe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds bounding box constraints referencing potentially a subset of the decision variables.  <br /></td></tr>
<tr class="memitem:a9207789fa0f2fef22d52c9665e8880c4" id="r_a9207789fa0f2fef22d52c9665e8880c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9207789fa0f2fef22d52c9665e8880c4">AddBoundingBoxConstraint</a> (<a class="el" href="classdouble.html">double</a> lb, <a class="el" href="classdouble.html">double</a> ub, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;var)</td></tr>
<tr class="memdesc:a9207789fa0f2fef22d52c9665e8880c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds bounds for a single variable.  <br /></td></tr>
<tr class="memitem:a405514ee538d773b3e533a09d9207457" id="r_a405514ee538d773b3e533a09d9207457"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a405514ee538d773b3e533a09d9207457">AddBoundingBoxConstraint</a> (<a class="el" href="classdouble.html">double</a> lb, <a class="el" href="classdouble.html">double</a> ub, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a405514ee538d773b3e533a09d9207457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the same scalar lower and upper bound to every variable in the list.  <br /></td></tr>
<tr class="memitem:a820bd029a9d41d438df117770f93822a" id="r_a820bd029a9d41d438df117770f93822a"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a820bd029a9d41d438df117770f93822a template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &amp;&amp;Derived::ColsAtCompileTime==1, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a820bd029a9d41d438df117770f93822a">AddBoundingBoxConstraint</a> (<a class="el" href="classdouble.html">double</a> lb, <a class="el" href="classdouble.html">double</a> ub, const Eigen::MatrixBase&lt; Derived &gt; &amp;vars)</td></tr>
<tr class="memdesc:a820bd029a9d41d438df117770f93822a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the same scalar lower and upper bound to every variable in <code class="param">vars</code>.  <br /></td></tr>
<tr class="memitem:aa6e4fbc2c4e7819d3382b42778537161" id="r_aa6e4fbc2c4e7819d3382b42778537161"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:aa6e4fbc2c4e7819d3382b42778537161 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &amp;&amp;Derived::ColsAtCompileTime !=1, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6e4fbc2c4e7819d3382b42778537161">AddBoundingBoxConstraint</a> (<a class="el" href="classdouble.html">double</a> lb, <a class="el" href="classdouble.html">double</a> ub, const Eigen::MatrixBase&lt; Derived &gt; &amp;vars)</td></tr>
<tr class="memdesc:aa6e4fbc2c4e7819d3382b42778537161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the same scalar lower and upper bound to every variable in <code class="param">vars</code>.  <br /></td></tr>
<tr class="memitem:a5efeb642dbf02776438ca049a3e42c39" id="r_a5efeb642dbf02776438ca049a3e42c39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_constraint.html">QuadraticConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5efeb642dbf02776438ca049a3e42c39">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_constraint.html">QuadraticConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a5efeb642dbf02776438ca049a3e42c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds quadratic constraint.  <br /></td></tr>
<tr class="memitem:a2056b1b15a85ae7936b320668c55716e" id="r_a2056b1b15a85ae7936b320668c55716e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_constraint.html">QuadraticConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2056b1b15a85ae7936b320668c55716e">AddQuadraticConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, <a class="el" href="classdouble.html">double</a> lb, <a class="el" href="classdouble.html">double</a> ub, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars, std::optional&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_constraint.html#a604cad5cda14e378ce4a77ab28ee9fd9">QuadraticConstraint::HessianType</a> &gt; hessian_type=std::nullopt)</td></tr>
<tr class="memdesc:a2056b1b15a85ae7936b320668c55716e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds quadratic constraint lb ≤ .5 xᵀQx + bᵀx ≤ ub Notice that if your quadratic constraint is convex, and you intend to solve the problem with a convex solver (like Mosek), then it is better to reformulate it with a second order cone constraint.  <br /></td></tr>
<tr class="memitem:a889fc7ebf3403ad19b99619211634ae7" id="r_a889fc7ebf3403ad19b99619211634ae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_constraint.html">QuadraticConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a889fc7ebf3403ad19b99619211634ae7">AddQuadraticConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, <a class="el" href="classdouble.html">double</a> lb, <a class="el" href="classdouble.html">double</a> ub, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars, std::optional&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_constraint.html#a604cad5cda14e378ce4a77ab28ee9fd9">QuadraticConstraint::HessianType</a> &gt; hessian_type=std::nullopt)</td></tr>
<tr class="memdesc:a889fc7ebf3403ad19b99619211634ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds quadratic constraint lb ≤ .5 xᵀQx + bᵀx ≤ ub Notice that if your quadratic constraint is convex, and you intend to solve the problem with a convex solver (like Mosek), then it is better to reformulate it with a second order cone constraint.  <br /></td></tr>
<tr class="memitem:abf7df46d3c85d0fb554170521011c169" id="r_abf7df46d3c85d0fb554170521011c169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_constraint.html">QuadraticConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf7df46d3c85d0fb554170521011c169">AddQuadraticConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, <a class="el" href="classdouble.html">double</a> lb, <a class="el" href="classdouble.html">double</a> ub, std::optional&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_constraint.html#a604cad5cda14e378ce4a77ab28ee9fd9">QuadraticConstraint::HessianType</a> &gt; hessian_type=std::nullopt)</td></tr>
<tr class="memdesc:abf7df46d3c85d0fb554170521011c169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads AddQuadraticConstraint, impose lb &lt;= e &lt;= ub where <span class="tt">e</span> is a quadratic expression.  <br /></td></tr>
<tr class="memitem:a008804cb1833a8496b6131daf8ace573" id="r_a008804cb1833a8496b6131daf8ace573"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a008804cb1833a8496b6131daf8ace573">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a008804cb1833a8496b6131daf8ace573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds Lorentz cone constraint referencing potentially a subset of the decision variables.  <br /></td></tr>
<tr class="memitem:a71c6b407838eed56bd96a33b64631ed6" id="r_a71c6b407838eed56bd96a33b64631ed6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71c6b407838eed56bd96a33b64631ed6">AddLorentzConeConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;f, <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a> eval_type=<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a>, <a class="el" href="classdouble.html">double</a> psd_tol=1e-8, <a class="el" href="classdouble.html">double</a> coefficient_tol=1e-8)</td></tr>
<tr class="memdesc:a71c6b407838eed56bd96a33b64631ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a Lorentz cone constraint of the form Ax+b &gt;= |Cx+d|₂ from a symbolic formula with one side which can be decomposed into sqrt((Cx+d)'(Cx+d)).  <br /></td></tr>
<tr class="memitem:a549db428087f40a28f570d96ffdacbba" id="r_a549db428087f40a28f570d96ffdacbba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a549db428087f40a28f570d96ffdacbba">AddLorentzConeConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;v, <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a> eval_type=<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a>)</td></tr>
<tr class="memdesc:a549db428087f40a28f570d96ffdacbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds Lorentz cone constraint referencing potentially a subset of the decision variables.  <br /></td></tr>
<tr class="memitem:abb92d5cedef371f57961674b3535e579" id="r_abb92d5cedef371f57961674b3535e579"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb92d5cedef371f57961674b3535e579">AddLorentzConeConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;linear_expression, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;quadratic_expression, <a class="el" href="classdouble.html">double</a> tol=0, <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a> eval_type=<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a>)</td></tr>
<tr class="memdesc:abb92d5cedef371f57961674b3535e579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds Lorentz cone constraint on the linear expression v1 and quadratic expression v2, such that v1 &gt;= sqrt(v2).  <br /></td></tr>
<tr class="memitem:a24cd977b63b356950165807fcfffd855" id="r_a24cd977b63b356950165807fcfffd855"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24cd977b63b356950165807fcfffd855">AddLorentzConeConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars, <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a> eval_type=<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a>)</td></tr>
<tr class="memdesc:a24cd977b63b356950165807fcfffd855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds Lorentz cone constraint referencing potentially a subset of the decision variables (defined in the vars parameter).  <br /></td></tr>
<tr class="memitem:a660fa2d745904f2b3b15868dc801e7bf" id="r_a660fa2d745904f2b3b15868dc801e7bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a660fa2d745904f2b3b15868dc801e7bf">AddLorentzConeConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars, <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a> eval_type=<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a>)</td></tr>
<tr class="memdesc:a660fa2d745904f2b3b15868dc801e7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds Lorentz cone constraint referencing potentially a subset of the decision variables (defined in the vars parameter).  <br /></td></tr>
<tr class="memitem:a203a7fc9d8d4da6977b58afe7427bc22" id="r_a203a7fc9d8d4da6977b58afe7427bc22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a203a7fc9d8d4da6977b58afe7427bc22">AddLorentzConeConstraint</a> (const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars, <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a> eval_type=<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a>)</td></tr>
<tr class="memdesc:a203a7fc9d8d4da6977b58afe7427bc22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imposes that a vector \( x\in\mathbb{R}^m \) lies in Lorentz cone.  <br /></td></tr>
<tr class="memitem:a60d7aa71c11c26ede234178cdef50ed6" id="r_a60d7aa71c11c26ede234178cdef50ed6"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a60d7aa71c11c26ede234178cdef50ed6 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60d7aa71c11c26ede234178cdef50ed6">AddLorentzConeConstraint</a> (const Eigen::MatrixBase&lt; <a class="el" href="namespacedrake_1_1solvers.html#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a>&lt; rows &gt; &gt; &amp;vars, <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a> eval_type=<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a>)</td></tr>
<tr class="memdesc:a60d7aa71c11c26ede234178cdef50ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imposes that a vector \( x\in\mathbb{R}^m \) lies in Lorentz cone.  <br /></td></tr>
<tr class="memitem:a63a80e477decc42724b9e814d70cc339" id="r_a63a80e477decc42724b9e814d70cc339"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63a80e477decc42724b9e814d70cc339">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a63a80e477decc42724b9e814d70cc339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a rotated Lorentz cone constraint referencing potentially a subset of decision variables.  <br /></td></tr>
<tr class="memitem:a52ceaba09e755defc9a689829a1ceb84" id="r_a52ceaba09e755defc9a689829a1ceb84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52ceaba09e755defc9a689829a1ceb84">AddRotatedLorentzConeConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;linear_expression1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;linear_expression2, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;quadratic_expression, <a class="el" href="classdouble.html">double</a> tol=0)</td></tr>
<tr class="memdesc:a52ceaba09e755defc9a689829a1ceb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds rotated Lorentz cone constraint on the linear expression v1, v2 and quadratic expression u, such that v1 * v2 &gt;= u, v1 &gt;= 0, v2 &gt;= 0.  <br /></td></tr>
<tr class="memitem:a9da7a2631c39df85535f07442694d1c8" id="r_a9da7a2631c39df85535f07442694d1c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9da7a2631c39df85535f07442694d1c8">AddRotatedLorentzConeConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;v)</td></tr>
<tr class="memdesc:a9da7a2631c39df85535f07442694d1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constraint that a symbolic expression <span class="tt">v</span> is in the rotated Lorentz cone, i.e.,.  <br /></td></tr>
<tr class="memitem:ad1a3f68dc5426b6c41009cb453de11fb" id="r_ad1a3f68dc5426b6c41009cb453de11fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1a3f68dc5426b6c41009cb453de11fb">AddRotatedLorentzConeConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:ad1a3f68dc5426b6c41009cb453de11fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a rotated Lorentz cone constraint referencing potentially a subset of decision variables, The linear expression \( z=Ax+b \) is in rotated Lorentz cone.  <br /></td></tr>
<tr class="memitem:acbaf2d641fd2fffcb7c7a3c68f0929be" id="r_acbaf2d641fd2fffcb7c7a3c68f0929be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbaf2d641fd2fffcb7c7a3c68f0929be">AddRotatedLorentzConeConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:acbaf2d641fd2fffcb7c7a3c68f0929be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a rotated Lorentz cone constraint referencing potentially a subset of decision variables, The linear expression \( z=Ax+b \) is in rotated Lorentz cone.  <br /></td></tr>
<tr class="memitem:a5260ab6567586156451d8e507973a833" id="r_a5260ab6567586156451d8e507973a833"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5260ab6567586156451d8e507973a833">AddRotatedLorentzConeConstraint</a> (const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a5260ab6567586156451d8e507973a833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose that a vector \( x\in\mathbb{R}^m \) is in rotated Lorentz cone.  <br /></td></tr>
<tr class="memitem:a0665194d043c0986f2aedc3cb2ff2e24" id="r_a0665194d043c0986f2aedc3cb2ff2e24"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a0665194d043c0986f2aedc3cb2ff2e24 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0665194d043c0986f2aedc3cb2ff2e24">AddRotatedLorentzConeConstraint</a> (const Eigen::MatrixBase&lt; <a class="el" href="namespacedrake_1_1solvers.html#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a>&lt; rows &gt; &gt; &amp;vars)</td></tr>
<tr class="memdesc:a0665194d043c0986f2aedc3cb2ff2e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose that a vector \( x\in\mathbb{R}^m \) is in rotated Lorentz cone.  <br /></td></tr>
<tr class="memitem:a4122eac69435dfefffe033a01cf60723" id="r_a4122eac69435dfefffe033a01cf60723"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4122eac69435dfefffe033a01cf60723">AddQuadraticAsRotatedLorentzConeConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, <a class="el" href="classdouble.html">double</a> c, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &amp;vars, <a class="el" href="classdouble.html">double</a> psd_tol=0.)</td></tr>
<tr class="memdesc:a4122eac69435dfefffe033a01cf60723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the convex quadratic constraint 0.5xᵀQx + bᵀx + c &lt;= 0 as a rotated Lorentz cone constraint [rᵀx+s, 1, Px+q] is in the rotated Lorentz cone.  <br /></td></tr>
<tr class="memitem:a69dd1bb48c3631c7a2e0a70e50022c1a" id="r_a69dd1bb48c3631c7a2e0a70e50022c1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69dd1bb48c3631c7a2e0a70e50022c1a">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a69dd1bb48c3631c7a2e0a70e50022c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear complementarity constraints referencing a subset of the decision variables.  <br /></td></tr>
<tr class="memitem:a39207cb8b0a32fdcda7d36d10700388d" id="r_a39207cb8b0a32fdcda7d36d10700388d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39207cb8b0a32fdcda7d36d10700388d">AddLinearComplementarityConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;M, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;q, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a39207cb8b0a32fdcda7d36d10700388d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear complementarity constraints referencing a subset of the decision variables.  <br /></td></tr>
<tr class="memitem:ad946ddf713f3d8f248c417cf9b728ec8" id="r_ad946ddf713f3d8f248c417cf9b728ec8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad946ddf713f3d8f248c417cf9b728ec8">AddLinearComplementarityConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;M, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;q, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:ad946ddf713f3d8f248c417cf9b728ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear complementarity constraints referencing a subset of the decision variables.  <br /></td></tr>
<tr class="memitem:ab79f540383e93ae6941d08e2e4f7c5db" id="r_ab79f540383e93ae6941d08e2e4f7c5db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab79f540383e93ae6941d08e2e4f7c5db">AddPolynomialConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="namespacedrake.html#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a> &gt; &gt; &amp;polynomials, const std::vector&lt; <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">Polynomiald::VarType</a> &gt; &amp;poly_vars, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;ub, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:ab79f540383e93ae6941d08e2e4f7c5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a polynomial constraint to the program referencing a subset of the decision variables (defined in the vars parameter).  <br /></td></tr>
<tr class="memitem:a76c0540f162fbd313399d54bb53e0113" id="r_a76c0540f162fbd313399d54bb53e0113"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76c0540f162fbd313399d54bb53e0113">AddPolynomialConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="namespacedrake.html#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a> &gt; &gt; &amp;polynomials, const std::vector&lt; <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">Polynomiald::VarType</a> &gt; &amp;poly_vars, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;ub, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a76c0540f162fbd313399d54bb53e0113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a polynomial constraint to the program referencing a subset of the decision variables (defined in the vars parameter).  <br /></td></tr>
<tr class="memitem:a7eaff79975646e0a4381f073a47c9974" id="r_a7eaff79975646e0a4381f073a47c9974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7eaff79975646e0a4381f073a47c9974">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a7eaff79975646e0a4381f073a47c9974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a positive semidefinite constraint on a symmetric matrix.  <br /></td></tr>
<tr class="memitem:a173507cceb8d15aa267a7dbb17466e7f" id="r_a173507cceb8d15aa267a7dbb17466e7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a173507cceb8d15aa267a7dbb17466e7f">AddConstraint</a> (std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; con, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt; &amp;symmetric_matrix_var)</td></tr>
<tr class="memdesc:a173507cceb8d15aa267a7dbb17466e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a positive semidefinite constraint on a symmetric matrix.  <br /></td></tr>
<tr class="memitem:a1eede327356f097ffbe492929b4effb7" id="r_a1eede327356f097ffbe492929b4effb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1eede327356f097ffbe492929b4effb7">AddPositiveSemidefiniteConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt; &amp;symmetric_matrix_var)</td></tr>
<tr class="memdesc:a1eede327356f097ffbe492929b4effb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a positive semidefinite constraint on a symmetric matrix.  <br /></td></tr>
<tr class="memitem:a3047d3c8592ca29f32d1ecf95d7afb50" id="r_a3047d3c8592ca29f32d1ecf95d7afb50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3047d3c8592ca29f32d1ecf95d7afb50">AddPositiveSemidefiniteConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;e)</td></tr>
<tr class="memdesc:a3047d3c8592ca29f32d1ecf95d7afb50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a positive semidefinite constraint on a symmetric matrix of symbolic expressions <code class="param">e</code>.  <br /></td></tr>
<tr class="memitem:a66308f4f93d121883f3223d204157317" id="r_a66308f4f93d121883f3223d204157317"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66308f4f93d121883f3223d204157317">AddPrincipalSubmatrixIsPsdConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt; &amp;symmetric_matrix_var, const std::set&lt; int &gt; &amp;minor_indices)</td></tr>
<tr class="memdesc:a66308f4f93d121883f3223d204157317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constraint that the principal submatrix of a symmetric matrix composed of the indices in minor_indices is positive semidefinite.  <br /></td></tr>
<tr class="memitem:a9e2bd03ae4dbcbe7f1ffa494b1d544bf" id="r_a9e2bd03ae4dbcbe7f1ffa494b1d544bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e2bd03ae4dbcbe7f1ffa494b1d544bf">AddPrincipalSubmatrixIsPsdConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;e, const std::set&lt; int &gt; &amp;minor_indices)</td></tr>
<tr class="memdesc:a9e2bd03ae4dbcbe7f1ffa494b1d544bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constraint the that the principal submatrix of a symmetric matrix of expressions composed of the indices in minor_indices is positive semidefinite.  <br /></td></tr>
<tr class="memitem:a8b781bb7ad3b694a9d9fcbf636235469" id="r_a8b781bb7ad3b694a9d9fcbf636235469"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b781bb7ad3b694a9d9fcbf636235469">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a8b781bb7ad3b694a9d9fcbf636235469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear matrix inequality constraint to the program.  <br /></td></tr>
<tr class="memitem:a2c01095865c3167e561093efa629b9cc" id="r_a2c01095865c3167e561093efa629b9cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c01095865c3167e561093efa629b9cc">AddLinearMatrixInequalityConstraint</a> (std::vector&lt; Eigen::MatrixXd &gt; F, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a2c01095865c3167e561093efa629b9cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear matrix inequality constraint to the program.  <br /></td></tr>
<tr class="memitem:a7efb262a19eb2917e4081a602ccc935b" id="r_a7efb262a19eb2917e4081a602ccc935b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7efb262a19eb2917e4081a602ccc935b">AddLinearMatrixInequalityConstraint</a> (std::vector&lt; Eigen::MatrixXd &gt; F, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a7efb262a19eb2917e4081a602ccc935b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear matrix inequality constraint to the program.  <br /></td></tr>
<tr class="memitem:ad4ef453a8a303d9d6f690017dbce1e28" id="r_ad4ef453a8a303d9d6f690017dbce1e28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4ef453a8a303d9d6f690017dbce1e28">AddLinearMatrixInequalityConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;X)</td></tr>
<tr class="memdesc:ad4ef453a8a303d9d6f690017dbce1e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear matrix inequality constraint on a symmetric matrix of symbolic expressions <span class="tt">X</span>, namely <span class="tt">X</span> is positive semidefinite, and each entry in <span class="tt">X</span> is a linear (affine) expression of decision variables.  <br /></td></tr>
<tr class="memitem:a3c351e546e7b6b97a3104b63d5fabe5d" id="r_a3c351e546e7b6b97a3104b63d5fabe5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c351e546e7b6b97a3104b63d5fabe5d">AddPositiveDiagonallyDominantMatrixConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;X)</td></tr>
<tr class="memdesc:a3c351e546e7b6b97a3104b63d5fabe5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the constraint that a symmetric matrix is diagonally dominant with non-negative diagonal entries.  <br /></td></tr>
<tr class="memitem:a127b9473329959a4877fe54abb53ff4e" id="r_a127b9473329959a4877fe54abb53ff4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a127b9473329959a4877fe54abb53ff4e">TightenPsdConstraintToDd</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; &amp;constraint)</td></tr>
<tr id="pub-methods-3" class="groupHeader"><td colspan="2"><div class="groupHeader">Diagonally dominant dual cone constraint</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="add_dd_dual"></a> Adds the constraint that a symmetric matrix is in the dual cone of the diagonally dominant matrices which is denoted DD*.</p>
<p>This set is a polyhedral (linear) outer approximation to the PSD cone. This follows from the fact that since DD ⊆ PSD, then PSD* ⊆ DD*, and since PSD is self-dual, we have that PSD = PSD* and so DD ⊆ PSD = PSD* ⊆ DD*.</p>
<p>A symmetric matrix X is in DD* if and only if vᵢᵀXvᵢ ≥ 0 for all vᵢ, where vᵢ is a non-zero vector with at most two entries set to ±1 and all other entries set to 0. There are 4 * (n choose 2) + 2 * n of these vectors, but notice that vᵢᵀXvᵢ = (-vᵢ)ᵀX(vᵢ) and so we only need to add all choices with different partities of which there are 2 * (n choose 2) + n = n². Therefore, if X is a matrix of size n x n, this function adds exactly n² linear constraints.</p>
<p>This is a consequence of the characterization of DD given in "Cones
of diagonally dominant matrices" by Barker and Carlson which can be found at <a href="https://msp.org/pjm/1975/57-1/p03.xhtml">https://msp.org/pjm/1975/57-1/p03.xhtml</a>. </p>
</div></td></tr>
<tr class="memitem:aa6b346ec7d733e7f9f7eb09284675268" id="r_aa6b346ec7d733e7f9f7eb09284675268"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6b346ec7d733e7f9f7eb09284675268">AddPositiveDiagonallyDominantDualConeMatrixConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;X)</td></tr>
<tr class="memdesc:aa6b346ec7d733e7f9f7eb09284675268"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded variant of <a class="el" href="#add_dd_dual">diagonally dominant dual cone constraint</a>.  <br /></td></tr>
<tr class="memitem:a207e587812840e9c4675294dccdd64e5" id="r_a207e587812840e9c4675294dccdd64e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a207e587812840e9c4675294dccdd64e5">AddPositiveDiagonallyDominantDualConeMatrixConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &amp;X)</td></tr>
<tr class="memdesc:a207e587812840e9c4675294dccdd64e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded variant of <a class="el" href="#add_dd_dual">diagonally dominant dual cone constraint</a>.  <br /></td></tr>
<tr class="memitem:ad72afe48df383e9d91358cc30567d24b" id="r_ad72afe48df383e9d91358cc30567d24b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad72afe48df383e9d91358cc30567d24b">RelaxPsdConstraintToDdDualCone</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; &amp;constraint)</td></tr>
<tr id="pub-methods-4" class="groupHeader"><td colspan="2"><div class="groupHeader">Scaled diagonally dominant matrix constraint</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="addsdd"></a> Adds the constraint that a symmetric matrix is scaled diagonally dominant (sdd).</p>
<p>A matrix X is sdd if there exists a diagonal matrix D, such that the product DXD is diagonally dominant with non-negative diagonal entries, namely d(i)X(i, i) ≥ ∑ⱼ |d(j)X(i, j)| ∀ j ≠ i where d(i) = D(i, i). X being sdd is equivalent to the existence of symmetric matrices Mⁱʲ∈ ℝⁿˣⁿ, i &lt; j, such that all entries in Mⁱʲ are 0, except Mⁱʲ(i, i), Mⁱʲ(i, j), Mⁱʲ(j, j). (Mⁱʲ(i, i), Mⁱʲ(j, j), Mⁱʲ(i, j)) is in the rotated Lorentz cone, and X = ∑ᵢⱼ Mⁱʲ.</p>
<p>The users can refer to "DSOS and SDSOS Optimization: More Tractable
Alternatives to Sum of Squares and Semidefinite Optimization" by Amir Ali Ahmadi and Anirudha Majumdar, with arXiv link <a href="https://arxiv.org/abs/1706.02586">https://arxiv.org/abs/1706.02586</a>. </p>
</div></td></tr>
<tr class="memitem:a01bd838750215d63ccc036a735c16597" id="r_a01bd838750215d63ccc036a735c16597"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="namespacedrake.html#a06406a5da633da84f911e2979aa48549">Matrix2</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01bd838750215d63ccc036a735c16597">AddScaledDiagonallyDominantMatrixConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;X)</td></tr>
<tr class="memdesc:a01bd838750215d63ccc036a735c16597"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded variant of <a class="el" href="#addsdd">scaled diagonally dominant matrix constraint</a>.  <br /></td></tr>
<tr class="memitem:acc67889da0ef9d366028204d1c6700f0" id="r_acc67889da0ef9d366028204d1c6700f0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="namespacedrake.html#a06406a5da633da84f911e2979aa48549">Matrix2</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc67889da0ef9d366028204d1c6700f0">AddScaledDiagonallyDominantMatrixConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &amp;X)</td></tr>
<tr class="memdesc:acc67889da0ef9d366028204d1c6700f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded variant of <a class="el" href="#addsdd">scaled diagonally dominant matrix constraint</a>.  <br /></td></tr>
<tr class="memitem:a013ab93a09dbb352bf98f8602c75439e" id="r_a013ab93a09dbb352bf98f8602c75439e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="namespacedrake.html#a06406a5da633da84f911e2979aa48549">Matrix2</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a013ab93a09dbb352bf98f8602c75439e">TightenPsdConstraintToSdd</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; &amp;constraint)</td></tr>
<tr id="pub-methods-5" class="groupHeader"><td colspan="2"><div class="groupHeader">Scaled diagonally dominant dual cone constraint</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="add_sdd_dual"></a> Adds the constraint that a symmetric matrix is in the dual cone of the scaled diagonally dominant matrices which is denoted SDD*.</p>
<p>The set SDD* is an SOCP outer approximation to the PSD cone that is tighter than DD*. This follows from the fact that DD ⊆ SDD ⊆ PSD = PSD* ⊆ SDD* ⊆ DD*.</p>
<p>A symmetric matrix X is in SDD* if and only if all 2 x 2 principal minors of X are psd. This can be encoded by ensuring that VᵢⱼᵀXVᵢⱼ is psd for all Vᵢⱼ, where Vᵢⱼ is the n x 2 matrix such that Vᵢⱼ(i, 0) = 1, V(j, 1) = 1, namely Vᵢⱼ = [eᵢ eⱼ]. This can be encoded using 1/2 * n * (n-1) RotatedLorentzCone constraints which we return in this function.</p>
<p>This can be seen by noting that VᵢⱼᵀXVᵢⱼ = ⌈ Xᵢᵢ Xᵢⱼ⌉ ⌊ Xⱼᵢ Xⱼⱼ⌋ is psd if and only if VⱼᵢᵀXVⱼᵢ as they are simply permutations of each other. Therefore, it suffices to only add the constraint for i ≥ j. Moreover, notice that VᵢᵢᵀXVᵢᵢ = ⌈ Xᵢᵢ 0⌉ ⌊ 0 0⌋ is psd if and only if Xᵢᵢ ≥ 0. This linear constraint is already implied by VᵢⱼᵀXVᵢⱼ is psd for every i ≠ j and so is redundant. Therefore, we only add RotatedLorentzConeConstraints for i &gt; j.</p>
<p>This characterization can be found in Section 3.3 of "Sum of Squares Basis
Pursuit with Linear and Second Order Cone Programming" by Ahmadi and Hall with arXiv link <a href="https://arxiv.org/abs/1510.01597">https://arxiv.org/abs/1510.01597</a> </p>
</div></td></tr>
<tr class="memitem:a1c8ce474c9ebb28fceb18705363d0ea9" id="r_a1c8ce474c9ebb28fceb18705363d0ea9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c8ce474c9ebb28fceb18705363d0ea9">AddScaledDiagonallyDominantDualConeMatrixConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;X)</td></tr>
<tr class="memdesc:a1c8ce474c9ebb28fceb18705363d0ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded variant of <a class="el" href="#add_sdd_dual">scaled diagonally dominant dual cone constraint</a>.  <br /></td></tr>
<tr class="memitem:a302b82c829349d67f3dddbc2b130c6e4" id="r_a302b82c829349d67f3dddbc2b130c6e4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a302b82c829349d67f3dddbc2b130c6e4">AddScaledDiagonallyDominantDualConeMatrixConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &amp;X)</td></tr>
<tr class="memdesc:a302b82c829349d67f3dddbc2b130c6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded variant of <a class="el" href="#add_sdd_dual">scaled diagonally dominant dual cone constraint</a>.  <br /></td></tr>
<tr class="memitem:a0c1a80d727e311f0d6f1a08edaa7f345" id="r_a0c1a80d727e311f0d6f1a08edaa7f345"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c1a80d727e311f0d6f1a08edaa7f345">RelaxPsdConstraintToSddDualCone</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; &amp;constraint)</td></tr>
<tr class="memitem:a146a2371a36f2dfadca6f468ba8b9126" id="r_a146a2371a36f2dfadca6f468ba8b9126"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a146a2371a36f2dfadca6f468ba8b9126">AddSosConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;p, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt; &gt; &amp;monomial_basis, <a class="el" href="#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> type=<a class="el" href="#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a>, const std::string &amp;gram_name=&quot;S&quot;)</td></tr>
<tr class="memdesc:a146a2371a36f2dfadca6f468ba8b9126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints that a given polynomial <code class="param">p</code> is a sums-of-squares (SOS), that is, <code class="param">p</code> can be decomposed into <span class="tt">mᵀQm</span>, where m is the <code class="param">monomial_basis</code>.  <br /></td></tr>
<tr class="memitem:a8248c9042b0947f8cb3242ca9b660200" id="r_a8248c9042b0947f8cb3242ca9b660200"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8248c9042b0947f8cb3242ca9b660200">AddSosConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;p, <a class="el" href="#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> type=<a class="el" href="#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a>, const std::string &amp;gram_name=&quot;S&quot;)</td></tr>
<tr class="memdesc:a8248c9042b0947f8cb3242ca9b660200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints that a given polynomial <code class="param">p</code> is a sums-of-squares (SOS), that is, <code class="param">p</code> can be decomposed into <span class="tt">mᵀQm</span>, where m is a monomial basis selected from the sparsity of <code class="param">p</code>.  <br /></td></tr>
<tr class="memitem:a1c068098fdd6c3d108ee92379d142232" id="r_a1c068098fdd6c3d108ee92379d142232"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c068098fdd6c3d108ee92379d142232">AddSosConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt; &gt; &amp;monomial_basis, <a class="el" href="#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> type=<a class="el" href="#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a>, const std::string &amp;gram_name=&quot;S&quot;)</td></tr>
<tr class="memdesc:a1c068098fdd6c3d108ee92379d142232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints that a given symbolic expression <code class="param">e</code> is a sums-of-squares (SOS), that is, <code class="param">p</code> can be decomposed into <span class="tt">mᵀQm</span>, where m is the <code class="param">monomial_basis</code>.  <br /></td></tr>
<tr class="memitem:a9e25ab3abb079aba95933bbe93fc84fd" id="r_a9e25ab3abb079aba95933bbe93fc84fd"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e25ab3abb079aba95933bbe93fc84fd">AddSosConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, <a class="el" href="#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> type=<a class="el" href="#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a>, const std::string &amp;gram_name=&quot;S&quot;)</td></tr>
<tr class="memdesc:a9e25ab3abb079aba95933bbe93fc84fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints that a given symbolic expression <code class="param">e</code> is a sums-of-squares (SOS), that is, <code class="param">e</code> can be decomposed into <span class="tt">mᵀQm</span>.  <br /></td></tr>
<tr class="memitem:aab52b4d6027e7d8a8fe8c1d6e8f0817b" id="r_aab52b4d6027e7d8a8fe8c1d6e8f0817b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab52b4d6027e7d8a8fe8c1d6e8f0817b">AddEqualityConstraintBetweenPolynomials</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;p1, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;p2)</td></tr>
<tr class="memdesc:aab52b4d6027e7d8a8fe8c1d6e8f0817b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraining that two polynomials are the same (i.e., they have the same coefficients for each monomial).  <br /></td></tr>
<tr class="memitem:a7a9ab8d22c4fbaa231c6864a711212de" id="r_a7a9ab8d22c4fbaa231c6864a711212de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html">ExponentialConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a9ab8d22c4fbaa231c6864a711212de">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html">ExponentialConeConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a7a9ab8d22c4fbaa231c6864a711212de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the exponential cone constraint that z = binding.evaluator()-&gt;A() * binding.variables() + binding.evaluator()-&gt;b() should be in the exponential cone.  <br /></td></tr>
<tr class="memitem:aa3139dbcbdf76b2b036f38aaa11a01f2" id="r_aa3139dbcbdf76b2b036f38aaa11a01f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html">ExponentialConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3139dbcbdf76b2b036f38aaa11a01f2">AddExponentialConeConstraint</a> (const Eigen::Ref&lt; const Eigen::SparseMatrix&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;A, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:aa3139dbcbdf76b2b036f38aaa11a01f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an exponential cone constraint, that z = A * vars + b should be in the exponential cone.  <br /></td></tr>
<tr class="memitem:acc55d94a5a55f8e03d0797c6f9d98e11" id="r_acc55d94a5a55f8e03d0797c6f9d98e11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html">ExponentialConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc55d94a5a55f8e03d0797c6f9d98e11">AddExponentialConeConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;z)</td></tr>
<tr class="memdesc:acc55d94a5a55f8e03d0797c6f9d98e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the constraint that z is in the exponential cone.  <br /></td></tr>
<tr class="memitem:aa44e07a559ca22d055de33fa1154c095" id="r_aa44e07a559ca22d055de33fa1154c095"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa44e07a559ca22d055de33fa1154c095">GetInitialGuess</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;<a class="el" href="#ab9468b404ae211e3deaa2e41237ee008">decision_variable</a>) const</td></tr>
<tr class="memdesc:aa44e07a559ca22d055de33fa1154c095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the initial guess for a single variable.  <br /></td></tr>
<tr class="memitem:ad8f92f6f44a275134898901185826bc2" id="r_ad8f92f6f44a275134898901185826bc2"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:ad8f92f6f44a275134898901185826bc2 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, <a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; <a class="el" href="classdouble.html">double</a>, Derived &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8f92f6f44a275134898901185826bc2">GetInitialGuess</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;decision_variable_mat) const</td></tr>
<tr class="memdesc:ad8f92f6f44a275134898901185826bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the initial guess for some variables.  <br /></td></tr>
<tr class="memitem:ae48cb6d2263ccf09e38932dcd27f769f" id="r_ae48cb6d2263ccf09e38932dcd27f769f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae48cb6d2263ccf09e38932dcd27f769f">SetInitialGuess</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;<a class="el" href="#ab9468b404ae211e3deaa2e41237ee008">decision_variable</a>, <a class="el" href="classdouble.html">double</a> variable_guess_value)</td></tr>
<tr class="memdesc:ae48cb6d2263ccf09e38932dcd27f769f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the initial guess for a single variable <code class="param">decision_variable</code>.  <br /></td></tr>
<tr class="memitem:a6eca61aa09da31d13c9d476cf1b6b760" id="r_a6eca61aa09da31d13c9d476cf1b6b760"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a6eca61aa09da31d13c9d476cf1b6b760 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6eca61aa09da31d13c9d476cf1b6b760">SetInitialGuess</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;decision_variable_mat, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;x0)</td></tr>
<tr class="memdesc:a6eca61aa09da31d13c9d476cf1b6b760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the initial guess for the decision variables stored in <code class="param">decision_variable_mat</code> to be <code class="param">x0</code>.  <br /></td></tr>
<tr class="memitem:ae35679ed5aabea90fcf4ff3b337b44f5" id="r_ae35679ed5aabea90fcf4ff3b337b44f5"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:ae35679ed5aabea90fcf4ff3b337b44f5 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae35679ed5aabea90fcf4ff3b337b44f5">SetInitialGuessForAllVariables</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;x0)</td></tr>
<tr class="memdesc:ae35679ed5aabea90fcf4ff3b337b44f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the initial guess for ALL decision variables.  <br /></td></tr>
<tr class="memitem:a65ab51bbb7a7abab25cb23d0f64d80d4" id="r_a65ab51bbb7a7abab25cb23d0f64d80d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65ab51bbb7a7abab25cb23d0f64d80d4">SetDecisionVariableValueInVector</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;<a class="el" href="#ab9468b404ae211e3deaa2e41237ee008">decision_variable</a>, <a class="el" href="classdouble.html">double</a> decision_variable_new_value, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::VectorXd &gt; values) const</td></tr>
<tr class="memdesc:a65ab51bbb7a7abab25cb23d0f64d80d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the value of a single <code class="param">decision_variable</code> inside the <code class="param">values</code> vector to be <code class="param">decision_variable_new_value</code>.  <br /></td></tr>
<tr class="memitem:afff086e342ead2410215c884dfd4e82d" id="r_afff086e342ead2410215c884dfd4e82d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afff086e342ead2410215c884dfd4e82d">SetDecisionVariableValueInVector</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt; &amp;<a class="el" href="#a8edf415633915556308470787995a6a0">decision_variables</a>, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;decision_variables_new_values, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::VectorXd &gt; values) const</td></tr>
<tr class="memdesc:afff086e342ead2410215c884dfd4e82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the values of some <code class="param">decision_variables</code> inside the <code class="param">values</code> vector to be <code class="param">decision_variables_new_values</code>.  <br /></td></tr>
<tr id="pub-methods-6" class="groupHeader"><td colspan="2"><div class="groupHeader">Set solver options</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="set_solver_option"></a> Set the options (parameters) for a specific solver.</p>
<p>Refer to <a class="el" href="structdrake_1_1solvers_1_1_solver_options.html" title="Stores options for multiple solvers.">SolverOptions</a> class for more details on the supported options of each solver. </p>
</div></td></tr>
<tr class="memitem:a77b58f1d09a3aec5918813ba163c1098" id="r_a77b58f1d09a3aec5918813ba163c1098"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77b58f1d09a3aec5918813ba163c1098">SetSolverOption</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;solver_id, const std::string &amp;solver_option, <a class="el" href="classdouble.html">double</a> option_value)</td></tr>
<tr class="memdesc:a77b58f1d09a3aec5918813ba163c1098"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="#set_solver_option">set_solver_option</a> for more details.  <br /></td></tr>
<tr class="memitem:a3aafa15b34bc04d8a3449f39787bc76e" id="r_a3aafa15b34bc04d8a3449f39787bc76e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3aafa15b34bc04d8a3449f39787bc76e">SetSolverOption</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;solver_id, const std::string &amp;solver_option, int option_value)</td></tr>
<tr class="memdesc:a3aafa15b34bc04d8a3449f39787bc76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="#set_solver_option">set_solver_option</a> for more details.  <br /></td></tr>
<tr class="memitem:a00b38acbaeb959344b7ef04e84f4c40c" id="r_a00b38acbaeb959344b7ef04e84f4c40c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00b38acbaeb959344b7ef04e84f4c40c">SetSolverOption</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;solver_id, const std::string &amp;solver_option, const std::string &amp;option_value)</td></tr>
<tr class="memdesc:a00b38acbaeb959344b7ef04e84f4c40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="#set_solver_option">set_solver_option</a> for more details.  <br /></td></tr>
<tr class="memitem:aed5ce186e378a8fbf9f0924b2e55994c" id="r_aed5ce186e378a8fbf9f0924b2e55994c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed5ce186e378a8fbf9f0924b2e55994c">SetSolverOptions</a> (const <a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &amp;<a class="el" href="#a083a1822093d823535a137992cee02c5">solver_options</a>)</td></tr>
<tr class="memdesc:aed5ce186e378a8fbf9f0924b2e55994c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite the stored solver options inside <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> with the provided solver options.  <br /></td></tr>
<tr class="memitem:a083a1822093d823535a137992cee02c5" id="r_a083a1822093d823535a137992cee02c5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a083a1822093d823535a137992cee02c5">solver_options</a> () const</td></tr>
<tr class="memdesc:a083a1822093d823535a137992cee02c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solver options stored inside <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <br /></td></tr>
<tr class="memitem:aea7d6e95dffa0b91fc280b86d2f430ae" id="r_aea7d6e95dffa0b91fc280b86d2f430ae"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html">VisualizationCallback</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea7d6e95dffa0b91fc280b86d2f430ae">visualization_callbacks</a> () const</td></tr>
<tr class="memdesc:aea7d6e95dffa0b91fc280b86d2f430ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for all callbacks.  <br /></td></tr>
<tr class="memitem:a36eaddbb4413ded70478606a4fe2d6cd" id="r_a36eaddbb4413ded70478606a4fe2d6cd"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36eaddbb4413ded70478606a4fe2d6cd">generic_costs</a> () const</td></tr>
<tr class="memdesc:a36eaddbb4413ded70478606a4fe2d6cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for all generic costs.  <br /></td></tr>
<tr class="memitem:a2efda53892ab1e6656e485cfecc3f9dc" id="r_a2efda53892ab1e6656e485cfecc3f9dc"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2efda53892ab1e6656e485cfecc3f9dc">generic_constraints</a> () const</td></tr>
<tr class="memdesc:a2efda53892ab1e6656e485cfecc3f9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for all generic constraints.  <br /></td></tr>
<tr class="memitem:a1047c3ed6cd2d49362c46ec044a6cf15" id="r_a1047c3ed6cd2d49362c46ec044a6cf15"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1047c3ed6cd2d49362c46ec044a6cf15">linear_equality_constraints</a> () const</td></tr>
<tr class="memdesc:a1047c3ed6cd2d49362c46ec044a6cf15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for linear equality constraints.  <br /></td></tr>
<tr class="memitem:a087b0d624bd07fa5c19e989fabb4b99d" id="r_a087b0d624bd07fa5c19e989fabb4b99d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a087b0d624bd07fa5c19e989fabb4b99d">linear_costs</a> () const</td></tr>
<tr class="memdesc:a087b0d624bd07fa5c19e989fabb4b99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for linear costs.  <br /></td></tr>
<tr class="memitem:ae5d8798432ed63b84b5ed9f14052cb65" id="r_ae5d8798432ed63b84b5ed9f14052cb65"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5d8798432ed63b84b5ed9f14052cb65">quadratic_costs</a> () const</td></tr>
<tr class="memdesc:ae5d8798432ed63b84b5ed9f14052cb65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for quadratic costs.  <br /></td></tr>
<tr class="memitem:a53b2bd4981be384bbafe8061fe3ca91c" id="r_a53b2bd4981be384bbafe8061fe3ca91c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53b2bd4981be384bbafe8061fe3ca91c">l2norm_costs</a> () const</td></tr>
<tr class="memdesc:a53b2bd4981be384bbafe8061fe3ca91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for l2norm costs.  <br /></td></tr>
<tr class="memitem:a47db746f450147854f745ce5d7c339bf" id="r_a47db746f450147854f745ce5d7c339bf"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47db746f450147854f745ce5d7c339bf">linear_constraints</a> () const</td></tr>
<tr class="memdesc:a47db746f450147854f745ce5d7c339bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for linear <em>inequality</em> constraints.  <br /></td></tr>
<tr class="memitem:a651c724635f0f4ae4e38830d4ff68537" id="r_a651c724635f0f4ae4e38830d4ff68537"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_constraint.html">QuadraticConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a651c724635f0f4ae4e38830d4ff68537">quadratic_constraints</a> () const</td></tr>
<tr class="memdesc:a651c724635f0f4ae4e38830d4ff68537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for quadratic constraints.  <br /></td></tr>
<tr class="memitem:a69e353dc288cf713625fde3378489ec0" id="r_a69e353dc288cf713625fde3378489ec0"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69e353dc288cf713625fde3378489ec0">lorentz_cone_constraints</a> () const</td></tr>
<tr class="memdesc:a69e353dc288cf713625fde3378489ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for Lorentz cone constraints.  <br /></td></tr>
<tr class="memitem:a9f19b917654b3dfd4d2a2a08ef296e1e" id="r_a9f19b917654b3dfd4d2a2a08ef296e1e"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f19b917654b3dfd4d2a2a08ef296e1e">rotated_lorentz_cone_constraints</a> () const</td></tr>
<tr class="memdesc:a9f19b917654b3dfd4d2a2a08ef296e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for rotated Lorentz cone constraints.  <br /></td></tr>
<tr class="memitem:a9cc8ec6b6a2747fb3eb73eb68e4e4095" id="r_a9cc8ec6b6a2747fb3eb73eb68e4e4095"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cc8ec6b6a2747fb3eb73eb68e4e4095">positive_semidefinite_constraints</a> () const</td></tr>
<tr class="memdesc:a9cc8ec6b6a2747fb3eb73eb68e4e4095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for positive semidefinite constraints.  <br /></td></tr>
<tr class="memitem:a877439eadc9880f433af13f5f3b6eeac" id="r_a877439eadc9880f433af13f5f3b6eeac"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a877439eadc9880f433af13f5f3b6eeac">linear_matrix_inequality_constraints</a> () const</td></tr>
<tr class="memdesc:a877439eadc9880f433af13f5f3b6eeac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for linear matrix inequality constraints.  <br /></td></tr>
<tr class="memitem:aa6354d6ed7478305a208d001354ce0b7" id="r_aa6354d6ed7478305a208d001354ce0b7"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html">ExponentialConeConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6354d6ed7478305a208d001354ce0b7">exponential_cone_constraints</a> () const</td></tr>
<tr class="memdesc:aa6354d6ed7478305a208d001354ce0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for exponential cone constraints.  <br /></td></tr>
<tr class="memitem:abbf73d7148b272c9980e85f4ebffe109" id="r_abbf73d7148b272c9980e85f4ebffe109"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbf73d7148b272c9980e85f4ebffe109">bounding_box_constraints</a> () const</td></tr>
<tr class="memdesc:abbf73d7148b272c9980e85f4ebffe109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for all bounding box constraints.  <br /></td></tr>
<tr class="memitem:a45bb14b07171be6da1b721bd57086520" id="r_a45bb14b07171be6da1b721bd57086520"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45bb14b07171be6da1b721bd57086520">linear_complementarity_constraints</a> () const</td></tr>
<tr class="memdesc:a45bb14b07171be6da1b721bd57086520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for all linear complementarity constraints.  <br /></td></tr>
<tr class="memitem:affd2ba88c2d87f03bb94729e114c8ee7" id="r_affd2ba88c2d87f03bb94729e114c8ee7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affd2ba88c2d87f03bb94729e114c8ee7">GetAllCosts</a> () const</td></tr>
<tr class="memdesc:affd2ba88c2d87f03bb94729e114c8ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter returning all costs.  <br /></td></tr>
<tr class="memitem:a508ba9c7debb1c02bc558f636861f016" id="r_a508ba9c7debb1c02bc558f636861f016"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a508ba9c7debb1c02bc558f636861f016">GetAllLinearConstraints</a> () const</td></tr>
<tr class="memdesc:a508ba9c7debb1c02bc558f636861f016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter returning all linear constraints (both linear equality and inequality constraints).  <br /></td></tr>
<tr class="memitem:ab1d6394dcd0825c2be850e170879e0a0" id="r_ab1d6394dcd0825c2be850e170879e0a0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1d6394dcd0825c2be850e170879e0a0">GetAllConstraints</a> () const</td></tr>
<tr class="memdesc:ab1d6394dcd0825c2be850e170879e0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for returning all constraints.  <br /></td></tr>
<tr class="memitem:a224e4c35014e87139f73f9a517866796" id="r_a224e4c35014e87139f73f9a517866796"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a224e4c35014e87139f73f9a517866796">num_vars</a> () const</td></tr>
<tr class="memdesc:a224e4c35014e87139f73f9a517866796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for number of variables in the optimization program.  <br /></td></tr>
<tr class="memitem:a3b1e942fc28f03d2b987fc0ea880e831" id="r_a3b1e942fc28f03d2b987fc0ea880e831"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b1e942fc28f03d2b987fc0ea880e831">num_indeterminates</a> () const</td></tr>
<tr class="memdesc:a3b1e942fc28f03d2b987fc0ea880e831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of indeterminates in the optimization program.  <br /></td></tr>
<tr class="memitem:a3b1cc95b2fb414c59fc25d233731fc42" id="r_a3b1cc95b2fb414c59fc25d233731fc42"><td class="memItemLeft" align="right" valign="top">const Eigen::VectorXd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b1cc95b2fb414c59fc25d233731fc42">initial_guess</a> () const</td></tr>
<tr class="memdesc:a3b1cc95b2fb414c59fc25d233731fc42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the initial guess.  <br /></td></tr>
<tr class="memitem:a2f25e54555621691b390c1658e21872f" id="r_a2f25e54555621691b390c1658e21872f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f25e54555621691b390c1658e21872f">FindDecisionVariableIndex</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;var) const</td></tr>
<tr class="memdesc:a2f25e54555621691b390c1658e21872f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the decision variable.  <br /></td></tr>
<tr class="memitem:a5aa2cdf4c8e6fae22b6b78718aeb0db0" id="r_a5aa2cdf4c8e6fae22b6b78718aeb0db0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5aa2cdf4c8e6fae22b6b78718aeb0db0">FindDecisionVariableIndices</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars) const</td></tr>
<tr class="memitem:a1470ed93553619a1f630bc8035947556" id="r_a1470ed93553619a1f630bc8035947556"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsize__t.html">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1470ed93553619a1f630bc8035947556">FindIndeterminateIndex</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;var) const</td></tr>
<tr class="memdesc:a1470ed93553619a1f630bc8035947556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the indeterminate.  <br /></td></tr>
<tr class="memitem:a4f857d6d118f26c7061861277139bda0" id="r_a4f857d6d118f26c7061861277139bda0"><td class="memTemplParams" colspan="2">template&lt;typename C, typename DerivedX&gt; </td></tr>
<tr class="memitem:a4f857d6d118f26c7061861277139bda0 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt; DerivedX &gt;::value, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; typename DerivedX::Scalar &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f857d6d118f26c7061861277139bda0">EvalBinding</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;binding, const Eigen::MatrixBase&lt; DerivedX &gt; &amp;prog_var_vals) const</td></tr>
<tr class="memdesc:a4f857d6d118f26c7061861277139bda0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the value of some binding, for some input value for all decision variables.  <br /></td></tr>
<tr class="memitem:ad62767f38872e337ed2356a3e162824d" id="r_ad62767f38872e337ed2356a3e162824d"><td class="memTemplParams" colspan="2">template&lt;typename C, typename DerivedX&gt; </td></tr>
<tr class="memitem:ad62767f38872e337ed2356a3e162824d template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt; DerivedX &gt;::value, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; typename DerivedX::Scalar &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad62767f38872e337ed2356a3e162824d">EvalBindings</a> (const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &gt; &amp;bindings, const Eigen::MatrixBase&lt; DerivedX &gt; &amp;prog_var_vals) const</td></tr>
<tr class="memdesc:ad62767f38872e337ed2356a3e162824d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a set of bindings (plural version of <span class="tt"><a class="el" href="#a4f857d6d118f26c7061861277139bda0" title="Evaluates the value of some binding, for some input value for all decision variables.">EvalBinding</a></span>).  <br /></td></tr>
<tr class="memitem:a608b6bbb4a0d0a4d00686ffdaba8923c" id="r_a608b6bbb4a0d0a4d00686ffdaba8923c"><td class="memTemplParams" colspan="2">template&lt;typename C, typename DerivedX&gt; </td></tr>
<tr class="memitem:a608b6bbb4a0d0a4d00686ffdaba8923c template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt; DerivedX &gt;::value, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; typename DerivedX::Scalar &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a608b6bbb4a0d0a4d00686ffdaba8923c">GetBindingVariableValues</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;binding, const Eigen::MatrixBase&lt; DerivedX &gt; &amp;prog_var_vals) const</td></tr>
<tr class="memdesc:a608b6bbb4a0d0a4d00686ffdaba8923c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the value of all decision variables, namely this.decision_variable(i) takes the value prog_var_vals(i), returns the vector that contains the value of the variables in binding.variables().  <br /></td></tr>
<tr class="memitem:a856ded9f90eaac91a1c66f2c139566b5" id="r_a856ded9f90eaac91a1c66f2c139566b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a856ded9f90eaac91a1c66f2c139566b5">EvalVisualizationCallbacks</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;prog_var_vals) const</td></tr>
<tr class="memdesc:a856ded9f90eaac91a1c66f2c139566b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates all visualization callbacks registered with the <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <br /></td></tr>
<tr class="memitem:a0eb46a0ff11d6f6d22d69d9c16bfce94" id="r_a0eb46a0ff11d6f6d22d69d9c16bfce94"><td class="memTemplParams" colspan="2">template&lt;typename C&gt; </td></tr>
<tr class="memitem:a0eb46a0ff11d6f6d22d69d9c16bfce94 template"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0eb46a0ff11d6f6d22d69d9c16bfce94">EvalBindingAtInitialGuess</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;binding) const</td></tr>
<tr class="memdesc:a0eb46a0ff11d6f6d22d69d9c16bfce94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the evaluator in <code class="param">binding</code> at the initial guess.  <br /></td></tr>
<tr class="memitem:a92eb16be90ba1765547a715ec244fe00" id="r_a92eb16be90ba1765547a715ec244fe00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92eb16be90ba1765547a715ec244fe00">CheckSatisfied</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &amp;binding, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;prog_var_vals, <a class="el" href="classdouble.html">double</a> tol=1e-6) const</td></tr>
<tr class="memdesc:a92eb16be90ba1765547a715ec244fe00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates CheckSatisfied for the constraint in <code class="param">binding</code> using the value of ALL of the decision variables in this program.  <br /></td></tr>
<tr class="memitem:ab7e684c1e5663a881e40cd35e3c66ae8" id="r_ab7e684c1e5663a881e40cd35e3c66ae8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7e684c1e5663a881e40cd35e3c66ae8">CheckSatisfied</a> (const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &gt; &amp;bindings, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;prog_var_vals, <a class="el" href="classdouble.html">double</a> tol=1e-6) const</td></tr>
<tr class="memdesc:ab7e684c1e5663a881e40cd35e3c66ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates CheckSatisfied for the all of the constraints in <code class="param">binding</code> using the value of ALL of the decision variables in this program.  <br /></td></tr>
<tr class="memitem:a40e98056457ab5ff0855a167b2a057dc" id="r_a40e98056457ab5ff0855a167b2a057dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40e98056457ab5ff0855a167b2a057dc">CheckSatisfiedAtInitialGuess</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &amp;binding, <a class="el" href="classdouble.html">double</a> tol=1e-6) const</td></tr>
<tr class="memdesc:a40e98056457ab5ff0855a167b2a057dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates CheckSatisfied for the constraint in <code class="param">binding</code> at the initial guess.  <br /></td></tr>
<tr class="memitem:a4249e7e6340d17cc2fe9a77c7ac049f7" id="r_a4249e7e6340d17cc2fe9a77c7ac049f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4249e7e6340d17cc2fe9a77c7ac049f7">CheckSatisfiedAtInitialGuess</a> (const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &gt; &amp;bindings, <a class="el" href="classdouble.html">double</a> tol=1e-6) const</td></tr>
<tr class="memdesc:a4249e7e6340d17cc2fe9a77c7ac049f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates CheckSatisfied for the all of the constraints in <code class="param">bindings</code> at the initial guess.  <br /></td></tr>
<tr class="memitem:a8edf415633915556308470787995a6a0" id="r_a8edf415633915556308470787995a6a0"><td class="memItemLeft" align="right" valign="top">Eigen::Map&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8edf415633915556308470787995a6a0">decision_variables</a> () const</td></tr>
<tr class="memdesc:a8edf415633915556308470787995a6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for all decision variables in the program.  <br /></td></tr>
<tr class="memitem:ab9468b404ae211e3deaa2e41237ee008" id="r_ab9468b404ae211e3deaa2e41237ee008"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9468b404ae211e3deaa2e41237ee008">decision_variable</a> (int i) const</td></tr>
<tr class="memdesc:ab9468b404ae211e3deaa2e41237ee008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the decision variable with index <code class="param">i</code> in the program.  <br /></td></tr>
<tr class="memitem:a42256b8f076fda109cf611d3b45e2e5e" id="r_a42256b8f076fda109cf611d3b45e2e5e"><td class="memItemLeft" align="right" valign="top">Eigen::Map&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42256b8f076fda109cf611d3b45e2e5e">indeterminates</a> () const</td></tr>
<tr class="memdesc:a42256b8f076fda109cf611d3b45e2e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for all indeterminates in the program.  <br /></td></tr>
<tr class="memitem:a0f75da04ed0e8cc2aee0c5d4c5c19a9f" id="r_a0f75da04ed0e8cc2aee0c5d4c5c19a9f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f75da04ed0e8cc2aee0c5d4c5c19a9f">indeterminate</a> (int i) const</td></tr>
<tr class="memdesc:a0f75da04ed0e8cc2aee0c5d4c5c19a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the indeterminate with index <code class="param">i</code> in the program.  <br /></td></tr>
<tr class="memitem:a83bb9dd09607a749769b9f9102395740" id="r_a83bb9dd09607a749769b9f9102395740"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83bb9dd09607a749769b9f9102395740">required_capabilities</a> () const</td></tr>
<tr class="memdesc:a83bb9dd09607a749769b9f9102395740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the required capability on the solver, given the cost/constraint/variable types in the program.  <br /></td></tr>
<tr class="memitem:af5b6d39a1b502b2b461de00ac5be2ec8" id="r_af5b6d39a1b502b2b461de00ac5be2ec8"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5b6d39a1b502b2b461de00ac5be2ec8">decision_variable_index</a> () const</td></tr>
<tr class="memdesc:af5b6d39a1b502b2b461de00ac5be2ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mapping from a decision variable ID to its index in the vector containing all the decision variables in the mathematical program.  <br /></td></tr>
<tr class="memitem:a5f8733e9e6866b4a4024e9c32043ab7d" id="r_a5f8733e9e6866b4a4024e9c32043ab7d"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f8733e9e6866b4a4024e9c32043ab7d">indeterminates_index</a> () const</td></tr>
<tr class="memdesc:a5f8733e9e6866b4a4024e9c32043ab7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mapping from an indeterminate ID to its index in the vector containing all the indeterminates in the mathematical program.  <br /></td></tr>
<tr id="pub-methods-7" class="groupHeader"><td colspan="2"><div class="groupHeader">Variable scaling</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="variable_scaling"></a> Some solvers (e.g.</p>
<p>SNOPT) work better if the decision variables values are on the same scale. Hence, internally we scale the variable as snopt_var_value = var_value / scaling_factor. This scaling factor is only used inside the solve, so users don't need to manually scale the variables every time they appears in cost and constraints. When the users set the initial guess, or getting the result from <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html#a879d07f1043c47fbf928c0ab8141bdbe" title="Gets the solution of all decision variables.">MathematicalProgramResult::GetSolution()</a>, the values are unscaled. Namely, MathematicalProgramResult::GetSolution(var) returns the value of var, not var_value / scaling_factor.</p>
<p>The feature of variable scaling is currently only implemented for SNOPT and OSQP. </p>
</div></td></tr>
<tr class="memitem:aeffcf790615d0cbfc2b05f80a42e2116" id="r_aeffcf790615d0cbfc2b05f80a42e2116"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; int, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeffcf790615d0cbfc2b05f80a42e2116">GetVariableScaling</a> () const</td></tr>
<tr class="memdesc:aeffcf790615d0cbfc2b05f80a42e2116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mapping from a decision variable index to its scaling factor.  <br /></td></tr>
<tr class="memitem:af4b4542d7067f6d60ea801b3b00c591f" id="r_af4b4542d7067f6d60ea801b3b00c591f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4b4542d7067f6d60ea801b3b00c591f">SetVariableScaling</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;var, <a class="el" href="classdouble.html">double</a> s)</td></tr>
<tr class="memdesc:af4b4542d7067f6d60ea801b3b00c591f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for the scaling <code class="param">s</code> of decision variable <code class="param">var</code>.  <br /></td></tr>
<tr class="memitem:ac2079c8eee90c77853f4a9a96c14715a" id="r_ac2079c8eee90c77853f4a9a96c14715a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2079c8eee90c77853f4a9a96c14715a">ClearVariableScaling</a> ()</td></tr>
<tr class="memdesc:ac2079c8eee90c77853f4a9a96c14715a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the scaling factors for decision variables.  <br /></td></tr>
<tr class="memitem:a581e627b1c23f4427ec3cee17760812a" id="r_a581e627b1c23f4427ec3cee17760812a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a581e627b1c23f4427ec3cee17760812a">RemoveDecisionVariable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;var)</td></tr>
<tr class="memdesc:a581e627b1c23f4427ec3cee17760812a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove <span class="tt">var</span> from this program's decision variable.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a78994b92c87719287528546dc12538bb" id="r_a78994b92c87719287528546dc12538bb"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78994b92c87719287528546dc12538bb">kGlobalInfeasibleCost</a></td></tr>
<tr class="memdesc:a78994b92c87719287528546dc12538bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The optimal cost is +∞ when the problem is globally infeasible.  <br /></td></tr>
<tr class="memitem:ab953e201d71c0ce608e7c95607a4f256" id="r_ab953e201d71c0ce608e7c95607a4f256"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab953e201d71c0ce608e7c95607a4f256">kUnboundedCost</a></td></tr>
<tr class="memdesc:ab953e201d71c0ce608e7c95607a4f256"><td class="mdescLeft">&#160;</td><td class="mdescRight">The optimal cost is -∞ when the problem is unbounded.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Remove costs, constraints or callbacks.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="remove_cost_constraint"></a> Removes costs, constraints or visualization callbacks from this program.</p>
<p>If this program contains multiple costs/constraints/callbacks objects matching the given argument, then all of these costs/constraints/callbacks are removed. If this program doesn't contain the specified cost/constraint/callback, then the code does nothing. We regard two costs/constraints/callbacks being equal, if their evaluators point to the same object, and the associated variables are also the same. </p><dl class="section note"><dt>Note</dt><dd>If two costs/constraints/callbacks represent the same expression, but their evaluators point to different objects, then they are NOT regarded the same. For example, if we have <div class="fragment"><div class="line"><span class="keyword">auto</span> cost1 = prog.AddLinearCost(x[0] + x[1]);</div>
<div class="line"><span class="keyword">auto</span> cost2 = prog.AddLinearCost(x[0] + x[1]);</div>
<div class="line"><span class="comment">// cost1 and cost2 represent the same cost, but cost1.evaluator() and</span></div>
<div class="line"><span class="comment">// cost2.evaluator() point to different objects. So after removing cost1,</span></div>
<div class="line"><span class="comment">// cost2 still lives in prog.</span></div>
<div class="line">prog.RemoveCost(cost1);</div>
<div class="line"><span class="comment">// This will print true.</span></div>
<div class="line">std::cout &lt;&lt; (prog.linear_costs()[0] == cost2) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
</div><!-- fragment --> </dd></dl>
</td></tr>
<tr class="memitem:a776ae5f3bb0dc9a705c584e511aff067" id="r_a776ae5f3bb0dc9a705c584e511aff067"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a776ae5f3bb0dc9a705c584e511aff067">RemoveCost</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &amp;cost)</td></tr>
<tr class="memdesc:a776ae5f3bb0dc9a705c584e511aff067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <code class="param">cost</code> from this mathematical program.  <br /></td></tr>
<tr class="memitem:acb1b59ceeeec9235267e4a8b6d440c9f" id="r_acb1b59ceeeec9235267e4a8b6d440c9f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb1b59ceeeec9235267e4a8b6d440c9f">RemoveConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &amp;constraint)</td></tr>
<tr class="memdesc:acb1b59ceeeec9235267e4a8b6d440c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <code class="param">constraint</code> from this mathematical program.  <br /></td></tr>
<tr class="memitem:aed6328ee1df2fa0f13f00151bc9f579f" id="r_aed6328ee1df2fa0f13f00151bc9f579f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed6328ee1df2fa0f13f00151bc9f579f">RemoveVisualizationCallback</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html">VisualizationCallback</a> &gt; &amp;callback)</td></tr>
<tr class="memdesc:aed6328ee1df2fa0f13f00151bc9f579f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <code class="param">callback</code> from this mathematical program.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Creating even-degree nonnegative polynomials</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="even_degree_nonnegative_polynomial"></a> Creates a nonnegative polynomial p = m(x)ᵀQm(x) of a given degree, and p only contains even-degree monomials.</p>
<p>If we partition the monomials m(x) to odd degree monomials m_o(x) and even degree monomials m_e(x), then we can write p(x) as </p><pre>
⌈m_o(x)⌉ᵀ * ⌈Q_oo Q_oeᵀ⌉ * ⌈m_o(x)⌉
⌊m_e(x)⌋    ⌊Q_oe Q_ee ⌋   ⌊m_e(x)⌋
</pre><p> Since p(x) doesn't contain any odd degree monomials, and p(x) contains terms m_e(x)ᵀ*Q_oe * m_o(x) which has odd degree, we know that the off-diagonal block Q_oe has to be zero. So the constraint that Q is psd can be simplified as Q_oo and Q_ee has to be psd. Since both Q_oo and Q_ee have smaller size than Q, these PSD constraints are easier to solve than requiring Q to be PSD. One use case for even-degree polynomial, is for polynomials that are even functions, namely p(x) = p(-x). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indeterminates</td><td>The set of indeterminates x </td></tr>
    <tr><td class="paramname">degree</td><td>The total degree of the polynomial p. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>This must be an even number. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>(p(x), Q_oo, Q_ee). p(x) is the newly added non-negative polynomial. p(x) = m_o(x)ᵀ*Q_oo*m_o(x) + m_e(x)ᵀ*Q_ee*m_e(x) where m_o(x) and m_e(x) contain all the even/odd monomials of x respectively. The returned non-negative polynomial can be of different types, including Sum-of-squares (SOS), diagonally-dominant-sum-of-squares (dsos), and scaled-diagonally-dominant-sum-of-squares (sdsos). </dd></dl>
</td></tr>
<tr class="memitem:a5dda62aec4fd45a95cad1867d9361854" id="r_a5dda62aec4fd45a95cad1867d9361854"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5dda62aec4fd45a95cad1867d9361854">NewEvenDegreeNonnegativePolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;<a class="el" href="#a42256b8f076fda109cf611d3b45e2e5e">indeterminates</a>, int degree, <a class="el" href="#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> type)</td></tr>
<tr class="memdesc:a5dda62aec4fd45a95cad1867d9361854"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="#even_degree_nonnegative_polynomial">even_degree_nonnegative_polynomial</a> for more details.  <br /></td></tr>
<tr class="memitem:afca1e0b1836c6cb3034c0f0903366723" id="r_afca1e0b1836c6cb3034c0f0903366723"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afca1e0b1836c6cb3034c0f0903366723">NewEvenDegreeSosPolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;<a class="el" href="#a42256b8f076fda109cf611d3b45e2e5e">indeterminates</a>, int degree)</td></tr>
<tr class="memdesc:afca1e0b1836c6cb3034c0f0903366723"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="#even_degree_nonnegative_polynomial">even_degree_nonnegative_polynomial</a> for more details.  <br /></td></tr>
<tr class="memitem:af958ec779d15747753ee886d28974382" id="r_af958ec779d15747753ee886d28974382"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af958ec779d15747753ee886d28974382">NewEvenDegreeSdsosPolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;<a class="el" href="#a42256b8f076fda109cf611d3b45e2e5e">indeterminates</a>, int degree)</td></tr>
<tr class="memdesc:af958ec779d15747753ee886d28974382"><td class="mdescLeft">&#160;</td><td class="mdescRight">see <a class="el" href="#even_degree_nonnegative_polynomial">even_degree_nonnegative_polynomial</a> for details.  <br /></td></tr>
<tr class="memitem:a84fc64a5a0af849e40b85214d8c60955" id="r_a84fc64a5a0af849e40b85214d8c60955"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84fc64a5a0af849e40b85214d8c60955">NewEvenDegreeDsosPolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;<a class="el" href="#a42256b8f076fda109cf611d3b45e2e5e">indeterminates</a>, int degree)</td></tr>
<tr class="memdesc:a84fc64a5a0af849e40b85214d8c60955"><td class="mdescLeft">&#160;</td><td class="mdescRight">see <a class="el" href="#even_degree_nonnegative_polynomial">even_degree_nonnegative_polynomial</a> for details.  <br /></td></tr>
<tr class="memitem:a9757b022381ac5841cd389a7e212dfbb" id="r_a9757b022381ac5841cd389a7e212dfbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9757b022381ac5841cd389a7e212dfbb">MakePolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e) const</td></tr>
<tr class="memdesc:a9757b022381ac5841cd389a7e212dfbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a symbolic polynomial from the given expression <span class="tt">e</span>.  <br /></td></tr>
<tr class="memitem:aee9493ea7d08a35395634bfbfd5713dd" id="r_aee9493ea7d08a35395634bfbfd5713dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee9493ea7d08a35395634bfbfd5713dd">Reparse</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> *p) const</td></tr>
<tr class="memdesc:aee9493ea7d08a35395634bfbfd5713dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reparses the polynomial <span class="tt">p</span> using this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>'s indeterminates.  <br /></td></tr>
<tr class="memitem:a46a010c4311bb044d66b14c16334db19" id="r_a46a010c4311bb044d66b14c16334db19"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:a46a010c4311bb044d66b14c16334db19 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a>&lt; rows, cols &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46a010c4311bb044d66b14c16334db19">NewIndeterminates</a> (const std::array&lt; std::string, rows *cols &gt; &amp;names)</td></tr>
<tr class="memdesc:a46a010c4311bb044d66b14c16334db19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates, appending them to an internal vector of any existing indeterminates.  <br /></td></tr>
<tr class="memitem:a819e745c1bb12da1806d5d7efec80bce" id="r_a819e745c1bb12da1806d5d7efec80bce"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a819e745c1bb12da1806d5d7efec80bce template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a>&lt; rows &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a819e745c1bb12da1806d5d7efec80bce">NewIndeterminates</a> (const std::array&lt; std::string, rows &gt; &amp;names)</td></tr>
<tr class="memdesc:a819e745c1bb12da1806d5d7efec80bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates, appending them to an internal vector of any existing indeterminates.  <br /></td></tr>
<tr class="memitem:a1fe5bb17e18cc4fca0687ba3af361da0" id="r_a1fe5bb17e18cc4fca0687ba3af361da0"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:a1fe5bb17e18cc4fca0687ba3af361da0 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a>&lt; rows, cols &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fe5bb17e18cc4fca0687ba3af361da0">NewIndeterminates</a> (const std::string &amp;name=&quot;X&quot;)</td></tr>
<tr class="memdesc:a1fe5bb17e18cc4fca0687ba3af361da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates, appending them to an internal vector of any existing indeterminates.  <br /></td></tr>
<tr class="memitem:a32ebe0215c7d23795508d0b552027608" id="r_a32ebe0215c7d23795508d0b552027608"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a32ebe0215c7d23795508d0b552027608 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a>&lt; rows &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32ebe0215c7d23795508d0b552027608">NewIndeterminates</a> (const std::string &amp;name=&quot;x&quot;)</td></tr>
<tr class="memdesc:a32ebe0215c7d23795508d0b552027608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates to the program.  <br /></td></tr>
<tr class="memitem:a0fd679ea34528e50d76d23f79fcd294f" id="r_a0fd679ea34528e50d76d23f79fcd294f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fd679ea34528e50d76d23f79fcd294f">NewIndeterminates</a> (int rows, const std::vector&lt; std::string &gt; &amp;names)</td></tr>
<tr class="memdesc:a0fd679ea34528e50d76d23f79fcd294f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <br /></td></tr>
<tr class="memitem:ae4ec9c4fc4ae8f5d8ff8382b227dd82f" id="r_ae4ec9c4fc4ae8f5d8ff8382b227dd82f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4ec9c4fc4ae8f5d8ff8382b227dd82f">NewIndeterminates</a> (int rows, const std::string &amp;name=&quot;x&quot;)</td></tr>
<tr class="memdesc:ae4ec9c4fc4ae8f5d8ff8382b227dd82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>, with default name "x".  <br /></td></tr>
<tr class="memitem:a12431081348a404711db4d3bb25c8a76" id="r_a12431081348a404711db4d3bb25c8a76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a7ab45e84bec7fad9608e19ae3441b0bf">MatrixXIndeterminate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12431081348a404711db4d3bb25c8a76">NewIndeterminates</a> (int rows, int cols, const std::vector&lt; std::string &gt; &amp;names)</td></tr>
<tr class="memdesc:a12431081348a404711db4d3bb25c8a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates, appending them to an internal vector of any existing vars.  <br /></td></tr>
<tr class="memitem:ad7e4fa58845ca19073b0c532431ac141" id="r_ad7e4fa58845ca19073b0c532431ac141"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a7ab45e84bec7fad9608e19ae3441b0bf">MatrixXIndeterminate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7e4fa58845ca19073b0c532431ac141">NewIndeterminates</a> (int rows, int cols, const std::string &amp;name=&quot;X&quot;)</td></tr>
<tr class="memdesc:ad7e4fa58845ca19073b0c532431ac141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>, with default name "X".  <br /></td></tr>
<tr class="memitem:a100c35ec0287aaded41a390e0fe95e4b" id="r_a100c35ec0287aaded41a390e0fe95e4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a100c35ec0287aaded41a390e0fe95e4b">AddIndeterminate</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;new_indeterminate)</td></tr>
<tr class="memdesc:a100c35ec0287aaded41a390e0fe95e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminate.  <br /></td></tr>
<tr class="memitem:a1d17877e373279d18488f21836285539" id="r_a1d17877e373279d18488f21836285539"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d17877e373279d18488f21836285539">AddIndeterminates</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#a7ab45e84bec7fad9608e19ae3441b0bf">MatrixXIndeterminate</a> &gt; &amp;new_indeterminates)</td></tr>
<tr class="memdesc:a1d17877e373279d18488f21836285539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates.  <br /></td></tr>
<tr class="memitem:a4b39856ec07e10a4f9f9980dbc33ef98" id="r_a4b39856ec07e10a4f9f9980dbc33ef98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b39856ec07e10a4f9f9980dbc33ef98">AddIndeterminates</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;new_indeterminates)</td></tr>
<tr class="memdesc:a4b39856ec07e10a4f9f9980dbc33ef98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates.  <br /></td></tr>
<tr class="memitem:a4724865fbef538d6b26a1d1934f93166" id="r_a4724865fbef538d6b26a1d1934f93166"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html">VisualizationCallback</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4724865fbef538d6b26a1d1934f93166">AddVisualizationCallback</a> (const <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html#a84c15b60ba647eabef0aaa2d5dd3943e">VisualizationCallback::CallbackFunction</a> &amp;callback, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a4724865fbef538d6b26a1d1934f93166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback method to visualize intermediate results of the optimization.  <br /></td></tr>
<tr class="memitem:a6a4b84ad651a9cb5a81723e336040ca8" id="r_a6a4b84ad651a9cb5a81723e336040ca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html">VisualizationCallback</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a4b84ad651a9cb5a81723e336040ca8">AddVisualizationCallback</a> (const <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html#a84c15b60ba647eabef0aaa2d5dd3943e">VisualizationCallback::CallbackFunction</a> &amp;callback, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a6a4b84ad651a9cb5a81723e336040ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback method to visualize intermediate results of the optimization.  <br /></td></tr>
<tr class="memitem:a4efea1b480be940fe05070939b7954ac" id="r_a4efea1b480be940fe05070939b7954ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4efea1b480be940fe05070939b7954ac">AddCost</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a4efea1b480be940fe05070939b7954ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a generic cost to the optimization program.  <br /></td></tr>
<tr class="memitem:a60e141e79d84c40fbc83ea8e3aab7823" id="r_a60e141e79d84c40fbc83ea8e3aab7823"><td class="memTemplParams" colspan="2">template&lt;typename C&gt; </td></tr>
<tr class="memitem:a60e141e79d84c40fbc83ea8e3aab7823 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60e141e79d84c40fbc83ea8e3aab7823">AddCost</a> (const std::shared_ptr&lt; C &gt; &amp;obj, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a60e141e79d84c40fbc83ea8e3aab7823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost type to the optimization program.  <br /></td></tr>
<tr class="memitem:a24f0ccf74cf7be71ca7bc12d81051cad" id="r_a24f0ccf74cf7be71ca7bc12d81051cad"><td class="memTemplParams" colspan="2">template&lt;typename C&gt; </td></tr>
<tr class="memitem:a24f0ccf74cf7be71ca7bc12d81051cad template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24f0ccf74cf7be71ca7bc12d81051cad">AddCost</a> (const std::shared_ptr&lt; C &gt; &amp;obj, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a24f0ccf74cf7be71ca7bc12d81051cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a generic cost to the optimization program.  <br /></td></tr>
<tr class="memitem:a7b9d222353fbde88b65460b4d127dfad" id="r_a7b9d222353fbde88b65460b4d127dfad"><td class="memTemplParams" colspan="2">template&lt;typename F&gt; </td></tr>
<tr class="memitem:a7b9d222353fbde88b65460b4d127dfad template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; internal::is_cost_functor_candidate&lt; F &gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b9d222353fbde88b65460b4d127dfad">AddCost</a> (F &amp;&amp;f, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a7b9d222353fbde88b65460b4d127dfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost to the optimization program on a list of variables.  <br /></td></tr>
<tr class="memitem:a134462c636b25fa7dfd0826f3984aaf3" id="r_a134462c636b25fa7dfd0826f3984aaf3"><td class="memTemplParams" colspan="2">template&lt;typename F&gt; </td></tr>
<tr class="memitem:a134462c636b25fa7dfd0826f3984aaf3 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; internal::is_cost_functor_candidate&lt; F &gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a134462c636b25fa7dfd0826f3984aaf3">AddCost</a> (F &amp;&amp;f, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a134462c636b25fa7dfd0826f3984aaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost to the optimization program on an Eigen::Vector containing decision variables.  <br /></td></tr>
<tr class="memitem:a93a41a9cfddad5b3219e961cd3c86f3a" id="r_a93a41a9cfddad5b3219e961cd3c86f3a"><td class="memTemplParams" colspan="2">template&lt;typename F, typename Vars&gt; </td></tr>
<tr class="memitem:a93a41a9cfddad5b3219e961cd3c86f3a template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; internal::assert_if_is_constraint&lt; F &gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93a41a9cfddad5b3219e961cd3c86f3a">AddCost</a> (F &amp;&amp;, Vars &amp;&amp;)</td></tr>
<tr class="memdesc:a93a41a9cfddad5b3219e961cd3c86f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically assert if a user inadvertently passes a binding-compatible <a class="el" href="classdrake_1_1solvers_1_1_constraint.html" title="A constraint is a function + lower and upper bounds.">Constraint</a>.  <br /></td></tr>
<tr class="memitem:af9361760e08efc82cecdb7d73abdaf08" id="r_af9361760e08efc82cecdb7d73abdaf08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9361760e08efc82cecdb7d73abdaf08">AddCost</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:af9361760e08efc82cecdb7d73abdaf08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form c'*x.  <br /></td></tr>
<tr class="memitem:a8a8dae8551794a05aadea978f2ae5ae3" id="r_a8a8dae8551794a05aadea978f2ae5ae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a8dae8551794a05aadea978f2ae5ae3">AddLinearCost</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a8a8dae8551794a05aadea978f2ae5ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear cost term of the form a'*x + b.  <br /></td></tr>
<tr class="memitem:afbe6af66a54f99a1274bf4004fc5a7a1" id="r_afbe6af66a54f99a1274bf4004fc5a7a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbe6af66a54f99a1274bf4004fc5a7a1">AddLinearCost</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;a, <a class="el" href="classdouble.html">double</a> b, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:afbe6af66a54f99a1274bf4004fc5a7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear cost term of the form a'*x + b.  <br /></td></tr>
<tr class="memitem:a3bc63e8400b182a07b2b9372a4418114" id="r_a3bc63e8400b182a07b2b9372a4418114"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bc63e8400b182a07b2b9372a4418114">AddLinearCost</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;a, <a class="el" href="classdouble.html">double</a> b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a3bc63e8400b182a07b2b9372a4418114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear cost term of the form a'*x + b.  <br /></td></tr>
<tr class="memitem:a7be5ae4905aa3e7a043f800bf02d7539" id="r_a7be5ae4905aa3e7a043f800bf02d7539"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">VarType</a>&gt; </td></tr>
<tr class="memitem:a7be5ae4905aa3e7a043f800bf02d7539 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7be5ae4905aa3e7a043f800bf02d7539">AddLinearCost</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;a, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">VarType</a> &amp;vars)</td></tr>
<tr class="memdesc:a7be5ae4905aa3e7a043f800bf02d7539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear cost term of the form a'*x.  <br /></td></tr>
<tr class="memitem:a413bc850a691a89ffd076b6bfbd6ffea" id="r_a413bc850a691a89ffd076b6bfbd6ffea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a413bc850a691a89ffd076b6bfbd6ffea">AddCost</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a413bc850a691a89ffd076b6bfbd6ffea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form 0.5*x'*Q*x + b'x.  <br /></td></tr>
<tr class="memitem:a03093e39f8da15c8a4064b8a14ab7cac" id="r_a03093e39f8da15c8a4064b8a14ab7cac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03093e39f8da15c8a4064b8a14ab7cac">AddQuadraticCost</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, std::optional&lt; bool &gt; is_convex=std::nullopt)</td></tr>
<tr class="memdesc:a03093e39f8da15c8a4064b8a14ab7cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a quadratic cost term of the form 0.5*x'*Q*x + b'*x + c.  <br /></td></tr>
<tr class="memitem:ab2846cb28c83784e28e1e6c7b29d36e7" id="r_ab2846cb28c83784e28e1e6c7b29d36e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2846cb28c83784e28e1e6c7b29d36e7">AddQuadraticCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars, std::optional&lt; bool &gt; is_convex=std::nullopt)</td></tr>
<tr class="memdesc:ab2846cb28c83784e28e1e6c7b29d36e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form 0.5*x'*Q*x + b'x.  <br /></td></tr>
<tr class="memitem:a90b9ebf0459a4d9f636018538670dbe2" id="r_a90b9ebf0459a4d9f636018538670dbe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90b9ebf0459a4d9f636018538670dbe2">AddQuadraticCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, <a class="el" href="classdouble.html">double</a> c, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars, std::optional&lt; bool &gt; is_convex=std::nullopt)</td></tr>
<tr class="memdesc:a90b9ebf0459a4d9f636018538670dbe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form 0.5*x'*Q*x + b'x + c Applied to subset of the variables.  <br /></td></tr>
<tr class="memitem:aecd6bb31415b2221144adaf4080bfeba" id="r_aecd6bb31415b2221144adaf4080bfeba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecd6bb31415b2221144adaf4080bfeba">AddQuadraticCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars, std::optional&lt; bool &gt; is_convex=std::nullopt)</td></tr>
<tr class="memdesc:aecd6bb31415b2221144adaf4080bfeba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form 0.5*x'*Q*x + b'x Applied to subset of the variables.  <br /></td></tr>
<tr class="memitem:a946990fb2424146499c82849f55e4985" id="r_a946990fb2424146499c82849f55e4985"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a946990fb2424146499c82849f55e4985">AddQuadraticErrorCost</a> (<a class="el" href="classdouble.html">double</a> w, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;x_desired, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a946990fb2424146499c82849f55e4985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form w*|x-x_desired|^2.  <br /></td></tr>
<tr class="memitem:a39f08dd96e9b93277bfd7f3bd33b0689" id="r_a39f08dd96e9b93277bfd7f3bd33b0689"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39f08dd96e9b93277bfd7f3bd33b0689">AddQuadraticErrorCost</a> (<a class="el" href="classdouble.html">double</a> w, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;x_desired, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a39f08dd96e9b93277bfd7f3bd33b0689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form w*|x-x_desired|^2.  <br /></td></tr>
<tr class="memitem:ab2fca7ef3d76b4e623e9e3a8768e6f99" id="r_ab2fca7ef3d76b4e623e9e3a8768e6f99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2fca7ef3d76b4e623e9e3a8768e6f99">AddQuadraticErrorCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;x_desired, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:ab2fca7ef3d76b4e623e9e3a8768e6f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form (x-x_desired)'<em>Q</em>(x-x_desired).  <br /></td></tr>
<tr class="memitem:a3b19f7bda6ac7551c6d0213b40527bf5" id="r_a3b19f7bda6ac7551c6d0213b40527bf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b19f7bda6ac7551c6d0213b40527bf5">AddQuadraticErrorCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;x_desired, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a3b19f7bda6ac7551c6d0213b40527bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form (x-x_desired)'<em>Q</em>(x-x_desired).  <br /></td></tr>
<tr class="memitem:a9efa750b110d6c422611461e969ea418" id="r_a9efa750b110d6c422611461e969ea418"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9efa750b110d6c422611461e969ea418">Add2NormSquaredCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a9efa750b110d6c422611461e969ea418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a quadratic cost of the form |Ax-b|²=(Ax-b)ᵀ(Ax-b).  <br /></td></tr>
<tr class="memitem:a68ecb84629ef2acad42dc9fe95d8754a" id="r_a68ecb84629ef2acad42dc9fe95d8754a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68ecb84629ef2acad42dc9fe95d8754a">Add2NormSquaredCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a68ecb84629ef2acad42dc9fe95d8754a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a quadratic cost of the form |Ax-b|²=(Ax-b)ᵀ(Ax-b).  <br /></td></tr>
<tr class="memitem:afdc73aabceb199326b321625c99a5830" id="r_afdc73aabceb199326b321625c99a5830"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdc73aabceb199326b321625c99a5830">AddCost</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:afdc73aabceb199326b321625c99a5830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an L2 norm cost |Ax+b|₂ (notice this cost is not quadratic since we don't take the square of the L2 norm).  <br /></td></tr>
<tr class="memitem:af8e539e3c7e8f00f5d161de118fd9c8a" id="r_af8e539e3c7e8f00f5d161de118fd9c8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8e539e3c7e8f00f5d161de118fd9c8a">AddL2NormCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:af8e539e3c7e8f00f5d161de118fd9c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an L2 norm cost |Ax+b|₂ (notice this cost is not quadratic since we don't take the square of the L2 norm).  <br /></td></tr>
<tr class="memitem:a11b78e6a556d483d18fe712ee19d35a2" id="r_a11b78e6a556d483d18fe712ee19d35a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11b78e6a556d483d18fe712ee19d35a2">AddL2NormCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a11b78e6a556d483d18fe712ee19d35a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an L2 norm cost |Ax+b|₂ (notice this cost is not quadratic since we don't take the square of the L2 norm).  <br /></td></tr>
<tr class="memitem:ab79f3a268966d52e8100cba853f76a20" id="r_ab79f3a268966d52e8100cba853f76a20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab79f3a268966d52e8100cba853f76a20">AddL2NormCost</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, <a class="el" href="classdouble.html">double</a> psd_tol=1e-8, <a class="el" href="classdouble.html">double</a> coefficient_tol=1e-8)</td></tr>
<tr class="memdesc:ab79f3a268966d52e8100cba853f76a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an L2 norm cost |Ax+b|₂ from a symbolic expression which can be decomposed into sqrt((Ax+b)'(Ax+b)).  <br /></td></tr>
<tr class="memitem:af2dfbbcf57de566c360a3e268fbe4d64" id="r_af2dfbbcf57de566c360a3e268fbe4d64"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2dfbbcf57de566c360a3e268fbe4d64">AddL2NormCostUsingConicConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:af2dfbbcf57de566c360a3e268fbe4d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an L2 norm cost min |Ax+b|₂ as a linear cost min s on the slack variable s, together with a Lorentz cone constraint s ≥ |Ax+b|₂ Many conic optimization solvers (Gurobi, MOSEK<a href="/tm.html">™</a>, SCS, etc) natively prefers this form of linear cost + conic constraints.  <br /></td></tr>
<tr class="memitem:a17183b1ac9b0e70ccc15924ae754baf1" id="r_a17183b1ac9b0e70ccc15924ae754baf1"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17183b1ac9b0e70ccc15924ae754baf1">AddL1NormCostInEpigraphForm</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a17183b1ac9b0e70ccc15924ae754baf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an L1 norm cost min |Ax+b|₁ as a linear cost min Σᵢsᵢ on the slack variables sᵢ, together with the constraints (for each i) sᵢ ≥ (|Ax+b|)ᵢ, which itself is written sᵢ ≥ (Ax+b)ᵢ and sᵢ ≥ -(Ax+b)ᵢ.  <br /></td></tr>
<tr class="memitem:acaac50719294dcb0ddad7ccb1df3ae03" id="r_acaac50719294dcb0ddad7ccb1df3ae03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_polynomial_cost.html">PolynomialCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acaac50719294dcb0ddad7ccb1df3ae03">AddPolynomialCost</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e)</td></tr>
<tr class="memdesc:acaac50719294dcb0ddad7ccb1df3ae03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term in the polynomial form.  <br /></td></tr>
<tr class="memitem:adeaa05fb1b97a02f8d14c393bebe68bf" id="r_adeaa05fb1b97a02f8d14c393bebe68bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adeaa05fb1b97a02f8d14c393bebe68bf">AddCost</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e)</td></tr>
<tr class="memdesc:adeaa05fb1b97a02f8d14c393bebe68bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost in the symbolic form.  <br /></td></tr>
<tr class="memitem:ab7b3bbb3c397919036c360eced743e1f" id="r_ab7b3bbb3c397919036c360eced743e1f"><td class="memTemplParams" colspan="2">template&lt;typename F&gt; </td></tr>
<tr class="memitem:ab7b3bbb3c397919036c360eced743e1f template"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7b3bbb3c397919036c360eced743e1f">MakeCost</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:ab7b3bbb3c397919036c360eced743e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an input of type <code class="param">F</code> to a FunctionCost object.  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="aaed05d048d1ac7b1d4960e328c20d02f" name="aaed05d048d1ac7b1d4960e328c20d02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed05d048d1ac7b1d4960e328c20d02f">&#9670;&#160;</a></span>VarType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">VarType</a> = <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">symbolic::Variable::Type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Member Enumeration Documentation</h2>
<a id="a407fb21fc13a5122994e71a05a6a0818" name="a407fb21fc13a5122994e71a05a6a0818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407fb21fc13a5122994e71a05a6a0818">&#9670;&#160;</a></span>NonnegativePolynomial</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Types of non-negative polynomial that can be found through conic optimization. </p>
<p>We currently support SOS, SDSOS and DSOS. For more information about these polynomial types, please refer to "DSOS and SDSOS Optimization: More Tractable
Alternatives to Sum of Squares and Semidefinite Optimization" by Amir Ali Ahmadi and Anirudha Majumdar, with arXiv link <a href="https://arxiv.org/abs/1706.02586">https://arxiv.org/abs/1706.02586</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076" name="a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076"></a>kSos&#160;</td><td class="fielddoc"><p>A sum-of-squares polynomial. </p>
</td></tr>
<tr><td class="fieldname"><a id="a407fb21fc13a5122994e71a05a6a0818a28b23c4ed46cc23775486c764a920e29" name="a407fb21fc13a5122994e71a05a6a0818a28b23c4ed46cc23775486c764a920e29"></a>kSdsos&#160;</td><td class="fielddoc"><p>A scaled-diagonally dominant sum-of-squares polynomial. </p>
</td></tr>
<tr><td class="fieldname"><a id="a407fb21fc13a5122994e71a05a6a0818a26e1dbaa56329cec4d3ba803424aed81" name="a407fb21fc13a5122994e71a05a6a0818a26e1dbaa56329cec4d3ba803424aed81"></a>kDsos&#160;</td><td class="fielddoc"><p>A diagonally dominant sum-of-squares polynomial. </p>
</td></tr>
</table>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6d281d024510ccc0f7787ebbb1e534ee" name="a6d281d024510ccc0f7787ebbb1e534ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d281d024510ccc0f7787ebbb1e534ee">&#9670;&#160;</a></span>MathematicalProgram() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MathematicalProgram </td>
          <td>(</td>
          <td class="paramtype">const MathematicalProgram &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1935f9e12a11b66c67eda33fd165b4d3" name="a1935f9e12a11b66c67eda33fd165b4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1935f9e12a11b66c67eda33fd165b4d3">&#9670;&#160;</a></span>MathematicalProgram() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MathematicalProgram </td>
          <td>(</td>
          <td class="paramtype">MathematicalProgram &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac577d0f44c9c07256230cf2642ec6822" name="ac577d0f44c9c07256230cf2642ec6822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac577d0f44c9c07256230cf2642ec6822">&#9670;&#160;</a></span>MathematicalProgram() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MathematicalProgram </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4793d463ad85b0e169fef6a974df5323" name="a4793d463ad85b0e169fef6a974df5323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4793d463ad85b0e169fef6a974df5323">&#9670;&#160;</a></span>~MathematicalProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a68ecb84629ef2acad42dc9fe95d8754a" name="a68ecb84629ef2acad42dc9fe95d8754a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ecb84629ef2acad42dc9fe95d8754a">&#9670;&#160;</a></span>Add2NormSquaredCost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; Add2NormSquaredCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a quadratic cost of the form |Ax-b|²=(Ax-b)ᵀ(Ax-b). </p>

</div>
</div>
<a id="a9efa750b110d6c422611461e969ea418" name="a9efa750b110d6c422611461e969ea418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9efa750b110d6c422611461e969ea418">&#9670;&#160;</a></span>Add2NormSquaredCost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; Add2NormSquaredCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a quadratic cost of the form |Ax-b|²=(Ax-b)ᵀ(Ax-b). </p>

</div>
</div>
<a id="a7d9354ce0d9623dd53f01ecb80b3cfe2" name="a7d9354ce0d9623dd53f01ecb80b3cfe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d9354ce0d9623dd53f01ecb80b3cfe2">&#9670;&#160;</a></span>AddBoundingBoxConstraint() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; AddBoundingBoxConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds bounding box constraints referencing potentially a subset of the decision variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>The lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>The upper bound. </td></tr>
    <tr><td class="paramname">vars</td><td>Will imposes constraint lb(i, j) &lt;= vars(i, j) &lt;= ub(i, j). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly constructed <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html" title="Implements a constraint of the form .">BoundingBoxConstraint</a>. </dd></dl>

</div>
</div>
<a id="aced7aa6413bd59c13621dc20250f9bbb" name="aced7aa6413bd59c13621dc20250f9bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced7aa6413bd59c13621dc20250f9bbb">&#9670;&#160;</a></span>AddBoundingBoxConstraint() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; AddBoundingBoxConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AddBoundingBoxConstraint. </p>
<p>Adds bounding box constraints referencing potentially a subset of the decision variables (defined in the vars parameter). Example </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> prog;</div>
<div class="line"><span class="keyword">auto</span> x = prog.<a class="code hl_function" href="#a53949966a66a6f53ba90596fc5a439ef">NewContinuousVariables</a>&lt;2&gt;(<span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> y = prog.<a class="code hl_function" href="#a53949966a66a6f53ba90596fc5a439ef">NewContinuousVariables</a>&lt;1&gt;(<span class="stringliteral">&quot;y&quot;</span>);</div>
<div class="line">Eigen::Vector3d lb(0, 1, 2);</div>
<div class="line">Eigen::Vector3d ub(1, 2, 3);</div>
<div class="line"><span class="comment">// Imposes the constraint</span></div>
<div class="line"><span class="comment">// 0 ≤ x(0) ≤ 1</span></div>
<div class="line"><span class="comment">// 1 ≤ x(1) ≤ 2</span></div>
<div class="line"><span class="comment">// 2 ≤ y    ≤ 3</span></div>
<div class="line">prog.<a class="code hl_function" href="#aced7aa6413bd59c13621dc20250f9bbb">AddBoundingBoxConstraint</a>(lb, ub, {x, y});</div>
<div class="ttc" id="aclassdrake_1_1solvers_1_1_mathematical_program_html_a53949966a66a6f53ba90596fc5a439ef"><div class="ttname"><a href="#a53949966a66a6f53ba90596fc5a439ef">drake::solvers::MathematicalProgram::NewContinuousVariables</a></div><div class="ttdeci">VectorXDecisionVariable NewContinuousVariables(int rows, const std::string &amp;name=&quot;x&quot;)</div><div class="ttdoc">Adds continuous variables, appending them to an internal vector of any existing vars.</div><div class="ttdef"><b>Definition</b> mathematical_program.h:248</div></div>
<div class="ttc" id="aclassdrake_1_1solvers_1_1_mathematical_program_html_a6d281d024510ccc0f7787ebbb1e534ee"><div class="ttname"><a href="#a6d281d024510ccc0f7787ebbb1e534ee">drake::solvers::MathematicalProgram::MathematicalProgram</a></div><div class="ttdeci">MathematicalProgram(const MathematicalProgram &amp;)=delete</div></div>
<div class="ttc" id="aclassdrake_1_1solvers_1_1_mathematical_program_html_aced7aa6413bd59c13621dc20250f9bbb"><div class="ttname"><a href="#aced7aa6413bd59c13621dc20250f9bbb">drake::solvers::MathematicalProgram::AddBoundingBoxConstraint</a></div><div class="ttdeci">Binding&lt; BoundingBoxConstraint &gt; AddBoundingBoxConstraint(const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub, const VariableRefList &amp;vars)</div><div class="ttdoc">AddBoundingBoxConstraint.</div><div class="ttdef"><b>Definition</b> mathematical_program.h:1955</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa6e4fbc2c4e7819d3382b42778537161" name="aa6e4fbc2c4e7819d3382b42778537161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e4fbc2c4e7819d3382b42778537161">&#9670;&#160;</a></span>AddBoundingBoxConstraint() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &amp;&amp;Derived::ColsAtCompileTime !=1, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; &gt; AddBoundingBoxConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the same scalar lower and upper bound to every variable in <code class="param">vars</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>An Eigen::Matrix with Variable as the scalar type. The matrix has unknown number of columns at compile time, or has more than one column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a820bd029a9d41d438df117770f93822a" name="a820bd029a9d41d438df117770f93822a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820bd029a9d41d438df117770f93822a">&#9670;&#160;</a></span>AddBoundingBoxConstraint() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &amp;&amp;Derived::ColsAtCompileTime==1, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; &gt; AddBoundingBoxConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the same scalar lower and upper bound to every variable in <code class="param">vars</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>An Eigen <a class="el" href="namespacedrake.html#a01ae662d5635b7c9efe03d15d976f7a8" title="A column vector templated on the number of rows.">Vector</a> type with Variable as the scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9207789fa0f2fef22d52c9665e8880c4" name="a9207789fa0f2fef22d52c9665e8880c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9207789fa0f2fef22d52c9665e8880c4">&#9670;&#160;</a></span>AddBoundingBoxConstraint() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; AddBoundingBoxConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds bounds for a single variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
    <tr><td class="paramname">var</td><td>The decision variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a405514ee538d773b3e533a09d9207457" name="a405514ee538d773b3e533a09d9207457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405514ee538d773b3e533a09d9207457">&#9670;&#160;</a></span>AddBoundingBoxConstraint() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; AddBoundingBoxConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the same scalar lower and upper bound to every variable in the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e23aa9a8116a05e5ef8c9dd6d7fa5e3" name="a3e23aa9a8116a05e5ef8c9dd6d7fa5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e23aa9a8116a05e5ef8c9dd6d7fa5e3">&#9670;&#160;</a></span>AddConstraint() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds bounding box constraints referencing potentially a subest of the decision variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binding</td><td>Binds a <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html" title="Implements a constraint of the form .">BoundingBoxConstraint</a> with some decision variables, such that binding.evaluator()-&gt;lower_bound()(i) &lt;= binding.variables()(i) &lt;= binding.evaluator().upper_bound()(i) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af05fa6863859ca8be0153e10c29def11" name="af05fa6863859ca8be0153e10c29def11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05fa6863859ca8be0153e10c29def11">&#9670;&#160;</a></span>AddConstraint() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a generic constraint to the program. </p>
<p>This should only be used if a more specific type of constraint is not available, as it may require the use of a significantly more expensive solver.</p>
<dl class="section note"><dt>Note</dt><dd>If <code class="param">binding.evaluator()-&gt;num_constraints()</code> == 0, then this constraint is not added into the <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. We return <code class="param">binding</code> directly. </dd></dl>

</div>
</div>
<a id="a7a9ab8d22c4fbaa231c6864a711212de" name="a7a9ab8d22c4fbaa231c6864a711212de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9ab8d22c4fbaa231c6864a711212de">&#9670;&#160;</a></span>AddConstraint() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html">ExponentialConeConstraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html">ExponentialConeConstraint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the exponential cone constraint that z = binding.evaluator()-&gt;A() * binding.variables() + binding.evaluator()-&gt;b() should be in the exponential cone. </p>
<p>Namely {(z₀, z₁, z₂) | z₀ ≥ z₁ * exp(z₂ / z₁), z₁ &gt; 0}. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binding</td><td>The binding of <a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html" title="An exponential cone constraint is a special type of convex cone constraint.">ExponentialConeConstraint</a> and its bound variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69dd1bb48c3631c7a2e0a70e50022c1a" name="a69dd1bb48c3631c7a2e0a70e50022c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69dd1bb48c3631c7a2e0a70e50022c1a">&#9670;&#160;</a></span>AddConstraint() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear complementarity constraints referencing a subset of the decision variables. </p>

</div>
</div>
<a id="adb35904c3fd69181dba1a7f185662473" name="adb35904c3fd69181dba1a7f185662473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb35904c3fd69181dba1a7f185662473">&#9670;&#160;</a></span>AddConstraint() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds linear constraints referencing potentially a subset of the decision variables (defined in the vars parameter). </p>

</div>
</div>
<a id="a9673db3dce831cddef02eb3345a5f809" name="a9673db3dce831cddef02eb3345a5f809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9673db3dce831cddef02eb3345a5f809">&#9670;&#160;</a></span>AddConstraint() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds linear equality constraints referencing potentially a subset of the decision variables. </p>

</div>
</div>
<a id="a8b781bb7ad3b694a9d9fcbf636235469" name="a8b781bb7ad3b694a9d9fcbf636235469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b781bb7ad3b694a9d9fcbf636235469">&#9670;&#160;</a></span>AddConstraint() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear matrix inequality constraint to the program. </p>

</div>
</div>
<a id="a008804cb1833a8496b6131daf8ace573" name="a008804cb1833a8496b6131daf8ace573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008804cb1833a8496b6131daf8ace573">&#9670;&#160;</a></span>AddConstraint() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds Lorentz cone constraint referencing potentially a subset of the decision variables. </p>
<p>The linear expression \( z=Ax+b \) is in the Lorentz cone. A vector \( z \in\mathbb{R}^n \) is in the Lorentz cone, if     </p><p class="formulaDsp">
\[z_0 \ge \sqrt{z_1^2 + ... + z_{n-1}^2}
\]
</p>
 
</div>
</div>
<a id="a7eaff79975646e0a4381f073a47c9974" name="a7eaff79975646e0a4381f073a47c9974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eaff79975646e0a4381f073a47c9974">&#9670;&#160;</a></span>AddConstraint() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a positive semidefinite constraint on a symmetric matrix. </p>

</div>
</div>
<a id="a5efeb642dbf02776438ca049a3e42c39" name="a5efeb642dbf02776438ca049a3e42c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5efeb642dbf02776438ca049a3e42c39">&#9670;&#160;</a></span>AddConstraint() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_constraint.html">QuadraticConstraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_constraint.html">QuadraticConstraint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds quadratic constraint. </p>
<p>The quadratic constraint is of the form lb ≤ .5 xᵀQx + bᵀx ≤ ub where <span class="tt">x</span> might be a subset of the decision variables in this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. Notice that if your quadratic constraint is convex, and you intend to solve the problem with a convex solver (like Mosek), then it is better to reformulate it with a second order cone constraint. See <a href="https://docs.mosek.com/11.1/capi/prob-def-quadratic.html#a-recommendation">https://docs.mosek.com/11.1/capi/prob-def-quadratic.html#a-recommendation</a> for an explanation. </p>

</div>
</div>
<a id="a63a80e477decc42724b9e814d70cc339" name="a63a80e477decc42724b9e814d70cc339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a80e477decc42724b9e814d70cc339">&#9670;&#160;</a></span>AddConstraint() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a rotated Lorentz cone constraint referencing potentially a subset of decision variables. </p>
<p>The linear expression \( z=Ax+b \) is in rotated Lorentz cone. A vector \( z \in\mathbb{R}^n \) is in the rotated Lorentz cone, if     </p><p class="formulaDsp">
\[z_0z_1 \ge z_2^2 + ... + z_{n-1}^2
\]
</p>
 
</div>
</div>
<a id="ace80ac92eb39cb00aeccd45c7b572cba" name="ace80ac92eb39cb00aeccd45c7b572cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace80ac92eb39cb00aeccd45c7b572cba">&#9670;&#160;</a></span>AddConstraint() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt; Derived, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>formulas</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a13da3f2f6edd0fd8b67178a75c29cbb5" name="a13da3f2f6edd0fd8b67178a75c29cbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13da3f2f6edd0fd8b67178a75c29cbb5">&#9670;&#160;</a></span>AddConstraint() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab94e40b82b4d9d62a702cf6636493416" name="ab94e40b82b4d9d62a702cf6636493416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94e40b82b4d9d62a702cf6636493416">&#9670;&#160;</a></span>AddConstraint() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>ub</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds one row of constraint lb &lt;= e &lt;= ub where <code class="param">e</code> is a symbolic expression. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if<ol type="1">
<li><span class="tt">lb &lt;= e &lt;= ub</span> is a trivial constraint such as 1 &lt;= 2 &lt;= 3.</li>
<li><span class="tt">lb &lt;= e &lt;= ub</span> is unsatisfiable such as 1 &lt;= -5 &lt;= 3</li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>A symbolic expression of the decision variables. </td></tr>
    <tr><td class="paramname">lb</td><td>A scalar, the lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>A scalar, the upper bound.</td></tr>
  </table>
  </dd>
</dl>
<p>The resulting constraint may be a <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html" title="Implements a constraint of the form .">BoundingBoxConstraint</a>, <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html" title="Implements a constraint of the form .">LinearConstraint</a>, <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html" title="Implements a constraint of the form .">LinearEqualityConstraint</a>, <a class="el" href="classdrake_1_1solvers_1_1_quadratic_constraint.html" title="lb ≤ .5 xᵀQx + bᵀx ≤ ub Without loss of generality, the class stores a symmetric matrix Q.">QuadraticConstraint</a>, or <a class="el" href="classdrake_1_1solvers_1_1_expression_constraint.html" title="Impose a generic (potentially nonlinear) constraint represented as a vector of symbolic Expression.">ExpressionConstraint</a>, depending on the arguments. Constraints of the form x == 1 (which could be created as a <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html" title="Implements a constraint of the form .">BoundingBoxConstraint</a> or <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html" title="Implements a constraint of the form .">LinearEqualityConstraint</a>) will be constructed as a <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html" title="Implements a constraint of the form .">LinearEqualityConstraint</a>. </p>

</div>
</div>
<a id="ae8d9bfe34ef20a9f343e518fccc40bd6" name="ae8d9bfe34ef20a9f343e518fccc40bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d9bfe34ef20a9f343e518fccc40bd6">&#9670;&#160;</a></span>AddConstraint() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a constraint represented by a symbolic formula to the program. </p>
<p>The input formula <code class="param">f</code> can be of the following forms:</p>
<ol type="1">
<li>e1 &lt;= e2</li>
<li>e1 &gt;= e2</li>
<li>e1 == e2</li>
<li>A conjunction of relational formulas where each conjunct is a relational formula matched by 1, 2, or 3.</li>
</ol>
<p>Note that first two cases might return an object of <a class="el" href="classdrake_1_1solvers_1_1_binding.html" title="A binding on constraint type C is a mapping of the decision variables onto the inputs of C.">Binding&lt;BoundingBoxConstraint&gt;</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html" title="A binding on constraint type C is a mapping of the decision variables onto the inputs of C.">Binding&lt;LinearConstraint&gt;</a>, or <a class="el" href="classdrake_1_1solvers_1_1_binding.html" title="A binding on constraint type C is a mapping of the decision variables onto the inputs of C.">Binding&lt;ExpressionConstraint&gt;</a>, depending on <code class="param">f</code>. Also the third case might return an object of <a class="el" href="classdrake_1_1solvers_1_1_binding.html" title="A binding on constraint type C is a mapping of the decision variables onto the inputs of C.">Binding&lt;LinearEqualityConstraint&gt;</a> or <a class="el" href="classdrake_1_1solvers_1_1_binding.html" title="A binding on constraint type C is a mapping of the decision variables onto the inputs of C.">Binding&lt;ExpressionConstraint&gt;</a>.</p>
<p>It throws an exception if</p><ol type="1">
<li><code class="param">f</code> is not matched with one of the above patterns. Especially, strict inequalities (&lt;, &gt;) are not allowed.</li>
<li><code class="param">f</code> is either a trivial constraint such as "1 &lt;= 2" or an unsatisfiable constraint such as "2 &lt;= 1".</li>
<li>It is not possible to find numerical bounds of <span class="tt">e1</span> and <span class="tt">e2</span> where <code class="param">f</code> = e1 ≃ e2. We allow <span class="tt">e1</span> and <span class="tt">e2</span> to be infinite but only if there are no other terms. For example, <span class="tt">x &lt;= ∞</span> is allowed. However, <span class="tt">x - ∞ &lt;= 0</span> is not allowed because <span class="tt">x ↦ ∞</span> introduces <span class="tt">nan</span> in the evaluation.</li>
</ol>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>A common use-case of this function is to add a constraint with the element-wise comparison between two Eigen matrices, using <span class="tt">A.array() &lt;= B.array()</span>. See the following example.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> prog;</div>
<div class="line">Eigen::Matrix&lt;double, 2, 2&gt; A = ...;</div>
<div class="line">Eigen::Vector2d b = ...;</div>
<div class="line"><span class="keyword">auto</span> x = prog.<a class="code hl_function" href="#a53949966a66a6f53ba90596fc5a439ef">NewContinuousVariables</a>(2, <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line">prog.<a class="code hl_function" href="#af05fa6863859ca8be0153e10c29def11">AddConstraint</a>((A * x).array() &lt;= b.array());</div>
<div class="ttc" id="aclassdrake_1_1solvers_1_1_mathematical_program_html_af05fa6863859ca8be0153e10c29def11"><div class="ttname"><a href="#af05fa6863859ca8be0153e10c29def11">drake::solvers::MathematicalProgram::AddConstraint</a></div><div class="ttdeci">Binding&lt; Constraint &gt; AddConstraint(const Binding&lt; Constraint &gt; &amp;binding)</div><div class="ttdoc">Adds a generic constraint to the program.</div></div>
</div><!-- fragment --><p>A formula in <code class="param">formulas</code> can be of the following forms:</p>
<ol type="1">
<li>e1 &lt;= e2</li>
<li>e1 &gt;= e2</li>
<li>e1 == e2</li>
</ol>
<p>It throws an exception if <a class="el" href="#ae8d9bfe34ef20a9f343e518fccc40bd6" title="Add a constraint represented by a symbolic formula to the program.">AddConstraint(const symbolic::Formula&amp; f)</a> throws an exception for f ∈ <code class="param">formulas</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>Eigen::Matrix or Eigen::Array with Formula as the Scalar. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d26f3d31c9cfba7144b9a0d96aebdd0" name="a8d26f3d31c9cfba7144b9a0d96aebdd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d26f3d31c9cfba7144b9a0d96aebdd0">&#9670;&#160;</a></span>AddConstraint() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto AddConstraint </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; C &gt;</td>          <td class="paramname"><span class="paramname"><em>con</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a generic constraint to the program. </p>
<p>This should only be used if a more specific type of constraint is not available, as it may require the use of a significantly more expensive solver. </p>

</div>
</div>
<a id="a0c28156f900997a8fb1b0079e30fce6d" name="a0c28156f900997a8fb1b0079e30fce6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c28156f900997a8fb1b0079e30fce6d">&#9670;&#160;</a></span>AddConstraint() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto AddConstraint </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; C &gt;</td>          <td class="paramname"><span class="paramname"><em>con</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a generic constraint to the program. </p>
<p>This should only be used if a more specific type of constraint is not available, as it may require the use of a significantly more expensive solver. </p>

</div>
</div>
<a id="a173507cceb8d15aa267a7dbb17466e7f" name="a173507cceb8d15aa267a7dbb17466e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173507cceb8d15aa267a7dbb17466e7f">&#9670;&#160;</a></span>AddConstraint() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>con</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>symmetric_matrix_var</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a positive semidefinite constraint on a symmetric matrix. </p>

</div>
</div>
<a id="a4efea1b480be940fe05070939b7954ac" name="a4efea1b480be940fe05070939b7954ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4efea1b480be940fe05070939b7954ac">&#9670;&#160;</a></span>AddCost() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; AddCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a generic cost to the optimization program. </p>

</div>
</div>
<a id="afdc73aabceb199326b321625c99a5830" name="afdc73aabceb199326b321625c99a5830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc73aabceb199326b321625c99a5830">&#9670;&#160;</a></span>AddCost() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a> &gt; AddCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an L2 norm cost |Ax+b|₂ (notice this cost is not quadratic since we don't take the square of the L2 norm). </p>
<p>Refer to AddL2NormCost for more details. </p>

</div>
</div>
<a id="af9361760e08efc82cecdb7d73abdaf08" name="af9361760e08efc82cecdb7d73abdaf08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9361760e08efc82cecdb7d73abdaf08">&#9670;&#160;</a></span>AddCost() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; AddCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term of the form c'*x. </p>
<p>Applied to a subset of the variables and pushes onto the linear cost data structure. </p>

</div>
</div>
<a id="a413bc850a691a89ffd076b6bfbd6ffea" name="a413bc850a691a89ffd076b6bfbd6ffea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413bc850a691a89ffd076b6bfbd6ffea">&#9670;&#160;</a></span>AddCost() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; AddCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term of the form 0.5*x'*Q*x + b'x. </p>
<p>Applied to subset of the variables and pushes onto the quadratic cost data structure. </p>

</div>
</div>
<a id="a60e141e79d84c40fbc83ea8e3aab7823" name="a60e141e79d84c40fbc83ea8e3aab7823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e141e79d84c40fbc83ea8e3aab7823">&#9670;&#160;</a></span>AddCost() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto AddCost </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; C &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost type to the optimization program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The added objective. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which the cost depend. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24f0ccf74cf7be71ca7bc12d81051cad" name="a24f0ccf74cf7be71ca7bc12d81051cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f0ccf74cf7be71ca7bc12d81051cad">&#9670;&#160;</a></span>AddCost() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto AddCost </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; C &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>obj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a generic cost to the optimization program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The added objective. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which the cost depend. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adeaa05fb1b97a02f8d14c393bebe68bf" name="adeaa05fb1b97a02f8d14c393bebe68bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeaa05fb1b97a02f8d14c393bebe68bf">&#9670;&#160;</a></span>AddCost() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; AddCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost in the symbolic form. </p>
<dl class="section return"><dt>Returns</dt><dd>The newly created cost, together with the bound variables. </dd></dl>

</div>
</div>
<a id="a93a41a9cfddad5b3219e961cd3c86f3a" name="a93a41a9cfddad5b3219e961cd3c86f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a41a9cfddad5b3219e961cd3c86f3a">&#9670;&#160;</a></span>AddCost() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F, typename Vars&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; internal::assert_if_is_constraint&lt; F &gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &gt; AddCost </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vars &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically assert if a user inadvertently passes a binding-compatible <a class="el" href="classdrake_1_1solvers_1_1_constraint.html" title="A constraint is a function + lower and upper bounds.">Constraint</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a134462c636b25fa7dfd0826f3984aaf3" name="a134462c636b25fa7dfd0826f3984aaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134462c636b25fa7dfd0826f3984aaf3">&#9670;&#160;</a></span>AddCost() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; internal::is_cost_functor_candidate&lt; F &gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &gt; AddCost </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost to the optimization program on an Eigen::Vector containing decision variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Type that defines functions numInputs, numOutputs and eval. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b9d222353fbde88b65460b4d127dfad" name="a7b9d222353fbde88b65460b4d127dfad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9d222353fbde88b65460b4d127dfad">&#9670;&#160;</a></span>AddCost() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; internal::is_cost_functor_candidate&lt; F &gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &gt; AddCost </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost to the optimization program on a list of variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>it should define functions numInputs, numOutputs and eval. Check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af436a548cfc2a209dc21427b328232b2" name="af436a548cfc2a209dc21427b328232b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af436a548cfc2a209dc21427b328232b2">&#9670;&#160;</a></span>AddDecisionVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddDecisionVariables </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>decision_variables</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends new variables to the end of the existing variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">decision_variables</td><td>The newly added decision_variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="#a8edf415633915556308470787995a6a0" title="Getter for all decision variables in the program.">decision_variables</a></span> should not intersect with the existing indeterminates in the optimization program. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the preconditions are not satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab52b4d6027e7d8a8fe8c1d6e8f0817b" name="aab52b4d6027e7d8a8fe8c1d6e8f0817b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab52b4d6027e7d8a8fe8c1d6e8f0817b">&#9670;&#160;</a></span>AddEqualityConstraintBetweenPolynomials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &gt; AddEqualityConstraintBetweenPolynomials </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constraining that two polynomials are the same (i.e., they have the same coefficients for each monomial). </p>
<p>This function is often used in sum-of-squares optimization. We will impose the linear equality constraint that the coefficient of a monomial in <code class="param">p1</code> is the same as the coefficient of the same monomial in <code class="param">p2</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>Note that p1's indeterminates should have been registered as indeterminates in this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> object, and p1's coefficients are affine functions of decision variables in this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> object. </td></tr>
    <tr><td class="paramname">p2</td><td>Note that p2's indeterminates should have been registered as indeterminates in this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> object, and p2's coefficients are affine functions of decision variables in this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It calls <span class="tt"><a class="el" href="#aee9493ea7d08a35395634bfbfd5713dd" title="Reparses the polynomial p using this MathematicalProgram&#39;s indeterminates.">Reparse</a></span> to enforce <span class="tt">p1</span> and <span class="tt">p2</span> to have this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>'s indeterminates. </dd></dl>

</div>
</div>
<a id="aa3139dbcbdf76b2b036f38aaa11a01f2" name="aa3139dbcbdf76b2b036f38aaa11a01f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3139dbcbdf76b2b036f38aaa11a01f2">&#9670;&#160;</a></span>AddExponentialConeConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html">ExponentialConeConstraint</a> &gt; AddExponentialConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::SparseMatrix&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an exponential cone constraint, that z = A * vars + b should be in the exponential cone. </p>
<p>Namely {z₀, z₁, z₂ | z₀ ≥ z₁ * exp(z₂ / z₁), z₁ &gt; 0}, or equivalently (using the logarithm function), {z₀, z₁, z₂ | z₂ ≤ z₁ * log(z₀ / z₁), z₀ &gt; 0, z₁ &gt; 0}. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The A matrix in the documentation above. A must have 3 rows. </td></tr>
    <tr><td class="paramname">b</td><td>The b vector in the documentation above. </td></tr>
    <tr><td class="paramname">vars</td><td>The variables bound with this constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc55d94a5a55f8e03d0797c6f9d98e11" name="acc55d94a5a55f8e03d0797c6f9d98e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc55d94a5a55f8e03d0797c6f9d98e11">&#9670;&#160;</a></span>AddExponentialConeConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html">ExponentialConeConstraint</a> &gt; AddExponentialConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>z</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the constraint that z is in the exponential cone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>The expression in the exponential cone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>each entry in <span class="tt">z</span> is a linear expression of the decision variables. </dd></dl>

</div>
</div>
<a id="a100c35ec0287aaded41a390e0fe95e4b" name="a100c35ec0287aaded41a390e0fe95e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100c35ec0287aaded41a390e0fe95e4b">&#9670;&#160;</a></span>AddIndeterminate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AddIndeterminate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>new_indeterminate</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminate. </p>
<p>This method appends an indeterminate to the end of the program's old indeterminates, if <span class="tt">new_indeterminate</span> is not already in the program's old indeterminates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_indeterminate</td><td>The indeterminate to be appended to the program's old indeterminates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>indeterminate_index The index of the added indeterminate in the program's indeterminates. i.e. prog.indeterminates()(indeterminate_index) = new_indeterminate. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">new_indeterminate</span> should not intersect with the program's decision variables. </dd>
<dd>
new_indeterminate should be of CONTINUOUS type. </dd></dl>

</div>
</div>
<a id="a1d17877e373279d18488f21836285539" name="a1d17877e373279d18488f21836285539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d17877e373279d18488f21836285539">&#9670;&#160;</a></span>AddIndeterminates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddIndeterminates </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#a7ab45e84bec7fad9608e19ae3441b0bf">MatrixXIndeterminate</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>new_indeterminates</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates. </p>
<p>This method appends some indeterminates to the end of the program's old indeterminates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_indeterminates</td><td>The indeterminates to be appended to the program's old indeterminates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">new_indeterminates</span> should not intersect with the program's old decision variables. </dd>
<dd>
Each entry in new_indeterminates should be of CONTINUOUS type. </dd></dl>

</div>
</div>
<a id="a4b39856ec07e10a4f9f9980dbc33ef98" name="a4b39856ec07e10a4f9f9980dbc33ef98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b39856ec07e10a4f9f9980dbc33ef98">&#9670;&#160;</a></span>AddIndeterminates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddIndeterminates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>new_indeterminates</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates. </p>
<p>This method appends some indeterminates to the end of the program's old indeterminates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_indeterminates</td><td>The indeterminates to be appended to the program's old indeterminates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">new_indeterminates</span> should not intersect with the program's old decision variables. </dd>
<dd>
Each entry in new_indeterminates should be of CONTINUOUS type. </dd></dl>

</div>
</div>
<a id="a17183b1ac9b0e70ccc15924ae754baf1" name="a17183b1ac9b0e70ccc15924ae754baf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17183b1ac9b0e70ccc15924ae754baf1">&#9670;&#160;</a></span>AddL1NormCostInEpigraphForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; &gt; AddL1NormCostInEpigraphForm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an L1 norm cost min |Ax+b|₁ as a linear cost min Σᵢsᵢ on the slack variables sᵢ, together with the constraints (for each i) sᵢ ≥ (|Ax+b|)ᵢ, which itself is written sᵢ ≥ (Ax+b)ᵢ and sᵢ ≥ -(Ax+b)ᵢ. </p>
<dl class="section return"><dt>Returns</dt><dd>(s, linear_cost, linear_constraint). <span class="tt">s</span> is the vector of slack variables, <span class="tt">linear_cost</span> is the cost on <span class="tt">s</span>, and <span class="tt">linear_constraint</span> is the constraint encoding s ≥ Ax+b and s ≥ -(Ax+b). </dd></dl>

</div>
</div>
<a id="af8e539e3c7e8f00f5d161de118fd9c8a" name="af8e539e3c7e8f00f5d161de118fd9c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e539e3c7e8f00f5d161de118fd9c8a">&#9670;&#160;</a></span>AddL2NormCost() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a> &gt; AddL2NormCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an L2 norm cost |Ax+b|₂ (notice this cost is not quadratic since we don't take the square of the L2 norm). </p>
<dl class="section note"><dt>Note</dt><dd>Currently kL2NormCost is supported by <a class="el" href="classdrake_1_1solvers_1_1_snopt_solver.html" title="An implementation of SolverInterface for the commercially-licensed SNOPT solver (https://ccom....">SnoptSolver</a>, <a class="el" href="classdrake_1_1solvers_1_1_ipopt_solver.html" title="A wrapper to call Ipopt using Drake&#39;s MathematicalProgram.">IpoptSolver</a>, <a class="el" href="classdrake_1_1solvers_1_1_nlopt_solver.html">NloptSolver</a>, <a class="el" href="classdrake_1_1solvers_1_1_gurobi_solver.html" title="An implementation of SolverInterface for the commercially-licensed Gurobi solver (https://www....">GurobiSolver</a>, <a class="el" href="classdrake_1_1solvers_1_1_mosek_solver.html" title="An implementation of SolverInterface for the commercially-licensed MOSEK (TM) solver (https://www....">MosekSolver</a>, <a class="el" href="classdrake_1_1solvers_1_1_clarabel_solver.html" title="An interface to wrap Clarabel https://github.com/oxfordcontrol/Clarabel.cpp.">ClarabelSolver</a>, and SCSSolver. </dd></dl>

</div>
</div>
<a id="a11b78e6a556d483d18fe712ee19d35a2" name="a11b78e6a556d483d18fe712ee19d35a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b78e6a556d483d18fe712ee19d35a2">&#9670;&#160;</a></span>AddL2NormCost() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a> &gt; AddL2NormCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an L2 norm cost |Ax+b|₂ (notice this cost is not quadratic since we don't take the square of the L2 norm). </p>

</div>
</div>
<a id="ab79f3a268966d52e8100cba853f76a20" name="ab79f3a268966d52e8100cba853f76a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79f3a268966d52e8100cba853f76a20">&#9670;&#160;</a></span>AddL2NormCost() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a> &gt; AddL2NormCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>psd_tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-8</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>coefficient_tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-8</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an L2 norm cost |Ax+b|₂ from a symbolic expression which can be decomposed into sqrt((Ax+b)'(Ax+b)). </p>
<p>See <a class="el" href="namespacedrake_1_1symbolic.html#a70b04dbbe04340ba67a5af39b6c0f277" title="Decomposes an L2 norm e = |Ax+b|₂ into A, b, and the variable vector x (or returns false if the decom...">symbolic::DecomposeL2NormExpression</a> for details on the tolerance parameters. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code class="param">e</code> cannot be decomposed into an L2 norm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2dfbbcf57de566c360a3e268fbe4d64" name="af2dfbbcf57de566c360a3e268fbe4d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2dfbbcf57de566c360a3e268fbe4d64">&#9670;&#160;</a></span>AddL2NormCostUsingConicConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; &gt; AddL2NormCostUsingConicConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an L2 norm cost min |Ax+b|₂ as a linear cost min s on the slack variable s, together with a Lorentz cone constraint s ≥ |Ax+b|₂ Many conic optimization solvers (Gurobi, MOSEK<a href="/tm.html">™</a>, SCS, etc) natively prefers this form of linear cost + conic constraints. </p>
<p>So if you are going to use one of these conic solvers, then add the L2 norm cost using this function instead of <a class="el" href="#af8e539e3c7e8f00f5d161de118fd9c8a" title="Adds an L2 norm cost |Ax+b|₂ (notice this cost is not quadratic since we don&#39;t take the square of the...">AddL2NormCost()</a>. </p><dl class="section return"><dt>Returns</dt><dd>(s, linear_cost, lorentz_cone_constraint). <span class="tt">s</span> is the slack variable (with variable name string as "slack"), <span class="tt">linear_cost</span> is the cost on <span class="tt">s</span>, and <span class="tt">lorentz_cone_constraint</span> is the constraint s≥|Ax+b|₂ </dd></dl>

</div>
</div>
<a id="ad946ddf713f3d8f248c417cf9b728ec8" name="ad946ddf713f3d8f248c417cf9b728ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad946ddf713f3d8f248c417cf9b728ec8">&#9670;&#160;</a></span>AddLinearComplementarityConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt; AddLinearComplementarityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear complementarity constraints referencing a subset of the decision variables. </p>

</div>
</div>
<a id="a39207cb8b0a32fdcda7d36d10700388d" name="a39207cb8b0a32fdcda7d36d10700388d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39207cb8b0a32fdcda7d36d10700388d">&#9670;&#160;</a></span>AddLinearComplementarityConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt; AddLinearComplementarityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear complementarity constraints referencing a subset of the decision variables. </p>

</div>
</div>
<a id="ae6ce8aa8d46b8d82cb7f8f5b10e7e83d" name="ae6ce8aa8d46b8d82cb7f8f5b10e7e83d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ce8aa8d46b8d82cb7f8f5b10e7e83d">&#9670;&#160;</a></span>AddLinearConstraint() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>formulas</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a linear constraint represented by an Eigen::Array&lt;symbolic::Formula&gt; to the program. </p>
<p>A common use-case of this function is to add a linear constraint with the element-wise comparison between two Eigen matrices, using <span class="tt">A.array() &lt;= B.array()</span>. See the following example.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> prog;</div>
<div class="line">Eigen::Matrix&lt;double, 2, 2&gt; A;</div>
<div class="line"><span class="keyword">auto</span> x = prog.<a class="code hl_function" href="#a53949966a66a6f53ba90596fc5a439ef">NewContinuousVariables</a>(2, <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line">Eigen::Vector2d b;</div>
<div class="line">... <span class="comment">// set up A and b</span></div>
<div class="line">prog.<a class="code hl_function" href="#ae73446f6e62cec6b42e8331a63fecd80">AddLinearConstraint</a>((A * x).array() &lt;= b.array());</div>
<div class="ttc" id="aclassdrake_1_1solvers_1_1_mathematical_program_html_ae73446f6e62cec6b42e8331a63fecd80"><div class="ttname"><a href="#ae73446f6e62cec6b42e8331a63fecd80">drake::solvers::MathematicalProgram::AddLinearConstraint</a></div><div class="ttdeci">Binding&lt; LinearConstraint &gt; AddLinearConstraint(const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub, const VariableRefList &amp;vars)</div><div class="ttdoc">Adds linear constraints referencing potentially a subset of the decision variables (defined in the va...</div><div class="ttdef"><b>Definition</b> mathematical_program.h:1528</div></div>
</div><!-- fragment --><p>A formula in <code class="param">formulas</code> can be of the following forms:</p>
<ol type="1">
<li>e1 &lt;= e2</li>
<li>e1 &gt;= e2</li>
<li>e1 == e2</li>
</ol>
<p>It throws an exception if <a class="el" href="#a1ecde2056d0658ea4dac1c0e632ad353" title="Add a linear constraint represented by a symbolic formula to the program.">AddLinearConstraint(const symbolic::Formula&amp; f)</a> throws an exception for f ∈ <code class="param">formulas</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>An Eigen Array type of Formula. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae78a44ed429e0dea8964470adbb46218" name="ae78a44ed429e0dea8964470adbb46218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78a44ed429e0dea8964470adbb46218">&#9670;&#160;</a></span>AddLinearConstraint() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds linear constraints referencing potentially a subset of the decision variables (defined in the vars parameter). </p>

</div>
</div>
<a id="ae73446f6e62cec6b42e8331a63fecd80" name="ae73446f6e62cec6b42e8331a63fecd80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73446f6e62cec6b42e8331a63fecd80">&#9670;&#160;</a></span>AddLinearConstraint() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds linear constraints referencing potentially a subset of the decision variables (defined in the vars parameter). </p>

</div>
</div>
<a id="a02f751c03b19f886921c96bce594708f" name="a02f751c03b19f886921c96bce594708f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f751c03b19f886921c96bce594708f">&#9670;&#160;</a></span>AddLinearConstraint() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds one row of linear constraint referencing potentially a subset of the decision variables (defined in the vars parameter). </p>
<p>lb &lt;= a*vars &lt;= ub </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A row vector. </td></tr>
    <tr><td class="paramname">lb</td><td>A scalar, the lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>A scalar, the upper bound. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which to impose the linear constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab33fe7b6e2383345d0293ab53cb08cf9" name="ab33fe7b6e2383345d0293ab53cb08cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33fe7b6e2383345d0293ab53cb08cf9">&#9670;&#160;</a></span>AddLinearConstraint() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds one row of linear constraint referencing potentially a subset of the decision variables (defined in the vars parameter). </p>
<p>lb &lt;= a*vars &lt;= ub </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A row vector. </td></tr>
    <tr><td class="paramname">lb</td><td>A scalar, the lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>A scalar, the upper bound. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which to impose the linear constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf32b3d53ae76435192532f9c013014d" name="adf32b3d53ae76435192532f9c013014d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf32b3d53ae76435192532f9c013014d">&#9670;&#160;</a></span>AddLinearConstraint() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds linear constraints represented by symbolic expressions to the program. </p>
<p>It throws if @v includes a non-linear expression or <span class="tt">lb &lt;= v &lt;=
ub</span> includes trivial/unsatisfiable constraints. </p>

</div>
</div>
<a id="a04044b1066ad9f2b70e24e283551d900" name="a04044b1066ad9f2b70e24e283551d900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04044b1066ad9f2b70e24e283551d900">&#9670;&#160;</a></span>AddLinearConstraint() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds sparse linear constraints referencing potentially a subset of the decision variables (defined in the vars parameter). </p>

</div>
</div>
<a id="abae6b3bdbb778be79abe20f3f977b1a9" name="abae6b3bdbb778be79abe20f3f977b1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae6b3bdbb778be79abe20f3f977b1a9">&#9670;&#160;</a></span>AddLinearConstraint() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds sparse linear constraints referencing potentially a subset of the decision variables (defined in the vars parameter). </p>

</div>
</div>
<a id="a11440aef6df9ddedfd6675ce56fe6e16" name="a11440aef6df9ddedfd6675ce56fe6e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11440aef6df9ddedfd6675ce56fe6e16">&#9670;&#160;</a></span>AddLinearConstraint() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>ub</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds one row of linear constraint lb &lt;= e &lt;= ub where <code class="param">e</code> is a symbolic expression. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if<ol type="1">
<li><code class="param">e</code> is a non-linear expression.</li>
<li><span class="tt">lb &lt;= e &lt;= ub</span> is a trivial constraint such as 1 &lt;= 2 &lt;= 3.</li>
<li><span class="tt">lb &lt;= e &lt;= ub</span> is unsatisfiable such as 1 &lt;= -5 &lt;= 3</li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>A linear symbolic expression in the form of <span class="tt">c0 + c1 * v1 +
... + cn * vn</span> where <code>c_i</code> is a constant and @v_i is a variable. </td></tr>
    <tr><td class="paramname">lb</td><td>A scalar, the lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>A scalar, the upper bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ecde2056d0658ea4dac1c0e632ad353" name="a1ecde2056d0658ea4dac1c0e632ad353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ecde2056d0658ea4dac1c0e632ad353">&#9670;&#160;</a></span>AddLinearConstraint() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a linear constraint represented by a symbolic formula to the program. </p>
<p>The input formula <code class="param">f</code> can be of the following forms:</p>
<ol type="1">
<li>e1 &lt;= e2</li>
<li>e1 &gt;= e2</li>
<li>e1 == e2</li>
<li>A conjunction of relational formulas where each conjunct is a relational formula matched by 1, 2, or 3.</li>
</ol>
<p>Note that first two cases might return an object of <a class="el" href="classdrake_1_1solvers_1_1_binding.html" title="A binding on constraint type C is a mapping of the decision variables onto the inputs of C.">Binding&lt;BoundingBoxConstraint&gt;</a> depending on <code class="param">f</code>. Also the third case returns an object of <a class="el" href="classdrake_1_1solvers_1_1_binding.html" title="A binding on constraint type C is a mapping of the decision variables onto the inputs of C.">Binding&lt;LinearEqualityConstraint&gt;</a>.</p>
<p>It throws an exception if</p><ol type="1">
<li><code class="param">f</code> is not matched with one of the above patterns. Especially, strict inequalities (&lt;, &gt;) are not allowed.</li>
<li><code class="param">f</code> includes a non-linear expression.</li>
<li><code class="param">f</code> is either a trivial constraint such as "1 &lt;= 2" or an unsatisfiable constraint such as "2 &lt;= 1".</li>
<li>It is not possible to find numerical bounds of <span class="tt">e1</span> and <span class="tt">e2</span> where <code class="param">f</code> = e1 ≃ e2. We allow <span class="tt">e1</span> and <span class="tt">e2</span> to be infinite but only if there are no other terms. For example, <span class="tt">x &lt;= ∞</span> is allowed. However, <span class="tt">x - ∞ &lt;= 0</span> is not allowed because <span class="tt">x ↦ ∞</span> introduces <span class="tt">nan</span> in the evaluation. </li>
</ol>

</div>
</div>
<a id="a7be5ae4905aa3e7a043f800bf02d7539" name="a7be5ae4905aa3e7a043f800bf02d7539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be5ae4905aa3e7a043f800bf02d7539">&#9670;&#160;</a></span>AddLinearCost() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">VarType</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; AddLinearCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">VarType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear cost term of the form a'*x. </p>
<p>Applied to a subset of the variables and pushes onto the linear cost data structure. </p>

</div>
</div>
<a id="a3bc63e8400b182a07b2b9372a4418114" name="a3bc63e8400b182a07b2b9372a4418114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc63e8400b182a07b2b9372a4418114">&#9670;&#160;</a></span>AddLinearCost() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; AddLinearCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear cost term of the form a'*x + b. </p>
<p>Applied to a subset of the variables and pushes onto the linear cost data structure. </p>

</div>
</div>
<a id="afbe6af66a54f99a1274bf4004fc5a7a1" name="afbe6af66a54f99a1274bf4004fc5a7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe6af66a54f99a1274bf4004fc5a7a1">&#9670;&#160;</a></span>AddLinearCost() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; AddLinearCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear cost term of the form a'*x + b. </p>
<p>Applied to a subset of the variables and pushes onto the linear cost data structure. </p>

</div>
</div>
<a id="a8a8dae8551794a05aadea978f2ae5ae3" name="a8a8dae8551794a05aadea978f2ae5ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8dae8551794a05aadea978f2ae5ae3">&#9670;&#160;</a></span>AddLinearCost() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; AddLinearCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear cost term of the form a'*x + b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>A linear symbolic expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>e is a linear expression a'*x + b, where each entry of x is a decision variable in the mathematical program. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added linear constraint, together with the bound variables. </dd></dl>

</div>
</div>
<a id="a52e173057b32bdbc6cd4c0a91273155a" name="a52e173057b32bdbc6cd4c0a91273155a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e173057b32bdbc6cd4c0a91273155a">&#9670;&#160;</a></span>AddLinearEqualityConstraint() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__vector__expression__double__pair.html">is_eigen_vector_expression_double_pair</a>&lt; DerivedV, DerivedB &gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds linear equality constraints \( v = b \), where <code class="param">v(i)</code> is a symbolic linear expression. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if<ol type="1">
<li><code class="param">v(i)</code> is a non-linear expression.</li>
<li><code class="param">v(i)</code> is a constant.</li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>An Eigen Matrix type of Expression. A column vector. </td></tr>
    <tr><td class="paramname">DerivedB</td><td>An Eigen Matrix type of double. A column vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>v(i) is a linear symbolic expression in the form of <span class="tt"> c0 + c1 * x1 + ... + cn * xn </span> where ci is a constant and @xi is a variable. </td></tr>
    <tr><td class="paramname">b</td><td>A vector of doubles. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added linear equality constraint, together with the bound variables. </dd></dl>

</div>
</div>
<a id="af564a395db829d7ef259f7e0fda590d1" name="af564a395db829d7ef259f7e0fda590d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af564a395db829d7ef259f7e0fda590d1">&#9670;&#160;</a></span>AddLinearEqualityConstraint() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__nonvector__expression__double__pair.html">is_eigen_nonvector_expression_double_pair</a>&lt; DerivedV, DerivedB &gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>V</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>lower_triangle</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear equality constraint for a matrix of linear expression <code class="param">V</code>, such that V(i, j) = B(i, j). </p>
<p>If V is a symmetric matrix, then the user may only want to constrain the lower triangular part of V. This function is meant to provide convenience to the user, it incurs additional copy and memory allocation. For faster speed, add each column of the matrix equality in a for loop. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>An Eigen Matrix type of Expression. The number of columns at compile time should not be 1. </td></tr>
    <tr><td class="paramname">DerivedB</td><td>An Eigen Matrix type of double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>An Eigen Matrix of symbolic expressions. V(i, j) should be a linear expression. </td></tr>
    <tr><td class="paramname">B</td><td>An Eigen Matrix of doubles. </td></tr>
    <tr><td class="paramname">lower_triangle</td><td>If true, then only the lower triangular part of <code class="param">V</code> is constrained, otherwise the whole matrix V is constrained. <br  />
 <em class="arg">Default:</em> is false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added linear equality constraint, together with the bound variables. </dd></dl>

</div>
</div>
<a id="a8a21f874c214118c63e2b954eb330e60" name="a8a21f874c214118c63e2b954eb330e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a21f874c214118c63e2b954eb330e60">&#9670;&#160;</a></span>AddLinearEqualityConstraint() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a>, Eigen::Dynamic, Eigen::Dynamic &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>formulas</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear equality constraint represented by an Eigen::Array&lt;symbolic::Formula&gt; to the program. </p>
<p>A common use-case of this function is to add a linear constraint with the element-wise comparison between two Eigen matrices, using <span class="tt">A.array() == B.array()</span>. See the following example.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> prog;</div>
<div class="line">Eigen::Matrix&lt;double, 2, 2&gt; A;</div>
<div class="line"><span class="keyword">auto</span> x = prog.<a class="code hl_function" href="#a53949966a66a6f53ba90596fc5a439ef">NewContinuousVariables</a>(2, <span class="stringliteral">&quot;x&quot;</span>);</div>
<div class="line">Eigen::Vector2d b;</div>
<div class="line">... <span class="comment">// set up A and b</span></div>
<div class="line">prog.<a class="code hl_function" href="#ae73446f6e62cec6b42e8331a63fecd80">AddLinearConstraint</a>((A * x).array() == b.array());</div>
</div><!-- fragment --><p>It throws an exception if <a class="el" href="#a1ecde2056d0658ea4dac1c0e632ad353" title="Add a linear constraint represented by a symbolic formula to the program.">AddLinearConstraint(const symbolic::Formula&amp; f)</a> throws an exception for f ∈ <span class="tt">formulas</span>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>An Eigen Array type of Formula. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7cd4f274bef65432200b7af16fd9547" name="ae7cd4f274bef65432200b7af16fd9547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7cd4f274bef65432200b7af16fd9547">&#9670;&#160;</a></span>AddLinearEqualityConstraint() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Aeq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>beq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AddLinearEqualityConstraint. </p>
<p>Adds linear equality constraints referencing potentially a subset of the decision variables.</p>
<p>Example: to add two equality constraints which only depend on two of the elements of x, you could use </p><div class="fragment"><div class="line"><span class="keyword">auto</span> x = prog.NewContinuousVariables(6,<span class="stringliteral">&quot;myvar&quot;</span>);</div>
<div class="line">Eigen::Matrix2d Aeq;</div>
<div class="line">Aeq &lt;&lt; -1, 2,</div>
<div class="line">        1, 1;</div>
<div class="line">Eigen::Vector2d beq(1, 3);</div>
<div class="line"><span class="comment">// Imposes constraint</span></div>
<div class="line"><span class="comment">// -x(0) + 2x(1) = 1</span></div>
<div class="line"><span class="comment">//  x(0) +  x(1) = 3</span></div>
<div class="line">prog.AddLinearEqualityConstraint(Aeq, beq, x.head&lt;2&gt;());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9de4ad8b35749c5d243bc7d7d30c9cce" name="a9de4ad8b35749c5d243bc7d7d30c9cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de4ad8b35749c5d243bc7d7d30c9cce">&#9670;&#160;</a></span>AddLinearEqualityConstraint() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Aeq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>beq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AddLinearEqualityConstraint. </p>
<p>Adds linear equality constraints referencing potentially a subset of the decision variables.</p>
<p>Example: to add two equality constraints which only depend on two of the elements of x, you could use </p><div class="fragment"><div class="line"><span class="keyword">auto</span> x = prog.NewContinuousVariables(6,<span class="stringliteral">&quot;myvar&quot;</span>);</div>
<div class="line">Eigen::Matrix2d Aeq;</div>
<div class="line">Aeq &lt;&lt; -1, 2,</div>
<div class="line">        1, 1;</div>
<div class="line">Eigen::Vector2d beq(1, 3);</div>
<div class="line">prog.AddLinearEqualityConstraint(Aeq, beq, {x.segment&lt;1&gt;(2),</div>
<div class="line">                                 x.segment&lt;1&gt;(5)});</div>
</div><!-- fragment --><p> The code above imposes constraints </p><p class="formulaDsp">
\[-x(2) + 2x(5) = 1 \]
</p>
 <p class="formulaDsp">
\[ x(2) +  x(5) = 3 \]
</p>
 
</div>
</div>
<a id="aea3c78c0bceb34690aeb9c1bc4623a08" name="aea3c78c0bceb34690aeb9c1bc4623a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3c78c0bceb34690aeb9c1bc4623a08">&#9670;&#160;</a></span>AddLinearEqualityConstraint() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>beq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds one row of linear equality constraint referencing potentially a subset of decision variables. </p>
<p class="formulaDsp">
\[ax = beq
\]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A row vector. </td></tr>
    <tr><td class="paramname">beq</td><td>A scalar. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which the constraint is imposed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9655ba551c55797c1e8f09726df7cd83" name="a9655ba551c55797c1e8f09726df7cd83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9655ba551c55797c1e8f09726df7cd83">&#9670;&#160;</a></span>AddLinearEqualityConstraint() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>beq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds one row of linear equality constraint referencing potentially a subset of decision variables. </p>
<p class="formulaDsp">
\[ax = beq
\]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A row vector. </td></tr>
    <tr><td class="paramname">beq</td><td>A scalar. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which the constraint is imposed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7686a606e69b00659edb6bf58c6f359a" name="a7686a606e69b00659edb6bf58c6f359a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7686a606e69b00659edb6bf58c6f359a">&#9670;&#160;</a></span>AddLinearEqualityConstraint() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Aeq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>beq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AddLinearEqualityConstraint. </p>
<p>Adds linear equality constraints referencing potentially a subset of the decision variables using a sparse A matrix. </p>

</div>
</div>
<a id="aed0a437321c66db371e91c105278cbdb" name="aed0a437321c66db371e91c105278cbdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0a437321c66db371e91c105278cbdb">&#9670;&#160;</a></span>AddLinearEqualityConstraint() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Aeq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>beq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AddLinearEqualityConstraint. </p>
<p>Adds linear equality constraints referencing potentially a subset of the decision variables using a sparse A matrix. </p>

</div>
</div>
<a id="adce9200575be00912b9f62ee4ea53599" name="adce9200575be00912b9f62ee4ea53599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce9200575be00912b9f62ee4ea53599">&#9670;&#160;</a></span>AddLinearEqualityConstraint() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds one row of linear constraint e = b where <code class="param">e</code> is a symbolic expression. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if<ol type="1">
<li><code class="param">e</code> is a non-linear expression.</li>
<li><code class="param">e</code> is a constant.</li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>A linear symbolic expression in the form of <span class="tt">c0 + c1 * x1 +
... + cn * xn</span> where <code>c_i</code> is a constant and @x_i is a variable. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added linear equality constraint, together with the bound variable. </dd></dl>

</div>
</div>
<a id="a51f626f98cede0db08541462de301bf9" name="a51f626f98cede0db08541462de301bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f626f98cede0db08541462de301bf9">&#9670;&#160;</a></span>AddLinearEqualityConstraint() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear equality constraint represented by a symbolic formula to the program. </p>
<p>The input formula <code class="param">f</code> is either an equality formula (<span class="tt">e1 == e2</span>) or a conjunction of equality formulas.</p>
<p>It throws an exception if</p>
<ol type="1">
<li><code class="param">f</code> is neither an equality formula nor a conjunction of equalities.</li>
<li><code class="param">f</code> includes a non-linear expression. </li>
</ol>

</div>
</div>
<a id="ad4ef453a8a303d9d6f690017dbce1e28" name="ad4ef453a8a303d9d6f690017dbce1e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ef453a8a303d9d6f690017dbce1e28">&#9670;&#160;</a></span>AddLinearMatrixInequalityConstraint() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt; AddLinearMatrixInequalityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear matrix inequality constraint on a symmetric matrix of symbolic expressions <span class="tt">X</span>, namely <span class="tt">X</span> is positive semidefinite, and each entry in <span class="tt">X</span> is a linear (affine) expression of decision variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>Imposes constraint "X is positive semidefinite". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>X is symmetric. </dd>
<dd>
X(i, j) is linear (affine) for all i, j</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added linear matrix inequality constraint. </dd></dl>

</div>
</div>
<a id="a7efb262a19eb2917e4081a602ccc935b" name="a7efb262a19eb2917e4081a602ccc935b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7efb262a19eb2917e4081a602ccc935b">&#9670;&#160;</a></span>AddLinearMatrixInequalityConstraint() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt; AddLinearMatrixInequalityConstraint </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Eigen::MatrixXd &gt;</td>          <td class="paramname"><span class="paramname"><em>F</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear matrix inequality constraint to the program. </p>

</div>
</div>
<a id="a2c01095865c3167e561093efa629b9cc" name="a2c01095865c3167e561093efa629b9cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c01095865c3167e561093efa629b9cc">&#9670;&#160;</a></span>AddLinearMatrixInequalityConstraint() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt; AddLinearMatrixInequalityConstraint </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Eigen::MatrixXd &gt;</td>          <td class="paramname"><span class="paramname"><em>F</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear matrix inequality constraint to the program. </p>

</div>
</div>
<a id="a49456fc8e174f6f6b3e74f901b2ca5b8" name="a49456fc8e174f6f6b3e74f901b2ca5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49456fc8e174f6f6b3e74f901b2ca5b8">&#9670;&#160;</a></span>AddLogDeterminantLowerBoundConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; AddLogDeterminantLowerBoundConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>lower</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Impose the constraint log(det(X)) &gt;= lower. </p>
<p>See <a class="el" href="#log_determinant">log_determinant</a> for more details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>A symmetric positive semidefinite matrix X. </td></tr>
    <tr><td class="paramname">lower</td><td>The lower bound of log(det(X)) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(constraint, t, Z) constraint is ∑ᵢt(i) &gt;= lower, we also return the newly created slack variables t and the lower triangular matrix Z. Note that Z is not a matrix of <a class="el" href="classdrake_1_1symbolic_1_1_variable.html" title="Represents a symbolic variable.">symbolic::Variable</a> but <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>, because the upper-diagonal entries of Z are not variable, but expression 0. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>X is a symmetric matrix. </dd></dl>

</div>
</div>
<a id="a60d7aa71c11c26ede234178cdef50ed6" name="a60d7aa71c11c26ede234178cdef50ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d7aa71c11c26ede234178cdef50ed6">&#9670;&#160;</a></span>AddLorentzConeConstraint() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rows&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; AddLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; <a class="el" href="namespacedrake_1_1solvers.html#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a>&lt; rows &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a></td>          <td class="paramname"><span class="paramname"><em>eval_type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imposes that a vector \( x\in\mathbb{R}^m \) lies in Lorentz cone. </p>
<p>Namely   </p><p class="formulaDsp">
\[x_0 \ge \sqrt{x_1^2 + .. + x_{m-1}^2}
\]
</p>
   <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vars</td><td>The stacked column of vars should lie within the Lorentz cone. </td></tr>
    <tr><td class="paramname">eval_type</td><td>The evaluation type when evaluating the lorentz cone constraint in generic optimization. Refer to <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4" title="We provide three possible Eval functions to represent the Lorentz cone constraint z₀ ≥ sqrt(z₁² + ....">LorentzConeConstraint::EvalType</a> for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added Lorentz cone constraint. </dd></dl>

</div>
</div>
<a id="a660fa2d745904f2b3b15868dc801e7bf" name="a660fa2d745904f2b3b15868dc801e7bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660fa2d745904f2b3b15868dc801e7bf">&#9670;&#160;</a></span>AddLorentzConeConstraint() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; AddLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a></td>          <td class="paramname"><span class="paramname"><em>eval_type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds Lorentz cone constraint referencing potentially a subset of the decision variables (defined in the vars parameter). </p>
<p>The linear expression \( z=Ax+b \) is in the Lorentz cone. A vector \( z \in\mathbb{R}^n \) is in the Lorentz cone, if     </p><p class="formulaDsp">
\[z_0 \ge \sqrt{z_1^2 + ... + z_{n-1}^2}
\]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A \(\mathbb{R}^{n\times m}\) matrix, whose number of columns equals to the size of the decision variables. </td></tr>
    <tr><td class="paramname">b</td><td>A \(\mathbb{R}^n\) vector, whose number of rows equals to the size of the decision variables. </td></tr>
    <tr><td class="paramname">vars</td><td>The Eigen vector of \( m \) decision variables. </td></tr>
    <tr><td class="paramname">eval_type</td><td>The evaluation type when evaluating the lorentz cone constraint in generic optimization. Refer to <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4" title="We provide three possible Eval functions to represent the Lorentz cone constraint z₀ ≥ sqrt(z₁² + ....">LorentzConeConstraint::EvalType</a> for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added Lorentz cone constraint.</dd></dl>
<p>For example, to add the Lorentz cone constraint </p><pre class="fragment">x+1 &gt;= sqrt(y² + 2y + x² + 5) = sqrt((y+1)² + x² + 2²),
</pre><p> the user could call </p><div class="fragment"><div class="line">Eigen::Matrix&lt;double, 4, 2&gt; A;</div>
<div class="line">Eigen::Vector4d b;</div>
<div class="line">A &lt;&lt; 1, 0, 0, 1, 1, 0, 0, 0;</div>
<div class="line">b &lt;&lt; 1, 1, 0, 2;</div>
<div class="line"><span class="comment">// A * [x;y] + b = [x+1; y+1; x; 2]</span></div>
<div class="line">prog.AddLorentzConeConstraint(A, b, <a class="code hl_typedef" href="namespacedrake.html#ab9f8b7dbd727440c2dd207bf43812f1e">Vector2&lt;symbolic::Variable&gt;</a>(x, y));</div>
<div class="ttc" id="anamespacedrake_html_ab9f8b7dbd727440c2dd207bf43812f1e"><div class="ttname"><a href="namespacedrake.html#ab9f8b7dbd727440c2dd207bf43812f1e">drake::Vector2</a></div><div class="ttdeci">Eigen::Matrix&lt; Scalar, 2, 1 &gt; Vector2</div><div class="ttdoc">A column vector of size 2, templated on scalar type.</div><div class="ttdef"><b>Definition</b> eigen_types.h:44</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a24cd977b63b356950165807fcfffd855" name="a24cd977b63b356950165807fcfffd855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24cd977b63b356950165807fcfffd855">&#9670;&#160;</a></span>AddLorentzConeConstraint() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; AddLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a></td>          <td class="paramname"><span class="paramname"><em>eval_type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds Lorentz cone constraint referencing potentially a subset of the decision variables (defined in the vars parameter). </p>
<p>The linear expression \( z=Ax+b \) is in the Lorentz cone. A vector \( z \in\mathbb{R}^n \) is in the Lorentz cone, if     </p><p class="formulaDsp">
\[z_0 \ge \sqrt{z_1^2 + ... + z_{n-1}^2}
\]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A \(\mathbb{R}^{n\times m}\) matrix, whose number of columns equals to the size of the decision variables. </td></tr>
    <tr><td class="paramname">b</td><td>A \(\mathbb{R}^n\) vector, whose number of rows equals to the size of the decision variables. </td></tr>
    <tr><td class="paramname">vars</td><td>The list of \( m \) decision variables. </td></tr>
    <tr><td class="paramname">eval_type</td><td>The evaluation type when evaluating the lorentz cone constraint in generic optimization. Refer to <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4" title="We provide three possible Eval functions to represent the Lorentz cone constraint z₀ ≥ sqrt(z₁² + ....">LorentzConeConstraint::EvalType</a> for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added Lorentz cone constraint. </dd></dl>

</div>
</div>
<a id="a549db428087f40a28f570d96ffdacbba" name="a549db428087f40a28f570d96ffdacbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a549db428087f40a28f570d96ffdacbba">&#9670;&#160;</a></span>AddLorentzConeConstraint() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; AddLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a></td>          <td class="paramname"><span class="paramname"><em>eval_type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds Lorentz cone constraint referencing potentially a subset of the decision variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>An Eigen::Vector of <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>. Constraining that   <p class="formulaDsp">
\[v_0 \ge \sqrt{v_1^2 + ... + v_{n-1}^2}
\]
</p>
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly constructed Lorentz cone constraint with the bounded variables. For example, to add the Lorentz cone constraint <pre class="fragment">x+1 &gt;= sqrt(y² + 2y + x² + 5),
     = sqrt((y+1)²+x²+2²)
</pre> The user could call <div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4&lt;symbolic::Expression&gt;</a> v(x+1, y+1, x, 2.);</div>
<div class="line">prog.AddLorentzConeConstraint(v);</div>
<div class="ttc" id="anamespacedrake_html_af7e96394aef85f13f3fc84d3c3c238b3"><div class="ttname"><a href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">drake::Vector4</a></div><div class="ttdeci">Eigen::Matrix&lt; Scalar, 4, 1 &gt; Vector4</div><div class="ttdoc">A column vector of size 4, templated on scalar type.</div><div class="ttdef"><b>Definition</b> eigen_types.h:52</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eval_type</td><td>The evaluation type when evaluating the lorentz cone constraint in generic optimization. Refer to <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4" title="We provide three possible Eval functions to represent the Lorentz cone constraint z₀ ≥ sqrt(z₁² + ....">LorentzConeConstraint::EvalType</a> for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb92d5cedef371f57961674b3535e579" name="abb92d5cedef371f57961674b3535e579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb92d5cedef371f57961674b3535e579">&#9670;&#160;</a></span>AddLorentzConeConstraint() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; AddLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>linear_expression</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>quadratic_expression</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a></td>          <td class="paramname"><span class="paramname"><em>eval_type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds Lorentz cone constraint on the linear expression v1 and quadratic expression v2, such that v1 &gt;= sqrt(v2). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linear_expression</td><td>The linear expression v1. </td></tr>
    <tr><td class="paramname">quadratic_expression</td><td>The quadratic expression v2. </td></tr>
    <tr><td class="paramname">tol</td><td>The tolerance to determine if the matrix in v2 is positive semidefinite or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>DecomposePositiveQuadraticForm for more explanation. <br  />
 <em class="arg">Default:</em> is 0. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eval_type</td><td>The evaluation type when evaluating the lorentz cone constraint in generic optimization. Refer to <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4" title="We provide three possible Eval functions to represent the Lorentz cone constraint z₀ ≥ sqrt(z₁² + ....">LorentzConeConstraint::EvalType</a> for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">binding</td><td>The newly added Lorentz cone constraint, together with the bound variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ol type="1">
<li><span class="tt">v1</span> is a linear expression, in the form of c'*x + d.</li>
<li><span class="tt">v2</span> is a quadratic expression, in the form of <pre>
         x'*Q*x + b'x + a
   </pre> Also the quadratic expression has to be convex, namely Q is a positive semidefinite matrix, and the quadratic expression needs to be non-negative for any x. </li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the preconditions are not satisfied.</td></tr>
  </table>
  </dd>
</dl>
<p>Notice this constraint is equivalent to the vector [z;y] is within a Lorentz cone, where </p><pre>
 z = v1
 y = R * x + d
</pre><p> while (R, d) satisfies y'*y = x'*Q*x + b'*x + a For example, to add the Lorentz cone constraint </p><pre class="fragment">x+1 &gt;= sqrt(y² + 2y + x² + 4),
</pre><p> the user could call </p><div class="fragment"><div class="line">prog.AddLorentzConeConstraint(x+1, <a class="code hl_function" href="namespacedrake.html#a92c1bc8d793f1a04fa4f4c33a011f4eb">pow</a>(y, 2) + 2 * y + <a class="code hl_function" href="namespacedrake.html#a92c1bc8d793f1a04fa4f4c33a011f4eb">pow</a>(x, 2) + 4);</div>
<div class="ttc" id="anamespacedrake_html_a92c1bc8d793f1a04fa4f4c33a011f4eb"><div class="ttname"><a href="namespacedrake.html#a92c1bc8d793f1a04fa4f4c33a011f4eb">drake::pow</a></div><div class="ttdeci">Polynomial&lt; T &gt; pow(const Polynomial&lt; T &gt; &amp;base, typename Polynomial&lt; T &gt;::PowerType exponent)</div><div class="ttdoc">Provides power function for Polynomial.</div><div class="ttdef"><b>Definition</b> polynomial.h:448</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a71c6b407838eed56bd96a33b64631ed6" name="a71c6b407838eed56bd96a33b64631ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c6b407838eed56bd96a33b64631ed6">&#9670;&#160;</a></span>AddLorentzConeConstraint() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; AddLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a></td>          <td class="paramname"><span class="paramname"><em>eval_type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>psd_tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-8</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>coefficient_tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-8</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a Lorentz cone constraint of the form Ax+b &gt;= |Cx+d|₂ from a symbolic formula with one side which can be decomposed into sqrt((Cx+d)'(Cx+d)). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eval_type</td><td>The evaluation type when evaluating the lorentz cone constraint in generic optimization. Refer to <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4" title="We provide three possible Eval functions to represent the Lorentz cone constraint z₀ ≥ sqrt(z₁² + ....">LorentzConeConstraint::EvalType</a> for more details.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="namespacedrake_1_1symbolic.html#a70b04dbbe04340ba67a5af39b6c0f277" title="Decomposes an L2 norm e = |Ax+b|₂ into A, b, and the variable vector x (or returns false if the decom...">symbolic::DecomposeL2NormExpression</a> for details on the tolerance parameters, <code class="param">psd_tol</code> and <code class="param">coefficient_tol</code>. Consider using the overload which takes a vector of expressions to avoid the numerical decomposition.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code class="param">f</code> cannot be decomposed into a Lorentz cone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a203a7fc9d8d4da6977b58afe7427bc22" name="a203a7fc9d8d4da6977b58afe7427bc22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203a7fc9d8d4da6977b58afe7427bc22">&#9670;&#160;</a></span>AddLorentzConeConstraint() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; AddLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a></td>          <td class="paramname"><span class="paramname"><em>eval_type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imposes that a vector \( x\in\mathbb{R}^m \) lies in Lorentz cone. </p>
<p>Namely   </p><p class="formulaDsp">
\[x_0 \ge \sqrt{x_1^2 + .. + x_{m-1}^2}
\]
</p>
   <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vars</td><td>The stacked column of vars should lie within the Lorentz cone. </td></tr>
    <tr><td class="paramname">eval_type</td><td>The evaluation type when evaluating the lorentz cone constraint in generic optimization. Refer to <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4" title="We provide three possible Eval functions to represent the Lorentz cone constraint z₀ ≥ sqrt(z₁² + ....">LorentzConeConstraint::EvalType</a> for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added Lorentz cone constraint. </dd></dl>

</div>
</div>
<a id="a81a184723f3b7f8171f549d7163a9f5b" name="a81a184723f3b7f8171f549d7163a9f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a184723f3b7f8171f549d7163a9f5b">&#9670;&#160;</a></span>AddMaximizeGeometricMeanCost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; AddMaximizeGeometricMeanCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An overloaded version of <a class="el" href="#maximize_geometric_mean">maximize_geometric_mean</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>cost The added cost (note that since <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> only minimizes the cost, the returned cost evaluates to -power(∏ᵢz(i), 1/n) where z = A*x+b. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>A.rows() == b.rows(), A.rows() &gt;= 2. </dd></dl>

</div>
</div>
<a id="ae88f4bd8b4b118589406e4221313817c" name="ae88f4bd8b4b118589406e4221313817c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88f4bd8b4b118589406e4221313817c">&#9670;&#160;</a></span>AddMaximizeGeometricMeanCost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; AddMaximizeGeometricMeanCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An overloaded version of <a class="el" href="#maximize_geometric_mean">maximize_geometric_mean</a>. </p>
<p>We add the cost to maximize the geometric mean of x, i.e., c*power(∏ᵢx(i), 1/n). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The positive coefficient of the geometric mean cost, <br  />
 <em class="arg">Default:</em> is 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cost The added cost (note that since <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> only minimizes the cost, the returned cost evaluates to -c * power(∏ᵢx(i), 1/n). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>x.rows() &gt;= 2. </dd>
<dd>
c &gt; 0. </dd></dl>

</div>
</div>
<a id="af41ff66fc4e80a37fafb623ee8b9ae73" name="af41ff66fc4e80a37fafb623ee8b9ae73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41ff66fc4e80a37fafb623ee8b9ae73">&#9670;&#160;</a></span>AddMaximizeLogDeterminantCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; AddMaximizeLogDeterminantCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximize the log determinant. </p>
<p>See <a class="el" href="#log_determinant">log_determinant</a> for more details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>A symmetric positive semidefinite matrix X, whose log(det(X)) will be maximized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(cost, t, Z) cost is -∑ᵢt(i), we also return the newly created slack variables t and the lower triangular matrix Z. Note that Z is not a matrix of <a class="el" href="classdrake_1_1symbolic_1_1_variable.html" title="Represents a symbolic variable.">symbolic::Variable</a> but <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>, because the upper-diagonal entries of Z are not variable, but expression 0. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>X is a symmetric matrix. </dd></dl>

</div>
</div>
<a id="a76c0540f162fbd313399d54bb53e0113" name="a76c0540f162fbd313399d54bb53e0113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c0540f162fbd313399d54bb53e0113">&#9670;&#160;</a></span>AddPolynomialConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; AddPolynomialConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="namespacedrake.html#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>polynomials</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">Polynomiald::VarType</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>poly_vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a polynomial constraint to the program referencing a subset of the decision variables (defined in the vars parameter). </p>

</div>
</div>
<a id="ab79f540383e93ae6941d08e2e4f7c5db" name="ab79f540383e93ae6941d08e2e4f7c5db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79f540383e93ae6941d08e2e4f7c5db">&#9670;&#160;</a></span>AddPolynomialConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; AddPolynomialConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="namespacedrake.html#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>polynomials</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">Polynomiald::VarType</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>poly_vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a polynomial constraint to the program referencing a subset of the decision variables (defined in the vars parameter). </p>

</div>
</div>
<a id="acaac50719294dcb0ddad7ccb1df3ae03" name="acaac50719294dcb0ddad7ccb1df3ae03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaac50719294dcb0ddad7ccb1df3ae03">&#9670;&#160;</a></span>AddPolynomialCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_polynomial_cost.html">PolynomialCost</a> &gt; AddPolynomialCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term in the polynomial form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>A symbolic expression in the polynomial form. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created cost and the bound variables. </dd></dl>

</div>
</div>
<a id="aa6b346ec7d733e7f9f7eb09284675268" name="aa6b346ec7d733e7f9f7eb09284675268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b346ec7d733e7f9f7eb09284675268">&#9670;&#160;</a></span>AddPositiveDiagonallyDominantDualConeMatrixConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; AddPositiveDiagonallyDominantDualConeMatrixConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded variant of <a class="el" href="#add_dd_dual">diagonally dominant dual cone constraint</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The matrix X. We will use 0.5(X+Xᵀ) as the "symmetric version" of X. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>X(i, j) should be a linear expression of decision variables. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A linear constraint of size n² encoding vᵢᵀXvᵢ ≥ 0 </dd></dl>

</div>
</div>
<a id="a207e587812840e9c4675294dccdd64e5" name="a207e587812840e9c4675294dccdd64e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207e587812840e9c4675294dccdd64e5">&#9670;&#160;</a></span>AddPositiveDiagonallyDominantDualConeMatrixConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; AddPositiveDiagonallyDominantDualConeMatrixConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded variant of <a class="el" href="#add_dd_dual">diagonally dominant dual cone constraint</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The matrix X. We will use 0.5(X+Xᵀ) as the "symmetric version" of X. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A linear constraint of size n² encoding vᵢᵀXvᵢ ≥ 0 </dd></dl>

</div>
</div>
<a id="a3c351e546e7b6b97a3104b63d5fabe5d" name="a3c351e546e7b6b97a3104b63d5fabe5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c351e546e7b6b97a3104b63d5fabe5d">&#9670;&#160;</a></span>AddPositiveDiagonallyDominantMatrixConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; AddPositiveDiagonallyDominantMatrixConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the constraint that a symmetric matrix is diagonally dominant with non-negative diagonal entries. </p>
<p>A symmetric matrix X is diagonally dominant with non-negative diagonal entries if X(i, i) &gt;= ∑ⱼ |X(i, j)| ∀ j ≠ i namely in each row, the diagonal entry is larger than the sum of the absolute values of all other entries in the same row. A matrix being diagonally dominant with non-negative diagonals is a sufficient (but not necessary) condition of a matrix being positive semidefinite. Internally we will create a matrix Y as slack variables, such that Y(i, j) represents the absolute value |X(i, j)| ∀ j ≠ i. The diagonal entries Y(i, i) = X(i, i) The users can refer to "DSOS and SDSOS Optimization: More Tractable
Alternatives to Sum of Squares and Semidefinite Optimization" by Amir Ali Ahmadi and Anirudha Majumdar, with arXiv link <a href="https://arxiv.org/abs/1706.02586">https://arxiv.org/abs/1706.02586</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The matrix X. We will use 0.5(X+Xᵀ) as the "symmetric version" of X. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Y The slack variable. Y(i, j) represents |X(i, j)| ∀ j ≠ i, with the constraint Y(i, j) &gt;= X(i, j) and Y(i, j) &gt;= -X(i, j). Y is a symmetric matrix. The diagonal entries Y(i, i) = X(i, i) </dd></dl>

</div>
</div>
<a id="a3047d3c8592ca29f32d1ecf95d7afb50" name="a3047d3c8592ca29f32d1ecf95d7afb50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3047d3c8592ca29f32d1ecf95d7afb50">&#9670;&#160;</a></span>AddPositiveSemidefiniteConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; AddPositiveSemidefiniteConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a positive semidefinite constraint on a symmetric matrix of symbolic expressions <code class="param">e</code>. </p>
<p>We create a new symmetric matrix of variables M being positive semidefinite, with the linear equality constraint e == M. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Imposes constraint "e is positive semidefinite". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>e is symmetric. </dd>
<dd>
e(i, j) is linear for all i, j</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added positive semidefinite constraint, with the bound variable M that are also newly added.</dd></dl>
<p>For example, to add a constraint that </p><pre class="fragment">⌈x + 1  2x + 3 x+y⌉
|2x+ 3       2   0| is positive semidefinite
⌊x + y       0   x⌋
</pre><p> The user could call </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3&lt;symbolic::Expression&gt;</a> e</div>
<div class="line">e &lt;&lt; x+1, 2*x+3, x+y,</div>
<div class="line">     2*x+3,   2,   0,</div>
<div class="line">     x+y,     0,   x;</div>
<div class="line">prog.AddPositiveSemidefiniteConstraint(e);</div>
<div class="ttc" id="anamespacedrake_html_a3922cc0c6264e8ff225a6aa0dd993667"><div class="ttname"><a href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">drake::Matrix3</a></div><div class="ttdeci">Eigen::Matrix&lt; Scalar, 3, 3 &gt; Matrix3</div><div class="ttdoc">A matrix of 3 rows and 3 columns, templated on scalar type.</div><div class="ttdef"><b>Definition</b> eigen_types.h:104</div></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>This function will add additional variables and linear equality constraints. Consider calling AddLinearMatrixInequalityConstraint(e), which doesn't introduce new variables or linear equality constraints. </dd></dl>

</div>
</div>
<a id="a1eede327356f097ffbe492929b4effb7" name="a1eede327356f097ffbe492929b4effb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eede327356f097ffbe492929b4effb7">&#9670;&#160;</a></span>AddPositiveSemidefiniteConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; AddPositiveSemidefiniteConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>symmetric_matrix_var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a positive semidefinite constraint on a symmetric matrix. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>in Debug mode if <code class="param">symmetric_matrix_var</code> is not symmetric. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symmetric_matrix_var</td><td>A symmetric <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e2bd03ae4dbcbe7f1ffa494b1d544bf" name="a9e2bd03ae4dbcbe7f1ffa494b1d544bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2bd03ae4dbcbe7f1ffa494b1d544bf">&#9670;&#160;</a></span>AddPrincipalSubmatrixIsPsdConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt; AddPrincipalSubmatrixIsPsdConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>minor_indices</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a constraint the that the principal submatrix of a symmetric matrix of expressions composed of the indices in minor_indices is positive semidefinite. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The passed <code class="param">symmetric_matrix_var</code> is a symmetric matrix. </dd>
<dd>
All values in <span class="tt">minor_indices</span> lie in the range [0, symmetric_matrix_var.rows() - 1]. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Imposes constraint "e is positive semidefinite". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2c01095865c3167e561093efa629b9cc" title="Adds a linear matrix inequality constraint to the program.">AddLinearMatrixInequalityConstraint</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the return type is <a class="el" href="classdrake_1_1solvers_1_1_binding.html" title="A binding on constraint type C is a mapping of the decision variables onto the inputs of C.">Binding&lt;LinearMatrixInequalityConstraint&gt;</a>, different from the overloaded function above which returns <a class="el" href="classdrake_1_1solvers_1_1_binding.html" title="A binding on constraint type C is a mapping of the decision variables onto the inputs of C.">Binding&lt;PositiveSemidefiniteConstraint&gt;</a>. We impose the constraint as an LMI so as to add fewer additional variables and constraints. </dd></dl>

</div>
</div>
<a id="a66308f4f93d121883f3223d204157317" name="a66308f4f93d121883f3223d204157317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66308f4f93d121883f3223d204157317">&#9670;&#160;</a></span>AddPrincipalSubmatrixIsPsdConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; AddPrincipalSubmatrixIsPsdConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>symmetric_matrix_var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>minor_indices</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a constraint that the principal submatrix of a symmetric matrix composed of the indices in minor_indices is positive semidefinite. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The passed <code class="param">symmetric_matrix_var</code> is a symmetric matrix. </dd>
<dd>
All values in <span class="tt">minor_indices</span> lie in the range [0, symmetric_matrix_var.rows() - 1]. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symmetric_matrix_var</td><td>A symmetric <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1eede327356f097ffbe492929b4effb7" title="Adds a positive semidefinite constraint on a symmetric matrix.">AddPositiveSemidefiniteConstraint</a> </dd></dl>

</div>
</div>
<a id="a4122eac69435dfefffe033a01cf60723" name="a4122eac69435dfefffe033a01cf60723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4122eac69435dfefffe033a01cf60723">&#9670;&#160;</a></span>AddQuadraticAsRotatedLorentzConeConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; AddQuadraticAsRotatedLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>psd_tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the convex quadratic constraint 0.5xᵀQx + bᵀx + c &lt;= 0 as a rotated Lorentz cone constraint [rᵀx+s, 1, Px+q] is in the rotated Lorentz cone. </p>
<p>When solving the optimization problem using conic solvers (like Mosek, Gurobi, SCS, etc), it is numerically preferable to impose the convex quadratic constraint as rotated Lorentz cone constraint. See <a href="https://docs.mosek.com/11.1/capi/prob-def-quadratic.html#a-recommendation">https://docs.mosek.com/11.1/capi/prob-def-quadratic.html#a-recommendation</a> </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if this quadratic constraint is not convex (Q is not positive semidefinite) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td>The Hessian of the quadratic constraint. Should be positive semidefinite. </td></tr>
    <tr><td class="paramname">b</td><td>The linear coefficient of the quadratic constraint. </td></tr>
    <tr><td class="paramname">c</td><td>The constant term of the quadratic constraint. </td></tr>
    <tr><td class="paramname">vars</td><td>x in the documentation above. </td></tr>
    <tr><td class="paramname">psd_tol</td><td>If the minimal eigenvalue of Q is smaller than -psd_tol, then throw an exception. <br  />
 <em class="arg">Default:</em> = 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2056b1b15a85ae7936b320668c55716e" name="a2056b1b15a85ae7936b320668c55716e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2056b1b15a85ae7936b320668c55716e">&#9670;&#160;</a></span>AddQuadraticConstraint() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_constraint.html">QuadraticConstraint</a> &gt; AddQuadraticConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_constraint.html#a604cad5cda14e378ce4a77ab28ee9fd9">QuadraticConstraint::HessianType</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>hessian_type</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds quadratic constraint lb ≤ .5 xᵀQx + bᵀx ≤ ub Notice that if your quadratic constraint is convex, and you intend to solve the problem with a convex solver (like Mosek), then it is better to reformulate it with a second order cone constraint. </p>
<p>See <a href="https://docs.mosek.com/11.1/capi/prob-def-quadratic.html#a-recommendation">https://docs.mosek.com/11.1/capi/prob-def-quadratic.html#a-recommendation</a> for an explanation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vars</td><td>x in the documentation above. </td></tr>
    <tr><td class="paramname">hessian_type</td><td>Whether the Hessian is positive semidefinite, negative semidefinite or indefinite. Drake will check the type if hessian_type=std::nullopt. Specifying the hessian type will speed this method up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>hessian_type should be correct if it is not std::nullopt, as we will blindly trust it in the downstream code. </dd></dl>

</div>
</div>
<a id="a889fc7ebf3403ad19b99619211634ae7" name="a889fc7ebf3403ad19b99619211634ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889fc7ebf3403ad19b99619211634ae7">&#9670;&#160;</a></span>AddQuadraticConstraint() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_constraint.html">QuadraticConstraint</a> &gt; AddQuadraticConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_constraint.html#a604cad5cda14e378ce4a77ab28ee9fd9">QuadraticConstraint::HessianType</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>hessian_type</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds quadratic constraint lb ≤ .5 xᵀQx + bᵀx ≤ ub Notice that if your quadratic constraint is convex, and you intend to solve the problem with a convex solver (like Mosek), then it is better to reformulate it with a second order cone constraint. </p>
<p>See <a href="https://docs.mosek.com/11.1/capi/prob-def-quadratic.html#a-recommendation">https://docs.mosek.com/11.1/capi/prob-def-quadratic.html#a-recommendation</a> for an explanation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vars</td><td>x in the documentation above. </td></tr>
    <tr><td class="paramname">hessian_type</td><td>Whether the Hessian is positive semidefinite, negative semidefinite or indefinite. Drake will check the type if hessian_type=std::nullopt. Specifying the hessian type will speed this method up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>hessian_type should be correct if it is not std::nullopt, as we will blindly trust it in the downstream code. </dd></dl>

</div>
</div>
<a id="abf7df46d3c85d0fb554170521011c169" name="abf7df46d3c85d0fb554170521011c169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7df46d3c85d0fb554170521011c169">&#9670;&#160;</a></span>AddQuadraticConstraint() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_constraint.html">QuadraticConstraint</a> &gt; AddQuadraticConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_constraint.html#a604cad5cda14e378ce4a77ab28ee9fd9">QuadraticConstraint::HessianType</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>hessian_type</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads AddQuadraticConstraint, impose lb &lt;= e &lt;= ub where <span class="tt">e</span> is a quadratic expression. </p>
<p>Notice that if your quadratic constraint is convex, and you intend to solve the problem with a convex solver (like Mosek), then it is better to reformulate it with a second order cone constraint. See <a href="https://docs.mosek.com/11.1/capi/prob-def-quadratic.html#a-recommendation">https://docs.mosek.com/11.1/capi/prob-def-quadratic.html#a-recommendation</a> for an explanation. </p>

</div>
</div>
<a id="aecd6bb31415b2221144adaf4080bfeba" name="aecd6bb31415b2221144adaf4080bfeba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd6bb31415b2221144adaf4080bfeba">&#9670;&#160;</a></span>AddQuadraticCost() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; AddQuadraticCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; bool &gt;</td>          <td class="paramname"><span class="paramname"><em>is_convex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term of the form 0.5*x'*Q*x + b'x Applied to subset of the variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is_convex</td><td>Whether the cost is already known to be convex. If is_convex=nullopt (the default), then Drake will determine if this is a convex quadratic cost or not. To improve the computation speed, the user can set is_convex if the user knows whether the cost is convex or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2846cb28c83784e28e1e6c7b29d36e7" name="ab2846cb28c83784e28e1e6c7b29d36e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2846cb28c83784e28e1e6c7b29d36e7">&#9670;&#160;</a></span>AddQuadraticCost() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; AddQuadraticCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; bool &gt;</td>          <td class="paramname"><span class="paramname"><em>is_convex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term of the form 0.5*x'*Q*x + b'x. </p>
<p>Applied to subset of the variables. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is_convex</td><td>Whether the cost is already known to be convex. If is_convex=nullopt (the default), then Drake will determine if this is a convex quadratic cost or not (by checking if matrix Q is positive semidefinite or not). To improve the computation speed, the user can set is_convex if the user knows whether the cost is convex or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90b9ebf0459a4d9f636018538670dbe2" name="a90b9ebf0459a4d9f636018538670dbe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b9ebf0459a4d9f636018538670dbe2">&#9670;&#160;</a></span>AddQuadraticCost() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; AddQuadraticCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; bool &gt;</td>          <td class="paramname"><span class="paramname"><em>is_convex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term of the form 0.5*x'*Q*x + b'x + c Applied to subset of the variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is_convex</td><td>Whether the cost is already known to be convex. If is_convex=nullopt (the default), then Drake will determine if this is a convex quadratic cost or not. To improve the computation speed, the user can set is_convex if the user knows whether the cost is convex or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03093e39f8da15c8a4064b8a14ab7cac" name="a03093e39f8da15c8a4064b8a14ab7cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03093e39f8da15c8a4064b8a14ab7cac">&#9670;&#160;</a></span>AddQuadraticCost() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; AddQuadraticCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; bool &gt;</td>          <td class="paramname"><span class="paramname"><em>is_convex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a quadratic cost term of the form 0.5*x'*Q*x + b'*x + c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>A quadratic symbolic expression. </td></tr>
    <tr><td class="paramname">is_convex</td><td>Whether the cost is already known to be convex. If is_convex=nullopt (the default), then Drake will determine if <span class="tt">e</span> is a convex quadratic cost or not. To improve the computation speed, the user can set is_convex if the user knows whether the cost is convex or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the expression is not quadratic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added cost together with the bound variables. </dd></dl>

</div>
</div>
<a id="a3b19f7bda6ac7551c6d0213b40527bf5" name="a3b19f7bda6ac7551c6d0213b40527bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b19f7bda6ac7551c6d0213b40527bf5">&#9670;&#160;</a></span>AddQuadraticErrorCost() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; AddQuadraticErrorCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x_desired</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term of the form (x-x_desired)'<em>Q</em>(x-x_desired). </p>

</div>
</div>
<a id="ab2fca7ef3d76b4e623e9e3a8768e6f99" name="ab2fca7ef3d76b4e623e9e3a8768e6f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2fca7ef3d76b4e623e9e3a8768e6f99">&#9670;&#160;</a></span>AddQuadraticErrorCost() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; AddQuadraticErrorCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x_desired</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term of the form (x-x_desired)'<em>Q</em>(x-x_desired). </p>

</div>
</div>
<a id="a39f08dd96e9b93277bfd7f3bd33b0689" name="a39f08dd96e9b93277bfd7f3bd33b0689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f08dd96e9b93277bfd7f3bd33b0689">&#9670;&#160;</a></span>AddQuadraticErrorCost() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; AddQuadraticErrorCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x_desired</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term of the form w*|x-x_desired|^2. </p>

</div>
</div>
<a id="a946990fb2424146499c82849f55e4985" name="a946990fb2424146499c82849f55e4985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946990fb2424146499c82849f55e4985">&#9670;&#160;</a></span>AddQuadraticErrorCost() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; AddQuadraticErrorCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x_desired</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term of the form w*|x-x_desired|^2. </p>

</div>
</div>
<a id="a0665194d043c0986f2aedc3cb2ff2e24" name="a0665194d043c0986f2aedc3cb2ff2e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0665194d043c0986f2aedc3cb2ff2e24">&#9670;&#160;</a></span>AddRotatedLorentzConeConstraint() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rows&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; AddRotatedLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; <a class="el" href="namespacedrake_1_1solvers.html#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a>&lt; rows &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Impose that a vector \( x\in\mathbb{R}^m \) is in rotated Lorentz cone. </p>
<p>Namely    </p><p class="formulaDsp">
\[x_0 x_1 \ge x_2^2 + ... + x_{m-1}^2\\
x_0 \ge 0, x_1 \ge 0
\]
</p>
    <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vars</td><td>The stacked column of vars lies in the rotated Lorentz cone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added rotated Lorentz cone constraint. </dd></dl>

</div>
</div>
<a id="acbaf2d641fd2fffcb7c7a3c68f0929be" name="acbaf2d641fd2fffcb7c7a3c68f0929be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbaf2d641fd2fffcb7c7a3c68f0929be">&#9670;&#160;</a></span>AddRotatedLorentzConeConstraint() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; AddRotatedLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a rotated Lorentz cone constraint referencing potentially a subset of decision variables, The linear expression \( z=Ax+b \) is in rotated Lorentz cone. </p>
<p>A vector \( z \in\mathbb{R}^n \) is in the rotated Lorentz cone, if     </p><p class="formulaDsp">
\[z_0z_1 \ge z_2^2 + ... + z_{n-1}^2
\]
</p>
<p> where \( A\in\mathbb{R}^{n\times m}, b\in\mathbb{R}^n\) are given matrices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A matrix whose number of columns equals to the size of the decision variables. </td></tr>
    <tr><td class="paramname">b</td><td>A vector whose number of rows equals to the size of the decision variables. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which the constraint is imposed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1a3f68dc5426b6c41009cb453de11fb" name="ad1a3f68dc5426b6c41009cb453de11fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a3f68dc5426b6c41009cb453de11fb">&#9670;&#160;</a></span>AddRotatedLorentzConeConstraint() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; AddRotatedLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a rotated Lorentz cone constraint referencing potentially a subset of decision variables, The linear expression \( z=Ax+b \) is in rotated Lorentz cone. </p>
<p>A vector \( z \in\mathbb{R}^n \) is in the rotated Lorentz cone, if     </p><p class="formulaDsp">
\[z_0z_1 \ge z_2^2 + ... + z_{n-1}^2
\]
</p>
<p> where \( A\in\mathbb{R}^{n\times m}, b\in\mathbb{R}^n\) are given matrices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A matrix whose number of columns equals to the size of the decision variables. </td></tr>
    <tr><td class="paramname">b</td><td>A vector whose number of rows equals to the size of the decision variables. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which the constraint is imposed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9da7a2631c39df85535f07442694d1c8" name="a9da7a2631c39df85535f07442694d1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da7a2631c39df85535f07442694d1c8">&#9670;&#160;</a></span>AddRotatedLorentzConeConstraint() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; AddRotatedLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a constraint that a symbolic expression <span class="tt">v</span> is in the rotated Lorentz cone, i.e.,. </p>
<p class="formulaDsp">
\[v_0v_1 \ge v_2^2 + ... + v_{n-1}^2\\
v_0 \ge 0, v_1 \ge 0
\]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A linear expression of variables, \( v = A x + b\), where  \( A,
b \) are given matrices of the correct size, \( x \) is the vector of decision variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">binding</td><td>The newly added rotated Lorentz cone constraint, together with the bound variables.</td></tr>
  </table>
  </dd>
</dl>
<p>For example, to add the rotated Lorentz cone constraint </p><pre class="fragment">(x+1)(x+y) &gt;= x²+z²+2z+5 = x² + (z+1)² + 2²
x+1 &gt;= 0
x+y &gt;= 0
</pre><p> The user could call </p><div class="fragment"><div class="line">Eigen::Matrix&lt;symbolic::Expression, 5, 1&gt; v;</div>
<div class="line">v &lt;&lt; x+1, x+y, x, z+1, 2;</div>
<div class="line">prog.AddRotatedLorentzConeConstraint(v);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a52ceaba09e755defc9a689829a1ceb84" name="a52ceaba09e755defc9a689829a1ceb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ceaba09e755defc9a689829a1ceb84">&#9670;&#160;</a></span>AddRotatedLorentzConeConstraint() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; AddRotatedLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>linear_expression1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>linear_expression2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>quadratic_expression</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds rotated Lorentz cone constraint on the linear expression v1, v2 and quadratic expression u, such that v1 * v2 &gt;= u, v1 &gt;= 0, v2 &gt;= 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linear_expression1</td><td>The linear expression v1. </td></tr>
    <tr><td class="paramname">linear_expression2</td><td>The linear expression v2. </td></tr>
    <tr><td class="paramname">quadratic_expression</td><td>The quadratic expression u. </td></tr>
    <tr><td class="paramname">tol</td><td>The tolerance to determine if the matrix in v2 is positive semidefinite or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>DecomposePositiveQuadraticForm for more explanation. <br  />
 <em class="arg">Default:</em> is 0. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">binding</td><td>The newly added rotated Lorentz cone constraint, together with the bound variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ol type="1">
<li><span class="tt">linear_expression1</span> is a linear (affine) expression, in the form of v1 = c1'*x + d1.</li>
<li><span class="tt">linear_expression2</span> is a linear (affine) expression, in the form of v2 = c2'*x + d2.</li>
</ol>
<ol type="1">
<li><span class="tt">quadratic_expression</span> is a quadratic expression, in the form of <pre>
         u = x'*Q*x + b'x + a
   </pre> Also the quadratic expression has to be convex, namely Q is a positive semidefinite matrix, and the quadratic expression needs to be non-negative for any x. </li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the preconditions are not satisfied.</td></tr>
  </table>
  </dd>
</dl>
<p>For example, to add the rotated Lorentz cone constraint </p><pre class="fragment">(x+1)(x+y) &gt;= x²+z²+2z+5
x+1 &gt;= 0
x+y &gt;= 0
</pre><p> The user could call </p><div class="fragment"><div class="line">prog.AddRotatedLorentzConeConstraint(x+1, x+y, <a class="code hl_function" href="namespacedrake.html#a92c1bc8d793f1a04fa4f4c33a011f4eb">pow</a>(x, 2) + <a class="code hl_function" href="namespacedrake.html#a92c1bc8d793f1a04fa4f4c33a011f4eb">pow</a>(z, 2) +</div>
<div class="line">2*z+5);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5260ab6567586156451d8e507973a833" name="a5260ab6567586156451d8e507973a833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5260ab6567586156451d8e507973a833">&#9670;&#160;</a></span>AddRotatedLorentzConeConstraint() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; AddRotatedLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Impose that a vector \( x\in\mathbb{R}^m \) is in rotated Lorentz cone. </p>
<p>Namely    </p><p class="formulaDsp">
\[x_0 x_1 \ge x_2^2 + ... + x_{m-1}^2\\
x_0 \ge 0, x_1 \ge 0
\]
</p>
    <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vars</td><td>The stacked column of vars lies in the rotated Lorentz cone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added rotated Lorentz cone constraint. </dd></dl>

</div>
</div>
<a id="a1c8ce474c9ebb28fceb18705363d0ea9" name="a1c8ce474c9ebb28fceb18705363d0ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8ce474c9ebb28fceb18705363d0ea9">&#9670;&#160;</a></span>AddScaledDiagonallyDominantDualConeMatrixConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; &gt; AddScaledDiagonallyDominantDualConeMatrixConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded variant of <a class="el" href="#add_sdd_dual">scaled diagonally dominant dual cone constraint</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The matrix X. We will use 0.5(X+Xᵀ) as the "symmetric version" of X. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>X(i, j) should be a linear expression of decision variables. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html" title="Constraining that the linear expression  lies within rotated Lorentz cone.">RotatedLorentzConeConstraint</a> constraints of length 1/2 * n * (n-1) encoding VᵢⱼᵀXVᵢⱼ is psd </dd></dl>

</div>
</div>
<a id="a302b82c829349d67f3dddbc2b130c6e4" name="a302b82c829349d67f3dddbc2b130c6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302b82c829349d67f3dddbc2b130c6e4">&#9670;&#160;</a></span>AddScaledDiagonallyDominantDualConeMatrixConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; &gt; AddScaledDiagonallyDominantDualConeMatrixConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded variant of <a class="el" href="#add_sdd_dual">scaled diagonally dominant dual cone constraint</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The matrix X. We will use 0.5(X+Xᵀ) as the "symmetric version" of X. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html" title="Constraining that the linear expression  lies within rotated Lorentz cone.">RotatedLorentzConeConstraint</a> constraints of length 1/2 * n * (n-1) encoding VᵢⱼᵀXVᵢⱼ is psd </dd></dl>

</div>
</div>
<a id="a01bd838750215d63ccc036a735c16597" name="a01bd838750215d63ccc036a735c16597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01bd838750215d63ccc036a735c16597">&#9670;&#160;</a></span>AddScaledDiagonallyDominantMatrixConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; <a class="el" href="namespacedrake.html#a06406a5da633da84f911e2979aa48549">Matrix2</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &gt; AddScaledDiagonallyDominantMatrixConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded variant of <a class="el" href="#addsdd">scaled diagonally dominant matrix constraint</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The matrix X to be constrained scaled diagonally dominant. X. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>X(i, j) should be a linear expression of decision variables. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>M A vector of vectors of 2 x 2 symmetric matrices M. For i &lt; j, M[i][j] is <pre>
[Mⁱʲ(i, i), Mⁱʲ(i, j)]
[Mⁱʲ(i, j), Mⁱʲ(j, j)].
</pre> Note that M[i][j](0, 1) = Mⁱʲ(i, j) = (X(i, j) + X(j, i)) / 2 for i &gt;= j, M[i][j] is the zero matrix. </dd></dl>

</div>
</div>
<a id="acc67889da0ef9d366028204d1c6700f0" name="acc67889da0ef9d366028204d1c6700f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc67889da0ef9d366028204d1c6700f0">&#9670;&#160;</a></span>AddScaledDiagonallyDominantMatrixConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; <a class="el" href="namespacedrake.html#a06406a5da633da84f911e2979aa48549">Matrix2</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &gt; AddScaledDiagonallyDominantMatrixConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded variant of <a class="el" href="#addsdd">scaled diagonally dominant matrix constraint</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The symmetric matrix X to be constrained scaled diagonally dominant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M For i &lt; j M[i][j] contains the slack variables, mentioned in <a class="el" href="#addsdd">scaled diagonally dominant matrix constraint</a>. For i &gt;= j, M[i][j] contains default-constructed variables (with get_id() == 0). </dd></dl>

</div>
</div>
<a id="a1c068098fdd6c3d108ee92379d142232" name="a1c068098fdd6c3d108ee92379d142232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c068098fdd6c3d108ee92379d142232">&#9670;&#160;</a></span>AddSosConstraint() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> AddSosConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>monomial_basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>gram_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;S&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints that a given symbolic expression <code class="param">e</code> is a sums-of-squares (SOS), that is, <code class="param">p</code> can be decomposed into <span class="tt">mᵀQm</span>, where m is the <code class="param">monomial_basis</code>. </p>
<p>Note that it decomposes <code class="param">e</code> into a polynomial with respect to <span class="tt"><a class="el" href="#a42256b8f076fda109cf611d3b45e2e5e" title="Getter for all indeterminates in the program.">indeterminates()</a></span> in this mathematical program. It returns the coefficients matrix Q, which is positive semidefinite. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Refer to <a class="el" href="#a407fb21fc13a5122994e71a05a6a0818" title="Types of non-negative polynomial that can be found through conic optimization.">NonnegativePolynomial</a> class documentation. </td></tr>
    <tr><td class="paramname">gram_name</td><td>The name of the gram matrix for print out. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e25ab3abb079aba95933bbe93fc84fd" name="a9e25ab3abb079aba95933bbe93fc84fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e25ab3abb079aba95933bbe93fc84fd">&#9670;&#160;</a></span>AddSosConstraint() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt; &gt; AddSosConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>gram_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;S&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints that a given symbolic expression <code class="param">e</code> is a sums-of-squares (SOS), that is, <code class="param">e</code> can be decomposed into <span class="tt">mᵀQm</span>. </p>
<p>Note that it decomposes <code class="param">e</code> into a polynomial with respect to <span class="tt"><a class="el" href="#a42256b8f076fda109cf611d3b45e2e5e" title="Getter for all indeterminates in the program.">indeterminates()</a></span> in this mathematical program. It returns a pair expressing:</p><ul>
<li>The coefficients matrix Q, which is positive semidefinite.</li>
<li>The monomial basis m. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Refer to <a class="el" href="#a407fb21fc13a5122994e71a05a6a0818" title="Types of non-negative polynomial that can be found through conic optimization.">NonnegativePolynomial</a> class documentation. </td></tr>
    <tr><td class="paramname">gram_name</td><td>The name of the gram matrix for print out. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a146a2371a36f2dfadca6f468ba8b9126" name="a146a2371a36f2dfadca6f468ba8b9126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a146a2371a36f2dfadca6f468ba8b9126">&#9670;&#160;</a></span>AddSosConstraint() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> AddSosConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>monomial_basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>gram_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;S&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints that a given polynomial <code class="param">p</code> is a sums-of-squares (SOS), that is, <code class="param">p</code> can be decomposed into <span class="tt">mᵀQm</span>, where m is the <code class="param">monomial_basis</code>. </p>
<p>It returns the coefficients matrix Q, which is positive semidefinite. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the polynomial. <br  />
 <em class="arg">Default:</em> is kSos, but the user can also use kSdsos and kDsos. Refer to <a class="el" href="#a407fb21fc13a5122994e71a05a6a0818" title="Types of non-negative polynomial that can be found through conic optimization.">NonnegativePolynomial</a> for details on different types of sos polynomials. </td></tr>
    <tr><td class="paramname">gram_name</td><td>The name of the gram matrix for print out.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It calls <span class="tt"><a class="el" href="#aee9493ea7d08a35395634bfbfd5713dd" title="Reparses the polynomial p using this MathematicalProgram&#39;s indeterminates.">Reparse</a></span> to enforce <span class="tt">p</span> to have this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>'s indeterminates if necessary. </dd></dl>

</div>
</div>
<a id="a8248c9042b0947f8cb3242ca9b660200" name="a8248c9042b0947f8cb3242ca9b660200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8248c9042b0947f8cb3242ca9b660200">&#9670;&#160;</a></span>AddSosConstraint() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt; &gt; AddSosConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>gram_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;S&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints that a given polynomial <code class="param">p</code> is a sums-of-squares (SOS), that is, <code class="param">p</code> can be decomposed into <span class="tt">mᵀQm</span>, where m is a monomial basis selected from the sparsity of <code class="param">p</code>. </p>
<p>It returns a pair of constraint bindings expressing:</p><ul>
<li>The coefficients matrix Q, which is positive semidefinite.</li>
<li>The monomial basis m. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the polynomial. <br  />
 <em class="arg">Default:</em> is kSos, but the user can also use kSdsos and kDsos. Refer to <a class="el" href="#a407fb21fc13a5122994e71a05a6a0818" title="Types of non-negative polynomial that can be found through conic optimization.">NonnegativePolynomial</a> for the details on different type of sos polynomials. </td></tr>
    <tr><td class="paramname">gram_name</td><td>The name of the gram matrix for print out.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It calls <span class="tt"><a class="el" href="#aee9493ea7d08a35395634bfbfd5713dd" title="Reparses the polynomial p using this MathematicalProgram&#39;s indeterminates.">Reparse</a></span> to enforce <span class="tt">p</span> to have this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>'s indeterminates if necessary. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a4724865fbef538d6b26a1d1934f93166" name="a4724865fbef538d6b26a1d1934f93166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4724865fbef538d6b26a1d1934f93166">&#9670;&#160;</a></span>AddVisualizationCallback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html">VisualizationCallback</a> &gt; AddVisualizationCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html#a84c15b60ba647eabef0aaa2d5dd3943e">VisualizationCallback::CallbackFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a callback method to visualize intermediate results of the optimization. </p>
<dl class="section note"><dt>Note</dt><dd>Just like other costs/constraints, not all solvers support callbacks. Adding a callback here will force MathematicalProgram::Solve to select a solver that support callbacks. For instance, adding a visualization callback to a quadratic programming problem may result in using a nonlinear programming solver as the default solver.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>a std::function that accepts an Eigen::Vector of doubles representing the bound decision variables. </td></tr>
    <tr><td class="paramname">vars</td><td>the decision variables that should be passed to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a4b84ad651a9cb5a81723e336040ca8" name="a6a4b84ad651a9cb5a81723e336040ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4b84ad651a9cb5a81723e336040ca8">&#9670;&#160;</a></span>AddVisualizationCallback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html">VisualizationCallback</a> &gt; AddVisualizationCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html#a84c15b60ba647eabef0aaa2d5dd3943e">VisualizationCallback::CallbackFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a callback method to visualize intermediate results of the optimization. </p>
<dl class="section note"><dt>Note</dt><dd>Just like other costs/constraints, not all solvers support callbacks. Adding a callback here will force MathematicalProgram::Solve to select a solver that support callbacks. For instance, adding a visualization callback to a quadratic programming problem may result in using a nonlinear programming solver as the default solver.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>a std::function that accepts an Eigen::Vector of doubles representing the for the bound decision variables. </td></tr>
    <tr><td class="paramname">vars</td><td>the decision variables that should be passed to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbf73d7148b272c9980e85f4ebffe109" name="abbf73d7148b272c9980e85f4ebffe109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf73d7148b272c9980e85f4ebffe109">&#9670;&#160;</a></span>bounding_box_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; &gt; &amp; bounding_box_constraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for all bounding box constraints. </p>

</div>
</div>
<a id="a92eb16be90ba1765547a715ec244fe00" name="a92eb16be90ba1765547a715ec244fe00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92eb16be90ba1765547a715ec244fe00">&#9670;&#160;</a></span>CheckSatisfied() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CheckSatisfied </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>prog_var_vals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-6</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates CheckSatisfied for the constraint in <code class="param">binding</code> using the value of ALL of the decision variables in this program. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the size of <span class="tt">prog_var_vals</span> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7e684c1e5663a881e40cd35e3c66ae8" name="ab7e684c1e5663a881e40cd35e3c66ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e684c1e5663a881e40cd35e3c66ae8">&#9670;&#160;</a></span>CheckSatisfied() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CheckSatisfied </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bindings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>prog_var_vals</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-6</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates CheckSatisfied for the all of the constraints in <code class="param">binding</code> using the value of ALL of the decision variables in this program. </p>
<dl class="section return"><dt>Returns</dt><dd>true iff all of the constraints are satisfied. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the size of <span class="tt">prog_var_vals</span> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40e98056457ab5ff0855a167b2a057dc" name="a40e98056457ab5ff0855a167b2a057dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e98056457ab5ff0855a167b2a057dc">&#9670;&#160;</a></span>CheckSatisfiedAtInitialGuess() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CheckSatisfiedAtInitialGuess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-6</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates CheckSatisfied for the constraint in <code class="param">binding</code> at the initial guess. </p>

</div>
</div>
<a id="a4249e7e6340d17cc2fe9a77c7ac049f7" name="a4249e7e6340d17cc2fe9a77c7ac049f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4249e7e6340d17cc2fe9a77c7ac049f7">&#9670;&#160;</a></span>CheckSatisfiedAtInitialGuess() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CheckSatisfiedAtInitialGuess </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bindings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-6</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates CheckSatisfied for the all of the constraints in <code class="param">bindings</code> at the initial guess. </p>
<dl class="section return"><dt>Returns</dt><dd>true iff all of the constraints are satisfied. </dd></dl>

</div>
</div>
<a id="ac2079c8eee90c77853f4a9a96c14715a" name="ac2079c8eee90c77853f4a9a96c14715a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2079c8eee90c77853f4a9a96c14715a">&#9670;&#160;</a></span>ClearVariableScaling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ClearVariableScaling </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the scaling factors for decision variables. </p>
<p>See <a class="el" href="#variable_scaling">Variable scaling</a> for more information. </p>

</div>
</div>
<a id="a8bf8eca4db252695b1950209857df07a" name="a8bf8eca4db252695b1950209857df07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf8eca4db252695b1950209857df07a">&#9670;&#160;</a></span>Clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> &gt; Clone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clones an optimization program. </p>
<p>The clone will be functionally equivalent to the source program with the same:</p>
<ul>
<li>decision variables</li>
<li>constraints</li>
<li>costs</li>
<li>solver settings</li>
<li>initial guess</li>
</ul>
<p>Note that this is currently a <em>shallow</em> clone. The costs and constraints are not themselves cloned.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">new_prog.</td><td>The newly constructed mathematical program. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9468b404ae211e3deaa2e41237ee008" name="ab9468b404ae211e3deaa2e41237ee008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9468b404ae211e3deaa2e41237ee008">&#9670;&#160;</a></span>decision_variable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp; decision_variable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the decision variable with index <code class="param">i</code> in the program. </p>

</div>
</div>
<a id="af5b6d39a1b502b2b461de00ac5be2ec8" name="af5b6d39a1b502b2b461de00ac5be2ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b6d39a1b502b2b461de00ac5be2ec8">&#9670;&#160;</a></span>decision_variable_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, int &gt; &amp; decision_variable_index </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the mapping from a decision variable ID to its index in the vector containing all the decision variables in the mathematical program. </p>

</div>
</div>
<a id="a8edf415633915556308470787995a6a0" name="a8edf415633915556308470787995a6a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8edf415633915556308470787995a6a0">&#9670;&#160;</a></span>decision_variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Map&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; decision_variables </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for all decision variables in the program. </p>

</div>
</div>
<a id="a4f857d6d118f26c7061861277139bda0" name="a4f857d6d118f26c7061861277139bda0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f857d6d118f26c7061861277139bda0">&#9670;&#160;</a></span>EvalBinding()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C, typename DerivedX&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt; DerivedX &gt;::value, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; typename DerivedX::Scalar &gt; &gt; EvalBinding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedX &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>prog_var_vals</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the value of some binding, for some input value for all decision variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binding</td><td>A <a class="el" href="classdrake_1_1solvers_1_1_binding.html" title="A binding on constraint type C is a mapping of the decision variables onto the inputs of C.">Binding</a> whose variables are decision variables in this program. </td></tr>
    <tr><td class="paramname">prog_var_vals</td><td>The value of all the decision variables in this program. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the size of <span class="tt">prog_var_vals</span> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0eb46a0ff11d6f6d22d69d9c16bfce94" name="a0eb46a0ff11d6f6d22d69d9c16bfce94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb46a0ff11d6f6d22d69d9c16bfce94">&#9670;&#160;</a></span>EvalBindingAtInitialGuess()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd EvalBindingAtInitialGuess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the evaluator in <code class="param">binding</code> at the initial guess. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of <code class="param">binding</code> at the initial guess. </dd></dl>

</div>
</div>
<a id="ad62767f38872e337ed2356a3e162824d" name="ad62767f38872e337ed2356a3e162824d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62767f38872e337ed2356a3e162824d">&#9670;&#160;</a></span>EvalBindings()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C, typename DerivedX&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt; DerivedX &gt;::value, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; typename DerivedX::Scalar &gt; &gt; EvalBindings </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bindings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedX &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>prog_var_vals</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a set of bindings (plural version of <span class="tt"><a class="el" href="#a4f857d6d118f26c7061861277139bda0" title="Evaluates the value of some binding, for some input value for all decision variables.">EvalBinding</a></span>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindings</td><td>List of bindings. </td></tr>
    <tr><td class="paramname">prog_var_vals</td><td>The value of all the decision variables in this program. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All binding values, concatenated into a single vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the size of <span class="tt">prog_var_vals</span> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a856ded9f90eaac91a1c66f2c139566b5" name="a856ded9f90eaac91a1c66f2c139566b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856ded9f90eaac91a1c66f2c139566b5">&#9670;&#160;</a></span>EvalVisualizationCallbacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EvalVisualizationCallbacks </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>prog_var_vals</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates all visualization callbacks registered with the <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog_var_vals</td><td>The value of all the decision variables in this program. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the size does not match. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6354d6ed7478305a208d001354ce0b7" name="aa6354d6ed7478305a208d001354ce0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6354d6ed7478305a208d001354ce0b7">&#9670;&#160;</a></span>exponential_cone_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html">ExponentialConeConstraint</a> &gt; &gt; &amp; exponential_cone_constraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for exponential cone constraints. </p>

</div>
</div>
<a id="a2f25e54555621691b390c1658e21872f" name="a2f25e54555621691b390c1658e21872f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f25e54555621691b390c1658e21872f">&#9670;&#160;</a></span>FindDecisionVariableIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int FindDecisionVariableIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the decision variable. </p>
<p>Internally the solvers thinks all variables are stored in an array, and it accesses each individual variable using its index. This index is used when adding constraints and costs for each solver. </p><dl class="section pre"><dt>Precondition</dt><dd>{<code class="param">var</code> is a decision variable in the mathematical program, otherwise this function throws a runtime error.} </dd></dl>

</div>
</div>
<a id="a5aa2cdf4c8e6fae22b6b78718aeb0db0" name="a5aa2cdf4c8e6fae22b6b78718aeb0db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa2cdf4c8e6fae22b6b78718aeb0db0">&#9670;&#160;</a></span>FindDecisionVariableIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; FindDecisionVariableIndices </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Returns the indices of the decision variables. Internally the solvers
thinks all variables are stored in an array, and it accesses each
individual
variable using its index. This index is used when adding constraints
and costs for each solver.
@pre{@p vars are decision variables in the mathematical program, otherwise
</pre><p> this function throws a runtime error.} </p>

</div>
</div>
<a id="a1470ed93553619a1f630bc8035947556" name="a1470ed93553619a1f630bc8035947556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1470ed93553619a1f630bc8035947556">&#9670;&#160;</a></span>FindIndeterminateIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsize__t.html">size_t</a> FindIndeterminateIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of the indeterminate. </p>
<p>Internally a solver thinks all indeterminates are stored in an array, and it accesses each individual indeterminate using its index. This index is used when adding constraints and costs for each solver. </p><dl class="section pre"><dt>Precondition</dt><dd><code class="param">var</code> is a indeterminate in the mathematical program, otherwise this function throws a runtime error. </dd></dl>

</div>
</div>
<a id="a2efda53892ab1e6656e485cfecc3f9dc" name="a2efda53892ab1e6656e485cfecc3f9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2efda53892ab1e6656e485cfecc3f9dc">&#9670;&#160;</a></span>generic_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &gt; &amp; generic_constraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for all generic constraints. </p>

</div>
</div>
<a id="a36eaddbb4413ded70478606a4fe2d6cd" name="a36eaddbb4413ded70478606a4fe2d6cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36eaddbb4413ded70478606a4fe2d6cd">&#9670;&#160;</a></span>generic_costs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &gt; &amp; generic_costs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for all generic costs. </p>

</div>
</div>
<a id="ab1d6394dcd0825c2be850e170879e0a0" name="ab1d6394dcd0825c2be850e170879e0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d6394dcd0825c2be850e170879e0a0">&#9670;&#160;</a></span>GetAllConstraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &gt; GetAllConstraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for returning all constraints. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacedrake.html#a01ae662d5635b7c9efe03d15d976f7a8" title="A column vector templated on the number of rows.">Vector</a> of all constraint bindings. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The group ordering may change as more constraint types are added. </dd></dl>

</div>
</div>
<a id="affd2ba88c2d87f03bb94729e114c8ee7" name="affd2ba88c2d87f03bb94729e114c8ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd2ba88c2d87f03bb94729e114c8ee7">&#9670;&#160;</a></span>GetAllCosts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &gt; GetAllCosts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter returning all costs. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacedrake.html#a01ae662d5635b7c9efe03d15d976f7a8" title="A column vector templated on the number of rows.">Vector</a> of all cost bindings. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The group ordering may change as more cost types are added. </dd></dl>

</div>
</div>
<a id="a508ba9c7debb1c02bc558f636861f016" name="a508ba9c7debb1c02bc558f636861f016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508ba9c7debb1c02bc558f636861f016">&#9670;&#160;</a></span>GetAllLinearConstraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; &gt; GetAllLinearConstraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter returning all linear constraints (both linear equality and inequality constraints). </p>
<p>Note that this does <em>not</em> include bounding box constraints, which are technically also linear. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacedrake.html#a01ae662d5635b7c9efe03d15d976f7a8" title="A column vector templated on the number of rows.">Vector</a> of all linear constraint bindings. </dd></dl>

</div>
</div>
<a id="a608b6bbb4a0d0a4d00686ffdaba8923c" name="a608b6bbb4a0d0a4d00686ffdaba8923c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608b6bbb4a0d0a4d00686ffdaba8923c">&#9670;&#160;</a></span>GetBindingVariableValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C, typename DerivedX&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt; DerivedX &gt;::value, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; typename DerivedX::Scalar &gt; &gt; GetBindingVariableValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedX &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>prog_var_vals</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the value of all decision variables, namely this.decision_variable(i) takes the value prog_var_vals(i), returns the vector that contains the value of the variables in binding.variables(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binding</td><td>binding.variables() must be decision variables in this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </td></tr>
    <tr><td class="paramname">prog_var_vals</td><td>The value of ALL the decision variables in this program. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>binding_variable_vals binding_variable_vals(i) is the value of binding.variables()(i) in prog_var_vals. </dd></dl>

</div>
</div>
<a id="ad8f92f6f44a275134898901185826bc2" name="ad8f92f6f44a275134898901185826bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f92f6f44a275134898901185826bc2">&#9670;&#160;</a></span>GetInitialGuess() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, <a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; <a class="el" href="classdouble.html">double</a>, Derived &gt; &gt; GetInitialGuess </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>decision_variable_mat</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the initial guess for some variables. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Each variable in <code class="param">decision_variable_mat</code> has been registered in the optimization program. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the pre condition is not satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa44e07a559ca22d055de33fa1154c095" name="aa44e07a559ca22d055de33fa1154c095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44e07a559ca22d055de33fa1154c095">&#9670;&#160;</a></span>GetInitialGuess() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GetInitialGuess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>decision_variable</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the initial guess for a single variable. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code class="param">decision_variable</code> has been registered in the optimization program. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the pre condition is not satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeffcf790615d0cbfc2b05f80a42e2116" name="aeffcf790615d0cbfc2b05f80a42e2116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeffcf790615d0cbfc2b05f80a42e2116">&#9670;&#160;</a></span>GetVariableScaling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt; int, <a class="el" href="classdouble.html">double</a> &gt; &amp; GetVariableScaling </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the mapping from a decision variable index to its scaling factor. </p>
<p>See <a class="el" href="#variable_scaling">Variable scaling</a> for more information. </p>

</div>
</div>
<a id="a0f75da04ed0e8cc2aee0c5d4c5c19a9f" name="a0f75da04ed0e8cc2aee0c5d4c5c19a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f75da04ed0e8cc2aee0c5d4c5c19a9f">&#9670;&#160;</a></span>indeterminate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp; indeterminate </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the indeterminate with index <code class="param">i</code> in the program. </p>

</div>
</div>
<a id="a42256b8f076fda109cf611d3b45e2e5e" name="a42256b8f076fda109cf611d3b45e2e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42256b8f076fda109cf611d3b45e2e5e">&#9670;&#160;</a></span>indeterminates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Map&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; indeterminates </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for all indeterminates in the program. </p>

</div>
</div>
<a id="a5f8733e9e6866b4a4024e9c32043ab7d" name="a5f8733e9e6866b4a4024e9c32043ab7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8733e9e6866b4a4024e9c32043ab7d">&#9670;&#160;</a></span>indeterminates_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, int &gt; &amp; indeterminates_index </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the mapping from an indeterminate ID to its index in the vector containing all the indeterminates in the mathematical program. </p>

</div>
</div>
<a id="a3b1cc95b2fb414c59fc25d233731fc42" name="a3b1cc95b2fb414c59fc25d233731fc42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1cc95b2fb414c59fc25d233731fc42">&#9670;&#160;</a></span>initial_guess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::VectorXd &amp; initial_guess </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the initial guess. </p>

</div>
</div>
<a id="acde760e4bedab593fdf328530467fa4d" name="acde760e4bedab593fdf328530467fa4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde760e4bedab593fdf328530467fa4d">&#9670;&#160;</a></span>IsThreadSafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsThreadSafe </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether it is safe to solve this mathematical program concurrently. </p>
<p>A mathematical program is safe to solve concurrently if all of its cost, constraints, and visualization callbacks are marked as thread safe. </p>

</div>
</div>
<a id="a53b2bd4981be384bbafe8061fe3ca91c" name="a53b2bd4981be384bbafe8061fe3ca91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b2bd4981be384bbafe8061fe3ca91c">&#9670;&#160;</a></span>l2norm_costs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a> &gt; &gt; &amp; l2norm_costs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for l2norm costs. </p>

</div>
</div>
<a id="a45bb14b07171be6da1b721bd57086520" name="a45bb14b07171be6da1b721bd57086520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45bb14b07171be6da1b721bd57086520">&#9670;&#160;</a></span>linear_complementarity_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt; &gt; &amp; linear_complementarity_constraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for all linear complementarity constraints. </p>

</div>
</div>
<a id="a47db746f450147854f745ce5d7c339bf" name="a47db746f450147854f745ce5d7c339bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47db746f450147854f745ce5d7c339bf">&#9670;&#160;</a></span>linear_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; &gt; &amp; linear_constraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for linear <em>inequality</em> constraints. </p>
<p>Note that this does not include <a class="el" href="#a1047c3ed6cd2d49362c46ec044a6cf15" title="Getter for linear equality constraints.">linear_equality_constraints()</a> nor <a class="el" href="#abbf73d7148b272c9980e85f4ebffe109" title="Getter for all bounding box constraints.">bounding_box_constraints()</a>. See also <a class="el" href="#a508ba9c7debb1c02bc558f636861f016" title="Getter returning all linear constraints (both linear equality and inequality constraints).">GetAllLinearConstraints()</a>. </p>

</div>
</div>
<a id="a087b0d624bd07fa5c19e989fabb4b99d" name="a087b0d624bd07fa5c19e989fabb4b99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087b0d624bd07fa5c19e989fabb4b99d">&#9670;&#160;</a></span>linear_costs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; &gt; &amp; linear_costs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for linear costs. </p>

</div>
</div>
<a id="a1047c3ed6cd2d49362c46ec044a6cf15" name="a1047c3ed6cd2d49362c46ec044a6cf15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1047c3ed6cd2d49362c46ec044a6cf15">&#9670;&#160;</a></span>linear_equality_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &gt; &amp; linear_equality_constraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for linear equality constraints. </p>
<p>Note that this only includes constraints that were added explicitly as <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html" title="Implements a constraint of the form .">LinearEqualityConstraint</a> or which were added symbolically (and their equality constraint nature was uncovered). There may be <a class="el" href="#abbf73d7148b272c9980e85f4ebffe109" title="Getter for all bounding box constraints.">bounding_box_constraints()</a> and <a class="el" href="#a47db746f450147854f745ce5d7c339bf" title="Getter for linear inequality constraints.">linear_constraints()</a> whose lower bounds also equal their upper bounds. </p>

</div>
</div>
<a id="a877439eadc9880f433af13f5f3b6eeac" name="a877439eadc9880f433af13f5f3b6eeac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877439eadc9880f433af13f5f3b6eeac">&#9670;&#160;</a></span>linear_matrix_inequality_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt; &gt; &amp; linear_matrix_inequality_constraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for linear matrix inequality constraints. </p>

</div>
</div>
<a id="a69e353dc288cf713625fde3378489ec0" name="a69e353dc288cf713625fde3378489ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e353dc288cf713625fde3378489ec0">&#9670;&#160;</a></span>lorentz_cone_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; &gt; &amp; lorentz_cone_constraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for Lorentz cone constraints. </p>

</div>
</div>
<a id="ab7b3bbb3c397919036c360eced743e1f" name="ab7b3bbb3c397919036c360eced743e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b3bbb3c397919036c360eced743e1f">&#9670;&#160;</a></span>MakeCost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; MakeCost </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an input of type <code class="param">F</code> to a FunctionCost object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>This class should have functions numInputs(), numOutputs and eval(x, y). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9757b022381ac5841cd389a7e212dfbb" name="a9757b022381ac5841cd389a7e212dfbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9757b022381ac5841cd389a7e212dfbb">&#9670;&#160;</a></span>MakePolynomial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> MakePolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a symbolic polynomial from the given expression <span class="tt">e</span>. </p>
<p>It uses this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>'s <span class="tt"><a class="el" href="#a42256b8f076fda109cf611d3b45e2e5e" title="Getter for all indeterminates in the program.">indeterminates()</a></span> in constructing the polynomial.</p>
<p>This method helps a user create a polynomial with the right set of indeterminates which are declared in this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. We recommend users to use this method over an explicit call to <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> constructors to avoid a possible mismatch between this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>'s indeterminates and the user-specified indeterminates (or unspecified, which then includes all symbolic variables in the expression <span class="tt">e</span>). Consider the following example.</p>
<p>e = ax + bx + c</p>
<p>MP.indeterminates() = {x} MP.decision_variables() = {a, b}</p>
<ul>
<li><span class="tt">MP.MakePolynomial(e)</span> create a polynomial, <span class="tt">(a + b)x + c</span>. Here only <span class="tt">x</span> is an indeterminate of this polynomial.</li>
<li>In contrast, <span class="tt">symbolic::Polynomial(e)</span> returns <span class="tt">ax + bx + c</span> where all variables <span class="tt">{a, b, x}</span> are indeterminates. Note that this is problematic as its indeterminates, <span class="tt">{a, b, x}</span> and the <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>'s decision variables, <span class="tt">{a, b}</span> overlap.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function does not require that the decision variables in <span class="tt">e</span> is a subset of the decision variables in <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </dd></dl>

</div>
</div>
<a id="aef5bd1296de2515ce750f5ebe441a15a" name="aef5bd1296de2515ce750f5ebe441a15a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5bd1296de2515ce750f5ebe441a15a">&#9670;&#160;</a></span>NewBinaryVariables() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Rows, int Cols = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; Rows, Cols &gt; NewBinaryVariables </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;b&quot;</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a matrix of binary variables into the optimization program. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rows</td><td>The number of rows in the newly added binary variables. </td></tr>
    <tr><td class="paramname">Cols</td><td>The number of columns in the new variables. The default is 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Each newly added binary variable will share the same name. The default name is "b". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix containing the newly added variables. </dd></dl>

</div>
</div>
<a id="a30759ec657805673fd0ce5e9edc166a2" name="a30759ec657805673fd0ce5e9edc166a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30759ec657805673fd0ce5e9edc166a2">&#9670;&#160;</a></span>NewBinaryVariables() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> NewBinaryVariables </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;b&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds binary variables to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </p>
<p>The new variables are viewed as a column vector, with size <code class="param">rows</code> x 1. </p><dl class="section see"><dt>See also</dt><dd>NewBinaryVariables(int rows, int cols, const
std::vector&lt;std::string&gt;&amp; names); </dd></dl>

</div>
</div>
<a id="a7b23670884fad3013a08886ad21ab297" name="a7b23670884fad3013a08886ad21ab297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b23670884fad3013a08886ad21ab297">&#9670;&#160;</a></span>NewBinaryVariables() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Rows = Eigen::Dynamic, int Cols = Eigen::Dynamic&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; Rows, Cols &gt; NewBinaryVariables </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds binary variables, appending them to an internal vector of any existing vars. </p>
<p>The initial guess values for the new variables are set to NaN, to indicate that an initial guess has not been assigned. Callers are expected to add costs and/or constraints to have any effect during optimization. Callers can also set the initial guess of the decision variables through <a class="el" href="#ae48cb6d2263ccf09e38932dcd27f769f" title="Sets the initial guess for a single variable decision_variable.">SetInitialGuess()</a> or <a class="el" href="#ae35679ed5aabea90fcf4ff3b337b44f5" title="Set the initial guess for ALL decision variables.">SetInitialGuessForAllVariables()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rows</td><td>The number of rows in the new variables. </td></tr>
    <tr><td class="paramname">Cols</td><td>The number of columns in the new variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new variables. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns in the new variables. </td></tr>
    <tr><td class="paramname">name</td><td>The commonly shared name of the new variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a> of size rows x cols, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> prog;</div>
<div class="line"><span class="keyword">auto</span> b = prog.<a class="code hl_function" href="#a7b23670884fad3013a08886ad21ab297">NewBinaryVariables</a>(2, 3, <span class="stringliteral">&quot;b&quot;</span>);</div>
<div class="ttc" id="aclassdrake_1_1solvers_1_1_mathematical_program_html_a7b23670884fad3013a08886ad21ab297"><div class="ttname"><a href="#a7b23670884fad3013a08886ad21ab297">drake::solvers::MathematicalProgram::NewBinaryVariables</a></div><div class="ttdeci">MatrixDecisionVariable&lt; Rows, Cols &gt; NewBinaryVariables(int rows, int cols, const std::string &amp;name)</div><div class="ttdoc">Adds binary variables, appending them to an internal vector of any existing vars.</div><div class="ttdef"><b>Definition</b> mathematical_program.h:354</div></div>
</div><!-- fragment --><p> This adds a 2 x 3 matrix decision variables into the program.</p>
<p>The name of the variable is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="a2bf2905bcc0613bc5055e13f6ed4ff1b" name="a2bf2905bcc0613bc5055e13f6ed4ff1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf2905bcc0613bc5055e13f6ed4ff1b">&#9670;&#160;</a></span>NewContinuousVariables() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Rows, int Cols = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; Rows, Cols &gt; NewContinuousVariables </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;X&quot;</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds continuous variables, appending them to an internal vector of any existing vars. </p>
<p>The initial guess values for the new variables are set to NaN, to indicate that an initial guess has not been assigned. Callers are expected to add costs and/or constraints to have any effect during optimization. Callers can also set the initial guess of the decision variables through <a class="el" href="#ae48cb6d2263ccf09e38932dcd27f769f" title="Sets the initial guess for a single variable decision_variable.">SetInitialGuess()</a> or <a class="el" href="#ae35679ed5aabea90fcf4ff3b337b44f5" title="Set the initial guess for ALL decision variables.">SetInitialGuessForAllVariables()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rows</td><td>The number of rows in the new variables. </td></tr>
    <tr><td class="paramname">Cols</td><td>The number of columns in the new variables. The default is 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>All variables will share the same name, but different index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a> of size rows x cols, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> prog;</div>
<div class="line"><span class="keyword">auto</span> x = prog.<a class="code hl_function" href="#a53949966a66a6f53ba90596fc5a439ef">NewContinuousVariables</a>&lt;2, 3&gt;(<span class="stringliteral">&quot;X&quot;</span>);</div>
</div><!-- fragment --><p> This adds a 2 x 3 matrix decision variables into the program.</p>
<p>The name of the variable is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="a53949966a66a6f53ba90596fc5a439ef" name="a53949966a66a6f53ba90596fc5a439ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53949966a66a6f53ba90596fc5a439ef">&#9670;&#160;</a></span>NewContinuousVariables() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> NewContinuousVariables </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;x&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds continuous variables, appending them to an internal vector of any existing vars. </p>
<p>The initial guess values for the new variables are set to NaN, to indicate that an initial guess has not been assigned. Callers are expected to add costs and/or constraints to have any effect during optimization. Callers can also set the initial guess of the decision variables through <a class="el" href="#ae48cb6d2263ccf09e38932dcd27f769f" title="Sets the initial guess for a single variable decision_variable.">SetInitialGuess()</a> or <a class="el" href="#ae35679ed5aabea90fcf4ff3b337b44f5" title="Set the initial guess for ALL decision variables.">SetInitialGuessForAllVariables()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new variables. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the newly added variables </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="namespacedrake_1_1solvers.html#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a> of size rows x 1, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> prog;</div>
<div class="line"><span class="keyword">auto</span> x = prog.<a class="code hl_function" href="#a53949966a66a6f53ba90596fc5a439ef">NewContinuousVariables</a>(2, <span class="stringliteral">&quot;x&quot;</span>);</div>
</div><!-- fragment --><p> This adds a 2 x 1 vector containing decision variables into the program. The names of the variables are "x(0)" and "x(1)".</p>
<p>The name of the variable is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="ac4289eb81e87e5ba7ebd0769439afe1e" name="ac4289eb81e87e5ba7ebd0769439afe1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4289eb81e87e5ba7ebd0769439afe1e">&#9670;&#160;</a></span>NewContinuousVariables() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Rows = Eigen::Dynamic, int Cols = Eigen::Dynamic&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; Rows, Cols &gt; NewContinuousVariables </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;X&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds continuous variables, appending them to an internal vector of any existing vars. </p>
<p>The initial guess values for the new variables are set to NaN, to indicate that an initial guess has not been assigned. Callers are expected to add costs and/or constraints to have any effect during optimization. Callers can also set the initial guess of the decision variables through <a class="el" href="#ae48cb6d2263ccf09e38932dcd27f769f" title="Sets the initial guess for a single variable decision_variable.">SetInitialGuess()</a> or <a class="el" href="#ae35679ed5aabea90fcf4ff3b337b44f5" title="Set the initial guess for ALL decision variables.">SetInitialGuessForAllVariables()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rows</td><td>The number of rows of the new variables, in the compile time. </td></tr>
    <tr><td class="paramname">Cols</td><td>The number of columns of the new variables, in the compile time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new variables. When Rows is not Eigen::Dynamic, rows is ignored. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns in the new variables. When Cols is not Eigen::Dynamic, cols is ignored. </td></tr>
    <tr><td class="paramname">name</td><td>All variables will share the same name, but different index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a> of size Rows x Cols, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> prog;</div>
<div class="line"><span class="keyword">auto</span> x = prog.<a class="code hl_function" href="#a53949966a66a6f53ba90596fc5a439ef">NewContinuousVariables</a>(2, 3, <span class="stringliteral">&quot;X&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> y = prog.<a class="code hl_function" href="#a53949966a66a6f53ba90596fc5a439ef">NewContinuousVariables</a>&lt;2, 3&gt;(2, 3, <span class="stringliteral">&quot;X&quot;</span>);</div>
</div><!-- fragment --><p> This adds a 2 x 3 matrix decision variables into the program.</p>
<p>The name of the variable is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="a84fc64a5a0af849e40b85214d8c60955" name="a84fc64a5a0af849e40b85214d8c60955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84fc64a5a0af849e40b85214d8c60955">&#9670;&#160;</a></span>NewEvenDegreeDsosPolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt; NewEvenDegreeDsosPolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>indeterminates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>degree</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>see <a class="el" href="#even_degree_nonnegative_polynomial">even_degree_nonnegative_polynomial</a> for details. </p>
<p>Variant that produces a DSOS polynomial. Same as NewEvenDegreeSosPolynomial, except the returned polynomial is diagonally dominant sum of squares (dsos). </p>

</div>
</div>
<a id="a4892d2259256cc4aff04a354391eae77" name="a4892d2259256cc4aff04a354391eae77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4892d2259256cc4aff04a354391eae77">&#9670;&#160;</a></span>NewEvenDegreeFreePolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> NewEvenDegreeFreePolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>indeterminates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>degree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>coeff_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;a&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a free polynomial that only contains even degree monomials. </p>
<p>A monomial is even degree if its total degree (sum of all variables' degree) is even. For example, xy is an even degree monomial (degree 2) while x²y is not (degree 3). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indeterminates</td><td>The monomial basis is over these indeterminates. </td></tr>
    <tr><td class="paramname">degree</td><td>The highest degree of the polynomial. </td></tr>
    <tr><td class="paramname">coeff_name</td><td>The coefficients of the polynomial are decision variables with this name as a base. The variable name would be "a1", "a2", etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dda62aec4fd45a95cad1867d9361854" name="a5dda62aec4fd45a95cad1867d9361854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dda62aec4fd45a95cad1867d9361854">&#9670;&#160;</a></span>NewEvenDegreeNonnegativePolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt; NewEvenDegreeNonnegativePolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>indeterminates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>degree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="#even_degree_nonnegative_polynomial">even_degree_nonnegative_polynomial</a> for more details. </p>
<p>Variant that produces different non-negative polynomials depending on <code class="param">type</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The returned polynomial p(x) can be either SOS, SDSOS or DSOS, depending on <code class="param">type</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af958ec779d15747753ee886d28974382" name="af958ec779d15747753ee886d28974382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af958ec779d15747753ee886d28974382">&#9670;&#160;</a></span>NewEvenDegreeSdsosPolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt; NewEvenDegreeSdsosPolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>indeterminates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>degree</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>see <a class="el" href="#even_degree_nonnegative_polynomial">even_degree_nonnegative_polynomial</a> for details. </p>
<p>Variant that produces an SDSOS polynomial. </p>

</div>
</div>
<a id="afca1e0b1836c6cb3034c0f0903366723" name="afca1e0b1836c6cb3034c0f0903366723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca1e0b1836c6cb3034c0f0903366723">&#9670;&#160;</a></span>NewEvenDegreeSosPolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt; NewEvenDegreeSosPolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>indeterminates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>degree</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="#even_degree_nonnegative_polynomial">even_degree_nonnegative_polynomial</a> for more details. </p>
<p>Variant that produces a SOS polynomial. </p>

</div>
</div>
<a id="ae6a71c1f6466e5dedbd2cd73372dfcd5" name="ae6a71c1f6466e5dedbd2cd73372dfcd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a71c1f6466e5dedbd2cd73372dfcd5">&#9670;&#160;</a></span>NewFreePolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> NewFreePolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>indeterminates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>degree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>coeff_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;a&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a free polynomial in a monomial basis over <code class="param">indeterminates</code> of a given <code class="param">degree</code>. </p>
<p>It uses <code class="param">coeff_name</code> to make new decision variables and use them as coefficients. For example, <span class="tt"><a class="el" href="#ae6a71c1f6466e5dedbd2cd73372dfcd5" title="Returns a free polynomial in a monomial basis over indeterminates of a given degree.">NewFreePolynomial</a>({x₀, x₁}, 2)</span> returns a₀x₁² + a₁x₀x₁ + a₂x₀² + a₃x₁ + a₄x₀ + a₅. </p>

</div>
</div>
<a id="a46a010c4311bb044d66b14c16334db19" name="a46a010c4311bb044d66b14c16334db19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a010c4311bb044d66b14c16334db19">&#9670;&#160;</a></span>NewIndeterminates() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rows, int cols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a>&lt; rows, cols &gt; NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::string, rows *cols &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>names</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates, appending them to an internal vector of any existing indeterminates. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new indeterminates. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns in the new indeterminates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>A vector of strings containing the name for each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec" title="MatrixIndeterminate&lt;int, int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable,...">MatrixIndeterminate</a> of size rows x cols, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> prog;</div>
<div class="line">std::array&lt;std::string, 6&gt; names = {<span class="stringliteral">&quot;x1&quot;</span>, <span class="stringliteral">&quot;x2&quot;</span>, <span class="stringliteral">&quot;x3&quot;</span>, <span class="stringliteral">&quot;x4&quot;</span>, <span class="stringliteral">&quot;x5&quot;</span>, <span class="stringliteral">&quot;x6&quot;</span>};</div>
<div class="line"><span class="keyword">auto</span> x = prog.<a class="code hl_function" href="#a46a010c4311bb044d66b14c16334db19">NewIndeterminates</a>&lt;2, 3&gt;(names);</div>
<div class="ttc" id="aclassdrake_1_1solvers_1_1_mathematical_program_html_a46a010c4311bb044d66b14c16334db19"><div class="ttname"><a href="#a46a010c4311bb044d66b14c16334db19">drake::solvers::MathematicalProgram::NewIndeterminates</a></div><div class="ttdeci">MatrixIndeterminate&lt; rows, cols &gt; NewIndeterminates(const std::array&lt; std::string, rows *cols &gt; &amp;names)</div><div class="ttdoc">Adds indeterminates, appending them to an internal vector of any existing indeterminates.</div><div class="ttdef"><b>Definition</b> mathematical_program.h:691</div></div>
</div><!-- fragment --><p> This adds a 2 x 3 matrix indeterminates into the program.</p>
<p>The name of the indeterminates is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="a819e745c1bb12da1806d5d7efec80bce" name="a819e745c1bb12da1806d5d7efec80bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819e745c1bb12da1806d5d7efec80bce">&#9670;&#160;</a></span>NewIndeterminates() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rows&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a>&lt; rows &gt; NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::string, rows &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>names</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates, appending them to an internal vector of any existing indeterminates. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new indeterminates. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns in the new indeterminates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>A vector of strings containing the name for each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec" title="MatrixIndeterminate&lt;int, int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable,...">MatrixIndeterminate</a> of size rows x cols, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> prog;</div>
<div class="line">std::array&lt;std::string, 2&gt; names = {<span class="stringliteral">&quot;x1&quot;</span>, <span class="stringliteral">&quot;x2&quot;</span>};</div>
<div class="line"><span class="keyword">auto</span> x = prog.<a class="code hl_function" href="#a46a010c4311bb044d66b14c16334db19">NewIndeterminates</a>&lt;2&gt;(names);</div>
</div><!-- fragment --><p> This adds a 2 vector indeterminates into the program.</p>
<p>The name of the indeterminates is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="a1fe5bb17e18cc4fca0687ba3af361da0" name="a1fe5bb17e18cc4fca0687ba3af361da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe5bb17e18cc4fca0687ba3af361da0">&#9670;&#160;</a></span>NewIndeterminates() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rows, int cols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a>&lt; rows, cols &gt; NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;X&quot;</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates, appending them to an internal vector of any existing indeterminates. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new indeterminates. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns in the new indeterminates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>All variables will share the same name, but different index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec" title="MatrixIndeterminate&lt;int, int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable,...">MatrixIndeterminate</a> of size rows x cols, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> prog;</div>
<div class="line"><span class="keyword">auto</span> x = prog.<a class="code hl_function" href="#a46a010c4311bb044d66b14c16334db19">NewIndeterminates</a>&lt;2, 3&gt;(<span class="stringliteral">&quot;X&quot;</span>);</div>
</div><!-- fragment --><p> This adds a 2 x 3 matrix indeterminates into the program.</p>
<p>The name of the indeterminates is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="a32ebe0215c7d23795508d0b552027608" name="a32ebe0215c7d23795508d0b552027608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ebe0215c7d23795508d0b552027608">&#9670;&#160;</a></span>NewIndeterminates() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rows&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a>&lt; rows &gt; NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;x&quot;</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates to the program. </p>
<p>The name for all newly added indeterminates are set to <code class="param">name</code>. The default name is "x" </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a819e745c1bb12da1806d5d7efec80bce" title="Adds indeterminates, appending them to an internal vector of any existing indeterminates.">NewIndeterminates(const std::array&lt;std::string, rows&gt;&amp; names)</a> </dd></dl>

</div>
</div>
<a id="ae4ec9c4fc4ae8f5d8ff8382b227dd82f" name="ae4ec9c4fc4ae8f5d8ff8382b227dd82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ec9c4fc4ae8f5d8ff8382b227dd82f">&#9670;&#160;</a></span>NewIndeterminates() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a> NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;x&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>, with default name "x". </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a12431081348a404711db4d3bb25c8a76" title="Adds indeterminates, appending them to an internal vector of any existing vars.">NewIndeterminates(int rows, int cols, const
std::vector&lt;std::string&gt;&amp; names)</a>; </dd></dl>

</div>
</div>
<a id="a0fd679ea34528e50d76d23f79fcd294f" name="a0fd679ea34528e50d76d23f79fcd294f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd679ea34528e50d76d23f79fcd294f">&#9670;&#160;</a></span>NewIndeterminates() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a> NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>names</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a12431081348a404711db4d3bb25c8a76" title="Adds indeterminates, appending them to an internal vector of any existing vars.">NewIndeterminates(int rows, int cols, const
std::vector&lt;std::string&gt;&amp; names)</a>; </dd></dl>

</div>
</div>
<a id="ad7e4fa58845ca19073b0c532431ac141" name="ad7e4fa58845ca19073b0c532431ac141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e4fa58845ca19073b0c532431ac141">&#9670;&#160;</a></span>NewIndeterminates() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a7ab45e84bec7fad9608e19ae3441b0bf">MatrixXIndeterminate</a> NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;X&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>, with default name "X". </p>
<p>The new variables are returned and viewed as a matrix, with size <code class="param">rows</code> x <code class="param">cols</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a12431081348a404711db4d3bb25c8a76" title="Adds indeterminates, appending them to an internal vector of any existing vars.">NewIndeterminates(int rows, int cols, const
std::vector&lt;std::string&gt;&amp; names)</a>; </dd></dl>

</div>
</div>
<a id="a12431081348a404711db4d3bb25c8a76" name="a12431081348a404711db4d3bb25c8a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12431081348a404711db4d3bb25c8a76">&#9670;&#160;</a></span>NewIndeterminates() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a7ab45e84bec7fad9608e19ae3441b0bf">MatrixXIndeterminate</a> NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>names</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates, appending them to an internal vector of any existing vars. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new indeterminates. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns in the new indeterminates. </td></tr>
    <tr><td class="paramname">names</td><td>A vector of strings containing the name for each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec" title="MatrixIndeterminate&lt;int, int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable,...">MatrixIndeterminate</a> of size rows x cols, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> prog;</div>
<div class="line"><span class="keyword">auto</span> x = prog.<a class="code hl_function" href="#a46a010c4311bb044d66b14c16334db19">NewIndeterminates</a>(2, 3, {<span class="stringliteral">&quot;x1&quot;</span>, <span class="stringliteral">&quot;x2&quot;</span>, <span class="stringliteral">&quot;x3&quot;</span>, <span class="stringliteral">&quot;x4&quot;</span>,</div>
<div class="line"><span class="stringliteral">&quot;x5&quot;</span>, <span class="stringliteral">&quot;x6&quot;</span>});</div>
</div><!-- fragment --><p> This adds a 2 x 3 matrix indeterminates into the program.</p>
<p>The name of the variable is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="aa65f91d84b3f2f0a5354def05ddb51e4" name="aa65f91d84b3f2f0a5354def05ddb51e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa65f91d84b3f2f0a5354def05ddb51e4">&#9670;&#160;</a></span>NewOddDegreeFreePolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> NewOddDegreeFreePolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>indeterminates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>degree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>coeff_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;a&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a free polynomial that only contains odd degree monomials. </p>
<p>A monomial is odd degree if its total degree (sum of all variables' degree) is even. For example, xy is not an odd degree monomial (degree 2) while x²y is (degree 3). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indeterminates</td><td>The monomial basis is over these indeterminates. </td></tr>
    <tr><td class="paramname">degree</td><td>The highest degree of the polynomial. </td></tr>
    <tr><td class="paramname">coeff_name</td><td>The coefficients of the polynomial are decision variables with this name as a base. The variable name would be "a1", "a2", etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27dc3e26c390f156079b2380ade4a28a" name="a27dc3e26c390f156079b2380ade4a28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27dc3e26c390f156079b2380ade4a28a">&#9670;&#160;</a></span>NewSosPolynomial() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> NewSosPolynomial </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gramian</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>monomial_basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads NewSosPolynomial, except the Gramian matrix Q is an input instead of an output. </p>

</div>
</div>
<a id="a7959d174df7776311b5520c2ab0b698b" name="a7959d174df7776311b5520c2ab0b698b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7959d174df7776311b5520c2ab0b698b">&#9670;&#160;</a></span>NewSosPolynomial() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt; NewSosPolynomial </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>monomial_basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>gram_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;S&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pair of a SOS polynomial p = mᵀQm and the Gramian matrix Q, where m is the <code class="param">monomial</code> basis. </p>
<p>For example, <span class="tt"><a class="el" href="#a7959d174df7776311b5520c2ab0b698b" title="Returns a pair of a SOS polynomial p = mᵀQm and the Gramian matrix Q, where m is the monomial basis.">NewSosPolynomial</a>(<a class="el" href="namespacedrake.html#ab9f8b7dbd727440c2dd207bf43812f1e" title="A column vector of size 2, templated on scalar type.">Vector2</a>&lt;Monomial&gt;{x,y})</span> returns a polynomial p = Q₍₀,₀₎x² + 2Q₍₁,₀₎xy + Q₍₁,₁₎y² and Q. Depending on the type of the polynomial, we will impose different constraint on the polynomial.</p><ul>
<li>if type = kSos, we impose the polynomial being SOS.</li>
<li>if type = kSdsos, we impose the polynomial being SDSOS.</li>
<li>if type = kDsos, we impose the polynomial being DSOS. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gram_name</td><td>The name of the gram matrix for print out. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Q is a symmetric monomial_basis.rows() x monomial_basis.rows() matrix. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="afe6d3a84c9a6e47773fc5950cfc6956b" name="afe6d3a84c9a6e47773fc5950cfc6956b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6d3a84c9a6e47773fc5950cfc6956b">&#9670;&#160;</a></span>NewSosPolynomial() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt; NewSosPolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>indeterminates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>degree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>gram_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;S&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads NewSosPolynomial. </p>
<p>Returns a pair of a SOS polynomial p = m(x)ᵀQm(x) of degree <code class="param">degree</code> and the Gramian matrix Q that should be PSD, where m(x) is the result of calling <span class="tt">MonomialBasis(<a class="el" href="#a42256b8f076fda109cf611d3b45e2e5e" title="Getter for all indeterminates in the program.">indeterminates</a>, degree/2)</span>. For example, <span class="tt"><a class="el" href="#a7959d174df7776311b5520c2ab0b698b" title="Returns a pair of a SOS polynomial p = mᵀQm and the Gramian matrix Q, where m is the monomial basis.">NewSosPolynomial</a>({x}, 4)</span> returns a pair of a polynomial p = Q₍₀,₀₎x⁴ + 2Q₍₁,₀₎ x³ + (2Q₍₂,₀₎ + Q₍₁,₁₎)x² + 2Q₍₂,₁₎x + Q₍₂,₂₎ and Q. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Depending on the type of the polynomial, we will impose different constraint on the polynomial.<ul>
<li>if type = kSos, we impose the polynomial being SOS.</li>
<li>if type = kSdsos, we impose the polynomial being SDSOS.</li>
<li>if type = kDsos, we impose the polynomial being DSOS. </li>
</ul>
</td></tr>
    <tr><td class="paramname">gram_name</td><td>The name of the gram matrix for print out.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code class="param">degree</code> is not a positive even integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>MonomialBasis. </dd></dl>

</div>
</div>
<a id="a70518c4015597117ed5981c729917312" name="a70518c4015597117ed5981c729917312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70518c4015597117ed5981c729917312">&#9670;&#160;</a></span>NewSymmetricContinuousVariables() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rows&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; rows, rows &gt; NewSymmetricContinuousVariables </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;Symmetric&quot;</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a static sized symmetric matrix as decision variables to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </p>
<p>The optimization will only use the stacked columns of the lower triangular part of the symmetric matrix as decision variables. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the symmetric matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the matrix. It is only used the for user to understand the optimization program. The default name is "Symmetric", and each variable will be named as <pre>
Symmetric(0, 0)     Symmetric(1, 0)     ... Symmetric(rows-1, 0)
Symmetric(1, 0)     Symmetric(1, 1)     ... Symmetric(rows-1, 1)
           ...
Symmetric(rows-1,0) Symmetric(rows-1,1) ... Symmetric(rows-1, rows-1)
</pre> Notice that the (i,j)'th entry and (j,i)'th entry has the same name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added decision variables. </dd></dl>

</div>
</div>
<a id="a8f718351922bc149cb6e7fa6d82288a5" name="a8f718351922bc149cb6e7fa6d82288a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f718351922bc149cb6e7fa6d82288a5">&#9670;&#160;</a></span>NewSymmetricContinuousVariables() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> NewSymmetricContinuousVariables </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;Symmetric&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a runtime sized symmetric matrix as decision variables to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </p>
<p>The optimization will only use the stacked columns of the lower triangular part of the symmetric matrix as decision variables. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the symmetric matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the matrix. It is only used the for user to understand the optimization program. The default name is "Symmetric", and each variable will be named as <pre>
Symmetric(0, 0)     Symmetric(1, 0)     ... Symmetric(rows-1, 0)
Symmetric(1, 0)     Symmetric(1, 1)     ... Symmetric(rows-1, 1)
           ...
Symmetric(rows-1,0) Symmetric(rows-1,1) ... Symmetric(rows-1, rows-1)
</pre> Notice that the (i,j)'th entry and (j,i)'th entry has the same name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added decision variables. </dd></dl>

</div>
</div>
<a id="a3b1e942fc28f03d2b987fc0ea880e831" name="a3b1e942fc28f03d2b987fc0ea880e831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1e942fc28f03d2b987fc0ea880e831">&#9670;&#160;</a></span>num_indeterminates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int num_indeterminates </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of indeterminates in the optimization program. </p>

</div>
</div>
<a id="a224e4c35014e87139f73f9a517866796" name="a224e4c35014e87139f73f9a517866796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224e4c35014e87139f73f9a517866796">&#9670;&#160;</a></span>num_vars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int num_vars </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for number of variables in the optimization program. </p>

</div>
</div>
<a id="a52818d384c5209004e28e368159dc3f8" name="a52818d384c5209004e28e368159dc3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52818d384c5209004e28e368159dc3f8">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb492b0c14e1ddab97608e6ebdc0cb58" name="aeb492b0c14e1ddab97608e6ebdc0cb58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb492b0c14e1ddab97608e6ebdc0cb58">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9cc8ec6b6a2747fb3eb73eb68e4e4095" name="a9cc8ec6b6a2747fb3eb73eb68e4e4095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc8ec6b6a2747fb3eb73eb68e4e4095">&#9670;&#160;</a></span>positive_semidefinite_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; &gt; &amp; positive_semidefinite_constraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for positive semidefinite constraints. </p>

</div>
</div>
<a id="a651c724635f0f4ae4e38830d4ff68537" name="a651c724635f0f4ae4e38830d4ff68537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651c724635f0f4ae4e38830d4ff68537">&#9670;&#160;</a></span>quadratic_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_constraint.html">QuadraticConstraint</a> &gt; &gt; &amp; quadratic_constraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for quadratic constraints. </p>

</div>
</div>
<a id="ae5d8798432ed63b84b5ed9f14052cb65" name="ae5d8798432ed63b84b5ed9f14052cb65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d8798432ed63b84b5ed9f14052cb65">&#9670;&#160;</a></span>quadratic_costs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; &gt; &amp; quadratic_costs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for quadratic costs. </p>

</div>
</div>
<a id="ad72afe48df383e9d91358cc30567d24b" name="ad72afe48df383e9d91358cc30567d24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad72afe48df383e9d91358cc30567d24b">&#9670;&#160;</a></span>RelaxPsdConstraintToDdDualCone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; RelaxPsdConstraintToDdDualCone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>constraint</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<ol type="1">
<li>Relaxes the positive semidefinite <code class="param">constraint</code> with a diagonally dominant dual cone constraint.</li>
<li>Adds the diagonally dominant dual cone constraint into this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.</li>
<li>Removes the positive semidefinite <code class="param">constraint</code>, if it had already been registered in this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.</li>
</ol>
<p>This provides a polyhedral (i.e. linear) necessary, but not sufficient, condition for the variables in <code class="param">constraint</code> to be positive semidefinite.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The decision variables contained in constraint have been registered with this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The return of AddPositiveDiagonallyDominantDualConeMatrixConstraint applied to the variables in <code class="param">constraint</code>. </dd></dl>

</div>
</div>
<a id="a0c1a80d727e311f0d6f1a08edaa7f345" name="a0c1a80d727e311f0d6f1a08edaa7f345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c1a80d727e311f0d6f1a08edaa7f345">&#9670;&#160;</a></span>RelaxPsdConstraintToSddDualCone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; &gt; RelaxPsdConstraintToSddDualCone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>constraint</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<ol type="1">
<li>Relaxes the positive semidefinite <code class="param">constraint</code> with a scaled diagonally dominant dual cone constraint.</li>
<li>Adds the scaled diagonally dominant dual cone constraint into this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.</li>
<li>Removes the positive semidefinite <code class="param">constraint</code>, if it had already been registered in this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.</li>
</ol>
<p>This provides a second-order cone necessary, but not sufficient, condition for the variables in <code class="param">constraint</code> to be positive semidefinite.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The decision variables contained in constraint have been registered with this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The return of AddScaledDiagonallyDominantDualConeMatrixConstraint applied to the variables in <code class="param">constraint</code>. </dd></dl>

</div>
</div>
<a id="acb1b59ceeeec9235267e4a8b6d440c9f" name="acb1b59ceeeec9235267e4a8b6d440c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1b59ceeeec9235267e4a8b6d440c9f">&#9670;&#160;</a></span>RemoveConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RemoveConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>constraint</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes <code class="param">constraint</code> from this mathematical program. </p>
<p>See <a class="el" href="#remove_cost_constraint">Remove costs, constraints or callbacks</a> for more details. </p><dl class="section return"><dt>Returns</dt><dd>number of constraint objects removed from this program. If this program doesn't contain <code class="param">constraint</code>, then returns 0. If this program contains multiple <code class="param">constraint</code> objects, then returns the repetition of <code class="param">constraint</code> in this program. </dd></dl>

</div>
</div>
<a id="a776ae5f3bb0dc9a705c584e511aff067" name="a776ae5f3bb0dc9a705c584e511aff067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776ae5f3bb0dc9a705c584e511aff067">&#9670;&#160;</a></span>RemoveCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RemoveCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cost</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes <code class="param">cost</code> from this mathematical program. </p>
<p>See <a class="el" href="#remove_cost_constraint">Remove costs, constraints or callbacks</a> for more details. </p><dl class="section return"><dt>Returns</dt><dd>number of cost objects removed from this program. If this program doesn't contain <code class="param">cost</code>, then returns 0. If this program contains multiple <code class="param">cost</code> objects, then returns the repetition of <code class="param">cost</code> in this program. </dd></dl>

</div>
</div>
<a id="a581e627b1c23f4427ec3cee17760812a" name="a581e627b1c23f4427ec3cee17760812a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581e627b1c23f4427ec3cee17760812a">&#9670;&#160;</a></span>RemoveDecisionVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RemoveDecisionVariable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove <span class="tt">var</span> from this program's decision variable. </p>
<dl class="section note"><dt>Note</dt><dd>after removing the variable, the indices of some remaining variables inside this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> will change. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the index of <span class="tt">var</span> in this optimization program. return -1 if <span class="tt">var</span> is not a decision variable. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if <span class="tt">var</span> is bound with any cost or constraint. </td></tr>
    <tr><td class="paramname">exception</td><td>if <span class="tt">var</span> is not a decision variable of the program. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed6328ee1df2fa0f13f00151bc9f579f" name="aed6328ee1df2fa0f13f00151bc9f579f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6328ee1df2fa0f13f00151bc9f579f">&#9670;&#160;</a></span>RemoveVisualizationCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RemoveVisualizationCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html">VisualizationCallback</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes <code class="param">callback</code> from this mathematical program. </p>
<p>See <a class="el" href="#remove_cost_constraint">Remove costs, constraints or callbacks</a> for more details. </p><dl class="section return"><dt>Returns</dt><dd>number of callback objects removed from this program. If this program doesn't contain <code class="param">callback</code>, then returns 0. If this program contains multiple <code class="param">callback</code> objects, then returns the repetition of <code class="param">callback</code> in this program. </dd></dl>

</div>
</div>
<a id="aee9493ea7d08a35395634bfbfd5713dd" name="aee9493ea7d08a35395634bfbfd5713dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9493ea7d08a35395634bfbfd5713dd">&#9670;&#160;</a></span>Reparse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> *</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reparses the polynomial <span class="tt">p</span> using this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>'s indeterminates. </p>

</div>
</div>
<a id="a83bb9dd09607a749769b9f9102395740" name="a83bb9dd09607a749769b9f9102395740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83bb9dd09607a749769b9f9102395740">&#9670;&#160;</a></span>required_capabilities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp; required_capabilities </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the required capability on the solver, given the cost/constraint/variable types in the program. </p>

</div>
</div>
<a id="a9f19b917654b3dfd4d2a2a08ef296e1e" name="a9f19b917654b3dfd4d2a2a08ef296e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f19b917654b3dfd4d2a2a08ef296e1e">&#9670;&#160;</a></span>rotated_lorentz_cone_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; &gt; &amp; rotated_lorentz_cone_constraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for rotated Lorentz cone constraints. </p>

</div>
</div>
<a id="afff086e342ead2410215c884dfd4e82d" name="afff086e342ead2410215c884dfd4e82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff086e342ead2410215c884dfd4e82d">&#9670;&#160;</a></span>SetDecisionVariableValueInVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetDecisionVariableValueInVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>decision_variables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>decision_variables_new_values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::VectorXd &gt;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the values of some <code class="param">decision_variables</code> inside the <code class="param">values</code> vector to be <code class="param">decision_variables_new_values</code>. </p>
<p>The other decision variables' values in <code class="param">values</code> are unchanged. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">decision_variables</td><td>registered decision variables in this program. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">decision_variables_new_values</td><td>the variables' respective new values; must have the same rows() and cols() sizes and <code class="param">decision_variables</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>The vector to be tweaked; must be of size <a class="el" href="#a224e4c35014e87139f73f9a517866796" title="Getter for number of variables in the optimization program.">num_vars()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65ab51bbb7a7abab25cb23d0f64d80d4" name="a65ab51bbb7a7abab25cb23d0f64d80d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ab51bbb7a7abab25cb23d0f64d80d4">&#9670;&#160;</a></span>SetDecisionVariableValueInVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetDecisionVariableValueInVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>decision_variable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>decision_variable_new_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::VectorXd &gt;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the value of a single <code class="param">decision_variable</code> inside the <code class="param">values</code> vector to be <code class="param">decision_variable_new_value</code>. </p>
<p>The other decision variables' values in <code class="param">values</code> are unchanged. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">decision_variable</td><td>a registered decision variable in this program. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">decision_variable_new_value</td><td>the variable's new values. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>The vector to be tweaked; must be of size <a class="el" href="#a224e4c35014e87139f73f9a517866796" title="Getter for number of variables in the optimization program.">num_vars()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6eca61aa09da31d13c9d476cf1b6b760" name="a6eca61aa09da31d13c9d476cf1b6b760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eca61aa09da31d13c9d476cf1b6b760">&#9670;&#160;</a></span>SetInitialGuess() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetInitialGuess </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>decision_variable_mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x0</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the initial guess for the decision variables stored in <code class="param">decision_variable_mat</code> to be <code class="param">x0</code>. </p>
<p>The guess is stored as part of this program. </p>

</div>
</div>
<a id="ae48cb6d2263ccf09e38932dcd27f769f" name="ae48cb6d2263ccf09e38932dcd27f769f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48cb6d2263ccf09e38932dcd27f769f">&#9670;&#160;</a></span>SetInitialGuess() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetInitialGuess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>decision_variable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>variable_guess_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the initial guess for a single variable <code class="param">decision_variable</code>. </p>
<p>The guess is stored as part of this program. </p><dl class="section pre"><dt>Precondition</dt><dd>decision_variable is a registered decision variable in the program. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if precondition is not satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae35679ed5aabea90fcf4ff3b337b44f5" name="ae35679ed5aabea90fcf4ff3b337b44f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35679ed5aabea90fcf4ff3b337b44f5">&#9670;&#160;</a></span>SetInitialGuessForAllVariables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetInitialGuessForAllVariables </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x0</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the initial guess for ALL decision variables. </p>
<p>Note that variables begin with a default initial guess of NaN to indicate that no guess is available. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x0</td><td>A vector of appropriate size (<a class="el" href="#a224e4c35014e87139f73f9a517866796" title="Getter for number of variables in the optimization program.">num_vars()</a> x 1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00b38acbaeb959344b7ef04e84f4c40c" name="a00b38acbaeb959344b7ef04e84f4c40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b38acbaeb959344b7ef04e84f4c40c">&#9670;&#160;</a></span>SetSolverOption() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetSolverOption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>solver_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>solver_option</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>option_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="#set_solver_option">set_solver_option</a> for more details. </p>
<p>Set the string-valued options. </p>

</div>
</div>
<a id="a77b58f1d09a3aec5918813ba163c1098" name="a77b58f1d09a3aec5918813ba163c1098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b58f1d09a3aec5918813ba163c1098">&#9670;&#160;</a></span>SetSolverOption() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetSolverOption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>solver_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>solver_option</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>option_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="#set_solver_option">set_solver_option</a> for more details. </p>
<p>Set the double-valued options. </p>

</div>
</div>
<a id="a3aafa15b34bc04d8a3449f39787bc76e" name="a3aafa15b34bc04d8a3449f39787bc76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aafa15b34bc04d8a3449f39787bc76e">&#9670;&#160;</a></span>SetSolverOption() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetSolverOption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>solver_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>solver_option</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>option_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="#set_solver_option">set_solver_option</a> for more details. </p>
<p>Set the integer-valued options. </p>

</div>
</div>
<a id="aed5ce186e378a8fbf9f0924b2e55994c" name="aed5ce186e378a8fbf9f0924b2e55994c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5ce186e378a8fbf9f0924b2e55994c">&#9670;&#160;</a></span>SetSolverOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetSolverOptions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>solver_options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrite the stored solver options inside <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> with the provided solver options. </p>

</div>
</div>
<a id="af4b4542d7067f6d60ea801b3b00c591f" name="af4b4542d7067f6d60ea801b3b00c591f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b4542d7067f6d60ea801b3b00c591f">&#9670;&#160;</a></span>SetVariableScaling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetVariableScaling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setter for the scaling <code class="param">s</code> of decision variable <code class="param">var</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>the decision variable to be scaled. </td></tr>
    <tr><td class="paramname">s</td><td>scaling factor (must be positive).</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="#variable_scaling">Variable scaling</a> for more information. </p>

</div>
</div>
<a id="a083a1822093d823535a137992cee02c5" name="a083a1822093d823535a137992cee02c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a083a1822093d823535a137992cee02c5">&#9670;&#160;</a></span>solver_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &amp; solver_options </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the solver options stored inside <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </p>

</div>
</div>
<a id="a127b9473329959a4877fe54abb53ff4e" name="a127b9473329959a4877fe54abb53ff4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127b9473329959a4877fe54abb53ff4e">&#9670;&#160;</a></span>TightenPsdConstraintToDd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; TightenPsdConstraintToDd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>constraint</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<ol type="1">
<li>Tightens the positive semidefinite <code class="param">constraint</code> with a positive diagonally dominant constraint.</li>
<li>Adds the positive diagonally dominant constraint into this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.</li>
<li>Removes the positive semidefinite <code class="param">constraint</code>, if it had already been registered in this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.</li>
</ol>
<p>This provides a polyhedral (i.e. linear) sufficient, but not necessary, condition for the variables in <code class="param">constraint</code> to be positive semidefinite.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The decision variables contained in constraint have been registered with this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The return of AddPositiveDiagonallyDominantMatrixConstraint applied to the variables in <code class="param">constraint</code>. </dd></dl>

</div>
</div>
<a id="a013ab93a09dbb352bf98f8602c75439e" name="a013ab93a09dbb352bf98f8602c75439e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013ab93a09dbb352bf98f8602c75439e">&#9670;&#160;</a></span>TightenPsdConstraintToSdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; <a class="el" href="namespacedrake.html#a06406a5da633da84f911e2979aa48549">Matrix2</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &gt; TightenPsdConstraintToSdd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>constraint</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<ol type="1">
<li>Tightens the positive semidefinite <code class="param">constraint</code> with a scaled diagonally dominant constraint.</li>
<li>Adds the scaled diagonally dominant constraint into this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.</li>
<li>Removes the positive semidefinite <code class="param">constraint</code>, if it had already been registered in this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.</li>
</ol>
<p>This provides a second-order cone sufficient, but not necessary, condition for the variables in <code class="param">constraint</code> to be positive semidefinite.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The decision variables contained in constraint have been registered with this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The return of AddScaledDiagonallyDominantMatrixConstraint applied to the variables in <code class="param">constraint</code>. </dd></dl>

</div>
</div>
<a id="aac993ecccd3d88aafefb6b8e3caa1dee" name="aac993ecccd3d88aafefb6b8e3caa1dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac993ecccd3d88aafefb6b8e3caa1dee">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns string representation of this program, listing the decision variables, costs, and constraints. </p>
<p>Note that by default, we do not require variables to have unique names. Providing useful variable names and calling Evaluator::set_description() to describe the costs and constraints can dramatically improve the readability of the output. See the tutorial <span class="tt">debug_mathematical_program.ipynb</span> for more information. </p>

</div>
</div>
<a id="aab8a2c8699234750a5ed6ccaac8da198" name="aab8a2c8699234750a5ed6ccaac8da198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8a2c8699234750a5ed6ccaac8da198">&#9670;&#160;</a></span>ToLatex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ToLatex </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>precision</em></span><span class="paramdefsep"> = </span><span class="paramdefval">3</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of this program in LaTeX. </p>
<p>This can be particularly useful e.g. in a Jupyter (python) notebook: </p><div class="fragment"><div class="line">from IPython.display <span class="keyword">import</span> Markdown, display</div>
<div class="line">display(Markdown(prog.ToLatex()))</div>
</div><!-- fragment --><p>Note that by default, we do not require variables to have unique names. Providing useful variable names and calling Evaluator::set_description() to describe the costs and constraints can dramatically improve the readability of the output. See the tutorial <span class="tt">debug_mathematical_program.ipynb</span> for more information. </p>

</div>
</div>
<a id="aea7d6e95dffa0b91fc280b86d2f430ae" name="aea7d6e95dffa0b91fc280b86d2f430ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7d6e95dffa0b91fc280b86d2f430ae">&#9670;&#160;</a></span>visualization_callbacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html">VisualizationCallback</a> &gt; &gt; &amp; visualization_callbacks </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for all callbacks. </p>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a78994b92c87719287528546dc12538bb" name="a78994b92c87719287528546dc12538bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78994b92c87719287528546dc12538bb">&#9670;&#160;</a></span>kGlobalInfeasibleCost</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> kGlobalInfeasibleCost</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      std::numeric_limits&lt;double&gt;::infinity()</div>
</div><!-- fragment -->
<p>The optimal cost is +∞ when the problem is globally infeasible. </p>

</div>
</div>
<a id="ab953e201d71c0ce608e7c95607a4f256" name="ab953e201d71c0ce608e7c95607a4f256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab953e201d71c0ce608e7c95607a4f256">&#9670;&#160;</a></span>kUnboundedCost</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> kUnboundedCost</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      -std::numeric_limits&lt;double&gt;::infinity()</div>
</div><!-- fragment -->
<p>The optimal cost is -∞ when the problem is unbounded. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/solvers/<a class="el" href="mathematical__program_8h.html">mathematical_program.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1solvers.html">solvers</a></li><li class="navelem"><a href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
