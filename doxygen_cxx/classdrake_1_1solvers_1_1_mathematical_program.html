<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: MathematicalProgram Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
   <td>
    <div id="DDGSearch">
     <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
      <input type="text" name="q" placeholder="Search C++ API only…" />
      <input type="hidden" name="sites" value="drake.mit.edu/doxygen_cxx" />
     </form>
     <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
      <input type="text" name="q" placeholder="Search all of Drake…" />
      <input type="hidden" name="sites" value="drake.mit.edu" />
     </form>
    </div">
   </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1solvers_1_1_mathematical_program.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classdrake_1_1solvers_1_1_mathematical_program-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MathematicalProgram Class Reference<div class="ingroups"><a class="el" href="group__solvers.html">Formulating and Solving Optimization Problems</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> stores the decision variables, the constraints and costs of an optimization problem. </p>
<p>The user can solve the problem by calling <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">solvers::Solve()</a> function, and obtain the results of the optimization. </p>
</div>
<p><code>#include &lt;drake/solvers/mathematical_program.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a407fb21fc13a5122994e71a05a6a0818"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> { <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">kSos</a>, 
<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818a28b23c4ed46cc23775486c764a920e29">kSdsos</a>, 
<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818a26e1dbaa56329cec4d3ba803424aed81">kDsos</a>
 }</td></tr>
<tr class="memdesc:a407fb21fc13a5122994e71a05a6a0818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of non-negative polynomial that can be found through conic optimization.  <a href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">More...</a><br /></td></tr>
<tr class="separator:a407fb21fc13a5122994e71a05a6a0818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed05d048d1ac7b1d4960e328c20d02f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aaed05d048d1ac7b1d4960e328c20d02f">VarType</a> = <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">symbolic::Variable::Type</a></td></tr>
<tr class="separator:aaed05d048d1ac7b1d4960e328c20d02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac577d0f44c9c07256230cf2642ec6822"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> ()</td></tr>
<tr class="separator:ac577d0f44c9c07256230cf2642ec6822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4793d463ad85b0e169fef6a974df5323"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a4793d463ad85b0e169fef6a974df5323">~MathematicalProgram</a> ()</td></tr>
<tr class="separator:a4793d463ad85b0e169fef6a974df5323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73c34779cac8f3d622aa353c8212d38"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aa73c34779cac8f3d622aa353c8212d38">Clone</a> () const</td></tr>
<tr class="memdesc:aa73c34779cac8f3d622aa353c8212d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones an optimization program.  <a href="#aa73c34779cac8f3d622aa353c8212d38">More...</a><br /></td></tr>
<tr class="separator:aa73c34779cac8f3d622aa353c8212d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac993ecccd3d88aafefb6b8e3caa1dee"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aac993ecccd3d88aafefb6b8e3caa1dee">to_string</a> () const</td></tr>
<tr class="memdesc:aac993ecccd3d88aafefb6b8e3caa1dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string representation of this program, listing the decision variables, costs, and constraints.  <a href="#aac993ecccd3d88aafefb6b8e3caa1dee">More...</a><br /></td></tr>
<tr class="separator:aac993ecccd3d88aafefb6b8e3caa1dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53949966a66a6f53ba90596fc5a439ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a53949966a66a6f53ba90596fc5a439ef">NewContinuousVariables</a> (<a class="el" href="classint.html">int</a> rows, const std::string &amp;name=&quot;x&quot;)</td></tr>
<tr class="memdesc:a53949966a66a6f53ba90596fc5a439ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds continuous variables, appending them to an internal vector of any existing vars.  <a href="#a53949966a66a6f53ba90596fc5a439ef">More...</a><br /></td></tr>
<tr class="separator:a53949966a66a6f53ba90596fc5a439ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd612c938a2bb1887476dadf65dd0a5"><td class="memTemplParams" colspan="2">template&lt;int Rows = Eigen::Dynamic, int Cols = Eigen::Dynamic&gt; </td></tr>
<tr class="memitem:a2cd612c938a2bb1887476dadf65dd0a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; Rows, Cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a2cd612c938a2bb1887476dadf65dd0a5">NewContinuousVariables</a> (<a class="el" href="classint.html">int</a> rows, <a class="el" href="classint.html">int</a> cols, const std::string &amp;name=&quot;X&quot;)</td></tr>
<tr class="memdesc:a2cd612c938a2bb1887476dadf65dd0a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds continuous variables, appending them to an internal vector of any existing vars.  <a href="#a2cd612c938a2bb1887476dadf65dd0a5">More...</a><br /></td></tr>
<tr class="separator:a2cd612c938a2bb1887476dadf65dd0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f22188fff7a464ac091b8fea727a89d"><td class="memTemplParams" colspan="2">template&lt;int Rows, int Cols = 1&gt; </td></tr>
<tr class="memitem:a8f22188fff7a464ac091b8fea727a89d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; Rows, Cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a8f22188fff7a464ac091b8fea727a89d">NewContinuousVariables</a> (const std::string &amp;name=&quot;X&quot;)</td></tr>
<tr class="memdesc:a8f22188fff7a464ac091b8fea727a89d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds continuous variables, appending them to an internal vector of any existing vars.  <a href="#a8f22188fff7a464ac091b8fea727a89d">More...</a><br /></td></tr>
<tr class="separator:a8f22188fff7a464ac091b8fea727a89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e5827a62c6aadac95e0a053cf3fe08"><td class="memTemplParams" colspan="2">template&lt;int Rows = Eigen::Dynamic, int Cols = Eigen::Dynamic&gt; </td></tr>
<tr class="memitem:ae4e5827a62c6aadac95e0a053cf3fe08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; Rows, Cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae4e5827a62c6aadac95e0a053cf3fe08">NewBinaryVariables</a> (<a class="el" href="classint.html">int</a> rows, <a class="el" href="classint.html">int</a> cols, const std::string &amp;name)</td></tr>
<tr class="memdesc:ae4e5827a62c6aadac95e0a053cf3fe08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds binary variables, appending them to an internal vector of any existing vars.  <a href="#ae4e5827a62c6aadac95e0a053cf3fe08">More...</a><br /></td></tr>
<tr class="separator:ae4e5827a62c6aadac95e0a053cf3fe08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b5acd86b0429f7cd22b04355f1f774"><td class="memTemplParams" colspan="2">template&lt;int Rows, int Cols = 1&gt; </td></tr>
<tr class="memitem:a07b5acd86b0429f7cd22b04355f1f774"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; Rows, Cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a07b5acd86b0429f7cd22b04355f1f774">NewBinaryVariables</a> (const std::string &amp;name=&quot;b&quot;)</td></tr>
<tr class="memdesc:a07b5acd86b0429f7cd22b04355f1f774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a matrix of binary variables into the optimization program.  <a href="#a07b5acd86b0429f7cd22b04355f1f774">More...</a><br /></td></tr>
<tr class="separator:a07b5acd86b0429f7cd22b04355f1f774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30759ec657805673fd0ce5e9edc166a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a30759ec657805673fd0ce5e9edc166a2">NewBinaryVariables</a> (<a class="el" href="classint.html">int</a> rows, const std::string &amp;name=&quot;b&quot;)</td></tr>
<tr class="memdesc:a30759ec657805673fd0ce5e9edc166a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds binary variables to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <a href="#a30759ec657805673fd0ce5e9edc166a2">More...</a><br /></td></tr>
<tr class="separator:a30759ec657805673fd0ce5e9edc166a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f718351922bc149cb6e7fa6d82288a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a8f718351922bc149cb6e7fa6d82288a5">NewSymmetricContinuousVariables</a> (<a class="el" href="classint.html">int</a> rows, const std::string &amp;name=&quot;Symmetric&quot;)</td></tr>
<tr class="memdesc:a8f718351922bc149cb6e7fa6d82288a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a runtime sized symmetric matrix as decision variables to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <a href="#a8f718351922bc149cb6e7fa6d82288a5">More...</a><br /></td></tr>
<tr class="separator:a8f718351922bc149cb6e7fa6d82288a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a84a217cea56358191de7d25c142c0"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:af9a84a217cea56358191de7d25c142c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; rows, rows &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#af9a84a217cea56358191de7d25c142c0">NewSymmetricContinuousVariables</a> (const std::string &amp;name=&quot;Symmetric&quot;)</td></tr>
<tr class="memdesc:af9a84a217cea56358191de7d25c142c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a static sized symmetric matrix as decision variables to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <a href="#af9a84a217cea56358191de7d25c142c0">More...</a><br /></td></tr>
<tr class="separator:af9a84a217cea56358191de7d25c142c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af436a548cfc2a209dc21427b328232b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#af436a548cfc2a209dc21427b328232b2">AddDecisionVariables</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt; &amp;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a3d833ea37172e9829c5d85e388eb9f59">decision_variables</a>)</td></tr>
<tr class="memdesc:af436a548cfc2a209dc21427b328232b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends new variables to the end of the existing variables.  <a href="#af436a548cfc2a209dc21427b328232b2">More...</a><br /></td></tr>
<tr class="separator:af436a548cfc2a209dc21427b328232b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a71c1f6466e5dedbd2cd73372dfcd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae6a71c1f6466e5dedbd2cd73372dfcd5">NewFreePolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#abaa1d35a078980665b4cabac09dd235b">indeterminates</a>, <a class="el" href="classint.html">int</a> degree, const std::string &amp;coeff_name=&quot;a&quot;)</td></tr>
<tr class="memdesc:ae6a71c1f6466e5dedbd2cd73372dfcd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a free polynomial in a monomial basis over <code>indeterminates</code> of a given <code>degree</code>.  <a href="#ae6a71c1f6466e5dedbd2cd73372dfcd5">More...</a><br /></td></tr>
<tr class="separator:ae6a71c1f6466e5dedbd2cd73372dfcd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4892d2259256cc4aff04a354391eae77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a4892d2259256cc4aff04a354391eae77">NewEvenDegreeFreePolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#abaa1d35a078980665b4cabac09dd235b">indeterminates</a>, <a class="el" href="classint.html">int</a> degree, const std::string &amp;coeff_name=&quot;a&quot;)</td></tr>
<tr class="memdesc:a4892d2259256cc4aff04a354391eae77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a free polynomial that only contains even degree monomials.  <a href="#a4892d2259256cc4aff04a354391eae77">More...</a><br /></td></tr>
<tr class="separator:a4892d2259256cc4aff04a354391eae77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65f91d84b3f2f0a5354def05ddb51e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aa65f91d84b3f2f0a5354def05ddb51e4">NewOddDegreeFreePolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#abaa1d35a078980665b4cabac09dd235b">indeterminates</a>, <a class="el" href="classint.html">int</a> degree, const std::string &amp;coeff_name=&quot;a&quot;)</td></tr>
<tr class="memdesc:aa65f91d84b3f2f0a5354def05ddb51e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a free polynomial that only contains odd degree monomials.  <a href="#aa65f91d84b3f2f0a5354def05ddb51e4">More...</a><br /></td></tr>
<tr class="separator:aa65f91d84b3f2f0a5354def05ddb51e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903fd7b5970fb835030958fe57d8cd6e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a903fd7b5970fb835030958fe57d8cd6e">NewNonnegativePolynomial</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;&gt; &amp;monomial_basis, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> type)</td></tr>
<tr class="memdesc:a903fd7b5970fb835030958fe57d8cd6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair of nonnegative polynomial p = mᵀQm and the Gramian matrix Q, where m is <code>monomial_basis</code>.  <a href="#a903fd7b5970fb835030958fe57d8cd6e">More...</a><br /></td></tr>
<tr class="separator:a903fd7b5970fb835030958fe57d8cd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789535f4318138071bb47f2ffb265407"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a789535f4318138071bb47f2ffb265407">NewNonnegativePolynomial</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;gramian, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;&gt; &amp;monomial_basis, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> type)</td></tr>
<tr class="memdesc:a789535f4318138071bb47f2ffb265407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a903fd7b5970fb835030958fe57d8cd6e" title="Returns a pair of nonnegative polynomial p = mᵀQm and the Gramian matrix Q, where m is monomial_basis...">NewNonnegativePolynomial()</a>, except the Gramian matrix Q is an input instead of an output.  <a href="#a789535f4318138071bb47f2ffb265407">More...</a><br /></td></tr>
<tr class="separator:a789535f4318138071bb47f2ffb265407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60415069ede137e871e1edd1f8194fe2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a60415069ede137e871e1edd1f8194fe2">NewNonnegativePolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#abaa1d35a078980665b4cabac09dd235b">indeterminates</a>, <a class="el" href="classint.html">int</a> degree, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> type)</td></tr>
<tr class="memdesc:a60415069ede137e871e1edd1f8194fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a903fd7b5970fb835030958fe57d8cd6e" title="Returns a pair of nonnegative polynomial p = mᵀQm and the Gramian matrix Q, where m is monomial_basis...">NewNonnegativePolynomial()</a>.  <a href="#a60415069ede137e871e1edd1f8194fe2">More...</a><br /></td></tr>
<tr class="separator:a60415069ede137e871e1edd1f8194fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac9dc35b894168d1b1600887bc27bcd"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#abac9dc35b894168d1b1600887bc27bcd">NewSosPolynomial</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;&gt; &amp;monomial_basis, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> type=<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a>)</td></tr>
<tr class="memdesc:abac9dc35b894168d1b1600887bc27bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair of a SOS polynomial p = mᵀQm and the Gramian matrix Q, where m is the <code>monomial</code> basis.  <a href="#abac9dc35b894168d1b1600887bc27bcd">More...</a><br /></td></tr>
<tr class="separator:abac9dc35b894168d1b1600887bc27bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9880f907227e7c09b7553f7581351a61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a9880f907227e7c09b7553f7581351a61">NewSosPolynomial</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;gramian, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;&gt; &amp;monomial_basis, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> type=<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a>)</td></tr>
<tr class="memdesc:a9880f907227e7c09b7553f7581351a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads NewSosPolynomial, except the Gramian matrix Q is an input instead of an output.  <a href="#a9880f907227e7c09b7553f7581351a61">More...</a><br /></td></tr>
<tr class="separator:a9880f907227e7c09b7553f7581351a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17696eeb5ed72ea8a4ddcaa732324a3e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a17696eeb5ed72ea8a4ddcaa732324a3e">NewSosPolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#abaa1d35a078980665b4cabac09dd235b">indeterminates</a>, <a class="el" href="classint.html">int</a> degree, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> type=<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a>)</td></tr>
<tr class="memdesc:a17696eeb5ed72ea8a4ddcaa732324a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads NewSosPolynomial.  <a href="#a17696eeb5ed72ea8a4ddcaa732324a3e">More...</a><br /></td></tr>
<tr class="separator:a17696eeb5ed72ea8a4ddcaa732324a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9757b022381ac5841cd389a7e212dfbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a9757b022381ac5841cd389a7e212dfbb">MakePolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e) const</td></tr>
<tr class="memdesc:a9757b022381ac5841cd389a7e212dfbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a symbolic polynomial from the given expression <code>e</code>.  <a href="#a9757b022381ac5841cd389a7e212dfbb">More...</a><br /></td></tr>
<tr class="separator:a9757b022381ac5841cd389a7e212dfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9493ea7d08a35395634bfbfd5713dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aee9493ea7d08a35395634bfbfd5713dd">Reparse</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> *p) const</td></tr>
<tr class="memdesc:aee9493ea7d08a35395634bfbfd5713dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reparses the polynomial <code>p</code> using this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>'s indeterminates.  <a href="#aee9493ea7d08a35395634bfbfd5713dd">More...</a><br /></td></tr>
<tr class="separator:aee9493ea7d08a35395634bfbfd5713dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0228101da15efa318a6e51349d3ff0a4"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:a0228101da15efa318a6e51349d3ff0a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a>&lt; rows, cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a0228101da15efa318a6e51349d3ff0a4">NewIndeterminates</a> (const std::array&lt; std::string, rows *cols &gt; &amp;names)</td></tr>
<tr class="memdesc:a0228101da15efa318a6e51349d3ff0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates, appending them to an internal vector of any existing indeterminates.  <a href="#a0228101da15efa318a6e51349d3ff0a4">More...</a><br /></td></tr>
<tr class="separator:a0228101da15efa318a6e51349d3ff0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae23f7c130166d82b578205015aed630"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:aae23f7c130166d82b578205015aed630"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a>&lt; rows &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aae23f7c130166d82b578205015aed630">NewIndeterminates</a> (const std::array&lt; std::string, rows &gt; &amp;names)</td></tr>
<tr class="memdesc:aae23f7c130166d82b578205015aed630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates, appending them to an internal vector of any existing indeterminates.  <a href="#aae23f7c130166d82b578205015aed630">More...</a><br /></td></tr>
<tr class="separator:aae23f7c130166d82b578205015aed630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c82857db425d76e1e49d69560f989d"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:a84c82857db425d76e1e49d69560f989d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a>&lt; rows, cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a84c82857db425d76e1e49d69560f989d">NewIndeterminates</a> (const std::string &amp;name=&quot;X&quot;)</td></tr>
<tr class="memdesc:a84c82857db425d76e1e49d69560f989d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates, appending them to an internal vector of any existing indeterminates.  <a href="#a84c82857db425d76e1e49d69560f989d">More...</a><br /></td></tr>
<tr class="separator:a84c82857db425d76e1e49d69560f989d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d51c28aae22e905563f6b00f3c65a7"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a26d51c28aae22e905563f6b00f3c65a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a>&lt; rows &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a26d51c28aae22e905563f6b00f3c65a7">NewIndeterminates</a> (const std::string &amp;name=&quot;x&quot;)</td></tr>
<tr class="memdesc:a26d51c28aae22e905563f6b00f3c65a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates to the program.  <a href="#a26d51c28aae22e905563f6b00f3c65a7">More...</a><br /></td></tr>
<tr class="separator:a26d51c28aae22e905563f6b00f3c65a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd679ea34528e50d76d23f79fcd294f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a0fd679ea34528e50d76d23f79fcd294f">NewIndeterminates</a> (<a class="el" href="classint.html">int</a> rows, const std::vector&lt; std::string &gt; &amp;names)</td></tr>
<tr class="memdesc:a0fd679ea34528e50d76d23f79fcd294f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <a href="#a0fd679ea34528e50d76d23f79fcd294f">More...</a><br /></td></tr>
<tr class="separator:a0fd679ea34528e50d76d23f79fcd294f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ec9c4fc4ae8f5d8ff8382b227dd82f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae4ec9c4fc4ae8f5d8ff8382b227dd82f">NewIndeterminates</a> (<a class="el" href="classint.html">int</a> rows, const std::string &amp;name=&quot;x&quot;)</td></tr>
<tr class="memdesc:ae4ec9c4fc4ae8f5d8ff8382b227dd82f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>, with default name "x".  <a href="#ae4ec9c4fc4ae8f5d8ff8382b227dd82f">More...</a><br /></td></tr>
<tr class="separator:ae4ec9c4fc4ae8f5d8ff8382b227dd82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12431081348a404711db4d3bb25c8a76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a60e13290a9b854b4fee070764f978d22">MatrixXIndeterminate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a12431081348a404711db4d3bb25c8a76">NewIndeterminates</a> (<a class="el" href="classint.html">int</a> rows, <a class="el" href="classint.html">int</a> cols, const std::vector&lt; std::string &gt; &amp;names)</td></tr>
<tr class="memdesc:a12431081348a404711db4d3bb25c8a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates, appending them to an internal vector of any existing vars.  <a href="#a12431081348a404711db4d3bb25c8a76">More...</a><br /></td></tr>
<tr class="separator:a12431081348a404711db4d3bb25c8a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e4fa58845ca19073b0c532431ac141"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a60e13290a9b854b4fee070764f978d22">MatrixXIndeterminate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ad7e4fa58845ca19073b0c532431ac141">NewIndeterminates</a> (<a class="el" href="classint.html">int</a> rows, <a class="el" href="classint.html">int</a> cols, const std::string &amp;name=&quot;X&quot;)</td></tr>
<tr class="memdesc:ad7e4fa58845ca19073b0c532431ac141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>, with default name "X".  <a href="#ad7e4fa58845ca19073b0c532431ac141">More...</a><br /></td></tr>
<tr class="separator:ad7e4fa58845ca19073b0c532431ac141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d17877e373279d18488f21836285539"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a1d17877e373279d18488f21836285539">AddIndeterminates</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#a60e13290a9b854b4fee070764f978d22">MatrixXIndeterminate</a> &gt; &amp;new_indeterminates)</td></tr>
<tr class="memdesc:a1d17877e373279d18488f21836285539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds indeterminates.  <a href="#a1d17877e373279d18488f21836285539">More...</a><br /></td></tr>
<tr class="separator:a1d17877e373279d18488f21836285539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67626d45d9a119d01e1c046ad89ee556"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html">VisualizationCallback</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a67626d45d9a119d01e1c046ad89ee556">AddVisualizationCallback</a> (const <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html#a84c15b60ba647eabef0aaa2d5dd3943e">VisualizationCallback::CallbackFunction</a> &amp;callback, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a67626d45d9a119d01e1c046ad89ee556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback method to visualize intermediate results of the optimization.  <a href="#a67626d45d9a119d01e1c046ad89ee556">More...</a><br /></td></tr>
<tr class="separator:a67626d45d9a119d01e1c046ad89ee556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2cc4c49122282ae0b2fe0511e86817"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html">VisualizationCallback</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a8d2cc4c49122282ae0b2fe0511e86817">AddVisualizationCallback</a> (const <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html#a84c15b60ba647eabef0aaa2d5dd3943e">VisualizationCallback::CallbackFunction</a> &amp;callback, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a8d2cc4c49122282ae0b2fe0511e86817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback method to visualize intermediate results of the optimization.  <a href="#a8d2cc4c49122282ae0b2fe0511e86817">More...</a><br /></td></tr>
<tr class="separator:a8d2cc4c49122282ae0b2fe0511e86817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac381d539927a444992b0945068cd8a8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac381d539927a444992b0945068cd8a8e">AddCost</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:ac381d539927a444992b0945068cd8a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a generic cost to the optimization program.  <a href="#ac381d539927a444992b0945068cd8a8e">More...</a><br /></td></tr>
<tr class="separator:ac381d539927a444992b0945068cd8a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e141e79d84c40fbc83ea8e3aab7823"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a60e141e79d84c40fbc83ea8e3aab7823"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a60e141e79d84c40fbc83ea8e3aab7823">AddCost</a> (const std::shared_ptr&lt; C &gt; &amp;obj, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a60e141e79d84c40fbc83ea8e3aab7823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost type to the optimization program.  <a href="#a60e141e79d84c40fbc83ea8e3aab7823">More...</a><br /></td></tr>
<tr class="separator:a60e141e79d84c40fbc83ea8e3aab7823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f0ccf74cf7be71ca7bc12d81051cad"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a24f0ccf74cf7be71ca7bc12d81051cad"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a24f0ccf74cf7be71ca7bc12d81051cad">AddCost</a> (const std::shared_ptr&lt; C &gt; &amp;obj, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a24f0ccf74cf7be71ca7bc12d81051cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a generic cost to the optimization program.  <a href="#a24f0ccf74cf7be71ca7bc12d81051cad">More...</a><br /></td></tr>
<tr class="separator:a24f0ccf74cf7be71ca7bc12d81051cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ef1a1c6bb49d3333ce2c303c0d212e"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a27ef1a1c6bb49d3333ce2c303c0d212e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; internal::is_cost_functor_candidate&lt; F &gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a27ef1a1c6bb49d3333ce2c303c0d212e">AddCost</a> (F &amp;&amp;f, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a27ef1a1c6bb49d3333ce2c303c0d212e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost to the optimization program on a list of variables.  <a href="#a27ef1a1c6bb49d3333ce2c303c0d212e">More...</a><br /></td></tr>
<tr class="separator:a27ef1a1c6bb49d3333ce2c303c0d212e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c495a4cd615dee9096bec347989e7e"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a65c495a4cd615dee9096bec347989e7e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; internal::is_cost_functor_candidate&lt; F &gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a65c495a4cd615dee9096bec347989e7e">AddCost</a> (F &amp;&amp;f, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a65c495a4cd615dee9096bec347989e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost to the optimization program on an Eigen::Vector containing decision variables.  <a href="#a65c495a4cd615dee9096bec347989e7e">More...</a><br /></td></tr>
<tr class="separator:a65c495a4cd615dee9096bec347989e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650567e1d5d23ca7a67dba50fedc7f27"><td class="memTemplParams" colspan="2">template&lt;typename F , typename Vars &gt; </td></tr>
<tr class="memitem:a650567e1d5d23ca7a67dba50fedc7f27"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; internal::assert_if_is_constraint&lt; F &gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a650567e1d5d23ca7a67dba50fedc7f27">AddCost</a> (F &amp;&amp;, Vars &amp;&amp;)</td></tr>
<tr class="memdesc:a650567e1d5d23ca7a67dba50fedc7f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically assert if a user inadvertently passes a binding-compatible <a class="el" href="classdrake_1_1solvers_1_1_constraint.html" title="A constraint is a function + lower and upper bounds.">Constraint</a>.  <a href="#a650567e1d5d23ca7a67dba50fedc7f27">More...</a><br /></td></tr>
<tr class="separator:a650567e1d5d23ca7a67dba50fedc7f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c127750dda0a393e598fef26a63ee27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a6c127750dda0a393e598fef26a63ee27">AddCost</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a6c127750dda0a393e598fef26a63ee27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form c'*x.  <a href="#a6c127750dda0a393e598fef26a63ee27">More...</a><br /></td></tr>
<tr class="separator:a6c127750dda0a393e598fef26a63ee27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6ebbdfd077e058cad0ac1bac9ffee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a1a6ebbdfd077e058cad0ac1bac9ffee7">AddLinearCost</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a1a6ebbdfd077e058cad0ac1bac9ffee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear cost term of the form a'*x + b.  <a href="#a1a6ebbdfd077e058cad0ac1bac9ffee7">More...</a><br /></td></tr>
<tr class="separator:a1a6ebbdfd077e058cad0ac1bac9ffee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d909ab79bbc45767206daaa8d145c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ab5d909ab79bbc45767206daaa8d145c8">AddLinearCost</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;a, double b, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:ab5d909ab79bbc45767206daaa8d145c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear cost term of the form a'*x + b.  <a href="#ab5d909ab79bbc45767206daaa8d145c8">More...</a><br /></td></tr>
<tr class="separator:ab5d909ab79bbc45767206daaa8d145c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa142d3f7b3e899ab26d4a42488f30ea4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aa142d3f7b3e899ab26d4a42488f30ea4">AddLinearCost</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;a, double b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:aa142d3f7b3e899ab26d4a42488f30ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear cost term of the form a'*x + b.  <a href="#aa142d3f7b3e899ab26d4a42488f30ea4">More...</a><br /></td></tr>
<tr class="separator:aa142d3f7b3e899ab26d4a42488f30ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06dbd6c1bf0971fc28366df95ee1bca2"><td class="memTemplParams" colspan="2">template&lt;typename VarType &gt; </td></tr>
<tr class="memitem:a06dbd6c1bf0971fc28366df95ee1bca2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a06dbd6c1bf0971fc28366df95ee1bca2">AddLinearCost</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;a, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">VarType</a> &amp;vars)</td></tr>
<tr class="memdesc:a06dbd6c1bf0971fc28366df95ee1bca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear cost term of the form a'*x.  <a href="#a06dbd6c1bf0971fc28366df95ee1bca2">More...</a><br /></td></tr>
<tr class="separator:a06dbd6c1bf0971fc28366df95ee1bca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560472e41de2cce737d4622ae22758d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a560472e41de2cce737d4622ae22758d4">AddCost</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a560472e41de2cce737d4622ae22758d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form 0.5*x'*Q*x + b'x.  <a href="#a560472e41de2cce737d4622ae22758d4">More...</a><br /></td></tr>
<tr class="separator:a560472e41de2cce737d4622ae22758d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9107a03b1a967f0efe1a7ad0d01dedd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae9107a03b1a967f0efe1a7ad0d01dedd">AddQuadraticCost</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, std::optional&lt; bool &gt; is_convex=std::nullopt)</td></tr>
<tr class="memdesc:ae9107a03b1a967f0efe1a7ad0d01dedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a quadratic cost term of the form 0.5*x'*Q*x + b'*x + c.  <a href="#ae9107a03b1a967f0efe1a7ad0d01dedd">More...</a><br /></td></tr>
<tr class="separator:ae9107a03b1a967f0efe1a7ad0d01dedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcdb1ab2b9211c869331a8b0af3e22c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#abdcdb1ab2b9211c869331a8b0af3e22c">AddQuadraticCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;vars, std::optional&lt; bool &gt; is_convex=std::nullopt)</td></tr>
<tr class="memdesc:abdcdb1ab2b9211c869331a8b0af3e22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form 0.5*x'*Q*x + b'x.  <a href="#abdcdb1ab2b9211c869331a8b0af3e22c">More...</a><br /></td></tr>
<tr class="separator:abdcdb1ab2b9211c869331a8b0af3e22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab631304ac72255c66ae90542de6542e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ab631304ac72255c66ae90542de6542e0">AddQuadraticCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, double c, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars, std::optional&lt; bool &gt; is_convex=std::nullopt)</td></tr>
<tr class="memdesc:ab631304ac72255c66ae90542de6542e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form 0.5*x'*Q*x + b'x + c Applied to subset of the variables.  <a href="#ab631304ac72255c66ae90542de6542e0">More...</a><br /></td></tr>
<tr class="separator:ab631304ac72255c66ae90542de6542e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee00f39c8fbbaab930492dec3e05ffe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a9ee00f39c8fbbaab930492dec3e05ffe">AddQuadraticCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars, std::optional&lt; bool &gt; is_convex=std::nullopt)</td></tr>
<tr class="memdesc:a9ee00f39c8fbbaab930492dec3e05ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form 0.5*x'*Q*x + b'x Applied to subset of the variables.  <a href="#a9ee00f39c8fbbaab930492dec3e05ffe">More...</a><br /></td></tr>
<tr class="separator:a9ee00f39c8fbbaab930492dec3e05ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae7eae6436a037740a2b8b7ba31f123"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a1ae7eae6436a037740a2b8b7ba31f123">AddQuadraticErrorCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;x_desired, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a1ae7eae6436a037740a2b8b7ba31f123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form (x-x_desired)'<em>Q</em>(x-x_desired).  <a href="#a1ae7eae6436a037740a2b8b7ba31f123">More...</a><br /></td></tr>
<tr class="separator:a1ae7eae6436a037740a2b8b7ba31f123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d57f46afbdd9192bae0d803fc7be404"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a7d57f46afbdd9192bae0d803fc7be404">AddQuadraticErrorCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;x_desired, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a7d57f46afbdd9192bae0d803fc7be404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term of the form (x-x_desired)'<em>Q</em>(x-x_desired).  <a href="#a7d57f46afbdd9192bae0d803fc7be404">More...</a><br /></td></tr>
<tr class="separator:a7d57f46afbdd9192bae0d803fc7be404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aece6fd5b228f6e0f7fc2c8c149f983"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a0aece6fd5b228f6e0f7fc2c8c149f983">Add2NormSquaredCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a0aece6fd5b228f6e0f7fc2c8c149f983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a quadratic cost of the form |Ax-b|²=(Ax-b)ᵀ(Ax-b)  <a href="#a0aece6fd5b228f6e0f7fc2c8c149f983">More...</a><br /></td></tr>
<tr class="separator:a0aece6fd5b228f6e0f7fc2c8c149f983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae0959f2cae1208fa1d8e80fa48242f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a0ae0959f2cae1208fa1d8e80fa48242f">Add2NormSquaredCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a0ae0959f2cae1208fa1d8e80fa48242f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a quadratic cost of the form |Ax-b|²=(Ax-b)ᵀ(Ax-b)  <a href="#a0ae0959f2cae1208fa1d8e80fa48242f">More...</a><br /></td></tr>
<tr class="separator:a0ae0959f2cae1208fa1d8e80fa48242f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412994ba25326bd8b1955cb180add256"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a412994ba25326bd8b1955cb180add256">AddCost</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a412994ba25326bd8b1955cb180add256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an L2 norm cost |Ax+b|₂ (notice this cost is not quadratic since we don't take the square of the L2 norm).  <a href="#a412994ba25326bd8b1955cb180add256">More...</a><br /></td></tr>
<tr class="separator:a412994ba25326bd8b1955cb180add256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57dac7a44fa56077931a7998f7069e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac57dac7a44fa56077931a7998f7069e2">AddL2NormCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:ac57dac7a44fa56077931a7998f7069e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an L2 norm cost |Ax+b|₂ (notice this cost is not quadratic since we don't take the square of the L2 norm).  <a href="#ac57dac7a44fa56077931a7998f7069e2">More...</a><br /></td></tr>
<tr class="separator:ac57dac7a44fa56077931a7998f7069e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5853578a7be1dd5279c7e73cd719e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a7f5853578a7be1dd5279c7e73cd719e6">AddL2NormCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a7f5853578a7be1dd5279c7e73cd719e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an L2 norm cost |Ax+b|₂ (notice this cost is not quadratic since we don't take the square of the L2 norm)  <a href="#a7f5853578a7be1dd5279c7e73cd719e6">More...</a><br /></td></tr>
<tr class="separator:a7f5853578a7be1dd5279c7e73cd719e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6060c77125050d8c1b479a83d983a569"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a6060c77125050d8c1b479a83d983a569">AddL2NormCostUsingConicConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a6060c77125050d8c1b479a83d983a569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an L2 norm cost min |Ax+b|₂ as a linear cost min s on the slack variable s, together with a Lorentz cone constraint s ≥ |Ax+b|₂ Many conic optimization solvers (Gurobi, MOSEK<a href="/tm.html">™</a>, SCS, etc) natively prefers this form of linear cost + conic constraints.  <a href="#a6060c77125050d8c1b479a83d983a569">More...</a><br /></td></tr>
<tr class="separator:a6060c77125050d8c1b479a83d983a569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14edfab282bd8d3d03bf38bb87a5fe51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_polynomial_cost.html">PolynomialCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a14edfab282bd8d3d03bf38bb87a5fe51">AddPolynomialCost</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a14edfab282bd8d3d03bf38bb87a5fe51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost term in the polynomial form.  <a href="#a14edfab282bd8d3d03bf38bb87a5fe51">More...</a><br /></td></tr>
<tr class="separator:a14edfab282bd8d3d03bf38bb87a5fe51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8745eb0e81fcbfc031c8e8c57609284"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aa8745eb0e81fcbfc031c8e8c57609284">AddCost</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aa8745eb0e81fcbfc031c8e8c57609284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost in the symbolic form.  <a href="#aa8745eb0e81fcbfc031c8e8c57609284">More...</a><br /></td></tr>
<tr class="separator:aa8745eb0e81fcbfc031c8e8c57609284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfe4319252cfe4f6b290986b504c404"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a8dfe4319252cfe4f6b290986b504c404">AddMaximizeLogDeterminantCost</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;X)</td></tr>
<tr class="memdesc:a8dfe4319252cfe4f6b290986b504c404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the cost to maximize the log determinant of symmetric matrix X.  <a href="#a8dfe4319252cfe4f6b290986b504c404">More...</a><br /></td></tr>
<tr class="separator:a8dfe4319252cfe4f6b290986b504c404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c4d6b9048536662622e58584c3a8df"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aa3c4d6b9048536662622e58584c3a8df">AddMaximizeLogDeterminantSymmetricMatrixCost</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;X)</td></tr>
<tr class="memdesc:aa3c4d6b9048536662622e58584c3a8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the cost to maximize the log determinant of symmetric matrix X.  <a href="#aa3c4d6b9048536662622e58584c3a8df">More...</a><br /></td></tr>
<tr class="separator:aa3c4d6b9048536662622e58584c3a8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e9e45a96eb6158f483aa0c81d2c7ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a13e9e45a96eb6158f483aa0c81d2c7ae">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a13e9e45a96eb6158f483aa0c81d2c7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a generic constraint to the program.  <a href="#a13e9e45a96eb6158f483aa0c81d2c7ae">More...</a><br /></td></tr>
<tr class="separator:a13e9e45a96eb6158f483aa0c81d2c7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c9655545a804d2a37a78e4225d8bde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae4c9655545a804d2a37a78e4225d8bde">AddConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, double lb, double ub)</td></tr>
<tr class="memdesc:ae4c9655545a804d2a37a78e4225d8bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one row of constraint lb &lt;= e &lt;= ub where <code>e</code> is a symbolic expression.  <a href="#ae4c9655545a804d2a37a78e4225d8bde">More...</a><br /></td></tr>
<tr class="separator:ae4c9655545a804d2a37a78e4225d8bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9245481a949ae2a1af84809f4d81d30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aa9245481a949ae2a1af84809f4d81d30">AddConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;v, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;ub)</td></tr>
<tr class="separator:aa9245481a949ae2a1af84809f4d81d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d9bfe34ef20a9f343e518fccc40bd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae8d9bfe34ef20a9f343e518fccc40bd6">AddConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;f)</td></tr>
<tr class="memdesc:ae8d9bfe34ef20a9f343e518fccc40bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a constraint represented by a symbolic formula to the program.  <a href="#ae8d9bfe34ef20a9f343e518fccc40bd6">More...</a><br /></td></tr>
<tr class="separator:ae8d9bfe34ef20a9f343e518fccc40bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf94f38f3b4c3bbbbb89ce5ef5a66c6"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a9cf94f38f3b4c3bbbbb89ce5ef5a66c6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt; Derived, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a9cf94f38f3b4c3bbbbb89ce5ef5a66c6">AddConstraint</a> (const Eigen::DenseBase&lt; Derived &gt; &amp;formulas)</td></tr>
<tr class="separator:a9cf94f38f3b4c3bbbbb89ce5ef5a66c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c28156f900997a8fb1b0079e30fce6d"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a0c28156f900997a8fb1b0079e30fce6d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a0c28156f900997a8fb1b0079e30fce6d">AddConstraint</a> (std::shared_ptr&lt; C &gt; con, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a0c28156f900997a8fb1b0079e30fce6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a generic constraint to the program.  <a href="#a0c28156f900997a8fb1b0079e30fce6d">More...</a><br /></td></tr>
<tr class="separator:a0c28156f900997a8fb1b0079e30fce6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d26f3d31c9cfba7144b9a0d96aebdd0"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a8d26f3d31c9cfba7144b9a0d96aebdd0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a8d26f3d31c9cfba7144b9a0d96aebdd0">AddConstraint</a> (std::shared_ptr&lt; C &gt; con, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a8d26f3d31c9cfba7144b9a0d96aebdd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a generic constraint to the program.  <a href="#a8d26f3d31c9cfba7144b9a0d96aebdd0">More...</a><br /></td></tr>
<tr class="separator:a8d26f3d31c9cfba7144b9a0d96aebdd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae677a49f65053b49a623e9b99bceff07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae677a49f65053b49a623e9b99bceff07">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:ae677a49f65053b49a623e9b99bceff07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear constraints referencing potentially a subset of the decision variables (defined in the vars parameter).  <a href="#ae677a49f65053b49a623e9b99bceff07">More...</a><br /></td></tr>
<tr class="separator:ae677a49f65053b49a623e9b99bceff07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d60c0944a1bf43c50dd26b6dbbc3c1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a7d60c0944a1bf43c50dd26b6dbbc3c1b">AddLinearConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a7d60c0944a1bf43c50dd26b6dbbc3c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear constraints referencing potentially a subset of the decision variables (defined in the vars parameter).  <a href="#a7d60c0944a1bf43c50dd26b6dbbc3c1b">More...</a><br /></td></tr>
<tr class="separator:a7d60c0944a1bf43c50dd26b6dbbc3c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fb1e639660acc96ade8aa1d6706c6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ad7fb1e639660acc96ade8aa1d6706c6f">AddLinearConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:ad7fb1e639660acc96ade8aa1d6706c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear constraints referencing potentially a subset of the decision variables (defined in the vars parameter).  <a href="#ad7fb1e639660acc96ade8aa1d6706c6f">More...</a><br /></td></tr>
<tr class="separator:ad7fb1e639660acc96ade8aa1d6706c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3340539f7b90d2f7d6987eea1a7242"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aea3340539f7b90d2f7d6987eea1a7242">AddLinearConstraint</a> (const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;a, double lb, double ub, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:aea3340539f7b90d2f7d6987eea1a7242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one row of linear constraint referencing potentially a subset of the decision variables (defined in the vars parameter).  <a href="#aea3340539f7b90d2f7d6987eea1a7242">More...</a><br /></td></tr>
<tr class="separator:aea3340539f7b90d2f7d6987eea1a7242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2358db7c4dc6aa23411618b1d21d9a07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a2358db7c4dc6aa23411618b1d21d9a07">AddLinearConstraint</a> (const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;a, double lb, double ub, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a2358db7c4dc6aa23411618b1d21d9a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one row of linear constraint referencing potentially a subset of the decision variables (defined in the vars parameter).  <a href="#a2358db7c4dc6aa23411618b1d21d9a07">More...</a><br /></td></tr>
<tr class="separator:a2358db7c4dc6aa23411618b1d21d9a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b35ad9e0036fc52b27fc98c555a091"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae0b35ad9e0036fc52b27fc98c555a091">AddLinearConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, double lb, double ub)</td></tr>
<tr class="memdesc:ae0b35ad9e0036fc52b27fc98c555a091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one row of linear constraint lb &lt;= e &lt;= ub where <code>e</code> is a symbolic expression.  <a href="#ae0b35ad9e0036fc52b27fc98c555a091">More...</a><br /></td></tr>
<tr class="separator:ae0b35ad9e0036fc52b27fc98c555a091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762c48bc981fb8d892fea63c4e97a326"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a762c48bc981fb8d892fea63c4e97a326">AddLinearConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;v, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;ub)</td></tr>
<tr class="memdesc:a762c48bc981fb8d892fea63c4e97a326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear constraints represented by symbolic expressions to the program.  <a href="#a762c48bc981fb8d892fea63c4e97a326">More...</a><br /></td></tr>
<tr class="separator:a762c48bc981fb8d892fea63c4e97a326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4bcd993d4cefb458564896160eebd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ade4bcd993d4cefb458564896160eebd2">AddLinearConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;f)</td></tr>
<tr class="memdesc:ade4bcd993d4cefb458564896160eebd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a linear constraint represented by a symbolic formula to the program.  <a href="#ade4bcd993d4cefb458564896160eebd2">More...</a><br /></td></tr>
<tr class="separator:ade4bcd993d4cefb458564896160eebd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db87ec5cd8f61d6ab5d689d181cd587"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a3db87ec5cd8f61d6ab5d689d181cd587">AddLinearConstraint</a> (const Eigen::Ref&lt; const Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a>, Eigen::Dynamic, Eigen::Dynamic &gt;&gt; &amp;formulas)</td></tr>
<tr class="memdesc:a3db87ec5cd8f61d6ab5d689d181cd587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a linear constraint represented by an Eigen::Array&lt;symbolic::Formula&gt; to the program.  <a href="#a3db87ec5cd8f61d6ab5d689d181cd587">More...</a><br /></td></tr>
<tr class="separator:a3db87ec5cd8f61d6ab5d689d181cd587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0884020fd41a68dfd00265226118685"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ab0884020fd41a68dfd00265226118685">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:ab0884020fd41a68dfd00265226118685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear equality constraints referencing potentially a subset of the decision variables.  <a href="#ab0884020fd41a68dfd00265226118685">More...</a><br /></td></tr>
<tr class="separator:ab0884020fd41a68dfd00265226118685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac623a8e305d300afa1d9f63bf3f266b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac623a8e305d300afa1d9f63bf3f266b8">AddLinearEqualityConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, double b)</td></tr>
<tr class="memdesc:ac623a8e305d300afa1d9f63bf3f266b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one row of linear constraint e = b where <code>e</code> is a symbolic expression.  <a href="#ac623a8e305d300afa1d9f63bf3f266b8">More...</a><br /></td></tr>
<tr class="separator:ac623a8e305d300afa1d9f63bf3f266b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c445bb3c911493f437f119372da5221"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a4c445bb3c911493f437f119372da5221">AddLinearEqualityConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a4c445bb3c911493f437f119372da5221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear equality constraint represented by a symbolic formula to the program.  <a href="#a4c445bb3c911493f437f119372da5221">More...</a><br /></td></tr>
<tr class="separator:a4c445bb3c911493f437f119372da5221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9164110d10cac0284a50a91b8308bae8"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedB &gt; </td></tr>
<tr class="memitem:a9164110d10cac0284a50a91b8308bae8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__vector__expression__double__pair.html">is_eigen_vector_expression_double_pair</a>&lt; DerivedV, DerivedB &gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a9164110d10cac0284a50a91b8308bae8">AddLinearEqualityConstraint</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;v, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;b)</td></tr>
<tr class="memdesc:a9164110d10cac0284a50a91b8308bae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear equality constraints \( v = b \), where <code>v(i)</code> is a symbolic linear expression.  <a href="#a9164110d10cac0284a50a91b8308bae8">More...</a><br /></td></tr>
<tr class="separator:a9164110d10cac0284a50a91b8308bae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3361c9cd54767f6b0441f3343eec35"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedB &gt; </td></tr>
<tr class="memitem:a7c3361c9cd54767f6b0441f3343eec35"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__nonvector__expression__double__pair.html">is_eigen_nonvector_expression_double_pair</a>&lt; DerivedV, DerivedB &gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a7c3361c9cd54767f6b0441f3343eec35">AddLinearEqualityConstraint</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B, bool lower_triangle=false)</td></tr>
<tr class="memdesc:a7c3361c9cd54767f6b0441f3343eec35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear equality constraint for a matrix of linear expression <code>V</code>, such that V(i, j) = B(i, j).  <a href="#a7c3361c9cd54767f6b0441f3343eec35">More...</a><br /></td></tr>
<tr class="separator:a7c3361c9cd54767f6b0441f3343eec35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4aec5ef573ea5fb0667475c7e5a1914"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aa4aec5ef573ea5fb0667475c7e5a1914">AddLinearEqualityConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Aeq, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;beq, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:aa4aec5ef573ea5fb0667475c7e5a1914"><td class="mdescLeft">&#160;</td><td class="mdescRight">AddLinearEqualityConstraint.  <a href="#aa4aec5ef573ea5fb0667475c7e5a1914">More...</a><br /></td></tr>
<tr class="separator:aa4aec5ef573ea5fb0667475c7e5a1914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8874425f3b864d09e7a05f6ca2c97805"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a8874425f3b864d09e7a05f6ca2c97805">AddLinearEqualityConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Aeq, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;beq, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a8874425f3b864d09e7a05f6ca2c97805"><td class="mdescLeft">&#160;</td><td class="mdescRight">AddLinearEqualityConstraint.  <a href="#a8874425f3b864d09e7a05f6ca2c97805">More...</a><br /></td></tr>
<tr class="separator:a8874425f3b864d09e7a05f6ca2c97805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba470b9c71439a795a0d647d171f71b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#adba470b9c71439a795a0d647d171f71b">AddLinearEqualityConstraint</a> (const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;a, double beq, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:adba470b9c71439a795a0d647d171f71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one row of linear equality constraint referencing potentially a subset of decision variables.  <a href="#adba470b9c71439a795a0d647d171f71b">More...</a><br /></td></tr>
<tr class="separator:adba470b9c71439a795a0d647d171f71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca8d2a20e1ba47d1c658613569eb447"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a7ca8d2a20e1ba47d1c658613569eb447">AddLinearEqualityConstraint</a> (const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;a, double beq, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a7ca8d2a20e1ba47d1c658613569eb447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one row of linear equality constraint referencing potentially a subset of decision variables.  <a href="#a7ca8d2a20e1ba47d1c658613569eb447">More...</a><br /></td></tr>
<tr class="separator:a7ca8d2a20e1ba47d1c658613569eb447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbd3feebe9cd0d5acf67dd4947c7994"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aadbd3feebe9cd0d5acf67dd4947c7994">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:aadbd3feebe9cd0d5acf67dd4947c7994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds bounding box constraints referencing potentially a subest of the decision variables.  <a href="#aadbd3feebe9cd0d5acf67dd4947c7994">More...</a><br /></td></tr>
<tr class="separator:aadbd3feebe9cd0d5acf67dd4947c7994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4d1c9278bc20bf599b1e74178f51c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a1b4d1c9278bc20bf599b1e74178f51c8">AddBoundingBoxConstraint</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a1b4d1c9278bc20bf599b1e74178f51c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">AddBoundingBoxConstraint.  <a href="#a1b4d1c9278bc20bf599b1e74178f51c8">More...</a><br /></td></tr>
<tr class="separator:a1b4d1c9278bc20bf599b1e74178f51c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353e8201ad1f01a69441e00fce617857"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a353e8201ad1f01a69441e00fce617857">AddBoundingBoxConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;ub, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a353e8201ad1f01a69441e00fce617857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds bounding box constraints referencing potentially a subset of the decision variables.  <a href="#a353e8201ad1f01a69441e00fce617857">More...</a><br /></td></tr>
<tr class="separator:a353e8201ad1f01a69441e00fce617857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c41563c9fea14a00330000b42a682fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a5c41563c9fea14a00330000b42a682fc">AddBoundingBoxConstraint</a> (double lb, double ub, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;var)</td></tr>
<tr class="memdesc:a5c41563c9fea14a00330000b42a682fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds bounds for a single variable.  <a href="#a5c41563c9fea14a00330000b42a682fc">More...</a><br /></td></tr>
<tr class="separator:a5c41563c9fea14a00330000b42a682fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8c7c4993cbaa6cc2ca30874be835d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a5e8c7c4993cbaa6cc2ca30874be835d7">AddBoundingBoxConstraint</a> (double lb, double ub, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a5e8c7c4993cbaa6cc2ca30874be835d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the same scalar lower and upper bound to every variable in the list.  <a href="#a5e8c7c4993cbaa6cc2ca30874be835d7">More...</a><br /></td></tr>
<tr class="separator:a5e8c7c4993cbaa6cc2ca30874be835d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdac15e414036a05505aa356c8011c74"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:acdac15e414036a05505aa356c8011c74"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &amp;&amp;Derived::ColsAtCompileTime==1, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#acdac15e414036a05505aa356c8011c74">AddBoundingBoxConstraint</a> (double lb, double ub, const Eigen::MatrixBase&lt; Derived &gt; &amp;vars)</td></tr>
<tr class="memdesc:acdac15e414036a05505aa356c8011c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the same scalar lower and upper bound to every variable in <code>vars</code>.  <a href="#acdac15e414036a05505aa356c8011c74">More...</a><br /></td></tr>
<tr class="separator:acdac15e414036a05505aa356c8011c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c89b0162a81a051cb90dad57a8e0686"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4c89b0162a81a051cb90dad57a8e0686"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &amp;&amp;Derived::ColsAtCompileTime !=1, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a4c89b0162a81a051cb90dad57a8e0686">AddBoundingBoxConstraint</a> (double lb, double ub, const Eigen::MatrixBase&lt; Derived &gt; &amp;vars)</td></tr>
<tr class="memdesc:a4c89b0162a81a051cb90dad57a8e0686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the same scalar lower and upper bound to every variable in <code>vars</code>.  <a href="#a4c89b0162a81a051cb90dad57a8e0686">More...</a><br /></td></tr>
<tr class="separator:a4c89b0162a81a051cb90dad57a8e0686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c149981283b0e251f55055c5ea4b40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a12c149981283b0e251f55055c5ea4b40">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a12c149981283b0e251f55055c5ea4b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds Lorentz cone constraint referencing potentially a subset of the decision variables.  <a href="#a12c149981283b0e251f55055c5ea4b40">More...</a><br /></td></tr>
<tr class="separator:a12c149981283b0e251f55055c5ea4b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9684f622903a0e38d1bf1ef8af6fcd51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a9684f622903a0e38d1bf1ef8af6fcd51">AddLorentzConeConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;v, <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a> eval_type=<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a>)</td></tr>
<tr class="memdesc:a9684f622903a0e38d1bf1ef8af6fcd51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds Lorentz cone constraint referencing potentially a subset of the decision variables.  <a href="#a9684f622903a0e38d1bf1ef8af6fcd51">More...</a><br /></td></tr>
<tr class="separator:a9684f622903a0e38d1bf1ef8af6fcd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d2492e6743d60dfe4060377e4a5503"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a02d2492e6743d60dfe4060377e4a5503">AddLorentzConeConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;linear_expression, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;quadratic_expression, double tol=0, <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a> eval_type=<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a>)</td></tr>
<tr class="memdesc:a02d2492e6743d60dfe4060377e4a5503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds Lorentz cone constraint on the linear expression v1 and quadratic expression v2, such that v1 &gt;= sqrt(v2)  <a href="#a02d2492e6743d60dfe4060377e4a5503">More...</a><br /></td></tr>
<tr class="separator:a02d2492e6743d60dfe4060377e4a5503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848e948c48c906a76d249a0606464868"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a848e948c48c906a76d249a0606464868">AddLorentzConeConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;vars, <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a> eval_type=<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a>)</td></tr>
<tr class="memdesc:a848e948c48c906a76d249a0606464868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds Lorentz cone constraint referencing potentially a subset of the decision variables (defined in the vars parameter).  <a href="#a848e948c48c906a76d249a0606464868">More...</a><br /></td></tr>
<tr class="separator:a848e948c48c906a76d249a0606464868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2e0b7c0a939513aba56fc147696a8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#adb2e0b7c0a939513aba56fc147696a8a">AddLorentzConeConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars, <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a> eval_type=<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a>)</td></tr>
<tr class="memdesc:adb2e0b7c0a939513aba56fc147696a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds Lorentz cone constraint referencing potentially a subset of the decision variables (defined in the vars parameter).  <a href="#adb2e0b7c0a939513aba56fc147696a8a">More...</a><br /></td></tr>
<tr class="separator:adb2e0b7c0a939513aba56fc147696a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2d933f65af2e81e40e08564c929529"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a6d2d933f65af2e81e40e08564c929529">AddLorentzConeConstraint</a> (const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;vars, <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a> eval_type=<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a>)</td></tr>
<tr class="memdesc:a6d2d933f65af2e81e40e08564c929529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imposes that a vector \( x\in\mathbb{R}^m \) lies in Lorentz cone.  <a href="#a6d2d933f65af2e81e40e08564c929529">More...</a><br /></td></tr>
<tr class="separator:a6d2d933f65af2e81e40e08564c929529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9082746a4852ea5087b2a6e3cc57ee"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a8a9082746a4852ea5087b2a6e3cc57ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a8a9082746a4852ea5087b2a6e3cc57ee">AddLorentzConeConstraint</a> (const Eigen::MatrixBase&lt; <a class="el" href="namespacedrake_1_1solvers.html#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a>&lt; rows &gt;&gt; &amp;vars, <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a> eval_type=<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a>)</td></tr>
<tr class="memdesc:a8a9082746a4852ea5087b2a6e3cc57ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imposes that a vector \( x\in\mathbb{R}^m \) lies in Lorentz cone.  <a href="#a8a9082746a4852ea5087b2a6e3cc57ee">More...</a><br /></td></tr>
<tr class="separator:a8a9082746a4852ea5087b2a6e3cc57ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b16dc5af33d4fd617a189a905d02173"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a8b16dc5af33d4fd617a189a905d02173">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a8b16dc5af33d4fd617a189a905d02173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a rotated Lorentz cone constraint referencing potentially a subset of decision variables.  <a href="#a8b16dc5af33d4fd617a189a905d02173">More...</a><br /></td></tr>
<tr class="separator:a8b16dc5af33d4fd617a189a905d02173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a0bbb8698b6c9015f06ef81f29e472"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a12a0bbb8698b6c9015f06ef81f29e472">AddRotatedLorentzConeConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;linear_expression1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;linear_expression2, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;quadratic_expression, double tol=0)</td></tr>
<tr class="memdesc:a12a0bbb8698b6c9015f06ef81f29e472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds rotated Lorentz cone constraint on the linear expression v1, v2 and quadratic expression u, such that v1 * v2 &gt;= u, v1 &gt;= 0, v2 &gt;= 0.  <a href="#a12a0bbb8698b6c9015f06ef81f29e472">More...</a><br /></td></tr>
<tr class="separator:a12a0bbb8698b6c9015f06ef81f29e472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8888193e1130288e45be9edd3f47a7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#af8888193e1130288e45be9edd3f47a7e">AddRotatedLorentzConeConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;v)</td></tr>
<tr class="memdesc:af8888193e1130288e45be9edd3f47a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constraint that a symbolic expression.  <a href="#af8888193e1130288e45be9edd3f47a7e">More...</a><br /></td></tr>
<tr class="separator:af8888193e1130288e45be9edd3f47a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad038198c145926f0e63faf04b254c7a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ad038198c145926f0e63faf04b254c7a3">AddRotatedLorentzConeConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:ad038198c145926f0e63faf04b254c7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a rotated Lorentz cone constraint referencing potentially a subset of decision variables, The linear expression \( z=Ax+b \) is in rotated Lorentz cone.  <a href="#ad038198c145926f0e63faf04b254c7a3">More...</a><br /></td></tr>
<tr class="separator:ad038198c145926f0e63faf04b254c7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fe068baa72efa72a6b4f12ef8184ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae8fe068baa72efa72a6b4f12ef8184ba">AddRotatedLorentzConeConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:ae8fe068baa72efa72a6b4f12ef8184ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a rotated Lorentz cone constraint referencing potentially a subset of decision variables, The linear expression \( z=Ax+b \) is in rotated Lorentz cone.  <a href="#ae8fe068baa72efa72a6b4f12ef8184ba">More...</a><br /></td></tr>
<tr class="separator:ae8fe068baa72efa72a6b4f12ef8184ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0b88b023b5603a6534662bf98af309"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a1c0b88b023b5603a6534662bf98af309">AddRotatedLorentzConeConstraint</a> (const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a1c0b88b023b5603a6534662bf98af309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose that a vector \( x\in\mathbb{R}^m \) is in rotated Lorentz cone.  <a href="#a1c0b88b023b5603a6534662bf98af309">More...</a><br /></td></tr>
<tr class="separator:a1c0b88b023b5603a6534662bf98af309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a5ef4b6da552936dabb22caae98f4b"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:af5a5ef4b6da552936dabb22caae98f4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#af5a5ef4b6da552936dabb22caae98f4b">AddRotatedLorentzConeConstraint</a> (const Eigen::MatrixBase&lt; <a class="el" href="namespacedrake_1_1solvers.html#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a>&lt; rows &gt;&gt; &amp;vars)</td></tr>
<tr class="memdesc:af5a5ef4b6da552936dabb22caae98f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose that a vector \( x\in\mathbb{R}^m \) is in rotated Lorentz cone.  <a href="#af5a5ef4b6da552936dabb22caae98f4b">More...</a><br /></td></tr>
<tr class="separator:af5a5ef4b6da552936dabb22caae98f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ce06116cc0cd7c681258befa944240"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#af4ce06116cc0cd7c681258befa944240">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:af4ce06116cc0cd7c681258befa944240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear complementarity constraints referencing a subset of the decision variables.  <a href="#af4ce06116cc0cd7c681258befa944240">More...</a><br /></td></tr>
<tr class="separator:af4ce06116cc0cd7c681258befa944240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb8281bc9e90a665dab64afa9749542"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aefb8281bc9e90a665dab64afa9749542">AddLinearComplementarityConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;M, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;q, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:aefb8281bc9e90a665dab64afa9749542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear complementarity constraints referencing a subset of the decision variables.  <a href="#aefb8281bc9e90a665dab64afa9749542">More...</a><br /></td></tr>
<tr class="separator:aefb8281bc9e90a665dab64afa9749542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cae2adfde468f154fc70a367e0f0ff6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a8cae2adfde468f154fc70a367e0f0ff6">AddLinearComplementarityConstraint</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;M, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;q, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a8cae2adfde468f154fc70a367e0f0ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear complementarity constraints referencing a subset of the decision variables.  <a href="#a8cae2adfde468f154fc70a367e0f0ff6">More...</a><br /></td></tr>
<tr class="separator:a8cae2adfde468f154fc70a367e0f0ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85baa493f8445101d0367606e3bf5f32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a85baa493f8445101d0367606e3bf5f32">AddPolynomialConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="namespacedrake.html#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a> &gt;&gt; &amp;polynomials, const std::vector&lt; <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">Polynomiald::VarType</a> &gt; &amp;poly_vars, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;ub, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a85baa493f8445101d0367606e3bf5f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a polynomial constraint to the program referencing a subset of the decision variables (defined in the vars parameter).  <a href="#a85baa493f8445101d0367606e3bf5f32">More...</a><br /></td></tr>
<tr class="separator:a85baa493f8445101d0367606e3bf5f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4784f36d627f416827aded75f1936808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a4784f36d627f416827aded75f1936808">AddPolynomialConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="namespacedrake.html#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a> &gt;&gt; &amp;polynomials, const std::vector&lt; <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">Polynomiald::VarType</a> &gt; &amp;poly_vars, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;ub, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a4784f36d627f416827aded75f1936808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a polynomial constraint to the program referencing a subset of the decision variables (defined in the vars parameter).  <a href="#a4784f36d627f416827aded75f1936808">More...</a><br /></td></tr>
<tr class="separator:a4784f36d627f416827aded75f1936808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed941c57116fdf9186a3f0ad7f55b5a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aed941c57116fdf9186a3f0ad7f55b5a8">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:aed941c57116fdf9186a3f0ad7f55b5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a positive semidefinite constraint on a symmetric matrix.  <a href="#aed941c57116fdf9186a3f0ad7f55b5a8">More...</a><br /></td></tr>
<tr class="separator:aed941c57116fdf9186a3f0ad7f55b5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c66d4086096ed5206e2168d8a6fe3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a46c66d4086096ed5206e2168d8a6fe3f">AddConstraint</a> (std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; con, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt; &amp;symmetric_matrix_var)</td></tr>
<tr class="memdesc:a46c66d4086096ed5206e2168d8a6fe3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a positive semidefinite constraint on a symmetric matrix.  <a href="#a46c66d4086096ed5206e2168d8a6fe3f">More...</a><br /></td></tr>
<tr class="separator:a46c66d4086096ed5206e2168d8a6fe3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8e0acb745cee5f6b8bb25248511406"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a4d8e0acb745cee5f6b8bb25248511406">AddPositiveSemidefiniteConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt; &amp;symmetric_matrix_var)</td></tr>
<tr class="memdesc:a4d8e0acb745cee5f6b8bb25248511406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a positive semidefinite constraint on a symmetric matrix.  <a href="#a4d8e0acb745cee5f6b8bb25248511406">More...</a><br /></td></tr>
<tr class="separator:a4d8e0acb745cee5f6b8bb25248511406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8ae66a7dc32a53fad92f348f127439"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a8f8ae66a7dc32a53fad92f348f127439">AddPositiveSemidefiniteConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;e)</td></tr>
<tr class="memdesc:a8f8ae66a7dc32a53fad92f348f127439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a positive semidefinite constraint on a symmetric matrix of symbolic expressions <code>e</code>.  <a href="#a8f8ae66a7dc32a53fad92f348f127439">More...</a><br /></td></tr>
<tr class="separator:a8f8ae66a7dc32a53fad92f348f127439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204ca1afa3b89cbcacb88162fb4007d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a204ca1afa3b89cbcacb88162fb4007d7">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:a204ca1afa3b89cbcacb88162fb4007d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear matrix inequality constraint to the program.  <a href="#a204ca1afa3b89cbcacb88162fb4007d7">More...</a><br /></td></tr>
<tr class="separator:a204ca1afa3b89cbcacb88162fb4007d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cca1ac259f166dc97725ed23b7e5739"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a3cca1ac259f166dc97725ed23b7e5739">AddLinearMatrixInequalityConstraint</a> (const std::vector&lt; Eigen::Ref&lt; const Eigen::MatrixXd &gt;&gt; &amp;F, const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;vars)</td></tr>
<tr class="memdesc:a3cca1ac259f166dc97725ed23b7e5739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear matrix inequality constraint to the program.  <a href="#a3cca1ac259f166dc97725ed23b7e5739">More...</a><br /></td></tr>
<tr class="separator:a3cca1ac259f166dc97725ed23b7e5739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f96e8fb29b956fde965719ae1bbb0cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a4f96e8fb29b956fde965719ae1bbb0cb">AddLinearMatrixInequalityConstraint</a> (const std::vector&lt; Eigen::Ref&lt; const Eigen::MatrixXd &gt;&gt; &amp;F, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a4f96e8fb29b956fde965719ae1bbb0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear matrix inequality constraint to the program.  <a href="#a4f96e8fb29b956fde965719ae1bbb0cb">More...</a><br /></td></tr>
<tr class="separator:a4f96e8fb29b956fde965719ae1bbb0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef1689f39c06dc1a2520276fcd47c5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a5ef1689f39c06dc1a2520276fcd47c5b">AddPositiveDiagonallyDominantMatrixConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;X)</td></tr>
<tr class="memdesc:a5ef1689f39c06dc1a2520276fcd47c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the constraint that a symmetric matrix is diagonally dominant with non-negative diagonal entries.  <a href="#a5ef1689f39c06dc1a2520276fcd47c5b">More...</a><br /></td></tr>
<tr class="separator:a5ef1689f39c06dc1a2520276fcd47c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27c69de208a984eac3ccba736b46b41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae27c69de208a984eac3ccba736b46b41">AddSosConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;p, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;&gt; &amp;monomial_basis, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> type=<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a>)</td></tr>
<tr class="memdesc:ae27c69de208a984eac3ccba736b46b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints that a given polynomial <code>p</code> is a sums-of-squares (SOS), that is, <code>p</code> can be decomposed into <code>mᵀQm</code>, where m is the <code>monomial_basis</code>.  <a href="#ae27c69de208a984eac3ccba736b46b41">More...</a><br /></td></tr>
<tr class="separator:ae27c69de208a984eac3ccba736b46b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861c38c659adf55d7ad0bffecee4bf13"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a861c38c659adf55d7ad0bffecee4bf13">AddSosConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;p, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> type=<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a>)</td></tr>
<tr class="memdesc:a861c38c659adf55d7ad0bffecee4bf13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints that a given polynomial <code>p</code> is a sums-of-squares (SOS), that is, <code>p</code> can be decomposed into <code>mᵀQm</code>, where m is a monomial basis selected from the sparsity of <code>p</code>.  <a href="#a861c38c659adf55d7ad0bffecee4bf13">More...</a><br /></td></tr>
<tr class="separator:a861c38c659adf55d7ad0bffecee4bf13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef1ca7232b100f33773c7cc7151f485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a1ef1ca7232b100f33773c7cc7151f485">AddSosConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;&gt; &amp;monomial_basis, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> type=<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a>)</td></tr>
<tr class="memdesc:a1ef1ca7232b100f33773c7cc7151f485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints that a given symbolic expression <code>e</code> is a sums-of-squares (SOS), that is, <code>p</code> can be decomposed into <code>mᵀQm</code>, where m is the <code>monomial_basis</code>.  <a href="#a1ef1ca7232b100f33773c7cc7151f485">More...</a><br /></td></tr>
<tr class="separator:a1ef1ca7232b100f33773c7cc7151f485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfeb9b0b6e49545dd732f7a3c95b152"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#afbfeb9b0b6e49545dd732f7a3c95b152">AddSosConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> type=<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a>)</td></tr>
<tr class="memdesc:afbfeb9b0b6e49545dd732f7a3c95b152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints that a given symbolic expression <code>e</code> is a sums-of-squares (SOS), that is, <code>e</code> can be decomposed into <code>mᵀQm</code>.  <a href="#afbfeb9b0b6e49545dd732f7a3c95b152">More...</a><br /></td></tr>
<tr class="separator:afbfeb9b0b6e49545dd732f7a3c95b152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5fc755dd3088b2e2d740965dd7a46f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a7d5fc755dd3088b2e2d740965dd7a46f">AddEqualityConstraintBetweenPolynomials</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;p1, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;p2)</td></tr>
<tr class="memdesc:a7d5fc755dd3088b2e2d740965dd7a46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraining that two polynomials are the same (i.e., they have the same coefficients for each monomial).  <a href="#a7d5fc755dd3088b2e2d740965dd7a46f">More...</a><br /></td></tr>
<tr class="separator:a7d5fc755dd3088b2e2d740965dd7a46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c8d9a4008399136a7f997d8b5be55c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html">ExponentialConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ad3c8d9a4008399136a7f997d8b5be55c">AddConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html">ExponentialConeConstraint</a> &gt; &amp;binding)</td></tr>
<tr class="memdesc:ad3c8d9a4008399136a7f997d8b5be55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the exponential cone constraint that z = binding.evaluator()-&gt;A() * binding.variables() + binding.evaluator()-&gt;b() should be in the exponential cone.  <a href="#ad3c8d9a4008399136a7f997d8b5be55c">More...</a><br /></td></tr>
<tr class="separator:ad3c8d9a4008399136a7f997d8b5be55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b08a882bd0f9c823350bf877fe7867f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html">ExponentialConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a7b08a882bd0f9c823350bf877fe7867f">AddExponentialConeConstraint</a> (const Eigen::Ref&lt; const Eigen::SparseMatrix&lt; double &gt;&gt; &amp;A, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a7b08a882bd0f9c823350bf877fe7867f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an exponential cone constraint, that z = A * vars + b should be in the exponential cone.  <a href="#a7b08a882bd0f9c823350bf877fe7867f">More...</a><br /></td></tr>
<tr class="separator:a7b08a882bd0f9c823350bf877fe7867f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700caef005988a7711e183b439e20a25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html">ExponentialConeConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a700caef005988a7711e183b439e20a25">AddExponentialConeConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;z)</td></tr>
<tr class="memdesc:a700caef005988a7711e183b439e20a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the constraint that z is in the exponential cone.  <a href="#a700caef005988a7711e183b439e20a25">More...</a><br /></td></tr>
<tr class="separator:a700caef005988a7711e183b439e20a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44e07a559ca22d055de33fa1154c095"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aa44e07a559ca22d055de33fa1154c095">GetInitialGuess</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a7647680c7f56fdae6dc324db6aed1e45">decision_variable</a>) const</td></tr>
<tr class="memdesc:aa44e07a559ca22d055de33fa1154c095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the initial guess for a single variable.  <a href="#aa44e07a559ca22d055de33fa1154c095">More...</a><br /></td></tr>
<tr class="separator:aa44e07a559ca22d055de33fa1154c095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390ecd2ae9e9cc6877af3c2202341b3e"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a390ecd2ae9e9cc6877af3c2202341b3e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, Eigen::Matrix&lt; double, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a390ecd2ae9e9cc6877af3c2202341b3e">GetInitialGuess</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;decision_variable_mat) const</td></tr>
<tr class="memdesc:a390ecd2ae9e9cc6877af3c2202341b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the initial guess for some variables.  <a href="#a390ecd2ae9e9cc6877af3c2202341b3e">More...</a><br /></td></tr>
<tr class="separator:a390ecd2ae9e9cc6877af3c2202341b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48cb6d2263ccf09e38932dcd27f769f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae48cb6d2263ccf09e38932dcd27f769f">SetInitialGuess</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a7647680c7f56fdae6dc324db6aed1e45">decision_variable</a>, double variable_guess_value)</td></tr>
<tr class="memdesc:ae48cb6d2263ccf09e38932dcd27f769f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the initial guess for a single variable <code>decision_variable</code>.  <a href="#ae48cb6d2263ccf09e38932dcd27f769f">More...</a><br /></td></tr>
<tr class="separator:ae48cb6d2263ccf09e38932dcd27f769f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eca61aa09da31d13c9d476cf1b6b760"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a6eca61aa09da31d13c9d476cf1b6b760"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a6eca61aa09da31d13c9d476cf1b6b760">SetInitialGuess</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;decision_variable_mat, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;x0)</td></tr>
<tr class="memdesc:a6eca61aa09da31d13c9d476cf1b6b760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the initial guess for the decision variables stored in <code>decision_variable_mat</code> to be <code>x0</code>.  <a href="#a6eca61aa09da31d13c9d476cf1b6b760">More...</a><br /></td></tr>
<tr class="separator:a6eca61aa09da31d13c9d476cf1b6b760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35679ed5aabea90fcf4ff3b337b44f5"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ae35679ed5aabea90fcf4ff3b337b44f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae35679ed5aabea90fcf4ff3b337b44f5">SetInitialGuessForAllVariables</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;x0)</td></tr>
<tr class="memdesc:ae35679ed5aabea90fcf4ff3b337b44f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the initial guess for ALL decision variables.  <a href="#ae35679ed5aabea90fcf4ff3b337b44f5">More...</a><br /></td></tr>
<tr class="separator:ae35679ed5aabea90fcf4ff3b337b44f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ab51bbb7a7abab25cb23d0f64d80d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a65ab51bbb7a7abab25cb23d0f64d80d4">SetDecisionVariableValueInVector</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a7647680c7f56fdae6dc324db6aed1e45">decision_variable</a>, double decision_variable_new_value, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::VectorXd &gt; values) const</td></tr>
<tr class="memdesc:a65ab51bbb7a7abab25cb23d0f64d80d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the value of a single <code>decision_variable</code> inside the <code>values</code> vector to be <code>decision_variable_new_value</code>.  <a href="#a65ab51bbb7a7abab25cb23d0f64d80d4">More...</a><br /></td></tr>
<tr class="separator:a65ab51bbb7a7abab25cb23d0f64d80d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff086e342ead2410215c884dfd4e82d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#afff086e342ead2410215c884dfd4e82d">SetDecisionVariableValueInVector</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt; &amp;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a3d833ea37172e9829c5d85e388eb9f59">decision_variables</a>, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;decision_variables_new_values, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::VectorXd &gt; values) const</td></tr>
<tr class="memdesc:afff086e342ead2410215c884dfd4e82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the values of some <code>decision_variables</code> inside the <code>values</code> vector to be <code>decision_variables_new_values</code>.  <a href="#afff086e342ead2410215c884dfd4e82d">More...</a><br /></td></tr>
<tr class="separator:afff086e342ead2410215c884dfd4e82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4737cb6ed52094f3d292e0ed4ca187da"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a4737cb6ed52094f3d292e0ed4ca187da">solver_options</a> () const</td></tr>
<tr class="memdesc:a4737cb6ed52094f3d292e0ed4ca187da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solver options stored inside <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <a href="#a4737cb6ed52094f3d292e0ed4ca187da">More...</a><br /></td></tr>
<tr class="separator:a4737cb6ed52094f3d292e0ed4ca187da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abf83f965123608bf855d5eef56806f"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; std::string, double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a7abf83f965123608bf855d5eef56806f">GetSolverOptionsDouble</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;solver_id) const</td></tr>
<tr class="separator:a7abf83f965123608bf855d5eef56806f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53e7b6bf2db39795a28138edda49638"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; std::string, <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aa53e7b6bf2db39795a28138edda49638">GetSolverOptionsInt</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;solver_id) const</td></tr>
<tr class="separator:aa53e7b6bf2db39795a28138edda49638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac296d646cdfb000b49df738e9da24159"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; std::string, std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac296d646cdfb000b49df738e9da24159">GetSolverOptionsStr</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;solver_id) const</td></tr>
<tr class="separator:ac296d646cdfb000b49df738e9da24159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744f8ed184bc9260b5970f7b8e12812a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html">VisualizationCallback</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a744f8ed184bc9260b5970f7b8e12812a">visualization_callbacks</a> () const</td></tr>
<tr class="memdesc:a744f8ed184bc9260b5970f7b8e12812a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for all callbacks.  <a href="#a744f8ed184bc9260b5970f7b8e12812a">More...</a><br /></td></tr>
<tr class="separator:a744f8ed184bc9260b5970f7b8e12812a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76eeecc02d2b6d3f2c11b407e70baf86"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a76eeecc02d2b6d3f2c11b407e70baf86">generic_costs</a> () const</td></tr>
<tr class="memdesc:a76eeecc02d2b6d3f2c11b407e70baf86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for all generic costs.  <a href="#a76eeecc02d2b6d3f2c11b407e70baf86">More...</a><br /></td></tr>
<tr class="separator:a76eeecc02d2b6d3f2c11b407e70baf86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a221ef50ba7ccdff7222a5a0fb38b7"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a63a221ef50ba7ccdff7222a5a0fb38b7">generic_constraints</a> () const</td></tr>
<tr class="memdesc:a63a221ef50ba7ccdff7222a5a0fb38b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for all generic constraints.  <a href="#a63a221ef50ba7ccdff7222a5a0fb38b7">More...</a><br /></td></tr>
<tr class="separator:a63a221ef50ba7ccdff7222a5a0fb38b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac264e3eaafb940135dfa11d3ba84c67"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aac264e3eaafb940135dfa11d3ba84c67">linear_equality_constraints</a> () const</td></tr>
<tr class="memdesc:aac264e3eaafb940135dfa11d3ba84c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for linear equality constraints.  <a href="#aac264e3eaafb940135dfa11d3ba84c67">More...</a><br /></td></tr>
<tr class="separator:aac264e3eaafb940135dfa11d3ba84c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073a43c000385cfb134619ac960ab36f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a073a43c000385cfb134619ac960ab36f">linear_costs</a> () const</td></tr>
<tr class="memdesc:a073a43c000385cfb134619ac960ab36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for linear costs.  <a href="#a073a43c000385cfb134619ac960ab36f">More...</a><br /></td></tr>
<tr class="separator:a073a43c000385cfb134619ac960ab36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67254b4fe297880931e6c66562f36353"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a67254b4fe297880931e6c66562f36353">quadratic_costs</a> () const</td></tr>
<tr class="memdesc:a67254b4fe297880931e6c66562f36353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for quadratic costs.  <a href="#a67254b4fe297880931e6c66562f36353">More...</a><br /></td></tr>
<tr class="separator:a67254b4fe297880931e6c66562f36353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e169f4d4bb63dd56bcd7cc89a561a1"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#af5e169f4d4bb63dd56bcd7cc89a561a1">l2norm_costs</a> () const</td></tr>
<tr class="memdesc:af5e169f4d4bb63dd56bcd7cc89a561a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for l2norm costs.  <a href="#af5e169f4d4bb63dd56bcd7cc89a561a1">More...</a><br /></td></tr>
<tr class="separator:af5e169f4d4bb63dd56bcd7cc89a561a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5febe285490e9ce74e824de29f2ecd9f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a5febe285490e9ce74e824de29f2ecd9f">linear_constraints</a> () const</td></tr>
<tr class="memdesc:a5febe285490e9ce74e824de29f2ecd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for linear constraints.  <a href="#a5febe285490e9ce74e824de29f2ecd9f">More...</a><br /></td></tr>
<tr class="separator:a5febe285490e9ce74e824de29f2ecd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9af8bd45f4e7aa63918031b0774fed0"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae9af8bd45f4e7aa63918031b0774fed0">lorentz_cone_constraints</a> () const</td></tr>
<tr class="memdesc:ae9af8bd45f4e7aa63918031b0774fed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for Lorentz cone constraints.  <a href="#ae9af8bd45f4e7aa63918031b0774fed0">More...</a><br /></td></tr>
<tr class="separator:ae9af8bd45f4e7aa63918031b0774fed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8ffa00352e1b2d8f1e8cfa720dc88c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aeb8ffa00352e1b2d8f1e8cfa720dc88c">rotated_lorentz_cone_constraints</a> () const</td></tr>
<tr class="memdesc:aeb8ffa00352e1b2d8f1e8cfa720dc88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for rotated Lorentz cone constraints.  <a href="#aeb8ffa00352e1b2d8f1e8cfa720dc88c">More...</a><br /></td></tr>
<tr class="separator:aeb8ffa00352e1b2d8f1e8cfa720dc88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653ebdfdf842cca45abac0c708d1195e"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a653ebdfdf842cca45abac0c708d1195e">positive_semidefinite_constraints</a> () const</td></tr>
<tr class="memdesc:a653ebdfdf842cca45abac0c708d1195e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for positive semidefinite constraints.  <a href="#a653ebdfdf842cca45abac0c708d1195e">More...</a><br /></td></tr>
<tr class="separator:a653ebdfdf842cca45abac0c708d1195e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e3ce329f648aae3bea248179013b34"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a27e3ce329f648aae3bea248179013b34">linear_matrix_inequality_constraints</a> () const</td></tr>
<tr class="memdesc:a27e3ce329f648aae3bea248179013b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for linear matrix inequality constraints.  <a href="#a27e3ce329f648aae3bea248179013b34">More...</a><br /></td></tr>
<tr class="separator:a27e3ce329f648aae3bea248179013b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ba7cf747dd35fbbbd4ea7c2baa4da7"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html">ExponentialConeConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a58ba7cf747dd35fbbbd4ea7c2baa4da7">exponential_cone_constraints</a> () const</td></tr>
<tr class="memdesc:a58ba7cf747dd35fbbbd4ea7c2baa4da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for exponential cone constraints.  <a href="#a58ba7cf747dd35fbbbd4ea7c2baa4da7">More...</a><br /></td></tr>
<tr class="separator:a58ba7cf747dd35fbbbd4ea7c2baa4da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39c3045633d664d62c161a5ef4f3c4c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#af39c3045633d664d62c161a5ef4f3c4c">bounding_box_constraints</a> () const</td></tr>
<tr class="memdesc:af39c3045633d664d62c161a5ef4f3c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for all bounding box constraints.  <a href="#af39c3045633d664d62c161a5ef4f3c4c">More...</a><br /></td></tr>
<tr class="separator:af39c3045633d664d62c161a5ef4f3c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9e00f78efde184f9f7377ed0a42700"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a1d9e00f78efde184f9f7377ed0a42700">linear_complementarity_constraints</a> () const</td></tr>
<tr class="memdesc:a1d9e00f78efde184f9f7377ed0a42700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for all linear complementarity constraints.  <a href="#a1d9e00f78efde184f9f7377ed0a42700">More...</a><br /></td></tr>
<tr class="separator:a1d9e00f78efde184f9f7377ed0a42700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90403c02bdb7c61d7a8de5dd39e9c39"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ad90403c02bdb7c61d7a8de5dd39e9c39">GetAllCosts</a> () const</td></tr>
<tr class="memdesc:ad90403c02bdb7c61d7a8de5dd39e9c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter returning all costs.  <a href="#ad90403c02bdb7c61d7a8de5dd39e9c39">More...</a><br /></td></tr>
<tr class="separator:ad90403c02bdb7c61d7a8de5dd39e9c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fe85b6ddbc665b74e8cf9c6bf02d3e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a17fe85b6ddbc665b74e8cf9c6bf02d3e">GetAllLinearConstraints</a> () const</td></tr>
<tr class="memdesc:a17fe85b6ddbc665b74e8cf9c6bf02d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter returning all linear constraints (both linear equality and inequality constraints).  <a href="#a17fe85b6ddbc665b74e8cf9c6bf02d3e">More...</a><br /></td></tr>
<tr class="separator:a17fe85b6ddbc665b74e8cf9c6bf02d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee45efd038cc24341094591bf1cbdbc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#afee45efd038cc24341094591bf1cbdbc">GetAllConstraints</a> () const</td></tr>
<tr class="memdesc:afee45efd038cc24341094591bf1cbdbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for returning all constraints.  <a href="#afee45efd038cc24341094591bf1cbdbc">More...</a><br /></td></tr>
<tr class="separator:afee45efd038cc24341094591bf1cbdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224e4c35014e87139f73f9a517866796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a224e4c35014e87139f73f9a517866796">num_vars</a> () const</td></tr>
<tr class="memdesc:a224e4c35014e87139f73f9a517866796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for number of variables in the optimization program.  <a href="#a224e4c35014e87139f73f9a517866796">More...</a><br /></td></tr>
<tr class="separator:a224e4c35014e87139f73f9a517866796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1e942fc28f03d2b987fc0ea880e831"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a3b1e942fc28f03d2b987fc0ea880e831">num_indeterminates</a> () const</td></tr>
<tr class="memdesc:a3b1e942fc28f03d2b987fc0ea880e831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of indeterminates in the optimization program.  <a href="#a3b1e942fc28f03d2b987fc0ea880e831">More...</a><br /></td></tr>
<tr class="separator:a3b1e942fc28f03d2b987fc0ea880e831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d203a1789d8fe03eeaaacdb49a267d4"><td class="memItemLeft" align="right" valign="top">const Eigen::VectorXd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a8d203a1789d8fe03eeaaacdb49a267d4">initial_guess</a> () const</td></tr>
<tr class="memdesc:a8d203a1789d8fe03eeaaacdb49a267d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the initial guess.  <a href="#a8d203a1789d8fe03eeaaacdb49a267d4">More...</a><br /></td></tr>
<tr class="separator:a8d203a1789d8fe03eeaaacdb49a267d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f25e54555621691b390c1658e21872f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a2f25e54555621691b390c1658e21872f">FindDecisionVariableIndex</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;var) const</td></tr>
<tr class="memdesc:a2f25e54555621691b390c1658e21872f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the decision variable.  <a href="#a2f25e54555621691b390c1658e21872f">More...</a><br /></td></tr>
<tr class="separator:a2f25e54555621691b390c1658e21872f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e872544e169f9b66f499bc06eb4641"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a53e872544e169f9b66f499bc06eb4641">FindDecisionVariableIndices</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;vars) const</td></tr>
<tr class="memdesc:a53e872544e169f9b66f499bc06eb4641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the indices of the decision variables.  <a href="#a53e872544e169f9b66f499bc06eb4641">More...</a><br /></td></tr>
<tr class="separator:a53e872544e169f9b66f499bc06eb4641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1470ed93553619a1f630bc8035947556"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a1470ed93553619a1f630bc8035947556">FindIndeterminateIndex</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;var) const</td></tr>
<tr class="memdesc:a1470ed93553619a1f630bc8035947556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the indeterminate.  <a href="#a1470ed93553619a1f630bc8035947556">More...</a><br /></td></tr>
<tr class="separator:a1470ed93553619a1f630bc8035947556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d07051ef1c3778a15b117060f65ac5"><td class="memTemplParams" colspan="2">template&lt;typename C , typename DerivedX &gt; </td></tr>
<tr class="memitem:af9d07051ef1c3778a15b117060f65ac5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt; DerivedX &gt;::value, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; typename DerivedX::Scalar &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#af9d07051ef1c3778a15b117060f65ac5">EvalBinding</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;binding, const Eigen::MatrixBase&lt; DerivedX &gt; &amp;prog_var_vals) const</td></tr>
<tr class="memdesc:af9d07051ef1c3778a15b117060f65ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the value of some binding, for some input value for all decision variables.  <a href="#af9d07051ef1c3778a15b117060f65ac5">More...</a><br /></td></tr>
<tr class="separator:af9d07051ef1c3778a15b117060f65ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ace5ac7ffabb8af91d49f41bc09ab1"><td class="memTemplParams" colspan="2">template&lt;typename C , typename DerivedX &gt; </td></tr>
<tr class="memitem:a30ace5ac7ffabb8af91d49f41bc09ab1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt; DerivedX &gt;::value, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; typename DerivedX::Scalar &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a30ace5ac7ffabb8af91d49f41bc09ab1">EvalBindings</a> (const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt;&gt; &amp;bindings, const Eigen::MatrixBase&lt; DerivedX &gt; &amp;prog_var_vals) const</td></tr>
<tr class="memdesc:a30ace5ac7ffabb8af91d49f41bc09ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a set of bindings (plural version of <code>EvalBinding</code>).  <a href="#a30ace5ac7ffabb8af91d49f41bc09ab1">More...</a><br /></td></tr>
<tr class="separator:a30ace5ac7ffabb8af91d49f41bc09ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1b28062ab095a5824cbf928e37e1ff"><td class="memTemplParams" colspan="2">template&lt;typename C , typename DerivedX &gt; </td></tr>
<tr class="memitem:adf1b28062ab095a5824cbf928e37e1ff"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt; DerivedX &gt;::value, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; typename DerivedX::Scalar &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#adf1b28062ab095a5824cbf928e37e1ff">GetBindingVariableValues</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;binding, const Eigen::MatrixBase&lt; DerivedX &gt; &amp;prog_var_vals) const</td></tr>
<tr class="memdesc:adf1b28062ab095a5824cbf928e37e1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the value of all decision variables, namely this.decision_variable(i) takes the value prog_var_vals(i), returns the vector that contains the value of the variables in binding.variables().  <a href="#adf1b28062ab095a5824cbf928e37e1ff">More...</a><br /></td></tr>
<tr class="separator:adf1b28062ab095a5824cbf928e37e1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856ded9f90eaac91a1c66f2c139566b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a856ded9f90eaac91a1c66f2c139566b5">EvalVisualizationCallbacks</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;prog_var_vals) const</td></tr>
<tr class="memdesc:a856ded9f90eaac91a1c66f2c139566b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates all visualization callbacks registered with the <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <a href="#a856ded9f90eaac91a1c66f2c139566b5">More...</a><br /></td></tr>
<tr class="separator:a856ded9f90eaac91a1c66f2c139566b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb46a0ff11d6f6d22d69d9c16bfce94"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a0eb46a0ff11d6f6d22d69d9c16bfce94"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a0eb46a0ff11d6f6d22d69d9c16bfce94">EvalBindingAtInitialGuess</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;binding) const</td></tr>
<tr class="memdesc:a0eb46a0ff11d6f6d22d69d9c16bfce94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the evaluator in <code>binding</code> at the initial guess.  <a href="#a0eb46a0ff11d6f6d22d69d9c16bfce94">More...</a><br /></td></tr>
<tr class="separator:a0eb46a0ff11d6f6d22d69d9c16bfce94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92eb16be90ba1765547a715ec244fe00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a92eb16be90ba1765547a715ec244fe00">CheckSatisfied</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &amp;binding, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;prog_var_vals, double tol=1e-6) const</td></tr>
<tr class="memdesc:a92eb16be90ba1765547a715ec244fe00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates CheckSatisfied for the constraint in <code>binding</code> using the value of ALL of the decision variables in this program.  <a href="#a92eb16be90ba1765547a715ec244fe00">More...</a><br /></td></tr>
<tr class="separator:a92eb16be90ba1765547a715ec244fe00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2467d1ef4671955b66dd8ddfac39e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a3c2467d1ef4671955b66dd8ddfac39e4">CheckSatisfied</a> (const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt;&gt; &amp;bindings, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;prog_var_vals, double tol=1e-6) const</td></tr>
<tr class="memdesc:a3c2467d1ef4671955b66dd8ddfac39e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates CheckSatisfied for the all of the constraints in <code>binding</code> using the value of ALL of the decision variables in this program.  <a href="#a3c2467d1ef4671955b66dd8ddfac39e4">More...</a><br /></td></tr>
<tr class="separator:a3c2467d1ef4671955b66dd8ddfac39e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e98056457ab5ff0855a167b2a057dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a40e98056457ab5ff0855a167b2a057dc">CheckSatisfiedAtInitialGuess</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &amp;binding, double tol=1e-6) const</td></tr>
<tr class="memdesc:a40e98056457ab5ff0855a167b2a057dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates CheckSatisfied for the constraint in <code>binding</code> at the initial guess.  <a href="#a40e98056457ab5ff0855a167b2a057dc">More...</a><br /></td></tr>
<tr class="separator:a40e98056457ab5ff0855a167b2a057dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe6687c1f407124c9bd88777ed71144"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#acbe6687c1f407124c9bd88777ed71144">CheckSatisfiedAtInitialGuess</a> (const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt;&gt; &amp;bindings, double tol=1e-6) const</td></tr>
<tr class="memdesc:acbe6687c1f407124c9bd88777ed71144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates CheckSatisfied for the all of the constraints in <code>bindings</code> at the initial guess.  <a href="#acbe6687c1f407124c9bd88777ed71144">More...</a><br /></td></tr>
<tr class="separator:acbe6687c1f407124c9bd88777ed71144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d833ea37172e9829c5d85e388eb9f59"><td class="memItemLeft" align="right" valign="top">Eigen::Map&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a3d833ea37172e9829c5d85e388eb9f59">decision_variables</a> () const</td></tr>
<tr class="memdesc:a3d833ea37172e9829c5d85e388eb9f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for all decision variables in the program.  <a href="#a3d833ea37172e9829c5d85e388eb9f59">More...</a><br /></td></tr>
<tr class="separator:a3d833ea37172e9829c5d85e388eb9f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7647680c7f56fdae6dc324db6aed1e45"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a7647680c7f56fdae6dc324db6aed1e45">decision_variable</a> (<a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a7647680c7f56fdae6dc324db6aed1e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the decision variable with index <code>i</code> in the program.  <a href="#a7647680c7f56fdae6dc324db6aed1e45">More...</a><br /></td></tr>
<tr class="separator:a7647680c7f56fdae6dc324db6aed1e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa1d35a078980665b4cabac09dd235b"><td class="memItemLeft" align="right" valign="top">Eigen::Map&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#abaa1d35a078980665b4cabac09dd235b">indeterminates</a> () const</td></tr>
<tr class="memdesc:abaa1d35a078980665b4cabac09dd235b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for all indeterminates in the program.  <a href="#abaa1d35a078980665b4cabac09dd235b">More...</a><br /></td></tr>
<tr class="separator:abaa1d35a078980665b4cabac09dd235b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6736e7e843acfd67ecd254b9a2270863"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a6736e7e843acfd67ecd254b9a2270863">indeterminate</a> (<a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="memdesc:a6736e7e843acfd67ecd254b9a2270863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the indeterminate with index <code>i</code> in the program.  <a href="#a6736e7e843acfd67ecd254b9a2270863">More...</a><br /></td></tr>
<tr class="separator:a6736e7e843acfd67ecd254b9a2270863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7f71f7ae23678cd721de4cfcb52f54"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a2a7f71f7ae23678cd721de4cfcb52f54">required_capabilities</a> () const</td></tr>
<tr class="memdesc:a2a7f71f7ae23678cd721de4cfcb52f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the required capability on the solver, given the cost/constraint/variable types in the program.  <a href="#a2a7f71f7ae23678cd721de4cfcb52f54">More...</a><br /></td></tr>
<tr class="separator:a2a7f71f7ae23678cd721de4cfcb52f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2b24f3bef681051fd923693a85ee7e"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a8f2b24f3bef681051fd923693a85ee7e">decision_variable_index</a> () const</td></tr>
<tr class="memdesc:a8f2b24f3bef681051fd923693a85ee7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mapping from a decision variable ID to its index in the vector containing all the decision variables in the mathematical program.  <a href="#a8f2b24f3bef681051fd923693a85ee7e">More...</a><br /></td></tr>
<tr class="separator:a8f2b24f3bef681051fd923693a85ee7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c27da874a5e06bccfb91ff25ec05fb9"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a0c27da874a5e06bccfb91ff25ec05fb9">indeterminates_index</a> () const</td></tr>
<tr class="memdesc:a0c27da874a5e06bccfb91ff25ec05fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mapping from an indeterminate ID to its index in the vector containing all the indeterminates in the mathematical program.  <a href="#a0c27da874a5e06bccfb91ff25ec05fb9">More...</a><br /></td></tr>
<tr class="separator:a0c27da874a5e06bccfb91ff25ec05fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:a6d281d024510ccc0f7787ebbb1e534ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a6d281d024510ccc0f7787ebbb1e534ee">MathematicalProgram</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;)=delete</td></tr>
<tr class="separator:a6d281d024510ccc0f7787ebbb1e534ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751cdda7529e03736fc7530fad6bd7fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a751cdda7529e03736fc7530fad6bd7fa">operator=</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;)=delete</td></tr>
<tr class="separator:a751cdda7529e03736fc7530fad6bd7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1935f9e12a11b66c67eda33fd165b4d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a1935f9e12a11b66c67eda33fd165b4d3">MathematicalProgram</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a1935f9e12a11b66c67eda33fd165b4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bf33171369a5b673c956f7e21e1c5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ad6bf33171369a5b673c956f7e21e1c5f">operator=</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ad6bf33171369a5b673c956f7e21e1c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Creating even-degree nonnegative polynomials</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="even_degree_nonnegative_polynomial"></a> Creates a nonnegative polynomial p = m(x)ᵀQm(x) of a given degree, and p only contains even-degree monomials. If we partition the monomials m(x) to odd degree monomials m_o(x) and even degree monomials m_e(x), then we can write p(x) as </p><pre>
⌈m_o(x)⌉ᵀ * ⌈Q_oo Q_oeᵀ⌉ * ⌈m_o(x)⌉
⌊m_e(x)⌋    ⌊Q_oe Q_ee ⌋   ⌊m_e(x)⌋
</pre><p> Since p(x) doesn't contain any odd degree monomials, and p(x) contains terms m_e(x)ᵀ*Q_oe * m_o(x) which has odd degree, we know that the off-diagonal block Q_oe has to be zero. So the constraint that Q is psd can be simplified as Q_oo and Q_ee has to be psd. Since both Q_oo and Q_ee have smaller size than Q, these PSD constraints are easier to solve than requiring Q to be PSD. One use case for even-degree polynomial, is for polynomials that are even functions, namely p(x) = p(-x). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indeterminates</td><td>The set of indeterminates x </td></tr>
    <tr><td class="paramname">degree</td><td>The total degree of the polynomial p. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>This must be an even number. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>(p(x), Q_oo, Q_ee). p(x) is the newly added non-negative polynomial. p(x) = m_o(x)ᵀ*Q_oo*m_o(x) + m_e(x)ᵀ*Q_ee*m_e(x) where m_o(x) and m_e(x) contain all the even/odd monomials of x respectively. The returned non-negative polynomial can be of different types, including Sum-of-squares (SOS), diagonally-dominant-sum-of-squares (dsos), and scaled-diagonally-dominant-sum-of-squares (sdsos). </dd></dl>
</div></td></tr>
<tr class="memitem:ab5aa9886afdbee42b4eab1077318f961"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ab5aa9886afdbee42b4eab1077318f961">NewEvenDegreeNonnegativePolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#abaa1d35a078980665b4cabac09dd235b">indeterminates</a>, <a class="el" href="classint.html">int</a> degree, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a> type)</td></tr>
<tr class="memdesc:ab5aa9886afdbee42b4eab1077318f961"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#even_degree_nonnegative_polynomial">even_degree_nonnegative_polynomial</a> for more details.  <a href="#ab5aa9886afdbee42b4eab1077318f961">More...</a><br /></td></tr>
<tr class="separator:ab5aa9886afdbee42b4eab1077318f961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b568d2ab99871d864e445960ac8dc18"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a3b568d2ab99871d864e445960ac8dc18">NewEvenDegreeSosPolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#abaa1d35a078980665b4cabac09dd235b">indeterminates</a>, <a class="el" href="classint.html">int</a> degree)</td></tr>
<tr class="memdesc:a3b568d2ab99871d864e445960ac8dc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#even_degree_nonnegative_polynomial">even_degree_nonnegative_polynomial</a> for more details.  <a href="#a3b568d2ab99871d864e445960ac8dc18">More...</a><br /></td></tr>
<tr class="separator:a3b568d2ab99871d864e445960ac8dc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3787e8a9fcc4e09304d6e1fa697d2d7f"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a3787e8a9fcc4e09304d6e1fa697d2d7f">NewEvenDegreeSdsosPolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#abaa1d35a078980665b4cabac09dd235b">indeterminates</a>, <a class="el" href="classint.html">int</a> degree)</td></tr>
<tr class="memdesc:a3787e8a9fcc4e09304d6e1fa697d2d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">see <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#even_degree_nonnegative_polynomial">even_degree_nonnegative_polynomial</a> for details.  <a href="#a3787e8a9fcc4e09304d6e1fa697d2d7f">More...</a><br /></td></tr>
<tr class="separator:a3787e8a9fcc4e09304d6e1fa697d2d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7be7b407fbcebb6fc7100759492a3d9"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#af7be7b407fbcebb6fc7100759492a3d9">NewEvenDegreeDsosPolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#abaa1d35a078980665b4cabac09dd235b">indeterminates</a>, <a class="el" href="classint.html">int</a> degree)</td></tr>
<tr class="memdesc:af7be7b407fbcebb6fc7100759492a3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">see <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#even_degree_nonnegative_polynomial">even_degree_nonnegative_polynomial</a> for details.  <a href="#af7be7b407fbcebb6fc7100759492a3d9">More...</a><br /></td></tr>
<tr class="separator:af7be7b407fbcebb6fc7100759492a3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Maximize geometric mean</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="maximize_geometric_mean"></a> Adds the cost to maximize the geometric mean of z = Ax+b, i.e. power(∏ᵢz(i), 1/n), where z ∈ ℝⁿ, z(i) &gt;= 0. Mathematically, the cost we add is -power(∏ᵢz(i), 1/r), where r = power(2, ceil(log₂n)), namely r is the smallest power of 2 that is no smaller than the size of z. For example, if z ∈ ℝ², then the added cost is -power(z(0)*z(1), 1/2) if z ∈ ℝ³, then the added cost is -power(z(0)*z(1)*z(2), 1/4).</p>
<p>In order to add this cost, we need to introduce a set of second-order cone constraints. For example, to maximize power(z(0) * z(1), 1/2), we introduce the slack variable w(0), together with the second order cone constraint w(0)² ≤ z(0) * z(1), z(0) ≥ 0, z(1) ≥ 0, and we maximize w(0).</p>
<p>To maximize power(z(0) * z(1) * z(2), 1/ 4), we introduce the slack variable w(0), w(1), w(2), together with the second order cone constraints </p><pre>
w(0)² ≤ z(0) * z(1), z(0) ≥ 0, z(1) ≥ 0
w(1)² ≤ z(2), z(2) ≥ 0
w(2)² ≤ w(0) * w(1), w(0) ≥ 0, w(1) ≥ 0
</pre><p> and we maximize w(2). </p>
</div></td></tr>
<tr class="memitem:a16968bf237a668a8777916fe61050848"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a16968bf237a668a8777916fe61050848">AddMaximizeGeometricMeanCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;x)</td></tr>
<tr class="memdesc:a16968bf237a668a8777916fe61050848"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overloaded version of <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#maximize_geometric_mean">maximize_geometric_mean</a>.  <a href="#a16968bf237a668a8777916fe61050848">More...</a><br /></td></tr>
<tr class="separator:a16968bf237a668a8777916fe61050848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ebe4b7fbb443836fa18d5645f656a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a03ebe4b7fbb443836fa18d5645f656a3">AddMaximizeGeometricMeanCost</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;x, double c=1.0)</td></tr>
<tr class="memdesc:a03ebe4b7fbb443836fa18d5645f656a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overloaded version of <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#maximize_geometric_mean">maximize_geometric_mean</a>.  <a href="#a03ebe4b7fbb443836fa18d5645f656a3">More...</a><br /></td></tr>
<tr class="separator:a03ebe4b7fbb443836fa18d5645f656a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">scaled diagonally dominant matrix constraint</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="addsdd"></a> Adds the constraint that a symmetric matrix is scaled diagonally dominant (sdd). A matrix X is sdd if there exists a diagonal matrix D, such that the product DXD is diagonally dominant with non-negative diagonal entries, namely d(i)X(i, i) ≥ ∑ⱼ |d(j)X(i, j)| ∀ j ≠ i where d(i) = D(i, i). X being sdd is equivalent to the existence of symmetric matrices Mⁱʲ∈ ℝⁿˣⁿ, i &lt; j, such that all entries in Mⁱʲ are 0, except Mⁱʲ(i, i), Mⁱʲ(i, j), Mⁱʲ(j, j). (Mⁱʲ(i, i), Mⁱʲ(j, j), Mⁱʲ(i, j)) is in the rotated Lorentz cone, and X = ∑ᵢⱼ Mⁱʲ.</p>
<p>The users can refer to "DSOS and SDSOS Optimization: More Tractable
Alternatives to Sum of Squares and Semidefinite Optimization" by Amir Ali Ahmadi and Anirudha Majumdar, with arXiv link <a href="https://arxiv.org/abs/1706.02586">https://arxiv.org/abs/1706.02586</a>. </p>
</div></td></tr>
<tr class="memitem:a025725213af92f5cbd02afb1c7c7f006"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="namespacedrake.html#a06406a5da633da84f911e2979aa48549">Matrix2</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a025725213af92f5cbd02afb1c7c7f006">AddScaledDiagonallyDominantMatrixConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;X)</td></tr>
<tr class="memdesc:a025725213af92f5cbd02afb1c7c7f006"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded variant of <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#addsdd">scaled diagonally dominant matrix constraint</a>.  <a href="#a025725213af92f5cbd02afb1c7c7f006">More...</a><br /></td></tr>
<tr class="separator:a025725213af92f5cbd02afb1c7c7f006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36d897cf0f11f2fa5f130148e4d5401"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="namespacedrake.html#a06406a5da633da84f911e2979aa48549">Matrix2</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aa36d897cf0f11f2fa5f130148e4d5401">AddScaledDiagonallyDominantMatrixConstraint</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;X)</td></tr>
<tr class="memdesc:aa36d897cf0f11f2fa5f130148e4d5401"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded variant of <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#addsdd">scaled diagonally dominant matrix constraint</a>.  <a href="#aa36d897cf0f11f2fa5f130148e4d5401">More...</a><br /></td></tr>
<tr class="separator:aa36d897cf0f11f2fa5f130148e4d5401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Set solver options</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="set_solver_option"></a> Set the options (parameters) for a specific solver. Refer to <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html" title="Stores options for multiple solvers.">SolverOptions</a> class for more details on the supported options of each solver. </p>
</div></td></tr>
<tr class="memitem:a77b58f1d09a3aec5918813ba163c1098"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a77b58f1d09a3aec5918813ba163c1098">SetSolverOption</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;solver_id, const std::string &amp;solver_option, double option_value)</td></tr>
<tr class="memdesc:a77b58f1d09a3aec5918813ba163c1098"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#set_solver_option">set_solver_option</a> for more details.  <a href="#a77b58f1d09a3aec5918813ba163c1098">More...</a><br /></td></tr>
<tr class="separator:a77b58f1d09a3aec5918813ba163c1098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aafa15b34bc04d8a3449f39787bc76e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a3aafa15b34bc04d8a3449f39787bc76e">SetSolverOption</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;solver_id, const std::string &amp;solver_option, <a class="el" href="classint.html">int</a> option_value)</td></tr>
<tr class="memdesc:a3aafa15b34bc04d8a3449f39787bc76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#set_solver_option">set_solver_option</a> for more details.  <a href="#a3aafa15b34bc04d8a3449f39787bc76e">More...</a><br /></td></tr>
<tr class="separator:a3aafa15b34bc04d8a3449f39787bc76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b38acbaeb959344b7ef04e84f4c40c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a00b38acbaeb959344b7ef04e84f4c40c">SetSolverOption</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;solver_id, const std::string &amp;solver_option, const std::string &amp;option_value)</td></tr>
<tr class="memdesc:a00b38acbaeb959344b7ef04e84f4c40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#set_solver_option">set_solver_option</a> for more details.  <a href="#a00b38acbaeb959344b7ef04e84f4c40c">More...</a><br /></td></tr>
<tr class="separator:a00b38acbaeb959344b7ef04e84f4c40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5ce186e378a8fbf9f0924b2e55994c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aed5ce186e378a8fbf9f0924b2e55994c">SetSolverOptions</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &amp;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a4737cb6ed52094f3d292e0ed4ca187da">solver_options</a>)</td></tr>
<tr class="memdesc:aed5ce186e378a8fbf9f0924b2e55994c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite the stored solver options inside <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> with the provided solver options.  <a href="#aed5ce186e378a8fbf9f0924b2e55994c">More...</a><br /></td></tr>
<tr class="separator:aed5ce186e378a8fbf9f0924b2e55994c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Variable scaling</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="variable_scaling"></a> Some solvers (e.g. SNOPT) work better if the decision variables values are on the same scale. Hence, internally we scale the variable as snopt_var_value = var_value / scaling_factor. This scaling factor is only used inside the solve, so users don't need to manually scale the variables every time they appears in cost and constraints. When the users set the initial guess, or getting the result from <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html#a0f8ef3892870d92bd4d3b0b5cd2e155f" title="Gets the solution of all decision variables.">MathematicalProgramResult::GetSolution()</a>, the values are unscaled. Namely, MathematicalProgramResult::GetSolution(var) returns the value of var, not var_value / scaling_factor.</p>
<p>The feature of variable scaling is currently only implemented for SNOPT and OSQP. </p>
</div></td></tr>
<tr class="memitem:a5ebc792721a0a9dca1079e093428655a"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; <a class="el" href="classint.html">int</a>, double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a5ebc792721a0a9dca1079e093428655a">GetVariableScaling</a> () const</td></tr>
<tr class="memdesc:a5ebc792721a0a9dca1079e093428655a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mapping from a decision variable index to its scaling factor.  <a href="#a5ebc792721a0a9dca1079e093428655a">More...</a><br /></td></tr>
<tr class="separator:a5ebc792721a0a9dca1079e093428655a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b4542d7067f6d60ea801b3b00c591f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#af4b4542d7067f6d60ea801b3b00c591f">SetVariableScaling</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;var, double s)</td></tr>
<tr class="memdesc:af4b4542d7067f6d60ea801b3b00c591f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for the scaling <code>s</code> of decision variable <code>var</code>.  <a href="#af4b4542d7067f6d60ea801b3b00c591f">More...</a><br /></td></tr>
<tr class="separator:af4b4542d7067f6d60ea801b3b00c591f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2079c8eee90c77853f4a9a96c14715a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac2079c8eee90c77853f4a9a96c14715a">ClearVariableScaling</a> ()</td></tr>
<tr class="memdesc:ac2079c8eee90c77853f4a9a96c14715a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the scaling factors for decision variables.  <a href="#ac2079c8eee90c77853f4a9a96c14715a">More...</a><br /></td></tr>
<tr class="separator:ac2079c8eee90c77853f4a9a96c14715a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Remove costs or constraints</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="remove_cost_constraint"></a> Removes costs or constraints from this program. If this program contains multiple costs/constraints objects matching the given argument, then all of these costs/constraints are removed. If this program doesn't contain the specified cost/constraint, then the code does nothing. We regard two costs/constraints being equal, if their evaluators point to the same object, and the associated variables are also the same. </p><dl class="section note"><dt>Note</dt><dd>If two costs/constraints represent the same expression, but their evaluators point to different objects, then they are NOT regarded the same. For example, if we have <div class="fragment"><div class="line"><span class="keyword">auto</span> cost1 = prog.AddLinearCost(x[0] + x[1]);</div><div class="line"><span class="keyword">auto</span> cost2 = prog.AddLinearCost(x[0] + x[1]);</div><div class="line"><span class="comment">// cost1 and cost2 represent the same cost, but cost1.evaluator() and</span></div><div class="line"><span class="comment">// cost2.evaluator() point to different objects. So after removing cost1,</span></div><div class="line"><span class="comment">// cost2 still lives in prog.</span></div><div class="line">prog.RemoveCost(cost1);</div><div class="line"><span class="comment">// This will print true.</span></div><div class="line">std::cout &lt;&lt; (prog.linear_costs()[0] == cost2) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div></div><!-- fragment --> </dd></dl>
</div></td></tr>
<tr class="memitem:a776ae5f3bb0dc9a705c584e511aff067"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a776ae5f3bb0dc9a705c584e511aff067">RemoveCost</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &amp;cost)</td></tr>
<tr class="memdesc:a776ae5f3bb0dc9a705c584e511aff067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <code>cost</code> from this mathematical program.  <a href="#a776ae5f3bb0dc9a705c584e511aff067">More...</a><br /></td></tr>
<tr class="separator:a776ae5f3bb0dc9a705c584e511aff067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1b59ceeeec9235267e4a8b6d440c9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#acb1b59ceeeec9235267e4a8b6d440c9f">RemoveConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &amp;constraint)</td></tr>
<tr class="memdesc:acb1b59ceeeec9235267e4a8b6d440c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <code>constraint</code> from this mathematical program.  <a href="#acb1b59ceeeec9235267e4a8b6d440c9f">More...</a><br /></td></tr>
<tr class="separator:acb1b59ceeeec9235267e4a8b6d440c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8f76110fcfea54be86c2ef1ebfeaab55"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a8f76110fcfea54be86c2ef1ebfeaab55"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a8f76110fcfea54be86c2ef1ebfeaab55">MakeCost</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:a8f76110fcfea54be86c2ef1ebfeaab55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an input of type <code>F</code> to a FunctionCost object.  <a href="#a8f76110fcfea54be86c2ef1ebfeaab55">More...</a><br /></td></tr>
<tr class="separator:a8f76110fcfea54be86c2ef1ebfeaab55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a78994b92c87719287528546dc12538bb"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a78994b92c87719287528546dc12538bb">kGlobalInfeasibleCost</a></td></tr>
<tr class="memdesc:a78994b92c87719287528546dc12538bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The optimal cost is +∞ when the problem is globally infeasible.  <a href="#a78994b92c87719287528546dc12538bb">More...</a><br /></td></tr>
<tr class="separator:a78994b92c87719287528546dc12538bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab953e201d71c0ce608e7c95607a4f256"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ab953e201d71c0ce608e7c95607a4f256">kUnboundedCost</a></td></tr>
<tr class="memdesc:ab953e201d71c0ce608e7c95607a4f256"><td class="mdescLeft">&#160;</td><td class="mdescRight">The optimal cost is -∞ when the problem is unbounded.  <a href="#ab953e201d71c0ce608e7c95607a4f256">More...</a><br /></td></tr>
<tr class="separator:ab953e201d71c0ce608e7c95607a4f256"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aaed05d048d1ac7b1d4960e328c20d02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed05d048d1ac7b1d4960e328c20d02f">&#9670;&nbsp;</a></span>VarType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">VarType</a> =  <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">symbolic::Variable::Type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a407fb21fc13a5122994e71a05a6a0818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407fb21fc13a5122994e71a05a6a0818">&#9670;&nbsp;</a></span>NonnegativePolynomial</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Types of non-negative polynomial that can be found through conic optimization. </p>
<p>We currently support SOS, SDSOS and DSOS. For more information about these polynomial types, please refer to "DSOS and SDSOS Optimization: More Tractable
Alternatives to Sum of Squares and Semidefinite Optimization" by Amir Ali Ahmadi and Anirudha Majumdar, with arXiv link <a href="https://arxiv.org/abs/1706.02586">https://arxiv.org/abs/1706.02586</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076"></a>kSos&#160;</td><td class="fielddoc"><p>A sum-of-squares polynomial. </p>
</td></tr>
<tr><td class="fieldname"><a id="a407fb21fc13a5122994e71a05a6a0818a28b23c4ed46cc23775486c764a920e29"></a>kSdsos&#160;</td><td class="fielddoc"><p>A scaled-diagonally dominant sum-of-squares polynomial. </p>
</td></tr>
<tr><td class="fieldname"><a id="a407fb21fc13a5122994e71a05a6a0818a26e1dbaa56329cec4d3ba803424aed81"></a>kDsos&#160;</td><td class="fielddoc"><p>A diagonally dominant sum-of-squares polynomial. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6d281d024510ccc0f7787ebbb1e534ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d281d024510ccc0f7787ebbb1e534ee">&#9670;&nbsp;</a></span>MathematicalProgram() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1935f9e12a11b66c67eda33fd165b4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1935f9e12a11b66c67eda33fd165b4d3">&#9670;&nbsp;</a></span>MathematicalProgram() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac577d0f44c9c07256230cf2642ec6822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac577d0f44c9c07256230cf2642ec6822">&#9670;&nbsp;</a></span>MathematicalProgram() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4793d463ad85b0e169fef6a974df5323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4793d463ad85b0e169fef6a974df5323">&#9670;&nbsp;</a></span>~MathematicalProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0aece6fd5b228f6e0f7fc2c8c149f983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aece6fd5b228f6e0f7fc2c8c149f983">&#9670;&nbsp;</a></span>Add2NormSquaredCost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a>&gt; Add2NormSquaredCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a quadratic cost of the form |Ax-b|²=(Ax-b)ᵀ(Ax-b) </p>

</div>
</div>
<a id="a0ae0959f2cae1208fa1d8e80fa48242f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae0959f2cae1208fa1d8e80fa48242f">&#9670;&nbsp;</a></span>Add2NormSquaredCost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a>&gt; Add2NormSquaredCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a quadratic cost of the form |Ax-b|²=(Ax-b)ᵀ(Ax-b) </p>

</div>
</div>
<a id="a1b4d1c9278bc20bf599b1e74178f51c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b4d1c9278bc20bf599b1e74178f51c8">&#9670;&nbsp;</a></span>AddBoundingBoxConstraint() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a>&gt; AddBoundingBoxConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AddBoundingBoxConstraint. </p>
<p>Adds bounding box constraints referencing potentially a subset of the decision variables (defined in the vars parameter). Example </p><div class="fragment"><div class="line"><a class="code" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> prog;</div><div class="line"><span class="keyword">auto</span> x = prog.NewContinuousVariables&lt;2&gt;(<span class="stringliteral">&quot;x&quot;</span>);</div><div class="line"><span class="keyword">auto</span> y = prog.NewContinuousVariables&lt;1&gt;(<span class="stringliteral">&quot;y&quot;</span>);</div><div class="line">Eigen::Vector3d lb(0, 1, 2);</div><div class="line">Eigen::Vector3d ub(1, 2, 3);</div><div class="line"><span class="comment">// Imposes the constraint</span></div><div class="line"><span class="comment">// 0 ≤ x(0) ≤ 1</span></div><div class="line"><span class="comment">// 1 ≤ x(1) ≤ 2</span></div><div class="line"><span class="comment">// 2 ≤ y    ≤ 3</span></div><div class="line">prog.AddBoundingBoxConstraint(lb, ub, {x, y});</div></div><!-- fragment --> 
</div>
</div>
<a id="a353e8201ad1f01a69441e00fce617857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353e8201ad1f01a69441e00fce617857">&#9670;&nbsp;</a></span>AddBoundingBoxConstraint() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a>&gt; AddBoundingBoxConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds bounding box constraints referencing potentially a subset of the decision variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>The lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>The upper bound. </td></tr>
    <tr><td class="paramname">vars</td><td>Will imposes constraint lb(i, j) &lt;= vars(i, j) &lt;= ub(i, j). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly constructed <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html" title="Implements a constraint of the form .">BoundingBoxConstraint</a>. </dd></dl>

</div>
</div>
<a id="a5c41563c9fea14a00330000b42a682fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c41563c9fea14a00330000b42a682fc">&#9670;&nbsp;</a></span>AddBoundingBoxConstraint() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a>&gt; AddBoundingBoxConstraint </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds bounds for a single variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
    <tr><td class="paramname">var</td><td>The decision variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e8c7c4993cbaa6cc2ca30874be835d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8c7c4993cbaa6cc2ca30874be835d7">&#9670;&nbsp;</a></span>AddBoundingBoxConstraint() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a>&gt; AddBoundingBoxConstraint </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the same scalar lower and upper bound to every variable in the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdac15e414036a05505aa356c8011c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdac15e414036a05505aa356c8011c74">&#9670;&nbsp;</a></span>AddBoundingBoxConstraint() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&gt; &amp;&amp; Derived::ColsAtCompileTime == 1, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a>&gt; &gt; AddBoundingBoxConstraint </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the same scalar lower and upper bound to every variable in <code>vars</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>An Eigen Vector type with Variable as the scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c89b0162a81a051cb90dad57a8e0686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c89b0162a81a051cb90dad57a8e0686">&#9670;&nbsp;</a></span>AddBoundingBoxConstraint() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&gt; &amp;&amp; Derived::ColsAtCompileTime != 1, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a>&gt; &gt; AddBoundingBoxConstraint </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the same scalar lower and upper bound to every variable in <code>vars</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>An Eigen::Matrix with Variable as the scalar type. The matrix has unknown number of columns at compile time, or has more than one column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>Lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>Upper bound. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13e9e45a96eb6158f483aa0c81d2c7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e9e45a96eb6158f483aa0c81d2c7ae">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[1/17]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a>&gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a generic constraint to the program. </p>
<p>This should only be used if a more specific type of constraint is not available, as it may require the use of a significantly more expensive solver.</p>
<dl class="section note"><dt>Note</dt><dd>If <code>binding.evaluator()-&gt;num_constraints()</code> == 0, then this constraint is not added into the <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. We return <code>binding</code> directly. </dd></dl>

</div>
</div>
<a id="ae4c9655545a804d2a37a78e4225d8bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c9655545a804d2a37a78e4225d8bde">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[2/17]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a>&gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds one row of constraint lb &lt;= e &lt;= ub where <code>e</code> is a symbolic expression. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if<ol type="1">
<li><code>lb &lt;= e &lt;= ub</code> is a trivial constraint such as 1 &lt;= 2 &lt;= 3.</li>
<li><code>lb &lt;= e &lt;= ub</code> is unsatisfiable such as 1 &lt;= -5 &lt;= 3</li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>A symbolic expression of the decision variables. </td></tr>
    <tr><td class="paramname">lb</td><td>A scalar, the lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>A scalar, the upper bound.</td></tr>
  </table>
  </dd>
</dl>
<p>The resulting constraint may be a <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html" title="Implements a constraint of the form .">BoundingBoxConstraint</a>, <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html" title="Implements a constraint of the form .">LinearConstraint</a>, <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html" title="Implements a constraint of the form .">LinearEqualityConstraint</a>, or <a class="el" href="classdrake_1_1solvers_1_1_expression_constraint.html" title="Impose a generic (potentially nonlinear) constraint represented as a vector of symbolic Expression.">ExpressionConstraint</a>, depending on the arguments. Constraints of the form x == 1 (which could be created as a <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html" title="Implements a constraint of the form .">BoundingBoxConstraint</a> or <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html" title="Implements a constraint of the form .">LinearEqualityConstraint</a>) will be constructed as a <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html" title="Implements a constraint of the form .">LinearEqualityConstraint</a>. </p>

</div>
</div>
<a id="aa9245481a949ae2a1af84809f4d81d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9245481a949ae2a1af84809f4d81d30">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[3/17]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a>&gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8d9bfe34ef20a9f343e518fccc40bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d9bfe34ef20a9f343e518fccc40bd6">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[4/17]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a constraint represented by a symbolic formula to the program. </p>
<p>The input formula <code>f</code> can be of the following forms:</p>
<ol type="1">
<li>e1 &lt;= e2</li>
<li>e1 &gt;= e2</li>
<li>e1 == e2</li>
<li>A conjunction of relational formulas where each conjunct is a relational formula matched by 1, 2, or 3.</li>
</ol>
<p>Note that first two cases might return an object of Binding&lt;BoundingBoxConstraint&gt;, Binding&lt;LinearConstraint&gt;, or Binding&lt;ExpressionConstraint&gt;, depending on <code>f</code>. Also the third case might return an object of Binding&lt;LinearEqualityConstraint&gt; or Binding&lt;ExpressionConstraint&gt;.</p>
<p>It throws an exception if</p><ol type="1">
<li><code>f</code> is not matched with one of the above patterns. Especially, strict inequalities (&lt;, &gt;) are not allowed.</li>
<li><code>f</code> is either a trivial constraint such as "1 &lt;= 2" or an unsatisfiable constraint such as "2 &lt;= 1".</li>
<li>It is not possible to find numerical bounds of <code>e1</code> and <code>e2</code> where <code>f</code> = e1 ≃ e2. We allow <code>e1</code> and <code>e2</code> to be infinite but only if there are no other terms. For example, <code>x &lt;= ∞</code> is allowed. However, <code>x - ∞ &lt;= 0</code> is not allowed because <code>x ↦ ∞</code> introduces <code>nan</code> in the evaluation.</li>
</ol>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>A common use-case of this function is to add a constraint with the element-wise comparison between two Eigen matrices, using <code>A.array() &lt;= B.array()</code>. See the following example.</p>
<div class="fragment"><div class="line"><a class="code" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> prog;</div><div class="line">Eigen::Matrix&lt;double, 2, 2&gt; A = ...;</div><div class="line"><a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a> b = ...;</div><div class="line"><span class="keyword">auto</span> x = prog.NewContinuousVariables(2, <span class="stringliteral">&quot;x&quot;</span>);</div><div class="line">prog.AddConstraint((A * x).array() &lt;= b.array());</div></div><!-- fragment --><p>A formula in <code>formulas</code> can be of the following forms:</p>
<ol type="1">
<li>e1 &lt;= e2</li>
<li>e1 &gt;= e2</li>
<li>e1 == e2</li>
</ol>
<p>It throws an exception if <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae8d9bfe34ef20a9f343e518fccc40bd6" title="Add a constraint represented by a symbolic formula to the program.">AddConstraint(const symbolic::Formula&amp; f)</a> throws an exception for f ∈ <code>formulas</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>Eigen::Matrix or Eigen::Array with Formula as the Scalar. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cf94f38f3b4c3bbbbb89ce5ef5a66c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf94f38f3b4c3bbbbb89ce5ef5a66c6">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[5/17]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt;Derived, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a>&gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a>&gt; &gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>formulas</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c28156f900997a8fb1b0079e30fce6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c28156f900997a8fb1b0079e30fce6d">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[6/17]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto AddConstraint </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; C &gt;&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a generic constraint to the program. </p>
<p>This should only be used if a more specific type of constraint is not available, as it may require the use of a significantly more expensive solver. </p>

</div>
</div>
<a id="a8d26f3d31c9cfba7144b9a0d96aebdd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d26f3d31c9cfba7144b9a0d96aebdd0">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[7/17]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto AddConstraint </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; C &gt;&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a generic constraint to the program. </p>
<p>This should only be used if a more specific type of constraint is not available, as it may require the use of a significantly more expensive solver. </p>

</div>
</div>
<a id="ae677a49f65053b49a623e9b99bceff07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae677a49f65053b49a623e9b99bceff07">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[8/17]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds linear constraints referencing potentially a subset of the decision variables (defined in the vars parameter). </p>

</div>
</div>
<a id="ab0884020fd41a68dfd00265226118685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0884020fd41a68dfd00265226118685">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[9/17]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a>&gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds linear equality constraints referencing potentially a subset of the decision variables. </p>

</div>
</div>
<a id="aadbd3feebe9cd0d5acf67dd4947c7994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadbd3feebe9cd0d5acf67dd4947c7994">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[10/17]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a>&gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds bounding box constraints referencing potentially a subest of the decision variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binding</td><td>Binds a <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html" title="Implements a constraint of the form .">BoundingBoxConstraint</a> with some decision variables, such that binding.evaluator()-&gt;lower_bound()(i) &lt;= binding.variables()(i) &lt;= binding.evaluator().upper_bound()(i) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12c149981283b0e251f55055c5ea4b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c149981283b0e251f55055c5ea4b40">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[11/17]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a>&gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds Lorentz cone constraint referencing potentially a subset of the decision variables. </p>
<p>The linear expression \( z=Ax+b \) is in the Lorentz cone. A vector \( z \in\mathbb{R}^n \) is in the Lorentz cone, if</p>
<p class="formulaDsp">
\[ z_0 \ge \sqrt{z_1^2 + ... + z_{n-1}^2} \]
</p>
 
</div>
</div>
<a id="a8b16dc5af33d4fd617a189a905d02173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b16dc5af33d4fd617a189a905d02173">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[12/17]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a>&gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a rotated Lorentz cone constraint referencing potentially a subset of decision variables. </p>
<p>The linear expression \( z=Ax+b \) is in rotated Lorentz cone. A vector \( z \in\mathbb{R}^n \) is in the rotated Lorentz cone, if</p>
<p class="formulaDsp">
\[ z_0z_1 \ge z_2^2 + ... + z_{n-1}^2 \]
</p>
 
</div>
</div>
<a id="af4ce06116cc0cd7c681258befa944240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ce06116cc0cd7c681258befa944240">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[13/17]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a>&gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear complementarity constraints referencing a subset of the decision variables. </p>

</div>
</div>
<a id="aed941c57116fdf9186a3f0ad7f55b5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed941c57116fdf9186a3f0ad7f55b5a8">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[14/17]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a>&gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a positive semidefinite constraint on a symmetric matrix. </p>

</div>
</div>
<a id="a46c66d4086096ed5206e2168d8a6fe3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c66d4086096ed5206e2168d8a6fe3f">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[15/17]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a>&gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a> &gt;&#160;</td>
          <td class="paramname"><em>con</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>symmetric_matrix_var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a positive semidefinite constraint on a symmetric matrix. </p>

</div>
</div>
<a id="a204ca1afa3b89cbcacb88162fb4007d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204ca1afa3b89cbcacb88162fb4007d7">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[16/17]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a>&gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear matrix inequality constraint to the program. </p>

</div>
</div>
<a id="ad3c8d9a4008399136a7f997d8b5be55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c8d9a4008399136a7f997d8b5be55c">&#9670;&nbsp;</a></span>AddConstraint() <span class="overload">[17/17]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html">ExponentialConeConstraint</a>&gt; AddConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html">ExponentialConeConstraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the exponential cone constraint that z = binding.evaluator()-&gt;A() * binding.variables() + binding.evaluator()-&gt;b() should be in the exponential cone. </p>
<p>Namely {(z₀, z₁, z₂) | z₀ ≥ z₁ * exp(z₂ / z₁), z₁ &gt; 0}. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binding</td><td>The binding of <a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html" title="An exponential cone constraint is a special type of convex cone constraint.">ExponentialConeConstraint</a> and its bound variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac381d539927a444992b0945068cd8a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac381d539927a444992b0945068cd8a8e">&#9670;&nbsp;</a></span>AddCost() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a>&gt; AddCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a generic cost to the optimization program. </p>

</div>
</div>
<a id="a60e141e79d84c40fbc83ea8e3aab7823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e141e79d84c40fbc83ea8e3aab7823">&#9670;&nbsp;</a></span>AddCost() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto AddCost </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost type to the optimization program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The added objective. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which the cost depend. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24f0ccf74cf7be71ca7bc12d81051cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f0ccf74cf7be71ca7bc12d81051cad">&#9670;&nbsp;</a></span>AddCost() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto AddCost </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a generic cost to the optimization program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The added objective. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which the cost depend. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27ef1a1c6bb49d3333ce2c303c0d212e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ef1a1c6bb49d3333ce2c303c0d212e">&#9670;&nbsp;</a></span>AddCost() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;internal::is_cost_functor_candidate&lt;F&gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a>&gt; &gt; AddCost </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost to the optimization program on a list of variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>it should define functions numInputs, numOutputs and eval. Check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65c495a4cd615dee9096bec347989e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c495a4cd615dee9096bec347989e7e">&#9670;&nbsp;</a></span>AddCost() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;internal::is_cost_functor_candidate&lt;F&gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a>&gt; &gt; AddCost </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost to the optimization program on an Eigen::Vector containing decision variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Type that defines functions numInputs, numOutputs and eval. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a650567e1d5d23ca7a67dba50fedc7f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650567e1d5d23ca7a67dba50fedc7f27">&#9670;&nbsp;</a></span>AddCost() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;internal::assert_if_is_constraint&lt;F&gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a>&gt; &gt; AddCost </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vars &amp;&amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically assert if a user inadvertently passes a binding-compatible <a class="el" href="classdrake_1_1solvers_1_1_constraint.html" title="A constraint is a function + lower and upper bounds.">Constraint</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c127750dda0a393e598fef26a63ee27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c127750dda0a393e598fef26a63ee27">&#9670;&nbsp;</a></span>AddCost() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a>&gt; AddCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term of the form c'*x. </p>
<p>Applied to a subset of the variables and pushes onto the linear cost data structure. </p>

</div>
</div>
<a id="a560472e41de2cce737d4622ae22758d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a560472e41de2cce737d4622ae22758d4">&#9670;&nbsp;</a></span>AddCost() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a>&gt; AddCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term of the form 0.5*x'*Q*x + b'x. </p>
<p>Applied to subset of the variables and pushes onto the quadratic cost data structure. </p>

</div>
</div>
<a id="a412994ba25326bd8b1955cb180add256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412994ba25326bd8b1955cb180add256">&#9670;&nbsp;</a></span>AddCost() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a>&gt; AddCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an L2 norm cost |Ax+b|₂ (notice this cost is not quadratic since we don't take the square of the L2 norm). </p>
<p>Refer to AddL2NormCost for more details. </p>

</div>
</div>
<a id="aa8745eb0e81fcbfc031c8e8c57609284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8745eb0e81fcbfc031c8e8c57609284">&#9670;&nbsp;</a></span>AddCost() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a>&gt; AddCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost in the symbolic form. </p>
<p>Note that the constant part of the cost is ignored. So if you set <code>e = x + 2</code>, then only the cost on <code>x</code> is added, the constant term 2 is ignored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The linear or quadratic expression of the cost. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>e</code> is linear or <code>e</code> is quadratic. Otherwise throws a runtime error. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created cost, together with the bound variables. </dd></dl>

</div>
</div>
<a id="af436a548cfc2a209dc21427b328232b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af436a548cfc2a209dc21427b328232b2">&#9670;&nbsp;</a></span>AddDecisionVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddDecisionVariables </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>decision_variables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends new variables to the end of the existing variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">decision_variables</td><td>The newly added decision_variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>decision_variables</code> should not intersect with the existing variables or indeterminates in the optimization program. </dd>
<dd>
Each entry in <code>decision_variables</code> should not be a dummy variable. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the preconditions are not satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d5fc755dd3088b2e2d740965dd7a46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5fc755dd3088b2e2d740965dd7a46f">&#9670;&nbsp;</a></span>AddEqualityConstraintBetweenPolynomials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddEqualityConstraintBetweenPolynomials </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constraining that two polynomials are the same (i.e., they have the same coefficients for each monomial). </p>
<p>This function is often used in sum-of-squares optimization. We will impose the linear equality constraint that the coefficient of a monomial in <code>p1</code> is the same as the coefficient of the same monomial in <code>p2</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>Note that p1's indeterminates should have been registered as indeterminates in this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> object, and p1's coefficients are affine functions of decision variables in this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> object. </td></tr>
    <tr><td class="paramname">p2</td><td>Note that p2's indeterminates should have been registered as indeterminates in this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> object, and p2's coefficients are affine functions of decision variables in this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It calls <code>Reparse</code> to enforce <code>p1</code> and <code>p2</code> to have this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>'s indeterminates. </dd></dl>

</div>
</div>
<a id="a7b08a882bd0f9c823350bf877fe7867f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b08a882bd0f9c823350bf877fe7867f">&#9670;&nbsp;</a></span>AddExponentialConeConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html">ExponentialConeConstraint</a>&gt; AddExponentialConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::SparseMatrix&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an exponential cone constraint, that z = A * vars + b should be in the exponential cone. </p>
<p>Namely {z₀, z₁, z₂ | z₀ ≥ z₁ * exp(z₂ / z₁), z₁ &gt; 0}. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The A matrix in the documentation above. A must have 3 rows. </td></tr>
    <tr><td class="paramname">b</td><td>The b vector in the documentation above. </td></tr>
    <tr><td class="paramname">vars</td><td>The variables bound with this constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a700caef005988a7711e183b439e20a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700caef005988a7711e183b439e20a25">&#9670;&nbsp;</a></span>AddExponentialConeConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html">ExponentialConeConstraint</a>&gt; AddExponentialConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the constraint that z is in the exponential cone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>The expression in the exponential cone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>each entry in <code>z</code> is a linear expression of the decision variables. </dd></dl>

</div>
</div>
<a id="a1d17877e373279d18488f21836285539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d17877e373279d18488f21836285539">&#9670;&nbsp;</a></span>AddIndeterminates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddIndeterminates </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#a60e13290a9b854b4fee070764f978d22">MatrixXIndeterminate</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_indeterminates</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates. </p>
<p>This method appends some indeterminates to the end of the program's old indeterminates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_indeterminates</td><td>The indeterminates to be appended to the program's old indeterminates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>new_indeterminates</code> should not intersect with the program's old indeterminates or decision variables. </dd>
<dd>
Each entry in new_indeterminates should not be dummy. </dd>
<dd>
Each entry in new_indeterminates should be of CONTINUOUS type. </dd></dl>

</div>
</div>
<a id="ac57dac7a44fa56077931a7998f7069e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57dac7a44fa56077931a7998f7069e2">&#9670;&nbsp;</a></span>AddL2NormCost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a>&gt; AddL2NormCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an L2 norm cost |Ax+b|₂ (notice this cost is not quadratic since we don't take the square of the L2 norm). </p>
<dl class="section note"><dt>Note</dt><dd>Currently no solver supports kL2NormCost, and the user will receive an error message if they add <a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html" title="Implements a cost of the form ‖Ax + b‖₂.">L2NormCost</a> and call <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a>. </dd></dl>

</div>
</div>
<a id="a7f5853578a7be1dd5279c7e73cd719e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5853578a7be1dd5279c7e73cd719e6">&#9670;&nbsp;</a></span>AddL2NormCost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a>&gt; AddL2NormCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an L2 norm cost |Ax+b|₂ (notice this cost is not quadratic since we don't take the square of the L2 norm) </p>

</div>
</div>
<a id="a6060c77125050d8c1b479a83d983a569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6060c77125050d8c1b479a83d983a569">&#9670;&nbsp;</a></span>AddL2NormCostUsingConicConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a>&gt;, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a>&gt; &gt; AddL2NormCostUsingConicConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an L2 norm cost min |Ax+b|₂ as a linear cost min s on the slack variable s, together with a Lorentz cone constraint s ≥ |Ax+b|₂ Many conic optimization solvers (Gurobi, MOSEK<a href="/tm.html">™</a>, SCS, etc) natively prefers this form of linear cost + conic constraints. </p>
<p>So if you are going to use one of these conic solvers, then add the L2 norm cost using this function instead of <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac57dac7a44fa56077931a7998f7069e2" title="Adds an L2 norm cost |Ax+b|₂ (notice this cost is not quadratic since we don&#39;t take the square of the...">AddL2NormCost()</a>. </p><dl class="section return"><dt>Returns</dt><dd>(s, linear_cost, lorentz_cone_constraint). <code>s</code> is the slack variable (with variable name string as "slack"), <code>linear_cost</code> is the cost on <code>s</code>, and <code>lorentz_cone_constraint</code> is the constraint s≥|Ax+b|₂ </dd></dl>

</div>
</div>
<a id="aefb8281bc9e90a665dab64afa9749542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb8281bc9e90a665dab64afa9749542">&#9670;&nbsp;</a></span>AddLinearComplementarityConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a>&gt; AddLinearComplementarityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear complementarity constraints referencing a subset of the decision variables. </p>

</div>
</div>
<a id="a8cae2adfde468f154fc70a367e0f0ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cae2adfde468f154fc70a367e0f0ff6">&#9670;&nbsp;</a></span>AddLinearComplementarityConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a>&gt; AddLinearComplementarityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear complementarity constraints referencing a subset of the decision variables. </p>

</div>
</div>
<a id="a7d60c0944a1bf43c50dd26b6dbbc3c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d60c0944a1bf43c50dd26b6dbbc3c1b">&#9670;&nbsp;</a></span>AddLinearConstraint() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds linear constraints referencing potentially a subset of the decision variables (defined in the vars parameter). </p>

</div>
</div>
<a id="ad7fb1e639660acc96ade8aa1d6706c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7fb1e639660acc96ade8aa1d6706c6f">&#9670;&nbsp;</a></span>AddLinearConstraint() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds linear constraints referencing potentially a subset of the decision variables (defined in the vars parameter). </p>

</div>
</div>
<a id="aea3340539f7b90d2f7d6987eea1a7242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3340539f7b90d2f7d6987eea1a7242">&#9670;&nbsp;</a></span>AddLinearConstraint() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds one row of linear constraint referencing potentially a subset of the decision variables (defined in the vars parameter). </p>
<p>lb &lt;= a*vars &lt;= ub </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A row vector. </td></tr>
    <tr><td class="paramname">lb</td><td>A scalar, the lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>A scalar, the upper bound. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which to impose the linear constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2358db7c4dc6aa23411618b1d21d9a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2358db7c4dc6aa23411618b1d21d9a07">&#9670;&nbsp;</a></span>AddLinearConstraint() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds one row of linear constraint referencing potentially a subset of the decision variables (defined in the vars parameter). </p>
<p>lb &lt;= a*vars &lt;= ub </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A row vector. </td></tr>
    <tr><td class="paramname">lb</td><td>A scalar, the lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>A scalar, the upper bound. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which to impose the linear constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0b35ad9e0036fc52b27fc98c555a091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b35ad9e0036fc52b27fc98c555a091">&#9670;&nbsp;</a></span>AddLinearConstraint() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds one row of linear constraint lb &lt;= e &lt;= ub where <code>e</code> is a symbolic expression. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if<ol type="1">
<li><code>e</code> is a non-linear expression.</li>
<li><code>lb &lt;= e &lt;= ub</code> is a trivial constraint such as 1 &lt;= 2 &lt;= 3.</li>
<li><code>lb &lt;= e &lt;= ub</code> is unsatisfiable such as 1 &lt;= -5 &lt;= 3</li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>A linear symbolic expression in the form of <code>c0 + c1 * v1 + ... + cn * vn</code> where <code>c_i</code> is a constant and @v_i is a variable. </td></tr>
    <tr><td class="paramname">lb</td><td>A scalar, the lower bound. </td></tr>
    <tr><td class="paramname">ub</td><td>A scalar, the upper bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a762c48bc981fb8d892fea63c4e97a326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762c48bc981fb8d892fea63c4e97a326">&#9670;&nbsp;</a></span>AddLinearConstraint() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds linear constraints represented by symbolic expressions to the program. </p>
<p>It throws if @v includes a non-linear expression or <code>lb &lt;= v &lt;= ub</code> includes trivial/unsatisfiable constraints. </p>

</div>
</div>
<a id="ade4bcd993d4cefb458564896160eebd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4bcd993d4cefb458564896160eebd2">&#9670;&nbsp;</a></span>AddLinearConstraint() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a linear constraint represented by a symbolic formula to the program. </p>
<p>The input formula <code>f</code> can be of the following forms:</p>
<ol type="1">
<li>e1 &lt;= e2</li>
<li>e1 &gt;= e2</li>
<li>e1 == e2</li>
<li>A conjunction of relational formulas where each conjunct is a relational formula matched by 1, 2, or 3.</li>
</ol>
<p>Note that first two cases might return an object of Binding&lt;BoundingBoxConstraint&gt; depending on <code>f</code>. Also the third case returns an object of Binding&lt;LinearEqualityConstraint&gt;.</p>
<p>It throws an exception if</p><ol type="1">
<li><code>f</code> is not matched with one of the above patterns. Especially, strict inequalities (&lt;, &gt;) are not allowed.</li>
<li><code>f</code> includes a non-linear expression.</li>
<li><code>f</code> is either a trivial constraint such as "1 &lt;= 2" or an unsatisfiable constraint such as "2 &lt;= 1".</li>
<li>It is not possible to find numerical bounds of <code>e1</code> and <code>e2</code> where <code>f</code> = e1 ≃ e2. We allow <code>e1</code> and <code>e2</code> to be infinite but only if there are no other terms. For example, <code>x &lt;= ∞</code> is allowed. However, <code>x - ∞ &lt;= 0</code> is not allowed because <code>x ↦ ∞</code> introduces <code>nan</code> in the evaluation. </li>
</ol>

</div>
</div>
<a id="a3db87ec5cd8f61d6ab5d689d181cd587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db87ec5cd8f61d6ab5d689d181cd587">&#9670;&nbsp;</a></span>AddLinearConstraint() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; AddLinearConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a>, Eigen::Dynamic, Eigen::Dynamic &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>formulas</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a linear constraint represented by an Eigen::Array&lt;symbolic::Formula&gt; to the program. </p>
<p>A common use-case of this function is to add a linear constraint with the element-wise comparison between two Eigen matrices, using <code>A.array() &lt;= B.array()</code>. See the following example.</p>
<div class="fragment"><div class="line"><a class="code" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> prog;</div><div class="line">Eigen::Matrix&lt;double, 2, 2&gt; A;</div><div class="line"><span class="keyword">auto</span> x = prog.NewContinuousVariables(2, <span class="stringliteral">&quot;x&quot;</span>);</div><div class="line"><a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a> b;</div><div class="line">... <span class="comment">// set up A and b</span></div><div class="line">prog.AddLinearConstraint((A * x).array() &lt;= b.array());</div></div><!-- fragment --><p>A formula in <code>formulas</code> can be of the following forms:</p>
<ol type="1">
<li>e1 &lt;= e2</li>
<li>e1 &gt;= e2</li>
<li>e1 == e2</li>
</ol>
<p>It throws an exception if <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ade4bcd993d4cefb458564896160eebd2" title="Add a linear constraint represented by a symbolic formula to the program.">AddLinearConstraint(const symbolic::Formula&amp; f)</a> throws an exception for f ∈ <code>formulas</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>An Eigen Array type of Formula. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a6ebbdfd077e058cad0ac1bac9ffee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6ebbdfd077e058cad0ac1bac9ffee7">&#9670;&nbsp;</a></span>AddLinearCost() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a>&gt; AddLinearCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear cost term of the form a'*x + b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>A linear symbolic expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>e is a linear expression a'*x + b, where each entry of x is a decision variable in the mathematical program. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added linear constraint, together with the bound variables. </dd></dl>

</div>
</div>
<a id="ab5d909ab79bbc45767206daaa8d145c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d909ab79bbc45767206daaa8d145c8">&#9670;&nbsp;</a></span>AddLinearCost() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a>&gt; AddLinearCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear cost term of the form a'*x + b. </p>
<p>Applied to a subset of the variables and pushes onto the linear cost data structure. </p>

</div>
</div>
<a id="aa142d3f7b3e899ab26d4a42488f30ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa142d3f7b3e899ab26d4a42488f30ea4">&#9670;&nbsp;</a></span>AddLinearCost() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a>&gt; AddLinearCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear cost term of the form a'*x + b. </p>
<p>Applied to a subset of the variables and pushes onto the linear cost data structure. </p>

</div>
</div>
<a id="a06dbd6c1bf0971fc28366df95ee1bca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06dbd6c1bf0971fc28366df95ee1bca2">&#9670;&nbsp;</a></span>AddLinearCost() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a>&gt; AddLinearCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">VarType</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear cost term of the form a'*x. </p>
<p>Applied to a subset of the variables and pushes onto the linear cost data structure. </p>

</div>
</div>
<a id="ac623a8e305d300afa1d9f63bf3f266b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac623a8e305d300afa1d9f63bf3f266b8">&#9670;&nbsp;</a></span>AddLinearEqualityConstraint() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a>&gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds one row of linear constraint e = b where <code>e</code> is a symbolic expression. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if<ol type="1">
<li><code>e</code> is a non-linear expression.</li>
<li><code>e</code> is a constant.</li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>A linear symbolic expression in the form of <code>c0 + c1 * x1 + ... + cn * xn</code> where <code>c_i</code> is a constant and @x_i is a variable. </td></tr>
    <tr><td class="paramname">b</td><td>A scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added linear equality constraint, together with the bound variable. </dd></dl>

</div>
</div>
<a id="a4c445bb3c911493f437f119372da5221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c445bb3c911493f437f119372da5221">&#9670;&nbsp;</a></span>AddLinearEqualityConstraint() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a>&gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear equality constraint represented by a symbolic formula to the program. </p>
<p>The input formula <code>f</code> is either an equality formula (<code>e1 == e2</code>) or a conjunction of equality formulas.</p>
<p>It throws an exception if</p>
<ol type="1">
<li><code>f</code> is neither an equality formula nor a conjunction of equalities.</li>
<li><code>f</code> includes a non-linear expression. </li>
</ol>

</div>
</div>
<a id="a9164110d10cac0284a50a91b8308bae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9164110d10cac0284a50a91b8308bae8">&#9670;&nbsp;</a></span>AddLinearEqualityConstraint() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__vector__expression__double__pair.html">is_eigen_vector_expression_double_pair</a>&lt;DerivedV, DerivedB&gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a>&gt; &gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds linear equality constraints \( v = b \), where <code>v(i)</code> is a symbolic linear expression. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if<ol type="1">
<li><code>v(i)</code> is a non-linear expression.</li>
<li><code>v(i)</code> is a constant.</li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>An Eigen Matrix type of Expression. A column vector. </td></tr>
    <tr><td class="paramname">DerivedB</td><td>An Eigen Matrix type of double. A column vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>v(i) is a linear symbolic expression in the form of <code> c0 + c1 * x1 + ... + cn * xn </code> where ci is a constant and @xi is a variable. </td></tr>
    <tr><td class="paramname">b</td><td>A vector of doubles. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added linear equality constraint, together with the bound variables. </dd></dl>

</div>
</div>
<a id="a7c3361c9cd54767f6b0441f3343eec35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3361c9cd54767f6b0441f3343eec35">&#9670;&nbsp;</a></span>AddLinearEqualityConstraint() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__nonvector__expression__double__pair.html">is_eigen_nonvector_expression_double_pair</a>&lt;DerivedV, DerivedB&gt;::value, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a>&gt; &gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lower_triangle</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear equality constraint for a matrix of linear expression <code>V</code>, such that V(i, j) = B(i, j). </p>
<p>If V is a symmetric matrix, then the user may only want to constrain the lower triangular part of V. This function is meant to provide convenience to the user, it incurs additional copy and memory allocation. For faster speed, add each column of the matrix equality in a for loop. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>An Eigen Matrix type of Expression. The number of columns at compile time should not be 1. </td></tr>
    <tr><td class="paramname">DerivedB</td><td>An Eigen Matrix type of double. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>An Eigen Matrix of symbolic expressions. V(i, j) should be a linear expression. </td></tr>
    <tr><td class="paramname">B</td><td>An Eigen Matrix of doubles. </td></tr>
    <tr><td class="paramname">lower_triangle</td><td>If true, then only the lower triangular part of <code>V</code> is constrained, otherwise the whole matrix V is constrained. <br />
 <em>Default:</em> is false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added linear equality constraint, together with the bound variables. </dd></dl>

</div>
</div>
<a id="aa4aec5ef573ea5fb0667475c7e5a1914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4aec5ef573ea5fb0667475c7e5a1914">&#9670;&nbsp;</a></span>AddLinearEqualityConstraint() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a>&gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Aeq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>beq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AddLinearEqualityConstraint. </p>
<p>Adds linear equality constraints referencing potentially a subset of the decision variables.</p>
<p>Example: to add two equality constraints which only depend on two of the elements of x, you could use </p><div class="fragment"><div class="line"><span class="keyword">auto</span> x = prog.NewContinuousVariables(6,<span class="stringliteral">&quot;myvar&quot;</span>);</div><div class="line">Eigen::Matrix2d Aeq;</div><div class="line">Aeq &lt;&lt; -1, 2,</div><div class="line">        1, 1;</div><div class="line"><a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a> beq(1, 3);</div><div class="line">prog.AddLinearEqualityConstraint(Aeq, beq, {x.segment&lt;1&gt;(2),</div><div class="line">                                 x.segment&lt;1&gt;(5)});</div></div><!-- fragment --><p> The code above imposes constraints </p><p class="formulaDsp">
\[-x(2) + 2x(5) = 1 \]
</p>
 <p class="formulaDsp">
\[ x(2) + x(5) = 3 \]
</p>
 
</div>
</div>
<a id="a8874425f3b864d09e7a05f6ca2c97805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8874425f3b864d09e7a05f6ca2c97805">&#9670;&nbsp;</a></span>AddLinearEqualityConstraint() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a>&gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Aeq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>beq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AddLinearEqualityConstraint. </p>
<p>Adds linear equality constraints referencing potentially a subset of the decision variables.</p>
<p>Example: to add two equality constraints which only depend on two of the elements of x, you could use </p><div class="fragment"><div class="line"><span class="keyword">auto</span> x = prog.NewContinuousVariables(6,<span class="stringliteral">&quot;myvar&quot;</span>);</div><div class="line">Eigen::Matrix2d Aeq;</div><div class="line">Aeq &lt;&lt; -1, 2,</div><div class="line">        1, 1;</div><div class="line"><a class="code" href="namespacedrake_1_1systems_1_1analysis_1_1test.html#a322dbcada3667894a629fe3f1a476f2a">Eigen::Vector2d</a> beq(1, 3);</div><div class="line"><span class="comment">// Imposes constraint</span></div><div class="line"><span class="comment">// -x(0) + 2x(1) = 1</span></div><div class="line"><span class="comment">//  x(0) +  x(1) = 3</span></div><div class="line">prog.AddLinearEqualityConstraint(Aeq, beq, x.head&lt;2&gt;());</div></div><!-- fragment --> 
</div>
</div>
<a id="adba470b9c71439a795a0d647d171f71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba470b9c71439a795a0d647d171f71b">&#9670;&nbsp;</a></span>AddLinearEqualityConstraint() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a>&gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds one row of linear equality constraint referencing potentially a subset of decision variables. </p>
<p class="formulaDsp">
\[ ax = beq \]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A row vector. </td></tr>
    <tr><td class="paramname">beq</td><td>A scalar. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which the constraint is imposed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ca8d2a20e1ba47d1c658613569eb447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca8d2a20e1ba47d1c658613569eb447">&#9670;&nbsp;</a></span>AddLinearEqualityConstraint() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a>&gt; AddLinearEqualityConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds one row of linear equality constraint referencing potentially a subset of decision variables. </p>
<p class="formulaDsp">
\[ ax = beq \]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A row vector. </td></tr>
    <tr><td class="paramname">beq</td><td>A scalar. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which the constraint is imposed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3cca1ac259f166dc97725ed23b7e5739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cca1ac259f166dc97725ed23b7e5739">&#9670;&nbsp;</a></span>AddLinearMatrixInequalityConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a>&gt; AddLinearMatrixInequalityConstraint </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Ref&lt; const Eigen::MatrixXd &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear matrix inequality constraint to the program. </p>

</div>
</div>
<a id="a4f96e8fb29b956fde965719ae1bbb0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f96e8fb29b956fde965719ae1bbb0cb">&#9670;&nbsp;</a></span>AddLinearMatrixInequalityConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a>&gt; AddLinearMatrixInequalityConstraint </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Ref&lt; const Eigen::MatrixXd &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear matrix inequality constraint to the program. </p>

</div>
</div>
<a id="a9684f622903a0e38d1bf1ef8af6fcd51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9684f622903a0e38d1bf1ef8af6fcd51">&#9670;&nbsp;</a></span>AddLorentzConeConstraint() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a>&gt; AddLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a>&#160;</td>
          <td class="paramname"><em>eval_type</em> = <code><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds Lorentz cone constraint referencing potentially a subset of the decision variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>An Eigen::Vector of <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>. Constraining that <p class="formulaDsp">
\[ v_0 \ge \sqrt{v_1^2 + ... + v_{n-1}^2} \]
</p>
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly constructed Lorentz cone constraint with the bounded variables. For example, to add the Lorentz cone constraint <pre class="fragment">x+1 &gt;= sqrt(y² + 2y + x² + 5),
     = sqrt((y+1)²+x²+2²)
</pre> The user could call <div class="fragment"><div class="line">Vector4&lt;symbolic::Expression&gt; v(x+1, y+1, x, 2.);</div><div class="line">prog.AddLorentzConeConstraint(v);</div></div><!-- fragment --> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eval_type</td><td>The evaluation type when evaluating the lorentz cone constraint in generic optimization. Refer to <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4" title="We provide three possible Eval functions to represent the Lorentz cone constraint z₀ ≥ sqrt(z₁² + ....">LorentzConeConstraint::EvalType</a> for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02d2492e6743d60dfe4060377e4a5503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d2492e6743d60dfe4060377e4a5503">&#9670;&nbsp;</a></span>AddLorentzConeConstraint() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a>&gt; AddLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>linear_expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>quadratic_expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a>&#160;</td>
          <td class="paramname"><em>eval_type</em> = <code><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds Lorentz cone constraint on the linear expression v1 and quadratic expression v2, such that v1 &gt;= sqrt(v2) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linear_expression</td><td>The linear expression v1. </td></tr>
    <tr><td class="paramname">quadratic_expression</td><td>The quadratic expression v2. </td></tr>
    <tr><td class="paramname">tol</td><td>The tolerance to determine if the matrix in v2 is positive semidefinite or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>DecomposePositiveQuadraticForm for more explanation. <br />
 <em>Default:</em> is 0. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eval_type</td><td>The evaluation type when evaluating the lorentz cone constraint in generic optimization. Refer to <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4" title="We provide three possible Eval functions to represent the Lorentz cone constraint z₀ ≥ sqrt(z₁² + ....">LorentzConeConstraint::EvalType</a> for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">binding</td><td>The newly added Lorentz cone constraint, together with the bound variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ol type="1">
<li><code>v1</code> is a linear expression, in the form of c'*x + d.</li>
<li><code>v2</code> is a quadratic expression, in the form of <pre>
         x'*Q*x + b'x + a
   </pre> Also the quadratic expression has to be convex, namely Q is a positive semidefinite matrix, and the quadratic expression needs to be non-negative for any x. </li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the preconditions are not satisfied.</td></tr>
  </table>
  </dd>
</dl>
<p>Notice this constraint is equivalent to the vector [z;y] is within a Lorentz cone, where </p><pre>
 z = v1
 y = R * x + d
</pre><p> while (R, d) satisfies y'*y = x'*Q*x + b'*x + a For example, to add the Lorentz cone constraint </p><pre class="fragment">x+1 &gt;= sqrt(y² + 2y + x² + 4),
</pre><p> the user could call </p><div class="fragment"><div class="line">prog.AddLorentzConeConstraint(x+1, <a class="code" href="namespacedrake.html#a95cb9413bd3124511459d856f6eef5f3">pow</a>(y, 2) + 2 * y + <a class="code" href="namespacedrake.html#a95cb9413bd3124511459d856f6eef5f3">pow</a>(x, 2) + 4);</div></div><!-- fragment --> 
</div>
</div>
<a id="a848e948c48c906a76d249a0606464868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848e948c48c906a76d249a0606464868">&#9670;&nbsp;</a></span>AddLorentzConeConstraint() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a>&gt; AddLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a>&#160;</td>
          <td class="paramname"><em>eval_type</em> = <code><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds Lorentz cone constraint referencing potentially a subset of the decision variables (defined in the vars parameter). </p>
<p>The linear expression \( z=Ax+b \) is in the Lorentz cone. A vector \( z \in\mathbb{R}^n \) is in the Lorentz cone, if</p>
<p class="formulaDsp">
\[ z_0 \ge \sqrt{z_1^2 + ... + z_{n-1}^2} \]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A \(\mathbb{R}^{n\times m}\) matrix, whose number of columns equals to the size of the decision variables. </td></tr>
    <tr><td class="paramname">b</td><td>A \(\mathbb{R}^n\) vector, whose number of rows equals to the size of the decision variables. </td></tr>
    <tr><td class="paramname">vars</td><td>The list of \( m \) decision variables. </td></tr>
    <tr><td class="paramname">eval_type</td><td>The evaluation type when evaluating the lorentz cone constraint in generic optimization. Refer to <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4" title="We provide three possible Eval functions to represent the Lorentz cone constraint z₀ ≥ sqrt(z₁² + ....">LorentzConeConstraint::EvalType</a> for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added Lorentz cone constraint. </dd></dl>

</div>
</div>
<a id="adb2e0b7c0a939513aba56fc147696a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2e0b7c0a939513aba56fc147696a8a">&#9670;&nbsp;</a></span>AddLorentzConeConstraint() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a>&gt; AddLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a>&#160;</td>
          <td class="paramname"><em>eval_type</em> = <code><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds Lorentz cone constraint referencing potentially a subset of the decision variables (defined in the vars parameter). </p>
<p>The linear expression \( z=Ax+b \) is in the Lorentz cone. A vector \( z \in\mathbb{R}^n \) is in the Lorentz cone, if</p>
<p class="formulaDsp">
\[ z_0 \ge \sqrt{z_1^2 + ... + z_{n-1}^2} \]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A \(\mathbb{R}^{n\times m}\) matrix, whose number of columns equals to the size of the decision variables. </td></tr>
    <tr><td class="paramname">b</td><td>A \(\mathbb{R}^n\) vector, whose number of rows equals to the size of the decision variables. </td></tr>
    <tr><td class="paramname">vars</td><td>The Eigen vector of \( m \) decision variables. </td></tr>
    <tr><td class="paramname">eval_type</td><td>The evaluation type when evaluating the lorentz cone constraint in generic optimization. Refer to <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4" title="We provide three possible Eval functions to represent the Lorentz cone constraint z₀ ≥ sqrt(z₁² + ....">LorentzConeConstraint::EvalType</a> for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added Lorentz cone constraint.</dd></dl>
<p>For example, to add the Lorentz cone constraint </p><pre class="fragment">x+1 &gt;= sqrt(y² + 2y + x² + 5) = sqrt((y+1)² + x² + 2²),
</pre><p> the user could call </p><div class="fragment"><div class="line">Eigen::Matrix&lt;double, 4, 2&gt; A;</div><div class="line">Eigen::Vector4d b;</div><div class="line">A &lt;&lt; 1, 0, 0, 1, 1, 0, 0, 0;</div><div class="line">b &lt;&lt; 1, 1, 0, 2;</div><div class="line"><span class="comment">// A * [x;y] + b = [x+1; y+1; x; 2]</span></div><div class="line">prog.AddLorentzConeConstraint(A, b, Vector2&lt;symbolic::Variable&gt;(x, y));</div></div><!-- fragment --> 
</div>
</div>
<a id="a6d2d933f65af2e81e40e08564c929529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d2d933f65af2e81e40e08564c929529">&#9670;&nbsp;</a></span>AddLorentzConeConstraint() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a>&gt; AddLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a>&#160;</td>
          <td class="paramname"><em>eval_type</em> = <code><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imposes that a vector \( x\in\mathbb{R}^m \) lies in Lorentz cone. </p>
<p>Namely </p><p class="formulaDsp">
\[ x_0 \ge \sqrt{x_1^2 + .. + x_{m-1}^2} \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vars</td><td>The stacked column of vars should lie within the Lorentz cone. </td></tr>
    <tr><td class="paramname">eval_type</td><td>The evaluation type when evaluating the lorentz cone constraint in generic optimization. Refer to <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4" title="We provide three possible Eval functions to represent the Lorentz cone constraint z₀ ≥ sqrt(z₁² + ....">LorentzConeConstraint::EvalType</a> for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added Lorentz cone constraint. </dd></dl>

</div>
</div>
<a id="a8a9082746a4852ea5087b2a6e3cc57ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9082746a4852ea5087b2a6e3cc57ee">&#9670;&nbsp;</a></span>AddLorentzConeConstraint() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a>&gt; AddLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; <a class="el" href="namespacedrake_1_1solvers.html#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a>&lt; rows &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4">LorentzConeConstraint::EvalType</a>&#160;</td>
          <td class="paramname"><em>eval_type</em> = <code><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4a6d5ca2cdc67e830f77b77110a22b23a1">LorentzConeConstraint::EvalType::kConvexSmooth</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imposes that a vector \( x\in\mathbb{R}^m \) lies in Lorentz cone. </p>
<p>Namely </p><p class="formulaDsp">
\[ x_0 \ge \sqrt{x_1^2 + .. + x_{m-1}^2} \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vars</td><td>The stacked column of vars should lie within the Lorentz cone. </td></tr>
    <tr><td class="paramname">eval_type</td><td>The evaluation type when evaluating the lorentz cone constraint in generic optimization. Refer to <a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#a7e69b5efb34e150cd2b2422e1e943da4" title="We provide three possible Eval functions to represent the Lorentz cone constraint z₀ ≥ sqrt(z₁² + ....">LorentzConeConstraint::EvalType</a> for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added Lorentz cone constraint. </dd></dl>

</div>
</div>
<a id="a16968bf237a668a8777916fe61050848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16968bf237a668a8777916fe61050848">&#9670;&nbsp;</a></span>AddMaximizeGeometricMeanCost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a>&gt; AddMaximizeGeometricMeanCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An overloaded version of <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#maximize_geometric_mean">maximize_geometric_mean</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>cost The added cost (note that since <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> only minimizes the cost, the returned cost evaluates to -c * power(∏ᵢx(i), 1/n). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>A.rows() == b.rows(), A.rows() &gt;= 2. </dd></dl>

</div>
</div>
<a id="a03ebe4b7fbb443836fa18d5645f656a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ebe4b7fbb443836fa18d5645f656a3">&#9670;&nbsp;</a></span>AddMaximizeGeometricMeanCost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a>&gt; AddMaximizeGeometricMeanCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An overloaded version of <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#maximize_geometric_mean">maximize_geometric_mean</a>. </p>
<p>We add the cost to maximize the geometric mean of x, i.e., c*power(∏ᵢx(i), 1/n). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The positive coefficient of the geometric mean cost, <br />
 <em>Default:</em> is 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cost The added cost (note that since <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> only minimizes the cost, the returned cost evaluates to -c * power(∏ᵢx(i), 1/n). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>x.rows() &gt;= 2. </dd>
<dd>
c &gt; 0. </dd></dl>

</div>
</div>
<a id="a8dfe4319252cfe4f6b290986b504c404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dfe4319252cfe4f6b290986b504c404">&#9670;&nbsp;</a></span>AddMaximizeLogDeterminantCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a>&gt;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&gt;, <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt; &gt; AddMaximizeLogDeterminantCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the cost to maximize the log determinant of symmetric matrix X. </p>
<p>log(det(X)) is a concave function of X, so we can maximize it through convex optimization. In order to do that, we introduce slack variables t, and a lower triangular matrix Z, with the constraints </p><pre class="fragment">⌈X         Z⌉ is positive semidifinite.
⌊Zᵀ  diag(Z)⌋

log(Z(i, i)) &gt;= t(i)
</pre><p>and we will minimize -∑ᵢt(i). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>A symmetric positive semidefinite matrix X, whose log(det(X)) will be maximized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(cost, t, Z) cost is -∑ᵢt(i), we also return the newly created slack variables t and the lower triangular matrix Z. Note that Z is not a matrix of <a class="el" href="classdrake_1_1symbolic_1_1_variable.html" title="Represents a symbolic variable.">symbolic::Variable</a> but <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>, because the upper-diagonal entries of Z are not variable, but expression 0. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>X is a symmetric matrix. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>We implicitly require that <code>X</code> being positive semidefinite (psd) (as X is the diagonal entry of the big psd matrix above). If your <code>X</code> is not necessarily psd, then don't call this function. </dd>
<dd>
The constraint log(Z(i, i)) &gt;= t(i) is imposed as an exponential cone constraint. Please make sure your have a solver that supports exponential cone constraint (currently SCS does). Refer to <a href="https://docs.mosek.com/modeling-cookbook/sdo.html#log-determinant">https://docs.mosek.com/modeling-cookbook/sdo.html#log-determinant</a> for more details. </dd></dl>

</div>
</div>
<a id="aa3c4d6b9048536662622e58584c3a8df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c4d6b9048536662622e58584c3a8df">&#9670;&nbsp;</a></span>AddMaximizeLogDeterminantSymmetricMatrixCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a>&gt;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&gt;, <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt; &gt; AddMaximizeLogDeterminantSymmetricMatrixCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the cost to maximize the log determinant of symmetric matrix X. </p>
<p>log(det(X)) is a concave function of X, so we can maximize it through convex optimization. In order to do that, we introduce slack variables t, and a lower triangular matrix Z, with the constraints </p><pre class="fragment">⌈X         Z⌉ is positive semidifinite.
⌊Zᵀ  diag(Z)⌋

log(Z(i, i)) &gt;= t(i)
</pre><p>and we will minimize -∑ᵢt(i). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>A symmetric positive semidefinite matrix X, whose log(det(X)) will be maximized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(cost, t, Z) cost is -∑ᵢt(i), we also return the newly created slack variables t and the lower triangular matrix Z. Note that Z is not a matrix of <a class="el" href="classdrake_1_1symbolic_1_1_variable.html" title="Represents a symbolic variable.">symbolic::Variable</a> but <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>, because the upper-diagonal entries of Z are not variable, but expression 0. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>X is a symmetric matrix. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>We implicitly require that <code>X</code> being positive semidefinite (psd) (as X is the diagonal entry of the big psd matrix above). If your <code>X</code> is not necessarily psd, then don't call this function. </dd>
<dd>
The constraint log(Z(i, i)) &gt;= t(i) is imposed as an exponential cone constraint. Please make sure your have a solver that supports exponential cone constraint (currently SCS does). Refer to <a href="https://docs.mosek.com/modeling-cookbook/sdo.html#log-determinant">https://docs.mosek.com/modeling-cookbook/sdo.html#log-determinant</a> for more details.(Deprecated.) </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>AddMaximizeLogDeterminantSymmetricMatrixCost has been  renamed to AddMaximizeLogDeterminantCost. <br />
 This will be removed from Drake on or after 2022-05-01.</dd></dl>

</div>
</div>
<a id="a85baa493f8445101d0367606e3bf5f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85baa493f8445101d0367606e3bf5f32">&#9670;&nbsp;</a></span>AddPolynomialConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a>&gt; AddPolynomialConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="namespacedrake.html#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>polynomials</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">Polynomiald::VarType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a polynomial constraint to the program referencing a subset of the decision variables (defined in the vars parameter). </p>

</div>
</div>
<a id="a4784f36d627f416827aded75f1936808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4784f36d627f416827aded75f1936808">&#9670;&nbsp;</a></span>AddPolynomialConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a>&gt; AddPolynomialConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="namespacedrake.html#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>polynomials</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">Polynomiald::VarType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a polynomial constraint to the program referencing a subset of the decision variables (defined in the vars parameter). </p>

</div>
</div>
<a id="a14edfab282bd8d3d03bf38bb87a5fe51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14edfab282bd8d3d03bf38bb87a5fe51">&#9670;&nbsp;</a></span>AddPolynomialCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_polynomial_cost.html">PolynomialCost</a>&gt; AddPolynomialCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term in the polynomial form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>A symbolic expression in the polynomial form. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created cost and the bound variables. </dd></dl>

</div>
</div>
<a id="a5ef1689f39c06dc1a2520276fcd47c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef1689f39c06dc1a2520276fcd47c5b">&#9670;&nbsp;</a></span>AddPositiveDiagonallyDominantMatrixConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt; AddPositiveDiagonallyDominantMatrixConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the constraint that a symmetric matrix is diagonally dominant with non-negative diagonal entries. </p>
<p>A symmetric matrix X is diagonally dominant with non-negative diagonal entries if X(i, i) &gt;= ∑ⱼ |X(i, j)| ∀ j ≠ i namely in each row, the diagonal entry is larger than the sum of the absolute values of all other entries in the same row. A matrix being diagonally dominant with non-negative diagonals is a sufficient (but not necessary) condition of a matrix being positive semidefinite. Internally we will create a matrix Y as slack variables, such that Y(i, j) represents the absolute value |X(i, j)| ∀ j ≠ i. The diagonal entries Y(i, i) = X(i, i) The users can refer to "DSOS and SDSOS Optimization: More Tractable
Alternatives to Sum of Squares and Semidefinite Optimization" by Amir Ali Ahmadi and Anirudha Majumdar, with arXiv link <a href="https://arxiv.org/abs/1706.02586">https://arxiv.org/abs/1706.02586</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The matrix X. We will use 0.5(X+Xᵀ) as the "symmetric version" of X. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Y The slack variable. Y(i, j) represents |X(i, j)| ∀ j ≠ i, with the constraint Y(i, j) &gt;= X(i, j) and Y(i, j) &gt;= -X(i, j). Y is a symmetric matrix. The diagonal entries Y(i, i) = X(i, i) </dd></dl>

</div>
</div>
<a id="a4d8e0acb745cee5f6b8bb25248511406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8e0acb745cee5f6b8bb25248511406">&#9670;&nbsp;</a></span>AddPositiveSemidefiniteConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a>&gt; AddPositiveSemidefiniteConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>symmetric_matrix_var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a positive semidefinite constraint on a symmetric matrix. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>in Debug mode if <code>symmetric_matrix_var</code> is not symmetric. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symmetric_matrix_var</td><td>A symmetric MatrixDecisionVariable object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f8ae66a7dc32a53fad92f348f127439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8ae66a7dc32a53fad92f348f127439">&#9670;&nbsp;</a></span>AddPositiveSemidefiniteConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a>&gt; AddPositiveSemidefiniteConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a positive semidefinite constraint on a symmetric matrix of symbolic expressions <code>e</code>. </p>
<p>We create a new symmetric matrix of variables M being positive semidefinite, with the linear equality constraint e == M. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Imposes constraint "e is positive semidefinite". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>{1. e is symmetric.<ol type="1">
<li>e(i, j) is linear for all i, j } </li>
</ol>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added positive semidefinite constraint, with the bound variable M that are also newly added.</dd></dl>
<p>For example, to add a constraint that </p><pre class="fragment">⌈x + 1  2x + 3 x+y⌉
|2x+ 3       2   0| is positive semidefinite
⌊x + y       0   x⌋
</pre><p> The user could call </p><div class="fragment"><div class="line">Matrix3&lt;symbolic::Expression&gt; e</div><div class="line">e &lt;&lt; x+1, 2*x+3, x+y,</div><div class="line">     2*x+3,   2,   0,</div><div class="line">     x+y,     0,   x;</div><div class="line">prog.AddPositiveSemidefiniteConstraint(e);</div></div><!-- fragment --> 
</div>
</div>
<a id="ae9107a03b1a967f0efe1a7ad0d01dedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9107a03b1a967f0efe1a7ad0d01dedd">&#9670;&nbsp;</a></span>AddQuadraticCost() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a>&gt; AddQuadraticCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>is_convex</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a quadratic cost term of the form 0.5*x'*Q*x + b'*x + c. </p>
<p>Notice that in the optimization program, the constant term <code>c</code> in the cost is ignored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>A quadratic symbolic expression. </td></tr>
    <tr><td class="paramname">is_convex</td><td>Whether the cost is already known to be convex. If is_convex=nullopt (the default), then Drake will determine if <code>e</code> is a convex quadratic cost or not. To improve the computation speed, the user can set is_convex if the user knows whether the cost is convex or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the expression is not quadratic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added cost together with the bound variables. </dd></dl>

</div>
</div>
<a id="abdcdb1ab2b9211c869331a8b0af3e22c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcdb1ab2b9211c869331a8b0af3e22c">&#9670;&nbsp;</a></span>AddQuadraticCost() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a>&gt; AddQuadraticCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>is_convex</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term of the form 0.5*x'*Q*x + b'x. </p>
<p>Applied to subset of the variables. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is_convex</td><td>Whether the cost is already known to be convex. If is_convex=nullopt (the default), then Drake will determine if this is a convex quadratic cost or not (by checking if matrix Q is positive semidefinite or not). To improve the computation speed, the user can set is_convex if the user knows whether the cost is convex or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab631304ac72255c66ae90542de6542e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab631304ac72255c66ae90542de6542e0">&#9670;&nbsp;</a></span>AddQuadraticCost() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a>&gt; AddQuadraticCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>is_convex</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term of the form 0.5*x'*Q*x + b'x + c Applied to subset of the variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is_convex</td><td>Whether the cost is already known to be convex. If is_convex=nullopt (the default), then Drake will determine if this is a convex quadratic cost or not. To improve the computation speed, the user can set is_convex if the user knows whether the cost is convex or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ee00f39c8fbbaab930492dec3e05ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee00f39c8fbbaab930492dec3e05ffe">&#9670;&nbsp;</a></span>AddQuadraticCost() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a>&gt; AddQuadraticCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>is_convex</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term of the form 0.5*x'*Q*x + b'x Applied to subset of the variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is_convex</td><td>Whether the cost is already known to be convex. If is_convex=nullopt (the default), then Drake will determine if this is a convex quadratic cost or not. To improve the computation speed, the user can set is_convex if the user knows whether the cost is convex or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ae7eae6436a037740a2b8b7ba31f123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae7eae6436a037740a2b8b7ba31f123">&#9670;&nbsp;</a></span>AddQuadraticErrorCost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a>&gt; AddQuadraticErrorCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term of the form (x-x_desired)'<em>Q</em>(x-x_desired). </p>

</div>
</div>
<a id="a7d57f46afbdd9192bae0d803fc7be404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d57f46afbdd9192bae0d803fc7be404">&#9670;&nbsp;</a></span>AddQuadraticErrorCost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a>&gt; AddQuadraticErrorCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost term of the form (x-x_desired)'<em>Q</em>(x-x_desired). </p>

</div>
</div>
<a id="a12a0bbb8698b6c9015f06ef81f29e472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a0bbb8698b6c9015f06ef81f29e472">&#9670;&nbsp;</a></span>AddRotatedLorentzConeConstraint() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a>&gt; AddRotatedLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>linear_expression1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>linear_expression2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>quadratic_expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds rotated Lorentz cone constraint on the linear expression v1, v2 and quadratic expression u, such that v1 * v2 &gt;= u, v1 &gt;= 0, v2 &gt;= 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linear_expression1</td><td>The linear expression v1. </td></tr>
    <tr><td class="paramname">linear_expression2</td><td>The linear expression v2. </td></tr>
    <tr><td class="paramname">quadratic_expression</td><td>The quadratic expression u. </td></tr>
    <tr><td class="paramname">tol</td><td>The tolerance to determine if the matrix in v2 is positive semidefinite or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>DecomposePositiveQuadraticForm for more explanation. <br />
 <em>Default:</em> is 0. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">binding</td><td>The newly added rotated Lorentz cone constraint, together with the bound variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ol type="1">
<li><code>linear_expression1</code> is a linear (affine) expression, in the form of v1 = c1'*x + d1.</li>
<li><code>linear_expression2</code> is a linear (affine) expression, in the form of v2 = c2'*x + d2.</li>
</ol>
<ol type="1">
<li><code>quadratic_expression</code> is a quadratic expression, in the form of <pre>
         u = x'*Q*x + b'x + a
   </pre> Also the quadratic expression has to be convex, namely Q is a positive semidefinite matrix, and the quadratic expression needs to be non-negative for any x. </li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the preconditions are not satisfied.</td></tr>
  </table>
  </dd>
</dl>
<p>For example, to add the rotated Lorentz cone constraint </p><pre class="fragment">(x+1)(x+y) &gt;= x²+z²+2z+5
x+1 &gt;= 0
x+y &gt;= 0
</pre><p> The user could call </p><div class="fragment"><div class="line">prog.AddRotatedLorentzConeConstraint(x+1, x+y, <a class="code" href="namespacedrake.html#a95cb9413bd3124511459d856f6eef5f3">pow</a>(x, 2) + <a class="code" href="namespacedrake.html#a95cb9413bd3124511459d856f6eef5f3">pow</a>(z, 2) +</div><div class="line">2*z+5);</div></div><!-- fragment --> 
</div>
</div>
<a id="af8888193e1130288e45be9edd3f47a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8888193e1130288e45be9edd3f47a7e">&#9670;&nbsp;</a></span>AddRotatedLorentzConeConstraint() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a>&gt; AddRotatedLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a constraint that a symbolic expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>is in the rotated Lorentz cone, i.e., <p class="formulaDsp">
\[ v_0v_1 \ge v_2^2 + ... + v_{n-1}^2\\ v_0 \ge 0, v_1 \ge 0 \]
</p>
 </td></tr>
    <tr><td class="paramname">v</td><td>A linear expression of variables, \( v = A x + b\), where \( A, b \) are given matrices of the correct size, \( x \) is the vector of decision variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">binding</td><td>The newly added rotated Lorentz cone constraint, together with the bound variables.</td></tr>
  </table>
  </dd>
</dl>
<p>For example, to add the rotated Lorentz cone constraint </p><pre class="fragment">(x+1)(x+y) &gt;= x²+z²+2z+5 = x² + (z+1)² + 2²
x+1 &gt;= 0
x+y &gt;= 0
</pre><p> The user could call </p><div class="fragment"><div class="line">Eigen::Matrix&lt;symbolic::Expression, 5, 1&gt; v;</div><div class="line">v &lt;&lt; x+1, x+y, x, z+1, 2;</div><div class="line">prog.AddRotatedLorentzConeConstraint(v);</div></div><!-- fragment --> 
</div>
</div>
<a id="ad038198c145926f0e63faf04b254c7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad038198c145926f0e63faf04b254c7a3">&#9670;&nbsp;</a></span>AddRotatedLorentzConeConstraint() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a>&gt; AddRotatedLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a rotated Lorentz cone constraint referencing potentially a subset of decision variables, The linear expression \( z=Ax+b \) is in rotated Lorentz cone. </p>
<p>A vector \( z \in\mathbb{R}^n \) is in the rotated Lorentz cone, if</p>
<p class="formulaDsp">
\[ z_0z_1 \ge z_2^2 + ... + z_{n-1}^2 \]
</p>
<p> where \( A\in\mathbb{R}^{n\times m}, b\in\mathbb{R}^n\) are given matrices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A matrix whose number of columns equals to the size of the decision variables. </td></tr>
    <tr><td class="paramname">b</td><td>A vector whose number of rows equals to the size fo the decision variables. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which the constraint is imposed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8fe068baa72efa72a6b4f12ef8184ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fe068baa72efa72a6b4f12ef8184ba">&#9670;&nbsp;</a></span>AddRotatedLorentzConeConstraint() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a>&gt; AddRotatedLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a rotated Lorentz cone constraint referencing potentially a subset of decision variables, The linear expression \( z=Ax+b \) is in rotated Lorentz cone. </p>
<p>A vector \( z \in\mathbb{R}^n \) is in the rotated Lorentz cone, if</p>
<p class="formulaDsp">
\[ z_0z_1 \ge z_2^2 + ... + z_{n-1}^2 \]
</p>
<p> where \( A\in\mathbb{R}^{n\times m}, b\in\mathbb{R}^n\) are given matrices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>A matrix whose number of columns equals to the size of the decision variables. </td></tr>
    <tr><td class="paramname">b</td><td>A vector whose number of rows equals to the size fo the decision variables. </td></tr>
    <tr><td class="paramname">vars</td><td>The decision variables on which the constraint is imposed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c0b88b023b5603a6534662bf98af309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0b88b023b5603a6534662bf98af309">&#9670;&nbsp;</a></span>AddRotatedLorentzConeConstraint() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a>&gt; AddRotatedLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Impose that a vector \( x\in\mathbb{R}^m \) is in rotated Lorentz cone. </p>
<p>Namely </p><p class="formulaDsp">
\[ x_0 x_1 \ge x_2^2 + ... + x_{m-1}^2\\ x_0 \ge 0, x_1 \ge 0 \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vars</td><td>The stacked column of vars lies in the rotated Lorentz cone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added rotated Lorentz cone constraint. </dd></dl>

</div>
</div>
<a id="af5a5ef4b6da552936dabb22caae98f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a5ef4b6da552936dabb22caae98f4b">&#9670;&nbsp;</a></span>AddRotatedLorentzConeConstraint() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a>&gt; AddRotatedLorentzConeConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; <a class="el" href="namespacedrake_1_1solvers.html#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a>&lt; rows &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Impose that a vector \( x\in\mathbb{R}^m \) is in rotated Lorentz cone. </p>
<p>Namely </p><p class="formulaDsp">
\[ x_0 x_1 \ge x_2^2 + ... + x_{m-1}^2\\ x_0 \ge 0, x_1 \ge 0 \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vars</td><td>The stacked column of vars lies in the rotated Lorentz cone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added rotated Lorentz cone constraint. </dd></dl>

</div>
</div>
<a id="a025725213af92f5cbd02afb1c7c7f006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a025725213af92f5cbd02afb1c7c7f006">&#9670;&nbsp;</a></span>AddScaledDiagonallyDominantMatrixConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="namespacedrake.html#a06406a5da633da84f911e2979aa48549">Matrix2</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt; &gt; &gt; AddScaledDiagonallyDominantMatrixConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded variant of <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#addsdd">scaled diagonally dominant matrix constraint</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The matrix X to be constrained scaled diagonally dominant. X. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>X(i, j) should be a linear expression of decision variables. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>M A vector of vectors of 2 x 2 symmetric matrices M. For i &lt; j, M[i][j] is <pre>
[Mⁱʲ(i, i), Mⁱʲ(i, j)]
[Mⁱʲ(i, j), Mⁱʲ(j, j)].
</pre> Note that M[i][j](0, 1) = Mⁱʲ(i, j) = (X(i, j) + X(j, i)) / 2 for i &gt;= j, M[i][j] is the zero matrix. </dd></dl>

</div>
</div>
<a id="aa36d897cf0f11f2fa5f130148e4d5401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa36d897cf0f11f2fa5f130148e4d5401">&#9670;&nbsp;</a></span>AddScaledDiagonallyDominantMatrixConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="namespacedrake.html#a06406a5da633da84f911e2979aa48549">Matrix2</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&gt; &gt; &gt; AddScaledDiagonallyDominantMatrixConstraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded variant of <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#addsdd">scaled diagonally dominant matrix constraint</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>The symmetric matrix X to be constrained scaled diagonally dominant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>M For i &lt; j M[i][j] contains the slack variables, mentioned in <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#addsdd">scaled diagonally dominant matrix constraint</a>. For i &gt;= j, M[i][j] contains dummy variables. </dd></dl>

</div>
</div>
<a id="ae27c69de208a984eac3ccba736b46b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27c69de208a984eac3ccba736b46b41">&#9670;&nbsp;</a></span>AddSosConstraint() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> AddSosConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>monomial_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints that a given polynomial <code>p</code> is a sums-of-squares (SOS), that is, <code>p</code> can be decomposed into <code>mᵀQm</code>, where m is the <code>monomial_basis</code>. </p>
<p>It returns the coefficients matrix Q, which is positive semidefinite. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the polynomial. <br />
 <em>Default:</em> is kSos, but the user can also use kSdsos and kDsos. Refer to NonnegativePolynomial for details on different types of sos polynomials.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It calls <code>Reparse</code> to enforce <code>p</code> to have this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>'s indeterminates if necessary. </dd></dl>

</div>
</div>
<a id="a861c38c659adf55d7ad0bffecee4bf13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861c38c659adf55d7ad0bffecee4bf13">&#9670;&nbsp;</a></span>AddSosConstraint() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a>&gt; &gt; AddSosConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints that a given polynomial <code>p</code> is a sums-of-squares (SOS), that is, <code>p</code> can be decomposed into <code>mᵀQm</code>, where m is a monomial basis selected from the sparsity of <code>p</code>. </p>
<p>It returns a pair of constraint bindings expressing:</p><ul>
<li>The coefficients matrix Q, which is positive semidefinite.</li>
<li>The monomial basis m. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the polynomial. <br />
 <em>Default:</em> is kSos, but the user can also use kSdsos and kDsos. Refer to NonnegativePolynomial for the details on different type of sos polynomials.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It calls <code>Reparse</code> to enforce <code>p</code> to have this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>'s indeterminates if necessary. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a1ef1ca7232b100f33773c7cc7151f485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef1ca7232b100f33773c7cc7151f485">&#9670;&nbsp;</a></span>AddSosConstraint() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> AddSosConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>monomial_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints that a given symbolic expression <code>e</code> is a sums-of-squares (SOS), that is, <code>p</code> can be decomposed into <code>mᵀQm</code>, where m is the <code>monomial_basis</code>. </p>
<p>Note that it decomposes <code>e</code> into a polynomial with respect to <code><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#abaa1d35a078980665b4cabac09dd235b" title="Getter for all indeterminates in the program.">indeterminates()</a></code> in this mathematical program. It returns the coefficients matrix Q, which is positive semidefinite. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Refer to NonnegativePolynomial class documentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbfeb9b0b6e49545dd732f7a3c95b152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfeb9b0b6e49545dd732f7a3c95b152">&#9670;&nbsp;</a></span>AddSosConstraint() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a>&gt; &gt; AddSosConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints that a given symbolic expression <code>e</code> is a sums-of-squares (SOS), that is, <code>e</code> can be decomposed into <code>mᵀQm</code>. </p>
<p>Note that it decomposes <code>e</code> into a polynomial with respect to <code><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#abaa1d35a078980665b4cabac09dd235b" title="Getter for all indeterminates in the program.">indeterminates()</a></code> in this mathematical program. It returns a pair expressing:</p><ul>
<li>The coefficients matrix Q, which is positive semidefinite.</li>
<li>The monomial basis m. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Refer to NonnegativePolynomial class documentation. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a67626d45d9a119d01e1c046ad89ee556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67626d45d9a119d01e1c046ad89ee556">&#9670;&nbsp;</a></span>AddVisualizationCallback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html">VisualizationCallback</a>&gt; AddVisualizationCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html#a84c15b60ba647eabef0aaa2d5dd3943e">VisualizationCallback::CallbackFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a callback method to visualize intermediate results of the optimization. </p>
<dl class="section note"><dt>Note</dt><dd>Just like other costs/constraints, not all solvers support callbacks. Adding a callback here will force MathematicalProgram::Solve to select a solver that support callbacks. For instance, adding a visualization callback to a quadratic programming problem may result in using a nonlinear programming solver as the default solver.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>a std::function that accepts an Eigen::Vector of doubles representing the bound decision variables. </td></tr>
    <tr><td class="paramname">vars</td><td>the decision variables that should be passed to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d2cc4c49122282ae0b2fe0511e86817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2cc4c49122282ae0b2fe0511e86817">&#9670;&nbsp;</a></span>AddVisualizationCallback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html">VisualizationCallback</a>&gt; AddVisualizationCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html#a84c15b60ba647eabef0aaa2d5dd3943e">VisualizationCallback::CallbackFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a callback method to visualize intermediate results of the optimization. </p>
<dl class="section note"><dt>Note</dt><dd>Just like other costs/constraints, not all solvers support callbacks. Adding a callback here will force MathematicalProgram::Solve to select a solver that support callbacks. For instance, adding a visualization callback to a quadratic programming problem may result in using a nonlinear programming solver as the default solver.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>a std::function that accepts an Eigen::Vector of doubles representing the for the bound decision variables. </td></tr>
    <tr><td class="paramname">vars</td><td>the decision variables that should be passed to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af39c3045633d664d62c161a5ef4f3c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39c3045633d664d62c161a5ef4f3c4c">&#9670;&nbsp;</a></span>bounding_box_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a>&gt; &gt;&amp; bounding_box_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for all bounding box constraints. </p>

</div>
</div>
<a id="a92eb16be90ba1765547a715ec244fe00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92eb16be90ba1765547a715ec244fe00">&#9670;&nbsp;</a></span>CheckSatisfied() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CheckSatisfied </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>prog_var_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates CheckSatisfied for the constraint in <code>binding</code> using the value of ALL of the decision variables in this program. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the size of <code>prog_var_vals</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c2467d1ef4671955b66dd8ddfac39e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2467d1ef4671955b66dd8ddfac39e4">&#9670;&nbsp;</a></span>CheckSatisfied() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CheckSatisfied </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>prog_var_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates CheckSatisfied for the all of the constraints in <code>binding</code> using the value of ALL of the decision variables in this program. </p>
<dl class="section return"><dt>Returns</dt><dd>true iff all of the constraints are satisfied. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the size of <code>prog_var_vals</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40e98056457ab5ff0855a167b2a057dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e98056457ab5ff0855a167b2a057dc">&#9670;&nbsp;</a></span>CheckSatisfiedAtInitialGuess() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CheckSatisfiedAtInitialGuess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates CheckSatisfied for the constraint in <code>binding</code> at the initial guess. </p>

</div>
</div>
<a id="acbe6687c1f407124c9bd88777ed71144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe6687c1f407124c9bd88777ed71144">&#9670;&nbsp;</a></span>CheckSatisfiedAtInitialGuess() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CheckSatisfiedAtInitialGuess </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates CheckSatisfied for the all of the constraints in <code>bindings</code> at the initial guess. </p>
<dl class="section return"><dt>Returns</dt><dd>true iff all of the constraints are satisfied. </dd></dl>

</div>
</div>
<a id="ac2079c8eee90c77853f4a9a96c14715a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2079c8eee90c77853f4a9a96c14715a">&#9670;&nbsp;</a></span>ClearVariableScaling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ClearVariableScaling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the scaling factors for decision variables. </p>
<p>See <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#variable_scaling">Variable scaling</a> for more information. </p>

</div>
</div>
<a id="aa73c34779cac8f3d622aa353c8212d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73c34779cac8f3d622aa353c8212d38">&#9670;&nbsp;</a></span>Clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a>&gt; Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clones an optimization program. </p>
<p>The clone will be functionally equivalent to the source program with the same:</p>
<ul>
<li>decision variables</li>
<li>constraints</li>
<li>costs</li>
<li>solver settings</li>
<li>initial guess</li>
</ul>
<p>However, the clone's x values will be initialized to NaN, and all internal solvers will be freshly constructed. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">new_prog.</td><td>The newly constructed mathematical program. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7647680c7f56fdae6dc324db6aed1e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7647680c7f56fdae6dc324db6aed1e45">&#9670;&nbsp;</a></span>decision_variable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&amp; decision_variable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the decision variable with index <code>i</code> in the program. </p>

</div>
</div>
<a id="a8f2b24f3bef681051fd923693a85ee7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2b24f3bef681051fd923693a85ee7e">&#9670;&nbsp;</a></span>decision_variable_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, <a class="el" href="classint.html">int</a>&gt;&amp; decision_variable_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the mapping from a decision variable ID to its index in the vector containing all the decision variables in the mathematical program. </p>

</div>
</div>
<a id="a3d833ea37172e9829c5d85e388eb9f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d833ea37172e9829c5d85e388eb9f59">&#9670;&nbsp;</a></span>decision_variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Map&lt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&gt; &gt; decision_variables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for all decision variables in the program. </p>

</div>
</div>
<a id="af9d07051ef1c3778a15b117060f65ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d07051ef1c3778a15b117060f65ac5">&#9670;&nbsp;</a></span>EvalBinding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt;DerivedX&gt;::value, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;typename DerivedX::Scalar&gt; &gt; EvalBinding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>prog_var_vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the value of some binding, for some input value for all decision variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binding</td><td>A <a class="el" href="classdrake_1_1solvers_1_1_binding.html" title="A binding on constraint type C is a mapping of the decision variables onto the inputs of C.">Binding</a> whose variables are decision variables in this program. </td></tr>
    <tr><td class="paramname">prog_var_vals</td><td>The value of all the decision variables in this program. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the size of <code>prog_var_vals</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0eb46a0ff11d6f6d22d69d9c16bfce94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb46a0ff11d6f6d22d69d9c16bfce94">&#9670;&nbsp;</a></span>EvalBindingAtInitialGuess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd EvalBindingAtInitialGuess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the evaluator in <code>binding</code> at the initial guess. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of <code>binding</code> at the initial guess. </dd></dl>

</div>
</div>
<a id="a30ace5ac7ffabb8af91d49f41bc09ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ace5ac7ffabb8af91d49f41bc09ab1">&#9670;&nbsp;</a></span>EvalBindings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt;DerivedX&gt;::value, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;typename DerivedX::Scalar&gt; &gt; EvalBindings </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>prog_var_vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a set of bindings (plural version of <code>EvalBinding</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindings</td><td>List of bindings. </td></tr>
    <tr><td class="paramname">prog</td><td></td></tr>
    <tr><td class="paramname">prog_var_vals</td><td>The value of all the decision variables in this program. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All binding values, concatenated into a single vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the size of <code>prog_var_vals</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a856ded9f90eaac91a1c66f2c139566b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856ded9f90eaac91a1c66f2c139566b5">&#9670;&nbsp;</a></span>EvalVisualizationCallbacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EvalVisualizationCallbacks </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>prog_var_vals</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates all visualization callbacks registered with the <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog_var_vals</td><td>The value of all the decision variables in this program. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the size does not match. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58ba7cf747dd35fbbbd4ea7c2baa4da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ba7cf747dd35fbbbd4ea7c2baa4da7">&#9670;&nbsp;</a></span>exponential_cone_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html">ExponentialConeConstraint</a>&gt; &gt;&amp; exponential_cone_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for exponential cone constraints. </p>

</div>
</div>
<a id="a2f25e54555621691b390c1658e21872f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f25e54555621691b390c1658e21872f">&#9670;&nbsp;</a></span>FindDecisionVariableIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> FindDecisionVariableIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the decision variable. </p>
<p>Internally the solvers thinks all variables are stored in an array, and it accesses each individual variable using its index. This index is used when adding constraints and costs for each solver. </p><dl class="section pre"><dt>Precondition</dt><dd>{<code>var</code> is a decision variable in the mathematical program, otherwise this function throws a runtime error.} </dd></dl>

</div>
</div>
<a id="a53e872544e169f9b66f499bc06eb4641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e872544e169f9b66f499bc06eb4641">&#9670;&nbsp;</a></span>FindDecisionVariableIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classint.html">int</a>&gt; FindDecisionVariableIndices </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the indices of the decision variables. </p>
<p>Internally the solvers thinks all variables are stored in an array, and it accesses each individual variable using its index. This index is used when adding constraints and costs for each solver. </p><dl class="section pre"><dt>Precondition</dt><dd>{<code>vars</code> are decision variables in the mathematical program, otherwise this function throws a runtime error.} </dd></dl>

</div>
</div>
<a id="a1470ed93553619a1f630bc8035947556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1470ed93553619a1f630bc8035947556">&#9670;&nbsp;</a></span>FindIndeterminateIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t FindIndeterminateIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the indeterminate. </p>
<p>Internally a solver thinks all indeterminates are stored in an array, and it accesses each individual indeterminate using its index. This index is used when adding constraints and costs for each solver. </p><dl class="section pre"><dt>Precondition</dt><dd><code>var</code> is a indeterminate in the mathematical program, otherwise this function throws a runtime error. </dd></dl>

</div>
</div>
<a id="a63a221ef50ba7ccdff7222a5a0fb38b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a221ef50ba7ccdff7222a5a0fb38b7">&#9670;&nbsp;</a></span>generic_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a>&gt; &gt;&amp; generic_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for all generic constraints. </p>

</div>
</div>
<a id="a76eeecc02d2b6d3f2c11b407e70baf86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76eeecc02d2b6d3f2c11b407e70baf86">&#9670;&nbsp;</a></span>generic_costs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a>&gt; &gt;&amp; generic_costs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for all generic costs. </p>

</div>
</div>
<a id="afee45efd038cc24341094591bf1cbdbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee45efd038cc24341094591bf1cbdbc">&#9670;&nbsp;</a></span>GetAllConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a>&gt; &gt; GetAllConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for returning all constraints. </p>
<dl class="section return"><dt>Returns</dt><dd>Vector of all constraint bindings. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The group ordering may change as more constraint types are added. </dd></dl>

</div>
</div>
<a id="ad90403c02bdb7c61d7a8de5dd39e9c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90403c02bdb7c61d7a8de5dd39e9c39">&#9670;&nbsp;</a></span>GetAllCosts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a>&gt; &gt; GetAllCosts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter returning all costs. </p>
<dl class="section return"><dt>Returns</dt><dd>Vector of all cost bindings. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The group ordering may change as more cost types are added. </dd></dl>

</div>
</div>
<a id="a17fe85b6ddbc665b74e8cf9c6bf02d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17fe85b6ddbc665b74e8cf9c6bf02d3e">&#9670;&nbsp;</a></span>GetAllLinearConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; &gt; GetAllLinearConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter returning all linear constraints (both linear equality and inequality constraints). </p>
<dl class="section return"><dt>Returns</dt><dd>Vector of all linear constraint bindings. </dd></dl>

</div>
</div>
<a id="adf1b28062ab095a5824cbf928e37e1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1b28062ab095a5824cbf928e37e1ff">&#9670;&nbsp;</a></span>GetBindingVariableValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a>&lt;DerivedX&gt;::value, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;typename DerivedX::Scalar&gt; &gt; GetBindingVariableValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>prog_var_vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the value of all decision variables, namely this.decision_variable(i) takes the value prog_var_vals(i), returns the vector that contains the value of the variables in binding.variables(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binding</td><td>binding.variables() must be decision variables in this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </td></tr>
    <tr><td class="paramname">prog_var_vals</td><td>The value of ALL the decision variables in this program. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>binding_variable_vals binding_variable_vals(i) is the value of binding.variables()(i) in prog_var_vals. </dd></dl>

</div>
</div>
<a id="aa44e07a559ca22d055de33fa1154c095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44e07a559ca22d055de33fa1154c095">&#9670;&nbsp;</a></span>GetInitialGuess() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GetInitialGuess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>decision_variable</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the initial guess for a single variable. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>decision_variable</code> has been registered in the optimization program. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the pre condition is not satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a390ecd2ae9e9cc6877af3c2202341b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390ecd2ae9e9cc6877af3c2202341b3e">&#9670;&nbsp;</a></span>GetInitialGuess() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&gt;, Eigen::Matrix&lt;double, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt; GetInitialGuess </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>decision_variable_mat</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the initial guess for some variables. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Each variable in <code>decision_variable_mat</code> has been registered in the optimization program. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the pre condition is not satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7abf83f965123608bf855d5eef56806f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7abf83f965123608bf855d5eef56806f">&#9670;&nbsp;</a></span>GetSolverOptionsDouble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt;std::string, double&gt;&amp; GetSolverOptionsDouble </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname"><em>solver_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa53e7b6bf2db39795a28138edda49638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53e7b6bf2db39795a28138edda49638">&#9670;&nbsp;</a></span>GetSolverOptionsInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt;std::string, <a class="el" href="classint.html">int</a>&gt;&amp; GetSolverOptionsInt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname"><em>solver_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac296d646cdfb000b49df738e9da24159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac296d646cdfb000b49df738e9da24159">&#9670;&nbsp;</a></span>GetSolverOptionsStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt;std::string, std::string&gt;&amp; GetSolverOptionsStr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname"><em>solver_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ebc792721a0a9dca1079e093428655a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ebc792721a0a9dca1079e093428655a">&#9670;&nbsp;</a></span>GetVariableScaling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt;<a class="el" href="classint.html">int</a>, double&gt;&amp; GetVariableScaling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the mapping from a decision variable index to its scaling factor. </p>
<p>See <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#variable_scaling">Variable scaling</a> for more information. </p>

</div>
</div>
<a id="a6736e7e843acfd67ecd254b9a2270863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6736e7e843acfd67ecd254b9a2270863">&#9670;&nbsp;</a></span>indeterminate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&amp; indeterminate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the indeterminate with index <code>i</code> in the program. </p>

</div>
</div>
<a id="abaa1d35a078980665b4cabac09dd235b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa1d35a078980665b4cabac09dd235b">&#9670;&nbsp;</a></span>indeterminates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Map&lt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&gt; &gt; indeterminates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for all indeterminates in the program. </p>

</div>
</div>
<a id="a0c27da874a5e06bccfb91ff25ec05fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c27da874a5e06bccfb91ff25ec05fb9">&#9670;&nbsp;</a></span>indeterminates_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, <a class="el" href="classint.html">int</a>&gt;&amp; indeterminates_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the mapping from an indeterminate ID to its index in the vector containing all the indeterminates in the mathematical program. </p>

</div>
</div>
<a id="a8d203a1789d8fe03eeaaacdb49a267d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d203a1789d8fe03eeaaacdb49a267d4">&#9670;&nbsp;</a></span>initial_guess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::VectorXd&amp; initial_guess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the initial guess. </p>

</div>
</div>
<a id="af5e169f4d4bb63dd56bcd7cc89a561a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e169f4d4bb63dd56bcd7cc89a561a1">&#9670;&nbsp;</a></span>l2norm_costs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a>&gt; &gt;&amp; l2norm_costs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for l2norm costs. </p>

</div>
</div>
<a id="a1d9e00f78efde184f9f7377ed0a42700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9e00f78efde184f9f7377ed0a42700">&#9670;&nbsp;</a></span>linear_complementarity_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a>&gt; &gt;&amp; linear_complementarity_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for all linear complementarity constraints. </p>

</div>
</div>
<a id="a5febe285490e9ce74e824de29f2ecd9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5febe285490e9ce74e824de29f2ecd9f">&#9670;&nbsp;</a></span>linear_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; &gt;&amp; linear_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for linear constraints. </p>

</div>
</div>
<a id="a073a43c000385cfb134619ac960ab36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073a43c000385cfb134619ac960ab36f">&#9670;&nbsp;</a></span>linear_costs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a>&gt; &gt;&amp; linear_costs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for linear costs. </p>

</div>
</div>
<a id="aac264e3eaafb940135dfa11d3ba84c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac264e3eaafb940135dfa11d3ba84c67">&#9670;&nbsp;</a></span>linear_equality_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a>&gt; &gt;&amp; linear_equality_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for linear equality constraints. </p>

</div>
</div>
<a id="a27e3ce329f648aae3bea248179013b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e3ce329f648aae3bea248179013b34">&#9670;&nbsp;</a></span>linear_matrix_inequality_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a>&gt; &gt;&amp; linear_matrix_inequality_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for linear matrix inequality constraints. </p>

</div>
</div>
<a id="ae9af8bd45f4e7aa63918031b0774fed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9af8bd45f4e7aa63918031b0774fed0">&#9670;&nbsp;</a></span>lorentz_cone_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a>&gt; &gt;&amp; lorentz_cone_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for Lorentz cone constraints. </p>

</div>
</div>
<a id="a8f76110fcfea54be86c2ef1ebfeaab55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f76110fcfea54be86c2ef1ebfeaab55">&#9670;&nbsp;</a></span>MakeCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a>&gt; MakeCost </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an input of type <code>F</code> to a FunctionCost object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>This class should have functions numInputs(), numOutputs and eval(x, y). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9757b022381ac5841cd389a7e212dfbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9757b022381ac5841cd389a7e212dfbb">&#9670;&nbsp;</a></span>MakePolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> MakePolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a symbolic polynomial from the given expression <code>e</code>. </p>
<p>It uses this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>'s <code><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#abaa1d35a078980665b4cabac09dd235b" title="Getter for all indeterminates in the program.">indeterminates()</a></code> in constructing the polynomial.</p>
<p>This method helps a user create a polynomial with the right set of indeterminates which are declared in this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. We recommend users to use this method over an explicit call to <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> constructors to avoid a possible mismatch between this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>'s indeterminates and the user-specified indeterminates (or unspecified, which then includes all symbolic variables in the expression <code>e</code>). Consider the following example.</p>
<p>e = ax + bx + c</p>
<p>MP.indeterminates() = {x} MP.decision_variables() = {a, b}</p>
<ul>
<li><code>MP.MakePolynomial(e)</code> create a polynomial, <code>(a + b)x + c</code>. Here only <code>x</code> is an indeterminate of this polynomial.</li>
<li>In contrast, <code>symbolic::Polynomial(e)</code> returns <code>ax + bx + c</code> where all variables <code>{a, b, x}</code> are indeterminates. Note that this is problematic as its indeterminates, <code>{a, b, x}</code> and the <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>'s decision variables, <code>{a, b}</code> overlap.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function does not require that the decision variables in <code>e</code> is a subset of the decision variables in <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </dd></dl>

</div>
</div>
<a id="ae4e5827a62c6aadac95e0a053cf3fe08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e5827a62c6aadac95e0a053cf3fe08">&#9670;&nbsp;</a></span>NewBinaryVariables() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt;Rows, Cols&gt; NewBinaryVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds binary variables, appending them to an internal vector of any existing vars. </p>
<p>The initial guess values for the new variables are set to NaN, to indicate that an initial guess has not been assigned. Callers are expected to add costs and/or constraints to have any effect during optimization. Callers can also set the initial guess of the decision variables through <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae48cb6d2263ccf09e38932dcd27f769f" title="Sets the initial guess for a single variable decision_variable.">SetInitialGuess()</a> or <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae35679ed5aabea90fcf4ff3b337b44f5" title="Set the initial guess for ALL decision variables.">SetInitialGuessForAllVariables()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rows</td><td>The number of rows in the new variables. </td></tr>
    <tr><td class="paramname">Cols</td><td>The number of columns in the new variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new variables. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns in the new variables. </td></tr>
    <tr><td class="paramname">name</td><td>The commonly shared name of the new variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MatrixDecisionVariable of size rows x cols, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> prog;</div><div class="line"><span class="keyword">auto</span> b = prog.NewBinaryVariables(2, 3, <span class="stringliteral">&quot;b&quot;</span>);</div></div><!-- fragment --><p> This adds a 2 x 3 matrix decision variables into the program.</p>
<p>The name of the variable is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="a07b5acd86b0429f7cd22b04355f1f774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b5acd86b0429f7cd22b04355f1f774">&#9670;&nbsp;</a></span>NewBinaryVariables() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt;Rows, Cols&gt; NewBinaryVariables </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;b&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a matrix of binary variables into the optimization program. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rows</td><td>The number of rows in the newly added binary variables. </td></tr>
    <tr><td class="paramname">Cols</td><td>The number of columns in the new variables. The default is 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Each newly added binary variable will share the same name. The default name is "b". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix containing the newly added variables. </dd></dl>

</div>
</div>
<a id="a30759ec657805673fd0ce5e9edc166a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30759ec657805673fd0ce5e9edc166a2">&#9670;&nbsp;</a></span>NewBinaryVariables() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> NewBinaryVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;b&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds binary variables to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </p>
<p>The new variables are viewed as a column vector, with size <code>rows</code> x 1. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae4e5827a62c6aadac95e0a053cf3fe08" title="Adds binary variables, appending them to an internal vector of any existing vars.">NewBinaryVariables</a>(int rows, int cols, const std::vector&lt;std::string&gt;&amp; names); </dd></dl>

</div>
</div>
<a id="a53949966a66a6f53ba90596fc5a439ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53949966a66a6f53ba90596fc5a439ef">&#9670;&nbsp;</a></span>NewContinuousVariables() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> NewContinuousVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;x&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds continuous variables, appending them to an internal vector of any existing vars. </p>
<p>The initial guess values for the new variables are set to NaN, to indicate that an initial guess has not been assigned. Callers are expected to add costs and/or constraints to have any effect during optimization. Callers can also set the initial guess of the decision variables through <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae48cb6d2263ccf09e38932dcd27f769f" title="Sets the initial guess for a single variable decision_variable.">SetInitialGuess()</a> or <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae35679ed5aabea90fcf4ff3b337b44f5" title="Set the initial guess for ALL decision variables.">SetInitialGuessForAllVariables()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new variables. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the newly added variables </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The VectorDecisionVariable of size rows x 1, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> prog;</div><div class="line"><span class="keyword">auto</span> x = prog.NewContinuousVariables(2, <span class="stringliteral">&quot;x&quot;</span>);</div></div><!-- fragment --><p> This adds a 2 x 1 vector containing decision variables into the program. The names of the variables are "x(0)" and "x(1)".</p>
<p>The name of the variable is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="a2cd612c938a2bb1887476dadf65dd0a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd612c938a2bb1887476dadf65dd0a5">&#9670;&nbsp;</a></span>NewContinuousVariables() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt;Rows, Cols&gt; NewContinuousVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;X&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds continuous variables, appending them to an internal vector of any existing vars. </p>
<p>The initial guess values for the new variables are set to NaN, to indicate that an initial guess has not been assigned. Callers are expected to add costs and/or constraints to have any effect during optimization. Callers can also set the initial guess of the decision variables through <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae48cb6d2263ccf09e38932dcd27f769f" title="Sets the initial guess for a single variable decision_variable.">SetInitialGuess()</a> or <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae35679ed5aabea90fcf4ff3b337b44f5" title="Set the initial guess for ALL decision variables.">SetInitialGuessForAllVariables()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rows</td><td>The number of rows of the new variables, in the compile time. </td></tr>
    <tr><td class="paramname">Cols</td><td>The number of columns of the new variables, in the compile time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new variables. When Rows is not Eigen::Dynamic, rows is ignored. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns in the new variables. When Cols is not Eigen::Dynamic, cols is ignored. </td></tr>
    <tr><td class="paramname">name</td><td>All variables will share the same name, but different index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MatrixDecisionVariable of size Rows x Cols, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> prog;</div><div class="line"><span class="keyword">auto</span> x = prog.NewContinuousVariables(2, 3, <span class="stringliteral">&quot;X&quot;</span>);</div><div class="line"><span class="keyword">auto</span> y = prog.NewContinuousVariables&lt;2, 3&gt;(2, 3, <span class="stringliteral">&quot;X&quot;</span>);</div></div><!-- fragment --><p> This adds a 2 x 3 matrix decision variables into the program.</p>
<p>The name of the variable is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="a8f22188fff7a464ac091b8fea727a89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f22188fff7a464ac091b8fea727a89d">&#9670;&nbsp;</a></span>NewContinuousVariables() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt;Rows, Cols&gt; NewContinuousVariables </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;X&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds continuous variables, appending them to an internal vector of any existing vars. </p>
<p>The initial guess values for the new variables are set to NaN, to indicate that an initial guess has not been assigned. Callers are expected to add costs and/or constraints to have any effect during optimization. Callers can also set the initial guess of the decision variables through <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae48cb6d2263ccf09e38932dcd27f769f" title="Sets the initial guess for a single variable decision_variable.">SetInitialGuess()</a> or <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#ae35679ed5aabea90fcf4ff3b337b44f5" title="Set the initial guess for ALL decision variables.">SetInitialGuessForAllVariables()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rows</td><td>The number of rows in the new variables. </td></tr>
    <tr><td class="paramname">Cols</td><td>The number of columns in the new variables. The default is 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>All variables will share the same name, but different index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MatrixDecisionVariable of size rows x cols, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> prog;</div><div class="line"><span class="keyword">auto</span> x = prog.NewContinuousVariables&lt;2, 3&gt;(<span class="stringliteral">&quot;X&quot;</span>);</div></div><!-- fragment --><p> This adds a 2 x 3 matrix decision variables into the program.</p>
<p>The name of the variable is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="af7be7b407fbcebb6fc7100759492a3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7be7b407fbcebb6fc7100759492a3d9">&#9670;&nbsp;</a></span>NewEvenDegreeDsosPolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>&gt; NewEvenDegreeDsosPolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>indeterminates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>see <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#even_degree_nonnegative_polynomial">even_degree_nonnegative_polynomial</a> for details. </p>
<p>Variant that produces a DSOS polynomial. Same as NewEvenDegreeSosPolynomial, except the returned polynomial is diagonally dominant sum of squares (dsos). </p>

</div>
</div>
<a id="a4892d2259256cc4aff04a354391eae77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4892d2259256cc4aff04a354391eae77">&#9670;&nbsp;</a></span>NewEvenDegreeFreePolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> NewEvenDegreeFreePolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>indeterminates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>coeff_name</em> = <code>&quot;a&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a free polynomial that only contains even degree monomials. </p>
<p>A monomial is even degree if its total degree (sum of all variables' degree) is even. For example, xy is an even degree monomial (degree 2) while x²y is not (degree 3). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indeterminates</td><td>The monomial basis is over these indeterminates. </td></tr>
    <tr><td class="paramname">degree</td><td>The highest degree of the polynomial. </td></tr>
    <tr><td class="paramname">coeff_name</td><td>The coefficients of the polynomial are decision variables with this name as a base. The variable name would be "a1", "a2", etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5aa9886afdbee42b4eab1077318f961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5aa9886afdbee42b4eab1077318f961">&#9670;&nbsp;</a></span>NewEvenDegreeNonnegativePolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>&gt; NewEvenDegreeNonnegativePolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>indeterminates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#even_degree_nonnegative_polynomial">even_degree_nonnegative_polynomial</a> for more details. </p>
<p>Variant that produces different non-negative polynomials depending on <code>type</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The returned polynomial p(x) can be either SOS, SDSOS or DSOS, depending on <code>type</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3787e8a9fcc4e09304d6e1fa697d2d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3787e8a9fcc4e09304d6e1fa697d2d7f">&#9670;&nbsp;</a></span>NewEvenDegreeSdsosPolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>&gt; NewEvenDegreeSdsosPolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>indeterminates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>see <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#even_degree_nonnegative_polynomial">even_degree_nonnegative_polynomial</a> for details. </p>
<p>Variant that produces an SDSOS polynomial. </p>

</div>
</div>
<a id="a3b568d2ab99871d864e445960ac8dc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b568d2ab99871d864e445960ac8dc18">&#9670;&nbsp;</a></span>NewEvenDegreeSosPolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>&gt; NewEvenDegreeSosPolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>indeterminates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#even_degree_nonnegative_polynomial">even_degree_nonnegative_polynomial</a> for more details. </p>
<p>Variant that produces a SOS polynomial. </p>

</div>
</div>
<a id="ae6a71c1f6466e5dedbd2cd73372dfcd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a71c1f6466e5dedbd2cd73372dfcd5">&#9670;&nbsp;</a></span>NewFreePolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> NewFreePolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>indeterminates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>coeff_name</em> = <code>&quot;a&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a free polynomial in a monomial basis over <code>indeterminates</code> of a given <code>degree</code>. </p>
<p>It uses <code>coeff_name</code> to make new decision variables and use them as coefficients. For example, <code>NewFreePolynomial({x₀, x₁}, 2)</code> returns a₀x₁² + a₁x₀x₁ + a₂x₀² + a₃x₁ + a₄x₀ + a₅. </p>

</div>
</div>
<a id="a0228101da15efa318a6e51349d3ff0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0228101da15efa318a6e51349d3ff0a4">&#9670;&nbsp;</a></span>NewIndeterminates() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a>&lt;rows, cols&gt; NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::string, rows *cols &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates, appending them to an internal vector of any existing indeterminates. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new indeterminates. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns in the new indeterminates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>A vector of strings containing the name for each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MatrixIndeterminate of size rows x cols, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> prog;</div><div class="line">std::array&lt;std::string, 6&gt; names = {<span class="stringliteral">&quot;x1&quot;</span>, <span class="stringliteral">&quot;x2&quot;</span>, <span class="stringliteral">&quot;x3&quot;</span>, <span class="stringliteral">&quot;x4&quot;</span>, <span class="stringliteral">&quot;x5&quot;</span>, <span class="stringliteral">&quot;x6&quot;</span>};</div><div class="line"><span class="keyword">auto</span> x = prog.NewIndeterminates&lt;2, 3&gt;(names);</div></div><!-- fragment --><p> This adds a 2 x 3 matrix indeterminates into the program.</p>
<p>The name of the indeterminates is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="aae23f7c130166d82b578205015aed630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae23f7c130166d82b578205015aed630">&#9670;&nbsp;</a></span>NewIndeterminates() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a>&lt;rows&gt; NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::string, rows &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates, appending them to an internal vector of any existing indeterminates. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new indeterminates. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns in the new indeterminates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>A vector of strings containing the name for each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MatrixIndeterminate of size rows x cols, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> prog;</div><div class="line">std::array&lt;std::string, 2&gt; names = {<span class="stringliteral">&quot;x1&quot;</span>, <span class="stringliteral">&quot;x2&quot;</span>};</div><div class="line"><span class="keyword">auto</span> x = prog.NewIndeterminates&lt;2&gt;(names);</div></div><!-- fragment --><p> This adds a 2 vector indeterminates into the program.</p>
<p>The name of the indeterminates is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="a84c82857db425d76e1e49d69560f989d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c82857db425d76e1e49d69560f989d">&#9670;&nbsp;</a></span>NewIndeterminates() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a>&lt;rows, cols&gt; NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;X&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates, appending them to an internal vector of any existing indeterminates. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new indeterminates. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns in the new indeterminates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>A vector of strings containing the name for each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MatrixIndeterminate of size rows x cols, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> prog;</div><div class="line"><span class="keyword">auto</span> x = prog.NewIndeterminates&lt;2, 3&gt;(<span class="stringliteral">&quot;X&quot;</span>);</div></div><!-- fragment --><p> This adds a 2 x 3 matrix indeterminates into the program.</p>
<p>The name of the indeterminates is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="a26d51c28aae22e905563f6b00f3c65a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d51c28aae22e905563f6b00f3c65a7">&#9670;&nbsp;</a></span>NewIndeterminates() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a>&lt;rows&gt; NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;x&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates to the program. </p>
<p>The name for all newly added indeterminates are set to <code>name</code>. The default name is "x" </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#aae23f7c130166d82b578205015aed630" title="Adds indeterminates, appending them to an internal vector of any existing indeterminates.">NewIndeterminates(const std::array&lt;std::string, rows&gt;&amp; names)</a> </dd></dl>

</div>
</div>
<a id="a0fd679ea34528e50d76d23f79fcd294f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd679ea34528e50d76d23f79fcd294f">&#9670;&nbsp;</a></span>NewIndeterminates() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a> NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a0228101da15efa318a6e51349d3ff0a4" title="Adds indeterminates, appending them to an internal vector of any existing indeterminates.">NewIndeterminates</a>(int rows, int cols, const std::vector&lt;std::string&gt;&amp; names); </dd></dl>

</div>
</div>
<a id="ae4ec9c4fc4ae8f5d8ff8382b227dd82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ec9c4fc4ae8f5d8ff8382b227dd82f">&#9670;&nbsp;</a></span>NewIndeterminates() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a> NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;x&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>, with default name "x". </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a0228101da15efa318a6e51349d3ff0a4" title="Adds indeterminates, appending them to an internal vector of any existing indeterminates.">NewIndeterminates</a>(int rows, int cols, const std::vector&lt;std::string&gt;&amp; names); </dd></dl>

</div>
</div>
<a id="a12431081348a404711db4d3bb25c8a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12431081348a404711db4d3bb25c8a76">&#9670;&nbsp;</a></span>NewIndeterminates() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a60e13290a9b854b4fee070764f978d22">MatrixXIndeterminate</a> NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates, appending them to an internal vector of any existing vars. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new indeterminates. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns in the new indeterminates. </td></tr>
    <tr><td class="paramname">names</td><td>A vector of strings containing the name for each variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The MatrixIndeterminate of size rows x cols, containing the new vars (not all the vars stored).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classdrake_1_1solvers_1_1_mathematical_program.html#ac577d0f44c9c07256230cf2642ec6822">MathematicalProgram</a> prog;</div><div class="line"><span class="keyword">auto</span> x = prog.NewIndeterminates(2, 3, {<span class="stringliteral">&quot;x1&quot;</span>, <span class="stringliteral">&quot;x2&quot;</span>, <span class="stringliteral">&quot;x3&quot;</span>, <span class="stringliteral">&quot;x4&quot;</span>,</div><div class="line"><span class="stringliteral">&quot;x5&quot;</span>, <span class="stringliteral">&quot;x6&quot;</span>});</div></div><!-- fragment --><p> This adds a 2 x 3 matrix indeterminates into the program.</p>
<p>The name of the variable is only used for the user in order to ease readability. </p>

</div>
</div>
<a id="ad7e4fa58845ca19073b0c532431ac141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e4fa58845ca19073b0c532431ac141">&#9670;&nbsp;</a></span>NewIndeterminates() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a60e13290a9b854b4fee070764f978d22">MatrixXIndeterminate</a> NewIndeterminates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;X&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds indeterminates to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>, with default name "X". </p>
<p>The new variables are returned and viewed as a matrix, with size <code>rows</code> x <code>cols</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a0228101da15efa318a6e51349d3ff0a4" title="Adds indeterminates, appending them to an internal vector of any existing indeterminates.">NewIndeterminates</a>(int rows, int cols, const std::vector&lt;std::string&gt;&amp; names); </dd></dl>

</div>
</div>
<a id="a903fd7b5970fb835030958fe57d8cd6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903fd7b5970fb835030958fe57d8cd6e">&#9670;&nbsp;</a></span>NewNonnegativePolynomial() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>&gt; NewNonnegativePolynomial </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>monomial_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pair of nonnegative polynomial p = mᵀQm and the Gramian matrix Q, where m is <code>monomial_basis</code>. </p>
<p>Adds Q as decision variables to the program. Depending on the type of the polynomial, we will impose different constraint on Q.</p><ul>
<li>if type = kSos, we impose Q being positive semidefinite.</li>
<li>if type = kSdsos, we impose Q being scaled diagonally dominant.</li>
<li>if type = kDsos, we impose Q being positive diagonally dominant. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">monomial_basis</td><td>The monomial basis. </td></tr>
    <tr><td class="paramname">type</td><td>The type of the nonnegative polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(p, Q) The polynomial p and the Gramian matrix Q. Q has been added as decision variables to the program.(Deprecated.) </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>Use NewSosPolynomial instead of NewNonnegativePolynomial <br />
 This will be removed from Drake on or after 2022-05-01.</dd></dl>
</li>
</ul>

</div>
</div>
<a id="a789535f4318138071bb47f2ffb265407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789535f4318138071bb47f2ffb265407">&#9670;&nbsp;</a></span>NewNonnegativePolynomial() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> NewNonnegativePolynomial </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gramian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>monomial_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a903fd7b5970fb835030958fe57d8cd6e" title="Returns a pair of nonnegative polynomial p = mᵀQm and the Gramian matrix Q, where m is monomial_basis...">NewNonnegativePolynomial()</a>, except the Gramian matrix Q is an input instead of an output. </p>
<p>Depending on the type of the polynomial, we will impose different constraint on the Gramian matrix.</p><ul>
<li>if type = kSos, we impose the Gramian matrix being positive semidefinite.</li>
<li>if type = kSdsos, we impose the Gramian matrix being scaled diagonally dominant.</li>
<li>if type = kDsos, we impose the Gramian matrix being positive diagonally dominant.(Deprecated.) <dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>Use NewSosPolynomial instead of NewNonnegativePolynomial <br />
 This will be removed from Drake on or after 2022-05-01.</dd></dl>
</li>
</ul>

</div>
</div>
<a id="a60415069ede137e871e1edd1f8194fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60415069ede137e871e1edd1f8194fe2">&#9670;&nbsp;</a></span>NewNonnegativePolynomial() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>&gt; NewNonnegativePolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>indeterminates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a903fd7b5970fb835030958fe57d8cd6e" title="Returns a pair of nonnegative polynomial p = mᵀQm and the Gramian matrix Q, where m is monomial_basis...">NewNonnegativePolynomial()</a>. </p>
<p>Instead of passing the monomial basis, we use a monomial basis that contains all monomials of <code>indeterminates</code> of total order up to <code>degree</code> / 2, hence the returned polynomial p contains all the monomials of <code>indeterminates</code> of total order up to <code>degree</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indeterminates</td><td>All the indeterminates in the polynomial p. </td></tr>
    <tr><td class="paramname">degree</td><td>The polynomial p will contain all the monomials up to order <code>degree</code>. </td></tr>
    <tr><td class="paramname">type</td><td>The type of the nonnegative polynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(p, Q) The polynomial p and the Gramian matrix Q. Q has been added as decision variables to the program. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>degree</code> is a positive even number.(Deprecated.) </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>Use NewSosPolynomial instead of NewNonnegativePolynomial <br />
 This will be removed from Drake on or after 2022-05-01.</dd></dl>

</div>
</div>
<a id="aa65f91d84b3f2f0a5354def05ddb51e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa65f91d84b3f2f0a5354def05ddb51e4">&#9670;&nbsp;</a></span>NewOddDegreeFreePolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> NewOddDegreeFreePolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>indeterminates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>coeff_name</em> = <code>&quot;a&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a free polynomial that only contains odd degree monomials. </p>
<p>A monomial is odd degree if its total degree (sum of all variables' degree) is even. For example, xy is not an odd degree monomial (degree 2) while x²y is (degree 3). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indeterminates</td><td>The monomial basis is over these indeterminates. </td></tr>
    <tr><td class="paramname">degree</td><td>The highest degree of the polynomial. </td></tr>
    <tr><td class="paramname">coeff_name</td><td>The coefficients of the polynomial are decision variables with this name as a base. The variable name would be "a1", "a2", etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abac9dc35b894168d1b1600887bc27bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac9dc35b894168d1b1600887bc27bcd">&#9670;&nbsp;</a></span>NewSosPolynomial() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>&gt; NewSosPolynomial </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>monomial_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pair of a SOS polynomial p = mᵀQm and the Gramian matrix Q, where m is the <code>monomial</code> basis. </p>
<p>For example, <code>NewSosPolynomial(Vector2&lt;Monomial&gt;{x,y})</code> returns a polynomial p = Q₍₀,₀₎x² + 2Q₍₁,₀₎xy + Q₍₁,₁₎y² and Q. Depending on the type of the polynomial, we will impose different constraint on the polynomial.</p><ul>
<li>if type = kSos, we impose the polynomial being SOS.</li>
<li>if type = kSdsos, we impose the polynomial being SDSOS.</li>
<li>if type = kDsos, we impose the polynomial being DSOS. <dl class="section note"><dt>Note</dt><dd>Q is a symmetric monomial_basis.rows() x monomial_basis.rows() matrix. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a9880f907227e7c09b7553f7581351a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9880f907227e7c09b7553f7581351a61">&#9670;&nbsp;</a></span>NewSosPolynomial() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> NewSosPolynomial </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gramian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>monomial_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads NewSosPolynomial, except the Gramian matrix Q is an input instead of an output. </p>

</div>
</div>
<a id="a17696eeb5ed72ea8a4ddcaa732324a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17696eeb5ed72ea8a4ddcaa732324a3e">&#9670;&nbsp;</a></span>NewSosPolynomial() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>, <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a>&gt; NewSosPolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>indeterminates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818">NonnegativePolynomial</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a407fb21fc13a5122994e71a05a6a0818a9214c59b16e91dfc8e167a26028bc076">NonnegativePolynomial::kSos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads NewSosPolynomial. </p>
<p>Returns a pair of a SOS polynomial p = m(x)ᵀQm(x) of degree <code>degree</code> and the Gramian matrix Q that should be PSD, where m(x) is the result of calling <code>MonomialBasis(indeterminates, degree/2)</code>. For example, <code>NewSosPolynomial({x}, 4)</code> returns a pair of a polynomial p = Q₍₀,₀₎x⁴ + 2Q₍₁,₀₎ x³ + (2Q₍₂,₀₎ + Q₍₁,₁₎)x² + 2Q₍₂,₁₎x + Q₍₂,₂₎ and Q. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Depending on the type of the polynomial, we will impose different constraint on the polynomial.<ul>
<li>if type = kSos, we impose the polynomial being SOS.</li>
<li>if type = kSdsos, we impose the polynomial being SDSOS.</li>
<li>if type = kDsos, we impose the polynomial being DSOS.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>degree</code> is not a positive even integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>MonomialBasis. </dd></dl>

</div>
</div>
<a id="a8f718351922bc149cb6e7fa6d82288a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f718351922bc149cb6e7fa6d82288a5">&#9670;&nbsp;</a></span>NewSymmetricContinuousVariables() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> NewSymmetricContinuousVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;Symmetric&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a runtime sized symmetric matrix as decision variables to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </p>
<p>The optimization will only use the stacked columns of the lower triangular part of the symmetric matrix as decision variables. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the symmetric matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the matrix. It is only used the for user to understand the optimization program. The default name is "Symmetric", and each variable will be named as <pre>
Symmetric(0, 0)     Symmetric(1, 0)     ... Symmetric(rows-1, 0)
Symmetric(1, 0)     Symmetric(1, 1)     ... Symmetric(rows-1, 1)
           ...
Symmetric(rows-1,0) Symmetric(rows-1,1) ... Symmetric(rows-1, rows-1)
</pre> Notice that the (i,j)'th entry and (j,i)'th entry has the same name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added decision variables. </dd></dl>

</div>
</div>
<a id="af9a84a217cea56358191de7d25c142c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a84a217cea56358191de7d25c142c0">&#9670;&nbsp;</a></span>NewSymmetricContinuousVariables() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt;rows, rows&gt; NewSymmetricContinuousVariables </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;Symmetric&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a static sized symmetric matrix as decision variables to this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </p>
<p>The optimization will only use the stacked columns of the lower triangular part of the symmetric matrix as decision variables. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the symmetric matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the matrix. It is only used the for user to understand the optimization program. The default name is "Symmetric", and each variable will be named as <pre>
Symmetric(0, 0)     Symmetric(1, 0)     ... Symmetric(rows-1, 0)
Symmetric(1, 0)     Symmetric(1, 1)     ... Symmetric(rows-1, 1)
           ...
Symmetric(rows-1,0) Symmetric(rows-1,1) ... Symmetric(rows-1, rows-1)
</pre> Notice that the (i,j)'th entry and (j,i)'th entry has the same name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added decision variables. </dd></dl>

</div>
</div>
<a id="a3b1e942fc28f03d2b987fc0ea880e831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1e942fc28f03d2b987fc0ea880e831">&#9670;&nbsp;</a></span>num_indeterminates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_indeterminates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of indeterminates in the optimization program. </p>

</div>
</div>
<a id="a224e4c35014e87139f73f9a517866796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224e4c35014e87139f73f9a517866796">&#9670;&nbsp;</a></span>num_vars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_vars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for number of variables in the optimization program. </p>

</div>
</div>
<a id="ad6bf33171369a5b673c956f7e21e1c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6bf33171369a5b673c956f7e21e1c5f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a751cdda7529e03736fc7530fad6bd7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751cdda7529e03736fc7530fad6bd7fa">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a653ebdfdf842cca45abac0c708d1195e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653ebdfdf842cca45abac0c708d1195e">&#9670;&nbsp;</a></span>positive_semidefinite_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a>&gt; &gt;&amp; positive_semidefinite_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for positive semidefinite constraints. </p>

</div>
</div>
<a id="a67254b4fe297880931e6c66562f36353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67254b4fe297880931e6c66562f36353">&#9670;&nbsp;</a></span>quadratic_costs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a>&gt; &gt;&amp; quadratic_costs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for quadratic costs. </p>

</div>
</div>
<a id="acb1b59ceeeec9235267e4a8b6d440c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1b59ceeeec9235267e4a8b6d440c9f">&#9670;&nbsp;</a></span>RemoveConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> RemoveConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes <code>constraint</code> from this mathematical program. </p>
<p>See <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#remove_cost_constraint">Remove costs or constraints</a> for more details. </p><dl class="section return"><dt>Returns</dt><dd>number of constraint objects removed from this program. If this program doesn't contain <code>constraint</code>, then returns 0. If this program contains multiple <code>constraint</code> objects, then returns the repetition of <code>constraint</code> in this program. </dd></dl>

</div>
</div>
<a id="a776ae5f3bb0dc9a705c584e511aff067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776ae5f3bb0dc9a705c584e511aff067">&#9670;&nbsp;</a></span>RemoveCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> RemoveCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cost</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes <code>cost</code> from this mathematical program. </p>
<p>See <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#remove_cost_constraint">Remove costs or constraints</a> for more details. </p><dl class="section return"><dt>Returns</dt><dd>number of cost objects removed from this program. If this program doesn't contain <code>cost</code>, then returns 0. If this program contains multiple <code>cost</code> objects, then returns the repetition of <code>cost</code> in this program. </dd></dl>

</div>
</div>
<a id="aee9493ea7d08a35395634bfbfd5713dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9493ea7d08a35395634bfbfd5713dd">&#9670;&nbsp;</a></span>Reparse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reparses the polynomial <code>p</code> using this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>'s indeterminates. </p>

</div>
</div>
<a id="a2a7f71f7ae23678cd721de4cfcb52f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7f71f7ae23678cd721de4cfcb52f54">&#9670;&nbsp;</a></span>required_capabilities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a>&amp; required_capabilities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the required capability on the solver, given the cost/constraint/variable types in the program. </p>

</div>
</div>
<a id="aeb8ffa00352e1b2d8f1e8cfa720dc88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8ffa00352e1b2d8f1e8cfa720dc88c">&#9670;&nbsp;</a></span>rotated_lorentz_cone_constraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a>&gt; &gt;&amp; rotated_lorentz_cone_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for rotated Lorentz cone constraints. </p>

</div>
</div>
<a id="a65ab51bbb7a7abab25cb23d0f64d80d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ab51bbb7a7abab25cb23d0f64d80d4">&#9670;&nbsp;</a></span>SetDecisionVariableValueInVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetDecisionVariableValueInVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>decision_variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>decision_variable_new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::VectorXd &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the value of a single <code>decision_variable</code> inside the <code>values</code> vector to be <code>decision_variable_new_value</code>. </p>
<p>The other decision variables' values in <code>values</code> are unchanged. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">decision_variable</td><td>a registered decision variable in this program. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">decision_variable_new_value</td><td>the variable's new values. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>The vector to be tweaked; must be of size <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a224e4c35014e87139f73f9a517866796" title="Getter for number of variables in the optimization program.">num_vars()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afff086e342ead2410215c884dfd4e82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff086e342ead2410215c884dfd4e82d">&#9670;&nbsp;</a></span>SetDecisionVariableValueInVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetDecisionVariableValueInVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>decision_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>decision_variables_new_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::VectorXd &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the values of some <code>decision_variables</code> inside the <code>values</code> vector to be <code>decision_variables_new_values</code>. </p>
<p>The other decision variables' values in <code>values</code> are unchanged. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">decision_variables</td><td>registered decision variables in this program. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">decision_variables_new_values</td><td>the variables' respective new values; must have the same rows() and cols() sizes and <code>decision_variables</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>The vector to be tweaked; must be of size <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a224e4c35014e87139f73f9a517866796" title="Getter for number of variables in the optimization program.">num_vars()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae48cb6d2263ccf09e38932dcd27f769f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48cb6d2263ccf09e38932dcd27f769f">&#9670;&nbsp;</a></span>SetInitialGuess() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetInitialGuess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>decision_variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>variable_guess_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the initial guess for a single variable <code>decision_variable</code>. </p>
<p>The guess is stored as part of this program. </p><dl class="section pre"><dt>Precondition</dt><dd>decision_variable is a registered decision variable in the program. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if precondition is not satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6eca61aa09da31d13c9d476cf1b6b760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eca61aa09da31d13c9d476cf1b6b760">&#9670;&nbsp;</a></span>SetInitialGuess() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetInitialGuess </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>decision_variable_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the initial guess for the decision variables stored in <code>decision_variable_mat</code> to be <code>x0</code>. </p>
<p>The guess is stored as part of this program. </p>

</div>
</div>
<a id="ae35679ed5aabea90fcf4ff3b337b44f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35679ed5aabea90fcf4ff3b337b44f5">&#9670;&nbsp;</a></span>SetInitialGuessForAllVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetInitialGuessForAllVariables </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the initial guess for ALL decision variables. </p>
<p>Note that variables begin with a default initial guess of NaN to indicate that no guess is available. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x0</td><td>A vector of appropriate size (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#a224e4c35014e87139f73f9a517866796" title="Getter for number of variables in the optimization program.">num_vars()</a> x 1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77b58f1d09a3aec5918813ba163c1098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b58f1d09a3aec5918813ba163c1098">&#9670;&nbsp;</a></span>SetSolverOption() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetSolverOption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname"><em>solver_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>solver_option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>option_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#set_solver_option">set_solver_option</a> for more details. </p>
<p>Set the double-valued options. </p>

</div>
</div>
<a id="a3aafa15b34bc04d8a3449f39787bc76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aafa15b34bc04d8a3449f39787bc76e">&#9670;&nbsp;</a></span>SetSolverOption() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetSolverOption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname"><em>solver_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>solver_option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>option_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#set_solver_option">set_solver_option</a> for more details. </p>
<p>Set the integer-valued options. </p>

</div>
</div>
<a id="a00b38acbaeb959344b7ef04e84f4c40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b38acbaeb959344b7ef04e84f4c40c">&#9670;&nbsp;</a></span>SetSolverOption() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetSolverOption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname"><em>solver_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>solver_option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>option_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#set_solver_option">set_solver_option</a> for more details. </p>
<p>Set the string-valued options. </p>

</div>
</div>
<a id="aed5ce186e378a8fbf9f0924b2e55994c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5ce186e378a8fbf9f0924b2e55994c">&#9670;&nbsp;</a></span>SetSolverOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetSolverOptions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>solver_options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrite the stored solver options inside <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> with the provided solver options. </p>

</div>
</div>
<a id="af4b4542d7067f6d60ea801b3b00c591f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b4542d7067f6d60ea801b3b00c591f">&#9670;&nbsp;</a></span>SetVariableScaling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetVariableScaling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setter for the scaling <code>s</code> of decision variable <code>var</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>the decision variable to be scaled. </td></tr>
    <tr><td class="paramname">s</td><td>scaling factor (must be positive).</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html#variable_scaling">Variable scaling</a> for more information. </p>

</div>
</div>
<a id="a4737cb6ed52094f3d292e0ed4ca187da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4737cb6ed52094f3d292e0ed4ca187da">&#9670;&nbsp;</a></span>solver_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a>&amp; solver_options </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the solver options stored inside <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </p>

</div>
</div>
<a id="aac993ecccd3d88aafefb6b8e3caa1dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac993ecccd3d88aafefb6b8e3caa1dee">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns string representation of this program, listing the decision variables, costs, and constraints. </p>
<p>Note that by default, we do not require variables to have unique names. Providing useful variable names and calling Evaluator::set_description() to describe the costs and constraints can dramatically improve the readability of the output. See the tutorial <code>debug_mathematical_program.ipynb</code> for more information. </p>

</div>
</div>
<a id="a744f8ed184bc9260b5970f7b8e12812a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744f8ed184bc9260b5970f7b8e12812a">&#9670;&nbsp;</a></span>visualization_callbacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html">VisualizationCallback</a>&gt; &gt;&amp; visualization_callbacks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for all callbacks. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a78994b92c87719287528546dc12538bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78994b92c87719287528546dc12538bb">&#9670;&nbsp;</a></span>kGlobalInfeasibleCost</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double kGlobalInfeasibleCost</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">      std::numeric_limits&lt;double&gt;::infinity()</div></div><!-- fragment -->
<p>The optimal cost is +∞ when the problem is globally infeasible. </p>

</div>
</div>
<a id="ab953e201d71c0ce608e7c95607a4f256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab953e201d71c0ce608e7c95607a4f256">&#9670;&nbsp;</a></span>kUnboundedCost</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double kUnboundedCost</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">      -std::numeric_limits&lt;double&gt;::infinity()</div></div><!-- fragment -->
<p>The optimal cost is -∞ when the problem is unbounded. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/solvers/<a class="el" href="mathematical__program_8h.html">mathematical_program.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- footer -->
<div id="nav-path" class="navpath">
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1solvers.html">solvers</a></li><li class="navelem"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a></li>
  </ul>
</div>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().value = searchBox.searchLabel;
</script>
</body>
</html>
