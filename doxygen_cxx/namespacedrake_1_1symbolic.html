<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake::symbolic Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespacedrake_1_1symbolic.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">drake::symbolic Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:BasisElementGradedReverseLexOrder" id="r_BasisElementGradedReverseLexOrder"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1symbolic_1_1_basis_element_graded_reverse_lex_order.html">BasisElementGradedReverseLexOrder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Graded reverse lexicographic order.  <a href="structdrake_1_1symbolic_1_1_basis_element_graded_reverse_lex_order.html#details">More...</a><br /></td></tr>
<tr class="memitem:BinaryExpressionCell" id="r_BinaryExpressionCell"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_binary_expression_cell.html">BinaryExpressionCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the base class for binary expressions.  <a href="classdrake_1_1symbolic_1_1_binary_expression_cell.html#details">More...</a><br /></td></tr>
<tr class="memitem:ChebyshevBasisElement" id="r_ChebyshevBasisElement"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html" title="ChebyshevBasisElement represents an element of Chebyshev polynomial basis, written as the product of ...">ChebyshevBasisElement</a> represents an element of Chebyshev polynomial basis, written as the product of Chebyshev polynomials, in the form Tₚ₀(x₀)Tₚ₁(x₁)...Tₚₙ(xₙ), where each Tₚᵢ(xᵢ) is a (univariate) Chebyshev polynomial of degree pᵢ.  <a href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html#details">More...</a><br /></td></tr>
<tr class="memitem:ChebyshevPolynomial" id="r_ChebyshevPolynomial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_polynomial.html">ChebyshevPolynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the Chebyshev polynomial of the first kind Tₙ(x).  <a href="classdrake_1_1symbolic_1_1_chebyshev_polynomial.html#details">More...</a><br /></td></tr>
<tr class="memitem:CodeGenVisitor" id="r_CodeGenVisitor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_code_gen_visitor.html">CodeGenVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor class for code generation.  <a href="classdrake_1_1symbolic_1_1_code_gen_visitor.html#details">More...</a><br /></td></tr>
<tr class="memitem:Environment" id="r_Environment"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a symbolic environment (mapping from a variable to a value).  <a href="classdrake_1_1symbolic_1_1_environment.html#details">More...</a><br /></td></tr>
<tr class="memitem:Expression" id="r_Expression"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a symbolic form of an expression.  <a href="classdrake_1_1symbolic_1_1_expression.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionAbs" id="r_ExpressionAbs"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_abs.html">ExpressionAbs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing absolute value function.  <a href="classdrake_1_1symbolic_1_1_expression_abs.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionAcos" id="r_ExpressionAcos"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_acos.html">ExpressionAcos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing arccosine function.  <a href="classdrake_1_1symbolic_1_1_expression_acos.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionAdd" id="r_ExpressionAdd"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html">ExpressionAdd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing an addition which is a sum of products.  <a href="classdrake_1_1symbolic_1_1_expression_add.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionAddFactory" id="r_ExpressionAddFactory"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_add_factory.html">ExpressionAddFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory class to help build <a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html" title="Symbolic expression representing an addition which is a sum of products.">ExpressionAdd</a> expressions.  <a href="classdrake_1_1symbolic_1_1_expression_add_factory.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionAsin" id="r_ExpressionAsin"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_asin.html">ExpressionAsin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing arcsine function.  <a href="classdrake_1_1symbolic_1_1_expression_asin.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionAtan" id="r_ExpressionAtan"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_atan.html">ExpressionAtan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing arctangent function.  <a href="classdrake_1_1symbolic_1_1_expression_atan.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionAtan2" id="r_ExpressionAtan2"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_atan2.html">ExpressionAtan2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing atan2 function (arctangent function with two arguments).  <a href="classdrake_1_1symbolic_1_1_expression_atan2.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionCeiling" id="r_ExpressionCeiling"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_ceiling.html">ExpressionCeiling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing ceil function.  <a href="classdrake_1_1symbolic_1_1_expression_ceiling.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionCell" id="r_ExpressionCell"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an abstract class which is the base of concrete symbolic-expression classes.  <a href="classdrake_1_1symbolic_1_1_expression_cell.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionCos" id="r_ExpressionCos"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_cos.html">ExpressionCos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing cosine function.  <a href="classdrake_1_1symbolic_1_1_expression_cos.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionCosh" id="r_ExpressionCosh"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_cosh.html">ExpressionCosh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing hyperbolic cosine function.  <a href="classdrake_1_1symbolic_1_1_expression_cosh.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionDiv" id="r_ExpressionDiv"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_div.html">ExpressionDiv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing division.  <a href="classdrake_1_1symbolic_1_1_expression_div.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionExp" id="r_ExpressionExp"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_exp.html">ExpressionExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing exponentiation using the base of natural logarithms.  <a href="classdrake_1_1symbolic_1_1_expression_exp.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionFloor" id="r_ExpressionFloor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_floor.html">ExpressionFloor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing floor function.  <a href="classdrake_1_1symbolic_1_1_expression_floor.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionIfThenElse" id="r_ExpressionIfThenElse"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_if_then_else.html">ExpressionIfThenElse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing if-then-else expression.  <a href="classdrake_1_1symbolic_1_1_expression_if_then_else.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionLog" id="r_ExpressionLog"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_log.html">ExpressionLog</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing logarithms.  <a href="classdrake_1_1symbolic_1_1_expression_log.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionMax" id="r_ExpressionMax"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_max.html">ExpressionMax</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing max function.  <a href="classdrake_1_1symbolic_1_1_expression_max.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionMin" id="r_ExpressionMin"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_min.html">ExpressionMin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing min function.  <a href="classdrake_1_1symbolic_1_1_expression_min.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionMul" id="r_ExpressionMul"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html">ExpressionMul</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing a multiplication of powers.  <a href="classdrake_1_1symbolic_1_1_expression_mul.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionMulFactory" id="r_ExpressionMulFactory"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_mul_factory.html">ExpressionMulFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory class to help build <a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html" title="Symbolic expression representing a multiplication of powers.">ExpressionMul</a> expressions.  <a href="classdrake_1_1symbolic_1_1_expression_mul_factory.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionNaN" id="r_ExpressionNaN"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_na_n.html">ExpressionNaN</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing NaN (not-a-number).  <a href="classdrake_1_1symbolic_1_1_expression_na_n.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionPow" id="r_ExpressionPow"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_pow.html">ExpressionPow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing power function.  <a href="classdrake_1_1symbolic_1_1_expression_pow.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionSin" id="r_ExpressionSin"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_sin.html">ExpressionSin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing sine function.  <a href="classdrake_1_1symbolic_1_1_expression_sin.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionSinh" id="r_ExpressionSinh"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_sinh.html">ExpressionSinh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing hyperbolic sine function.  <a href="classdrake_1_1symbolic_1_1_expression_sinh.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionSqrt" id="r_ExpressionSqrt"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_sqrt.html">ExpressionSqrt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing square-root.  <a href="classdrake_1_1symbolic_1_1_expression_sqrt.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionTan" id="r_ExpressionTan"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_tan.html">ExpressionTan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing tangent function.  <a href="classdrake_1_1symbolic_1_1_expression_tan.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionTanh" id="r_ExpressionTanh"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_tanh.html">ExpressionTanh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing hyperbolic tangent function.  <a href="classdrake_1_1symbolic_1_1_expression_tanh.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionUninterpretedFunction" id="r_ExpressionUninterpretedFunction"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html">ExpressionUninterpretedFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing an uninterpreted function.  <a href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionVar" id="r_ExpressionVar"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_var.html">ExpressionVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing a variable.  <a href="classdrake_1_1symbolic_1_1_expression_var.html#details">More...</a><br /></td></tr>
<tr class="memitem:Formula" id="r_Formula"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a symbolic form of a first-order logic formula.  <a href="classdrake_1_1symbolic_1_1_formula.html#details">More...</a><br /></td></tr>
<tr class="memitem:FormulaAnd" id="r_FormulaAnd"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_and.html">FormulaAnd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing conjunctions (f1 ∧ ... ∧ fn).  <a href="classdrake_1_1symbolic_1_1_formula_and.html#details">More...</a><br /></td></tr>
<tr class="memitem:FormulaCell" id="r_FormulaCell"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an abstract class which is the base of concrete symbolic-formula classes (i.e.  <a href="classdrake_1_1symbolic_1_1_formula_cell.html#details">More...</a><br /></td></tr>
<tr class="memitem:FormulaEq" id="r_FormulaEq"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_eq.html">FormulaEq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing equality (e1 = e2).  <a href="classdrake_1_1symbolic_1_1_formula_eq.html#details">More...</a><br /></td></tr>
<tr class="memitem:FormulaFalse" id="r_FormulaFalse"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_false.html">FormulaFalse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing false.  <a href="classdrake_1_1symbolic_1_1_formula_false.html#details">More...</a><br /></td></tr>
<tr class="memitem:FormulaForall" id="r_FormulaForall"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_forall.html">FormulaForall</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing universal quantifications (∀ x₁, ..., * xn.  <a href="classdrake_1_1symbolic_1_1_formula_forall.html#details">More...</a><br /></td></tr>
<tr class="memitem:FormulaGeq" id="r_FormulaGeq"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_geq.html">FormulaGeq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing 'greater-than-or-equal-to' (e1 ≥ e2).  <a href="classdrake_1_1symbolic_1_1_formula_geq.html#details">More...</a><br /></td></tr>
<tr class="memitem:FormulaGt" id="r_FormulaGt"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_gt.html">FormulaGt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing 'greater-than' (e1 &gt; e2).  <a href="classdrake_1_1symbolic_1_1_formula_gt.html#details">More...</a><br /></td></tr>
<tr class="memitem:FormulaIsnan" id="r_FormulaIsnan"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_isnan.html">FormulaIsnan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing isnan predicate.  <a href="classdrake_1_1symbolic_1_1_formula_isnan.html#details">More...</a><br /></td></tr>
<tr class="memitem:FormulaLeq" id="r_FormulaLeq"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_leq.html">FormulaLeq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing 'less-than-or-equal-to' (e1 ≤ e2).  <a href="classdrake_1_1symbolic_1_1_formula_leq.html#details">More...</a><br /></td></tr>
<tr class="memitem:FormulaLt" id="r_FormulaLt"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_lt.html">FormulaLt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing 'less-than' (e1 &lt; e2).  <a href="classdrake_1_1symbolic_1_1_formula_lt.html#details">More...</a><br /></td></tr>
<tr class="memitem:FormulaNeq" id="r_FormulaNeq"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_neq.html">FormulaNeq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing disequality (e1 ≠ e2).  <a href="classdrake_1_1symbolic_1_1_formula_neq.html#details">More...</a><br /></td></tr>
<tr class="memitem:FormulaNot" id="r_FormulaNot"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_not.html">FormulaNot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing negations (¬f).  <a href="classdrake_1_1symbolic_1_1_formula_not.html#details">More...</a><br /></td></tr>
<tr class="memitem:FormulaOr" id="r_FormulaOr"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_or.html">FormulaOr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing disjunctions (f1 ∨ ... ∨ fn).  <a href="classdrake_1_1symbolic_1_1_formula_or.html#details">More...</a><br /></td></tr>
<tr class="memitem:FormulaPositiveSemidefinite" id="r_FormulaPositiveSemidefinite"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_positive_semidefinite.html">FormulaPositiveSemidefinite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing positive-semidefinite (PSD) constraint.  <a href="classdrake_1_1symbolic_1_1_formula_positive_semidefinite.html#details">More...</a><br /></td></tr>
<tr class="memitem:FormulaTrue" id="r_FormulaTrue"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_true.html">FormulaTrue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing true.  <a href="classdrake_1_1symbolic_1_1_formula_true.html#details">More...</a><br /></td></tr>
<tr class="memitem:FormulaVar" id="r_FormulaVar"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_var.html">FormulaVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing a Boolean variable.  <a href="classdrake_1_1symbolic_1_1_formula_var.html#details">More...</a><br /></td></tr>
<tr class="memitem:GenericPolynomial" id="r_GenericPolynomial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents symbolic generic polynomials using a given basis (for example, monomial basis, Chebyshev basis, etc).  <a href="classdrake_1_1symbolic_1_1_generic_polynomial.html#details">More...</a><br /></td></tr>
<tr class="memitem:GradedReverseLexOrder" id="r_GradedReverseLexOrder"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1symbolic_1_1_graded_reverse_lex_order.html">GradedReverseLexOrder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Graded reverse lexicographic order.  <a href="structdrake_1_1symbolic_1_1_graded_reverse_lex_order.html#details">More...</a><br /></td></tr>
<tr class="memitem:Monomial" id="r_Monomial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a monomial, a product of powers of variables with non-negative integer exponents.  <a href="classdrake_1_1symbolic_1_1_monomial.html#details">More...</a><br /></td></tr>
<tr class="memitem:MonomialBasisElement" id="r_MonomialBasisElement"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html" title="MonomialBasisElement represents a monomial, a product of powers of variables with non-negative intege...">MonomialBasisElement</a> represents a monomial, a product of powers of variables with non-negative integer exponents.  <a href="classdrake_1_1symbolic_1_1_monomial_basis_element.html#details">More...</a><br /></td></tr>
<tr class="memitem:NaryFormulaCell" id="r_NaryFormulaCell"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_nary_formula_cell.html">NaryFormulaCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the base class for N-ary logic operators (∧ and ∨).  <a href="classdrake_1_1symbolic_1_1_nary_formula_cell.html#details">More...</a><br /></td></tr>
<tr class="memitem:Polynomial" id="r_Polynomial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents symbolic polynomials.  <a href="classdrake_1_1symbolic_1_1_polynomial.html#details">More...</a><br /></td></tr>
<tr class="memitem:PolynomialBasisElement" id="r_PolynomialBasisElement"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial_basis_element.html">PolynomialBasisElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each polynomial p(x) can be written as a linear combination of its basis elements p(x) = ∑ᵢ cᵢ * ϕᵢ(x), where ϕᵢ(x) is the i'th element in the basis, cᵢ is the coefficient of that element.  <a href="classdrake_1_1symbolic_1_1_polynomial_basis_element.html#details">More...</a><br /></td></tr>
<tr class="memitem:RationalFunction" id="r_RationalFunction"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents symbolic rational function.  <a href="classdrake_1_1symbolic_1_1_rational_function.html#details">More...</a><br /></td></tr>
<tr class="memitem:RelationalFormulaCell" id="r_RelationalFormulaCell"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_relational_formula_cell.html">RelationalFormulaCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the base class for relational operators (==, !=, &lt;, &lt;=, &gt;, &gt;=).  <a href="classdrake_1_1symbolic_1_1_relational_formula_cell.html#details">More...</a><br /></td></tr>
<tr class="memitem:RewritingRule" id="r_RewritingRule"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html">RewritingRule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <span class="tt"><a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html" title="A RewritingRule, lhs =&gt; rhs, consists of two Patterns lhs and rhs.">RewritingRule</a></span>, <span class="tt"><a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html#a591614b343901f3cefb7a99c45a18ece" title="Returns the const reference of the LHS of the rewriting rule.">lhs</a> =&gt; <a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html#a0455cdebb745b731f88f6136f907dfb4" title="Returns the const reference of the RHS of the rewriting rule.">rhs</a></span>, consists of two Patterns <span class="tt"><a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html#a591614b343901f3cefb7a99c45a18ece" title="Returns the const reference of the LHS of the rewriting rule.">lhs</a></span> and <span class="tt"><a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html#a0455cdebb745b731f88f6136f907dfb4" title="Returns the const reference of the RHS of the rewriting rule.">rhs</a></span>.  <a href="classdrake_1_1symbolic_1_1_rewriting_rule.html#details">More...</a><br /></td></tr>
<tr class="memitem:SinCos" id="r_SinCos"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1symbolic_1_1_sin_cos.html">SinCos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a pair of <a class="el" href="classdrake_1_1symbolic_1_1_variables.html" title="Represents a set of variables.">Variables</a> corresponding to sin(q) and cos(q).  <a href="structdrake_1_1symbolic_1_1_sin_cos.html#details">More...</a><br /></td></tr>
<tr class="memitem:UnaryExpressionCell" id="r_UnaryExpressionCell"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_unary_expression_cell.html">UnaryExpressionCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the base class for unary expressions.  <a href="classdrake_1_1symbolic_1_1_unary_expression_cell.html#details">More...</a><br /></td></tr>
<tr class="memitem:Variable" id="r_Variable"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a symbolic variable.  <a href="classdrake_1_1symbolic_1_1_variable.html#details">More...</a><br /></td></tr>
<tr class="memitem:Variables" id="r_Variables"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a set of variables.  <a href="classdrake_1_1symbolic_1_1_variables.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acbfe43d34e6c71c503d4de11da53bbb7" id="r_acbfe43d34e6c71c503d4de11da53bbb7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbfe43d34e6c71c503d4de11da53bbb7">Substitution</a> = std::unordered_map&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;</td></tr>
<tr class="memitem:ab1a5d6781b80333555bde1ed59a38477" id="r_ab1a5d6781b80333555bde1ed59a38477"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:ab1a5d6781b80333555bde1ed59a38477 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a></td></tr>
<tr class="memdesc:ab1a5d6781b80333555bde1ed59a38477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an explicit SFINAE alias for use with return types to dissuade CTAD from trying to instantiate an invalid GenericElement&lt;&gt; for operator overloads, (if that's actually the case).  <br /></td></tr>
<tr class="memitem:aeb27ddf30420e620beb8e6725d83208f" id="r_aeb27ddf30420e620beb8e6725d83208f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb27ddf30420e620beb8e6725d83208f">Pattern</a> = <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a></td></tr>
<tr class="memdesc:aeb27ddf30420e620beb8e6725d83208f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern is an expression which possibly includes variables which represent placeholders.  <br /></td></tr>
<tr class="memitem:a134e54042165751a5e5369b4631c90eb" id="r_a134e54042165751a5e5369b4631c90eb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a134e54042165751a5e5369b4631c90eb">Rewriter</a> = std::function&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>(const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp;)&gt;</td></tr>
<tr class="memdesc:a134e54042165751a5e5369b4631c90eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <span class="tt"><a class="el" href="#a134e54042165751a5e5369b4631c90eb" title="A Rewriter is a function from an Expression to an Expression.">Rewriter</a></span> is a function from an <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">Expression</a> to an <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">Expression</a>.  <br /></td></tr>
<tr class="memitem:a13c5d9eccfc9643fdd5764d6e72b8faf" id="r_a13c5d9eccfc9643fdd5764d6e72b8faf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13c5d9eccfc9643fdd5764d6e72b8faf">SinCosSubstitution</a> = std::unordered_map&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, <a class="el" href="structdrake_1_1symbolic_1_1_sin_cos.html">SinCos</a>&gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a245f75ee96839b12e22fea09c6f3ec91" id="r_a245f75ee96839b12e22fea09c6f3ec91"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91">ExpressionKind</a> : std::uint16_t { <br />
&#160;&#160;<a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91acb17869fe51048b5a5c4c6106551a255">Constant</a> = 0
, <a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91a5a92344ee95acf10c31901b36418be77">Var</a> = 0x7FF1u
, <a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91aec211f7c20af43e742bf2570c3cb84f9">Add</a>
, <a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91a62b6d55816cf737bfc6f42e60df1a3f2">Mul</a>
, <br />
&#160;&#160;<a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91a43d11850893d2fe84a1e618121c1cc0a">Div</a>
, <a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91ace0be71e33226e4c1db2bcea5959f16b">Log</a>
, <a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91a1e34af023adeb7d5f484f8eb4b9826b6">Abs</a>
, <a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91acad39a154bffb61175f674d6eefaf6d0">Exp</a>
, <br />
&#160;&#160;<a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91aae77f3ad25595e35b327334d89410054">Sqrt</a>
, <a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91a8be6d3e955290ee50c00a4bc92aa7749">Pow</a>
, <a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91a0986d137604183312e6d3599578bc6cd">Sin</a>
, <a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91affca562be079b9e4e41ea9d6a86c582b">Cos</a>
, <br />
&#160;&#160;<a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91a1266b4e6f81e60733ec6c717e0181f60">Tan</a>
, <a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91a76cfc54de4e2b9cde17334c821217d11">Asin</a>
, <a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91aed4629033ecb516ed7d1536e162030bb">Acos</a>
, <a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91ac9968ab1fa8103acbb3a4f22265f2def">Atan</a>
, <br />
&#160;&#160;<a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91a5816dfcaf3b6dbb486ef9c8c006ff613">Atan2</a> = 0xFFF1u
, <a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91a98ed804abf4edd1f3be3fa894fa8cc3d">Sinh</a>
, <a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91a4371c3565b771b40c187487cc0190392">Cosh</a>
, <a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91acc132a41cab5676334f353a22a0aa5c5">Tanh</a>
, <br />
&#160;&#160;<a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91a78d811e98514cd165dda532286610fd2">Min</a>
, <a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91a6a061313d22e51e0f25b7cd4dc065233">Max</a>
, <a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91ab95a01ffffa8fcdd2a9af961937c097c">Ceil</a>
, <a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91af3f6d0343d56ce88ce7958170ed05cb3">Floor</a>
, <br />
&#160;&#160;<a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91aaff6933d8331eca27edc911467980c9c">IfThenElse</a>
, <a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91a7ecfb3bf076a6a9635f975fe96ac97fd">NaN</a>
, <a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91a2e59a51ac43bc3415c1b8ce7b3f98579">UninterpretedFunction</a>
<br />
 }</td></tr>
<tr class="memdesc:a245f75ee96839b12e22fea09c6f3ec91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kinds of symbolic expressions.  <a href="#a245f75ee96839b12e22fea09c6f3ec91">More...</a><br /></td></tr>
<tr class="memitem:a6869e7044dd90be5d972ee7dd4e821b6" id="r_a6869e7044dd90be5d972ee7dd4e821b6"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a> { <br />
&#160;&#160;<a class="el" href="#a6869e7044dd90be5d972ee7dd4e821b6af8320b26d30ab433c5a54546d21f414c">False</a>
, <a class="el" href="#a6869e7044dd90be5d972ee7dd4e821b6af827cf462f62848df37c5e1e94a4da74">True</a>
, <a class="el" href="#a6869e7044dd90be5d972ee7dd4e821b6a5a92344ee95acf10c31901b36418be77">Var</a>
, <a class="el" href="#a6869e7044dd90be5d972ee7dd4e821b6a3718b5ecf60aa0dba49e150e96cb1fc3">Eq</a>
, <br />
&#160;&#160;<a class="el" href="#a6869e7044dd90be5d972ee7dd4e821b6ae4ecc5da3c6dbb4448f25990dc609727">Neq</a>
, <a class="el" href="#a6869e7044dd90be5d972ee7dd4e821b6a086cb8308e5a36e7c4ed1f8873ad801f">Gt</a>
, <a class="el" href="#a6869e7044dd90be5d972ee7dd4e821b6a5dabfebb89e6e45a8cf8573d92746ed3">Geq</a>
, <a class="el" href="#a6869e7044dd90be5d972ee7dd4e821b6a50033c15af7795cd6617f117b29d6922">Lt</a>
, <br />
&#160;&#160;<a class="el" href="#a6869e7044dd90be5d972ee7dd4e821b6abe5721bf93d718a79358217ec9b88176">Leq</a>
, <a class="el" href="#a6869e7044dd90be5d972ee7dd4e821b6ac33315685a0cba3ce53be378b3c7874b">And</a>
, <a class="el" href="#a6869e7044dd90be5d972ee7dd4e821b6a3a2d5fe857d8f9541136a124c2edec6c">Or</a>
, <a class="el" href="#a6869e7044dd90be5d972ee7dd4e821b6aa74c05d080620f087c4e523977230666">Not</a>
, <br />
&#160;&#160;<a class="el" href="#a6869e7044dd90be5d972ee7dd4e821b6a43cfe3c750a08acb91df1e3384548078">Forall</a>
, <a class="el" href="#a6869e7044dd90be5d972ee7dd4e821b6afd116e3418522ffc34d7423bc601510d">Isnan</a>
, <a class="el" href="#a6869e7044dd90be5d972ee7dd4e821b6a1fbc164d3e50b7fd20690a21f1b7b2f2">PositiveSemidefinite</a>
<br />
 }</td></tr>
<tr class="memdesc:a6869e7044dd90be5d972ee7dd4e821b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kinds of symbolic formulas.  <a href="#a6869e7044dd90be5d972ee7dd4e821b6">More...</a><br /></td></tr>
<tr class="memitem:a0f7729e9ae50c2b5ca1d86021ad1ae44" id="r_a0f7729e9ae50c2b5ca1d86021ad1ae44"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f7729e9ae50c2b5ca1d86021ad1ae44">SinCosSubstitutionType</a> { <a class="el" href="#a0f7729e9ae50c2b5ca1d86021ad1ae44af4d2017f452ed392e963b2d8ddf591bb">kAngle</a>
, <a class="el" href="#a0f7729e9ae50c2b5ca1d86021ad1ae44aea1eea0840dd2bfd79a5cbfdf49ea143">kHalfAnglePreferSin</a>
, <a class="el" href="#a0f7729e9ae50c2b5ca1d86021ad1ae44acdf5f9e766a4e04d5ac3bf38e82da0f0">kHalfAnglePreferCos</a>
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3c8de394d55df1f6646d10a5ae89d078" id="r_a3c8de394d55df1f6646d10a5ae89d078"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a>, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c8de394d55df1f6646d10a5ae89d078">operator*</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a> &amp;a, const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a> &amp;b)</td></tr>
<tr class="memdesc:a3c8de394d55df1f6646d10a5ae89d078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of two Chebyshev basis elements.  <br /></td></tr>
<tr class="memitem:a84f10ab6930f1ff4b45b06ca3fcd195f" id="r_a84f10ab6930f1ff4b45b06ca3fcd195f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84f10ab6930f1ff4b45b06ca3fcd195f">to_string</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a> &amp;m)</td></tr>
<tr class="memitem:ad33e2289eb5f8ba9d8a286bd6e954001" id="r_ad33e2289eb5f8ba9d8a286bd6e954001"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad33e2289eb5f8ba9d8a286bd6e954001">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a> &amp;m)</td></tr>
<tr class="memdesc:ad33e2289eb5f8ba9d8a286bd6e954001"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr class="memitem:a86cb7ce14b898914868a96cf815611fb" id="r_a86cb7ce14b898914868a96cf815611fb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86cb7ce14b898914868a96cf815611fb">to_string</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_polynomial.html">ChebyshevPolynomial</a> &amp;p)</td></tr>
<tr class="memitem:ad8ca491b4e798266df4f026a079f4418" id="r_ad8ca491b4e798266df4f026a079f4418"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8ca491b4e798266df4f026a079f4418">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_polynomial.html">ChebyshevPolynomial</a> &amp;p)</td></tr>
<tr class="memdesc:ad8ca491b4e798266df4f026a079f4418"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr class="memitem:aced5d6021e6da5973d88a559b59b9c59" id="r_aced5d6021e6da5973d88a559b59b9c59"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aced5d6021e6da5973d88a559b59b9c59">EvaluateChebyshevPolynomial</a> (double var_val, int degree)</td></tr>
<tr class="memdesc:aced5d6021e6da5973d88a559b59b9c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a Chebyshev polynomial at a given value.  <br /></td></tr>
<tr class="memitem:gaa11ee8e11a75ed1fa0f970ed7a547add" id="r_gaa11ee8e11a75ed1fa0f970ed7a547add"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__codegen.html#gaa11ee8e11a75ed1fa0f970ed7a547add">CodeGen</a> (const std::string &amp;function_name, const std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;parameters, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:gaa11ee8e11a75ed1fa0f970ed7a547add"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given symbolic expression <code class="param">e</code>, generates two C functions, <span class="tt">&lt;function_name&gt;</span> and <span class="tt">&lt;function_name&gt;_meta</span>.  <br /></td></tr>
<tr class="memitem:ga6ea9f92ac433622af3395e4b8b175ee2" id="r_ga6ea9f92ac433622af3395e4b8b175ee2"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:ga6ea9f92ac433622af3395e4b8b175ee2 template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__codegen.html#ga6ea9f92ac433622af3395e4b8b175ee2">CodeGen</a> (const std::string &amp;function_name, const std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;parameters, const Eigen::PlainObjectBase&lt; Derived &gt; &amp;M)</td></tr>
<tr class="memdesc:ga6ea9f92ac433622af3395e4b8b175ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given symbolic dense matrix <code class="param">M</code>, generates two C functions, <span class="tt">&lt;function_name&gt;</span> and <span class="tt">&lt;function_name&gt;_meta</span>.  <br /></td></tr>
<tr class="memitem:gaeecd86feb47996f0ae2c3f1f40958676" id="r_gaeecd86feb47996f0ae2c3f1f40958676"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__codegen.html#gaeecd86feb47996f0ae2c3f1f40958676">CodeGen</a> (const std::string &amp;function_name, const std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;parameters, const Eigen::Ref&lt; const Eigen::SparseMatrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Eigen::ColMajor &gt; &gt; &amp;M)</td></tr>
<tr class="memdesc:gaeecd86feb47996f0ae2c3f1f40958676"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given symbolic column-major sparse matrix <code class="param">M</code>, generates two C functions, <span class="tt">&lt;function_name&gt;</span> and <span class="tt">&lt;function_name&gt;_meta</span>.  <br /></td></tr>
<tr class="memitem:aa4051560c8a37770f83160386c2ef480" id="r_aa4051560c8a37770f83160386c2ef480"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4051560c8a37770f83160386c2ef480">IsAffine</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;m, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars)</td></tr>
<tr class="memdesc:aa4051560c8a37770f83160386c2ef480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if every element in <span class="tt">m</span> is affine in <span class="tt">vars</span>.  <br /></td></tr>
<tr class="memitem:a19b26cd2e30ae5f1e86f1649f39f32d6" id="r_a19b26cd2e30ae5f1e86f1649f39f32d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19b26cd2e30ae5f1e86f1649f39f32d6">IsAffine</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;m)</td></tr>
<tr class="memdesc:a19b26cd2e30ae5f1e86f1649f39f32d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if every element in <span class="tt">m</span> is affine.  <br /></td></tr>
<tr class="memitem:a3d65bb35caa2548754aca87d76c33e55" id="r_a3d65bb35caa2548754aca87d76c33e55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d65bb35caa2548754aca87d76c33e55">DecomposeLinearExpressions</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;expressions, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &gt; &amp;vars, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::MatrixXd &gt; M)</td></tr>
<tr class="memdesc:a3d65bb35caa2548754aca87d76c33e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decomposes <code class="param">expressions</code> into <code class="param">M</code> * <code class="param">vars</code>.  <br /></td></tr>
<tr class="memitem:a8bb461d089db5bc37c4510108a616833" id="r_a8bb461d089db5bc37c4510108a616833"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bb461d089db5bc37c4510108a616833">DecomposeAffineExpressions</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;expressions, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &gt; &amp;vars, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::MatrixXd &gt; M, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::VectorXd &gt; v)</td></tr>
<tr class="memdesc:a8bb461d089db5bc37c4510108a616833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decomposes <code class="param">expressions</code> into <code class="param">M</code> * <code class="param">vars</code> + <code class="param">v</code>.  <br /></td></tr>
<tr class="memitem:a474ad60951290be07b6bb8e737d0a5ec" id="r_a474ad60951290be07b6bb8e737d0a5ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a474ad60951290be07b6bb8e737d0a5ec">ExtractAndAppendVariablesFromExpression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; *vars, std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, int &gt; *map_var_to_index)</td></tr>
<tr class="memdesc:a474ad60951290be07b6bb8e737d0a5ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an expression <span class="tt">e</span>, extracts all variables inside <span class="tt">e</span>, appends these variables to <span class="tt">vars</span> if they are not included in <span class="tt">vars</span> yet.  <br /></td></tr>
<tr class="memitem:a50d8d95273e14b9a63bc8d592c382861" id="r_a50d8d95273e14b9a63bc8d592c382861"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;, std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50d8d95273e14b9a63bc8d592c382861">ExtractVariablesFromExpression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a50d8d95273e14b9a63bc8d592c382861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an expression <span class="tt">e</span>, extracts all variables inside <span class="tt">e</span>.  <br /></td></tr>
<tr class="memitem:a98eba0d5094e9e15c3038815b16159e6" id="r_a98eba0d5094e9e15c3038815b16159e6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;, std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">Variable::Id</a>, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98eba0d5094e9e15c3038815b16159e6">ExtractVariablesFromExpression</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;expressions)</td></tr>
<tr class="memdesc:a98eba0d5094e9e15c3038815b16159e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads ExtractVariablesFromExpression but with a vector of expressions.  <br /></td></tr>
<tr class="memitem:a9b2d3a1021e4b76e2644196df9f7a6b9" id="r_a9b2d3a1021e4b76e2644196df9f7a6b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b2d3a1021e4b76e2644196df9f7a6b9">DecomposeQuadraticPolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;poly, const std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, int &gt; &amp;map_var_to_index, Eigen::MatrixXd *Q, Eigen::VectorXd *b, double *c)</td></tr>
<tr class="memdesc:a9b2d3a1021e4b76e2644196df9f7a6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a quadratic polynomial <code class="param">poly</code>, decomposes it into the form 0.5 * x' Q * x + b' * x + c.  <br /></td></tr>
<tr class="memitem:a91f81efc5e997042f4e6f0005a05fc5d" id="r_a91f81efc5e997042f4e6f0005a05fc5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91f81efc5e997042f4e6f0005a05fc5d">DecomposeAffineExpressions</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;v, Eigen::MatrixXd *A, Eigen::VectorXd *b, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; *vars)</td></tr>
<tr class="memdesc:a91f81efc5e997042f4e6f0005a05fc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of affine expressions v, decompose it to  \( v = A vars + b
\).  <br /></td></tr>
<tr class="memitem:a5465afe4a1b0379e8a3f99e507ebfcf7" id="r_a5465afe4a1b0379e8a3f99e507ebfcf7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5465afe4a1b0379e8a3f99e507ebfcf7">DecomposeAffineExpression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, const std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, int &gt; &amp;map_var_to_index, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::RowVectorXd &gt; coeffs, double *constant_term)</td></tr>
<tr class="memdesc:a5465afe4a1b0379e8a3f99e507ebfcf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decomposes an affine combination <code class="param">e</code> = c0 + c1 * v1 + ... cn * vn into the following:  <br /></td></tr>
<tr class="memitem:a2b5d1822f59197807ea089c71ae6e2b8" id="r_a2b5d1822f59197807ea089c71ae6e2b8"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b5d1822f59197807ea089c71ae6e2b8">DecomposeLumpedParameters</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;f, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &gt; &amp;parameters)</td></tr>
<tr class="memdesc:a2b5d1822f59197807ea089c71ae6e2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of Expressions <code class="param">f</code> and a list of <code class="param">parameters</code> we define all additional variables in <code class="param">f</code> to be a vector of "non-parameter variables", n.  <br /></td></tr>
<tr class="memitem:a70b04dbbe04340ba67a5af39b6c0f277" id="r_a70b04dbbe04340ba67a5af39b6c0f277"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; bool, Eigen::MatrixXd, Eigen::VectorXd, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70b04dbbe04340ba67a5af39b6c0f277">DecomposeL2NormExpression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, double psd_tol=1e-8, double coefficient_tol=1e-8)</td></tr>
<tr class="memdesc:a70b04dbbe04340ba67a5af39b6c0f277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decomposes an L2 norm <code class="param">e</code> = |Ax+b|₂ into A, b, and the variable vector x (or returns false if the decomposition is not possible).  <br /></td></tr>
<tr class="memitem:af8fafcceed185abdb6726cbaf4ff3be3" id="r_af8fafcceed185abdb6726cbaf4ff3be3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8fafcceed185abdb6726cbaf4ff3be3">PopulateRandomVariables</a> (<a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> env, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;variables, <a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *random_generator)</td></tr>
<tr class="memdesc:af8fafcceed185abdb6726cbaf4ff3be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the environment <code class="param">env</code> by sampling values for the unassigned random variables in <code class="param">variables</code> using <code class="param">random_generator</code>.  <br /></td></tr>
<tr class="memitem:a3d376b5d0899a705ee72195cde03af1c" id="r_a3d376b5d0899a705ee72195cde03af1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d376b5d0899a705ee72195cde03af1c">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="memitem:af3b7983f85fe6d5d0e6dd623f630cff2" id="r_af3b7983f85fe6d5d0e6dd623f630cff2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3b7983f85fe6d5d0e6dd623f630cff2">operator+=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="memitem:a1474e5a6eadf9c929b552c4a1a774539" id="r_a1474e5a6eadf9c929b552c4a1a774539"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1474e5a6eadf9c929b552c4a1a774539">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memitem:ac7396940e4ad4279f7e7a984305a051a" id="r_ac7396940e4ad4279f7e7a984305a051a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7396940e4ad4279f7e7a984305a051a">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="memitem:a160ea247e390cafd990190196c446785" id="r_a160ea247e390cafd990190196c446785"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a160ea247e390cafd990190196c446785">operator-=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="memitem:ad82a0882a250b686c193c81892f8bf34" id="r_ad82a0882a250b686c193c81892f8bf34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad82a0882a250b686c193c81892f8bf34">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memitem:a3afe6eb8130d59ffeabe0b6dcc382353" id="r_a3afe6eb8130d59ffeabe0b6dcc382353"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3afe6eb8130d59ffeabe0b6dcc382353">operator*</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="memitem:a702e8b7089a5dd3d5cc22f9da154e1b2" id="r_a702e8b7089a5dd3d5cc22f9da154e1b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a702e8b7089a5dd3d5cc22f9da154e1b2">operator*=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="memitem:a9a65c6eae526c1f116f99fa1eba9f73a" id="r_a9a65c6eae526c1f116f99fa1eba9f73a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a65c6eae526c1f116f99fa1eba9f73a">operator/</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="memitem:aa54e8cfb56c376f1e578784d6b68fbf1" id="r_aa54e8cfb56c376f1e578784d6b68fbf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa54e8cfb56c376f1e578784d6b68fbf1">operator/=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="memitem:a1c7c9095542cd5f4ef70f50bca1aab7c" id="r_a1c7c9095542cd5f4ef70f50bca1aab7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c7c9095542cd5f4ef70f50bca1aab7c">log</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memitem:a44e11b5fa4c16951b30b26e43a316569" id="r_a44e11b5fa4c16951b30b26e43a316569"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44e11b5fa4c16951b30b26e43a316569">abs</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memitem:a27e661d9a5f1936f326068b2dea3eecc" id="r_a27e661d9a5f1936f326068b2dea3eecc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27e661d9a5f1936f326068b2dea3eecc">exp</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memitem:a79e1b5d9aadd56991632f40804d4bf93" id="r_a79e1b5d9aadd56991632f40804d4bf93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79e1b5d9aadd56991632f40804d4bf93">sqrt</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memitem:aa57efef61100945c693ecb05dadf6dcf" id="r_aa57efef61100945c693ecb05dadf6dcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa57efef61100945c693ecb05dadf6dcf">pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="memitem:af3cd13d5472028f31c2e70f1b0e08b5d" id="r_af3cd13d5472028f31c2e70f1b0e08b5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3cd13d5472028f31c2e70f1b0e08b5d">sin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memitem:a8d78919127ccba2ba24cdb1b0c57613d" id="r_a8d78919127ccba2ba24cdb1b0c57613d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d78919127ccba2ba24cdb1b0c57613d">cos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memitem:a734f5b457c5a0b898ab8b6f247f0ce76" id="r_a734f5b457c5a0b898ab8b6f247f0ce76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a734f5b457c5a0b898ab8b6f247f0ce76">tan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memitem:a66f66b1d5e15bec4b2b7f12ade1b3094" id="r_a66f66b1d5e15bec4b2b7f12ade1b3094"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66f66b1d5e15bec4b2b7f12ade1b3094">asin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memitem:a008a73e1d2390dc2325d70175fb5410e" id="r_a008a73e1d2390dc2325d70175fb5410e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a008a73e1d2390dc2325d70175fb5410e">acos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memitem:acf24c6f256d7360650cb379c22886409" id="r_acf24c6f256d7360650cb379c22886409"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf24c6f256d7360650cb379c22886409">atan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memitem:a9ddcc51253066082911475e06b0ac994" id="r_a9ddcc51253066082911475e06b0ac994"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ddcc51253066082911475e06b0ac994">atan2</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="memitem:aa5f5c9f26be9d9eef2784073ac8075e0" id="r_aa5f5c9f26be9d9eef2784073ac8075e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5f5c9f26be9d9eef2784073ac8075e0">sinh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memitem:a27a345a84e6b273a71aa02ee312f9c51" id="r_a27a345a84e6b273a71aa02ee312f9c51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27a345a84e6b273a71aa02ee312f9c51">cosh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memitem:ae96194d93ad39bcb2b7ed22891f44ec7" id="r_ae96194d93ad39bcb2b7ed22891f44ec7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae96194d93ad39bcb2b7ed22891f44ec7">tanh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memitem:a1f18b20230d6fd5d6a2c81a278a89edc" id="r_a1f18b20230d6fd5d6a2c81a278a89edc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f18b20230d6fd5d6a2c81a278a89edc">min</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="memitem:aa951d192140621a51f31d68ead6f3e4d" id="r_aa951d192140621a51f31d68ead6f3e4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa951d192140621a51f31d68ead6f3e4d">max</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="memitem:ad62c6b17ca0d4f9bbbefe1aff58d46ca" id="r_ad62c6b17ca0d4f9bbbefe1aff58d46ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad62c6b17ca0d4f9bbbefe1aff58d46ca">clamp</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;v, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;lo, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;hi)</td></tr>
<tr class="memitem:a2e5ea5116992b4f695c16ad0f297686b" id="r_a2e5ea5116992b4f695c16ad0f297686b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e5ea5116992b4f695c16ad0f297686b">ceil</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memitem:a08cadfe5adda620a40258a84d87081f4" id="r_a08cadfe5adda620a40258a84d87081f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08cadfe5adda620a40258a84d87081f4">floor</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memitem:adb59d484cb2b6737923c9b53e0ec432c" id="r_adb59d484cb2b6737923c9b53e0ec432c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb59d484cb2b6737923c9b53e0ec432c">if_then_else</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f_cond, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e_then, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e_else)</td></tr>
<tr class="memitem:a11eb904ad30c23a3a54c95c38c2f294c" id="r_a11eb904ad30c23a3a54c95c38c2f294c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11eb904ad30c23a3a54c95c38c2f294c">uninterpreted_function</a> (std::string name, std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; arguments)</td></tr>
<tr class="memdesc:a11eb904ad30c23a3a54c95c38c2f294c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an uninterpreted-function expression with <code class="param">name</code> and <code class="param">arguments</code>.  <br /></td></tr>
<tr class="memitem:ac36260fe42c812627ad0979214777e5b" id="r_ac36260fe42c812627ad0979214777e5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac36260fe42c812627ad0979214777e5b">swap</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;a, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;b)</td></tr>
<tr class="memitem:af6ea3eaf1a7e5beed8feb1c401d51bbc" id="r_af6ea3eaf1a7e5beed8feb1c401d51bbc"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6ea3eaf1a7e5beed8feb1c401d51bbc">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memitem:acef926e653145a96fc31416c85e20c14" id="r_acef926e653145a96fc31416c85e20c14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acef926e653145a96fc31416c85e20c14">is_constant</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:acef926e653145a96fc31416c85e20c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is a constant expression.  <br /></td></tr>
<tr class="memitem:abefc608adef6255f93f6aecf809a8b11" id="r_abefc608adef6255f93f6aecf809a8b11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abefc608adef6255f93f6aecf809a8b11">is_constant</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, double v)</td></tr>
<tr class="memdesc:abefc608adef6255f93f6aecf809a8b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is a constant expression representing <code class="param">v</code>.  <br /></td></tr>
<tr class="memitem:a07f09fda9abe80d7b775527445374c06" id="r_a07f09fda9abe80d7b775527445374c06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07f09fda9abe80d7b775527445374c06">is_zero</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a07f09fda9abe80d7b775527445374c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is 0.0.  <br /></td></tr>
<tr class="memitem:a28f3f42c88b77cf4893385a7a093087c" id="r_a28f3f42c88b77cf4893385a7a093087c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28f3f42c88b77cf4893385a7a093087c">is_one</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a28f3f42c88b77cf4893385a7a093087c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is 1.0.  <br /></td></tr>
<tr class="memitem:a4707946faf3b330e3bce6702cf48b2dd" id="r_a4707946faf3b330e3bce6702cf48b2dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4707946faf3b330e3bce6702cf48b2dd">is_neg_one</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a4707946faf3b330e3bce6702cf48b2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is -1.0.  <br /></td></tr>
<tr class="memitem:a1e9232608f43a586aad546b2a078aeb0" id="r_a1e9232608f43a586aad546b2a078aeb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e9232608f43a586aad546b2a078aeb0">is_two</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a1e9232608f43a586aad546b2a078aeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is 2.0.  <br /></td></tr>
<tr class="memitem:a56597943e81b4b1cb898816104662a16" id="r_a56597943e81b4b1cb898816104662a16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56597943e81b4b1cb898816104662a16">is_nan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a56597943e81b4b1cb898816104662a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is NaN.  <br /></td></tr>
<tr class="memitem:a3313ad6342effa904bba98f1ef811902" id="r_a3313ad6342effa904bba98f1ef811902"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3313ad6342effa904bba98f1ef811902">is_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a3313ad6342effa904bba98f1ef811902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is a variable expression.  <br /></td></tr>
<tr class="memitem:a5b8a1e5e59b460cac7c2d8b5cb1e172c" id="r_a5b8a1e5e59b460cac7c2d8b5cb1e172c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b8a1e5e59b460cac7c2d8b5cb1e172c">is_addition</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a5b8a1e5e59b460cac7c2d8b5cb1e172c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is an addition expression.  <br /></td></tr>
<tr class="memitem:ad1f74bcd66ba02bc91f3434924a6c8a2" id="r_ad1f74bcd66ba02bc91f3434924a6c8a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1f74bcd66ba02bc91f3434924a6c8a2">is_multiplication</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ad1f74bcd66ba02bc91f3434924a6c8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is a multiplication expression.  <br /></td></tr>
<tr class="memitem:ab069e1d04f34ba9f9eff1ee8e97cca6e" id="r_ab069e1d04f34ba9f9eff1ee8e97cca6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab069e1d04f34ba9f9eff1ee8e97cca6e">is_division</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ab069e1d04f34ba9f9eff1ee8e97cca6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is a division expression.  <br /></td></tr>
<tr class="memitem:ab049cfca69564b8713a3fd0a0e3bbba9" id="r_ab049cfca69564b8713a3fd0a0e3bbba9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab049cfca69564b8713a3fd0a0e3bbba9">is_log</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ab049cfca69564b8713a3fd0a0e3bbba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is a log expression.  <br /></td></tr>
<tr class="memitem:ab6046c9bad9a1c5a1ba51ec6157376c3" id="r_ab6046c9bad9a1c5a1ba51ec6157376c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6046c9bad9a1c5a1ba51ec6157376c3">is_abs</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ab6046c9bad9a1c5a1ba51ec6157376c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is an abs expression.  <br /></td></tr>
<tr class="memitem:a77a9ff7a7f105a0e9edf77cace06d9e9" id="r_a77a9ff7a7f105a0e9edf77cace06d9e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77a9ff7a7f105a0e9edf77cace06d9e9">is_exp</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a77a9ff7a7f105a0e9edf77cace06d9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is an exp expression.  <br /></td></tr>
<tr class="memitem:ad88aa92c34154f228b7609c0a1e1f0ef" id="r_ad88aa92c34154f228b7609c0a1e1f0ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad88aa92c34154f228b7609c0a1e1f0ef">is_sqrt</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ad88aa92c34154f228b7609c0a1e1f0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is a square-root expression.  <br /></td></tr>
<tr class="memitem:aa8204863236e57c7a074fb90bceb61a1" id="r_aa8204863236e57c7a074fb90bceb61a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8204863236e57c7a074fb90bceb61a1">is_pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aa8204863236e57c7a074fb90bceb61a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is a power-function expression.  <br /></td></tr>
<tr class="memitem:a1af6fb7d06debf378b3a7446f7ad6f26" id="r_a1af6fb7d06debf378b3a7446f7ad6f26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1af6fb7d06debf378b3a7446f7ad6f26">is_sin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a1af6fb7d06debf378b3a7446f7ad6f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is a sine expression.  <br /></td></tr>
<tr class="memitem:a1ad1d934168832dc9e42cc388cdaccca" id="r_a1ad1d934168832dc9e42cc388cdaccca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ad1d934168832dc9e42cc388cdaccca">is_cos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a1ad1d934168832dc9e42cc388cdaccca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is a cosine expression.  <br /></td></tr>
<tr class="memitem:aa4a2c288d79cc175a23093bfe33a033a" id="r_aa4a2c288d79cc175a23093bfe33a033a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4a2c288d79cc175a23093bfe33a033a">is_tan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aa4a2c288d79cc175a23093bfe33a033a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is a tangent expression.  <br /></td></tr>
<tr class="memitem:a55b4c96682d9db457216b967fe589b0f" id="r_a55b4c96682d9db457216b967fe589b0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55b4c96682d9db457216b967fe589b0f">is_asin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a55b4c96682d9db457216b967fe589b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is an arcsine expression.  <br /></td></tr>
<tr class="memitem:a40a4e8165bee3d62bd4df8a68226098c" id="r_a40a4e8165bee3d62bd4df8a68226098c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40a4e8165bee3d62bd4df8a68226098c">is_acos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a40a4e8165bee3d62bd4df8a68226098c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is an arccosine expression.  <br /></td></tr>
<tr class="memitem:a8137a62cd95401854de0b108ceb9ad6b" id="r_a8137a62cd95401854de0b108ceb9ad6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8137a62cd95401854de0b108ceb9ad6b">is_atan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a8137a62cd95401854de0b108ceb9ad6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is an arctangent expression.  <br /></td></tr>
<tr class="memitem:a623309330fb0ecf31d8d9607e9da1215" id="r_a623309330fb0ecf31d8d9607e9da1215"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a623309330fb0ecf31d8d9607e9da1215">is_atan2</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a623309330fb0ecf31d8d9607e9da1215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is an arctangent2 expression.  <br /></td></tr>
<tr class="memitem:a4e18537f0fba7c1c6c87b20644caf9af" id="r_a4e18537f0fba7c1c6c87b20644caf9af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e18537f0fba7c1c6c87b20644caf9af">is_sinh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a4e18537f0fba7c1c6c87b20644caf9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is a hyperbolic-sine expression.  <br /></td></tr>
<tr class="memitem:ab296e6587d7bf86a4f1b54b5005df4a6" id="r_ab296e6587d7bf86a4f1b54b5005df4a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab296e6587d7bf86a4f1b54b5005df4a6">is_cosh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ab296e6587d7bf86a4f1b54b5005df4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is a hyperbolic-cosine expression.  <br /></td></tr>
<tr class="memitem:aabae426c9b32ec48a5655f1e2bafd44c" id="r_aabae426c9b32ec48a5655f1e2bafd44c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabae426c9b32ec48a5655f1e2bafd44c">is_tanh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aabae426c9b32ec48a5655f1e2bafd44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is a hyperbolic-tangent expression.  <br /></td></tr>
<tr class="memitem:ad138a32ee051ed06353da9b4d26374ed" id="r_ad138a32ee051ed06353da9b4d26374ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad138a32ee051ed06353da9b4d26374ed">is_min</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ad138a32ee051ed06353da9b4d26374ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is a min expression.  <br /></td></tr>
<tr class="memitem:a30f8d47e7843b3aabbe95d6651b7c85f" id="r_a30f8d47e7843b3aabbe95d6651b7c85f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30f8d47e7843b3aabbe95d6651b7c85f">is_max</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a30f8d47e7843b3aabbe95d6651b7c85f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is a max expression.  <br /></td></tr>
<tr class="memitem:af208e5f109a14eae18e12eb779e11c28" id="r_af208e5f109a14eae18e12eb779e11c28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af208e5f109a14eae18e12eb779e11c28">is_ceil</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:af208e5f109a14eae18e12eb779e11c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is a ceil expression.  <br /></td></tr>
<tr class="memitem:a2fc1f48deb39118a12ed30496c2a0a33" id="r_a2fc1f48deb39118a12ed30496c2a0a33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fc1f48deb39118a12ed30496c2a0a33">is_floor</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a2fc1f48deb39118a12ed30496c2a0a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is a floor expression.  <br /></td></tr>
<tr class="memitem:a5490fa85a0978930d5966dad1c6ba54b" id="r_a5490fa85a0978930d5966dad1c6ba54b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5490fa85a0978930d5966dad1c6ba54b">is_if_then_else</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a5490fa85a0978930d5966dad1c6ba54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is an if-then-else expression.  <br /></td></tr>
<tr class="memitem:aa19665aa37ff4c0aff7aa1ca142eff46" id="r_aa19665aa37ff4c0aff7aa1ca142eff46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa19665aa37ff4c0aff7aa1ca142eff46">is_uninterpreted_function</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aa19665aa37ff4c0aff7aa1ca142eff46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">e</code> is an uninterpreted-function expression.  <br /></td></tr>
<tr class="memitem:a5165b4cdadcd273d3faad9dffd2bcc7e" id="r_a5165b4cdadcd273d3faad9dffd2bcc7e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5165b4cdadcd273d3faad9dffd2bcc7e">get_constant_value</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a5165b4cdadcd273d3faad9dffd2bcc7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant value of the constant expression <code class="param">e</code>.  <br /></td></tr>
<tr class="memitem:af3d53e917f4fd1da3301aa00ee90bb8b" id="r_af3d53e917f4fd1da3301aa00ee90bb8b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3d53e917f4fd1da3301aa00ee90bb8b">get_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:af3d53e917f4fd1da3301aa00ee90bb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the embedded variable in the variable expression <code class="param">e</code>.  <br /></td></tr>
<tr class="memitem:a3445a75a8296154f264bf7177f9e85ab" id="r_a3445a75a8296154f264bf7177f9e85ab"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3445a75a8296154f264bf7177f9e85ab">get_argument</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a3445a75a8296154f264bf7177f9e85ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the argument in the unary expression <code class="param">e</code>.  <br /></td></tr>
<tr class="memitem:a447067b42b3ed05358bbbbf227e4d1d8" id="r_a447067b42b3ed05358bbbbf227e4d1d8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a447067b42b3ed05358bbbbf227e4d1d8">get_first_argument</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a447067b42b3ed05358bbbbf227e4d1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first argument of the binary expression <code class="param">e</code>.  <br /></td></tr>
<tr class="memitem:a4e891509f0e836fd647f1ea1d8e9f86b" id="r_a4e891509f0e836fd647f1ea1d8e9f86b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e891509f0e836fd647f1ea1d8e9f86b">get_second_argument</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a4e891509f0e836fd647f1ea1d8e9f86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the second argument of the binary expression <code class="param">e</code>.  <br /></td></tr>
<tr class="memitem:a657fe44ab4b095f9603a3c9429098981" id="r_a657fe44ab4b095f9603a3c9429098981"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a657fe44ab4b095f9603a3c9429098981">get_constant_in_addition</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a657fe44ab4b095f9603a3c9429098981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant part of the addition expression <code class="param">e</code>.  <br /></td></tr>
<tr class="memitem:a0c96dfd079cf8490a85e9f087f6aab2d" id="r_a0c96dfd079cf8490a85e9f087f6aab2d"><td class="memItemLeft" align="right" valign="top">const std::map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c96dfd079cf8490a85e9f087f6aab2d">get_expr_to_coeff_map_in_addition</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a0c96dfd079cf8490a85e9f087f6aab2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map from an expression to its coefficient in the addition expression <code class="param">e</code>.  <br /></td></tr>
<tr class="memitem:ae1f447c509e16ebf85df16216af97882" id="r_ae1f447c509e16ebf85df16216af97882"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1f447c509e16ebf85df16216af97882">get_constant_in_multiplication</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ae1f447c509e16ebf85df16216af97882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant part of the multiplication expression <code class="param">e</code>.  <br /></td></tr>
<tr class="memitem:a9abf9c0b485045bd9a88c6bda2706e3d" id="r_a9abf9c0b485045bd9a88c6bda2706e3d"><td class="memItemLeft" align="right" valign="top">const std::map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9abf9c0b485045bd9a88c6bda2706e3d">get_base_to_exponent_map_in_multiplication</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a9abf9c0b485045bd9a88c6bda2706e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map from a base expression to its exponent expression in the multiplication expression <code class="param">e</code>.  <br /></td></tr>
<tr class="memitem:a0a54f523f3f3f991c16bea9f3466e2d5" id="r_a0a54f523f3f3f991c16bea9f3466e2d5"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a54f523f3f3f991c16bea9f3466e2d5">get_uninterpreted_function_name</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a0a54f523f3f3f991c16bea9f3466e2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of an uninterpreted-function expression <code class="param">e</code>.  <br /></td></tr>
<tr class="memitem:a8d4249d71cfbc5fe0260cd14fdc4bcf0" id="r_a8d4249d71cfbc5fe0260cd14fdc4bcf0"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d4249d71cfbc5fe0260cd14fdc4bcf0">get_uninterpreted_function_arguments</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a8d4249d71cfbc5fe0260cd14fdc4bcf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the arguments of an uninterpreted-function expression <code class="param">e</code>.  <br /></td></tr>
<tr class="memitem:a90e045ae61515d2b1a9206abc2ca5412" id="r_a90e045ae61515d2b1a9206abc2ca5412"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90e045ae61515d2b1a9206abc2ca5412">get_conditional_formula</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a90e045ae61515d2b1a9206abc2ca5412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conditional formula in the if-then-else expression <code class="param">e</code>.  <br /></td></tr>
<tr class="memitem:a4fc636cd4593a513941cc0431eb086e2" id="r_a4fc636cd4593a513941cc0431eb086e2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fc636cd4593a513941cc0431eb086e2">get_then_expression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a4fc636cd4593a513941cc0431eb086e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 'then' expression in the if-then-else expression <code class="param">e</code>.  <br /></td></tr>
<tr class="memitem:a93333785c7a6b3a8cf3b517eadaf982a" id="r_a93333785c7a6b3a8cf3b517eadaf982a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93333785c7a6b3a8cf3b517eadaf982a">get_else_expression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a93333785c7a6b3a8cf3b517eadaf982a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 'else' expression in the if-then-else expression <code class="param">e</code>.  <br /></td></tr>
<tr class="memitem:a62cd62f14d17b199df485d5a4c2c976a" id="r_a62cd62f14d17b199df485d5a4c2c976a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62cd62f14d17b199df485d5a4c2c976a">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="memitem:a95dd79861957477e088534110c2604a1" id="r_a95dd79861957477e088534110c2604a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95dd79861957477e088534110c2604a1">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="memitem:abd176811046c1f4fab6d56404b270d66" id="r_abd176811046c1f4fab6d56404b270d66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd176811046c1f4fab6d56404b270d66">TaylorExpand</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;f, const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;a, int order)</td></tr>
<tr class="memdesc:abd176811046c1f4fab6d56404b270d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Taylor series expansion of <span class="tt">f</span> around <span class="tt">a</span> of order <span class="tt">order</span>.  <br /></td></tr>
<tr class="memitem:a0d0aa159235b47cd34fba5759eaaf194" id="r_a0d0aa159235b47cd34fba5759eaaf194"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL, typename MatrixR&gt; </td></tr>
<tr class="memitem:a0d0aa159235b47cd34fba5759eaaf194 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, double &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d0aa159235b47cd34fba5759eaaf194">operator*</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:a0d0aa159235b47cd34fba5759eaaf194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following matrix operations:  <br /></td></tr>
<tr class="memitem:a6e1d7fdaf7c05721d6bb5c790ee8f734" id="r_a6e1d7fdaf7c05721d6bb5c790ee8f734"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL, typename MatrixR&gt; </td></tr>
<tr class="memitem:a6e1d7fdaf7c05721d6bb5c790ee8f734 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, double &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e1d7fdaf7c05721d6bb5c790ee8f734">operator*</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:a6e1d7fdaf7c05721d6bb5c790ee8f734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following matrix operations:  <br /></td></tr>
<tr class="memitem:ab2ea62b60a8dab79d3121862b48692ac" id="r_ab2ea62b60a8dab79d3121862b48692ac"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL, typename MatrixR&gt; </td></tr>
<tr class="memitem:ab2ea62b60a8dab79d3121862b48692ac template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2ea62b60a8dab79d3121862b48692ac">operator*</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:ab2ea62b60a8dab79d3121862b48692ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following matrix operations:  <br /></td></tr>
<tr class="memitem:a26e0be383a80c0ba1f0bdc6788a9d938" id="r_a26e0be383a80c0ba1f0bdc6788a9d938"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL, typename MatrixR&gt; </td></tr>
<tr class="memitem:a26e0be383a80c0ba1f0bdc6788a9d938 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26e0be383a80c0ba1f0bdc6788a9d938">operator*</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:a26e0be383a80c0ba1f0bdc6788a9d938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following matrix operations:  <br /></td></tr>
<tr class="memitem:a0f4d385b974644173b82afae8298cde3" id="r_a0f4d385b974644173b82afae8298cde3"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL, typename MatrixR&gt; </td></tr>
<tr class="memitem:a0f4d385b974644173b82afae8298cde3 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, double &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f4d385b974644173b82afae8298cde3">operator*</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:a0f4d385b974644173b82afae8298cde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following matrix operations:  <br /></td></tr>
<tr class="memitem:a32fa8a1e572d7ca5513a7046540191e4" id="r_a32fa8a1e572d7ca5513a7046540191e4"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL, typename MatrixR&gt; </td></tr>
<tr class="memitem:a32fa8a1e572d7ca5513a7046540191e4 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, double &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32fa8a1e572d7ca5513a7046540191e4">operator*</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:a32fa8a1e572d7ca5513a7046540191e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following matrix operations:  <br /></td></tr>
<tr class="memitem:aaaa40522735a8ab22bee50d971abd7c2" id="r_aaaa40522735a8ab22bee50d971abd7c2"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL, typename MatrixR&gt; </td></tr>
<tr class="memitem:aaaa40522735a8ab22bee50d971abd7c2 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaaa40522735a8ab22bee50d971abd7c2">operator*</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:aaaa40522735a8ab22bee50d971abd7c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following matrix operations:  <br /></td></tr>
<tr class="memitem:a49df60ca05e93c468b6a8d6abe2cb36f" id="r_a49df60ca05e93c468b6a8d6abe2cb36f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL, typename MatrixR&gt; </td></tr>
<tr class="memitem:a49df60ca05e93c468b6a8d6abe2cb36f template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49df60ca05e93c468b6a8d6abe2cb36f">operator*</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:a49df60ca05e93c468b6a8d6abe2cb36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following matrix operations:  <br /></td></tr>
<tr class="memitem:a2f3f93c98fa5f5179d7c50685f332e3d" id="r_a2f3f93c98fa5f5179d7c50685f332e3d"><td class="memTemplParams" colspan="2">template&lt;int Dim, int LhsMode, int RhsMode, int LhsOptions, int RhsOptions&gt; </td></tr>
<tr class="memitem:a2f3f93c98fa5f5179d7c50685f332e3d template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f3f93c98fa5f5179d7c50685f332e3d">operator*</a> (const Eigen::Transform&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Dim, LhsMode, LhsOptions &gt; &amp;t1, const Eigen::Transform&lt; double, Dim, RhsMode, RhsOptions &gt; &amp;t2)</td></tr>
<tr class="memdesc:a2f3f93c98fa5f5179d7c50685f332e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform&lt;double&gt; * Transform&lt;Expression&gt; =&gt; Transform&lt;Expression&gt;.  <br /></td></tr>
<tr class="memitem:ae55638160eeaa986a98f80775f603f1a" id="r_ae55638160eeaa986a98f80775f603f1a"><td class="memTemplParams" colspan="2">template&lt;int Dim, int LhsMode, int RhsMode, int LhsOptions, int RhsOptions&gt; </td></tr>
<tr class="memitem:ae55638160eeaa986a98f80775f603f1a template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae55638160eeaa986a98f80775f603f1a">operator*</a> (const Eigen::Transform&lt; double, Dim, LhsMode, LhsOptions &gt; &amp;t1, const Eigen::Transform&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Dim, RhsMode, RhsOptions &gt; &amp;t2)</td></tr>
<tr class="memdesc:ae55638160eeaa986a98f80775f603f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform&lt;Expression&gt; * Transform&lt;double&gt; =&gt; Transform&lt;Expression&gt;.  <br /></td></tr>
<tr class="memitem:a58c00a140ffd74ecb1b06db9ad425e29" id="r_a58c00a140ffd74ecb1b06db9ad425e29"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a58c00a140ffd74ecb1b06db9ad425e29 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, <a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; double, Derived &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58c00a140ffd74ecb1b06db9ad425e29">Evaluate</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;env=<a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a>{}, <a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *random_generator=nullptr)</td></tr>
<tr class="memdesc:a58c00a140ffd74ecb1b06db9ad425e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a symbolic matrix <code class="param">m</code> using <code class="param">env</code> and <code class="param">random_generator</code>.  <br /></td></tr>
<tr class="memitem:a09b9bc7afd420d9f8f438caf34e503b9" id="r_a09b9bc7afd420d9f8f438caf34e503b9"><td class="memItemLeft" align="right" valign="top">Eigen::SparseMatrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09b9bc7afd420d9f8f438caf34e503b9">Evaluate</a> (const Eigen::Ref&lt; const Eigen::SparseMatrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;m, const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;env=<a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a>{})</td></tr>
<tr class="memdesc:a09b9bc7afd420d9f8f438caf34e503b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates <code class="param">m</code> using a given environment (by default, an empty environment).  <br /></td></tr>
<tr class="memitem:a658c0fc2151b55cdcce0d1375890f6a3" id="r_a658c0fc2151b55cdcce0d1375890f6a3"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a658c0fc2151b55cdcce0d1375890f6a3 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a658c0fc2151b55cdcce0d1375890f6a3">Substitute</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const <a class="el" href="#acbfe43d34e6c71c503d4de11da53bbb7">Substitution</a> &amp;subst)</td></tr>
<tr class="memdesc:a658c0fc2151b55cdcce0d1375890f6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes a symbolic matrix <code class="param">m</code> using a given substitution <code class="param">subst</code>.  <br /></td></tr>
<tr class="memitem:aa5081dc3c7c801e707310141c8944f15" id="r_aa5081dc3c7c801e707310141c8944f15"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:aa5081dc3c7c801e707310141c8944f15 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5081dc3c7c801e707310141c8944f15">Substitute</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aa5081dc3c7c801e707310141c8944f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes <code class="param">var</code> with <code class="param">e</code> in a symbolic matrix <code class="param">m</code>.  <br /></td></tr>
<tr class="memitem:adf71bc1325f5e381cd96a9fc952f3485" id="r_adf71bc1325f5e381cd96a9fc952f3485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf71bc1325f5e381cd96a9fc952f3485">GetVariableVector</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;expressions)</td></tr>
<tr class="memdesc:adf71bc1325f5e381cd96a9fc952f3485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a vector of variables from the vector of variable expressions.  <br /></td></tr>
<tr class="memitem:a8f7f698709e6838fff06fe4b668263f0" id="r_a8f7f698709e6838fff06fe4b668263f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f7f698709e6838fff06fe4b668263f0">Jacobian</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;f, const std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:a8f7f698709e6838fff06fe4b668263f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian matrix J of the vector function <code class="param">f</code> with respect to <code class="param">vars</code>.  <br /></td></tr>
<tr class="memitem:a1c77acbc22041eabb6c243ba5e09ea4a" id="r_a1c77acbc22041eabb6c243ba5e09ea4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c77acbc22041eabb6c243ba5e09ea4a">Jacobian</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;f, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &gt; &amp;vars)</td></tr>
<tr class="memdesc:a1c77acbc22041eabb6c243ba5e09ea4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian matrix J of the vector function <code class="param">f</code> with respect to <code class="param">vars</code>.  <br /></td></tr>
<tr class="memitem:a3893c42663dcc49584d831c5ab23fef5" id="r_a3893c42663dcc49584d831c5ab23fef5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3893c42663dcc49584d831c5ab23fef5">GetDistinctVariables</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;v)</td></tr>
<tr class="memdesc:a3893c42663dcc49584d831c5ab23fef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distinct variables in the matrix of expressions.  <br /></td></tr>
<tr class="memitem:a1616e76093d11cfcac6a6f14d399cc9a" id="r_a1616e76093d11cfcac6a6f14d399cc9a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a1616e76093d11cfcac6a6f14d399cc9a template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; DerivedA &gt;, DerivedA &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; DerivedB &gt;, DerivedB &gt; &amp;&amp;std::is_same_v&lt; typename DerivedA::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&amp;std::is_same_v&lt; typename DerivedB::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1616e76093d11cfcac6a6f14d399cc9a">CheckStructuralEquality</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:a1616e76093d11cfcac6a6f14d399cc9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two Eigen::Matrix&lt;Expression&gt; <code class="param">m1</code> and <code class="param">m2</code> are structurally equal.  <br /></td></tr>
<tr class="memitem:a41fa4f6294d582b138b5879c7d8da160" id="r_a41fa4f6294d582b138b5879c7d8da160"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41fa4f6294d582b138b5879c7d8da160">is_integer</a> (double v)</td></tr>
<tr class="memitem:a94fa08146a43d6256435dba24f608bcd" id="r_a94fa08146a43d6256435dba24f608bcd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94fa08146a43d6256435dba24f608bcd">is_positive_integer</a> (double v)</td></tr>
<tr class="memitem:aa3adfd829d909bb71fce5624c2866e6c" id="r_aa3adfd829d909bb71fce5624c2866e6c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3adfd829d909bb71fce5624c2866e6c">is_non_negative_integer</a> (double v)</td></tr>
<tr class="memitem:a1044a1ad5d60045c18502cec5121149c" id="r_a1044a1ad5d60045c18502cec5121149c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1044a1ad5d60045c18502cec5121149c">is_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a1044a1ad5d60045c18502cec5121149c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is a variable expression.  <br /></td></tr>
<tr class="memitem:aa38007aa3852d7b21d088e210e5bd17e" id="r_aa38007aa3852d7b21d088e210e5bd17e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa38007aa3852d7b21d088e210e5bd17e">is_unary</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:aa38007aa3852d7b21d088e210e5bd17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is a unary expression.  <br /></td></tr>
<tr class="memitem:ad8d5eb3f737c5d4ffc2dee47228d316f" id="r_ad8d5eb3f737c5d4ffc2dee47228d316f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8d5eb3f737c5d4ffc2dee47228d316f">is_binary</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:ad8d5eb3f737c5d4ffc2dee47228d316f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is a binary expression.  <br /></td></tr>
<tr class="memitem:a8b5c270803005a40362fb97997347098" id="r_a8b5c270803005a40362fb97997347098"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b5c270803005a40362fb97997347098">is_addition</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a8b5c270803005a40362fb97997347098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is an addition expression.  <br /></td></tr>
<tr class="memitem:a3fbd20b990ba883bca7f6188c26ba861" id="r_a3fbd20b990ba883bca7f6188c26ba861"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fbd20b990ba883bca7f6188c26ba861">is_multiplication</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a3fbd20b990ba883bca7f6188c26ba861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is an multiplication expression.  <br /></td></tr>
<tr class="memitem:a1ef7767ed74e24d55ada8b380bcd22d8" id="r_a1ef7767ed74e24d55ada8b380bcd22d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ef7767ed74e24d55ada8b380bcd22d8">is_division</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a1ef7767ed74e24d55ada8b380bcd22d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is a division expression.  <br /></td></tr>
<tr class="memitem:a81fc6d7808fa4484507ddbb2471deb80" id="r_a81fc6d7808fa4484507ddbb2471deb80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81fc6d7808fa4484507ddbb2471deb80">is_log</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a81fc6d7808fa4484507ddbb2471deb80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is a log expression.  <br /></td></tr>
<tr class="memitem:a98d9027559c1c3c683711d50fc7ff48f" id="r_a98d9027559c1c3c683711d50fc7ff48f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98d9027559c1c3c683711d50fc7ff48f">is_abs</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a98d9027559c1c3c683711d50fc7ff48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is an absolute-value-function expression.  <br /></td></tr>
<tr class="memitem:aa1af4fb44735c433e6742487abbdf9eb" id="r_aa1af4fb44735c433e6742487abbdf9eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1af4fb44735c433e6742487abbdf9eb">is_exp</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:aa1af4fb44735c433e6742487abbdf9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is an exp expression.  <br /></td></tr>
<tr class="memitem:a12582d9a26dfcad1e0f38d7cb252c278" id="r_a12582d9a26dfcad1e0f38d7cb252c278"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12582d9a26dfcad1e0f38d7cb252c278">is_sqrt</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a12582d9a26dfcad1e0f38d7cb252c278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is a square-root expression.  <br /></td></tr>
<tr class="memitem:a78e3f155f5ffb14a784c8c6ba45eda79" id="r_a78e3f155f5ffb14a784c8c6ba45eda79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78e3f155f5ffb14a784c8c6ba45eda79">is_pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a78e3f155f5ffb14a784c8c6ba45eda79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is a power-function expression.  <br /></td></tr>
<tr class="memitem:a9333b59cea2e2d4fd444a236883efc19" id="r_a9333b59cea2e2d4fd444a236883efc19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9333b59cea2e2d4fd444a236883efc19">is_sin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a9333b59cea2e2d4fd444a236883efc19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is a sine expression.  <br /></td></tr>
<tr class="memitem:a91183d02aeaa64b9f83cf61cede3d013" id="r_a91183d02aeaa64b9f83cf61cede3d013"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91183d02aeaa64b9f83cf61cede3d013">is_cos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a91183d02aeaa64b9f83cf61cede3d013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is a cosine expression.  <br /></td></tr>
<tr class="memitem:a7d440af755e098914afb44da35f0bc41" id="r_a7d440af755e098914afb44da35f0bc41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d440af755e098914afb44da35f0bc41">is_tan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a7d440af755e098914afb44da35f0bc41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is a tangent expression.  <br /></td></tr>
<tr class="memitem:aede8001df8d3301fef461d03dd2d859d" id="r_aede8001df8d3301fef461d03dd2d859d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aede8001df8d3301fef461d03dd2d859d">is_asin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:aede8001df8d3301fef461d03dd2d859d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is an arcsine expression.  <br /></td></tr>
<tr class="memitem:a5508dd313a8bc04ddcd2ce645fa2e821" id="r_a5508dd313a8bc04ddcd2ce645fa2e821"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5508dd313a8bc04ddcd2ce645fa2e821">is_acos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a5508dd313a8bc04ddcd2ce645fa2e821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is an arccosine expression.  <br /></td></tr>
<tr class="memitem:ae05b78fd26fef2a243bdfe6530c59dc5" id="r_ae05b78fd26fef2a243bdfe6530c59dc5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae05b78fd26fef2a243bdfe6530c59dc5">is_atan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:ae05b78fd26fef2a243bdfe6530c59dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is an arctangent expression.  <br /></td></tr>
<tr class="memitem:a9d8916c566e17be2178816265ade645d" id="r_a9d8916c566e17be2178816265ade645d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d8916c566e17be2178816265ade645d">is_atan2</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a9d8916c566e17be2178816265ade645d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is a arctangent2 expression.  <br /></td></tr>
<tr class="memitem:a39b7051855909d23cb2364be81055f4d" id="r_a39b7051855909d23cb2364be81055f4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39b7051855909d23cb2364be81055f4d">is_sinh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a39b7051855909d23cb2364be81055f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is a hyperbolic-sine expression.  <br /></td></tr>
<tr class="memitem:a5db9c4002b15345dce271d95cf5ead8b" id="r_a5db9c4002b15345dce271d95cf5ead8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5db9c4002b15345dce271d95cf5ead8b">is_cosh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a5db9c4002b15345dce271d95cf5ead8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is a hyperbolic-cosine expression.  <br /></td></tr>
<tr class="memitem:a9046d3df24ec467a11723f4d93a2b2b0" id="r_a9046d3df24ec467a11723f4d93a2b2b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9046d3df24ec467a11723f4d93a2b2b0">is_tanh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a9046d3df24ec467a11723f4d93a2b2b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is a hyperbolic-tangent expression.  <br /></td></tr>
<tr class="memitem:a07604bda8201f0e20706eb90227c1237" id="r_a07604bda8201f0e20706eb90227c1237"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07604bda8201f0e20706eb90227c1237">is_min</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a07604bda8201f0e20706eb90227c1237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is a min expression.  <br /></td></tr>
<tr class="memitem:adfb4d01316fdb9323695db004bb8253b" id="r_adfb4d01316fdb9323695db004bb8253b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfb4d01316fdb9323695db004bb8253b">is_max</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:adfb4d01316fdb9323695db004bb8253b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is a max expression.  <br /></td></tr>
<tr class="memitem:a21641bf62f5605ddf8818f445fcdfa4a" id="r_a21641bf62f5605ddf8818f445fcdfa4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21641bf62f5605ddf8818f445fcdfa4a">is_ceil</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a21641bf62f5605ddf8818f445fcdfa4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is a ceil expression.  <br /></td></tr>
<tr class="memitem:a20fb80a81ab38fa64a9cc84c5dd3a71d" id="r_a20fb80a81ab38fa64a9cc84c5dd3a71d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20fb80a81ab38fa64a9cc84c5dd3a71d">is_floor</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a20fb80a81ab38fa64a9cc84c5dd3a71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is a floor expression.  <br /></td></tr>
<tr class="memitem:ab19b1f2d76056a8e9ee91ca1d14ee822" id="r_ab19b1f2d76056a8e9ee91ca1d14ee822"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab19b1f2d76056a8e9ee91ca1d14ee822">is_if_then_else</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:ab19b1f2d76056a8e9ee91ca1d14ee822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is an if-then-else expression.  <br /></td></tr>
<tr class="memitem:accafe113c53c148891d12dcabc66dddc" id="r_accafe113c53c148891d12dcabc66dddc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accafe113c53c148891d12dcabc66dddc">is_uninterpreted_function</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:accafe113c53c148891d12dcabc66dddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">c</code> is an uninterpreted-function expression.  <br /></td></tr>
<tr class="memitem:a9911fd0881ffc66c0c64e8d727399237" id="r_a9911fd0881ffc66c0c64e8d727399237"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9911fd0881ffc66c0c64e8d727399237">operator&lt;</a> (<a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91">ExpressionKind</a> k1, <a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91">ExpressionKind</a> k2)</td></tr>
<tr class="memdesc:a9911fd0881ffc66c0c64e8d727399237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total ordering between ExpressionKinds.  <br /></td></tr>
<tr class="memitem:ae5abf0008c6baabf649d608c33114a47" id="r_ae5abf0008c6baabf649d608c33114a47"><td class="memTemplParams" colspan="2">template&lt;typename Result, typename Visitor, typename... Args&gt; </td></tr>
<tr class="memitem:ae5abf0008c6baabf649d608c33114a47 template"><td class="memItemLeft" align="right" valign="top">Result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5abf0008c6baabf649d608c33114a47">VisitPolynomial</a> (Visitor *v, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae5abf0008c6baabf649d608c33114a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls visitor object <code class="param">v</code> with a polynomial symbolic-expression <code class="param">e</code>, and arguments <code class="param">args</code>.  <br /></td></tr>
<tr class="memitem:a0f2183e65fb6daea39bbc9084cd99b87" id="r_a0f2183e65fb6daea39bbc9084cd99b87"><td class="memTemplParams" colspan="2">template&lt;typename Result, typename Visitor, typename... Args&gt; </td></tr>
<tr class="memitem:a0f2183e65fb6daea39bbc9084cd99b87 template"><td class="memItemLeft" align="right" valign="top">Result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f2183e65fb6daea39bbc9084cd99b87">VisitExpression</a> (Visitor *v, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a0f2183e65fb6daea39bbc9084cd99b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls visitor object <code class="param">v</code> with a symbolic-expression <code class="param">e</code>, and arguments <code class="param">args</code>.  <br /></td></tr>
<tr class="memitem:a5206a4972567789a21f4c05dbbca1bc7" id="r_a5206a4972567789a21f4c05dbbca1bc7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5206a4972567789a21f4c05dbbca1bc7">operator&lt;</a> (<a class="el" href="#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a> k1, <a class="el" href="#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a> k2)</td></tr>
<tr class="memitem:a7d13fc861c980e5cca95449bb11cbe01" id="r_a7d13fc861c980e5cca95449bb11cbe01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d13fc861c980e5cca95449bb11cbe01">forall</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a7d13fc861c980e5cca95449bb11cbe01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a formula <code class="param">f</code>, universally quantified by variables <code class="param">vars</code>.  <br /></td></tr>
<tr class="memitem:ad928a3acb97d0b15191fdda370098cec" id="r_ad928a3acb97d0b15191fdda370098cec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad928a3acb97d0b15191fdda370098cec">make_conjunction</a> (const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp;formulas)</td></tr>
<tr class="memdesc:ad928a3acb97d0b15191fdda370098cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a conjunction of <code class="param">formulas</code>.  <br /></td></tr>
<tr class="memitem:afa29726cabd0dc09fe4fb61ffe80ad02" id="r_afa29726cabd0dc09fe4fb61ffe80ad02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa29726cabd0dc09fe4fb61ffe80ad02">operator&amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f1, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f2)</td></tr>
<tr class="memitem:ae4af14e85b9784db6c9f6374e7d7ae67" id="r_ae4af14e85b9784db6c9f6374e7d7ae67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4af14e85b9784db6c9f6374e7d7ae67">operator&amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memitem:a3b513c43cd0d555b75ce08e18241e920" id="r_a3b513c43cd0d555b75ce08e18241e920"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b513c43cd0d555b75ce08e18241e920">operator&amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="memitem:a47ad638c3929268d643623b21901e11a" id="r_a47ad638c3929268d643623b21901e11a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47ad638c3929268d643623b21901e11a">operator&amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v1, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v2)</td></tr>
<tr class="memitem:a10a756a422ebc5e372bb1ecc5ccab5be" id="r_a10a756a422ebc5e372bb1ecc5ccab5be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10a756a422ebc5e372bb1ecc5ccab5be">make_disjunction</a> (const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp;formulas)</td></tr>
<tr class="memdesc:a10a756a422ebc5e372bb1ecc5ccab5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a disjunction of <code class="param">formulas</code>.  <br /></td></tr>
<tr class="memitem:afd02ba28125fcb30762312b0361e0790" id="r_afd02ba28125fcb30762312b0361e0790"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd02ba28125fcb30762312b0361e0790">operator||</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f1, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f2)</td></tr>
<tr class="memitem:a1b37f14ce7a17532970ad74b4182267d" id="r_a1b37f14ce7a17532970ad74b4182267d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b37f14ce7a17532970ad74b4182267d">operator||</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memitem:af301dd903e8b79a8584fa3ed0fb3708a" id="r_af301dd903e8b79a8584fa3ed0fb3708a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af301dd903e8b79a8584fa3ed0fb3708a">operator||</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="memitem:a09c7a845583db868b2d30a66c2616397" id="r_a09c7a845583db868b2d30a66c2616397"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09c7a845583db868b2d30a66c2616397">operator||</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v1, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v2)</td></tr>
<tr class="memitem:a49edb4821b05df85a60fe3d96adf4f70" id="r_a49edb4821b05df85a60fe3d96adf4f70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49edb4821b05df85a60fe3d96adf4f70">operator!</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memitem:a9175736ad1ead8240b9bbc1bd8d4f37f" id="r_a9175736ad1ead8240b9bbc1bd8d4f37f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9175736ad1ead8240b9bbc1bd8d4f37f">operator!</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="memitem:ae28c71d4bee52bfa5e4928605a4ee87d" id="r_ae28c71d4bee52bfa5e4928605a4ee87d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae28c71d4bee52bfa5e4928605a4ee87d">operator==</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="memitem:acf2a23baf604198889aab8eea8620601" id="r_acf2a23baf604198889aab8eea8620601"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf2a23baf604198889aab8eea8620601">operator!=</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="memitem:aea9d6243717b5f82e19ace8a5d88f450" id="r_aea9d6243717b5f82e19ace8a5d88f450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea9d6243717b5f82e19ace8a5d88f450">operator&lt;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="memitem:ad91873fce901342b010a449f7952d290" id="r_ad91873fce901342b010a449f7952d290"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad91873fce901342b010a449f7952d290">operator&lt;=</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="memitem:a047255afbaefd1684cccb967c2ceb1b7" id="r_a047255afbaefd1684cccb967c2ceb1b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a047255afbaefd1684cccb967c2ceb1b7">operator&gt;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="memitem:ac8f5b0df2a3fecea9d23b24475c7fdca" id="r_ac8f5b0df2a3fecea9d23b24475c7fdca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8f5b0df2a3fecea9d23b24475c7fdca">operator&gt;=</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="memitem:aee7da5a29fea63347ec7c9fddce7f022" id="r_aee7da5a29fea63347ec7c9fddce7f022"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee7da5a29fea63347ec7c9fddce7f022">isnan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aee7da5a29fea63347ec7c9fddce7f022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a> for the predicate isnan(e) to the given expression.  <br /></td></tr>
<tr class="memitem:a566d62c9e145df5946146f1a53c12a96" id="r_a566d62c9e145df5946146f1a53c12a96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a566d62c9e145df5946146f1a53c12a96">isinf</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a566d62c9e145df5946146f1a53c12a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a> determining if the given expression <code class="param">e</code> is a positive or negative infinity.  <br /></td></tr>
<tr class="memitem:ae2e386e89865ff1db9ac93f7a3e79586" id="r_ae2e386e89865ff1db9ac93f7a3e79586"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2e386e89865ff1db9ac93f7a3e79586">isfinite</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ae2e386e89865ff1db9ac93f7a3e79586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a> determining if the given expression <code class="param">e</code> has a finite value.  <br /></td></tr>
<tr class="memitem:a525eb4ca416c6055765da5ba992b1c9c" id="r_a525eb4ca416c6055765da5ba992b1c9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a525eb4ca416c6055765da5ba992b1c9c">positive_semidefinite</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;m)</td></tr>
<tr class="memdesc:a525eb4ca416c6055765da5ba992b1c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula constraining <code class="param">m</code> to be a positive-semidefinite matrix.  <br /></td></tr>
<tr class="memitem:ab7294a6a837aa476fe079c9d5596f373" id="r_ab7294a6a837aa476fe079c9d5596f373"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7294a6a837aa476fe079c9d5596f373">positive_semidefinite</a> (const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;m, Eigen::UpLoType mode)</td></tr>
<tr class="memdesc:ab7294a6a837aa476fe079c9d5596f373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a symbolic positive-semidefinite formula from <code class="param">m</code>.  <br /></td></tr>
<tr class="memitem:a073573483e330bf1779f5079b2e88d8c" id="r_a073573483e330bf1779f5079b2e88d8c"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a073573483e330bf1779f5079b2e88d8c template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a073573483e330bf1779f5079b2e88d8c">positive_semidefinite</a> (const Eigen::TriangularView&lt; Derived, Eigen::Lower &gt; &amp;l)</td></tr>
<tr class="memdesc:a073573483e330bf1779f5079b2e88d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a symbolic positive-semidefinite formula from a lower triangular-view <code class="param">l</code>.  <br /></td></tr>
<tr class="memitem:a79e5b283a437914a863d9f4cde2d8fdd" id="r_a79e5b283a437914a863d9f4cde2d8fdd"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a79e5b283a437914a863d9f4cde2d8fdd template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79e5b283a437914a863d9f4cde2d8fdd">positive_semidefinite</a> (const Eigen::TriangularView&lt; Derived, Eigen::Upper &gt; &amp;u)</td></tr>
<tr class="memdesc:a79e5b283a437914a863d9f4cde2d8fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a symbolic positive-semidefinite formula from an upper triangular-view <code class="param">u</code>.  <br /></td></tr>
<tr class="memitem:a96c90655d4fb45b63c8e1bde735e6c47" id="r_a96c90655d4fb45b63c8e1bde735e6c47"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96c90655d4fb45b63c8e1bde735e6c47">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memitem:aea6545b9866491ab6406d9141903d204" id="r_aea6545b9866491ab6406d9141903d204"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea6545b9866491ab6406d9141903d204">is_false</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:aea6545b9866491ab6406d9141903d204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is structurally equal to False formula.  <br /></td></tr>
<tr class="memitem:ac015488f4fe334717bbe5a47e1f1da87" id="r_ac015488f4fe334717bbe5a47e1f1da87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac015488f4fe334717bbe5a47e1f1da87">is_true</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:ac015488f4fe334717bbe5a47e1f1da87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is structurally equal to True formula.  <br /></td></tr>
<tr class="memitem:aebdc9659eb8cc2eb735925fc4f2828ac" id="r_aebdc9659eb8cc2eb735925fc4f2828ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebdc9659eb8cc2eb735925fc4f2828ac">is_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:aebdc9659eb8cc2eb735925fc4f2828ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a variable formula.  <br /></td></tr>
<tr class="memitem:aa44a7661fef44d4031441019512ef82d" id="r_aa44a7661fef44d4031441019512ef82d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa44a7661fef44d4031441019512ef82d">is_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:aa44a7661fef44d4031441019512ef82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a formula representing equality (==).  <br /></td></tr>
<tr class="memitem:a7b22d6f9b90847ce4b84be2a5afd1c30" id="r_a7b22d6f9b90847ce4b84be2a5afd1c30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b22d6f9b90847ce4b84be2a5afd1c30">is_not_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a7b22d6f9b90847ce4b84be2a5afd1c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a formula representing disequality (!=).  <br /></td></tr>
<tr class="memitem:a25bef67cdba7a3575080ee23c4a49c24" id="r_a25bef67cdba7a3575080ee23c4a49c24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25bef67cdba7a3575080ee23c4a49c24">is_greater_than</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a25bef67cdba7a3575080ee23c4a49c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a formula representing greater-than (&gt;).  <br /></td></tr>
<tr class="memitem:aa6bd435704910ee83eec832dec9e0ebe" id="r_aa6bd435704910ee83eec832dec9e0ebe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6bd435704910ee83eec832dec9e0ebe">is_greater_than_or_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:aa6bd435704910ee83eec832dec9e0ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a formula representing greater-than-or-equal-to (&gt;=).  <br /></td></tr>
<tr class="memitem:a9754658b6efb430a95a6ef060573970e" id="r_a9754658b6efb430a95a6ef060573970e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9754658b6efb430a95a6ef060573970e">is_less_than</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a9754658b6efb430a95a6ef060573970e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a formula representing less-than (&lt;).  <br /></td></tr>
<tr class="memitem:af1861c52cf99c60f758c0f4bd642ecf9" id="r_af1861c52cf99c60f758c0f4bd642ecf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1861c52cf99c60f758c0f4bd642ecf9">is_less_than_or_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:af1861c52cf99c60f758c0f4bd642ecf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a formula representing less-than-or-equal-to (&lt;=).  <br /></td></tr>
<tr class="memitem:ab48c893fbcf425253c444573d100c3f2" id="r_ab48c893fbcf425253c444573d100c3f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab48c893fbcf425253c444573d100c3f2">is_relational</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:ab48c893fbcf425253c444573d100c3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a relational formula ({==, !=, &gt;, &gt;=, &lt;, &lt;=}).  <br /></td></tr>
<tr class="memitem:a70fdb6bef6734fc34b5215e5c7b661df" id="r_a70fdb6bef6734fc34b5215e5c7b661df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70fdb6bef6734fc34b5215e5c7b661df">is_conjunction</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a70fdb6bef6734fc34b5215e5c7b661df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a conjunction (∧).  <br /></td></tr>
<tr class="memitem:a307cee89f5417dd1c19ba16bb273fb25" id="r_a307cee89f5417dd1c19ba16bb273fb25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a307cee89f5417dd1c19ba16bb273fb25">is_disjunction</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a307cee89f5417dd1c19ba16bb273fb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a disjunction (∨).  <br /></td></tr>
<tr class="memitem:a63d76102c00828325b11b21db606b5a0" id="r_a63d76102c00828325b11b21db606b5a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63d76102c00828325b11b21db606b5a0">is_nary</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a63d76102c00828325b11b21db606b5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a n-ary formula ({∧, ∨}).  <br /></td></tr>
<tr class="memitem:afbbcd3f16b91bba700239675e5826a81" id="r_afbbcd3f16b91bba700239675e5826a81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbbcd3f16b91bba700239675e5826a81">is_negation</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:afbbcd3f16b91bba700239675e5826a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a negation (¬).  <br /></td></tr>
<tr class="memitem:a1860e7373cbab3826845de76f4c6fc6a" id="r_a1860e7373cbab3826845de76f4c6fc6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1860e7373cbab3826845de76f4c6fc6a">is_forall</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a1860e7373cbab3826845de76f4c6fc6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a Forall formula (∀).  <br /></td></tr>
<tr class="memitem:a75b1751d953407c394e5643f2d1d3f27" id="r_a75b1751d953407c394e5643f2d1d3f27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75b1751d953407c394e5643f2d1d3f27">is_isnan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a75b1751d953407c394e5643f2d1d3f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is an isnan formula.  <br /></td></tr>
<tr class="memitem:a31788a703bff17b148b3107beefbc585" id="r_a31788a703bff17b148b3107beefbc585"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31788a703bff17b148b3107beefbc585">is_positive_semidefinite</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a31788a703bff17b148b3107beefbc585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a positive-semidefinite formula.  <br /></td></tr>
<tr class="memitem:a85376535fc0a875d116702f9186d8f99" id="r_a85376535fc0a875d116702f9186d8f99"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85376535fc0a875d116702f9186d8f99">get_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a85376535fc0a875d116702f9186d8f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the embedded variable in the variable formula <code class="param">f</code>.  <br /></td></tr>
<tr class="memitem:a77f3d349554a28bfa3f1107bb4adaab6" id="r_a77f3d349554a28bfa3f1107bb4adaab6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77f3d349554a28bfa3f1107bb4adaab6">get_lhs_expression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a77f3d349554a28bfa3f1107bb4adaab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lhs-argument of a relational formula <code class="param">f</code>.  <br /></td></tr>
<tr class="memitem:af855c0227ec69f59da11988c82ae4ce2" id="r_af855c0227ec69f59da11988c82ae4ce2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af855c0227ec69f59da11988c82ae4ce2">get_rhs_expression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:af855c0227ec69f59da11988c82ae4ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rhs-argument of a relational formula <code class="param">f</code>.  <br /></td></tr>
<tr class="memitem:a4ce6eacfc51cea8af6b9c1e0e963807a" id="r_a4ce6eacfc51cea8af6b9c1e0e963807a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ce6eacfc51cea8af6b9c1e0e963807a">get_unary_expression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a4ce6eacfc51cea8af6b9c1e0e963807a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the expression in a unary expression formula <code class="param">f</code>.  <br /></td></tr>
<tr class="memitem:a5a51076f5f4ab9497965268ceb34e82c" id="r_a5a51076f5f4ab9497965268ceb34e82c"><td class="memItemLeft" align="right" valign="top">const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a51076f5f4ab9497965268ceb34e82c">get_operands</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a5a51076f5f4ab9497965268ceb34e82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of formulas in a n-ary formula <code class="param">f</code>.  <br /></td></tr>
<tr class="memitem:a4d6409b69e4049b282edaaea65fe1b43" id="r_a4d6409b69e4049b282edaaea65fe1b43"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d6409b69e4049b282edaaea65fe1b43">get_operand</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a4d6409b69e4049b282edaaea65fe1b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the formula in a negation formula <code class="param">f</code>.  <br /></td></tr>
<tr class="memitem:a637fea2c6cfc60b582df81b7b1187e94" id="r_a637fea2c6cfc60b582df81b7b1187e94"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a637fea2c6cfc60b582df81b7b1187e94">get_quantified_variables</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a637fea2c6cfc60b582df81b7b1187e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the quantified variables in a forall formula <code class="param">f</code>.  <br /></td></tr>
<tr class="memitem:a6d5aa689465b2522a75c7dc12fcf1b60" id="r_a6d5aa689465b2522a75c7dc12fcf1b60"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d5aa689465b2522a75c7dc12fcf1b60">get_quantified_formula</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a6d5aa689465b2522a75c7dc12fcf1b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the quantified formula in a forall formula <code class="param">f</code>.  <br /></td></tr>
<tr class="memitem:ab77026017746534a08312bf9eb2d4a99" id="r_ab77026017746534a08312bf9eb2d4a99"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab77026017746534a08312bf9eb2d4a99">get_matrix_in_positive_semidefinite</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:ab77026017746534a08312bf9eb2d4a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the matrix in a positive-semidefinite formula <code class="param">f</code>.  <br /></td></tr>
<tr class="memitem:a993b173875967c3a3d57757f554dfab4" id="r_a993b173875967c3a3d57757f554dfab4"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a993b173875967c3a3d57757f554dfab4 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()==typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a993b173875967c3a3d57757f554dfab4">operator==</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a993b173875967c3a3d57757f554dfab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise symbolic-equality of two arrays <code class="param">m1</code> and <code class="param">m2</code>.  <br /></td></tr>
<tr class="memitem:a4656598caa852c1ad39ea6513e8aeff6" id="r_a4656598caa852c1ad39ea6513e8aeff6"><td class="memTemplParams" colspan="2">template&lt;typename Derived, typename ScalarType&gt; </td></tr>
<tr class="memitem:a4656598caa852c1ad39ea6513e8aeff6 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar()==ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4656598caa852c1ad39ea6513e8aeff6">operator==</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:a4656598caa852c1ad39ea6513e8aeff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code class="param">a</code> and a scalar <code class="param">v</code> using equal-to operator (==).  <br /></td></tr>
<tr class="memitem:ac5764ce1fcaf60cd695e106397ea7bb7" id="r_ac5764ce1fcaf60cd695e106397ea7bb7"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType, typename Derived&gt; </td></tr>
<tr class="memitem:ac5764ce1fcaf60cd695e106397ea7bb7 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType()==typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5764ce1fcaf60cd695e106397ea7bb7">operator==</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:ac5764ce1fcaf60cd695e106397ea7bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code class="param">v</code> and an array <code class="param">using</code> equal-to operator (==).  <br /></td></tr>
<tr class="memitem:a00e6a5930a86434ef7dd224f001a282b" id="r_a00e6a5930a86434ef7dd224f001a282b"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a00e6a5930a86434ef7dd224f001a282b template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()&lt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00e6a5930a86434ef7dd224f001a282b">operator&lt;=</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a00e6a5930a86434ef7dd224f001a282b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code class="param">a1</code> and <code class="param">a2</code> using less-than-or-equal operator (&lt;=).  <br /></td></tr>
<tr class="memitem:a74f6eeef08887be237dd99f50e3efeb8" id="r_a74f6eeef08887be237dd99f50e3efeb8"><td class="memTemplParams" colspan="2">template&lt;typename Derived, typename ScalarType&gt; </td></tr>
<tr class="memitem:a74f6eeef08887be237dd99f50e3efeb8 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar()&lt;=ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74f6eeef08887be237dd99f50e3efeb8">operator&lt;=</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:a74f6eeef08887be237dd99f50e3efeb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code class="param">a</code> and a scalar <code class="param">v</code> using less-than-or-equal operator (&lt;=).  <br /></td></tr>
<tr class="memitem:a1546fbcbc705d680d1ae89a5dd5e9c1b" id="r_a1546fbcbc705d680d1ae89a5dd5e9c1b"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType, typename Derived&gt; </td></tr>
<tr class="memitem:a1546fbcbc705d680d1ae89a5dd5e9c1b template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType()&lt;=typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1546fbcbc705d680d1ae89a5dd5e9c1b">operator&lt;=</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a1546fbcbc705d680d1ae89a5dd5e9c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code class="param">v</code> and an array <code class="param">using</code> less-than-or-equal operator (&lt;=).  <br /></td></tr>
<tr class="memitem:a2a7547f207b1d32989acd9629fba4994" id="r_a2a7547f207b1d32989acd9629fba4994"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a2a7547f207b1d32989acd9629fba4994 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()&lt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a7547f207b1d32989acd9629fba4994">operator&lt;</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a2a7547f207b1d32989acd9629fba4994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code class="param">a1</code> and <code class="param">a2</code> using less-than operator (&lt;).  <br /></td></tr>
<tr class="memitem:afd43f36981591cbe9f45910e46c041a9" id="r_afd43f36981591cbe9f45910e46c041a9"><td class="memTemplParams" colspan="2">template&lt;typename Derived, typename ScalarType&gt; </td></tr>
<tr class="memitem:afd43f36981591cbe9f45910e46c041a9 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar()&lt; ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd43f36981591cbe9f45910e46c041a9">operator&lt;</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:afd43f36981591cbe9f45910e46c041a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code class="param">a</code> and a scalar <code class="param">v</code> using less-than operator (&lt;).  <br /></td></tr>
<tr class="memitem:a08bfc1af3d18b12aa8a994d31a2643f7" id="r_a08bfc1af3d18b12aa8a994d31a2643f7"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType, typename Derived&gt; </td></tr>
<tr class="memitem:a08bfc1af3d18b12aa8a994d31a2643f7 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType()&lt; typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08bfc1af3d18b12aa8a994d31a2643f7">operator&lt;</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a08bfc1af3d18b12aa8a994d31a2643f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code class="param">v</code> and an array <code class="param">using</code> less-than operator (&lt;).  <br /></td></tr>
<tr class="memitem:a2fd72f8875df01ff36fdedd9371e8db0" id="r_a2fd72f8875df01ff36fdedd9371e8db0"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a2fd72f8875df01ff36fdedd9371e8db0 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() &gt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fd72f8875df01ff36fdedd9371e8db0">operator&gt;=</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a2fd72f8875df01ff36fdedd9371e8db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code class="param">a1</code> and <code class="param">a2</code> using greater-than-or-equal operator (&gt;=).  <br /></td></tr>
<tr class="memitem:ac9c625401bc6fa407a54cb6004b8299f" id="r_ac9c625401bc6fa407a54cb6004b8299f"><td class="memTemplParams" colspan="2">template&lt;typename Derived, typename ScalarType&gt; </td></tr>
<tr class="memitem:ac9c625401bc6fa407a54cb6004b8299f template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar() &gt;=ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9c625401bc6fa407a54cb6004b8299f">operator&gt;=</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:ac9c625401bc6fa407a54cb6004b8299f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code class="param">a</code> and a scalar <code class="param">v</code> using greater-than-or-equal operator (&gt;=).  <br /></td></tr>
<tr class="memitem:a6f190c2b8351007ad0ebf41a52d03472" id="r_a6f190c2b8351007ad0ebf41a52d03472"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType, typename Derived&gt; </td></tr>
<tr class="memitem:a6f190c2b8351007ad0ebf41a52d03472 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType() &gt;=typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f190c2b8351007ad0ebf41a52d03472">operator&gt;=</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a6f190c2b8351007ad0ebf41a52d03472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code class="param">v</code> and an array <code class="param">using</code> less-than-or-equal operator (&lt;=) instead of greater-than-or-equal operator (&gt;=).  <br /></td></tr>
<tr class="memitem:add8009d78d933826d765faf7ae3d112f" id="r_add8009d78d933826d765faf7ae3d112f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:add8009d78d933826d765faf7ae3d112f template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() &gt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add8009d78d933826d765faf7ae3d112f">operator&gt;</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:add8009d78d933826d765faf7ae3d112f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code class="param">a1</code> and <code class="param">a2</code> using greater-than operator (&gt;).  <br /></td></tr>
<tr class="memitem:a39121e92f332d2ca0dc6e42e6f9344a0" id="r_a39121e92f332d2ca0dc6e42e6f9344a0"><td class="memTemplParams" colspan="2">template&lt;typename Derived, typename ScalarType&gt; </td></tr>
<tr class="memitem:a39121e92f332d2ca0dc6e42e6f9344a0 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar() &gt; ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39121e92f332d2ca0dc6e42e6f9344a0">operator&gt;</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:a39121e92f332d2ca0dc6e42e6f9344a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code class="param">a</code> and a scalar <code class="param">v</code> using greater-than operator (&gt;).  <br /></td></tr>
<tr class="memitem:a7d51445b9c7e7e2292fcfebd038b1738" id="r_a7d51445b9c7e7e2292fcfebd038b1738"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType, typename Derived&gt; </td></tr>
<tr class="memitem:a7d51445b9c7e7e2292fcfebd038b1738 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType() &gt; typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d51445b9c7e7e2292fcfebd038b1738">operator&gt;</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a7d51445b9c7e7e2292fcfebd038b1738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code class="param">v</code> and an array <code class="param">using</code> less-than operator (&lt;) instead of greater-than operator (&gt;).  <br /></td></tr>
<tr class="memitem:a8e2230c401a3cf25909b4b25cac536be" id="r_a8e2230c401a3cf25909b4b25cac536be"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a8e2230c401a3cf25909b4b25cac536be template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() !=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e2230c401a3cf25909b4b25cac536be">operator!=</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a8e2230c401a3cf25909b4b25cac536be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code class="param">a1</code> and <code class="param">a2</code> using not-equal operator (!=).  <br /></td></tr>
<tr class="memitem:a417bf2fd4f030f7aa2d3ac779bf4c099" id="r_a417bf2fd4f030f7aa2d3ac779bf4c099"><td class="memTemplParams" colspan="2">template&lt;typename Derived, typename ScalarType&gt; </td></tr>
<tr class="memitem:a417bf2fd4f030f7aa2d3ac779bf4c099 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar() !=ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a417bf2fd4f030f7aa2d3ac779bf4c099">operator!=</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:a417bf2fd4f030f7aa2d3ac779bf4c099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code class="param">a</code> and a scalar <code class="param">v</code> using not-equal operator (!=).  <br /></td></tr>
<tr class="memitem:a0e08ccfd1038cd9ee942d2c32d9db1d6" id="r_a0e08ccfd1038cd9ee942d2c32d9db1d6"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType, typename Derived&gt; </td></tr>
<tr class="memitem:a0e08ccfd1038cd9ee942d2c32d9db1d6 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType() !=typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e08ccfd1038cd9ee942d2c32d9db1d6">operator!=</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a0e08ccfd1038cd9ee942d2c32d9db1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code class="param">v</code> and an array <code class="param">using</code> not-equal operator (!=).  <br /></td></tr>
<tr class="memitem:a5baf7e7e983ace79d366f506103a06db" id="r_a5baf7e7e983ace79d366f506103a06db"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a5baf7e7e983ace79d366f506103a06db template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()==typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5baf7e7e983ace79d366f506103a06db">operator==</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:a5baf7e7e983ace79d366f506103a06db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula checking if two matrices <code class="param">m1</code> and <code class="param">m2</code> are equal.  <br /></td></tr>
<tr class="memitem:a092d073efe77947ba617bc41cf166308" id="r_a092d073efe77947ba617bc41cf166308"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a092d073efe77947ba617bc41cf166308 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() !=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a092d073efe77947ba617bc41cf166308">operator!=</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:a092d073efe77947ba617bc41cf166308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing the condition whether <code class="param">m1</code> and <code class="param">m2</code> are not the same.  <br /></td></tr>
<tr class="memitem:ac3ae1c03a9f8e4a5dc7b4131e5a60294" id="r_ac3ae1c03a9f8e4a5dc7b4131e5a60294"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:ac3ae1c03a9f8e4a5dc7b4131e5a60294 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()&lt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3ae1c03a9f8e4a5dc7b4131e5a60294">operator&lt;</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:ac3ae1c03a9f8e4a5dc7b4131e5a60294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing element-wise comparison between two matrices <code class="param">m1</code> and <code class="param">m2</code> using less-than (&lt;) operator.  <br /></td></tr>
<tr class="memitem:a29be67079f48ecf9ed0420b7e92de59f" id="r_a29be67079f48ecf9ed0420b7e92de59f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a29be67079f48ecf9ed0420b7e92de59f template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()&lt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29be67079f48ecf9ed0420b7e92de59f">operator&lt;=</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:a29be67079f48ecf9ed0420b7e92de59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing element-wise comparison between two matrices <code class="param">m1</code> and <code class="param">m2</code> using less-than-or-equal operator (&lt;=).  <br /></td></tr>
<tr class="memitem:ae9dbd563dfe489f43f1f0754c4a04e27" id="r_ae9dbd563dfe489f43f1f0754c4a04e27"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:ae9dbd563dfe489f43f1f0754c4a04e27 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() &gt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9dbd563dfe489f43f1f0754c4a04e27">operator&gt;</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:ae9dbd563dfe489f43f1f0754c4a04e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing element-wise comparison between two matrices <code class="param">m1</code> and <code class="param">m2</code> using greater-than operator (&gt;).  <br /></td></tr>
<tr class="memitem:a59b73c7509dfecd799346d10b030bedd" id="r_a59b73c7509dfecd799346d10b030bedd"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a59b73c7509dfecd799346d10b030bedd template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() &gt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59b73c7509dfecd799346d10b030bedd">operator&gt;=</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:a59b73c7509dfecd799346d10b030bedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing element-wise comparison between two matrices <code class="param">m1</code> and <code class="param">m2</code> using greater-than-or-equal operator (&gt;=).  <br /></td></tr>
<tr class="memitem:a8a8bf1c901b65947ce83086ab0921b13" id="r_a8a8bf1c901b65947ce83086ab0921b13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a8bf1c901b65947ce83086ab0921b13">is_false</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a8a8bf1c901b65947ce83086ab0921b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is structurally equal to False formula.  <br /></td></tr>
<tr class="memitem:a2f1159580703bc95a8f14848e38cb659" id="r_a2f1159580703bc95a8f14848e38cb659"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f1159580703bc95a8f14848e38cb659">is_true</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a2f1159580703bc95a8f14848e38cb659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is structurally equal to True formula.  <br /></td></tr>
<tr class="memitem:a14d18c58b79582620cb6b8ff37ec1e85" id="r_a14d18c58b79582620cb6b8ff37ec1e85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14d18c58b79582620cb6b8ff37ec1e85">is_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a14d18c58b79582620cb6b8ff37ec1e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a variable formula.  <br /></td></tr>
<tr class="memitem:a37d37d1e3097c7a898d706aee5066f90" id="r_a37d37d1e3097c7a898d706aee5066f90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37d37d1e3097c7a898d706aee5066f90">is_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a37d37d1e3097c7a898d706aee5066f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a formula representing equality (==).  <br /></td></tr>
<tr class="memitem:a08c4eae26a98b1345c997e579ed0709a" id="r_a08c4eae26a98b1345c997e579ed0709a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08c4eae26a98b1345c997e579ed0709a">is_not_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a08c4eae26a98b1345c997e579ed0709a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a formula representing disequality (!=).  <br /></td></tr>
<tr class="memitem:aaf04cff26c77f1ef1f11fedc77a31bb5" id="r_aaf04cff26c77f1ef1f11fedc77a31bb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf04cff26c77f1ef1f11fedc77a31bb5">is_greater_than</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:aaf04cff26c77f1ef1f11fedc77a31bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a formula representing greater-than (&gt;).  <br /></td></tr>
<tr class="memitem:a987c2a9d322549f8617a45997bae8aa6" id="r_a987c2a9d322549f8617a45997bae8aa6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a987c2a9d322549f8617a45997bae8aa6">is_greater_than_or_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a987c2a9d322549f8617a45997bae8aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a formula representing greater-than-or-equal-to (&gt;=).  <br /></td></tr>
<tr class="memitem:a4e70f747ac0d276d07b39a56d8f2b5b9" id="r_a4e70f747ac0d276d07b39a56d8f2b5b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e70f747ac0d276d07b39a56d8f2b5b9">is_less_than</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a4e70f747ac0d276d07b39a56d8f2b5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a formula representing less-than (&lt;).  <br /></td></tr>
<tr class="memitem:a77bc9328e2893740b71f07cf466f02db" id="r_a77bc9328e2893740b71f07cf466f02db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77bc9328e2893740b71f07cf466f02db">is_less_than_or_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a77bc9328e2893740b71f07cf466f02db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a formula representing less-than-or-equal-to (&lt;=).  <br /></td></tr>
<tr class="memitem:aba3787e10ce1fe3bb7f6645a0f9ac671" id="r_aba3787e10ce1fe3bb7f6645a0f9ac671"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba3787e10ce1fe3bb7f6645a0f9ac671">is_relational</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:aba3787e10ce1fe3bb7f6645a0f9ac671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a relational formula ({==, !=, &gt;, &gt;=, &lt;, &lt;=}).  <br /></td></tr>
<tr class="memitem:a9074585b52963983223bce6e902efea7" id="r_a9074585b52963983223bce6e902efea7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9074585b52963983223bce6e902efea7">is_conjunction</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a9074585b52963983223bce6e902efea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a conjunction (∧).  <br /></td></tr>
<tr class="memitem:a8877eff0311bb541c504a56196a591f0" id="r_a8877eff0311bb541c504a56196a591f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8877eff0311bb541c504a56196a591f0">is_disjunction</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a8877eff0311bb541c504a56196a591f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a disjunction (∨).  <br /></td></tr>
<tr class="memitem:a58cc3d5891c01e1be6530506251dcdca" id="r_a58cc3d5891c01e1be6530506251dcdca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58cc3d5891c01e1be6530506251dcdca">is_nary</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a58cc3d5891c01e1be6530506251dcdca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is N-ary.  <br /></td></tr>
<tr class="memitem:adf3743f22df29090472d034a69b9d7aa" id="r_adf3743f22df29090472d034a69b9d7aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf3743f22df29090472d034a69b9d7aa">is_negation</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:adf3743f22df29090472d034a69b9d7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a negation (¬).  <br /></td></tr>
<tr class="memitem:a7cdcb84785fc3ddf61732a3279ce6d74" id="r_a7cdcb84785fc3ddf61732a3279ce6d74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cdcb84785fc3ddf61732a3279ce6d74">is_forall</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a7cdcb84785fc3ddf61732a3279ce6d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a Forall formula (∀).  <br /></td></tr>
<tr class="memitem:aa7ae3f7e8da7523a075b5adfcb7b788c" id="r_aa7ae3f7e8da7523a075b5adfcb7b788c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7ae3f7e8da7523a075b5adfcb7b788c">is_isnan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:aa7ae3f7e8da7523a075b5adfcb7b788c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is an isnan formula.  <br /></td></tr>
<tr class="memitem:a4c0bed602c95290fb77dc45316a1f54d" id="r_a4c0bed602c95290fb77dc45316a1f54d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c0bed602c95290fb77dc45316a1f54d">is_positive_semidefinite</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a4c0bed602c95290fb77dc45316a1f54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a positive semidefinite formula.  <br /></td></tr>
<tr class="memitem:a2bbf53a99973d5ba527ae4a7ea4931c7" id="r_a2bbf53a99973d5ba527ae4a7ea4931c7"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_false.html">FormulaFalse</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bbf53a99973d5ba527ae4a7ea4931c7">to_false</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a2bbf53a99973d5ba527ae4a7ea4931c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaFalse&gt;</code>.  <br /></td></tr>
<tr class="memitem:a34830c27f16176946d3f44522530f636" id="r_a34830c27f16176946d3f44522530f636"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_true.html">FormulaTrue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34830c27f16176946d3f44522530f636">to_true</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a34830c27f16176946d3f44522530f636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaTrue&gt;</code>.  <br /></td></tr>
<tr class="memitem:a3c92380da4b49bf1656529597e4ddc70" id="r_a3c92380da4b49bf1656529597e4ddc70"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_var.html">FormulaVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c92380da4b49bf1656529597e4ddc70">to_variable</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a3c92380da4b49bf1656529597e4ddc70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaVar&gt;</code>.  <br /></td></tr>
<tr class="memitem:a35d0b8206340d13c1a3c2fd3108ad6f5" id="r_a35d0b8206340d13c1a3c2fd3108ad6f5"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_relational_formula_cell.html">RelationalFormulaCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35d0b8206340d13c1a3c2fd3108ad6f5">to_relational</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a35d0b8206340d13c1a3c2fd3108ad6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const RelationalFormulaCell&gt;</code>.  <br /></td></tr>
<tr class="memitem:a114b828a560f66f99ad8c007c7fe8a87" id="r_a114b828a560f66f99ad8c007c7fe8a87"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_eq.html">FormulaEq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a114b828a560f66f99ad8c007c7fe8a87">to_equal_to</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a114b828a560f66f99ad8c007c7fe8a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaEq&gt;</code>.  <br /></td></tr>
<tr class="memitem:a7c497ffa47a786ac3368318ced96bf59" id="r_a7c497ffa47a786ac3368318ced96bf59"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_neq.html">FormulaNeq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c497ffa47a786ac3368318ced96bf59">to_not_equal_to</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a7c497ffa47a786ac3368318ced96bf59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaNeq&gt;</code>.  <br /></td></tr>
<tr class="memitem:ac2a2dda8cb2b922f953d359f4036e3d8" id="r_ac2a2dda8cb2b922f953d359f4036e3d8"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_gt.html">FormulaGt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2a2dda8cb2b922f953d359f4036e3d8">to_greater_than</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:ac2a2dda8cb2b922f953d359f4036e3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaGt&gt;</code>.  <br /></td></tr>
<tr class="memitem:a7771171eaf02f03dd1ba8dedecb47920" id="r_a7771171eaf02f03dd1ba8dedecb47920"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_geq.html">FormulaGeq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7771171eaf02f03dd1ba8dedecb47920">to_greater_than_or_equal_to</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a7771171eaf02f03dd1ba8dedecb47920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaGeq&gt;</code>.  <br /></td></tr>
<tr class="memitem:ab3413a434f3062f2fb166447ab2a5957" id="r_ab3413a434f3062f2fb166447ab2a5957"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_lt.html">FormulaLt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3413a434f3062f2fb166447ab2a5957">to_less_than</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:ab3413a434f3062f2fb166447ab2a5957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaLt&gt;</code>.  <br /></td></tr>
<tr class="memitem:aed7bae580456c9c97c66fde521f9ba4b" id="r_aed7bae580456c9c97c66fde521f9ba4b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_leq.html">FormulaLeq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed7bae580456c9c97c66fde521f9ba4b">to_less_than_or_equal_to</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:aed7bae580456c9c97c66fde521f9ba4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaLeq&gt;</code>.  <br /></td></tr>
<tr class="memitem:a7ad8506492b71ef35438b982222fe7a2" id="r_a7ad8506492b71ef35438b982222fe7a2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_and.html">FormulaAnd</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ad8506492b71ef35438b982222fe7a2">to_conjunction</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a7ad8506492b71ef35438b982222fe7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaAnd&gt;</code>.  <br /></td></tr>
<tr class="memitem:aedf1aeb7366fd71f0a1e453059befe10" id="r_aedf1aeb7366fd71f0a1e453059befe10"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_or.html">FormulaOr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedf1aeb7366fd71f0a1e453059befe10">to_disjunction</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:aedf1aeb7366fd71f0a1e453059befe10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaOr&gt;</code>.  <br /></td></tr>
<tr class="memitem:ab743717efe7d701eec6cf5e6bf624195" id="r_ab743717efe7d701eec6cf5e6bf624195"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_nary_formula_cell.html">NaryFormulaCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab743717efe7d701eec6cf5e6bf624195">to_nary</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:ab743717efe7d701eec6cf5e6bf624195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const NaryFormulaCell&gt;</code>.  <br /></td></tr>
<tr class="memitem:af9ce9d7c42b2425a69e80351df215726" id="r_af9ce9d7c42b2425a69e80351df215726"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_not.html">FormulaNot</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9ce9d7c42b2425a69e80351df215726">to_negation</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:af9ce9d7c42b2425a69e80351df215726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaNot&gt;</code>.  <br /></td></tr>
<tr class="memitem:a128bda6d0407c2509719a983fbb14622" id="r_a128bda6d0407c2509719a983fbb14622"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_forall.html">FormulaForall</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a128bda6d0407c2509719a983fbb14622">to_forall</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a128bda6d0407c2509719a983fbb14622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaForall&gt;</code>.  <br /></td></tr>
<tr class="memitem:a68b7fb17c13137d8fe71c9afead52d0f" id="r_a68b7fb17c13137d8fe71c9afead52d0f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_isnan.html">FormulaIsnan</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68b7fb17c13137d8fe71c9afead52d0f">to_isnan</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a68b7fb17c13137d8fe71c9afead52d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaIsnan&gt;</code>.  <br /></td></tr>
<tr class="memitem:ac61b44814f737e4b79d59fe7fa448495" id="r_ac61b44814f737e4b79d59fe7fa448495"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_positive_semidefinite.html">FormulaPositiveSemidefinite</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac61b44814f737e4b79d59fe7fa448495">to_positive_semidefinite</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:ac61b44814f737e4b79d59fe7fa448495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaPositiveSemidefinite&gt;</code>.  <br /></td></tr>
<tr class="memitem:a975cce0c245364b8dfea662b296d7eb1" id="r_a975cce0c245364b8dfea662b296d7eb1"><td class="memTemplParams" colspan="2">template&lt;typename Result, typename Visitor, typename... Args&gt; </td></tr>
<tr class="memitem:a975cce0c245364b8dfea662b296d7eb1 template"><td class="memItemLeft" align="right" valign="top">Result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a975cce0c245364b8dfea662b296d7eb1">VisitFormula</a> (Visitor *v, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a975cce0c245364b8dfea662b296d7eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls visitor object <code class="param">v</code> with a symbolic formula <code class="param">f</code>, and arguments <code class="param">args</code>.  <br /></td></tr>
<tr class="memitem:a411e51a0c60278b06088ad1fa084e605" id="r_a411e51a0c60278b06088ad1fa084e605"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a411e51a0c60278b06088ad1fa084e605">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="memdesc:a411e51a0c60278b06088ad1fa084e605"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr class="memitem:af69250c699b4b8cbcbb54d322570d175" id="r_af69250c699b4b8cbcbb54d322570d175"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af69250c699b4b8cbcbb54d322570d175">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">Variable::Type</a> type)</td></tr>
<tr class="memdesc:af69250c699b4b8cbcbb54d322570d175"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr class="memitem:ac163e37c2a6109a9a469be234a3382d2" id="r_ac163e37c2a6109a9a469be234a3382d2"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac163e37c2a6109a9a469be234a3382d2">to_string</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">Variable::Type</a> &amp;type)</td></tr>
<tr class="memitem:aaa2767293dcf51a7e6c97ac205f9fb21" id="r_aaa2767293dcf51a7e6c97ac205f9fb21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa2767293dcf51a7e6c97ac205f9fb21">MakeMatrixVariable</a> (int rows, int cols, const std::string &amp;name, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">Variable::Type</a> type=<a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479ab1fa9dd3af034b3ef4291579aa673c07">Variable::Type::CONTINUOUS</a>)</td></tr>
<tr class="memdesc:aaa2767293dcf51a7e6c97ac205f9fb21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen matrix of symbolic variables.  <br /></td></tr>
<tr class="memitem:a077c5aa3c1d61b9bf22590e5325af815" id="r_a077c5aa3c1d61b9bf22590e5325af815"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a077c5aa3c1d61b9bf22590e5325af815">MakeMatrixBooleanVariable</a> (int rows, int cols, const std::string &amp;name)</td></tr>
<tr class="memdesc:a077c5aa3c1d61b9bf22590e5325af815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen matrix of symbolic Boolean variables.  <br /></td></tr>
<tr class="memitem:ac40449e991943b02a88f4627fd02c872" id="r_ac40449e991943b02a88f4627fd02c872"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac40449e991943b02a88f4627fd02c872">MakeMatrixBinaryVariable</a> (int rows, int cols, const std::string &amp;name)</td></tr>
<tr class="memdesc:ac40449e991943b02a88f4627fd02c872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen matrix of symbolic binary variables.  <br /></td></tr>
<tr class="memitem:a4881156a2dba929854529bbecb7bb2e2" id="r_a4881156a2dba929854529bbecb7bb2e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4881156a2dba929854529bbecb7bb2e2">MakeMatrixContinuousVariable</a> (int rows, int cols, const std::string &amp;name)</td></tr>
<tr class="memdesc:a4881156a2dba929854529bbecb7bb2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen matrix of symbolic continuous variables.  <br /></td></tr>
<tr class="memitem:aceffea98cb4dc7da681037dd3448e8a2" id="r_aceffea98cb4dc7da681037dd3448e8a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aceffea98cb4dc7da681037dd3448e8a2">MakeMatrixIntegerVariable</a> (int rows, int cols, const std::string &amp;name)</td></tr>
<tr class="memdesc:aceffea98cb4dc7da681037dd3448e8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen matrix of symbolic integer variables.  <br /></td></tr>
<tr class="memitem:a68e8b1ffb5f74f3ce63c46724e86936f" id="r_a68e8b1ffb5f74f3ce63c46724e86936f"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:a68e8b1ffb5f74f3ce63c46724e86936f template"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68e8b1ffb5f74f3ce63c46724e86936f">MakeMatrixVariable</a> (const std::string &amp;name, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">Variable::Type</a> type=<a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479ab1fa9dd3af034b3ef4291579aa673c07">Variable::Type::CONTINUOUS</a>)</td></tr>
<tr class="memdesc:a68e8b1ffb5f74f3ce63c46724e86936f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen matrix of symbolic variables.  <br /></td></tr>
<tr class="memitem:a294114651d7f14e697af924bdeab3be6" id="r_a294114651d7f14e697af924bdeab3be6"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:a294114651d7f14e697af924bdeab3be6 template"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a294114651d7f14e697af924bdeab3be6">MakeMatrixBooleanVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a294114651d7f14e697af924bdeab3be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen matrix of symbolic Boolean variables.  <br /></td></tr>
<tr class="memitem:a2e71bf8f0510b93790216b435d76b990" id="r_a2e71bf8f0510b93790216b435d76b990"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:a2e71bf8f0510b93790216b435d76b990 template"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e71bf8f0510b93790216b435d76b990">MakeMatrixBinaryVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a2e71bf8f0510b93790216b435d76b990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen matrix of symbolic binary variables.  <br /></td></tr>
<tr class="memitem:aaae2ea8fef645baa51e6cea3e54986aa" id="r_aaae2ea8fef645baa51e6cea3e54986aa"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:aaae2ea8fef645baa51e6cea3e54986aa template"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaae2ea8fef645baa51e6cea3e54986aa">MakeMatrixContinuousVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aaae2ea8fef645baa51e6cea3e54986aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen matrix of symbolic continuous variables.  <br /></td></tr>
<tr class="memitem:ac0fe9881160a77596c4b05b7ba61ee31" id="r_ac0fe9881160a77596c4b05b7ba61ee31"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:ac0fe9881160a77596c4b05b7ba61ee31 template"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0fe9881160a77596c4b05b7ba61ee31">MakeMatrixIntegerVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ac0fe9881160a77596c4b05b7ba61ee31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen matrix of symbolic integer variables.  <br /></td></tr>
<tr class="memitem:ae31d21987f2a78dacc64786ef86233cd" id="r_ae31d21987f2a78dacc64786ef86233cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae31d21987f2a78dacc64786ef86233cd">MakeVectorVariable</a> (int rows, const std::string &amp;name, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">Variable::Type</a> type=<a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479ab1fa9dd3af034b3ef4291579aa673c07">Variable::Type::CONTINUOUS</a>)</td></tr>
<tr class="memdesc:ae31d21987f2a78dacc64786ef86233cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen vector of symbolic variables.  <br /></td></tr>
<tr class="memitem:a1f7fee6b939582c5bd9f0020ebeb2c2a" id="r_a1f7fee6b939582c5bd9f0020ebeb2c2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f7fee6b939582c5bd9f0020ebeb2c2a">MakeVectorBooleanVariable</a> (int rows, const std::string &amp;name)</td></tr>
<tr class="memdesc:a1f7fee6b939582c5bd9f0020ebeb2c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen vector of symbolic Boolean variables.  <br /></td></tr>
<tr class="memitem:a9341ab1f18ff240083389ccdcb483ed3" id="r_a9341ab1f18ff240083389ccdcb483ed3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9341ab1f18ff240083389ccdcb483ed3">MakeVectorBinaryVariable</a> (int rows, const std::string &amp;name)</td></tr>
<tr class="memdesc:a9341ab1f18ff240083389ccdcb483ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen vector of symbolic binary variables.  <br /></td></tr>
<tr class="memitem:a9512d7058f85f0f5ddcf2ad601768d54" id="r_a9512d7058f85f0f5ddcf2ad601768d54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9512d7058f85f0f5ddcf2ad601768d54">MakeVectorContinuousVariable</a> (int rows, const std::string &amp;name)</td></tr>
<tr class="memdesc:a9512d7058f85f0f5ddcf2ad601768d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen vector of symbolic continuous variables.  <br /></td></tr>
<tr class="memitem:aa67f9414a4674809981130f03d1da9c0" id="r_aa67f9414a4674809981130f03d1da9c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa67f9414a4674809981130f03d1da9c0">MakeVectorIntegerVariable</a> (int rows, const std::string &amp;name)</td></tr>
<tr class="memdesc:aa67f9414a4674809981130f03d1da9c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen vector of symbolic integer variables.  <br /></td></tr>
<tr class="memitem:a2e7c156277f8c2d91bd0a59c1d498138" id="r_a2e7c156277f8c2d91bd0a59c1d498138"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a2e7c156277f8c2d91bd0a59c1d498138 template"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e7c156277f8c2d91bd0a59c1d498138">MakeVectorVariable</a> (const std::string &amp;name, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">Variable::Type</a> type=<a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479ab1fa9dd3af034b3ef4291579aa673c07">Variable::Type::CONTINUOUS</a>)</td></tr>
<tr class="memdesc:a2e7c156277f8c2d91bd0a59c1d498138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen vector of symbolic variables.  <br /></td></tr>
<tr class="memitem:ad19385116c11441853d823e47ad33aa7" id="r_ad19385116c11441853d823e47ad33aa7"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:ad19385116c11441853d823e47ad33aa7 template"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad19385116c11441853d823e47ad33aa7">MakeVectorBooleanVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ad19385116c11441853d823e47ad33aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen vector of symbolic Boolean variables.  <br /></td></tr>
<tr class="memitem:a5ada2f4cd5f626d2ed9d9b532362ddda" id="r_a5ada2f4cd5f626d2ed9d9b532362ddda"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a5ada2f4cd5f626d2ed9d9b532362ddda template"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ada2f4cd5f626d2ed9d9b532362ddda">MakeVectorBinaryVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a5ada2f4cd5f626d2ed9d9b532362ddda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen vector of symbolic binary variables.  <br /></td></tr>
<tr class="memitem:a7753f7705e1a8cc3bd01ea57d36ccd87" id="r_a7753f7705e1a8cc3bd01ea57d36ccd87"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a7753f7705e1a8cc3bd01ea57d36ccd87 template"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7753f7705e1a8cc3bd01ea57d36ccd87">MakeVectorContinuousVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a7753f7705e1a8cc3bd01ea57d36ccd87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen vector of symbolic continuous variables.  <br /></td></tr>
<tr class="memitem:a64a75ded73193f7ec7d332fd36af5bbb" id="r_a64a75ded73193f7ec7d332fd36af5bbb"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a64a75ded73193f7ec7d332fd36af5bbb template"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64a75ded73193f7ec7d332fd36af5bbb">MakeVectorIntegerVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a64a75ded73193f7ec7d332fd36af5bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen vector of symbolic integer variables.  <br /></td></tr>
<tr class="memitem:a83d142d09707408089d64c4a15c57ab7" id="r_a83d142d09707408089d64c4a15c57ab7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a83d142d09707408089d64c4a15c57ab7 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt; DerivedA, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;::value &amp;&amp;<a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt; DerivedB, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;::value, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83d142d09707408089d64c4a15c57ab7">CheckStructuralEquality</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:a83d142d09707408089d64c4a15c57ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two Eigen::Matrix&lt;Variable&gt; <code class="param">m1</code> and <code class="param">m2</code> are structurally equal.  <br /></td></tr>
<tr class="memitem:a63b70da62df0e5cd98c463b03038a175" id="r_a63b70da62df0e5cd98c463b03038a175"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63b70da62df0e5cd98c463b03038a175">operator+=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars1, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars2)</td></tr>
<tr class="memdesc:a63b70da62df0e5cd98c463b03038a175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <code class="param">var1</code> with the result of set-union(<code class="param">var1</code>, <code class="param">var2</code>).  <br /></td></tr>
<tr class="memitem:a3f8e3a0afbcb8a9b989e58d4377cb8c0" id="r_a3f8e3a0afbcb8a9b989e58d4377cb8c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f8e3a0afbcb8a9b989e58d4377cb8c0">operator+=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="memdesc:a3f8e3a0afbcb8a9b989e58d4377cb8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <code class="param">vars</code> with the result of set-union(<code class="param">vars</code>, { <code class="param">var</code> }).  <br /></td></tr>
<tr class="memitem:a0176708e0ff133d7166b2f4700832885" id="r_a0176708e0ff133d7166b2f4700832885"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0176708e0ff133d7166b2f4700832885">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> vars1, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars2)</td></tr>
<tr class="memdesc:a0176708e0ff133d7166b2f4700832885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set-union of <code class="param">var1</code> and <code class="param">var2</code>.  <br /></td></tr>
<tr class="memitem:a7d10380477ac001084ccc42d6aa005b6" id="r_a7d10380477ac001084ccc42d6aa005b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d10380477ac001084ccc42d6aa005b6">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> vars, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="memdesc:a7d10380477ac001084ccc42d6aa005b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set-union of <code class="param">vars</code> and {<code class="param">var}</code>.  <br /></td></tr>
<tr class="memitem:ac56aaa3de6bd181f40290eb9c9ab264e" id="r_ac56aaa3de6bd181f40290eb9c9ab264e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac56aaa3de6bd181f40290eb9c9ab264e">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var, <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> vars)</td></tr>
<tr class="memdesc:ac56aaa3de6bd181f40290eb9c9ab264e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set-union of {<code class="param">var}</code> and <code class="param">vars</code>.  <br /></td></tr>
<tr class="memitem:a61ada8774d03a585cc10d36fc7b4b007" id="r_a61ada8774d03a585cc10d36fc7b4b007"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61ada8774d03a585cc10d36fc7b4b007">operator-=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars1, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars2)</td></tr>
<tr class="memdesc:a61ada8774d03a585cc10d36fc7b4b007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <code class="param">var1</code> with the result of set-minus(<code class="param">var1</code>, <code class="param">var2</code>).  <br /></td></tr>
<tr class="memitem:abe694f2d15e6c4385d2f5d861099b51e" id="r_abe694f2d15e6c4385d2f5d861099b51e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe694f2d15e6c4385d2f5d861099b51e">operator-=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="memdesc:abe694f2d15e6c4385d2f5d861099b51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <code class="param">vars</code> with the result of set-minus(<code class="param">vars</code>, {<code class="param">var}</code>).  <br /></td></tr>
<tr class="memitem:ab15f6e5aa82236dcd5bfb4a310022997" id="r_ab15f6e5aa82236dcd5bfb4a310022997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab15f6e5aa82236dcd5bfb4a310022997">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> vars1, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars2)</td></tr>
<tr class="memdesc:ab15f6e5aa82236dcd5bfb4a310022997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set-minus(<code class="param">var1</code>, <code class="param">vars2</code>).  <br /></td></tr>
<tr class="memitem:a24e3c65798c6801e74fa2bf071c5f589" id="r_a24e3c65798c6801e74fa2bf071c5f589"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24e3c65798c6801e74fa2bf071c5f589">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> vars, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="memdesc:a24e3c65798c6801e74fa2bf071c5f589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set-minus(<code class="param">vars</code>, { <code class="param">var</code> }).  <br /></td></tr>
<tr class="memitem:adbfb5367e72dfbaf7a778e6896113f64" id="r_adbfb5367e72dfbaf7a778e6896113f64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbfb5367e72dfbaf7a778e6896113f64">intersect</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars1, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars2)</td></tr>
<tr class="memdesc:adbfb5367e72dfbaf7a778e6896113f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection of <code class="param">vars1</code> and <code class="param">vars2</code>.  <br /></td></tr>
<tr class="memitem:a63710a8d54f76e835b258885102859ec" id="r_a63710a8d54f76e835b258885102859ec"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:a63710a8d54f76e835b258885102859ec template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63710a8d54f76e835b258885102859ec">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;p)</td></tr>
<tr class="memitem:a9b8eb0200739107fb3a8d36ae80ed99b" id="r_a9b8eb0200739107fb3a8d36ae80ed99b"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:a9b8eb0200739107fb3a8d36ae80ed99b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b8eb0200739107fb3a8d36ae80ed99b">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p1, const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;p2)</td></tr>
<tr class="memitem:a4bafc617451743d2ddf608aa2c08dd71" id="r_a4bafc617451743d2ddf608aa2c08dd71"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:a4bafc617451743d2ddf608aa2c08dd71 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bafc617451743d2ddf608aa2c08dd71">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p, const BasisElement &amp;m)</td></tr>
<tr class="memitem:a69687593429f546fb96c6298712bbad5" id="r_a69687593429f546fb96c6298712bbad5"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:a69687593429f546fb96c6298712bbad5 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69687593429f546fb96c6298712bbad5">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p, double c)</td></tr>
<tr class="memitem:a08a9fa5e93b7cd9537d31b957ac91251" id="r_a08a9fa5e93b7cd9537d31b957ac91251"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:a08a9fa5e93b7cd9537d31b957ac91251 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08a9fa5e93b7cd9537d31b957ac91251">operator+</a> (const BasisElement &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p)</td></tr>
<tr class="memitem:aadaf8a9e57bdd9678f6026b8e7899130" id="r_aadaf8a9e57bdd9678f6026b8e7899130"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:aadaf8a9e57bdd9678f6026b8e7899130 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadaf8a9e57bdd9678f6026b8e7899130">operator+</a> (const BasisElement &amp;m1, const BasisElement &amp;m2)</td></tr>
<tr class="memitem:a4f71101776f748d68a527275be5335bf" id="r_a4f71101776f748d68a527275be5335bf"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:a4f71101776f748d68a527275be5335bf template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f71101776f748d68a527275be5335bf">operator+</a> (const BasisElement &amp;m, double c)</td></tr>
<tr class="memitem:aeeb112e0e9010afde895dbde2139f09a" id="r_aeeb112e0e9010afde895dbde2139f09a"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:aeeb112e0e9010afde895dbde2139f09a template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeeb112e0e9010afde895dbde2139f09a">operator+</a> (double c, <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p)</td></tr>
<tr class="memitem:abf046f3e0b64c3749dce4dfbddaaefda" id="r_abf046f3e0b64c3749dce4dfbddaaefda"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:abf046f3e0b64c3749dce4dfbddaaefda template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf046f3e0b64c3749dce4dfbddaaefda">operator+</a> (double c, const BasisElement &amp;m)</td></tr>
<tr class="memitem:acc55a6a39a5555cc6bf7bdc398c046fc" id="r_acc55a6a39a5555cc6bf7bdc398c046fc"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:acc55a6a39a5555cc6bf7bdc398c046fc template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc55a6a39a5555cc6bf7bdc398c046fc">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="memitem:a5f259fc8f615afffd8901318602c37db" id="r_a5f259fc8f615afffd8901318602c37db"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:a5f259fc8f615afffd8901318602c37db template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f259fc8f615afffd8901318602c37db">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p)</td></tr>
<tr class="memitem:a3f3c47a396ac8d468bf5f2f45e230de3" id="r_a3f3c47a396ac8d468bf5f2f45e230de3"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:a3f3c47a396ac8d468bf5f2f45e230de3 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f3c47a396ac8d468bf5f2f45e230de3">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p1, const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;p2)</td></tr>
<tr class="memitem:a17ca7e584216ee1fea23c512c45bad90" id="r_a17ca7e584216ee1fea23c512c45bad90"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:a17ca7e584216ee1fea23c512c45bad90 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17ca7e584216ee1fea23c512c45bad90">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p, const BasisElement &amp;m)</td></tr>
<tr class="memitem:aefd3a8bbf787fda994df54be2a27ee9a" id="r_aefd3a8bbf787fda994df54be2a27ee9a"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:aefd3a8bbf787fda994df54be2a27ee9a template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefd3a8bbf787fda994df54be2a27ee9a">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p, double c)</td></tr>
<tr class="memitem:a0096960e4dcb5c6258a38bee7c16d72e" id="r_a0096960e4dcb5c6258a38bee7c16d72e"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:a0096960e4dcb5c6258a38bee7c16d72e template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0096960e4dcb5c6258a38bee7c16d72e">operator-</a> (const BasisElement &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p)</td></tr>
<tr class="memitem:ab821b0c64d442826c0a991c3de361b6b" id="r_ab821b0c64d442826c0a991c3de361b6b"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:ab821b0c64d442826c0a991c3de361b6b template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab821b0c64d442826c0a991c3de361b6b">operator-</a> (const BasisElement &amp;m1, const BasisElement &amp;m2)</td></tr>
<tr class="memitem:a14bc553c23b60390c291e4a67c40df4d" id="r_a14bc553c23b60390c291e4a67c40df4d"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:a14bc553c23b60390c291e4a67c40df4d template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14bc553c23b60390c291e4a67c40df4d">operator-</a> (const BasisElement &amp;m, double c)</td></tr>
<tr class="memitem:a1f44f4beff2210528a3ecccb58dd4804" id="r_a1f44f4beff2210528a3ecccb58dd4804"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:a1f44f4beff2210528a3ecccb58dd4804 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f44f4beff2210528a3ecccb58dd4804">operator-</a> (double c, <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p)</td></tr>
<tr class="memitem:a4d2041a414f01d6e9f106335ed5dd899" id="r_a4d2041a414f01d6e9f106335ed5dd899"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:a4d2041a414f01d6e9f106335ed5dd899 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d2041a414f01d6e9f106335ed5dd899">operator-</a> (double c, const BasisElement &amp;m)</td></tr>
<tr class="memitem:a1676f2a150914291663b452854d91130" id="r_a1676f2a150914291663b452854d91130"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:a1676f2a150914291663b452854d91130 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1676f2a150914291663b452854d91130">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="memitem:a2c9898ab369984f945de0515f25d6ed6" id="r_a2c9898ab369984f945de0515f25d6ed6"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:a2c9898ab369984f945de0515f25d6ed6 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c9898ab369984f945de0515f25d6ed6">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p)</td></tr>
<tr class="memitem:a27ba3edbf8685b85b205325292578087" id="r_a27ba3edbf8685b85b205325292578087"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:a27ba3edbf8685b85b205325292578087 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27ba3edbf8685b85b205325292578087">operator*</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p1, const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;p2)</td></tr>
<tr class="memitem:a6d5903da758c3263027fe2d3879eb883" id="r_a6d5903da758c3263027fe2d3879eb883"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:a6d5903da758c3263027fe2d3879eb883 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d5903da758c3263027fe2d3879eb883">operator*</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p, const BasisElement &amp;m)</td></tr>
<tr class="memitem:a0e099436a8bc0e61fb6b7a18e673e7eb" id="r_a0e099436a8bc0e61fb6b7a18e673e7eb"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:a0e099436a8bc0e61fb6b7a18e673e7eb template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e099436a8bc0e61fb6b7a18e673e7eb">operator*</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p, double c)</td></tr>
<tr class="memitem:ad432e40263668f90f62a421d67c66f5f" id="r_ad432e40263668f90f62a421d67c66f5f"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:ad432e40263668f90f62a421d67c66f5f template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad432e40263668f90f62a421d67c66f5f">operator*</a> (const BasisElement &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p)</td></tr>
<tr class="memitem:a6b40dd59bc3bbf7d7d66bc8653a66437" id="r_a6b40dd59bc3bbf7d7d66bc8653a66437"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:a6b40dd59bc3bbf7d7d66bc8653a66437 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b40dd59bc3bbf7d7d66bc8653a66437">operator*</a> (const BasisElement &amp;m, double c)</td></tr>
<tr class="memitem:a67779390665ae921316f2fed4d5bbc5d" id="r_a67779390665ae921316f2fed4d5bbc5d"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:a67779390665ae921316f2fed4d5bbc5d template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67779390665ae921316f2fed4d5bbc5d">operator*</a> (double c, <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p)</td></tr>
<tr class="memitem:a1f0f7c92e16ecceaef0a148919ccfdb4" id="r_a1f0f7c92e16ecceaef0a148919ccfdb4"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:a1f0f7c92e16ecceaef0a148919ccfdb4 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f0f7c92e16ecceaef0a148919ccfdb4">operator*</a> (double c, const BasisElement &amp;m)</td></tr>
<tr class="memitem:a64fedfabf66785a5397ef80ee3388a12" id="r_a64fedfabf66785a5397ef80ee3388a12"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:a64fedfabf66785a5397ef80ee3388a12 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64fedfabf66785a5397ef80ee3388a12">operator*</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="memitem:aaf28234a16f99392d95b9ae31fe3cb68" id="r_aaf28234a16f99392d95b9ae31fe3cb68"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:aaf28234a16f99392d95b9ae31fe3cb68 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf28234a16f99392d95b9ae31fe3cb68">operator*</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p)</td></tr>
<tr class="memitem:afe3877f48503b37c421e051962900121" id="r_afe3877f48503b37c421e051962900121"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:afe3877f48503b37c421e051962900121 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe3877f48503b37c421e051962900121">operator/</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p, double v)</td></tr>
<tr class="memdesc:afe3877f48503b37c421e051962900121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">p / v</span>.  <br /></td></tr>
<tr class="memitem:aa790991ea69175051e7324d12302ad52" id="r_aa790991ea69175051e7324d12302ad52"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:aa790991ea69175051e7324d12302ad52 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa790991ea69175051e7324d12302ad52">pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;p, int n)</td></tr>
<tr class="memdesc:aa790991ea69175051e7324d12302ad52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns polynomial <code class="param">raised</code> to <code class="param">n</code>.  <br /></td></tr>
<tr class="memitem:a36547d6c95341875bc899be1bd1c27d1" id="r_a36547d6c95341875bc899be1bd1c27d1"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:a36547d6c95341875bc899be1bd1c27d1 template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36547d6c95341875bc899be1bd1c27d1">to_string</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;p)</td></tr>
<tr class="memitem:aab36f2eb0e38222af36d1499d0a2f47a" id="r_aab36f2eb0e38222af36d1499d0a2f47a"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement&gt; </td></tr>
<tr class="memitem:aab36f2eb0e38222af36d1499d0a2f47a template"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab36f2eb0e38222af36d1499d0a2f47a">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;p)</td></tr>
<tr class="memdesc:aab36f2eb0e38222af36d1499d0a2f47a"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr class="memitem:ac98eda5e1ecf8e4ca123d898f2cec6fe" id="r_ac98eda5e1ecf8e4ca123d898f2cec6fe"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac98eda5e1ecf8e4ca123d898f2cec6fe">ToLatex</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, int precision=3)</td></tr>
<tr class="memdesc:ac98eda5e1ecf8e4ca123d898f2cec6fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a LaTeX string representation of <span class="tt">e</span> with floating point coefficients displayed using <span class="tt">precision</span>.  <br /></td></tr>
<tr class="memitem:a792037568d9fe9ad837351c523146ada" id="r_a792037568d9fe9ad837351c523146ada"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a792037568d9fe9ad837351c523146ada">ToLatex</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f, int precision=3)</td></tr>
<tr class="memdesc:a792037568d9fe9ad837351c523146ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a LaTeX string representation of <span class="tt">f</span> with floating point coefficients displayed using <span class="tt">precision</span>.  <br /></td></tr>
<tr class="memitem:a2c784608acef125ad519984e49395059" id="r_a2c784608acef125ad519984e49395059"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c784608acef125ad519984e49395059">ToLatex</a> (double val, int precision=3)</td></tr>
<tr class="memdesc:a2c784608acef125ad519984e49395059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a Latex string representation of <span class="tt">val</span> displayed with <span class="tt">precision</span>, with one exception.  <br /></td></tr>
<tr class="memitem:ad07c658dafebaf56057941ccae6f81c4" id="r_ad07c658dafebaf56057941ccae6f81c4"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:ad07c658dafebaf56057941ccae6f81c4 template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad07c658dafebaf56057941ccae6f81c4">ToLatex</a> (const Eigen::PlainObjectBase&lt; Derived &gt; &amp;M, int precision=3)</td></tr>
<tr class="memdesc:ad07c658dafebaf56057941ccae6f81c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a LaTeX string representation of <span class="tt">M</span> with floating point coefficients displayed using <span class="tt">precision</span>.  <br /></td></tr>
<tr class="memitem:ada77c9969b0422090c05636a895c0e8e" id="r_ada77c9969b0422090c05636a895c0e8e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada77c9969b0422090c05636a895c0e8e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="memdesc:ada77c9969b0422090c05636a895c0e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr class="memitem:ad5eb41b274605738d8049c0f0440c9ec" id="r_ad5eb41b274605738d8049c0f0440c9ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5eb41b274605738d8049c0f0440c9ec">operator*</a> (<a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> m1, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m2)</td></tr>
<tr class="memdesc:ad5eb41b274605738d8049c0f0440c9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a multiplication of two monomials, <span class="tt">m1</span> and <span class="tt">m2</span>.  <br /></td></tr>
<tr class="memitem:ad9fccbdfb814f10727e3b23ef0b6a20f" id="r_ad9fccbdfb814f10727e3b23ef0b6a20f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9fccbdfb814f10727e3b23ef0b6a20f">pow</a> (<a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> m, int p)</td></tr>
<tr class="memdesc:ad9fccbdfb814f10727e3b23ef0b6a20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">m</span> raised to <span class="tt">p</span>.  <br /></td></tr>
<tr class="memitem:af3dc291b1ebd331cf320000abb9817cc" id="r_af3dc291b1ebd331cf320000abb9817cc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3dc291b1ebd331cf320000abb9817cc">to_string</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a> &amp;m)</td></tr>
<tr class="memitem:aebaa1c50ddcd18c8de9ba5ebc01f3989" id="r_aebaa1c50ddcd18c8de9ba5ebc01f3989"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebaa1c50ddcd18c8de9ba5ebc01f3989">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a> &amp;m)</td></tr>
<tr class="memdesc:aebaa1c50ddcd18c8de9ba5ebc01f3989"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr class="memitem:ac8c98dff8a011e805179c01ac7f652c9" id="r_ac8c98dff8a011e805179c01ac7f652c9"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a>, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8c98dff8a011e805179c01ac7f652c9">operator*</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a> &amp;m1, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a> &amp;m2)</td></tr>
<tr class="memdesc:ac8c98dff8a011e805179c01ac7f652c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a multiplication of two monomials, <code class="param">m1</code> and <code class="param">m2</code>.  <br /></td></tr>
<tr class="memitem:a0c35c520e88da642e19a0a30c332528f" id="r_a0c35c520e88da642e19a0a30c332528f"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a>, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c35c520e88da642e19a0a30c332528f">pow</a> (<a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a> m, int p)</td></tr>
<tr class="memdesc:a0c35c520e88da642e19a0a30c332528f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code class="param">m</code> raised to <code class="param">p</code>.  <br /></td></tr>
<tr class="memitem:adc6302f8ed7ce764202bffb915277dc2" id="r_adc6302f8ed7ce764202bffb915277dc2"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc6302f8ed7ce764202bffb915277dc2">MonomialBasis</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars, int degree)</td></tr>
<tr class="memdesc:adc6302f8ed7ce764202bffb915277dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all monomials up to a given degree under the graded reverse lexicographic order.  <br /></td></tr>
<tr class="memitem:a873c3185813c9ca5a6ca690669698518" id="r_a873c3185813c9ca5a6ca690669698518"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a873c3185813c9ca5a6ca690669698518">NChooseK</a> (int n, int k)</td></tr>
<tr class="memitem:a522ebdd58f8672ca038fb6fbfdce4534" id="r_a522ebdd58f8672ca038fb6fbfdce4534"><td class="memTemplParams" colspan="2">template&lt;int n, int degree&gt; </td></tr>
<tr class="memitem:a522ebdd58f8672ca038fb6fbfdce4534 template"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, <a class="el" href="#a873c3185813c9ca5a6ca690669698518">NChooseK</a>(n+degree, degree), 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a522ebdd58f8672ca038fb6fbfdce4534">MonomialBasis</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars)</td></tr>
<tr class="memdesc:a522ebdd58f8672ca038fb6fbfdce4534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all monomials up to a given degree under the graded reverse lexicographic order.  <br /></td></tr>
<tr class="memitem:aa926fea06c17ca6892965848c0236c9b" id="r_aa926fea06c17ca6892965848c0236c9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa926fea06c17ca6892965848c0236c9b">MonomialBasis</a> (const std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>, int &gt; &amp;variables_degree)</td></tr>
<tr class="memdesc:aa926fea06c17ca6892965848c0236c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all the monomials (in graded reverse lexicographic order) such that the total degree for each set of variables is no larger than a specific degree.  <br /></td></tr>
<tr class="memitem:a88ddd8d42b90d109f5d7312db729a959" id="r_a88ddd8d42b90d109f5d7312db729a959"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88ddd8d42b90d109f5d7312db729a959">EvenDegreeMonomialBasis</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars, int degree)</td></tr>
<tr class="memdesc:a88ddd8d42b90d109f5d7312db729a959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all even degree monomials up to a given degree under the graded reverse lexicographic order.  <br /></td></tr>
<tr class="memitem:afb92bbabf88873d1766586c031a6f3e2" id="r_afb92bbabf88873d1766586c031a6f3e2"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb92bbabf88873d1766586c031a6f3e2">OddDegreeMonomialBasis</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars, int degree)</td></tr>
<tr class="memdesc:afb92bbabf88873d1766586c031a6f3e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all odd degree monomials up to a given degree under the graded reverse lexicographic order.  <br /></td></tr>
<tr class="memitem:ab45e72ece70fdb6eba8afcfc7b773c76" id="r_ab45e72ece70fdb6eba8afcfc7b773c76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab45e72ece70fdb6eba8afcfc7b773c76">CalcMonomialBasisOrderUpToOne</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;x, bool sort_monomial=false)</td></tr>
<tr class="memdesc:ab45e72ece70fdb6eba8afcfc7b773c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates all the monomials of <span class="tt">x</span>, such that the degree for x(i) is no larger than 1 for every x(i) in <span class="tt">x</span>.  <br /></td></tr>
<tr class="memitem:af36c077e8377e8f6f79da19b22034a88" id="r_af36c077e8377e8f6f79da19b22034a88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af36c077e8377e8f6f79da19b22034a88">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="memdesc:af36c077e8377e8f6f79da19b22034a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operation for polynomial.  <br /></td></tr>
<tr class="memitem:af24522315ccc26ae75f90fe52edf75f8" id="r_af24522315ccc26ae75f90fe52edf75f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af24522315ccc26ae75f90fe52edf75f8">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p1, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p2)</td></tr>
<tr class="memitem:a1e385d568eb0ddc41d5b2dac2e081be0" id="r_a1e385d568eb0ddc41d5b2dac2e081be0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e385d568eb0ddc41d5b2dac2e081be0">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="memitem:af815e05dc1e773d924b5a761def81cbc" id="r_af815e05dc1e773d924b5a761def81cbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af815e05dc1e773d924b5a761def81cbc">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, double c)</td></tr>
<tr class="memitem:a8f71e04c7645cc414e256fd4dd5bb868" id="r_a8f71e04c7645cc414e256fd4dd5bb868"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f71e04c7645cc414e256fd4dd5bb868">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="memitem:a3624f7d482fabd5c332896a9c5c94734" id="r_a3624f7d482fabd5c332896a9c5c94734"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3624f7d482fabd5c332896a9c5c94734">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m1, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m2)</td></tr>
<tr class="memitem:acb5a9659a11c5ee575468598af3a1234" id="r_acb5a9659a11c5ee575468598af3a1234"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb5a9659a11c5ee575468598af3a1234">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, double c)</td></tr>
<tr class="memitem:a2ed2f8193622c6f565730970d1aed056" id="r_a2ed2f8193622c6f565730970d1aed056"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ed2f8193622c6f565730970d1aed056">operator+</a> (double c, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="memitem:ab4870c39dd0f76fa28c59bcf791863fd" id="r_ab4870c39dd0f76fa28c59bcf791863fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4870c39dd0f76fa28c59bcf791863fd">operator+</a> (double c, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="memitem:aebd0c790d7f80f2b396f05e17c67d056" id="r_aebd0c790d7f80f2b396f05e17c67d056"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebd0c790d7f80f2b396f05e17c67d056">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="memitem:a040f17cc92f514c54410eafcd5b62e72" id="r_a040f17cc92f514c54410eafcd5b62e72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a040f17cc92f514c54410eafcd5b62e72">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="memitem:a7526af799be25855a26020f2dace6e3d" id="r_a7526af799be25855a26020f2dace6e3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7526af799be25855a26020f2dace6e3d">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="memitem:a93ac6ff834c014e5dc9c7050c5d26a3e" id="r_a93ac6ff834c014e5dc9c7050c5d26a3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93ac6ff834c014e5dc9c7050c5d26a3e">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memitem:a2e5b784ac8ef76dc1d5295d1d4d6f89a" id="r_a2e5b784ac8ef76dc1d5295d1d4d6f89a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e5b784ac8ef76dc1d5295d1d4d6f89a">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p1, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p2)</td></tr>
<tr class="memitem:a47ad706c6f9ac6d8413383d8152c4b51" id="r_a47ad706c6f9ac6d8413383d8152c4b51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47ad706c6f9ac6d8413383d8152c4b51">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="memitem:a07c397de070f92d19567a8c0c73d327e" id="r_a07c397de070f92d19567a8c0c73d327e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07c397de070f92d19567a8c0c73d327e">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, double c)</td></tr>
<tr class="memitem:a4f70ed5b694fb54c450571f7e954ca64" id="r_a4f70ed5b694fb54c450571f7e954ca64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f70ed5b694fb54c450571f7e954ca64">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="memitem:a3a25d63b978c1df701182843ce44f0ca" id="r_a3a25d63b978c1df701182843ce44f0ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a25d63b978c1df701182843ce44f0ca">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m1, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m2)</td></tr>
<tr class="memitem:a887493584a26c3184345aeb2771452b2" id="r_a887493584a26c3184345aeb2771452b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a887493584a26c3184345aeb2771452b2">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, double c)</td></tr>
<tr class="memitem:ad94604e34addd7ab076028c07b2c34ab" id="r_ad94604e34addd7ab076028c07b2c34ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad94604e34addd7ab076028c07b2c34ab">operator-</a> (double c, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="memitem:af88644b55b7486916d5b86ba9fb77ac1" id="r_af88644b55b7486916d5b86ba9fb77ac1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af88644b55b7486916d5b86ba9fb77ac1">operator-</a> (double c, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="memitem:ad77a50d7df89fae73fa46eb7396ac3a0" id="r_ad77a50d7df89fae73fa46eb7396ac3a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad77a50d7df89fae73fa46eb7396ac3a0">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="memitem:a54bcaf5825f2f80f109635e0703018bf" id="r_a54bcaf5825f2f80f109635e0703018bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54bcaf5825f2f80f109635e0703018bf">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="memitem:a95404d48e05dca0c0c3af3ec6bf387db" id="r_a95404d48e05dca0c0c3af3ec6bf387db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95404d48e05dca0c0c3af3ec6bf387db">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="memitem:aeee94abcf94c5c3efac678b457cd3b3a" id="r_aeee94abcf94c5c3efac678b457cd3b3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeee94abcf94c5c3efac678b457cd3b3a">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memitem:a60c0402d8a4ab5d50003560ddccdb3a6" id="r_a60c0402d8a4ab5d50003560ddccdb3a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60c0402d8a4ab5d50003560ddccdb3a6">operator*</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p1, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p2)</td></tr>
<tr class="memitem:a82a1e5c6f989d9eb82b47f06df766264" id="r_a82a1e5c6f989d9eb82b47f06df766264"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82a1e5c6f989d9eb82b47f06df766264">operator*</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="memitem:aa927bf74086ce7d6a35bbe805e90dd4c" id="r_aa927bf74086ce7d6a35bbe805e90dd4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa927bf74086ce7d6a35bbe805e90dd4c">operator*</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, double c)</td></tr>
<tr class="memitem:a45f74794ee4a396e8fd39b44665c2a62" id="r_a45f74794ee4a396e8fd39b44665c2a62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45f74794ee4a396e8fd39b44665c2a62">operator*</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="memitem:a335b835b158bb74b8c176f0a9d0d98b3" id="r_a335b835b158bb74b8c176f0a9d0d98b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a335b835b158bb74b8c176f0a9d0d98b3">operator*</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, double c)</td></tr>
<tr class="memitem:a36b5a1a34fd92c6df9037af080ba1913" id="r_a36b5a1a34fd92c6df9037af080ba1913"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36b5a1a34fd92c6df9037af080ba1913">operator*</a> (double c, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="memitem:a30e80d8ac3887ff8b4c0368edf473436" id="r_a30e80d8ac3887ff8b4c0368edf473436"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30e80d8ac3887ff8b4c0368edf473436">operator*</a> (double c, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="memitem:ae03557c00e4297b310ef75c16f48f3b3" id="r_ae03557c00e4297b310ef75c16f48f3b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae03557c00e4297b310ef75c16f48f3b3">operator*</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="memitem:a85a5b653c9cc881bd5995e5affbfa0d0" id="r_a85a5b653c9cc881bd5995e5affbfa0d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85a5b653c9cc881bd5995e5affbfa0d0">operator*</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="memitem:ae55ea800cf249789ff0c149ce44affea" id="r_ae55ea800cf249789ff0c149ce44affea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae55ea800cf249789ff0c149ce44affea">operator*</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="memitem:ac1151332b14909d80e32a755b5a4bcfb" id="r_ac1151332b14909d80e32a755b5a4bcfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1151332b14909d80e32a755b5a4bcfb">operator*</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memitem:a05b3624316b66d6957ab849780f51a5a" id="r_a05b3624316b66d6957ab849780f51a5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05b3624316b66d6957ab849780f51a5a">operator/</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, double v)</td></tr>
<tr class="memdesc:a05b3624316b66d6957ab849780f51a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">p / v</span>.  <br /></td></tr>
<tr class="memitem:ab8141e1f59b8161bf1c985ecaf485b0f" id="r_ab8141e1f59b8161bf1c985ecaf485b0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8141e1f59b8161bf1c985ecaf485b0f">operator/</a> (double v, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="memitem:a95555bac413dee5fe5e2bd57d18493e9" id="r_a95555bac413dee5fe5e2bd57d18493e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95555bac413dee5fe5e2bd57d18493e9">operator/</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="memitem:a7366e0c649e02fd21e85f3f3748fb5fb" id="r_a7366e0c649e02fd21e85f3f3748fb5fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7366e0c649e02fd21e85f3f3748fb5fb">operator/</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memitem:a2996d1aeb389e57074bef357b2db3585" id="r_a2996d1aeb389e57074bef357b2db3585"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2996d1aeb389e57074bef357b2db3585">pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, int n)</td></tr>
<tr class="memdesc:a2996d1aeb389e57074bef357b2db3585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns polynomial <span class="tt">p</span> raised to <span class="tt">n</span>.  <br /></td></tr>
<tr class="memitem:a3bc94e9465444b70978c2250c37722f5" id="r_a3bc94e9465444b70978c2250c37722f5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bc94e9465444b70978c2250c37722f5">to_string</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="memitem:ad946994348eafef6d3e20ebc08bfa5d2" id="r_ad946994348eafef6d3e20ebc08bfa5d2"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad946994348eafef6d3e20ebc08bfa5d2">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="memdesc:ad946994348eafef6d3e20ebc08bfa5d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr class="memitem:ab12259a0866a3cbc6a8883ec0b8009b1" id="r_ab12259a0866a3cbc6a8883ec0b8009b1"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL, typename MatrixR&gt; </td></tr>
<tr class="memitem:ab12259a0866a3cbc6a8883ec0b8009b1 template"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab12259a0866a3cbc6a8883ec0b8009b1">operator*</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:ab12259a0866a3cbc6a8883ec0b8009b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following matrix operations:  <br /></td></tr>
<tr class="memitem:ac0307b6ce5db3cdd869f02b790c89d0b" id="r_ac0307b6ce5db3cdd869f02b790c89d0b"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:ac0307b6ce5db3cdd869f02b790c89d0b template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &gt;, <a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; double, Derived &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0307b6ce5db3cdd869f02b790c89d0b">Evaluate</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;env)</td></tr>
<tr class="memdesc:ac0307b6ce5db3cdd869f02b790c89d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a matrix <span class="tt">m</span> of symbolic polynomials using <span class="tt">env</span>.  <br /></td></tr>
<tr class="memitem:a1470c88dce76c089a696e9957d454d06" id="r_a1470c88dce76c089a696e9957d454d06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1470c88dce76c089a696e9957d454d06">Jacobian</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &gt; &gt; &amp;f, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &gt; &amp;vars)</td></tr>
<tr class="memdesc:a1470c88dce76c089a696e9957d454d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian matrix J of the vector function <span class="tt">f</span> with respect to <span class="tt">vars</span>.  <br /></td></tr>
<tr class="memitem:a9a564c13b0f2dfdd43264f378f5d5ee1" id="r_a9a564c13b0f2dfdd43264f378f5d5ee1"><td class="memTemplParams" colspan="2">template&lt;typename Derived1, typename Derived2&gt; </td></tr>
<tr class="memitem:a9a564c13b0f2dfdd43264f378f5d5ee1 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt; Derived1, <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;::value &amp;&amp;(<a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt; Derived2, double &gt;::value||<a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt; Derived2, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;::value||<a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt; Derived2, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;::value), <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a564c13b0f2dfdd43264f378f5d5ee1">CalcPolynomialWLowerTriangularPart</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;monomial_basis, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;gram_lower)</td></tr>
<tr class="memdesc:a9a564c13b0f2dfdd43264f378f5d5ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the polynomial m(x)ᵀ * Q * m(x), where m(x) is the monomial basis, and Q is the Gram matrix.  <br /></td></tr>
<tr class="memitem:a2f254dc74f6fa876d91ecaeed7e9683f" id="r_a2f254dc74f6fa876d91ecaeed7e9683f"><td class="memTemplParams" colspan="2">template&lt;int rows, typename BasisElement&gt; </td></tr>
<tr class="memitem:a2f254dc74f6fa876d91ecaeed7e9683f template"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; BasisElement, rows, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f254dc74f6fa876d91ecaeed7e9683f">ComputePolynomialBasisUpToDegree</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars, int degree, internal::DegreeType degree_type)</td></tr>
<tr class="memdesc:a2f254dc74f6fa876d91ecaeed7e9683f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all polynomial basis elements up to a given degree under the graded reverse lexicographic order.  <br /></td></tr>
<tr class="memitem:a90f257b9087b47d0579d8e7d9631abb4" id="r_a90f257b9087b47d0579d8e7d9631abb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90f257b9087b47d0579d8e7d9631abb4">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f1, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f2)</td></tr>
<tr class="memitem:a6ab71a213952c1f284526102a4356381" id="r_a6ab71a213952c1f284526102a4356381"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ab71a213952c1f284526102a4356381">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="memitem:a0801308a64278437b3734f11cc813da5" id="r_a0801308a64278437b3734f11cc813da5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0801308a64278437b3734f11cc813da5">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="memitem:a5d664e2d28875d2a98edc0fb0fd3fe13" id="r_a5d664e2d28875d2a98edc0fb0fd3fe13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d664e2d28875d2a98edc0fb0fd3fe13">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="memitem:a395a3505af09308c3bc0c8ebf55c3afb" id="r_a395a3505af09308c3bc0c8ebf55c3afb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a395a3505af09308c3bc0c8ebf55c3afb">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="memitem:abc56bda0a18e846fe326ac025e01a45d" id="r_abc56bda0a18e846fe326ac025e01a45d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc56bda0a18e846fe326ac025e01a45d">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, double c)</td></tr>
<tr class="memitem:a001ec416bb7ee68695e1ec9a65b98720" id="r_a001ec416bb7ee68695e1ec9a65b98720"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a001ec416bb7ee68695e1ec9a65b98720">operator+</a> (double c, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="memitem:a084bf309d07e7c8560b89bcf3f7523a2" id="r_a084bf309d07e7c8560b89bcf3f7523a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a084bf309d07e7c8560b89bcf3f7523a2">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f1, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f2)</td></tr>
<tr class="memitem:a42cb7637d5591968374ac16f95d7ca68" id="r_a42cb7637d5591968374ac16f95d7ca68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42cb7637d5591968374ac16f95d7ca68">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="memitem:a408fb0f03f4fde816c1affebe3cb19c2" id="r_a408fb0f03f4fde816c1affebe3cb19c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a408fb0f03f4fde816c1affebe3cb19c2">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f)</td></tr>
<tr class="memitem:a67dbb91e91fae264abe9d39a6c167fe3" id="r_a67dbb91e91fae264abe9d39a6c167fe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67dbb91e91fae264abe9d39a6c167fe3">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, double c)</td></tr>
<tr class="memitem:a417daa8f767bb80ebf2b775eede4ad76" id="r_a417daa8f767bb80ebf2b775eede4ad76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a417daa8f767bb80ebf2b775eede4ad76">operator-</a> (double c, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="memitem:a1b2dcc0fc8eac4d6edf356e350128354" id="r_a1b2dcc0fc8eac4d6edf356e350128354"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b2dcc0fc8eac4d6edf356e350128354">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="memitem:a22eee8b618367ee530884a25714761a4" id="r_a22eee8b618367ee530884a25714761a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22eee8b618367ee530884a25714761a4">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="memitem:a47e353ad2f92e91622a6554945c10190" id="r_a47e353ad2f92e91622a6554945c10190"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47e353ad2f92e91622a6554945c10190">operator*</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f1, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f2)</td></tr>
<tr class="memitem:a5da13e9a5ae37fbfea7bd661cc15b3f8" id="r_a5da13e9a5ae37fbfea7bd661cc15b3f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5da13e9a5ae37fbfea7bd661cc15b3f8">operator*</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="memitem:ac96d8eb0d54db155ab9f2ae5b3057c2f" id="r_ac96d8eb0d54db155ab9f2ae5b3057c2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac96d8eb0d54db155ab9f2ae5b3057c2f">operator*</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="memitem:ab92318b3c84edc12ed69faa7098c9ccc" id="r_ab92318b3c84edc12ed69faa7098c9ccc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab92318b3c84edc12ed69faa7098c9ccc">operator*</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, double c)</td></tr>
<tr class="memitem:ae6654fd307d9348f2baa46da2ff3abd3" id="r_ae6654fd307d9348f2baa46da2ff3abd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6654fd307d9348f2baa46da2ff3abd3">operator*</a> (double c, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="memitem:a474c15a8d4808149c8dfc6dbab6eda4b" id="r_a474c15a8d4808149c8dfc6dbab6eda4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a474c15a8d4808149c8dfc6dbab6eda4b">operator*</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="memitem:a0985bb395cb5351f28a5dc7c634a9963" id="r_a0985bb395cb5351f28a5dc7c634a9963"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0985bb395cb5351f28a5dc7c634a9963">operator*</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="memitem:aedd63e0afe919c6474d0da57593d8d5f" id="r_aedd63e0afe919c6474d0da57593d8d5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedd63e0afe919c6474d0da57593d8d5f">operator/</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f1, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f2)</td></tr>
<tr class="memitem:a6f0bea506f1ba735c18adec70cc049a1" id="r_a6f0bea506f1ba735c18adec70cc049a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f0bea506f1ba735c18adec70cc049a1">operator/</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="memitem:a0b72643a63257ec55447a31a7627b7dd" id="r_a0b72643a63257ec55447a31a7627b7dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b72643a63257ec55447a31a7627b7dd">operator/</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f)</td></tr>
<tr class="memitem:aeffbde3ace1b49b7df5ec9eb9aa8f956" id="r_aeffbde3ace1b49b7df5ec9eb9aa8f956"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeffbde3ace1b49b7df5ec9eb9aa8f956">operator/</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, double c)</td></tr>
<tr class="memitem:a9f7de309c1619f81c94cfa294e5a9065" id="r_a9f7de309c1619f81c94cfa294e5a9065"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f7de309c1619f81c94cfa294e5a9065">operator/</a> (double c, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f)</td></tr>
<tr class="memitem:a2395a6ba4fad53d7c3daa2f792269d99" id="r_a2395a6ba4fad53d7c3daa2f792269d99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2395a6ba4fad53d7c3daa2f792269d99">operator/</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="memitem:a19aa5481bd2bb69b6e4df135231e21f6" id="r_a19aa5481bd2bb69b6e4df135231e21f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19aa5481bd2bb69b6e4df135231e21f6">operator/</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="memitem:ab0bc13bb742ac53358559066848dfa9f" id="r_ab0bc13bb742ac53358559066848dfa9f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0bc13bb742ac53358559066848dfa9f">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f)</td></tr>
<tr class="memdesc:ab0bc13bb742ac53358559066848dfa9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr class="memitem:aefc48865f4a78fceaa3527e94d420bdb" id="r_aefc48865f4a78fceaa3527e94d420bdb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefc48865f4a78fceaa3527e94d420bdb">to_string</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f)</td></tr>
<tr class="memitem:a1689f9845acfae35173fede790537df9" id="r_a1689f9845acfae35173fede790537df9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1689f9845acfae35173fede790537df9">pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f, int n)</td></tr>
<tr class="memdesc:a1689f9845acfae35173fede790537df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rational function <code class="param">f</code> raised to <code class="param">n</code>.  <br /></td></tr>
<tr class="memitem:a36162c4bad2ea2acd8b5ca7bad262ce9" id="r_a36162c4bad2ea2acd8b5ca7bad262ce9"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL, typename MatrixR&gt; </td></tr>
<tr class="memitem:a36162c4bad2ea2acd8b5ca7bad262ce9 template"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36162c4bad2ea2acd8b5ca7bad262ce9">operator*</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:a36162c4bad2ea2acd8b5ca7bad262ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following operations:  <br /></td></tr>
<tr class="memitem:ac6940f8db0a8eb87213dfb7416e13699" id="r_ac6940f8db0a8eb87213dfb7416e13699"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6940f8db0a8eb87213dfb7416e13699">ReplaceBilinearTerms</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &amp;x, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &amp;y, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;W)</td></tr>
<tr class="memdesc:ac6940f8db0a8eb87213dfb7416e13699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all the bilinear product terms in the expression <span class="tt">e</span>, with the corresponding terms in <span class="tt">W</span>, where <span class="tt">W</span> represents the matrix x * yᵀ, such that after replacement, <span class="tt">e</span> does not have bilinear terms involving <span class="tt">x</span> and <span class="tt">y</span>.  <br /></td></tr>
<tr class="memitem:a327c04af4b8fa510bd365a1bb7dfe6ed" id="r_a327c04af4b8fa510bd365a1bb7dfe6ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a134e54042165751a5e5369b4631c90eb">Rewriter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a327c04af4b8fa510bd365a1bb7dfe6ed">MakeRuleRewriter</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html">RewritingRule</a> &amp;r)</td></tr>
<tr class="memdesc:a327c04af4b8fa510bd365a1bb7dfe6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a rewriter based on a rewriting rule <code class="param">r</code>.  <br /></td></tr>
<tr class="memitem:a6c07a8bfb2806c62d5dccd3e5b024786" id="r_a6c07a8bfb2806c62d5dccd3e5b024786"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c07a8bfb2806c62d5dccd3e5b024786">Substitute</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, const <a class="el" href="#a13c5d9eccfc9643fdd5764d6e72b8faf">SinCosSubstitution</a> &amp;subs)</td></tr>
<tr class="memdesc:a6c07a8bfb2806c62d5dccd3e5b024786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a substitution map q =&gt; {s, c}, substitutes instances of sin(q) and cos(q) in <span class="tt">e</span> with <span class="tt">s</span> and <span class="tt">c</span>, with partial support for trigonometric expansions.  <br /></td></tr>
<tr class="memitem:a42493d53cbbe01bee01850904587aff4" id="r_a42493d53cbbe01bee01850904587aff4"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a42493d53cbbe01bee01850904587aff4 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42493d53cbbe01bee01850904587aff4">Substitute</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const <a class="el" href="#a13c5d9eccfc9643fdd5764d6e72b8faf">SinCosSubstitution</a> &amp;subs)</td></tr>
<tr class="memdesc:a42493d53cbbe01bee01850904587aff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix version of sin/cos substitution.  <br /></td></tr>
<tr class="memitem:adda4247e60672d71b861c7b426b50ae4" id="r_adda4247e60672d71b861c7b426b50ae4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">symbolic::RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adda4247e60672d71b861c7b426b50ae4">SubstituteStereographicProjection</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;e, const std::vector&lt; <a class="el" href="structdrake_1_1symbolic_1_1_sin_cos.html">SinCos</a> &gt; &amp;sin_cos, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &amp;t)</td></tr>
<tr class="memdesc:adda4247e60672d71b861c7b426b50ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes the variables representing sine and cosine functions with their stereographic projection.  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="ab1a5d6781b80333555bde1ed59a38477" name="ab1a5d6781b80333555bde1ed59a38477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a5d6781b80333555bde1ed59a38477">&#9670;&#160;</a></span>GenericPolynomialEnable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::enable_if_t&lt;std::is_base_of_v&lt;PolynomialBasisElement, BasisElement&gt;,</div>
<div class="line">                     <a class="code hl_class" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial&lt;BasisElement&gt;</a>&gt;</div>
<div class="ttc" id="aclassdrake_1_1symbolic_1_1_generic_polynomial_html"><div class="ttname"><a href="classdrake_1_1symbolic_1_1_generic_polynomial.html">drake::symbolic::GenericPolynomial</a></div><div class="ttdoc">Represents symbolic generic polynomials using a given basis (for example, monomial basis,...</div><div class="ttdef"><b>Definition</b> generic_polynomial.h:38</div></div>
</div><!-- fragment -->
<p>Defines an explicit SFINAE alias for use with return types to dissuade CTAD from trying to instantiate an invalid GenericElement&lt;&gt; for operator overloads, (if that's actually the case). </p>
<p>See discussion for more info: <a href="https://github.com/robotlocomotion/drake/pull/14053#pullrequestreview-488744679">https://github.com/robotlocomotion/drake/pull/14053#pullrequestreview-488744679</a> </p>

</div>
</div>
<a id="aeb27ddf30420e620beb8e6725d83208f" name="aeb27ddf30420e620beb8e6725d83208f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb27ddf30420e620beb8e6725d83208f">&#9670;&#160;</a></span>Pattern</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aeb27ddf30420e620beb8e6725d83208f">Pattern</a> = <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pattern is an expression which possibly includes variables which represent placeholders. </p>
<p>It is used to construct a <span class="tt"><a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html" title="A RewritingRule, lhs =&gt; rhs, consists of two Patterns lhs and rhs.">RewritingRule</a></span>. </p>

</div>
</div>
<a id="a134e54042165751a5e5369b4631c90eb" name="a134e54042165751a5e5369b4631c90eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134e54042165751a5e5369b4631c90eb">&#9670;&#160;</a></span>Rewriter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a134e54042165751a5e5369b4631c90eb">Rewriter</a> = std::function&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>(const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <span class="tt"><a class="el" href="#a134e54042165751a5e5369b4631c90eb" title="A Rewriter is a function from an Expression to an Expression.">Rewriter</a></span> is a function from an <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">Expression</a> to an <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">Expression</a>. </p>

</div>
</div>
<a id="a13c5d9eccfc9643fdd5764d6e72b8faf" name="a13c5d9eccfc9643fdd5764d6e72b8faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c5d9eccfc9643fdd5764d6e72b8faf">&#9670;&#160;</a></span>SinCosSubstitution</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a13c5d9eccfc9643fdd5764d6e72b8faf">SinCosSubstitution</a> = std::unordered_map&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, <a class="el" href="structdrake_1_1symbolic_1_1_sin_cos.html">SinCos</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbfe43d34e6c71c503d4de11da53bbb7" name="acbfe43d34e6c71c503d4de11da53bbb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbfe43d34e6c71c503d4de11da53bbb7">&#9670;&#160;</a></span>Substitution</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#acbfe43d34e6c71c503d4de11da53bbb7">Substitution</a> = std::unordered_map&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="a245f75ee96839b12e22fea09c6f3ec91" name="a245f75ee96839b12e22fea09c6f3ec91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245f75ee96839b12e22fea09c6f3ec91">&#9670;&#160;</a></span>ExpressionKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91">ExpressionKind</a> : std::uint16_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kinds of symbolic expressions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91acb17869fe51048b5a5c4c6106551a255" name="a245f75ee96839b12e22fea09c6f3ec91acb17869fe51048b5a5c4c6106551a255"></a>Constant&#160;</td><td class="fielddoc"><p>constant (double) </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a5a92344ee95acf10c31901b36418be77" name="a245f75ee96839b12e22fea09c6f3ec91a5a92344ee95acf10c31901b36418be77"></a>Var&#160;</td><td class="fielddoc"><p>variable </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91aec211f7c20af43e742bf2570c3cb84f9" name="a245f75ee96839b12e22fea09c6f3ec91aec211f7c20af43e742bf2570c3cb84f9"></a>Add&#160;</td><td class="fielddoc"><p>addition (+) </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a62b6d55816cf737bfc6f42e60df1a3f2" name="a245f75ee96839b12e22fea09c6f3ec91a62b6d55816cf737bfc6f42e60df1a3f2"></a>Mul&#160;</td><td class="fielddoc"><p>multiplication (*) </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a43d11850893d2fe84a1e618121c1cc0a" name="a245f75ee96839b12e22fea09c6f3ec91a43d11850893d2fe84a1e618121c1cc0a"></a>Div&#160;</td><td class="fielddoc"><p>division (/) </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91ace0be71e33226e4c1db2bcea5959f16b" name="a245f75ee96839b12e22fea09c6f3ec91ace0be71e33226e4c1db2bcea5959f16b"></a>Log&#160;</td><td class="fielddoc"><p>logarithms </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a1e34af023adeb7d5f484f8eb4b9826b6" name="a245f75ee96839b12e22fea09c6f3ec91a1e34af023adeb7d5f484f8eb4b9826b6"></a>Abs&#160;</td><td class="fielddoc"><p>absolute value function </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91acad39a154bffb61175f674d6eefaf6d0" name="a245f75ee96839b12e22fea09c6f3ec91acad39a154bffb61175f674d6eefaf6d0"></a>Exp&#160;</td><td class="fielddoc"><p>exponentiation </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91aae77f3ad25595e35b327334d89410054" name="a245f75ee96839b12e22fea09c6f3ec91aae77f3ad25595e35b327334d89410054"></a>Sqrt&#160;</td><td class="fielddoc"><p>square root </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a8be6d3e955290ee50c00a4bc92aa7749" name="a245f75ee96839b12e22fea09c6f3ec91a8be6d3e955290ee50c00a4bc92aa7749"></a>Pow&#160;</td><td class="fielddoc"><p>power function </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a0986d137604183312e6d3599578bc6cd" name="a245f75ee96839b12e22fea09c6f3ec91a0986d137604183312e6d3599578bc6cd"></a>Sin&#160;</td><td class="fielddoc"><p>sine </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91affca562be079b9e4e41ea9d6a86c582b" name="a245f75ee96839b12e22fea09c6f3ec91affca562be079b9e4e41ea9d6a86c582b"></a>Cos&#160;</td><td class="fielddoc"><p>cosine </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a1266b4e6f81e60733ec6c717e0181f60" name="a245f75ee96839b12e22fea09c6f3ec91a1266b4e6f81e60733ec6c717e0181f60"></a>Tan&#160;</td><td class="fielddoc"><p>tangent </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a76cfc54de4e2b9cde17334c821217d11" name="a245f75ee96839b12e22fea09c6f3ec91a76cfc54de4e2b9cde17334c821217d11"></a>Asin&#160;</td><td class="fielddoc"><p>arcsine </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91aed4629033ecb516ed7d1536e162030bb" name="a245f75ee96839b12e22fea09c6f3ec91aed4629033ecb516ed7d1536e162030bb"></a>Acos&#160;</td><td class="fielddoc"><p>arccosine </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91ac9968ab1fa8103acbb3a4f22265f2def" name="a245f75ee96839b12e22fea09c6f3ec91ac9968ab1fa8103acbb3a4f22265f2def"></a>Atan&#160;</td><td class="fielddoc"><p>arctangent </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a5816dfcaf3b6dbb486ef9c8c006ff613" name="a245f75ee96839b12e22fea09c6f3ec91a5816dfcaf3b6dbb486ef9c8c006ff613"></a>Atan2&#160;</td><td class="fielddoc"><p>arctangent2 (atan2(y,x) = atan(y/x)) </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a98ed804abf4edd1f3be3fa894fa8cc3d" name="a245f75ee96839b12e22fea09c6f3ec91a98ed804abf4edd1f3be3fa894fa8cc3d"></a>Sinh&#160;</td><td class="fielddoc"><p>hyperbolic sine </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a4371c3565b771b40c187487cc0190392" name="a245f75ee96839b12e22fea09c6f3ec91a4371c3565b771b40c187487cc0190392"></a>Cosh&#160;</td><td class="fielddoc"><p>hyperbolic cosine </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91acc132a41cab5676334f353a22a0aa5c5" name="a245f75ee96839b12e22fea09c6f3ec91acc132a41cab5676334f353a22a0aa5c5"></a>Tanh&#160;</td><td class="fielddoc"><p>hyperbolic tangent </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a78d811e98514cd165dda532286610fd2" name="a245f75ee96839b12e22fea09c6f3ec91a78d811e98514cd165dda532286610fd2"></a>Min&#160;</td><td class="fielddoc"><p>min </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a6a061313d22e51e0f25b7cd4dc065233" name="a245f75ee96839b12e22fea09c6f3ec91a6a061313d22e51e0f25b7cd4dc065233"></a>Max&#160;</td><td class="fielddoc"><p>max </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91ab95a01ffffa8fcdd2a9af961937c097c" name="a245f75ee96839b12e22fea09c6f3ec91ab95a01ffffa8fcdd2a9af961937c097c"></a>Ceil&#160;</td><td class="fielddoc"><p>ceil </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91af3f6d0343d56ce88ce7958170ed05cb3" name="a245f75ee96839b12e22fea09c6f3ec91af3f6d0343d56ce88ce7958170ed05cb3"></a>Floor&#160;</td><td class="fielddoc"><p>floor </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91aaff6933d8331eca27edc911467980c9c" name="a245f75ee96839b12e22fea09c6f3ec91aaff6933d8331eca27edc911467980c9c"></a>IfThenElse&#160;</td><td class="fielddoc"><p>if then else </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a7ecfb3bf076a6a9635f975fe96ac97fd" name="a245f75ee96839b12e22fea09c6f3ec91a7ecfb3bf076a6a9635f975fe96ac97fd"></a>NaN&#160;</td><td class="fielddoc"><p>NaN. </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a2e59a51ac43bc3415c1b8ce7b3f98579" name="a245f75ee96839b12e22fea09c6f3ec91a2e59a51ac43bc3415c1b8ce7b3f98579"></a>UninterpretedFunction&#160;</td><td class="fielddoc"><p>Uninterpreted function. </p>
</td></tr>
</table>

</div>
</div>
<a id="a6869e7044dd90be5d972ee7dd4e821b6" name="a6869e7044dd90be5d972ee7dd4e821b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6869e7044dd90be5d972ee7dd4e821b6">&#9670;&#160;</a></span>FormulaKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kinds of symbolic formulas. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6af8320b26d30ab433c5a54546d21f414c" name="a6869e7044dd90be5d972ee7dd4e821b6af8320b26d30ab433c5a54546d21f414c"></a>False&#160;</td><td class="fielddoc"><p>⊥ </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6af827cf462f62848df37c5e1e94a4da74" name="a6869e7044dd90be5d972ee7dd4e821b6af827cf462f62848df37c5e1e94a4da74"></a>True&#160;</td><td class="fielddoc"><p>⊤ </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a5a92344ee95acf10c31901b36418be77" name="a6869e7044dd90be5d972ee7dd4e821b6a5a92344ee95acf10c31901b36418be77"></a>Var&#160;</td><td class="fielddoc"><p>Boolean <a class="el" href="classdrake_1_1symbolic_1_1_variable.html" title="Represents a symbolic variable.">Variable</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a3718b5ecf60aa0dba49e150e96cb1fc3" name="a6869e7044dd90be5d972ee7dd4e821b6a3718b5ecf60aa0dba49e150e96cb1fc3"></a>Eq&#160;</td><td class="fielddoc"><p>= </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6ae4ecc5da3c6dbb4448f25990dc609727" name="a6869e7044dd90be5d972ee7dd4e821b6ae4ecc5da3c6dbb4448f25990dc609727"></a>Neq&#160;</td><td class="fielddoc"><p>!= </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a086cb8308e5a36e7c4ed1f8873ad801f" name="a6869e7044dd90be5d972ee7dd4e821b6a086cb8308e5a36e7c4ed1f8873ad801f"></a>Gt&#160;</td><td class="fielddoc"><blockquote class="doxtable">
<p></p>
</blockquote>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a5dabfebb89e6e45a8cf8573d92746ed3" name="a6869e7044dd90be5d972ee7dd4e821b6a5dabfebb89e6e45a8cf8573d92746ed3"></a>Geq&#160;</td><td class="fielddoc"><p>&gt;= </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a50033c15af7795cd6617f117b29d6922" name="a6869e7044dd90be5d972ee7dd4e821b6a50033c15af7795cd6617f117b29d6922"></a>Lt&#160;</td><td class="fielddoc"><p>&lt; </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6abe5721bf93d718a79358217ec9b88176" name="a6869e7044dd90be5d972ee7dd4e821b6abe5721bf93d718a79358217ec9b88176"></a>Leq&#160;</td><td class="fielddoc"><p>&lt;= </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6ac33315685a0cba3ce53be378b3c7874b" name="a6869e7044dd90be5d972ee7dd4e821b6ac33315685a0cba3ce53be378b3c7874b"></a>And&#160;</td><td class="fielddoc"><p>Conjunction (∧). </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a3a2d5fe857d8f9541136a124c2edec6c" name="a6869e7044dd90be5d972ee7dd4e821b6a3a2d5fe857d8f9541136a124c2edec6c"></a>Or&#160;</td><td class="fielddoc"><p>Disjunction (∨). </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6aa74c05d080620f087c4e523977230666" name="a6869e7044dd90be5d972ee7dd4e821b6aa74c05d080620f087c4e523977230666"></a>Not&#160;</td><td class="fielddoc"><p>Negation (¬). </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a43cfe3c750a08acb91df1e3384548078" name="a6869e7044dd90be5d972ee7dd4e821b6a43cfe3c750a08acb91df1e3384548078"></a>Forall&#160;</td><td class="fielddoc"><p>Universal quantification (∀). </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6afd116e3418522ffc34d7423bc601510d" name="a6869e7044dd90be5d972ee7dd4e821b6afd116e3418522ffc34d7423bc601510d"></a>Isnan&#160;</td><td class="fielddoc"><p>NaN check predicate. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a1fbc164d3e50b7fd20690a21f1b7b2f2" name="a6869e7044dd90be5d972ee7dd4e821b6a1fbc164d3e50b7fd20690a21f1b7b2f2"></a>PositiveSemidefinite&#160;</td><td class="fielddoc"><p>Positive semidefinite matrix. </p>
</td></tr>
</table>

</div>
</div>
<a id="a0f7729e9ae50c2b5ca1d86021ad1ae44" name="a0f7729e9ae50c2b5ca1d86021ad1ae44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7729e9ae50c2b5ca1d86021ad1ae44">&#9670;&#160;</a></span>SinCosSubstitutionType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a0f7729e9ae50c2b5ca1d86021ad1ae44">SinCosSubstitutionType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0f7729e9ae50c2b5ca1d86021ad1ae44af4d2017f452ed392e963b2d8ddf591bb" name="a0f7729e9ae50c2b5ca1d86021ad1ae44af4d2017f452ed392e963b2d8ddf591bb"></a>kAngle&#160;</td><td class="fielddoc"><p>Substitutes s &lt;=&gt; sin(q), c &lt;=&gt; cos(q). </p>
</td></tr>
<tr><td class="fieldname"><a id="a0f7729e9ae50c2b5ca1d86021ad1ae44aea1eea0840dd2bfd79a5cbfdf49ea143" name="a0f7729e9ae50c2b5ca1d86021ad1ae44aea1eea0840dd2bfd79a5cbfdf49ea143"></a>kHalfAnglePreferSin&#160;</td><td class="fielddoc"><p>Substitutes s &lt;=&gt; sin(q/2), c &lt;=&gt; cos(q/2), and prefers sin when the choice is ambiguous; e.g. </p>
<p>cos(q) =&gt; 1 - 2s². </p>
</td></tr>
<tr><td class="fieldname"><a id="a0f7729e9ae50c2b5ca1d86021ad1ae44acdf5f9e766a4e04d5ac3bf38e82da0f0" name="a0f7729e9ae50c2b5ca1d86021ad1ae44acdf5f9e766a4e04d5ac3bf38e82da0f0"></a>kHalfAnglePreferCos&#160;</td><td class="fielddoc"><p>Substitutes s &lt;=&gt; sin(q/2), c &lt;=&gt; cos(q/2), and prefers cos when the choice is ambiguous; e.g. </p>
<p>cos(q) =&gt; 2c² - 1. </p>
</td></tr>
</table>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a44e11b5fa4c16951b30b26e43a316569" name="a44e11b5fa4c16951b30b26e43a316569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e11b5fa4c16951b30b26e43a316569">&#9670;&#160;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a008a73e1d2390dc2325d70175fb5410e" name="a008a73e1d2390dc2325d70175fb5410e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008a73e1d2390dc2325d70175fb5410e">&#9670;&#160;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66f66b1d5e15bec4b2b7f12ade1b3094" name="a66f66b1d5e15bec4b2b7f12ade1b3094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f66b1d5e15bec4b2b7f12ade1b3094">&#9670;&#160;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf24c6f256d7360650cb379c22886409" name="acf24c6f256d7360650cb379c22886409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf24c6f256d7360650cb379c22886409">&#9670;&#160;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ddcc51253066082911475e06b0ac994" name="a9ddcc51253066082911475e06b0ac994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ddcc51253066082911475e06b0ac994">&#9670;&#160;</a></span>atan2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> atan2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab45e72ece70fdb6eba8afcfc7b773c76" name="ab45e72ece70fdb6eba8afcfc7b773c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45e72ece70fdb6eba8afcfc7b773c76">&#9670;&#160;</a></span>CalcMonomialBasisOrderUpToOne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &gt; CalcMonomialBasisOrderUpToOne </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>sort_monomial</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates all the monomials of <span class="tt">x</span>, such that the degree for x(i) is no larger than 1 for every x(i) in <span class="tt">x</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The variables whose monomials are generated. </td></tr>
    <tr><td class="paramname">sort_monomial</td><td>If true, the returned monomials are sorted in the graded reverse lexicographic order. For example if x = (x₀, x₁) with x₀&lt; x₁, then this function returns [x₀x₁, x₁, x₀, 1]. If sort_monomial=false, then we return the monomials in an arbitrary order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a564c13b0f2dfdd43264f378f5d5ee1" name="a9a564c13b0f2dfdd43264f378f5d5ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a564c13b0f2dfdd43264f378f5d5ee1">&#9670;&#160;</a></span>CalcPolynomialWLowerTriangularPart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived1, typename Derived2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt; Derived1, <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;::value &amp;&amp;(<a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt; Derived2, double &gt;::value||<a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt; Derived2, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;::value||<a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt; Derived2, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;::value), <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &gt;::type CalcPolynomialWLowerTriangularPart </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>monomial_basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gram_lower</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the polynomial m(x)ᵀ * Q * m(x), where m(x) is the monomial basis, and Q is the Gram matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">monomial_basis</td><td>m(x) in the documentation. A vector of monomials. </td></tr>
    <tr><td class="paramname">gram_lower</td><td>The lower triangular entries in Q, stacked columnwise into a vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e5ea5116992b4f695c16ad0f297686b" name="a2e5ea5116992b4f695c16ad0f297686b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5ea5116992b4f695c16ad0f297686b">&#9670;&#160;</a></span>ceil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1616e76093d11cfcac6a6f14d399cc9a" name="a1616e76093d11cfcac6a6f14d399cc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1616e76093d11cfcac6a6f14d399cc9a">&#9670;&#160;</a></span>CheckStructuralEquality() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; DerivedA &gt;, DerivedA &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; DerivedB &gt;, DerivedB &gt; &amp;&amp;std::is_same_v&lt; typename DerivedA::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&amp;std::is_same_v&lt; typename DerivedB::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, bool &gt; CheckStructuralEquality </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if two Eigen::Matrix&lt;Expression&gt; <code class="param">m1</code> and <code class="param">m2</code> are structurally equal. </p>
<p>That is, it returns true if and only if <span class="tt">m1(i, j)</span> is structurally equal to <span class="tt">m2(i, j)</span> for all <span class="tt">i</span>, <span class="tt">j</span>. </p>

</div>
</div>
<a id="a83d142d09707408089d64c4a15c57ab7" name="a83d142d09707408089d64c4a15c57ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d142d09707408089d64c4a15c57ab7">&#9670;&#160;</a></span>CheckStructuralEquality() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt; DerivedA, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;::value &amp;&amp;<a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt; DerivedB, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;::value, bool &gt; CheckStructuralEquality </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if two Eigen::Matrix&lt;Variable&gt; <code class="param">m1</code> and <code class="param">m2</code> are structurally equal. </p>
<p>That is, it returns true if and only if <span class="tt">m1(i, j)</span> is structurally equal to <span class="tt">m2(i, j)</span> for all <span class="tt">i</span>, <span class="tt">j</span>. </p>

</div>
</div>
<a id="ad62c6b17ca0d4f9bbbefe1aff58d46ca" name="ad62c6b17ca0d4f9bbbefe1aff58d46ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62c6b17ca0d4f9bbbefe1aff58d46ca">&#9670;&#160;</a></span>clamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> clamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>hi</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f254dc74f6fa876d91ecaeed7e9683f" name="a2f254dc74f6fa876d91ecaeed7e9683f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f254dc74f6fa876d91ecaeed7e9683f">&#9670;&#160;</a></span>ComputePolynomialBasisUpToDegree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rows, typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; BasisElement, rows, 1 &gt; ComputePolynomialBasisUpToDegree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>degree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::DegreeType</td>          <td class="paramname"><span class="paramname"><em>degree_type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all polynomial basis elements up to a given degree under the graded reverse lexicographic order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>Number of rows or Eigen::Dynamic. </td></tr>
    <tr><td class="paramname">BasisElement</td><td>A derived class of <a class="el" href="classdrake_1_1symbolic_1_1_polynomial_basis_element.html" title="Each polynomial p(x) can be written as a linear combination of its basis elements p(x) = ∑ᵢ cᵢ * ϕᵢ(x...">PolynomialBasisElement</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vars</td><td>The variables appearing in the polynomial basis. </td></tr>
    <tr><td class="paramname">degree</td><td>The highest total degree of the polynomial basis elements. </td></tr>
    <tr><td class="paramname">degree_type</td><td>If degree_type is kAny, then the polynomial basis elements' degrees are no larger than <code class="param">degree</code>. If degree_type is kEven, then the elements' degrees are even numbers no larger than <code class="param">degree</code>. If degree_type is kOdd, then the elements' degrees are odd numbers no larger than <code class="param">degree</code>. TODO(hongkai.dai): this will replace ComputeMonomialBasis in <a class="el" href="monomial__util_8h.html">monomial_util.h</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d78919127ccba2ba24cdb1b0c57613d" name="a8d78919127ccba2ba24cdb1b0c57613d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d78919127ccba2ba24cdb1b0c57613d">&#9670;&#160;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27a345a84e6b273a71aa02ee312f9c51" name="a27a345a84e6b273a71aa02ee312f9c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a345a84e6b273a71aa02ee312f9c51">&#9670;&#160;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5465afe4a1b0379e8a3f99e507ebfcf7" name="a5465afe4a1b0379e8a3f99e507ebfcf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5465afe4a1b0379e8a3f99e507ebfcf7">&#9670;&#160;</a></span>DecomposeAffineExpression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DecomposeAffineExpression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>map_var_to_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::RowVectorXd &gt;</td>          <td class="paramname"><span class="paramname"><em>coeffs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>constant_term</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decomposes an affine combination <code class="param">e</code> = c0 + c1 * v1 + ... cn * vn into the following: </p>
<pre class="fragment"> constant term      : c0
 coefficient vector : [c1, ..., cn]
 variable vector    : [v1, ..., vn]
</pre><p>Then, it extracts the coefficient and the constant term. A map from variable ID to int, <code class="param">map_var_to_index</code>, is used to decide a variable's index in a linear combination.</p>
<dl class="section pre"><dt>Precondition</dt><dd><ol type="1">
<li><code>coeffs</code> is a row vector of double, whose length matches with the size of <code>map_var_to_index</code>.</li>
<li>e.is_polynomial() is true.</li>
<li>e is an affine expression.</li>
<li>all values in <span class="tt">map_var_to_index</span> should be in the range [0, map_var_to_index.size())</li>
</ol>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>The symbolic affine expression </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_var_to_index</td><td>A mapping from variable ID to variable index, such that map_var_to_index[vi.get_ID()] = i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coeffs</td><td>A row vector. coeffs(i) = ci. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">constant_term</td><td>c0 in the equation above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>num_variable. Number of variables in the expression. 2 * x(0) + 3 has 1 variable; 2 * x(0) + 3 * x(1) - 2 * x(0) has 1 variable, since the x(0) term cancels.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the input expression is not affine. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bb461d089db5bc37c4510108a616833" name="a8bb461d089db5bc37c4510108a616833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb461d089db5bc37c4510108a616833">&#9670;&#160;</a></span>DecomposeAffineExpressions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DecomposeAffineExpressions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>expressions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::MatrixXd &gt;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::VectorXd &gt;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decomposes <code class="param">expressions</code> into <code class="param">M</code> * <code class="param">vars</code> + <code class="param">v</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code class="param">expressions</code> is not affine in <code class="param">vars</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>M.rows() == expressions.rows() &amp;&amp; M.cols() == vars.rows(). </dd>
<dd>
v.rows() == expressions.rows(). </dd></dl>

</div>
</div>
<a id="a91f81efc5e997042f4e6f0005a05fc5d" name="a91f81efc5e997042f4e6f0005a05fc5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f81efc5e997042f4e6f0005a05fc5d">&#9670;&#160;</a></span>DecomposeAffineExpressions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DecomposeAffineExpressions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd *</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector of affine expressions v, decompose it to  \( v = A vars + b
\). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>A vector of affine expressions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>The matrix containing the linear coefficients. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>The vector containing all the constant terms. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vars</td><td>All variables.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the input expressions are not affine. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70b04dbbe04340ba67a5af39b6c0f277" name="a70b04dbbe04340ba67a5af39b6c0f277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b04dbbe04340ba67a5af39b6c0f277">&#9670;&#160;</a></span>DecomposeL2NormExpression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; bool, Eigen::MatrixXd, Eigen::VectorXd, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &gt; DecomposeL2NormExpression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>psd_tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-8</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>coefficient_tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-8</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decomposes an L2 norm <code class="param">e</code> = |Ax+b|₂ into A, b, and the variable vector x (or returns false if the decomposition is not possible). </p>
<p>In order for the decomposition to succeed, the following conditions must be met:</p><ol type="1">
<li>e is a sqrt expression.</li>
<li>e.get_argument() is a polynomial of degree 2, which can be expressed as a quadratic form (Ax+b)ᵀ(Ax+b).</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The symbolic affine expression </td></tr>
    <tr><td class="paramname">psd_tol</td><td>The tolerance for checking positive semidefiniteness. Eigenvalues less that this threshold are considered to be zero. Matrices with negative eigenvalues less than this threshold are considered to be not positive semidefinite, and will cause the decomposition to fail. </td></tr>
    <tr><td class="paramname">coefficient_tol</td><td>The absolute tolerance for checking that the coefficients of the expression inside the sqrt match the coefficients of |Ax+b|₂².</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>[is_l2norm, A, b, vars] where is_l2norm is true iff the decomposition was successful, and if is_l2norm is true then |A*vars + b|₂ = e. </dd></dl>

</div>
</div>
<a id="a3d65bb35caa2548754aca87d76c33e55" name="a3d65bb35caa2548754aca87d76c33e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d65bb35caa2548754aca87d76c33e55">&#9670;&#160;</a></span>DecomposeLinearExpressions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DecomposeLinearExpressions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>expressions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::MatrixXd &gt;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decomposes <code class="param">expressions</code> into <code class="param">M</code> * <code class="param">vars</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code class="param">expressions</code> is not linear in <code class="param">vars</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>M.rows() == expressions.rows() &amp;&amp; M.cols() == vars.rows(). </dd></dl>

</div>
</div>
<a id="a2b5d1822f59197807ea089c71ae6e2b8" name="a2b5d1822f59197807ea089c71ae6e2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5d1822f59197807ea089c71ae6e2b8">&#9670;&#160;</a></span>DecomposeLumpedParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; DecomposeLumpedParameters </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>parameters</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector of Expressions <code class="param">f</code> and a list of <code class="param">parameters</code> we define all additional variables in <code class="param">f</code> to be a vector of "non-parameter variables", n. </p>
<p>This method returns a factorization of <code class="param">f</code> into an equivalent "data
matrix", W, which depends only on the non-parameter variables, and a "lumped
parameter vector", α, which depends only on <code class="param">parameters:</code> f = W(n)*α(parameters) + w0(n).</p>
<dl class="section note"><dt>Note</dt><dd>The current implementation makes some simple attempts to minimize the number of lumped parameters, but more simplification could be implemented relatively easily. Optimal simplification, however, involves the complexity of comparing two arbitrary Expressions (see <a class="el" href="classdrake_1_1symbolic_1_1_expression.html#abb771e5bf5c37eb4753daf77f77adab0" title="Checks structural equality.">Expression::EqualTo</a> for more details).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code class="param">f</code> is not decomposable in this way (cells containing <code class="param">parameters</code> may only be added or multiplied with cells containing non-parameter variables).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>W(n), α(parameters), and w0(n). </dd></dl>

</div>
</div>
<a id="a9b2d3a1021e4b76e2644196df9f7a6b9" name="a9b2d3a1021e4b76e2644196df9f7a6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b2d3a1021e4b76e2644196df9f7a6b9">&#9670;&#160;</a></span>DecomposeQuadraticPolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DecomposeQuadraticPolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>poly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>map_var_to_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd *</td>          <td class="paramname"><span class="paramname"><em>Q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a quadratic polynomial <code class="param">poly</code>, decomposes it into the form 0.5 * x' Q * x + b' * x + c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poly</td><td>Quadratic polynomial to decompose. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_var_to_index</td><td>maps variables in <span class="tt">poly.GetVariables()</span> to the index in the vector <span class="tt">x</span>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>The Hessian of the quadratic expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The size of Q should be <span class="tt">num_variables x num_variables</span>. Q is a symmetric matrix. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>linear term of the quadratic expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The size of <span class="tt">b</span> should be <span class="tt">num_variables</span>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>The constant term of the quadratic expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0307b6ce5db3cdd869f02b790c89d0b" name="ac0307b6ce5db3cdd869f02b790c89d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0307b6ce5db3cdd869f02b790c89d0b">&#9670;&#160;</a></span>Evaluate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &gt;, <a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; double, Derived &gt; &gt; Evaluate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates a matrix <span class="tt">m</span> of symbolic polynomials using <span class="tt">env</span>. </p>
<dl class="section return"><dt>Returns</dt><dd>a matrix of double whose size is the size of <span class="tt">m</span>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if NaN is detected during evaluation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58c00a140ffd74ecb1b06db9ad425e29" name="a58c00a140ffd74ecb1b06db9ad425e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c00a140ffd74ecb1b06db9ad425e29">&#9670;&#160;</a></span>Evaluate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, <a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; double, Derived &gt; &gt; Evaluate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a>{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *</td>          <td class="paramname"><span class="paramname"><em>random_generator</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a symbolic matrix <code class="param">m</code> using <code class="param">env</code> and <code class="param">random_generator</code>. </p>
<p>If there is a random variable in <code class="param">m</code> which is unassigned in <code class="param">env</code>, this function uses <code class="param">random_generator</code> to sample a value and use the value to substitute all occurrences of the random variable in <code class="param">m</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>a matrix of double whose size is the size of <code class="param">m</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if NaN is detected during evaluation. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <code class="param">m</code> includes unassigned random variables but <code class="param">random_generator</code> is <span class="tt">nullptr</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09b9bc7afd420d9f8f438caf34e503b9" name="a09b9bc7afd420d9f8f438caf34e503b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b9bc7afd420d9f8f438caf34e503b9">&#9670;&#160;</a></span>Evaluate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::SparseMatrix&lt; double &gt; Evaluate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::SparseMatrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>env</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a>{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates <code class="param">m</code> using a given environment (by default, an empty environment). </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there exists a variable in <code class="param">m</code> whose value is not provided by <code class="param">env</code>. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if NaN is detected during evaluation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aced5d6021e6da5973d88a559b59b9c59" name="aced5d6021e6da5973d88a559b59b9c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced5d6021e6da5973d88a559b59b9c59">&#9670;&#160;</a></span>EvaluateChebyshevPolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double EvaluateChebyshevPolynomial </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>var_val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>degree</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a Chebyshev polynomial at a given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var_val</td><td>The value of the variable. </td></tr>
    <tr><td class="paramname">degree</td><td>The degree of the Chebyshev polynomial. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88ddd8d42b90d109f5d7312db729a959" name="a88ddd8d42b90d109f5d7312db729a959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ddd8d42b90d109f5d7312db729a959">&#9670;&#160;</a></span>EvenDegreeMonomialBasis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, Eigen::Dynamic, 1 &gt; EvenDegreeMonomialBasis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>degree</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all even degree monomials up to a given degree under the graded reverse lexicographic order. </p>
<p>A monomial has an even degree if its total degree is even. So xy is an even degree monomial (degree 2) while x²y is not (degree 3). Note that graded reverse lexicographic order uses the total order among <a class="el" href="classdrake_1_1symbolic_1_1_variable.html" title="Represents a symbolic variable.">Variable</a> which is based on a variable's unique ID. For example, for a given variable ordering x &gt; y &gt; z, <span class="tt"><a class="el" href="#a88ddd8d42b90d109f5d7312db729a959" title="Returns all even degree monomials up to a given degree under the graded reverse lexicographic order.">EvenDegreeMonomialBasis</a>({x, y, z}, 2)</span> returns a column vector <span class="tt">[x², xy, y², xz, yz, z², 1]</span>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code class="param">vars</code> is a non-empty set. </dd>
<dd>
<code class="param">degree</code> is a non-negative integer. </dd></dl>

</div>
</div>
<a id="a27e661d9a5f1936f326068b2dea3eecc" name="a27e661d9a5f1936f326068b2dea3eecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e661d9a5f1936f326068b2dea3eecc">&#9670;&#160;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a474ad60951290be07b6bb8e737d0a5ec" name="a474ad60951290be07b6bb8e737d0a5ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474ad60951290be07b6bb8e737d0a5ec">&#9670;&#160;</a></span>ExtractAndAppendVariablesFromExpression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ExtractAndAppendVariablesFromExpression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, int &gt; *</td>          <td class="paramname"><span class="paramname"><em>map_var_to_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an expression <span class="tt">e</span>, extracts all variables inside <span class="tt">e</span>, appends these variables to <span class="tt">vars</span> if they are not included in <span class="tt">vars</span> yet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>A symbolic expression. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vars</td><td>As an input, <span class="tt">vars</span> contain the variables before extracting expression <span class="tt">e</span>. As an output, the variables in <span class="tt">e</span> that were not included in <span class="tt">vars</span>, will be appended to the end of <span class="tt">vars</span>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">map_var_to_index</td><td>is of the same size as <span class="tt">vars</span>, and map_var_to_index[vars(i).get_id()] = i. This invariance holds for map_var_to_index both as the input and as the output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98eba0d5094e9e15c3038815b16159e6" name="a98eba0d5094e9e15c3038815b16159e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98eba0d5094e9e15c3038815b16159e6">&#9670;&#160;</a></span>ExtractVariablesFromExpression() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;, std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">Variable::Id</a>, int &gt; &gt; ExtractVariablesFromExpression </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>expressions</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads ExtractVariablesFromExpression but with a vector of expressions. </p>

</div>
</div>
<a id="a50d8d95273e14b9a63bc8d592c382861" name="a50d8d95273e14b9a63bc8d592c382861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d8d95273e14b9a63bc8d592c382861">&#9670;&#160;</a></span>ExtractVariablesFromExpression() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;, std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, int &gt; &gt; ExtractVariablesFromExpression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an expression <span class="tt">e</span>, extracts all variables inside <span class="tt">e</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>A symbolic expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">pair</td><td>pair.first is the variables in <span class="tt">e</span>. pair.second is the mapping from the variable ID to the index in pair.first, such that pair.second[pair.first(i).get_id()] = i </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08cadfe5adda620a40258a84d87081f4" name="a08cadfe5adda620a40258a84d87081f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08cadfe5adda620a40258a84d87081f4">&#9670;&#160;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d13fc861c980e5cca95449bb11cbe01" name="a7d13fc861c980e5cca95449bb11cbe01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d13fc861c980e5cca95449bb11cbe01">&#9670;&#160;</a></span>forall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> forall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a formula <code class="param">f</code>, universally quantified by variables <code class="param">vars</code>. </p>

</div>
</div>
<a id="a3445a75a8296154f264bf7177f9e85ab" name="a3445a75a8296154f264bf7177f9e85ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3445a75a8296154f264bf7177f9e85ab">&#9670;&#160;</a></span>get_argument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp; get_argument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the argument in the unary expression <code class="param">e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code class="param">e</code> is a unary expression.} </dd></dl>

</div>
</div>
<a id="a9abf9c0b485045bd9a88c6bda2706e3d" name="a9abf9c0b485045bd9a88c6bda2706e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abf9c0b485045bd9a88c6bda2706e3d">&#9670;&#160;</a></span>get_base_to_exponent_map_in_multiplication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp; get_base_to_exponent_map_in_multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the map from a base expression to its exponent expression in the multiplication expression <code class="param">e</code>. </p>
<p>For instance, given 7 * x^2 * y^3 * z^x, the return value maps 'x' to 2, 'y' to 3, and 'z' to 'x'. </p><dl class="section pre"><dt>Precondition</dt><dd>{<code class="param">e</code> is a multiplication expression.} </dd></dl>

</div>
</div>
<a id="a90e045ae61515d2b1a9206abc2ca5412" name="a90e045ae61515d2b1a9206abc2ca5412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e045ae61515d2b1a9206abc2ca5412">&#9670;&#160;</a></span>get_conditional_formula()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp; get_conditional_formula </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the conditional formula in the if-then-else expression <code class="param">e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code class="param">e</code> is an if-then-else expression. </dd></dl>

</div>
</div>
<a id="a657fe44ab4b095f9603a3c9429098981" name="a657fe44ab4b095f9603a3c9429098981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657fe44ab4b095f9603a3c9429098981">&#9670;&#160;</a></span>get_constant_in_addition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_constant_in_addition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the constant part of the addition expression <code class="param">e</code>. </p>
<p>For instance, given 7 + 2 * x + 3 * y, it returns 7. </p><dl class="section pre"><dt>Precondition</dt><dd>{<code class="param">e</code> is an addition expression.} </dd></dl>

</div>
</div>
<a id="ae1f447c509e16ebf85df16216af97882" name="ae1f447c509e16ebf85df16216af97882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f447c509e16ebf85df16216af97882">&#9670;&#160;</a></span>get_constant_in_multiplication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_constant_in_multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the constant part of the multiplication expression <code class="param">e</code>. </p>
<p>For instance, given 7 * x^2 * y^3, it returns 7. </p><dl class="section pre"><dt>Precondition</dt><dd>{<code class="param">e</code> is a multiplication expression.} </dd></dl>

</div>
</div>
<a id="a5165b4cdadcd273d3faad9dffd2bcc7e" name="a5165b4cdadcd273d3faad9dffd2bcc7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5165b4cdadcd273d3faad9dffd2bcc7e">&#9670;&#160;</a></span>get_constant_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_constant_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the constant value of the constant expression <code class="param">e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code class="param">e</code> is a constant expression.} </dd></dl>

</div>
</div>
<a id="a93333785c7a6b3a8cf3b517eadaf982a" name="a93333785c7a6b3a8cf3b517eadaf982a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93333785c7a6b3a8cf3b517eadaf982a">&#9670;&#160;</a></span>get_else_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp; get_else_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 'else' expression in the if-then-else expression <code class="param">e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code class="param">e</code> is an if-then-else expression. </dd></dl>

</div>
</div>
<a id="a0c96dfd079cf8490a85e9f087f6aab2d" name="a0c96dfd079cf8490a85e9f087f6aab2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c96dfd079cf8490a85e9f087f6aab2d">&#9670;&#160;</a></span>get_expr_to_coeff_map_in_addition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, double &gt; &amp; get_expr_to_coeff_map_in_addition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the map from an expression to its coefficient in the addition expression <code class="param">e</code>. </p>
<p>For instance, given 7 + 2 * x + 3 * y, the return value maps 'x' to 2 and 'y' to 3. </p><dl class="section pre"><dt>Precondition</dt><dd>{<code class="param">e</code> is an addition expression.} </dd></dl>

</div>
</div>
<a id="a447067b42b3ed05358bbbbf227e4d1d8" name="a447067b42b3ed05358bbbbf227e4d1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447067b42b3ed05358bbbbf227e4d1d8">&#9670;&#160;</a></span>get_first_argument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp; get_first_argument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first argument of the binary expression <code class="param">e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code class="param">e</code> is a binary expression.} </dd></dl>

</div>
</div>
<a id="a77f3d349554a28bfa3f1107bb4adaab6" name="a77f3d349554a28bfa3f1107bb4adaab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f3d349554a28bfa3f1107bb4adaab6">&#9670;&#160;</a></span>get_lhs_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp; get_lhs_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the lhs-argument of a relational formula <code class="param">f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code class="param">f</code> is a relational formula.} </dd></dl>

</div>
</div>
<a id="ab77026017746534a08312bf9eb2d4a99" name="ab77026017746534a08312bf9eb2d4a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77026017746534a08312bf9eb2d4a99">&#9670;&#160;</a></span>get_matrix_in_positive_semidefinite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp; get_matrix_in_positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the matrix in a positive-semidefinite formula <code class="param">f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code class="param">f</code> is a positive-semidefinite formula.} </dd></dl>

</div>
</div>
<a id="a4d6409b69e4049b282edaaea65fe1b43" name="a4d6409b69e4049b282edaaea65fe1b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6409b69e4049b282edaaea65fe1b43">&#9670;&#160;</a></span>get_operand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp; get_operand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the formula in a negation formula <code class="param">f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code class="param">f</code> is a negation formula.} </dd></dl>

</div>
</div>
<a id="a5a51076f5f4ab9497965268ceb34e82c" name="a5a51076f5f4ab9497965268ceb34e82c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a51076f5f4ab9497965268ceb34e82c">&#9670;&#160;</a></span>get_operands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp; get_operands </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of formulas in a n-ary formula <code class="param">f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code class="param">f</code> is a n-ary formula.} </dd></dl>

</div>
</div>
<a id="a6d5aa689465b2522a75c7dc12fcf1b60" name="a6d5aa689465b2522a75c7dc12fcf1b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d5aa689465b2522a75c7dc12fcf1b60">&#9670;&#160;</a></span>get_quantified_formula()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp; get_quantified_formula </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the quantified formula in a forall formula <code class="param">f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code class="param">f</code> is a forall formula.} </dd></dl>

</div>
</div>
<a id="a637fea2c6cfc60b582df81b7b1187e94" name="a637fea2c6cfc60b582df81b7b1187e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637fea2c6cfc60b582df81b7b1187e94">&#9670;&#160;</a></span>get_quantified_variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp; get_quantified_variables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the quantified variables in a forall formula <code class="param">f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code class="param">f</code> is a forall formula.} </dd></dl>

</div>
</div>
<a id="af855c0227ec69f59da11988c82ae4ce2" name="af855c0227ec69f59da11988c82ae4ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af855c0227ec69f59da11988c82ae4ce2">&#9670;&#160;</a></span>get_rhs_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp; get_rhs_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the rhs-argument of a relational formula <code class="param">f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code class="param">f</code> is a relational formula.} </dd></dl>

</div>
</div>
<a id="a4e891509f0e836fd647f1ea1d8e9f86b" name="a4e891509f0e836fd647f1ea1d8e9f86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e891509f0e836fd647f1ea1d8e9f86b">&#9670;&#160;</a></span>get_second_argument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp; get_second_argument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the second argument of the binary expression <code class="param">e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code class="param">e</code> is a binary expression.} </dd></dl>

</div>
</div>
<a id="a4fc636cd4593a513941cc0431eb086e2" name="a4fc636cd4593a513941cc0431eb086e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc636cd4593a513941cc0431eb086e2">&#9670;&#160;</a></span>get_then_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp; get_then_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 'then' expression in the if-then-else expression <code class="param">e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code class="param">e</code> is an if-then-else expression. </dd></dl>

</div>
</div>
<a id="a4ce6eacfc51cea8af6b9c1e0e963807a" name="a4ce6eacfc51cea8af6b9c1e0e963807a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce6eacfc51cea8af6b9c1e0e963807a">&#9670;&#160;</a></span>get_unary_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp; get_unary_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the expression in a unary expression formula <code class="param">f</code>. </p>
<p>Currently, an <a class="el" href="#aee7da5a29fea63347ec7c9fddce7f022" title="Returns a Formula for the predicate isnan(e) to the given expression.">isnan()</a> formula is the only kind of unary expression formula. </p><dl class="section pre"><dt>Precondition</dt><dd>{<code class="param">f</code> is a unary expression formula.} </dd></dl>

</div>
</div>
<a id="a8d4249d71cfbc5fe0260cd14fdc4bcf0" name="a8d4249d71cfbc5fe0260cd14fdc4bcf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4249d71cfbc5fe0260cd14fdc4bcf0">&#9670;&#160;</a></span>get_uninterpreted_function_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp; get_uninterpreted_function_arguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the arguments of an uninterpreted-function expression <code class="param">e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code class="param">e</code> is an uninterpreted-function expression. </dd></dl>

</div>
</div>
<a id="a0a54f523f3f3f991c16bea9f3466e2d5" name="a0a54f523f3f3f991c16bea9f3466e2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a54f523f3f3f991c16bea9f3466e2d5">&#9670;&#160;</a></span>get_uninterpreted_function_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; get_uninterpreted_function_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of an uninterpreted-function expression <code class="param">e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code class="param">e</code> is an uninterpreted-function expression. </dd></dl>

</div>
</div>
<a id="af3d53e917f4fd1da3301aa00ee90bb8b" name="af3d53e917f4fd1da3301aa00ee90bb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d53e917f4fd1da3301aa00ee90bb8b">&#9670;&#160;</a></span>get_variable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp; get_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the embedded variable in the variable expression <code class="param">e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code class="param">e</code> is a variable expression.} </dd></dl>

</div>
</div>
<a id="a85376535fc0a875d116702f9186d8f99" name="a85376535fc0a875d116702f9186d8f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85376535fc0a875d116702f9186d8f99">&#9670;&#160;</a></span>get_variable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp; get_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the embedded variable in the variable formula <code class="param">f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code class="param">f</code> is a variable formula. </dd></dl>

</div>
</div>
<a id="a3893c42663dcc49584d831c5ab23fef5" name="a3893c42663dcc49584d831c5ab23fef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3893c42663dcc49584d831c5ab23fef5">&#9670;&#160;</a></span>GetDistinctVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> GetDistinctVariables </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the distinct variables in the matrix of expressions. </p>

</div>
</div>
<a id="adf71bc1325f5e381cd96a9fc952f3485" name="adf71bc1325f5e381cd96a9fc952f3485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf71bc1325f5e381cd96a9fc952f3485">&#9670;&#160;</a></span>GetVariableVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; GetVariableVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>expressions</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a vector of variables from the vector of variable expressions. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there is an expression in <code class="param">vec</code> which is not a variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb59d484cb2b6737923c9b53e0ec432c" name="adb59d484cb2b6737923c9b53e0ec432c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb59d484cb2b6737923c9b53e0ec432c">&#9670;&#160;</a></span>if_then_else()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> if_then_else </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f_cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e_then</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e_else</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">  if_then_else(cond, expr_then, expr_else)
</pre><p>The value returned by the above if-then-else expression is <code class="param">expr_then</code> if <code class="param">cond</code> is evaluated to true. Otherwise, it returns <code class="param">expr_else</code>.</p>
<p>The semantics is similar to the C++'s conditional expression constructed by its ternary operator, <code></code>?:. However, there is a key difference between the C++'s conditional expression and our <code>if_then_else</code> expression in a way the arguments are evaluated during the construction.</p>
<ul>
<li>In case of the C++'s conditional expression, <span class="tt"> <a class="el" href="namespacedrake.html#a032afe843cdaa8b1e28e99344d84ab9d" title="Provides cond&#39;s base case for AutoDiff.">cond</a> ? expr_then :
   expr_else</span>, the then expression <code>expr_then</code> (respectively, the else expression <code>expr_else</code>) is <b>only</b> evaluated when the conditional expression <code>cond</code> is evaluated to <b>true</b> (respectively, when <code>cond</code> is evaluated to <b>false</b>).</li>
<li>In case of the symbolic expression, <span class="tt">if_then_else(cond, expr_then,
   expr_else)</span>, however, <b>both</b> arguments <code>expr_then</code> and <code>expr_else</code> are evaluated first and then passed to the <code>if_then_else</code> function.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function returns an <b>expression</b> and it is different from the C++'s if-then-else <b>statement</b>.</dd>
<dd>
While it is still possible to define <span class="tt"> <a class="el" href="#a1f18b20230d6fd5d6a2c81a278a89edc">min</a>, <a class="el" href="#aa951d192140621a51f31d68ead6f3e4d">max</a>, <a class="el" href="#a44e11b5fa4c16951b30b26e43a316569">abs</a></span> math functions using <code>if_then_else</code> expression, it is highly <b>recommended</b> to use the provided native definitions for them because it allows solvers to detect specific math functions and to have a room for special optimizations.</dd>
<dd>
More information about the C++'s conditional expression and ternary operator is available at <a href="http://en.cppreference.com/w/cpp/language/operator_other#Conditional_operator">http://en.cppreference.com/w/cpp/language/operator_other#Conditional_operator</a>. </dd></dl>

</div>
</div>
<a id="adbfb5367e72dfbaf7a778e6896113f64" name="adbfb5367e72dfbaf7a778e6896113f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbfb5367e72dfbaf7a778e6896113f64">&#9670;&#160;</a></span>intersect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the intersection of <code class="param">vars1</code> and <code class="param">vars2</code>. </p>
<p>This function has a time complexity of <span class="tt">O(N₁ + N₂)</span> where <span class="tt">N₁</span> and <span class="tt">N₂</span> are the size of <code class="param">vars1</code> and <code class="param">vars2</code> respectively. </p>

</div>
</div>
<a id="ab6046c9bad9a1c5a1ba51ec6157376c3" name="ab6046c9bad9a1c5a1ba51ec6157376c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6046c9bad9a1c5a1ba51ec6157376c3">&#9670;&#160;</a></span>is_abs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is an abs expression. </p>

</div>
</div>
<a id="a98d9027559c1c3c683711d50fc7ff48f" name="a98d9027559c1c3c683711d50fc7ff48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d9027559c1c3c683711d50fc7ff48f">&#9670;&#160;</a></span>is_abs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is an absolute-value-function expression. </p>

</div>
</div>
<a id="a40a4e8165bee3d62bd4df8a68226098c" name="a40a4e8165bee3d62bd4df8a68226098c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a4e8165bee3d62bd4df8a68226098c">&#9670;&#160;</a></span>is_acos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is an arccosine expression. </p>

</div>
</div>
<a id="a5508dd313a8bc04ddcd2ce645fa2e821" name="a5508dd313a8bc04ddcd2ce645fa2e821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5508dd313a8bc04ddcd2ce645fa2e821">&#9670;&#160;</a></span>is_acos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is an arccosine expression. </p>

</div>
</div>
<a id="a5b8a1e5e59b460cac7c2d8b5cb1e172c" name="a5b8a1e5e59b460cac7c2d8b5cb1e172c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8a1e5e59b460cac7c2d8b5cb1e172c">&#9670;&#160;</a></span>is_addition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_addition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is an addition expression. </p>

</div>
</div>
<a id="a8b5c270803005a40362fb97997347098" name="a8b5c270803005a40362fb97997347098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5c270803005a40362fb97997347098">&#9670;&#160;</a></span>is_addition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_addition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is an addition expression. </p>

</div>
</div>
<a id="a55b4c96682d9db457216b967fe589b0f" name="a55b4c96682d9db457216b967fe589b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b4c96682d9db457216b967fe589b0f">&#9670;&#160;</a></span>is_asin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is an arcsine expression. </p>

</div>
</div>
<a id="aede8001df8d3301fef461d03dd2d859d" name="aede8001df8d3301fef461d03dd2d859d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede8001df8d3301fef461d03dd2d859d">&#9670;&#160;</a></span>is_asin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is an arcsine expression. </p>

</div>
</div>
<a id="a8137a62cd95401854de0b108ceb9ad6b" name="a8137a62cd95401854de0b108ceb9ad6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8137a62cd95401854de0b108ceb9ad6b">&#9670;&#160;</a></span>is_atan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is an arctangent expression. </p>

</div>
</div>
<a id="ae05b78fd26fef2a243bdfe6530c59dc5" name="ae05b78fd26fef2a243bdfe6530c59dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05b78fd26fef2a243bdfe6530c59dc5">&#9670;&#160;</a></span>is_atan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is an arctangent expression. </p>

</div>
</div>
<a id="a623309330fb0ecf31d8d9607e9da1215" name="a623309330fb0ecf31d8d9607e9da1215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623309330fb0ecf31d8d9607e9da1215">&#9670;&#160;</a></span>is_atan2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_atan2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is an arctangent2 expression. </p>

</div>
</div>
<a id="a9d8916c566e17be2178816265ade645d" name="a9d8916c566e17be2178816265ade645d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8916c566e17be2178816265ade645d">&#9670;&#160;</a></span>is_atan2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_atan2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is a arctangent2 expression. </p>

</div>
</div>
<a id="ad8d5eb3f737c5d4ffc2dee47228d316f" name="ad8d5eb3f737c5d4ffc2dee47228d316f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d5eb3f737c5d4ffc2dee47228d316f">&#9670;&#160;</a></span>is_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is a binary expression. </p>

</div>
</div>
<a id="af208e5f109a14eae18e12eb779e11c28" name="af208e5f109a14eae18e12eb779e11c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af208e5f109a14eae18e12eb779e11c28">&#9670;&#160;</a></span>is_ceil() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is a ceil expression. </p>

</div>
</div>
<a id="a21641bf62f5605ddf8818f445fcdfa4a" name="a21641bf62f5605ddf8818f445fcdfa4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21641bf62f5605ddf8818f445fcdfa4a">&#9670;&#160;</a></span>is_ceil() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is a ceil expression. </p>

</div>
</div>
<a id="a70fdb6bef6734fc34b5215e5c7b661df" name="a70fdb6bef6734fc34b5215e5c7b661df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70fdb6bef6734fc34b5215e5c7b661df">&#9670;&#160;</a></span>is_conjunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_conjunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a conjunction (∧). </p>

</div>
</div>
<a id="a9074585b52963983223bce6e902efea7" name="a9074585b52963983223bce6e902efea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9074585b52963983223bce6e902efea7">&#9670;&#160;</a></span>is_conjunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_conjunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a conjunction (∧). </p>

</div>
</div>
<a id="acef926e653145a96fc31416c85e20c14" name="acef926e653145a96fc31416c85e20c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef926e653145a96fc31416c85e20c14">&#9670;&#160;</a></span>is_constant() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_constant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is a constant expression. </p>

</div>
</div>
<a id="abefc608adef6255f93f6aecf809a8b11" name="abefc608adef6255f93f6aecf809a8b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abefc608adef6255f93f6aecf809a8b11">&#9670;&#160;</a></span>is_constant() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_constant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is a constant expression representing <code class="param">v</code>. </p>

</div>
</div>
<a id="a1ad1d934168832dc9e42cc388cdaccca" name="a1ad1d934168832dc9e42cc388cdaccca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad1d934168832dc9e42cc388cdaccca">&#9670;&#160;</a></span>is_cos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is a cosine expression. </p>

</div>
</div>
<a id="a91183d02aeaa64b9f83cf61cede3d013" name="a91183d02aeaa64b9f83cf61cede3d013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91183d02aeaa64b9f83cf61cede3d013">&#9670;&#160;</a></span>is_cos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is a cosine expression. </p>

</div>
</div>
<a id="ab296e6587d7bf86a4f1b54b5005df4a6" name="ab296e6587d7bf86a4f1b54b5005df4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab296e6587d7bf86a4f1b54b5005df4a6">&#9670;&#160;</a></span>is_cosh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is a hyperbolic-cosine expression. </p>

</div>
</div>
<a id="a5db9c4002b15345dce271d95cf5ead8b" name="a5db9c4002b15345dce271d95cf5ead8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db9c4002b15345dce271d95cf5ead8b">&#9670;&#160;</a></span>is_cosh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is a hyperbolic-cosine expression. </p>

</div>
</div>
<a id="a307cee89f5417dd1c19ba16bb273fb25" name="a307cee89f5417dd1c19ba16bb273fb25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a307cee89f5417dd1c19ba16bb273fb25">&#9670;&#160;</a></span>is_disjunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_disjunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a disjunction (∨). </p>

</div>
</div>
<a id="a8877eff0311bb541c504a56196a591f0" name="a8877eff0311bb541c504a56196a591f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8877eff0311bb541c504a56196a591f0">&#9670;&#160;</a></span>is_disjunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_disjunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a disjunction (∨). </p>

</div>
</div>
<a id="ab069e1d04f34ba9f9eff1ee8e97cca6e" name="ab069e1d04f34ba9f9eff1ee8e97cca6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab069e1d04f34ba9f9eff1ee8e97cca6e">&#9670;&#160;</a></span>is_division() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_division </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is a division expression. </p>

</div>
</div>
<a id="a1ef7767ed74e24d55ada8b380bcd22d8" name="a1ef7767ed74e24d55ada8b380bcd22d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef7767ed74e24d55ada8b380bcd22d8">&#9670;&#160;</a></span>is_division() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_division </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is a division expression. </p>

</div>
</div>
<a id="aa44a7661fef44d4031441019512ef82d" name="aa44a7661fef44d4031441019512ef82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44a7661fef44d4031441019512ef82d">&#9670;&#160;</a></span>is_equal_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a formula representing equality (==). </p>

</div>
</div>
<a id="a37d37d1e3097c7a898d706aee5066f90" name="a37d37d1e3097c7a898d706aee5066f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d37d1e3097c7a898d706aee5066f90">&#9670;&#160;</a></span>is_equal_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a formula representing equality (==). </p>

</div>
</div>
<a id="a77a9ff7a7f105a0e9edf77cace06d9e9" name="a77a9ff7a7f105a0e9edf77cace06d9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a9ff7a7f105a0e9edf77cace06d9e9">&#9670;&#160;</a></span>is_exp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is an exp expression. </p>

</div>
</div>
<a id="aa1af4fb44735c433e6742487abbdf9eb" name="aa1af4fb44735c433e6742487abbdf9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1af4fb44735c433e6742487abbdf9eb">&#9670;&#160;</a></span>is_exp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is an exp expression. </p>

</div>
</div>
<a id="aea6545b9866491ab6406d9141903d204" name="aea6545b9866491ab6406d9141903d204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6545b9866491ab6406d9141903d204">&#9670;&#160;</a></span>is_false() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_false </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is structurally equal to False formula. </p>

</div>
</div>
<a id="a8a8bf1c901b65947ce83086ab0921b13" name="a8a8bf1c901b65947ce83086ab0921b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8bf1c901b65947ce83086ab0921b13">&#9670;&#160;</a></span>is_false() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_false </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is structurally equal to False formula. </p>

</div>
</div>
<a id="a2fc1f48deb39118a12ed30496c2a0a33" name="a2fc1f48deb39118a12ed30496c2a0a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc1f48deb39118a12ed30496c2a0a33">&#9670;&#160;</a></span>is_floor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is a floor expression. </p>

</div>
</div>
<a id="a20fb80a81ab38fa64a9cc84c5dd3a71d" name="a20fb80a81ab38fa64a9cc84c5dd3a71d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20fb80a81ab38fa64a9cc84c5dd3a71d">&#9670;&#160;</a></span>is_floor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is a floor expression. </p>

</div>
</div>
<a id="a1860e7373cbab3826845de76f4c6fc6a" name="a1860e7373cbab3826845de76f4c6fc6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1860e7373cbab3826845de76f4c6fc6a">&#9670;&#160;</a></span>is_forall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_forall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a Forall formula (∀). </p>

</div>
</div>
<a id="a7cdcb84785fc3ddf61732a3279ce6d74" name="a7cdcb84785fc3ddf61732a3279ce6d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cdcb84785fc3ddf61732a3279ce6d74">&#9670;&#160;</a></span>is_forall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_forall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a Forall formula (∀). </p>

</div>
</div>
<a id="a25bef67cdba7a3575080ee23c4a49c24" name="a25bef67cdba7a3575080ee23c4a49c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25bef67cdba7a3575080ee23c4a49c24">&#9670;&#160;</a></span>is_greater_than() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_greater_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a formula representing greater-than (&gt;). </p>

</div>
</div>
<a id="aaf04cff26c77f1ef1f11fedc77a31bb5" name="aaf04cff26c77f1ef1f11fedc77a31bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf04cff26c77f1ef1f11fedc77a31bb5">&#9670;&#160;</a></span>is_greater_than() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_greater_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a formula representing greater-than (&gt;). </p>

</div>
</div>
<a id="aa6bd435704910ee83eec832dec9e0ebe" name="aa6bd435704910ee83eec832dec9e0ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6bd435704910ee83eec832dec9e0ebe">&#9670;&#160;</a></span>is_greater_than_or_equal_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_greater_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a formula representing greater-than-or-equal-to (&gt;=). </p>

</div>
</div>
<a id="a987c2a9d322549f8617a45997bae8aa6" name="a987c2a9d322549f8617a45997bae8aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987c2a9d322549f8617a45997bae8aa6">&#9670;&#160;</a></span>is_greater_than_or_equal_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_greater_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a formula representing greater-than-or-equal-to (&gt;=). </p>

</div>
</div>
<a id="a5490fa85a0978930d5966dad1c6ba54b" name="a5490fa85a0978930d5966dad1c6ba54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5490fa85a0978930d5966dad1c6ba54b">&#9670;&#160;</a></span>is_if_then_else() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_if_then_else </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is an if-then-else expression. </p>

</div>
</div>
<a id="ab19b1f2d76056a8e9ee91ca1d14ee822" name="ab19b1f2d76056a8e9ee91ca1d14ee822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19b1f2d76056a8e9ee91ca1d14ee822">&#9670;&#160;</a></span>is_if_then_else() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_if_then_else </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is an if-then-else expression. </p>

</div>
</div>
<a id="a41fa4f6294d582b138b5879c7d8da160" name="a41fa4f6294d582b138b5879c7d8da160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fa4f6294d582b138b5879c7d8da160">&#9670;&#160;</a></span>is_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_integer </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a75b1751d953407c394e5643f2d1d3f27" name="a75b1751d953407c394e5643f2d1d3f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b1751d953407c394e5643f2d1d3f27">&#9670;&#160;</a></span>is_isnan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is an isnan formula. </p>

</div>
</div>
<a id="aa7ae3f7e8da7523a075b5adfcb7b788c" name="aa7ae3f7e8da7523a075b5adfcb7b788c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ae3f7e8da7523a075b5adfcb7b788c">&#9670;&#160;</a></span>is_isnan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is an isnan formula. </p>

</div>
</div>
<a id="a9754658b6efb430a95a6ef060573970e" name="a9754658b6efb430a95a6ef060573970e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9754658b6efb430a95a6ef060573970e">&#9670;&#160;</a></span>is_less_than() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_less_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a formula representing less-than (&lt;). </p>

</div>
</div>
<a id="a4e70f747ac0d276d07b39a56d8f2b5b9" name="a4e70f747ac0d276d07b39a56d8f2b5b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e70f747ac0d276d07b39a56d8f2b5b9">&#9670;&#160;</a></span>is_less_than() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_less_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a formula representing less-than (&lt;). </p>

</div>
</div>
<a id="af1861c52cf99c60f758c0f4bd642ecf9" name="af1861c52cf99c60f758c0f4bd642ecf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1861c52cf99c60f758c0f4bd642ecf9">&#9670;&#160;</a></span>is_less_than_or_equal_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_less_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a formula representing less-than-or-equal-to (&lt;=). </p>

</div>
</div>
<a id="a77bc9328e2893740b71f07cf466f02db" name="a77bc9328e2893740b71f07cf466f02db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77bc9328e2893740b71f07cf466f02db">&#9670;&#160;</a></span>is_less_than_or_equal_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_less_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a formula representing less-than-or-equal-to (&lt;=). </p>

</div>
</div>
<a id="ab049cfca69564b8713a3fd0a0e3bbba9" name="ab049cfca69564b8713a3fd0a0e3bbba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab049cfca69564b8713a3fd0a0e3bbba9">&#9670;&#160;</a></span>is_log() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is a log expression. </p>

</div>
</div>
<a id="a81fc6d7808fa4484507ddbb2471deb80" name="a81fc6d7808fa4484507ddbb2471deb80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81fc6d7808fa4484507ddbb2471deb80">&#9670;&#160;</a></span>is_log() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is a log expression. </p>

</div>
</div>
<a id="a30f8d47e7843b3aabbe95d6651b7c85f" name="a30f8d47e7843b3aabbe95d6651b7c85f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f8d47e7843b3aabbe95d6651b7c85f">&#9670;&#160;</a></span>is_max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is a max expression. </p>

</div>
</div>
<a id="adfb4d01316fdb9323695db004bb8253b" name="adfb4d01316fdb9323695db004bb8253b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb4d01316fdb9323695db004bb8253b">&#9670;&#160;</a></span>is_max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is a max expression. </p>

</div>
</div>
<a id="ad138a32ee051ed06353da9b4d26374ed" name="ad138a32ee051ed06353da9b4d26374ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad138a32ee051ed06353da9b4d26374ed">&#9670;&#160;</a></span>is_min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is a min expression. </p>

</div>
</div>
<a id="a07604bda8201f0e20706eb90227c1237" name="a07604bda8201f0e20706eb90227c1237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07604bda8201f0e20706eb90227c1237">&#9670;&#160;</a></span>is_min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is a min expression. </p>

</div>
</div>
<a id="ad1f74bcd66ba02bc91f3434924a6c8a2" name="ad1f74bcd66ba02bc91f3434924a6c8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f74bcd66ba02bc91f3434924a6c8a2">&#9670;&#160;</a></span>is_multiplication() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is a multiplication expression. </p>

</div>
</div>
<a id="a3fbd20b990ba883bca7f6188c26ba861" name="a3fbd20b990ba883bca7f6188c26ba861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fbd20b990ba883bca7f6188c26ba861">&#9670;&#160;</a></span>is_multiplication() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is an multiplication expression. </p>

</div>
</div>
<a id="a56597943e81b4b1cb898816104662a16" name="a56597943e81b4b1cb898816104662a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56597943e81b4b1cb898816104662a16">&#9670;&#160;</a></span>is_nan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_nan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is NaN. </p>

</div>
</div>
<a id="a63d76102c00828325b11b21db606b5a0" name="a63d76102c00828325b11b21db606b5a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d76102c00828325b11b21db606b5a0">&#9670;&#160;</a></span>is_nary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_nary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a n-ary formula ({∧, ∨}). </p>

</div>
</div>
<a id="a58cc3d5891c01e1be6530506251dcdca" name="a58cc3d5891c01e1be6530506251dcdca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58cc3d5891c01e1be6530506251dcdca">&#9670;&#160;</a></span>is_nary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_nary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is N-ary. </p>

</div>
</div>
<a id="a4707946faf3b330e3bce6702cf48b2dd" name="a4707946faf3b330e3bce6702cf48b2dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4707946faf3b330e3bce6702cf48b2dd">&#9670;&#160;</a></span>is_neg_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_neg_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is -1.0. </p>

</div>
</div>
<a id="afbbcd3f16b91bba700239675e5826a81" name="afbbcd3f16b91bba700239675e5826a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbcd3f16b91bba700239675e5826a81">&#9670;&#160;</a></span>is_negation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_negation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a negation (¬). </p>

</div>
</div>
<a id="adf3743f22df29090472d034a69b9d7aa" name="adf3743f22df29090472d034a69b9d7aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3743f22df29090472d034a69b9d7aa">&#9670;&#160;</a></span>is_negation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_negation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a negation (¬). </p>

</div>
</div>
<a id="aa3adfd829d909bb71fce5624c2866e6c" name="aa3adfd829d909bb71fce5624c2866e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3adfd829d909bb71fce5624c2866e6c">&#9670;&#160;</a></span>is_non_negative_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_non_negative_integer </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b22d6f9b90847ce4b84be2a5afd1c30" name="a7b22d6f9b90847ce4b84be2a5afd1c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b22d6f9b90847ce4b84be2a5afd1c30">&#9670;&#160;</a></span>is_not_equal_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_not_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a formula representing disequality (!=). </p>

</div>
</div>
<a id="a08c4eae26a98b1345c997e579ed0709a" name="a08c4eae26a98b1345c997e579ed0709a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c4eae26a98b1345c997e579ed0709a">&#9670;&#160;</a></span>is_not_equal_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_not_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a formula representing disequality (!=). </p>

</div>
</div>
<a id="a28f3f42c88b77cf4893385a7a093087c" name="a28f3f42c88b77cf4893385a7a093087c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f3f42c88b77cf4893385a7a093087c">&#9670;&#160;</a></span>is_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is 1.0. </p>

</div>
</div>
<a id="a94fa08146a43d6256435dba24f608bcd" name="a94fa08146a43d6256435dba24f608bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94fa08146a43d6256435dba24f608bcd">&#9670;&#160;</a></span>is_positive_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_positive_integer </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31788a703bff17b148b3107beefbc585" name="a31788a703bff17b148b3107beefbc585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31788a703bff17b148b3107beefbc585">&#9670;&#160;</a></span>is_positive_semidefinite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a positive-semidefinite formula. </p>

</div>
</div>
<a id="a4c0bed602c95290fb77dc45316a1f54d" name="a4c0bed602c95290fb77dc45316a1f54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0bed602c95290fb77dc45316a1f54d">&#9670;&#160;</a></span>is_positive_semidefinite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a positive semidefinite formula. </p>

</div>
</div>
<a id="aa8204863236e57c7a074fb90bceb61a1" name="aa8204863236e57c7a074fb90bceb61a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8204863236e57c7a074fb90bceb61a1">&#9670;&#160;</a></span>is_pow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is a power-function expression. </p>

</div>
</div>
<a id="a78e3f155f5ffb14a784c8c6ba45eda79" name="a78e3f155f5ffb14a784c8c6ba45eda79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e3f155f5ffb14a784c8c6ba45eda79">&#9670;&#160;</a></span>is_pow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is a power-function expression. </p>

</div>
</div>
<a id="ab48c893fbcf425253c444573d100c3f2" name="ab48c893fbcf425253c444573d100c3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48c893fbcf425253c444573d100c3f2">&#9670;&#160;</a></span>is_relational() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_relational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a relational formula ({==, !=, &gt;, &gt;=, &lt;, &lt;=}). </p>

</div>
</div>
<a id="aba3787e10ce1fe3bb7f6645a0f9ac671" name="aba3787e10ce1fe3bb7f6645a0f9ac671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3787e10ce1fe3bb7f6645a0f9ac671">&#9670;&#160;</a></span>is_relational() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_relational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a relational formula ({==, !=, &gt;, &gt;=, &lt;, &lt;=}). </p>

</div>
</div>
<a id="a1af6fb7d06debf378b3a7446f7ad6f26" name="a1af6fb7d06debf378b3a7446f7ad6f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af6fb7d06debf378b3a7446f7ad6f26">&#9670;&#160;</a></span>is_sin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is a sine expression. </p>

</div>
</div>
<a id="a9333b59cea2e2d4fd444a236883efc19" name="a9333b59cea2e2d4fd444a236883efc19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9333b59cea2e2d4fd444a236883efc19">&#9670;&#160;</a></span>is_sin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is a sine expression. </p>

</div>
</div>
<a id="a4e18537f0fba7c1c6c87b20644caf9af" name="a4e18537f0fba7c1c6c87b20644caf9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e18537f0fba7c1c6c87b20644caf9af">&#9670;&#160;</a></span>is_sinh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is a hyperbolic-sine expression. </p>

</div>
</div>
<a id="a39b7051855909d23cb2364be81055f4d" name="a39b7051855909d23cb2364be81055f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b7051855909d23cb2364be81055f4d">&#9670;&#160;</a></span>is_sinh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is a hyperbolic-sine expression. </p>

</div>
</div>
<a id="ad88aa92c34154f228b7609c0a1e1f0ef" name="ad88aa92c34154f228b7609c0a1e1f0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88aa92c34154f228b7609c0a1e1f0ef">&#9670;&#160;</a></span>is_sqrt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is a square-root expression. </p>

</div>
</div>
<a id="a12582d9a26dfcad1e0f38d7cb252c278" name="a12582d9a26dfcad1e0f38d7cb252c278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12582d9a26dfcad1e0f38d7cb252c278">&#9670;&#160;</a></span>is_sqrt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is a square-root expression. </p>

</div>
</div>
<a id="aa4a2c288d79cc175a23093bfe33a033a" name="aa4a2c288d79cc175a23093bfe33a033a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a2c288d79cc175a23093bfe33a033a">&#9670;&#160;</a></span>is_tan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is a tangent expression. </p>

</div>
</div>
<a id="a7d440af755e098914afb44da35f0bc41" name="a7d440af755e098914afb44da35f0bc41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d440af755e098914afb44da35f0bc41">&#9670;&#160;</a></span>is_tan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is a tangent expression. </p>

</div>
</div>
<a id="aabae426c9b32ec48a5655f1e2bafd44c" name="aabae426c9b32ec48a5655f1e2bafd44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabae426c9b32ec48a5655f1e2bafd44c">&#9670;&#160;</a></span>is_tanh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is a hyperbolic-tangent expression. </p>

</div>
</div>
<a id="a9046d3df24ec467a11723f4d93a2b2b0" name="a9046d3df24ec467a11723f4d93a2b2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9046d3df24ec467a11723f4d93a2b2b0">&#9670;&#160;</a></span>is_tanh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is a hyperbolic-tangent expression. </p>

</div>
</div>
<a id="ac015488f4fe334717bbe5a47e1f1da87" name="ac015488f4fe334717bbe5a47e1f1da87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac015488f4fe334717bbe5a47e1f1da87">&#9670;&#160;</a></span>is_true() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_true </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is structurally equal to True formula. </p>

</div>
</div>
<a id="a2f1159580703bc95a8f14848e38cb659" name="a2f1159580703bc95a8f14848e38cb659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1159580703bc95a8f14848e38cb659">&#9670;&#160;</a></span>is_true() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_true </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is structurally equal to True formula. </p>

</div>
</div>
<a id="a1e9232608f43a586aad546b2a078aeb0" name="a1e9232608f43a586aad546b2a078aeb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9232608f43a586aad546b2a078aeb0">&#9670;&#160;</a></span>is_two()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_two </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is 2.0. </p>

</div>
</div>
<a id="aa38007aa3852d7b21d088e210e5bd17e" name="aa38007aa3852d7b21d088e210e5bd17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38007aa3852d7b21d088e210e5bd17e">&#9670;&#160;</a></span>is_unary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_unary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is a unary expression. </p>

</div>
</div>
<a id="aa19665aa37ff4c0aff7aa1ca142eff46" name="aa19665aa37ff4c0aff7aa1ca142eff46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19665aa37ff4c0aff7aa1ca142eff46">&#9670;&#160;</a></span>is_uninterpreted_function() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_uninterpreted_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is an uninterpreted-function expression. </p>

</div>
</div>
<a id="accafe113c53c148891d12dcabc66dddc" name="accafe113c53c148891d12dcabc66dddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accafe113c53c148891d12dcabc66dddc">&#9670;&#160;</a></span>is_uninterpreted_function() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_uninterpreted_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is an uninterpreted-function expression. </p>

</div>
</div>
<a id="a3313ad6342effa904bba98f1ef811902" name="a3313ad6342effa904bba98f1ef811902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3313ad6342effa904bba98f1ef811902">&#9670;&#160;</a></span>is_variable() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is a variable expression. </p>

</div>
</div>
<a id="a1044a1ad5d60045c18502cec5121149c" name="a1044a1ad5d60045c18502cec5121149c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1044a1ad5d60045c18502cec5121149c">&#9670;&#160;</a></span>is_variable() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">c</code> is a variable expression. </p>

</div>
</div>
<a id="aebdc9659eb8cc2eb735925fc4f2828ac" name="aebdc9659eb8cc2eb735925fc4f2828ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdc9659eb8cc2eb735925fc4f2828ac">&#9670;&#160;</a></span>is_variable() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a variable formula. </p>

</div>
</div>
<a id="a14d18c58b79582620cb6b8ff37ec1e85" name="a14d18c58b79582620cb6b8ff37ec1e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d18c58b79582620cb6b8ff37ec1e85">&#9670;&#160;</a></span>is_variable() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">f</code> is a variable formula. </p>

</div>
</div>
<a id="a07f09fda9abe80d7b775527445374c06" name="a07f09fda9abe80d7b775527445374c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f09fda9abe80d7b775527445374c06">&#9670;&#160;</a></span>is_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_zero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code class="param">e</code> is 0.0. </p>

</div>
</div>
<a id="a19b26cd2e30ae5f1e86f1649f39f32d6" name="a19b26cd2e30ae5f1e86f1649f39f32d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b26cd2e30ae5f1e86f1649f39f32d6">&#9670;&#160;</a></span>IsAffine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsAffine </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if every element in <span class="tt">m</span> is affine. </p>
<dl class="section note"><dt>Note</dt><dd>If <span class="tt">m</span> is an empty matrix, it returns true. </dd></dl>

</div>
</div>
<a id="aa4051560c8a37770f83160386c2ef480" name="aa4051560c8a37770f83160386c2ef480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4051560c8a37770f83160386c2ef480">&#9670;&#160;</a></span>IsAffine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsAffine </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if every element in <span class="tt">m</span> is affine in <span class="tt">vars</span>. </p>
<dl class="section note"><dt>Note</dt><dd>If <span class="tt">m</span> is an empty matrix, it returns true. </dd></dl>

</div>
</div>
<a id="ae2e386e89865ff1db9ac93f7a3e79586" name="ae2e386e89865ff1db9ac93f7a3e79586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e386e89865ff1db9ac93f7a3e79586">&#9670;&#160;</a></span>isfinite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> isfinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a> determining if the given expression <code class="param">e</code> has a finite value. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if NaN is detected during evaluation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a566d62c9e145df5946146f1a53c12a96" name="a566d62c9e145df5946146f1a53c12a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566d62c9e145df5946146f1a53c12a96">&#9670;&#160;</a></span>isinf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> isinf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a> determining if the given expression <code class="param">e</code> is a positive or negative infinity. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if NaN is detected during evaluation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee7da5a29fea63347ec7c9fddce7f022" name="aee7da5a29fea63347ec7c9fddce7f022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7da5a29fea63347ec7c9fddce7f022">&#9670;&#160;</a></span>isnan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a> for the predicate isnan(e) to the given expression. </p>
<p>This serves as the argument-dependent lookup related to std::isnan(double).</p>
<p>When this formula is evaluated, there are two possible outcomes:</p><ul>
<li>Returns false if the e.Evaluate() is not NaN.</li>
<li>Throws std::exception if NaN is detected during evaluation. Note that the evaluation of <span class="tt">isnan(e)</span> never returns true. </li>
</ul>

</div>
</div>
<a id="a1c77acbc22041eabb6c243ba5e09ea4a" name="a1c77acbc22041eabb6c243ba5e09ea4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c77acbc22041eabb6c243ba5e09ea4a">&#9670;&#160;</a></span>Jacobian() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; Jacobian </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Jacobian matrix J of the vector function <code class="param">f</code> with respect to <code class="param">vars</code>. </p>
<p>J(i,j) contains ∂f(i)/∂vars(j).</p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code class="param">vars</code> is non-empty}. </dd></dl>

</div>
</div>
<a id="a8f7f698709e6838fff06fe4b668263f0" name="a8f7f698709e6838fff06fe4b668263f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7f698709e6838fff06fe4b668263f0">&#9670;&#160;</a></span>Jacobian() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; Jacobian </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Jacobian matrix J of the vector function <code class="param">f</code> with respect to <code class="param">vars</code>. </p>
<p>J(i,j) contains ∂f(i)/∂vars(j).</p>
<p>For example, Jacobian([x * cos(y), x * sin(y), x^2], {x, y}) returns the following 3x2 matrix: </p><pre>
 = |cos(y)   -x * sin(y)|
   |sin(y)    x * cos(y)|
   | 2 * x             0|
 </pre><dl class="section pre"><dt>Precondition</dt><dd>{<code class="param">vars</code> is non-empty}. </dd></dl>

</div>
</div>
<a id="a1470c88dce76c089a696e9957d454d06" name="a1470c88dce76c089a696e9957d454d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1470c88dce76c089a696e9957d454d06">&#9670;&#160;</a></span>Jacobian() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &gt; Jacobian </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the Jacobian matrix J of the vector function <span class="tt">f</span> with respect to <span class="tt">vars</span>. </p>
<p>J(i,j) contains ∂f(i)/∂vars(j). </p><dl class="section pre"><dt>Precondition</dt><dd><span class="tt">vars</span> is non-empty. </dd></dl>

</div>
</div>
<a id="a1c7c9095542cd5f4ef70f50bca1aab7c" name="a1c7c9095542cd5f4ef70f50bca1aab7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7c9095542cd5f4ef70f50bca1aab7c">&#9670;&#160;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad928a3acb97d0b15191fdda370098cec" name="ad928a3acb97d0b15191fdda370098cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad928a3acb97d0b15191fdda370098cec">&#9670;&#160;</a></span>make_conjunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> make_conjunction </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>formulas</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a conjunction of <code class="param">formulas</code>. </p>
<p>It performs the following simplification:</p>
<ul>
<li>make_conjunction({}) returns True.</li>
<li>make_conjunction({f₁}) returns f₁.</li>
<li>If False ∈ <code class="param">formulas</code>, it returns False.</li>
<li>If True ∈ <code class="param">formulas</code>, it will not appear in the return value.</li>
<li>Nested conjunctions will be flattened. For example, make_conjunction({f₁, f₂ ∧ f₃}) returns f₁ ∧ f₂ ∧ f₃. </li>
</ul>

</div>
</div>
<a id="a10a756a422ebc5e372bb1ecc5ccab5be" name="a10a756a422ebc5e372bb1ecc5ccab5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a756a422ebc5e372bb1ecc5ccab5be">&#9670;&#160;</a></span>make_disjunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> make_disjunction </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>formulas</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a disjunction of <code class="param">formulas</code>. </p>
<p>It performs the following simplification:</p>
<ul>
<li>make_disjunction({}) returns False.</li>
<li>make_disjunction({f₁}) returns f₁.</li>
<li>If True ∈ <code class="param">formulas</code>, it returns True.</li>
<li>If False ∈ <code class="param">formulas</code>, it will not appear in the return value.</li>
<li>Nested disjunctions will be flattened. For example, make_disjunction({f₁, f₂ ∨ f₃}) returns f₁ ∨ f₂ ∨ f₃. </li>
</ul>

</div>
</div>
<a id="a2e71bf8f0510b93790216b435d76b990" name="a2e71bf8f0510b93790216b435d76b990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e71bf8f0510b93790216b435d76b990">&#9670;&#160;</a></span>MakeMatrixBinaryVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rows, int cols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt; MakeMatrixBinaryVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen matrix of symbolic binary variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <span class="tt">name(i, j)</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac40449e991943b02a88f4627fd02c872" name="ac40449e991943b02a88f4627fd02c872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40449e991943b02a88f4627fd02c872">&#9670;&#160;</a></span>MakeMatrixBinaryVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; MakeMatrixBinaryVariable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen matrix of symbolic binary variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <span class="tt">name(i, j)</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a294114651d7f14e697af924bdeab3be6" name="a294114651d7f14e697af924bdeab3be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a294114651d7f14e697af924bdeab3be6">&#9670;&#160;</a></span>MakeMatrixBooleanVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rows, int cols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt; MakeMatrixBooleanVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen matrix of symbolic Boolean variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <span class="tt">name(i, j)</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a077c5aa3c1d61b9bf22590e5325af815" name="a077c5aa3c1d61b9bf22590e5325af815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077c5aa3c1d61b9bf22590e5325af815">&#9670;&#160;</a></span>MakeMatrixBooleanVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; MakeMatrixBooleanVariable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen matrix of symbolic Boolean variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <span class="tt">name(i, j)</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaae2ea8fef645baa51e6cea3e54986aa" name="aaae2ea8fef645baa51e6cea3e54986aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae2ea8fef645baa51e6cea3e54986aa">&#9670;&#160;</a></span>MakeMatrixContinuousVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rows, int cols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt; MakeMatrixContinuousVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen matrix of symbolic continuous variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <span class="tt">name(i, j)</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4881156a2dba929854529bbecb7bb2e2" name="a4881156a2dba929854529bbecb7bb2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4881156a2dba929854529bbecb7bb2e2">&#9670;&#160;</a></span>MakeMatrixContinuousVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; MakeMatrixContinuousVariable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen matrix of symbolic continuous variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <span class="tt">name(i, j)</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0fe9881160a77596c4b05b7ba61ee31" name="ac0fe9881160a77596c4b05b7ba61ee31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0fe9881160a77596c4b05b7ba61ee31">&#9670;&#160;</a></span>MakeMatrixIntegerVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rows, int cols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt; MakeMatrixIntegerVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen matrix of symbolic integer variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <span class="tt">name(i, j)</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aceffea98cb4dc7da681037dd3448e8a2" name="aceffea98cb4dc7da681037dd3448e8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceffea98cb4dc7da681037dd3448e8a2">&#9670;&#160;</a></span>MakeMatrixIntegerVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; MakeMatrixIntegerVariable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen matrix of symbolic integer variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <span class="tt">name(i, j)</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68e8b1ffb5f74f3ce63c46724e86936f" name="a68e8b1ffb5f74f3ce63c46724e86936f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e8b1ffb5f74f3ce63c46724e86936f">&#9670;&#160;</a></span>MakeMatrixVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rows, int cols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt; MakeMatrixVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">Variable::Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479ab1fa9dd3af034b3ef4291579aa673c07">Variable::Type::CONTINUOUS</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen matrix of symbolic variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <span class="tt">name(i, j)</span>. </td></tr>
    <tr><td class="paramname">type</td><td>The type of variables in the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa2767293dcf51a7e6c97ac205f9fb21" name="aaa2767293dcf51a7e6c97ac205f9fb21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa2767293dcf51a7e6c97ac205f9fb21">&#9670;&#160;</a></span>MakeMatrixVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; MakeMatrixVariable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">Variable::Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479ab1fa9dd3af034b3ef4291579aa673c07">Variable::Type::CONTINUOUS</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen matrix of symbolic variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <span class="tt">name(i, j)</span>. </td></tr>
    <tr><td class="paramname">type</td><td>The type of variables in the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a327c04af4b8fa510bd365a1bb7dfe6ed" name="a327c04af4b8fa510bd365a1bb7dfe6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327c04af4b8fa510bd365a1bb7dfe6ed">&#9670;&#160;</a></span>MakeRuleRewriter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a134e54042165751a5e5369b4631c90eb">Rewriter</a> MakeRuleRewriter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html">RewritingRule</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a rewriter based on a rewriting rule <code class="param">r</code>. </p>

</div>
</div>
<a id="a5ada2f4cd5f626d2ed9d9b532362ddda" name="a5ada2f4cd5f626d2ed9d9b532362ddda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ada2f4cd5f626d2ed9d9b532362ddda">&#9670;&#160;</a></span>MakeVectorBinaryVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rows&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt; MakeVectorBinaryVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen vector of symbolic binary variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <span class="tt">name(i)</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9341ab1f18ff240083389ccdcb483ed3" name="a9341ab1f18ff240083389ccdcb483ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9341ab1f18ff240083389ccdcb483ed3">&#9670;&#160;</a></span>MakeVectorBinaryVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; MakeVectorBinaryVariable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen vector of symbolic binary variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <span class="tt">name(i)</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad19385116c11441853d823e47ad33aa7" name="ad19385116c11441853d823e47ad33aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19385116c11441853d823e47ad33aa7">&#9670;&#160;</a></span>MakeVectorBooleanVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rows&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt; MakeVectorBooleanVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen vector of symbolic Boolean variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <span class="tt">name(i)</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f7fee6b939582c5bd9f0020ebeb2c2a" name="a1f7fee6b939582c5bd9f0020ebeb2c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7fee6b939582c5bd9f0020ebeb2c2a">&#9670;&#160;</a></span>MakeVectorBooleanVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; MakeVectorBooleanVariable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen vector of symbolic Boolean variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <span class="tt">name(i)</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7753f7705e1a8cc3bd01ea57d36ccd87" name="a7753f7705e1a8cc3bd01ea57d36ccd87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7753f7705e1a8cc3bd01ea57d36ccd87">&#9670;&#160;</a></span>MakeVectorContinuousVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rows&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt; MakeVectorContinuousVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen vector of symbolic continuous variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <span class="tt">name(i)</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9512d7058f85f0f5ddcf2ad601768d54" name="a9512d7058f85f0f5ddcf2ad601768d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9512d7058f85f0f5ddcf2ad601768d54">&#9670;&#160;</a></span>MakeVectorContinuousVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; MakeVectorContinuousVariable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen vector of symbolic continuous variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <span class="tt">name(i)</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64a75ded73193f7ec7d332fd36af5bbb" name="a64a75ded73193f7ec7d332fd36af5bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a75ded73193f7ec7d332fd36af5bbb">&#9670;&#160;</a></span>MakeVectorIntegerVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rows&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt; MakeVectorIntegerVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen vector of symbolic integer variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <span class="tt">name(i)</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa67f9414a4674809981130f03d1da9c0" name="aa67f9414a4674809981130f03d1da9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67f9414a4674809981130f03d1da9c0">&#9670;&#160;</a></span>MakeVectorIntegerVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; MakeVectorIntegerVariable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen vector of symbolic integer variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <span class="tt">name(i)</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e7c156277f8c2d91bd0a59c1d498138" name="a2e7c156277f8c2d91bd0a59c1d498138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7c156277f8c2d91bd0a59c1d498138">&#9670;&#160;</a></span>MakeVectorVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rows&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt; MakeVectorVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">Variable::Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479ab1fa9dd3af034b3ef4291579aa673c07">Variable::Type::CONTINUOUS</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen vector of symbolic variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <span class="tt">name(i)</span>. </td></tr>
    <tr><td class="paramname">type</td><td>The type of variables in the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae31d21987f2a78dacc64786ef86233cd" name="ae31d21987f2a78dacc64786ef86233cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31d21987f2a78dacc64786ef86233cd">&#9670;&#160;</a></span>MakeVectorVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; MakeVectorVariable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">Variable::Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479ab1fa9dd3af034b3ef4291579aa673c07">Variable::Type::CONTINUOUS</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen vector of symbolic variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <span class="tt">name(i)</span>. </td></tr>
    <tr><td class="paramname">type</td><td>The type of variables in the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa951d192140621a51f31d68ead6f3e4d" name="aa951d192140621a51f31d68ead6f3e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa951d192140621a51f31d68ead6f3e4d">&#9670;&#160;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f18b20230d6fd5d6a2c81a278a89edc" name="a1f18b20230d6fd5d6a2c81a278a89edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f18b20230d6fd5d6a2c81a278a89edc">&#9670;&#160;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa926fea06c17ca6892965848c0236c9b" name="aa926fea06c17ca6892965848c0236c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa926fea06c17ca6892965848c0236c9b">&#9670;&#160;</a></span>MonomialBasis() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &gt; MonomialBasis </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>, int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>variables_degree</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all the monomials (in graded reverse lexicographic order) such that the total degree for each set of variables is no larger than a specific degree. </p>
<p>For example if x_set = {x₀, x₁} and y_set = {y₀, y₁}, then MonomialBasis({{x_set, 2}, {y_set, 1}}) will include all the monomials, whose total degree of x_set is no larger than 2, and the total degree of y_set is no larger than 1. Hence it can include monomials such as x₀x₁y₀, but not x₀y₀y₁ because the total degree for y_set is 2. So it would return the following set of monomials (ignoring the ordering) {x₀²y₀, x₀²y₁, x₀x₁y₀, x₀x₁y₁, x₁²y₀, x₁²y₀, x₀y₀, x₀y₁, x₁y₀, x₁y₁, x₀², x₀x₁, x₁², x₀, x₁, y₀, y₁, 1}. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables_degree</td><td><span class="tt">(vars, degree)</span> maps each set of variables <span class="tt">vars</span> to the maximal degree of these variables in the monomial. Namely the summation of the degree of each variable in <span class="tt">vars</span> is no larger than <span class="tt">degree</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The variables in <span class="tt">variables_degree</span> don't overlap. </dd>
<dd>
The degree in <span class="tt">variables_degree</span> are non-negative. </dd></dl>

</div>
</div>
<a id="a522ebdd58f8672ca038fb6fbfdce4534" name="a522ebdd58f8672ca038fb6fbfdce4534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522ebdd58f8672ca038fb6fbfdce4534">&#9670;&#160;</a></span>MonomialBasis() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, int degree&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, <a class="el" href="#a873c3185813c9ca5a6ca690669698518">NChooseK</a>(n+degree, degree), 1 &gt; MonomialBasis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all monomials up to a given degree under the graded reverse lexicographic order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">n</td><td>number of variables. </td></tr>
    <tr><td class="paramname">degree</td><td>maximum total degree of monomials to compute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code class="param">vars</code> is a non-empty set. </dd>
<dd>
vars.size() == <code class="param">n</code>. </dd></dl>

</div>
</div>
<a id="adc6302f8ed7ce764202bffb915277dc2" name="adc6302f8ed7ce764202bffb915277dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6302f8ed7ce764202bffb915277dc2">&#9670;&#160;</a></span>MonomialBasis() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, Eigen::Dynamic, 1 &gt; MonomialBasis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>degree</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all monomials up to a given degree under the graded reverse lexicographic order. </p>
<p>Note that graded reverse lexicographic order uses the total order among <a class="el" href="classdrake_1_1symbolic_1_1_variable.html" title="Represents a symbolic variable.">Variable</a> which is based on a variable's unique ID. For example, for a given variable ordering x &gt; y &gt; z, <span class="tt"><a class="el" href="#adc6302f8ed7ce764202bffb915277dc2" title="Returns all monomials up to a given degree under the graded reverse lexicographic order.">MonomialBasis</a>({x, y, z},
2)</span> returns a column vector <span class="tt">[x^2, xy, y^2, xz, yz, z^2, x, y, z, 1]</span>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code class="param">vars</code> is a non-empty set. </dd>
<dd>
<code class="param">degree</code> is a non-negative integer. </dd></dl>

</div>
</div>
<a id="a873c3185813c9ca5a6ca690669698518" name="a873c3185813c9ca5a6ca690669698518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873c3185813c9ca5a6ca690669698518">&#9670;&#160;</a></span>NChooseK()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int NChooseK </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb92bbabf88873d1766586c031a6f3e2" name="afb92bbabf88873d1766586c031a6f3e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb92bbabf88873d1766586c031a6f3e2">&#9670;&#160;</a></span>OddDegreeMonomialBasis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, Eigen::Dynamic, 1 &gt; OddDegreeMonomialBasis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>degree</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all odd degree monomials up to a given degree under the graded reverse lexicographic order. </p>
<p>A monomial has an odd degree if its total degree is odd. So x²y is an odd degree monomial (degree 3) while xy is not (degree 2). Note that graded reverse lexicographic order uses the total order among <a class="el" href="classdrake_1_1symbolic_1_1_variable.html" title="Represents a symbolic variable.">Variable</a> which is based on a variable's unique ID. For example, for a given variable ordering x &gt; y &gt; z, <span class="tt"><a class="el" href="#afb92bbabf88873d1766586c031a6f3e2" title="Returns all odd degree monomials up to a given degree under the graded reverse lexicographic order.">OddDegreeMonomialBasis</a>({x, y, z}, 3)</span> returns a column vector <span class="tt">[x³, x²y, xy², y³, x²z, xyz, y²z, xz², yz², z³, x,
y, z]</span></p>
<dl class="section pre"><dt>Precondition</dt><dd><code class="param">vars</code> is a non-empty set. </dd>
<dd>
<code class="param">degree</code> is a non-negative integer. </dd></dl>

</div>
</div>
<a id="a49edb4821b05df85a60fe3d96adf4f70" name="a49edb4821b05df85a60fe3d96adf4f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49edb4821b05df85a60fe3d96adf4f70">&#9670;&#160;</a></span>operator!() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator! </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9175736ad1ead8240b9bbc1bd8d4f37f" name="a9175736ad1ead8240b9bbc1bd8d4f37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9175736ad1ead8240b9bbc1bd8d4f37f">&#9670;&#160;</a></span>operator!() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator! </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a417bf2fd4f030f7aa2d3ac779bf4c099" name="a417bf2fd4f030f7aa2d3ac779bf4c099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417bf2fd4f030f7aa2d3ac779bf4c099">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived, typename ScalarType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar() !=ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt; <a class="el" href="#a49edb4821b05df85a60fe3d96adf4f70">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code class="param">a</code> and a scalar <code class="param">v</code> using not-equal operator (!=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <span class="tt">(a != v)</span> has a symbolic formula <span class="tt">a(i, j) != v</span>. </p>

</div>
</div>
<a id="a8e2230c401a3cf25909b4b25cac536be" name="a8e2230c401a3cf25909b4b25cac536be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2230c401a3cf25909b4b25cac536be">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() !=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt; <a class="el" href="#a49edb4821b05df85a60fe3d96adf4f70">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;</td>          <td class="paramname"><span class="paramname"><em>a1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;</td>          <td class="paramname"><span class="paramname"><em>a2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code class="param">a1</code> and <code class="param">a2</code> using not-equal operator (!=). </p>

</div>
</div>
<a id="a092d073efe77947ba617bc41cf166308" name="a092d073efe77947ba617bc41cf166308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a092d073efe77947ba617bc41cf166308">&#9670;&#160;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() !=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; <a class="el" href="#a49edb4821b05df85a60fe3d96adf4f70">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula representing the condition whether <code class="param">m1</code> and <code class="param">m2</code> are not the same. </p>
<p>The following table describes the return type of <code class="param">m1</code> != <code class="param">m2</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LHS \ RHS  </th><th class="markdownTableHeadNone">EM&lt;Expression&gt;  </th><th class="markdownTableHeadNone">EM&lt;Variable&gt;  </th><th class="markdownTableHeadNone">EM&lt;double&gt;  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;Expression&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EM&lt;Variable&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;double&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone">bool  </td></tr>
</table>
<p>In the table, <span class="tt">EM</span> is a short-hand of <span class="tt">Eigen::Matrix</span>.</p>
<p>Note that this function does <em>not</em> provide operator overloading for the following case. It returns <span class="tt">bool</span> and is provided by Eigen.</p>
<ul>
<li>Eigen::Matrix&lt;double&gt; != Eigen::Matrix&lt;double&gt; </li>
</ul>

</div>
</div>
<a id="acf2a23baf604198889aab8eea8620601" name="acf2a23baf604198889aab8eea8620601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf2a23baf604198889aab8eea8620601">&#9670;&#160;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> <a class="el" href="#a49edb4821b05df85a60fe3d96adf4f70">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e08ccfd1038cd9ee942d2c32d9db1d6" name="a0e08ccfd1038cd9ee942d2c32d9db1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e08ccfd1038cd9ee942d2c32d9db1d6">&#9670;&#160;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType, typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType() !=typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt; <a class="el" href="#a49edb4821b05df85a60fe3d96adf4f70">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code class="param">v</code> and an array <code class="param">using</code> not-equal operator (!=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <span class="tt">(v != a)</span> has a symbolic formula <span class="tt">v != a(i, j)</span>. </p>

</div>
</div>
<a id="a3b513c43cd0d555b75ce08e18241e920" name="a3b513c43cd0d555b75ce08e18241e920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b513c43cd0d555b75ce08e18241e920">&#9670;&#160;</a></span>operator&amp;&amp;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa29726cabd0dc09fe4fb61ffe80ad02" name="afa29726cabd0dc09fe4fb61ffe80ad02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa29726cabd0dc09fe4fb61ffe80ad02">&#9670;&#160;</a></span>operator&amp;&amp;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4af14e85b9784db6c9f6374e7d7ae67" name="ae4af14e85b9784db6c9f6374e7d7ae67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4af14e85b9784db6c9f6374e7d7ae67">&#9670;&#160;</a></span>operator&amp;&amp;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a47ad638c3929268d643623b21901e11a" name="a47ad638c3929268d643623b21901e11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ad638c3929268d643623b21901e11a">&#9670;&#160;</a></span>operator&amp;&amp;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b40dd59bc3bbf7d7d66bc8653a66437" name="a6b40dd59bc3bbf7d7d66bc8653a66437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b40dd59bc3bbf7d7d66bc8653a66437">&#9670;&#160;</a></span>operator*() <span class="overload">[1/43]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const BasisElement &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad432e40263668f90f62a421d67c66f5f" name="ad432e40263668f90f62a421d67c66f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad432e40263668f90f62a421d67c66f5f">&#9670;&#160;</a></span>operator*() <span class="overload">[2/43]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const BasisElement &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c8de394d55df1f6646d10a5ae89d078" name="a3c8de394d55df1f6646d10a5ae89d078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8de394d55df1f6646d10a5ae89d078">&#9670;&#160;</a></span>operator*() <span class="overload">[3/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a>, double &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the product of two Chebyshev basis elements. </p>
<p>Since Tₘ(x) * Tₙ(x) = 0.5 (Tₘ₊ₙ(x) + Tₘ₋ₙ(x)) if m &gt;= n, the product of Chebyshev basis elements is the weighted sum of several Chebyshev basis elements. For example T₁(x)T₂(y) * T₃(x)T₁(y) = 0.25*(T₄(x)T₃(y) + T₂(x)T₃(y)</p><ul>
<li>T₄(x)T₁(y) + T₂(x)T₁(y)) <dl class="section return"><dt>Returns</dt><dd>the result of the product, from each <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html" title="ChebyshevBasisElement represents an element of Chebyshev polynomial basis, written as the product of ...">ChebyshevBasisElement</a> to its coefficient. In the example above, it returns (T₄(x)T₃(y) -&gt; 0.25), (T₂(x)T₃(y) -&gt; 0.25), (T₄(x)T₁(y) -&gt; 0.25) and (T₂(x)T₁(y) -&gt; 0.25) </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ae55638160eeaa986a98f80775f603f1a" name="ae55638160eeaa986a98f80775f603f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55638160eeaa986a98f80775f603f1a">&#9670;&#160;</a></span>operator*() <span class="overload">[4/43]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Dim, int LhsMode, int RhsMode, int LhsOptions, int RhsOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator* </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Transform&lt; double, Dim, LhsMode, LhsOptions &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>t1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Dim, RhsMode, RhsOptions &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>t2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform&lt;Expression&gt; * Transform&lt;double&gt; =&gt; Transform&lt;Expression&gt;. </p>

</div>
</div>
<a id="a2f3f93c98fa5f5179d7c50685f332e3d" name="a2f3f93c98fa5f5179d7c50685f332e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f3f93c98fa5f5179d7c50685f332e3d">&#9670;&#160;</a></span>operator*() <span class="overload">[5/43]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Dim, int LhsMode, int RhsMode, int LhsOptions, int RhsOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator* </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Transform&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Dim, LhsMode, LhsOptions &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>t1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; double, Dim, RhsMode, RhsOptions &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>t2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform&lt;double&gt; * Transform&lt;Expression&gt; =&gt; Transform&lt;Expression&gt;. </p>

</div>
</div>
<a id="ae55ea800cf249789ff0c149ce44affea" name="ae55ea800cf249789ff0c149ce44affea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55ea800cf249789ff0c149ce44affea">&#9670;&#160;</a></span>operator*() <span class="overload">[6/43]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a49df60ca05e93c468b6a8d6abe2cb36f" name="a49df60ca05e93c468b6a8d6abe2cb36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49df60ca05e93c468b6a8d6abe2cb36f">&#9670;&#160;</a></span>operator*() <span class="overload">[7/43]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixL, typename MatrixR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following matrix operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information.</dd></dl>
<ul>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt; <dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="aaaa40522735a8ab22bee50d971abd7c2" name="aaaa40522735a8ab22bee50d971abd7c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa40522735a8ab22bee50d971abd7c2">&#9670;&#160;</a></span>operator*() <span class="overload">[8/43]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixL, typename MatrixR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following matrix operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information.</dd></dl>
<ul>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt; <dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a32fa8a1e572d7ca5513a7046540191e4" name="a32fa8a1e572d7ca5513a7046540191e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32fa8a1e572d7ca5513a7046540191e4">&#9670;&#160;</a></span>operator*() <span class="overload">[9/43]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixL, typename MatrixR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, double &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following matrix operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information.</dd></dl>
<ul>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt; <dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a0f4d385b974644173b82afae8298cde3" name="a0f4d385b974644173b82afae8298cde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4d385b974644173b82afae8298cde3">&#9670;&#160;</a></span>operator*() <span class="overload">[10/43]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixL, typename MatrixR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, double &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following matrix operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information.</dd></dl>
<ul>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt; <dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a26e0be383a80c0ba1f0bdc6788a9d938" name="a26e0be383a80c0ba1f0bdc6788a9d938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e0be383a80c0ba1f0bdc6788a9d938">&#9670;&#160;</a></span>operator*() <span class="overload">[11/43]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixL, typename MatrixR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following matrix operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information.</dd></dl>
<ul>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt; <dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ab2ea62b60a8dab79d3121862b48692ac" name="ab2ea62b60a8dab79d3121862b48692ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ea62b60a8dab79d3121862b48692ac">&#9670;&#160;</a></span>operator*() <span class="overload">[12/43]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixL, typename MatrixR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following matrix operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information.</dd></dl>
<ul>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt; <dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a6e1d7fdaf7c05721d6bb5c790ee8f734" name="a6e1d7fdaf7c05721d6bb5c790ee8f734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e1d7fdaf7c05721d6bb5c790ee8f734">&#9670;&#160;</a></span>operator*() <span class="overload">[13/43]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixL, typename MatrixR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, double &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following matrix operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information.</dd></dl>
<ul>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt; <dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a0d0aa159235b47cd34fba5759eaaf194" name="a0d0aa159235b47cd34fba5759eaaf194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0aa159235b47cd34fba5759eaaf194">&#9670;&#160;</a></span>operator*() <span class="overload">[14/43]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixL, typename MatrixR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, double &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following matrix operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information.</dd></dl>
<ul>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt; <dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ab12259a0866a3cbc6a8883ec0b8009b1" name="ab12259a0866a3cbc6a8883ec0b8009b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12259a0866a3cbc6a8883ec0b8009b1">&#9670;&#160;</a></span>operator*() <span class="overload">[15/43]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixL, typename MatrixR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following matrix operations: </p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information.</dd></dl>
<ul>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt; <dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a36162c4bad2ea2acd8b5ca7bad262ce9" name="a36162c4bad2ea2acd8b5ca7bad262ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36162c4bad2ea2acd8b5ca7bad262ce9">&#9670;&#160;</a></span>operator*() <span class="overload">[16/43]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixL, typename MatrixR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following operations: </p>
<ul>
<li>Matrix&lt;RF&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;RF&gt;</li>
<li>Matrix&lt;RF&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;RF&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;RF&gt; =&gt; Matrix&lt;RF&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;RF&gt; =&gt; Matrix&lt;RF&gt;</li>
</ul>
<p>where RF is a shorthand for <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html" title="Represents symbolic rational function.">RationalFunction</a>.</p>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information</dd></dl>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information.</dd></dl>
<ul>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt; <dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a335b835b158bb74b8c176f0a9d0d98b3" name="a335b835b158bb74b8c176f0a9d0d98b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335b835b158bb74b8c176f0a9d0d98b3">&#9670;&#160;</a></span>operator*() <span class="overload">[17/43]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a45f74794ee4a396e8fd39b44665c2a62" name="a45f74794ee4a396e8fd39b44665c2a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f74794ee4a396e8fd39b44665c2a62">&#9670;&#160;</a></span>operator*() <span class="overload">[18/43]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a474c15a8d4808149c8dfc6dbab6eda4b" name="a474c15a8d4808149c8dfc6dbab6eda4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474c15a8d4808149c8dfc6dbab6eda4b">&#9670;&#160;</a></span>operator*() <span class="overload">[19/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8c98dff8a011e805179c01ac7f652c9" name="ac8c98dff8a011e805179c01ac7f652c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c98dff8a011e805179c01ac7f652c9">&#9670;&#160;</a></span>operator*() <span class="overload">[20/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a>, double &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a multiplication of two monomials, <code class="param">m1</code> and <code class="param">m2</code>. </p>
<dl class="section note"><dt>Note</dt><dd>that we return a map from the monomial product to its coefficient. This map has size 1, and the coefficient is also 1. We return a map instead of the <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html" title="MonomialBasisElement represents a monomial, a product of powers of variables with non-negative intege...">MonomialBasisElement</a> directly, because we want operator* to have the same return signature as other <a class="el" href="classdrake_1_1symbolic_1_1_polynomial_basis_element.html" title="Each polynomial p(x) can be written as a linear combination of its basis elements p(x) = ∑ᵢ cᵢ * ϕᵢ(x...">PolynomialBasisElement</a>. For example, the product between two <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html" title="ChebyshevBasisElement represents an element of Chebyshev polynomial basis, written as the product of ...">ChebyshevBasisElement</a> objects is a weighted sum of <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html" title="ChebyshevBasisElement represents an element of Chebyshev polynomial basis, written as the product of ...">ChebyshevBasisElement</a> objects. </dd>
<dd>
we do not provide operator*= function for this class, since operator*= would return <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html" title="MonomialBasisElement represents a monomial, a product of powers of variables with non-negative intege...">MonomialBasisElement</a>, which is different from operator*. </dd></dl>

</div>
</div>
<a id="ac1151332b14909d80e32a755b5a4bcfb" name="ac1151332b14909d80e32a755b5a4bcfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1151332b14909d80e32a755b5a4bcfb">&#9670;&#160;</a></span>operator*() <span class="overload">[21/43]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac96d8eb0d54db155ab9f2ae5b3057c2f" name="ac96d8eb0d54db155ab9f2ae5b3057c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96d8eb0d54db155ab9f2ae5b3057c2f">&#9670;&#160;</a></span>operator*() <span class="overload">[22/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf28234a16f99392d95b9ae31fe3cb68" name="aaf28234a16f99392d95b9ae31fe3cb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf28234a16f99392d95b9ae31fe3cb68">&#9670;&#160;</a></span>operator*() <span class="overload">[23/43]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a85a5b653c9cc881bd5995e5affbfa0d0" name="a85a5b653c9cc881bd5995e5affbfa0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a5b653c9cc881bd5995e5affbfa0d0">&#9670;&#160;</a></span>operator*() <span class="overload">[24/43]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f0f7c92e16ecceaef0a148919ccfdb4" name="a1f0f7c92e16ecceaef0a148919ccfdb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f0f7c92e16ecceaef0a148919ccfdb4">&#9670;&#160;</a></span>operator*() <span class="overload">[25/43]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisElement &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30e80d8ac3887ff8b4c0368edf473436" name="a30e80d8ac3887ff8b4c0368edf473436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e80d8ac3887ff8b4c0368edf473436">&#9670;&#160;</a></span>operator*() <span class="overload">[26/43]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator* </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a67779390665ae921316f2fed4d5bbc5d" name="a67779390665ae921316f2fed4d5bbc5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67779390665ae921316f2fed4d5bbc5d">&#9670;&#160;</a></span>operator*() <span class="overload">[27/43]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a36b5a1a34fd92c6df9037af080ba1913" name="a36b5a1a34fd92c6df9037af080ba1913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b5a1a34fd92c6df9037af080ba1913">&#9670;&#160;</a></span>operator*() <span class="overload">[28/43]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator* </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6654fd307d9348f2baa46da2ff3abd3" name="ae6654fd307d9348f2baa46da2ff3abd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6654fd307d9348f2baa46da2ff3abd3">&#9670;&#160;</a></span>operator*() <span class="overload">[29/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator* </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3afe6eb8130d59ffeabe0b6dcc382353" name="a3afe6eb8130d59ffeabe0b6dcc382353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3afe6eb8130d59ffeabe0b6dcc382353">&#9670;&#160;</a></span>operator*() <span class="overload">[30/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d5903da758c3263027fe2d3879eb883" name="a6d5903da758c3263027fe2d3879eb883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d5903da758c3263027fe2d3879eb883">&#9670;&#160;</a></span>operator*() <span class="overload">[31/43]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisElement &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64fedfabf66785a5397ef80ee3388a12" name="a64fedfabf66785a5397ef80ee3388a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64fedfabf66785a5397ef80ee3388a12">&#9670;&#160;</a></span>operator*() <span class="overload">[32/43]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e099436a8bc0e61fb6b7a18e673e7eb" name="a0e099436a8bc0e61fb6b7a18e673e7eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e099436a8bc0e61fb6b7a18e673e7eb">&#9670;&#160;</a></span>operator*() <span class="overload">[33/43]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27ba3edbf8685b85b205325292578087" name="a27ba3edbf8685b85b205325292578087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ba3edbf8685b85b205325292578087">&#9670;&#160;</a></span>operator*() <span class="overload">[34/43]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5eb41b274605738d8049c0f0440c9ec" name="ad5eb41b274605738d8049c0f0440c9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5eb41b274605738d8049c0f0440c9ec">&#9670;&#160;</a></span>operator*() <span class="overload">[35/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a></td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a multiplication of two monomials, <span class="tt">m1</span> and <span class="tt">m2</span>. </p>

</div>
</div>
<a id="a82a1e5c6f989d9eb82b47f06df766264" name="a82a1e5c6f989d9eb82b47f06df766264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a1e5c6f989d9eb82b47f06df766264">&#9670;&#160;</a></span>operator*() <span class="overload">[36/43]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae03557c00e4297b310ef75c16f48f3b3" name="ae03557c00e4297b310ef75c16f48f3b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03557c00e4297b310ef75c16f48f3b3">&#9670;&#160;</a></span>operator*() <span class="overload">[37/43]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa927bf74086ce7d6a35bbe805e90dd4c" name="aa927bf74086ce7d6a35bbe805e90dd4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa927bf74086ce7d6a35bbe805e90dd4c">&#9670;&#160;</a></span>operator*() <span class="overload">[38/43]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a60c0402d8a4ab5d50003560ddccdb3a6" name="a60c0402d8a4ab5d50003560ddccdb3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c0402d8a4ab5d50003560ddccdb3a6">&#9670;&#160;</a></span>operator*() <span class="overload">[39/43]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0985bb395cb5351f28a5dc7c634a9963" name="a0985bb395cb5351f28a5dc7c634a9963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0985bb395cb5351f28a5dc7c634a9963">&#9670;&#160;</a></span>operator*() <span class="overload">[40/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5da13e9a5ae37fbfea7bd661cc15b3f8" name="a5da13e9a5ae37fbfea7bd661cc15b3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da13e9a5ae37fbfea7bd661cc15b3f8">&#9670;&#160;</a></span>operator*() <span class="overload">[41/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab92318b3c84edc12ed69faa7098c9ccc" name="ab92318b3c84edc12ed69faa7098c9ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92318b3c84edc12ed69faa7098c9ccc">&#9670;&#160;</a></span>operator*() <span class="overload">[42/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a47e353ad2f92e91622a6554945c10190" name="a47e353ad2f92e91622a6554945c10190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e353ad2f92e91622a6554945c10190">&#9670;&#160;</a></span>operator*() <span class="overload">[43/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a702e8b7089a5dd3d5cc22f9da154e1b2" name="a702e8b7089a5dd3d5cc22f9da154e1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a702e8b7089a5dd3d5cc22f9da154e1b2">&#9670;&#160;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f71101776f748d68a527275be5335bf" name="a4f71101776f748d68a527275be5335bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f71101776f748d68a527275be5335bf">&#9670;&#160;</a></span>operator+() <span class="overload">[1/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const BasisElement &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a08a9fa5e93b7cd9537d31b957ac91251" name="a08a9fa5e93b7cd9537d31b957ac91251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a9fa5e93b7cd9537d31b957ac91251">&#9670;&#160;</a></span>operator+() <span class="overload">[2/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const BasisElement &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aadaf8a9e57bdd9678f6026b8e7899130" name="aadaf8a9e57bdd9678f6026b8e7899130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadaf8a9e57bdd9678f6026b8e7899130">&#9670;&#160;</a></span>operator+() <span class="overload">[3/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const BasisElement &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisElement &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1474e5a6eadf9c929b552c4a1a774539" name="a1474e5a6eadf9c929b552c4a1a774539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1474e5a6eadf9c929b552c4a1a774539">&#9670;&#160;</a></span>operator+() <span class="overload">[4/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7526af799be25855a26020f2dace6e3d" name="a7526af799be25855a26020f2dace6e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7526af799be25855a26020f2dace6e3d">&#9670;&#160;</a></span>operator+() <span class="overload">[5/35]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb5a9659a11c5ee575468598af3a1234" name="acb5a9659a11c5ee575468598af3a1234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb5a9659a11c5ee575468598af3a1234">&#9670;&#160;</a></span>operator+() <span class="overload">[6/35]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f71e04c7645cc414e256fd4dd5bb868" name="a8f71e04c7645cc414e256fd4dd5bb868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f71e04c7645cc414e256fd4dd5bb868">&#9670;&#160;</a></span>operator+() <span class="overload">[7/35]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d664e2d28875d2a98edc0fb0fd3fe13" name="a5d664e2d28875d2a98edc0fb0fd3fe13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d664e2d28875d2a98edc0fb0fd3fe13">&#9670;&#160;</a></span>operator+() <span class="overload">[8/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3624f7d482fabd5c332896a9c5c94734" name="a3624f7d482fabd5c332896a9c5c94734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3624f7d482fabd5c332896a9c5c94734">&#9670;&#160;</a></span>operator+() <span class="overload">[9/35]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93ac6ff834c014e5dc9c7050c5d26a3e" name="a93ac6ff834c014e5dc9c7050c5d26a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ac6ff834c014e5dc9c7050c5d26a3e">&#9670;&#160;</a></span>operator+() <span class="overload">[10/35]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0801308a64278437b3734f11cc813da5" name="a0801308a64278437b3734f11cc813da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0801308a64278437b3734f11cc813da5">&#9670;&#160;</a></span>operator+() <span class="overload">[11/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f259fc8f615afffd8901318602c37db" name="a5f259fc8f615afffd8901318602c37db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f259fc8f615afffd8901318602c37db">&#9670;&#160;</a></span>operator+() <span class="overload">[12/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a040f17cc92f514c54410eafcd5b62e72" name="a040f17cc92f514c54410eafcd5b62e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040f17cc92f514c54410eafcd5b62e72">&#9670;&#160;</a></span>operator+() <span class="overload">[13/35]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a62cd62f14d17b199df485d5a4c2c976a" name="a62cd62f14d17b199df485d5a4c2c976a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62cd62f14d17b199df485d5a4c2c976a">&#9670;&#160;</a></span>operator+() <span class="overload">[14/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac56aaa3de6bd181f40290eb9c9ab264e" name="ac56aaa3de6bd181f40290eb9c9ab264e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56aaa3de6bd181f40290eb9c9ab264e">&#9670;&#160;</a></span>operator+() <span class="overload">[15/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a></td>          <td class="paramname"><span class="paramname"><em>vars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns set-union of {<code class="param">var}</code> and <code class="param">vars</code>. </p>

</div>
</div>
<a id="abf046f3e0b64c3749dce4dfbddaaefda" name="abf046f3e0b64c3749dce4dfbddaaefda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf046f3e0b64c3749dce4dfbddaaefda">&#9670;&#160;</a></span>operator+() <span class="overload">[16/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisElement &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4870c39dd0f76fa28c59bcf791863fd" name="ab4870c39dd0f76fa28c59bcf791863fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4870c39dd0f76fa28c59bcf791863fd">&#9670;&#160;</a></span>operator+() <span class="overload">[17/35]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeeb112e0e9010afde895dbde2139f09a" name="aeeb112e0e9010afde895dbde2139f09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb112e0e9010afde895dbde2139f09a">&#9670;&#160;</a></span>operator+() <span class="overload">[18/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ed2f8193622c6f565730970d1aed056" name="a2ed2f8193622c6f565730970d1aed056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed2f8193622c6f565730970d1aed056">&#9670;&#160;</a></span>operator+() <span class="overload">[19/35]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a001ec416bb7ee68695e1ec9a65b98720" name="a001ec416bb7ee68695e1ec9a65b98720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001ec416bb7ee68695e1ec9a65b98720">&#9670;&#160;</a></span>operator+() <span class="overload">[20/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d376b5d0899a705ee72195cde03af1c" name="a3d376b5d0899a705ee72195cde03af1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d376b5d0899a705ee72195cde03af1c">&#9670;&#160;</a></span>operator+() <span class="overload">[21/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bafc617451743d2ddf608aa2c08dd71" name="a4bafc617451743d2ddf608aa2c08dd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bafc617451743d2ddf608aa2c08dd71">&#9670;&#160;</a></span>operator+() <span class="overload">[22/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisElement &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc55a6a39a5555cc6bf7bdc398c046fc" name="acc55a6a39a5555cc6bf7bdc398c046fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc55a6a39a5555cc6bf7bdc398c046fc">&#9670;&#160;</a></span>operator+() <span class="overload">[23/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a69687593429f546fb96c6298712bbad5" name="a69687593429f546fb96c6298712bbad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69687593429f546fb96c6298712bbad5">&#9670;&#160;</a></span>operator+() <span class="overload">[24/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b8eb0200739107fb3a8d36ae80ed99b" name="a9b8eb0200739107fb3a8d36ae80ed99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8eb0200739107fb3a8d36ae80ed99b">&#9670;&#160;</a></span>operator+() <span class="overload">[25/35]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e385d568eb0ddc41d5b2dac2e081be0" name="a1e385d568eb0ddc41d5b2dac2e081be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e385d568eb0ddc41d5b2dac2e081be0">&#9670;&#160;</a></span>operator+() <span class="overload">[26/35]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aebd0c790d7f80f2b396f05e17c67d056" name="aebd0c790d7f80f2b396f05e17c67d056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd0c790d7f80f2b396f05e17c67d056">&#9670;&#160;</a></span>operator+() <span class="overload">[27/35]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af815e05dc1e773d924b5a761def81cbc" name="af815e05dc1e773d924b5a761def81cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af815e05dc1e773d924b5a761def81cbc">&#9670;&#160;</a></span>operator+() <span class="overload">[28/35]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af24522315ccc26ae75f90fe52edf75f8" name="af24522315ccc26ae75f90fe52edf75f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24522315ccc26ae75f90fe52edf75f8">&#9670;&#160;</a></span>operator+() <span class="overload">[29/35]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a395a3505af09308c3bc0c8ebf55c3afb" name="a395a3505af09308c3bc0c8ebf55c3afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395a3505af09308c3bc0c8ebf55c3afb">&#9670;&#160;</a></span>operator+() <span class="overload">[30/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ab71a213952c1f284526102a4356381" name="a6ab71a213952c1f284526102a4356381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab71a213952c1f284526102a4356381">&#9670;&#160;</a></span>operator+() <span class="overload">[31/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc56bda0a18e846fe326ac025e01a45d" name="abc56bda0a18e846fe326ac025e01a45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc56bda0a18e846fe326ac025e01a45d">&#9670;&#160;</a></span>operator+() <span class="overload">[32/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a90f257b9087b47d0579d8e7d9631abb4" name="a90f257b9087b47d0579d8e7d9631abb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f257b9087b47d0579d8e7d9631abb4">&#9670;&#160;</a></span>operator+() <span class="overload">[33/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d10380477ac001084ccc42d6aa005b6" name="a7d10380477ac001084ccc42d6aa005b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d10380477ac001084ccc42d6aa005b6">&#9670;&#160;</a></span>operator+() <span class="overload">[34/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a></td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns set-union of <code class="param">vars</code> and {<code class="param">var}</code>. </p>

</div>
</div>
<a id="a0176708e0ff133d7166b2f4700832885" name="a0176708e0ff133d7166b2f4700832885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0176708e0ff133d7166b2f4700832885">&#9670;&#160;</a></span>operator+() <span class="overload">[35/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a></td>          <td class="paramname"><span class="paramname"><em>vars1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns set-union of <code class="param">var1</code> and <code class="param">var2</code>. </p>

</div>
</div>
<a id="af3b7983f85fe6d5d0e6dd623f630cff2" name="af3b7983f85fe6d5d0e6dd623f630cff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b7983f85fe6d5d0e6dd623f630cff2">&#9670;&#160;</a></span>operator+=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f8e3a0afbcb8a9b989e58d4377cb8c0" name="a3f8e3a0afbcb8a9b989e58d4377cb8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8e3a0afbcb8a9b989e58d4377cb8c0">&#9670;&#160;</a></span>operator+=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates <code class="param">vars</code> with the result of set-union(<code class="param">vars</code>, { <code class="param">var</code> }). </p>

</div>
</div>
<a id="a63b70da62df0e5cd98c463b03038a175" name="a63b70da62df0e5cd98c463b03038a175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b70da62df0e5cd98c463b03038a175">&#9670;&#160;</a></span>operator+=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates <code class="param">var1</code> with the result of set-union(<code class="param">var1</code>, <code class="param">var2</code>). </p>

</div>
</div>
<a id="a14bc553c23b60390c291e4a67c40df4d" name="a14bc553c23b60390c291e4a67c40df4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bc553c23b60390c291e4a67c40df4d">&#9670;&#160;</a></span>operator-() <span class="overload">[1/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const BasisElement &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0096960e4dcb5c6258a38bee7c16d72e" name="a0096960e4dcb5c6258a38bee7c16d72e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0096960e4dcb5c6258a38bee7c16d72e">&#9670;&#160;</a></span>operator-() <span class="overload">[2/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const BasisElement &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab821b0c64d442826c0a991c3de361b6b" name="ab821b0c64d442826c0a991c3de361b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab821b0c64d442826c0a991c3de361b6b">&#9670;&#160;</a></span>operator-() <span class="overload">[3/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const BasisElement &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisElement &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad82a0882a250b686c193c81892f8bf34" name="ad82a0882a250b686c193c81892f8bf34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82a0882a250b686c193c81892f8bf34">&#9670;&#160;</a></span>operator-() <span class="overload">[4/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95404d48e05dca0c0c3af3ec6bf387db" name="a95404d48e05dca0c0c3af3ec6bf387db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95404d48e05dca0c0c3af3ec6bf387db">&#9670;&#160;</a></span>operator-() <span class="overload">[5/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63710a8d54f76e835b258885102859ec" name="a63710a8d54f76e835b258885102859ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63710a8d54f76e835b258885102859ec">&#9670;&#160;</a></span>operator-() <span class="overload">[6/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a887493584a26c3184345aeb2771452b2" name="a887493584a26c3184345aeb2771452b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887493584a26c3184345aeb2771452b2">&#9670;&#160;</a></span>operator-() <span class="overload">[7/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f70ed5b694fb54c450571f7e954ca64" name="a4f70ed5b694fb54c450571f7e954ca64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f70ed5b694fb54c450571f7e954ca64">&#9670;&#160;</a></span>operator-() <span class="overload">[8/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b2dcc0fc8eac4d6edf356e350128354" name="a1b2dcc0fc8eac4d6edf356e350128354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2dcc0fc8eac4d6edf356e350128354">&#9670;&#160;</a></span>operator-() <span class="overload">[9/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a25d63b978c1df701182843ce44f0ca" name="a3a25d63b978c1df701182843ce44f0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a25d63b978c1df701182843ce44f0ca">&#9670;&#160;</a></span>operator-() <span class="overload">[10/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af36c077e8377e8f6f79da19b22034a88" name="af36c077e8377e8f6f79da19b22034a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36c077e8377e8f6f79da19b22034a88">&#9670;&#160;</a></span>operator-() <span class="overload">[11/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unary minus operation for polynomial. </p>

</div>
</div>
<a id="aeee94abcf94c5c3efac678b457cd3b3a" name="aeee94abcf94c5c3efac678b457cd3b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee94abcf94c5c3efac678b457cd3b3a">&#9670;&#160;</a></span>operator-() <span class="overload">[12/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a408fb0f03f4fde816c1affebe3cb19c2" name="a408fb0f03f4fde816c1affebe3cb19c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a408fb0f03f4fde816c1affebe3cb19c2">&#9670;&#160;</a></span>operator-() <span class="overload">[13/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54bcaf5825f2f80f109635e0703018bf" name="a54bcaf5825f2f80f109635e0703018bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bcaf5825f2f80f109635e0703018bf">&#9670;&#160;</a></span>operator-() <span class="overload">[14/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c9898ab369984f945de0515f25d6ed6" name="a2c9898ab369984f945de0515f25d6ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9898ab369984f945de0515f25d6ed6">&#9670;&#160;</a></span>operator-() <span class="overload">[15/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95dd79861957477e088534110c2604a1" name="a95dd79861957477e088534110c2604a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95dd79861957477e088534110c2604a1">&#9670;&#160;</a></span>operator-() <span class="overload">[16/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d2041a414f01d6e9f106335ed5dd899" name="a4d2041a414f01d6e9f106335ed5dd899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2041a414f01d6e9f106335ed5dd899">&#9670;&#160;</a></span>operator-() <span class="overload">[17/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisElement &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af88644b55b7486916d5b86ba9fb77ac1" name="af88644b55b7486916d5b86ba9fb77ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88644b55b7486916d5b86ba9fb77ac1">&#9670;&#160;</a></span>operator-() <span class="overload">[18/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f44f4beff2210528a3ecccb58dd4804" name="a1f44f4beff2210528a3ecccb58dd4804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f44f4beff2210528a3ecccb58dd4804">&#9670;&#160;</a></span>operator-() <span class="overload">[19/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad94604e34addd7ab076028c07b2c34ab" name="ad94604e34addd7ab076028c07b2c34ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94604e34addd7ab076028c07b2c34ab">&#9670;&#160;</a></span>operator-() <span class="overload">[20/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a417daa8f767bb80ebf2b775eede4ad76" name="a417daa8f767bb80ebf2b775eede4ad76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417daa8f767bb80ebf2b775eede4ad76">&#9670;&#160;</a></span>operator-() <span class="overload">[21/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator- </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7396940e4ad4279f7e7a984305a051a" name="ac7396940e4ad4279f7e7a984305a051a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7396940e4ad4279f7e7a984305a051a">&#9670;&#160;</a></span>operator-() <span class="overload">[22/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a17ca7e584216ee1fea23c512c45bad90" name="a17ca7e584216ee1fea23c512c45bad90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ca7e584216ee1fea23c512c45bad90">&#9670;&#160;</a></span>operator-() <span class="overload">[23/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisElement &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1676f2a150914291663b452854d91130" name="a1676f2a150914291663b452854d91130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1676f2a150914291663b452854d91130">&#9670;&#160;</a></span>operator-() <span class="overload">[24/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aefd3a8bbf787fda994df54be2a27ee9a" name="aefd3a8bbf787fda994df54be2a27ee9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd3a8bbf787fda994df54be2a27ee9a">&#9670;&#160;</a></span>operator-() <span class="overload">[25/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f3c47a396ac8d468bf5f2f45e230de3" name="a3f3c47a396ac8d468bf5f2f45e230de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3c47a396ac8d468bf5f2f45e230de3">&#9670;&#160;</a></span>operator-() <span class="overload">[26/36]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a47ad706c6f9ac6d8413383d8152c4b51" name="a47ad706c6f9ac6d8413383d8152c4b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ad706c6f9ac6d8413383d8152c4b51">&#9670;&#160;</a></span>operator-() <span class="overload">[27/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad77a50d7df89fae73fa46eb7396ac3a0" name="ad77a50d7df89fae73fa46eb7396ac3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77a50d7df89fae73fa46eb7396ac3a0">&#9670;&#160;</a></span>operator-() <span class="overload">[28/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07c397de070f92d19567a8c0c73d327e" name="a07c397de070f92d19567a8c0c73d327e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c397de070f92d19567a8c0c73d327e">&#9670;&#160;</a></span>operator-() <span class="overload">[29/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e5b784ac8ef76dc1d5295d1d4d6f89a" name="a2e5b784ac8ef76dc1d5295d1d4d6f89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5b784ac8ef76dc1d5295d1d4d6f89a">&#9670;&#160;</a></span>operator-() <span class="overload">[30/36]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a22eee8b618367ee530884a25714761a4" name="a22eee8b618367ee530884a25714761a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22eee8b618367ee530884a25714761a4">&#9670;&#160;</a></span>operator-() <span class="overload">[31/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42cb7637d5591968374ac16f95d7ca68" name="a42cb7637d5591968374ac16f95d7ca68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42cb7637d5591968374ac16f95d7ca68">&#9670;&#160;</a></span>operator-() <span class="overload">[32/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67dbb91e91fae264abe9d39a6c167fe3" name="a67dbb91e91fae264abe9d39a6c167fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67dbb91e91fae264abe9d39a6c167fe3">&#9670;&#160;</a></span>operator-() <span class="overload">[33/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a084bf309d07e7c8560b89bcf3f7523a2" name="a084bf309d07e7c8560b89bcf3f7523a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084bf309d07e7c8560b89bcf3f7523a2">&#9670;&#160;</a></span>operator-() <span class="overload">[34/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24e3c65798c6801e74fa2bf071c5f589" name="a24e3c65798c6801e74fa2bf071c5f589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e3c65798c6801e74fa2bf071c5f589">&#9670;&#160;</a></span>operator-() <span class="overload">[35/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a></td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns set-minus(<code class="param">vars</code>, { <code class="param">var</code> }). </p>

</div>
</div>
<a id="ab15f6e5aa82236dcd5bfb4a310022997" name="ab15f6e5aa82236dcd5bfb4a310022997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15f6e5aa82236dcd5bfb4a310022997">&#9670;&#160;</a></span>operator-() <span class="overload">[36/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a></td>          <td class="paramname"><span class="paramname"><em>vars1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns set-minus(<code class="param">var1</code>, <code class="param">vars2</code>). </p>

</div>
</div>
<a id="a160ea247e390cafd990190196c446785" name="a160ea247e390cafd990190196c446785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160ea247e390cafd990190196c446785">&#9670;&#160;</a></span>operator-=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe694f2d15e6c4385d2f5d861099b51e" name="abe694f2d15e6c4385d2f5d861099b51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe694f2d15e6c4385d2f5d861099b51e">&#9670;&#160;</a></span>operator-=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates <code class="param">vars</code> with the result of set-minus(<code class="param">vars</code>, {<code class="param">var}</code>). </p>

</div>
</div>
<a id="a61ada8774d03a585cc10d36fc7b4b007" name="a61ada8774d03a585cc10d36fc7b4b007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ada8774d03a585cc10d36fc7b4b007">&#9670;&#160;</a></span>operator-=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vars2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates <code class="param">var1</code> with the result of set-minus(<code class="param">var1</code>, <code class="param">var2</code>). </p>

</div>
</div>
<a id="a95555bac413dee5fe5e2bd57d18493e9" name="a95555bac413dee5fe5e2bd57d18493e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95555bac413dee5fe5e2bd57d18493e9">&#9670;&#160;</a></span>operator/() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2395a6ba4fad53d7c3daa2f792269d99" name="a2395a6ba4fad53d7c3daa2f792269d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2395a6ba4fad53d7c3daa2f792269d99">&#9670;&#160;</a></span>operator/() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7366e0c649e02fd21e85f3f3748fb5fb" name="a7366e0c649e02fd21e85f3f3748fb5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7366e0c649e02fd21e85f3f3748fb5fb">&#9670;&#160;</a></span>operator/() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b72643a63257ec55447a31a7627b7dd" name="a0b72643a63257ec55447a31a7627b7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b72643a63257ec55447a31a7627b7dd">&#9670;&#160;</a></span>operator/() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the numerator of the divisor is structurally equal to zero. Note that this does not guarantee that the denominator of the result is not zero after expansion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f7de309c1619f81c94cfa294e5a9065" name="a9f7de309c1619f81c94cfa294e5a9065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7de309c1619f81c94cfa294e5a9065">&#9670;&#160;</a></span>operator/() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the numerator of the divisor is structurally equal to zero. Note that this does not guarantee that the denominator of the result is not zero after expansion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8141e1f59b8161bf1c985ecaf485b0f" name="ab8141e1f59b8161bf1c985ecaf485b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8141e1f59b8161bf1c985ecaf485b0f">&#9670;&#160;</a></span>operator/() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a65c6eae526c1f116f99fa1eba9f73a" name="a9a65c6eae526c1f116f99fa1eba9f73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a65c6eae526c1f116f99fa1eba9f73a">&#9670;&#160;</a></span>operator/() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe3877f48503b37c421e051962900121" name="afe3877f48503b37c421e051962900121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3877f48503b37c421e051962900121">&#9670;&#160;</a></span>operator/() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="tt">p / v</span>. </p>

</div>
</div>
<a id="a05b3624316b66d6957ab849780f51a5a" name="a05b3624316b66d6957ab849780f51a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b3624316b66d6957ab849780f51a5a">&#9670;&#160;</a></span>operator/() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="tt">p / v</span>. </p>

</div>
</div>
<a id="a19aa5481bd2bb69b6e4df135231e21f6" name="a19aa5481bd2bb69b6e4df135231e21f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19aa5481bd2bb69b6e4df135231e21f6">&#9670;&#160;</a></span>operator/() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f0bea506f1ba735c18adec70cc049a1" name="a6f0bea506f1ba735c18adec70cc049a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0bea506f1ba735c18adec70cc049a1">&#9670;&#160;</a></span>operator/() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the divisor is structurally equal to zero. Note that this does not guarantee that the denominator of the result is not zero after expansion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeffbde3ace1b49b7df5ec9eb9aa8f956" name="aeffbde3ace1b49b7df5ec9eb9aa8f956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeffbde3ace1b49b7df5ec9eb9aa8f956">&#9670;&#160;</a></span>operator/() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if c is 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedd63e0afe919c6474d0da57593d8d5f" name="aedd63e0afe919c6474d0da57593d8d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd63e0afe919c6474d0da57593d8d5f">&#9670;&#160;</a></span>operator/() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td>          <td class="paramname"><span class="paramname"><em>f1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the numerator of the divisor is structurally equal to zero. Note that this does not guarantee that the denominator of the result is not zero after expansion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa54e8cfb56c376f1e578784d6b68fbf1" name="aa54e8cfb56c376f1e578784d6b68fbf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54e8cfb56c376f1e578784d6b68fbf1">&#9670;&#160;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp; operator/= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd43f36981591cbe9f45910e46c041a9" name="afd43f36981591cbe9f45910e46c041a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd43f36981591cbe9f45910e46c041a9">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived, typename ScalarType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar()&lt; ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt; operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code class="param">a</code> and a scalar <code class="param">v</code> using less-than operator (&lt;). </p>
<p>That is, for all i and j, the (i, j)-th entry of <span class="tt">(a &lt; v)</span> has a symbolic formula <span class="tt">a(i, j) &lt; v</span>. </p>

</div>
</div>
<a id="a2a7547f207b1d32989acd9629fba4994" name="a2a7547f207b1d32989acd9629fba4994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7547f207b1d32989acd9629fba4994">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()&lt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt; operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;</td>          <td class="paramname"><span class="paramname"><em>a1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;</td>          <td class="paramname"><span class="paramname"><em>a2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code class="param">a1</code> and <code class="param">a2</code> using less-than operator (&lt;). </p>

</div>
</div>
<a id="ac3ae1c03a9f8e4a5dc7b4131e5a60294" name="ac3ae1c03a9f8e4a5dc7b4131e5a60294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ae1c03a9f8e4a5dc7b4131e5a60294">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()&lt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula representing element-wise comparison between two matrices <code class="param">m1</code> and <code class="param">m2</code> using less-than (&lt;) operator. </p>
<p>The following table describes the return type of <code class="param">m1</code> &lt; <code class="param">m2</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LHS \ RHS  </th><th class="markdownTableHeadNone">EM&lt;Expression&gt;  </th><th class="markdownTableHeadNone">EM&lt;Variable&gt;  </th><th class="markdownTableHeadNone">EM&lt;double&gt;  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;Expression&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EM&lt;Variable&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;double&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone">N/A  </td></tr>
</table>
<p>In the table, <span class="tt">EM</span> is a short-hand of <span class="tt">Eigen::Matrix</span>. </p>

</div>
</div>
<a id="aea9d6243717b5f82e19ace8a5d88f450" name="aea9d6243717b5f82e19ace8a5d88f450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9d6243717b5f82e19ace8a5d88f450">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a08bfc1af3d18b12aa8a994d31a2643f7" name="a08bfc1af3d18b12aa8a994d31a2643f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08bfc1af3d18b12aa8a994d31a2643f7">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType, typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType()&lt; typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt; operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code class="param">v</code> and an array <code class="param">using</code> less-than operator (&lt;). </p>
<p>That is, for all i and j, the (i, j)-th entry of <span class="tt">(v &lt; a)</span> has a symbolic formula <span class="tt">v &lt; a(i, j)</span>. </p>

</div>
</div>
<a id="a9911fd0881ffc66c0c64e8d727399237" name="a9911fd0881ffc66c0c64e8d727399237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9911fd0881ffc66c0c64e8d727399237">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91">ExpressionKind</a></td>          <td class="paramname"><span class="paramname"><em>k1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a245f75ee96839b12e22fea09c6f3ec91">ExpressionKind</a></td>          <td class="paramname"><span class="paramname"><em>k2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total ordering between ExpressionKinds. </p>

</div>
</div>
<a id="a5206a4972567789a21f4c05dbbca1bc7" name="a5206a4972567789a21f4c05dbbca1bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5206a4972567789a21f4c05dbbca1bc7">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a></td>          <td class="paramname"><span class="paramname"><em>k1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a></td>          <td class="paramname"><span class="paramname"><em>k2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0bc13bb742ac53358559066848dfa9f" name="ab0bc13bb742ac53358559066848dfa9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0bc13bb742ac53358559066848dfa9f">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated</a></b></dt><dd>Use fmt functions instead (e.g., fmt::format(), fmt::to_string(),  fmt::print()). Refer to GitHub issue #17742 for more information. <br  />
 This will be removed from Drake on or after 2026-06-01. </dd></dl>

</div>
</div>
<a id="af6ea3eaf1a7e5beed8feb1c401d51bbc" name="af6ea3eaf1a7e5beed8feb1c401d51bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ea3eaf1a7e5beed8feb1c401d51bbc">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96c90655d4fb45b63c8e1bde735e6c47" name="a96c90655d4fb45b63c8e1bde735e6c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c90655d4fb45b63c8e1bde735e6c47">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab36f2eb0e38222af36d1499d0a2f47a" name="aab36f2eb0e38222af36d1499d0a2f47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab36f2eb0e38222af36d1499d0a2f47a">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated</a></b></dt><dd>Use fmt functions instead (e.g., fmt::format(), fmt::to_string(),  fmt::print()). Refer to GitHub issue #17742 for more information. <br  />
 This will be removed from Drake on or after 2026-05-01. </dd></dl>

</div>
</div>
<a id="ad946994348eafef6d3e20ebc08bfa5d2" name="ad946994348eafef6d3e20ebc08bfa5d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad946994348eafef6d3e20ebc08bfa5d2">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated</a></b></dt><dd>Use fmt functions instead (e.g., fmt::format(), fmt::to_string(),  fmt::print()). Refer to GitHub issue #17742 for more information. <br  />
 This will be removed from Drake on or after 2026-05-01. </dd></dl>

</div>
</div>
<a id="a411e51a0c60278b06088ad1fa084e605" name="a411e51a0c60278b06088ad1fa084e605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411e51a0c60278b06088ad1fa084e605">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated</a></b></dt><dd>Use fmt functions instead (e.g., fmt::format(), fmt::to_string(),  fmt::print()). Refer to GitHub issue #17742 for more information. <br  />
 This will be removed from Drake on or after 2026-05-01. </dd></dl>

</div>
</div>
<a id="af69250c699b4b8cbcbb54d322570d175" name="af69250c699b4b8cbcbb54d322570d175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69250c699b4b8cbcbb54d322570d175">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">Variable::Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated</a></b></dt><dd>Use fmt functions instead (e.g., fmt::format(), fmt::to_string(),  fmt::print()). Refer to GitHub issue #17742 for more information. <br  />
 This will be removed from Drake on or after 2026-05-01. </dd></dl>

</div>
</div>
<a id="ad33e2289eb5f8ba9d8a286bd6e954001" name="ad33e2289eb5f8ba9d8a286bd6e954001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33e2289eb5f8ba9d8a286bd6e954001">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated</a></b></dt><dd>Use fmt functions instead (e.g., fmt::format(), fmt::to_string(),  fmt::print()). Refer to GitHub issue #17742 for more information. <br  />
 This will be removed from Drake on or after 2026-06-01. </dd></dl>

</div>
</div>
<a id="ad8ca491b4e798266df4f026a079f4418" name="ad8ca491b4e798266df4f026a079f4418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ca491b4e798266df4f026a079f4418">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_polynomial.html">ChebyshevPolynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated</a></b></dt><dd>Use fmt functions instead (e.g., fmt::format(), fmt::to_string(),  fmt::print()). Refer to GitHub issue #17742 for more information. <br  />
 This will be removed from Drake on or after 2026-06-01. </dd></dl>

</div>
</div>
<a id="ada77c9969b0422090c05636a895c0e8e" name="ada77c9969b0422090c05636a895c0e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada77c9969b0422090c05636a895c0e8e">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated</a></b></dt><dd>Use fmt functions instead (e.g., fmt::format(), fmt::to_string(),  fmt::print()). Refer to GitHub issue #17742 for more information. <br  />
 This will be removed from Drake on or after 2026-05-01. </dd></dl>

</div>
</div>
<a id="aebaa1c50ddcd18c8de9ba5ebc01f3989" name="aebaa1c50ddcd18c8de9ba5ebc01f3989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebaa1c50ddcd18c8de9ba5ebc01f3989">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated</a></b></dt><dd>Use fmt functions instead (e.g., fmt::format(), fmt::to_string(),  fmt::print()). Refer to GitHub issue #17742 for more information. <br  />
 This will be removed from Drake on or after 2026-06-01. </dd></dl>

</div>
</div>
<a id="a74f6eeef08887be237dd99f50e3efeb8" name="a74f6eeef08887be237dd99f50e3efeb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f6eeef08887be237dd99f50e3efeb8">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived, typename ScalarType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar()&lt;=ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt; operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code class="param">a</code> and a scalar <code class="param">v</code> using less-than-or-equal operator (&lt;=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <span class="tt">(a &lt;= v)</span> has a symbolic formula <span class="tt">a(i, j) &lt;= v</span>. </p>

</div>
</div>
<a id="a00e6a5930a86434ef7dd224f001a282b" name="a00e6a5930a86434ef7dd224f001a282b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e6a5930a86434ef7dd224f001a282b">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()&lt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt; operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;</td>          <td class="paramname"><span class="paramname"><em>a1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;</td>          <td class="paramname"><span class="paramname"><em>a2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code class="param">a1</code> and <code class="param">a2</code> using less-than-or-equal operator (&lt;=). </p>

</div>
</div>
<a id="a29be67079f48ecf9ed0420b7e92de59f" name="a29be67079f48ecf9ed0420b7e92de59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29be67079f48ecf9ed0420b7e92de59f">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()&lt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula representing element-wise comparison between two matrices <code class="param">m1</code> and <code class="param">m2</code> using less-than-or-equal operator (&lt;=). </p>
<p>The following table describes the return type of <code class="param">m1</code> &lt;= <code class="param">m2</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LHS \ RHS  </th><th class="markdownTableHeadNone">EM&lt;Expression&gt;  </th><th class="markdownTableHeadNone">EM&lt;Variable&gt;  </th><th class="markdownTableHeadNone">EM&lt;double&gt;  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;Expression&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EM&lt;Variable&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;double&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone">N/A  </td></tr>
</table>
<p>In the table, <span class="tt">EM</span> is a short-hand of <span class="tt">Eigen::Matrix</span>. </p>

</div>
</div>
<a id="ad91873fce901342b010a449f7952d290" name="ad91873fce901342b010a449f7952d290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91873fce901342b010a449f7952d290">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1546fbcbc705d680d1ae89a5dd5e9c1b" name="a1546fbcbc705d680d1ae89a5dd5e9c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1546fbcbc705d680d1ae89a5dd5e9c1b">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType, typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType()&lt;=typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt; operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code class="param">v</code> and an array <code class="param">using</code> less-than-or-equal operator (&lt;=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <span class="tt">(v &lt;= a)</span> has a symbolic formula <span class="tt">v &lt;= a(i, j)</span>. </p>

</div>
</div>
<a id="a4656598caa852c1ad39ea6513e8aeff6" name="a4656598caa852c1ad39ea6513e8aeff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4656598caa852c1ad39ea6513e8aeff6">&#9670;&#160;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived, typename ScalarType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar()==ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt; operator== </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code class="param">a</code> and a scalar <code class="param">v</code> using equal-to operator (==). </p>
<p>That is, for all i and j, the (i, j)-th entry of <span class="tt">(a
== v)</span> has a symbolic formula <span class="tt">a(i, j) == v</span>.</p>
<p>Here is an example using this operator overloading. </p><div class="fragment"><div class="line">Eigen::Array&lt;Variable, 2, 2&gt; a;</div>
<div class="line">a &lt;&lt; <a class="code hl_class" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>{<span class="stringliteral">&quot;x&quot;</span>}, Variable{<span class="stringliteral">&quot;y&quot;</span>},</div>
<div class="line">     Variable{<span class="stringliteral">&quot;z&quot;</span>}, <a class="code hl_class" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>{<span class="stringliteral">&quot;w&quot;</span>};</div>
<div class="line">Eigen::Array&lt;Formula, 2, 2&gt; f = (a == 3.5);</div>
<div class="line"><span class="comment">// Here f = |(x == 3.5)  (y == 3.5)|</span></div>
<div class="line"><span class="comment">//          |(z == 3.5)  (w == 3.5)|.</span></div>
<div class="ttc" id="aclassdrake_1_1symbolic_1_1_variable_html"><div class="ttname"><a href="classdrake_1_1symbolic_1_1_variable.html">drake::symbolic::Variable</a></div><div class="ttdoc">Represents a symbolic variable.</div><div class="ttdef"><b>Definition</b> variable.h:37</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a993b173875967c3a3d57757f554dfab4" name="a993b173875967c3a3d57757f554dfab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a993b173875967c3a3d57757f554dfab4">&#9670;&#160;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()==typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt; operator== </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;</td>          <td class="paramname"><span class="paramname"><em>a1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;</td>          <td class="paramname"><span class="paramname"><em>a2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise symbolic-equality of two arrays <code class="param">m1</code> and <code class="param">m2</code>. </p>
<p>The following table describes the return type of <code class="param">m1</code> == <code class="param">m2</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LHS \ RHS  </th><th class="markdownTableHeadNone">EA&lt;Expression&gt;  </th><th class="markdownTableHeadNone">EA&lt;Variable&gt;  </th><th class="markdownTableHeadNone">EA&lt;double&gt;  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EA&lt;Expression&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EA&lt;Variable&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EA&lt;double&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;  </td><td class="markdownTableBodyNone">EA&lt;bool&gt;  </td></tr>
</table>
<p>In the table, <span class="tt">EA</span> is a short-hand of <span class="tt">Eigen::Array</span>.</p>
<p>Note that this function does <em>not</em> provide operator overloading for the following case. It returns <span class="tt">Eigen::Array&lt;bool&gt;</span> and is provided by Eigen.</p>
<ul>
<li>Eigen::Array&lt;double&gt; == Eigen::Array&lt;double&gt; </li>
</ul>

</div>
</div>
<a id="a5baf7e7e983ace79d366f506103a06db" name="a5baf7e7e983ace79d366f506103a06db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5baf7e7e983ace79d366f506103a06db">&#9670;&#160;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()==typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; operator== </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula checking if two matrices <code class="param">m1</code> and <code class="param">m2</code> are equal. </p>
<p>The following table describes the return type of <code class="param">m1</code> == <code class="param">m2</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LHS \ RHS  </th><th class="markdownTableHeadNone">EM&lt;Expression&gt;  </th><th class="markdownTableHeadNone">EM&lt;Variable&gt;  </th><th class="markdownTableHeadNone">EM&lt;double&gt;  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;Expression&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EM&lt;Variable&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;double&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone">bool  </td></tr>
</table>
<p>In the table, <span class="tt">EM</span> is a short-hand of <span class="tt">Eigen::Matrix</span>.</p>
<p>Note that this function does <em>not</em> provide operator overloading for the following case. It returns <span class="tt">bool</span> and is provided by Eigen.</p>
<ul>
<li>Eigen::Matrix&lt;double&gt; == Eigen::Matrix&lt;double&gt;</li>
</ul>
<p>Note that this method returns a conjunctive formula which keeps its conjuncts as <span class="tt">std::set&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>&gt;</span> internally. This set is ordered by <span class="tt"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html#abd2677c76ddb28c10321b8178cfc6292" title="Checks lexicographical ordering between this and e.">Formula::Less</a></span> and this ordering can be <em>different</em> from the one in inputs. Also, any duplicated formulas are removed in construction. Please check the following example.</p>
<div class="fragment"><div class="line"><span class="comment">// set up v1 = [y x y] and v2 = [1 2 1]</span></div>
<div class="line"><a class="code hl_typedef" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX&lt;Expression&gt;</a> v1{3};</div>
<div class="line"><a class="code hl_typedef" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX&lt;Expression&gt;</a> v2{3};</div>
<div class="line"><span class="keyword">const</span> Variable x{<span class="stringliteral">&quot;x&quot;</span>};</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> y{<span class="stringliteral">&quot;y&quot;</span>};</div>
<div class="line">v1 &lt;&lt; y, x, y;</div>
<div class="line">v2 &lt;&lt; 1, 2, 1;</div>
<div class="line"><span class="comment">// Here v1_eq_v2 = ((x = 2) ∧ (y = 1))</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> v1_eq_v2{v1 == v2};</div>
<div class="line"><span class="keyword">const</span> std::set&lt;Formula&gt; conjuncts{<a class="code hl_function" href="#a5a51076f5f4ab9497965268ceb34e82c">get_operands</a>(v1_eq_v2)};</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&amp; f : conjuncts) {</div>
<div class="line">  std::cerr &lt;&lt; f &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"><span class="comment">// The outcome of the above loop is:</span></div>
<div class="line">(x = 2)</div>
<div class="line">(y = 1)</div>
<div class="ttc" id="aclassdrake_1_1symbolic_1_1_formula_html"><div class="ttname"><a href="classdrake_1_1symbolic_1_1_formula.html">drake::symbolic::Formula</a></div><div class="ttdoc">Represents a symbolic form of a first-order logic formula.</div><div class="ttdef"><b>Definition</b> formula.h:114</div></div>
<div class="ttc" id="anamespacedrake_1_1symbolic_html_a5a51076f5f4ab9497965268ceb34e82c"><div class="ttname"><a href="#a5a51076f5f4ab9497965268ceb34e82c">drake::symbolic::get_operands</a></div><div class="ttdeci">const std::set&lt; Formula &gt; &amp; get_operands(const Formula &amp;f)</div><div class="ttdoc">Returns the set of formulas in a n-ary formula f.</div></div>
<div class="ttc" id="anamespacedrake_html_a77dd228fb4dd66a2c17dd3f7f38ffd85"><div class="ttname"><a href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">drake::VectorX</a></div><div class="ttdeci">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; VectorX</div><div class="ttdoc">A column vector of any size, templated on scalar type.</div><div class="ttdef"><b>Definition</b> eigen_types.h:67</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae28c71d4bee52bfa5e4928605a4ee87d" name="ae28c71d4bee52bfa5e4928605a4ee87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28c71d4bee52bfa5e4928605a4ee87d">&#9670;&#160;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5764ce1fcaf60cd695e106397ea7bb7" name="ac5764ce1fcaf60cd695e106397ea7bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5764ce1fcaf60cd695e106397ea7bb7">&#9670;&#160;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType, typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType()==typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt; operator== </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code class="param">v</code> and an array <code class="param">using</code> equal-to operator (==). </p>
<p>That is, for all i and j, the (i, j)-th entry of <span class="tt">(v == a)</span> has a symbolic formula <span class="tt">v == a(i, j)</span>.</p>
<p>Here is an example using this operator overloading. </p><div class="fragment"><div class="line">Eigen::Array&lt;Variable, 2, 2&gt; a;</div>
<div class="line">a &lt;&lt; <a class="code hl_class" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>{<span class="stringliteral">&quot;x&quot;</span>}, Variable{<span class="stringliteral">&quot;y&quot;</span>},</div>
<div class="line">     Variable{<span class="stringliteral">&quot;z&quot;</span>}, <a class="code hl_class" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>{<span class="stringliteral">&quot;w&quot;</span>};</div>
<div class="line">Eigen::Array&lt;Formula, 2, 2&gt; f = (3.5 == a);</div>
<div class="line"><span class="comment">// Here f = |(3.5 == x)  (3.5 == y)|</span></div>
<div class="line"><span class="comment">//          |(3.5 == z)  (3.5 == w)|.</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a39121e92f332d2ca0dc6e42e6f9344a0" name="a39121e92f332d2ca0dc6e42e6f9344a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39121e92f332d2ca0dc6e42e6f9344a0">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived, typename ScalarType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar() &gt; ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt; operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code class="param">a</code> and a scalar <code class="param">v</code> using greater-than operator (&gt;). </p>
<p>That is, for all i and j, the (i, j)-th entry of <span class="tt">(a &gt; v)</span> has a symbolic formula <span class="tt">a(i, j) &gt; v</span>. </p>

</div>
</div>
<a id="add8009d78d933826d765faf7ae3d112f" name="add8009d78d933826d765faf7ae3d112f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8009d78d933826d765faf7ae3d112f">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() &gt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt; operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;</td>          <td class="paramname"><span class="paramname"><em>a1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;</td>          <td class="paramname"><span class="paramname"><em>a2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code class="param">a1</code> and <code class="param">a2</code> using greater-than operator (&gt;). </p>

</div>
</div>
<a id="ae9dbd563dfe489f43f1f0754c4a04e27" name="ae9dbd563dfe489f43f1f0754c4a04e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9dbd563dfe489f43f1f0754c4a04e27">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() &gt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula representing element-wise comparison between two matrices <code class="param">m1</code> and <code class="param">m2</code> using greater-than operator (&gt;). </p>
<p>The following table describes the return type of <code class="param">m1</code> &gt; <code class="param">m2</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LHS \ RHS  </th><th class="markdownTableHeadNone">EM&lt;Expression&gt;  </th><th class="markdownTableHeadNone">EM&lt;Variable&gt;  </th><th class="markdownTableHeadNone">EM&lt;double&gt;  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;Expression&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EM&lt;Variable&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;double&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone">N/A  </td></tr>
</table>
<p>In the table, <span class="tt">EM</span> is a short-hand of <span class="tt">Eigen::Matrix</span>. </p>

</div>
</div>
<a id="a047255afbaefd1684cccb967c2ceb1b7" name="a047255afbaefd1684cccb967c2ceb1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047255afbaefd1684cccb967c2ceb1b7">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d51445b9c7e7e2292fcfebd038b1738" name="a7d51445b9c7e7e2292fcfebd038b1738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d51445b9c7e7e2292fcfebd038b1738">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType, typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType() &gt; typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt; operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code class="param">v</code> and an array <code class="param">using</code> less-than operator (&lt;) instead of greater-than operator (&gt;). </p>
<p>That is, for all i and j, the (i, j)-th entry of <span class="tt">(v &gt; a)</span> has a symbolic formula <span class="tt">a(i,
j) &lt; v</span>.</p>
<p>Note that given <span class="tt">v &gt; a</span>, this methods returns the result of <span class="tt">a &lt; v</span>. First of all, this formulation is mathematically equivalent to the original formulation. We implement this method in this way to be consistent with Eigen's semantics. See the definition of <span class="tt">EIGEN_MAKE_CWISE_COMP_R_OP</span> in ArrayCwiseBinaryOps.h file in Eigen. </p>

</div>
</div>
<a id="ac9c625401bc6fa407a54cb6004b8299f" name="ac9c625401bc6fa407a54cb6004b8299f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c625401bc6fa407a54cb6004b8299f">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived, typename ScalarType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar() &gt;=ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt; operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code class="param">a</code> and a scalar <code class="param">v</code> using greater-than-or-equal operator (&gt;=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <span class="tt">(a &gt;= v)</span> has a symbolic formula <span class="tt">a(i, j) &gt;= v</span>. </p>

</div>
</div>
<a id="a2fd72f8875df01ff36fdedd9371e8db0" name="a2fd72f8875df01ff36fdedd9371e8db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd72f8875df01ff36fdedd9371e8db0">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() &gt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt; operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;</td>          <td class="paramname"><span class="paramname"><em>a1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;</td>          <td class="paramname"><span class="paramname"><em>a2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code class="param">a1</code> and <code class="param">a2</code> using greater-than-or-equal operator (&gt;=). </p>

</div>
</div>
<a id="a59b73c7509dfecd799346d10b030bedd" name="a59b73c7509dfecd799346d10b030bedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b73c7509dfecd799346d10b030bedd">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() &gt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula representing element-wise comparison between two matrices <code class="param">m1</code> and <code class="param">m2</code> using greater-than-or-equal operator (&gt;=). </p>
<p>The following table describes the return type of <code class="param">m1</code> &gt;= <code class="param">m2</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LHS \ RHS  </th><th class="markdownTableHeadNone">EM&lt;Expression&gt;  </th><th class="markdownTableHeadNone">EM&lt;Variable&gt;  </th><th class="markdownTableHeadNone">EM&lt;double&gt;  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;Expression&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EM&lt;Variable&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;double&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone">N/A  </td></tr>
</table>
<p>In the table, <span class="tt">EM</span> is a short-hand of <span class="tt">Eigen::Matrix</span>. </p>

</div>
</div>
<a id="ac8f5b0df2a3fecea9d23b24475c7fdca" name="ac8f5b0df2a3fecea9d23b24475c7fdca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f5b0df2a3fecea9d23b24475c7fdca">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f190c2b8351007ad0ebf41a52d03472" name="a6f190c2b8351007ad0ebf41a52d03472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f190c2b8351007ad0ebf41a52d03472">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType, typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType() &gt;=typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt; operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code class="param">v</code> and an array <code class="param">using</code> less-than-or-equal operator (&lt;=) instead of greater-than-or-equal operator (&gt;=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <span class="tt">(v &gt;= a)</span> has a symbolic formula <span class="tt">a(i, j) &lt;= v</span>.</p>
<p>Note that given <span class="tt">v &gt;= a</span>, this methods returns the result of <span class="tt">a &lt;= v</span>. First of all, this formulation is mathematically equivalent to the original formulation. We implement this method in this way to be consistent with Eigen's semantics. See the definition of <span class="tt">EIGEN_MAKE_CWISE_COMP_R_OP</span> in ArrayCwiseBinaryOps.h file in Eigen. </p>

</div>
</div>
<a id="af301dd903e8b79a8584fa3ed0fb3708a" name="af301dd903e8b79a8584fa3ed0fb3708a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af301dd903e8b79a8584fa3ed0fb3708a">&#9670;&#160;</a></span>operator||() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd02ba28125fcb30762312b0361e0790" name="afd02ba28125fcb30762312b0361e0790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd02ba28125fcb30762312b0361e0790">&#9670;&#160;</a></span>operator||() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b37f14ce7a17532970ad74b4182267d" name="a1b37f14ce7a17532970ad74b4182267d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b37f14ce7a17532970ad74b4182267d">&#9670;&#160;</a></span>operator||() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09c7a845583db868b2d30a66c2616397" name="a09c7a845583db868b2d30a66c2616397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c7a845583db868b2d30a66c2616397">&#9670;&#160;</a></span>operator||() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8fafcceed185abdb6726cbaf4ff3be3" name="af8fafcceed185abdb6726cbaf4ff3be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8fafcceed185abdb6726cbaf4ff3be3">&#9670;&#160;</a></span>PopulateRandomVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> PopulateRandomVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a></td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>variables</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *</td>          <td class="paramname"><span class="paramname"><em>random_generator</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the environment <code class="param">env</code> by sampling values for the unassigned random variables in <code class="param">variables</code> using <code class="param">random_generator</code>. </p>

</div>
</div>
<a id="a525eb4ca416c6055765da5ba992b1c9c" name="a525eb4ca416c6055765da5ba992b1c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525eb4ca416c6055765da5ba992b1c9c">&#9670;&#160;</a></span>positive_semidefinite() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula constraining <code class="param">m</code> to be a positive-semidefinite matrix. </p>
<p>By definition, a symmetric matrix <code class="param">m</code> is positive-semidefinte if xᵀ m x ≥ 0 for all vector x ∈ ℝⁿ.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code class="param">m</code> is not symmetric.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method checks if <code class="param">m</code> is symmetric, which can be costly. If you want to avoid it, please consider using <span class="tt"><a class="el" href="#a525eb4ca416c6055765da5ba992b1c9c" title="Returns a symbolic formula constraining m to be a positive-semidefinite matrix.">positive_semidefinite</a>(m.triangularView&lt;Eigen::Lower&gt;())</span> or <span class="tt"><a class="el" href="#a525eb4ca416c6055765da5ba992b1c9c" title="Returns a symbolic formula constraining m to be a positive-semidefinite matrix.">positive_semidefinite</a>(m.triangularView&lt;Eigen::Upper&gt;())</span> instead of <span class="tt">positive_semidefinite(m)</span>. </dd></dl>

</div>
</div>
<a id="a073573483e330bf1779f5079b2e88d8c" name="a073573483e330bf1779f5079b2e88d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073573483e330bf1779f5079b2e88d8c">&#9670;&#160;</a></span>positive_semidefinite() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const Eigen::TriangularView&lt; Derived, Eigen::Lower &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>l</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs and returns a symbolic positive-semidefinite formula from a lower triangular-view <code class="param">l</code>. </p>
<p>See the following code snippet.</p>
<div class="fragment"><div class="line">Eigen::Matrix&lt;Expression, 2, 2&gt; m;</div>
<div class="line">m &lt;&lt; 1.0, 2.0,</div>
<div class="line">     3.0, 4.0;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> psd{<a class="code hl_function" href="#a525eb4ca416c6055765da5ba992b1c9c">positive_semidefinite</a>(m.triangularView&lt;Eigen::Lower&gt;())};</div>
<div class="line"><span class="comment">// psd includes [1.0 3.0]</span></div>
<div class="line"><span class="comment">//              [3.0 4.0].</span></div>
<div class="ttc" id="anamespacedrake_1_1symbolic_html_a525eb4ca416c6055765da5ba992b1c9c"><div class="ttname"><a href="#a525eb4ca416c6055765da5ba992b1c9c">drake::symbolic::positive_semidefinite</a></div><div class="ttdeci">Formula positive_semidefinite(const Eigen::Ref&lt; const MatrixX&lt; Expression &gt; &gt; &amp;m)</div><div class="ttdoc">Returns a symbolic formula constraining m to be a positive-semidefinite matrix.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a79e5b283a437914a863d9f4cde2d8fdd" name="a79e5b283a437914a863d9f4cde2d8fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e5b283a437914a863d9f4cde2d8fdd">&#9670;&#160;</a></span>positive_semidefinite() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const Eigen::TriangularView&lt; Derived, Eigen::Upper &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs and returns a symbolic positive-semidefinite formula from an upper triangular-view <code class="param">u</code>. </p>
<p>See the following code snippet.</p>
<div class="fragment"><div class="line">Eigen::Matrix&lt;Expression, 2, 2&gt; m;</div>
<div class="line">m &lt;&lt; 1.0, 2.0,</div>
<div class="line">     3.0, 4.0;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> psd{<a class="code hl_function" href="#a525eb4ca416c6055765da5ba992b1c9c">positive_semidefinite</a>(m.triangularView&lt;Eigen::Upper&gt;())};</div>
<div class="line"><span class="comment">// psd includes [1.0 2.0]</span></div>
<div class="line"><span class="comment">//              [2.0 4.0].</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab7294a6a837aa476fe079c9d5596f373" name="ab7294a6a837aa476fe079c9d5596f373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7294a6a837aa476fe079c9d5596f373">&#9670;&#160;</a></span>positive_semidefinite() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::UpLoType</td>          <td class="paramname"><span class="paramname"><em>mode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs and returns a symbolic positive-semidefinite formula from <code class="param">m</code>. </p>
<p>If <code class="param">mode</code> is Eigen::Lower, it's using the lower-triangular part of <code class="param">m</code> to construct a positive-semidefinite formula. If <code class="param">mode</code> is Eigen::Upper, the upper-triangular part of <code class="param">m</code> is used. It throws std::exception if <code class="param">has</code> other values. See the following code snippet.</p>
<div class="fragment"><div class="line">Eigen::Matrix&lt;Expression, 2, 2&gt; m;</div>
<div class="line">m &lt;&lt; 1.0, 2.0,</div>
<div class="line">     3.0, 4.0;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> psd_l{<a class="code hl_function" href="#a525eb4ca416c6055765da5ba992b1c9c">positive_semidefinite</a>(m, Eigen::Lower)};</div>
<div class="line"><span class="comment">// psd_l includes [1.0 3.0]</span></div>
<div class="line"><span class="comment">//                [3.0 4.0].</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> Formula psd_u{<a class="code hl_function" href="#a525eb4ca416c6055765da5ba992b1c9c">positive_semidefinite</a>(m, Eigen::Upper)};</div>
<div class="line"><span class="comment">// psd_u includes [1.0 2.0]</span></div>
<div class="line"><span class="comment">//                [2.0 4.0].</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa57efef61100945c693ecb05dadf6dcf" name="aa57efef61100945c693ecb05dadf6dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57efef61100945c693ecb05dadf6dcf">&#9670;&#160;</a></span>pow() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa790991ea69175051e7324d12302ad52" name="aa790991ea69175051e7324d12302ad52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa790991ea69175051e7324d12302ad52">&#9670;&#160;</a></span>pow() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab1a5d6781b80333555bde1ed59a38477">GenericPolynomialEnable</a>&lt; BasisElement &gt; pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns polynomial <code class="param">raised</code> to <code class="param">n</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base polynomial. </td></tr>
    <tr><td class="paramname">n</td><td>The exponent of the power. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>n&gt;=0. </dd></dl>

</div>
</div>
<a id="a2996d1aeb389e57074bef357b2db3585" name="a2996d1aeb389e57074bef357b2db3585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2996d1aeb389e57074bef357b2db3585">&#9670;&#160;</a></span>pow() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns polynomial <span class="tt">p</span> raised to <span class="tt">n</span>. </p>

</div>
</div>
<a id="a1689f9845acfae35173fede790537df9" name="a1689f9845acfae35173fede790537df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1689f9845acfae35173fede790537df9">&#9670;&#160;</a></span>pow() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the rational function <code class="param">f</code> raised to <code class="param">n</code>. </p>
<p>If n is positive, (f/g)ⁿ = fⁿ / gⁿ; If n is negative, (f/g)ⁿ = g⁻ⁿ / f⁻ⁿ; (f/g)⁰ = 1 / 1. </p>

</div>
</div>
<a id="ad9fccbdfb814f10727e3b23ef0b6a20f" name="ad9fccbdfb814f10727e3b23ef0b6a20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9fccbdfb814f10727e3b23ef0b6a20f">&#9670;&#160;</a></span>pow() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="tt">m</span> raised to <span class="tt">p</span>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">p</span> is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c35c520e88da642e19a0a30c332528f" name="a0c35c520e88da642e19a0a30c332528f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c35c520e88da642e19a0a30c332528f">&#9670;&#160;</a></span>pow() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a>, double &gt; pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code class="param">m</code> raised to <code class="param">p</code>. </p>
<dl class="section note"><dt>Note</dt><dd>that we return a map from the monomial power to its coefficient. This map has size 1, and the coefficient is also 1. We return a map instead of the <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html" title="MonomialBasisElement represents a monomial, a product of powers of variables with non-negative intege...">MonomialBasisElement</a> directly, because we want <a class="el" href="#aa57efef61100945c693ecb05dadf6dcf">pow()</a> to have the same return signature as other <a class="el" href="classdrake_1_1symbolic_1_1_polynomial_basis_element.html" title="Each polynomial p(x) can be written as a linear combination of its basis elements p(x) = ∑ᵢ cᵢ * ϕᵢ(x...">PolynomialBasisElement</a>. For example, the power of a <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html" title="ChebyshevBasisElement represents an element of Chebyshev polynomial basis, written as the product of ...">ChebyshevBasisElement</a> object is a weighted sum of <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html" title="ChebyshevBasisElement represents an element of Chebyshev polynomial basis, written as the product of ...">ChebyshevBasisElement</a> objects. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code class="param">p</code> is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6940f8db0a8eb87213dfb7416e13699" name="ac6940f8db0a8eb87213dfb7416e13699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6940f8db0a8eb87213dfb7416e13699">&#9670;&#160;</a></span>ReplaceBilinearTerms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> ReplaceBilinearTerms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>W</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all the bilinear product terms in the expression <span class="tt">e</span>, with the corresponding terms in <span class="tt">W</span>, where <span class="tt">W</span> represents the matrix x * yᵀ, such that after replacement, <span class="tt">e</span> does not have bilinear terms involving <span class="tt">x</span> and <span class="tt">y</span>. </p>
<p>For example, if e = x(0)*y(0) + 2 * x(0)*y(1) + x(1) * y(1) + 3 * x(1), <span class="tt">e</span> has bilinear terms x(0)*y(0), x(0) * y(1) and x(2) * y(1), if we call ReplaceBilinearTerms(e, x, y, W) where W(i, j) represent the term x(i) * y(j), then this function returns W(0, 0) + 2 * W(0, 1) + W(1, 1) + 3 * x(1). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>An expression potentially contains bilinear products between x and y. </td></tr>
    <tr><td class="paramname">x</td><td>The bilinear product between <span class="tt">x</span> and <span class="tt">y</span> will be replaced by the corresponding term in <span class="tt">W</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">x</span> contains duplicate entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>The bilinear product between <span class="tt">x</span> and <span class="tt">y</span> will be replaced by the corresponding term in <span class="tt">W</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">y</span> contains duplicate entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">W</td><td>Bilinear product term x(i) * y(j) will be replaced by W(i, j). If W(i,j) is not a single variable, but an expression, then this expression cannot contain a variable in either x or y. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception,if</td><td>W(i, j) is not a single variable, and also contains a variable in x or y. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>W.rows() == x.rows() and W.cols() == y.rows(). </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The symbolic expression after replacing x(i) * y(j) with W(i, j). </dd></dl>

</div>
</div>
<a id="af3cd13d5472028f31c2e70f1b0e08b5d" name="af3cd13d5472028f31c2e70f1b0e08b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cd13d5472028f31c2e70f1b0e08b5d">&#9670;&#160;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5f5c9f26be9d9eef2784073ac8075e0" name="aa5f5c9f26be9d9eef2784073ac8075e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f5c9f26be9d9eef2784073ac8075e0">&#9670;&#160;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79e1b5d9aadd56991632f40804d4bf93" name="a79e1b5d9aadd56991632f40804d4bf93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e1b5d9aadd56991632f40804d4bf93">&#9670;&#160;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42493d53cbbe01bee01850904587aff4" name="a42493d53cbbe01bee01850904587aff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42493d53cbbe01bee01850904587aff4">&#9670;&#160;</a></span>Substitute() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Derived &gt; Substitute </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a13c5d9eccfc9643fdd5764d6e72b8faf">SinCosSubstitution</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>subs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix version of sin/cos substitution. </p>

</div>
</div>
<a id="a658c0fc2151b55cdcce0d1375890f6a3" name="a658c0fc2151b55cdcce0d1375890f6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658c0fc2151b55cdcce0d1375890f6a3">&#9670;&#160;</a></span>Substitute() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Derived &gt; Substitute </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#acbfe43d34e6c71c503d4de11da53bbb7">Substitution</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>subst</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutes a symbolic matrix <code class="param">m</code> using a given substitution <code class="param">subst</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>a matrix of symbolic expressions whose size is the size of <code class="param">m</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if NaN is detected during substitution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5081dc3c7c801e707310141c8944f15" name="aa5081dc3c7c801e707310141c8944f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5081dc3c7c801e707310141c8944f15">&#9670;&#160;</a></span>Substitute() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Derived &gt; Substitute </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutes <code class="param">var</code> with <code class="param">e</code> in a symbolic matrix <code class="param">m</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>a matrix of symbolic expressions whose size is the size of <code class="param">m</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if NaN is detected during substitution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c07a8bfb2806c62d5dccd3e5b024786" name="a6c07a8bfb2806c62d5dccd3e5b024786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c07a8bfb2806c62d5dccd3e5b024786">&#9670;&#160;</a></span>Substitute() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> Substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a13c5d9eccfc9643fdd5764d6e72b8faf">SinCosSubstitution</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>subs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a substitution map q =&gt; {s, c}, substitutes instances of sin(q) and cos(q) in <span class="tt">e</span> with <span class="tt">s</span> and <span class="tt">c</span>, with partial support for trigonometric expansions. </p>
<p>For instance, </p><pre class="fragment">  Variable x{"x"}, y{"y"};
  Variable sx{"sx"}, cx{"cx"}, sy{"sy"}, cy{"cy"};
  SinCosSubstitution subs;
  subs.emplace(x, SinCos(sx, cx));
  subs.emplace(y, SinCos(sy, cy));
  Expression e = Substitute(x * sin(x + y), subs);
</pre><p> will result in the expression <span class="tt">x * (sx*cy + cx*sy)</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subs</td><td>When set to one of the half_angle options, then the same workflow replaces instances of sin(q/2) and cos(q/2) in <span class="tt">e</span> will be replaced with <span class="tt">s</span>, and <span class="tt">c</span>. <br  />
 <em class="arg">Default:</em> false.</td></tr>
  </table>
  </dd>
</dl>
<p>The half-angle representation is more natural in many analysis computations for robots, for instance: <a href="https://underactuated.csail.mit.edu/lyapunov.html#trig_quadratic">https://underactuated.csail.mit.edu/lyapunov.html#trig_quadratic</a></p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if a trigonometric function is not a trigonometric polynomial in <span class="tt">q</span> or if the <span class="tt">e</span> requires a trigonometric expansion that not supported yet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adda4247e60672d71b861c7b426b50ae4" name="adda4247e60672d71b861c7b426b50ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda4247e60672d71b861c7b426b50ae4">&#9670;&#160;</a></span>SubstituteStereographicProjection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">symbolic::RationalFunction</a> SubstituteStereographicProjection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structdrake_1_1symbolic_1_1_sin_cos.html">SinCos</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sin_cos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitutes the variables representing sine and cosine functions with their stereographic projection. </p>
<p>We replace cosθᵢ with (1-tᵢ²)/(1+tᵢ²), and sinθᵢ with 2tᵢ/(1+tᵢ²), and get a rational polynomial. The indeterminates of this rational polynomial are t together with the indeterminates in <span class="tt">e</span> that are not cosθ or sinθ. If the input expression doesn't contain the sine and cosine functions, then the returned rational has denominator being 1. Notice that the indeterminates of <span class="tt">e</span> can include variables other than cosθ and sinθ, and we impose no requirements on these variables that are not cosθ or sinθ.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The symbolic polynomial to be substituted. </td></tr>
    <tr><td class="paramname">sin_cos</td><td>sin_cos(i) is the pair of variables (sᵢ, cᵢ), (where sᵢ=sinθᵢ, cᵢ=cosθᵢ) as documented above. </td></tr>
    <tr><td class="paramname">t</td><td>New variables to express cos and sin as rationals of t. tᵢ = tan(θᵢ/2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>t.rows() == sin_cos.size() </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>e_rational The rational polynomial of e after replacement. The indeterminates of the polynomials are <span class="tt">t</span> together with the indeterminates in <span class="tt">e</span> that are not cosθ or sinθ. Example <pre class="fragment">* std::vector&lt;SinCos&gt; sin_cos;
* sin_cos.emplace_back(symbolic::Variable("s0"), symbolic::Variable("c0"));
* sin_cos.emplace_back(symbolic::Variable("s1"), symbolic::Variable("c1"));
* Vector2&lt;symbolic::Variable&gt; t(symbolic::Variable("t0"),
*                               symbolic::Variable("t1"));
* const auto e_rational =
* SubstituteStereographicProjection(t(0) * sin_cos[0].s*sin_cos[1].c + 1,
*                                   sin_cos, t);
* // e_rational should be
* // (2*t0*t0*(1-t1*t1) + (1+t0*t0)*(1+t1*t1))
* // --------------------------------------------
* //        ((1+t0*t0)*(1+t1*t1))
* </pre> </dd></dl>

</div>
</div>
<a id="ac36260fe42c812627ad0979214777e5b" name="ac36260fe42c812627ad0979214777e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36260fe42c812627ad0979214777e5b">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a734f5b457c5a0b898ab8b6f247f0ce76" name="a734f5b457c5a0b898ab8b6f247f0ce76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734f5b457c5a0b898ab8b6f247f0ce76">&#9670;&#160;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae96194d93ad39bcb2b7ed22891f44ec7" name="ae96194d93ad39bcb2b7ed22891f44ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96194d93ad39bcb2b7ed22891f44ec7">&#9670;&#160;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd176811046c1f4fab6d56404b270d66" name="abd176811046c1f4fab6d56404b270d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd176811046c1f4fab6d56404b270d66">&#9670;&#160;</a></span>TaylorExpand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> TaylorExpand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Taylor series expansion of <span class="tt">f</span> around <span class="tt">a</span> of order <span class="tt">order</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Symbolic expression to approximate using Taylor series expansion. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Symbolic environment which specifies the point of approximation. If a partial environment is provided, the unspecified variables are treated as symbolic variables (e.g. decision variable). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Positive integer which specifies the maximum order of the resulting polynomial approximating <span class="tt">f</span> around <span class="tt">a</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ad8506492b71ef35438b982222fe7a2" name="a7ad8506492b71ef35438b982222fe7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad8506492b71ef35438b982222fe7a2">&#9670;&#160;</a></span>to_conjunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_and.html">FormulaAnd</a> &gt; to_conjunction </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaAnd&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_conjunction(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="aedf1aeb7366fd71f0a1e453059befe10" name="aedf1aeb7366fd71f0a1e453059befe10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf1aeb7366fd71f0a1e453059befe10">&#9670;&#160;</a></span>to_disjunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_or.html">FormulaOr</a> &gt; to_disjunction </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaOr&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_disjunction(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a114b828a560f66f99ad8c007c7fe8a87" name="a114b828a560f66f99ad8c007c7fe8a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114b828a560f66f99ad8c007c7fe8a87">&#9670;&#160;</a></span>to_equal_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_eq.html">FormulaEq</a> &gt; to_equal_to </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaEq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_equal_to(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a2bbf53a99973d5ba527ae4a7ea4931c7" name="a2bbf53a99973d5ba527ae4a7ea4931c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bbf53a99973d5ba527ae4a7ea4931c7">&#9670;&#160;</a></span>to_false()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_false.html">FormulaFalse</a> &gt; to_false </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaFalse&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_false(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a128bda6d0407c2509719a983fbb14622" name="a128bda6d0407c2509719a983fbb14622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128bda6d0407c2509719a983fbb14622">&#9670;&#160;</a></span>to_forall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_forall.html">FormulaForall</a> &gt; to_forall </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaForall&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_forall(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="ac2a2dda8cb2b922f953d359f4036e3d8" name="ac2a2dda8cb2b922f953d359f4036e3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a2dda8cb2b922f953d359f4036e3d8">&#9670;&#160;</a></span>to_greater_than()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_gt.html">FormulaGt</a> &gt; to_greater_than </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaGt&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_greater_than(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a7771171eaf02f03dd1ba8dedecb47920" name="a7771171eaf02f03dd1ba8dedecb47920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7771171eaf02f03dd1ba8dedecb47920">&#9670;&#160;</a></span>to_greater_than_or_equal_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_geq.html">FormulaGeq</a> &gt; to_greater_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaGeq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_greater_than_or_equal_to(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a68b7fb17c13137d8fe71c9afead52d0f" name="a68b7fb17c13137d8fe71c9afead52d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b7fb17c13137d8fe71c9afead52d0f">&#9670;&#160;</a></span>to_isnan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_isnan.html">FormulaIsnan</a> &gt; to_isnan </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaIsnan&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_isnan(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="ab3413a434f3062f2fb166447ab2a5957" name="ab3413a434f3062f2fb166447ab2a5957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3413a434f3062f2fb166447ab2a5957">&#9670;&#160;</a></span>to_less_than()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_lt.html">FormulaLt</a> &gt; to_less_than </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaLt&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_less_than(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="aed7bae580456c9c97c66fde521f9ba4b" name="aed7bae580456c9c97c66fde521f9ba4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed7bae580456c9c97c66fde521f9ba4b">&#9670;&#160;</a></span>to_less_than_or_equal_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_leq.html">FormulaLeq</a> &gt; to_less_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaLeq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_less_than_or_equal_to(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="ab743717efe7d701eec6cf5e6bf624195" name="ab743717efe7d701eec6cf5e6bf624195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab743717efe7d701eec6cf5e6bf624195">&#9670;&#160;</a></span>to_nary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_nary_formula_cell.html">NaryFormulaCell</a> &gt; to_nary </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const NaryFormulaCell&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_nary(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="af9ce9d7c42b2425a69e80351df215726" name="af9ce9d7c42b2425a69e80351df215726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ce9d7c42b2425a69e80351df215726">&#9670;&#160;</a></span>to_negation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_not.html">FormulaNot</a> &gt; to_negation </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaNot&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_negation(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a7c497ffa47a786ac3368318ced96bf59" name="a7c497ffa47a786ac3368318ced96bf59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c497ffa47a786ac3368318ced96bf59">&#9670;&#160;</a></span>to_not_equal_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_neq.html">FormulaNeq</a> &gt; to_not_equal_to </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaNeq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_not_equal_to(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="ac61b44814f737e4b79d59fe7fa448495" name="ac61b44814f737e4b79d59fe7fa448495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61b44814f737e4b79d59fe7fa448495">&#9670;&#160;</a></span>to_positive_semidefinite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_positive_semidefinite.html">FormulaPositiveSemidefinite</a> &gt; to_positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaPositiveSemidefinite&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_positive_semidefinite(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a35d0b8206340d13c1a3c2fd3108ad6f5" name="a35d0b8206340d13c1a3c2fd3108ad6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d0b8206340d13c1a3c2fd3108ad6f5">&#9670;&#160;</a></span>to_relational()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_relational_formula_cell.html">RelationalFormulaCell</a> &gt; to_relational </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const RelationalFormulaCell&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_relational(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a84f10ab6930f1ff4b45b06ca3fcd195f" name="a84f10ab6930f1ff4b45b06ca3fcd195f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f10ab6930f1ff4b45b06ca3fcd195f">&#9670;&#160;</a></span>to_string() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a86cb7ce14b898914868a96cf815611fb" name="a86cb7ce14b898914868a96cf815611fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86cb7ce14b898914868a96cf815611fb">&#9670;&#160;</a></span>to_string() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_polynomial.html">ChebyshevPolynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a36547d6c95341875bc899be1bd1c27d1" name="a36547d6c95341875bc899be1bd1c27d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36547d6c95341875bc899be1bd1c27d1">&#9670;&#160;</a></span>to_string() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3dc291b1ebd331cf320000abb9817cc" name="af3dc291b1ebd331cf320000abb9817cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3dc291b1ebd331cf320000abb9817cc">&#9670;&#160;</a></span>to_string() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3bc94e9465444b70978c2250c37722f5" name="a3bc94e9465444b70978c2250c37722f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc94e9465444b70978c2250c37722f5">&#9670;&#160;</a></span>to_string() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aefc48865f4a78fceaa3527e94d420bdb" name="aefc48865f4a78fceaa3527e94d420bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc48865f4a78fceaa3527e94d420bdb">&#9670;&#160;</a></span>to_string() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac163e37c2a6109a9a469be234a3382d2" name="ac163e37c2a6109a9a469be234a3382d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac163e37c2a6109a9a469be234a3382d2">&#9670;&#160;</a></span>to_string() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">Variable::Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34830c27f16176946d3f44522530f636" name="a34830c27f16176946d3f44522530f636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34830c27f16176946d3f44522530f636">&#9670;&#160;</a></span>to_true()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_true.html">FormulaTrue</a> &gt; to_true </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaTrue&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_true(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a3c92380da4b49bf1656529597e4ddc70" name="a3c92380da4b49bf1656529597e4ddc70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c92380da4b49bf1656529597e4ddc70">&#9670;&#160;</a></span>to_variable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_var.html">FormulaVar</a> &gt; to_variable </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f_ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code class="param">f_ptr</code> to <code>shared_ptr&lt;const FormulaVar&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_variable(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="ad07c658dafebaf56057941ccae6f81c4" name="ad07c658dafebaf56057941ccae6f81c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07c658dafebaf56057941ccae6f81c4">&#9670;&#160;</a></span>ToLatex() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string ToLatex </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>precision</em></span><span class="paramdefsep"> = </span><span class="paramdefval">3</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a LaTeX string representation of <span class="tt">M</span> with floating point coefficients displayed using <span class="tt">precision</span>. </p>

</div>
</div>
<a id="ac98eda5e1ecf8e4ca123d898f2cec6fe" name="ac98eda5e1ecf8e4ca123d898f2cec6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98eda5e1ecf8e4ca123d898f2cec6fe">&#9670;&#160;</a></span>ToLatex() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ToLatex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>precision</em></span><span class="paramdefsep"> = </span><span class="paramdefval">3</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a LaTeX string representation of <span class="tt">e</span> with floating point coefficients displayed using <span class="tt">precision</span>. </p>

</div>
</div>
<a id="a792037568d9fe9ad837351c523146ada" name="a792037568d9fe9ad837351c523146ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a792037568d9fe9ad837351c523146ada">&#9670;&#160;</a></span>ToLatex() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ToLatex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>precision</em></span><span class="paramdefsep"> = </span><span class="paramdefval">3</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a LaTeX string representation of <span class="tt">f</span> with floating point coefficients displayed using <span class="tt">precision</span>. </p>

</div>
</div>
<a id="a2c784608acef125ad519984e49395059" name="a2c784608acef125ad519984e49395059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c784608acef125ad519984e49395059">&#9670;&#160;</a></span>ToLatex() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ToLatex </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>precision</em></span><span class="paramdefsep"> = </span><span class="paramdefval">3</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a Latex string representation of <span class="tt">val</span> displayed with <span class="tt">precision</span>, with one exception. </p>
<p>If the fractional part of <span class="tt">val</span> is exactly zero, then <span class="tt">val</span> is represented perfectly as an integer, and is displayed without the trailing decimal point and zeros (in this case, the <span class="tt">precision</span> argument is ignored). </p>

</div>
</div>
<a id="a11eb904ad30c23a3a54c95c38c2f294c" name="a11eb904ad30c23a3a54c95c38c2f294c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11eb904ad30c23a3a54c95c38c2f294c">&#9670;&#160;</a></span>uninterpreted_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> uninterpreted_function </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>arguments</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an uninterpreted-function expression with <code class="param">name</code> and <code class="param">arguments</code>. </p>
<p>An uninterpreted function is an opaque function that has no other property than its name and a list of its arguments. This is useful to applications where it is good enough to provide abstract information of a function without exposing full details. Declaring sparsity of a system is a typical example. </p>

</div>
</div>
<a id="a0f2183e65fb6daea39bbc9084cd99b87" name="a0f2183e65fb6daea39bbc9084cd99b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2183e65fb6daea39bbc9084cd99b87">&#9670;&#160;</a></span>VisitExpression()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Result, typename Visitor, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Result VisitExpression </td>
          <td>(</td>
          <td class="paramtype">Visitor *</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls visitor object <code class="param">v</code> with a symbolic-expression <code class="param">e</code>, and arguments <code class="param">args</code>. </p>
<p>Visitor object is expected to implement the following methods which take <code class="param">f</code> and <code class="param">args:</code> <span class="tt">VisitConstant</span>, <span class="tt">VisitVariable</span>, <span class="tt">VisitAddition</span>, <span class="tt">VisitMultiplication</span>, <span class="tt">VisitDivision</span>, <span class="tt">VisitLog</span>, <span class="tt">VisitAbs</span>, <span class="tt">VisitExp</span>, <span class="tt">VisitSqrt</span>, <span class="tt">VisitPow</span>, <span class="tt">VisitSin</span>, <span class="tt">VisitCos</span>, <span class="tt">VisitTan</span>, <span class="tt">VisitAsin</span>, <span class="tt">VisitAtan</span>, <span class="tt">VisitAtan2</span>, <span class="tt">VisitSinh</span>, <span class="tt">VisitCosh</span>, <span class="tt">VisitTanh</span>, <span class="tt">VisitMin</span>, <span class="tt">VisitMax</span>, <span class="tt">VisitCeil</span>, <span class="tt">VisitFloor</span>, <span class="tt">VisitIfThenElse</span>, <span class="tt">VisitUninterpretedFunction</span>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if NaN is detected during a visit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a975cce0c245364b8dfea662b296d7eb1" name="a975cce0c245364b8dfea662b296d7eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975cce0c245364b8dfea662b296d7eb1">&#9670;&#160;</a></span>VisitFormula()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Result, typename Visitor, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Result VisitFormula </td>
          <td>(</td>
          <td class="paramtype">Visitor *</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls visitor object <code class="param">v</code> with a symbolic formula <code class="param">f</code>, and arguments <code class="param">args</code>. </p>
<p>Visitor object is expected to implement the following methods which take <code class="param">f</code> and <code class="param">args:</code> <span class="tt">VisitFalse</span>, <span class="tt">VisitTrue</span>, <span class="tt">VisitVariable</span>, <span class="tt">VisitEqualTo</span>, VisitNotEqualTo, VisitGreaterThan, <span class="tt">VisitGreaterThanOrEqualTo</span>, <span class="tt">VisitLessThan</span>, <span class="tt">VisitLessThanOrEqualTo</span>, <span class="tt">VisitConjunction</span>, <span class="tt">VisitDisjunction</span>, <span class="tt">VisitNegation</span>, <span class="tt">VisitForall</span>, <span class="tt">VisitIsnan</span>, <span class="tt">VisitPositiveSemidefinite</span>.</p>
<p>Check the implementation of <code>NegationNormalFormConverter</code> class in drake/common/test/symbolic_formula_visitor_test.cc file to find an example. </p>

</div>
</div>
<a id="ae5abf0008c6baabf649d608c33114a47" name="ae5abf0008c6baabf649d608c33114a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5abf0008c6baabf649d608c33114a47">&#9670;&#160;</a></span>VisitPolynomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Result, typename Visitor, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Result VisitPolynomial </td>
          <td>(</td>
          <td class="paramtype">Visitor *</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls visitor object <code class="param">v</code> with a polynomial symbolic-expression <code class="param">e</code>, and arguments <code class="param">args</code>. </p>
<p>Visitor object is expected to implement the following methods which take <code class="param">f</code> and <code class="param">args:</code> <span class="tt">VisitConstant</span>, <span class="tt">VisitVariable</span>, <span class="tt">VisitAddition</span>, <span class="tt">VisitMultiplication</span>, <span class="tt">VisitDivision</span>, <span class="tt">VisitPow</span>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if NaN is detected during a visit.</td></tr>
  </table>
  </dd>
</dl>
<p>See the implementation of <code>DegreeVisitor</code> class and <code>Degree</code> function in drake/common/symbolic_monomial.cc as an example usage.</p>
<dl class="section pre"><dt>Precondition</dt><dd>e.is_polynomial() is true. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1symbolic.html">symbolic</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="https://accessibility.mit.edu/" class="site-menu-item">Accessibility</a>
        </li>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
