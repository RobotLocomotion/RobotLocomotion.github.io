<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake::symbolic Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 </div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacedrake_1_1symbolic.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">drake::symbolic Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedrake_1_1symbolic_1_1test"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic_1_1test.html">test</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1symbolic_1_1_basis_element_graded_reverse_lex_order.html">BasisElementGradedReverseLexOrder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Graded reverse lexicographic order.  <a href="structdrake_1_1symbolic_1_1_basis_element_graded_reverse_lex_order.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_binary_expression_cell.html">BinaryExpressionCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the base class for binary expressions.  <a href="classdrake_1_1symbolic_1_1_binary_expression_cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html" title="ChebyshevBasisElement represents an element of Chebyshev polynomial basis, written as the product of ...">ChebyshevBasisElement</a> represents an element of Chebyshev polynomial basis, written as the product of Chebyshev polynomials, in the form Tₚ₀(x₀)Tₚ₁(x₁)...Tₚₙ(xₙ), where each Tₚᵢ(xᵢ) is a (univariate) Chebyshev polynomial of degree pᵢ.  <a href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_polynomial.html">ChebyshevPolynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the Chebyshev polynomial of the first kind Tₙ(x).  <a href="classdrake_1_1symbolic_1_1_chebyshev_polynomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_code_gen_visitor.html">CodeGenVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor class for code generation.  <a href="classdrake_1_1symbolic_1_1_code_gen_visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a symbolic environment (mapping from a variable to a value).  <a href="classdrake_1_1symbolic_1_1_environment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a symbolic form of an expression.  <a href="classdrake_1_1symbolic_1_1_expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_abs.html">ExpressionAbs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing absolute value function.  <a href="classdrake_1_1symbolic_1_1_expression_abs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_acos.html">ExpressionAcos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing arccosine function.  <a href="classdrake_1_1symbolic_1_1_expression_acos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html">ExpressionAdd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing an addition which is a sum of products.  <a href="classdrake_1_1symbolic_1_1_expression_add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_add_factory.html">ExpressionAddFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory class to help build <a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html" title="Symbolic expression representing an addition which is a sum of products.">ExpressionAdd</a> expressions.  <a href="classdrake_1_1symbolic_1_1_expression_add_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_asin.html">ExpressionAsin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing arcsine function.  <a href="classdrake_1_1symbolic_1_1_expression_asin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_atan.html">ExpressionAtan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing arctangent function.  <a href="classdrake_1_1symbolic_1_1_expression_atan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_atan2.html">ExpressionAtan2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing atan2 function (arctangent function with two arguments).  <a href="classdrake_1_1symbolic_1_1_expression_atan2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_ceiling.html">ExpressionCeiling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing ceil function.  <a href="classdrake_1_1symbolic_1_1_expression_ceiling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an abstract class which is the base of concrete symbolic-expression classes.  <a href="classdrake_1_1symbolic_1_1_expression_cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_cos.html">ExpressionCos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing cosine function.  <a href="classdrake_1_1symbolic_1_1_expression_cos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_cosh.html">ExpressionCosh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing hyperbolic cosine function.  <a href="classdrake_1_1symbolic_1_1_expression_cosh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_div.html">ExpressionDiv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing division.  <a href="classdrake_1_1symbolic_1_1_expression_div.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_exp.html">ExpressionExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing exponentiation using the base of natural logarithms.  <a href="classdrake_1_1symbolic_1_1_expression_exp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_floor.html">ExpressionFloor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing floor function.  <a href="classdrake_1_1symbolic_1_1_expression_floor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_if_then_else.html">ExpressionIfThenElse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing if-then-else expression.  <a href="classdrake_1_1symbolic_1_1_expression_if_then_else.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_log.html">ExpressionLog</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing logarithms.  <a href="classdrake_1_1symbolic_1_1_expression_log.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_max.html">ExpressionMax</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing max function.  <a href="classdrake_1_1symbolic_1_1_expression_max.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_min.html">ExpressionMin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing min function.  <a href="classdrake_1_1symbolic_1_1_expression_min.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html">ExpressionMul</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing a multiplication of powers.  <a href="classdrake_1_1symbolic_1_1_expression_mul.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_mul_factory.html">ExpressionMulFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory class to help build <a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html" title="Symbolic expression representing a multiplication of powers.">ExpressionMul</a> expressions.  <a href="classdrake_1_1symbolic_1_1_expression_mul_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_na_n.html">ExpressionNaN</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing NaN (not-a-number).  <a href="classdrake_1_1symbolic_1_1_expression_na_n.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_pow.html">ExpressionPow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing power function.  <a href="classdrake_1_1symbolic_1_1_expression_pow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_sin.html">ExpressionSin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing sine function.  <a href="classdrake_1_1symbolic_1_1_expression_sin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_sinh.html">ExpressionSinh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing hyperbolic sine function.  <a href="classdrake_1_1symbolic_1_1_expression_sinh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_sqrt.html">ExpressionSqrt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing square-root.  <a href="classdrake_1_1symbolic_1_1_expression_sqrt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_tan.html">ExpressionTan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing tangent function.  <a href="classdrake_1_1symbolic_1_1_expression_tan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_tanh.html">ExpressionTanh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing hyperbolic tangent function.  <a href="classdrake_1_1symbolic_1_1_expression_tanh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html">ExpressionUninterpretedFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing an uninterpreted function.  <a href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_var.html">ExpressionVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing a variable.  <a href="classdrake_1_1symbolic_1_1_expression_var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a symbolic form of a first-order logic formula.  <a href="classdrake_1_1symbolic_1_1_formula.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_and.html">FormulaAnd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing conjunctions (f1 ∧ ...  <a href="classdrake_1_1symbolic_1_1_formula_and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an abstract class which is the base of concrete symbolic-formula classes (i.e.  <a href="classdrake_1_1symbolic_1_1_formula_cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_eq.html">FormulaEq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing equality (e1 = e2).  <a href="classdrake_1_1symbolic_1_1_formula_eq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_false.html">FormulaFalse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing false.  <a href="classdrake_1_1symbolic_1_1_formula_false.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_forall.html">FormulaForall</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing universal quantifications (∀ x₁, ..., * xn.  <a href="classdrake_1_1symbolic_1_1_formula_forall.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_geq.html">FormulaGeq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing 'greater-than-or-equal-to' (e1 ≥ e2).  <a href="classdrake_1_1symbolic_1_1_formula_geq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_gt.html">FormulaGt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing 'greater-than' (e1 &gt; e2).  <a href="classdrake_1_1symbolic_1_1_formula_gt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_isnan.html">FormulaIsnan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing isnan predicate.  <a href="classdrake_1_1symbolic_1_1_formula_isnan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_leq.html">FormulaLeq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing 'less-than-or-equal-to' (e1 ≤ e2).  <a href="classdrake_1_1symbolic_1_1_formula_leq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_lt.html">FormulaLt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing 'less-than' (e1 &lt; e2).  <a href="classdrake_1_1symbolic_1_1_formula_lt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_neq.html">FormulaNeq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing disequality (e1 ≠ e2).  <a href="classdrake_1_1symbolic_1_1_formula_neq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_not.html">FormulaNot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing negations (¬f).  <a href="classdrake_1_1symbolic_1_1_formula_not.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_or.html">FormulaOr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing disjunctions (f1 ∨ ...  <a href="classdrake_1_1symbolic_1_1_formula_or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_positive_semidefinite.html">FormulaPositiveSemidefinite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing positive-semidefinite (PSD) constraint.  <a href="classdrake_1_1symbolic_1_1_formula_positive_semidefinite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_true.html">FormulaTrue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing true.  <a href="classdrake_1_1symbolic_1_1_formula_true.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_var.html">FormulaVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing a Boolean variable.  <a href="classdrake_1_1symbolic_1_1_formula_var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents symbolic generic polynomials using a given basis (for example, monomial basis, Chebyshev basis, etc).  <a href="classdrake_1_1symbolic_1_1_generic_polynomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1symbolic_1_1_graded_reverse_lex_order.html">GradedReverseLexOrder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Graded reverse lexicographic order.  <a href="structdrake_1_1symbolic_1_1_graded_reverse_lex_order.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a monomial, a product of powers of variables with non-negative integer exponents.  <a href="classdrake_1_1symbolic_1_1_monomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html" title="MonomialBasisElement represents a monomial, a product of powers of variables with non-negative intege...">MonomialBasisElement</a> represents a monomial, a product of powers of variables with non-negative integer exponents.  <a href="classdrake_1_1symbolic_1_1_monomial_basis_element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_nary_formula_cell.html">NaryFormulaCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the base class for N-ary logic operators (∧ and ∨).  <a href="classdrake_1_1symbolic_1_1_nary_formula_cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents symbolic polynomials.  <a href="classdrake_1_1symbolic_1_1_polynomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial_basis_element.html">PolynomialBasisElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each polynomial p(x) can be written as a linear combination of its basis elements p(x) = ∑ᵢ cᵢ * ϕᵢ(x), where ϕᵢ(x) is the i'th element in the basis, cᵢ is the coefficient of that element.  <a href="classdrake_1_1symbolic_1_1_polynomial_basis_element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents symbolic rational function.  <a href="classdrake_1_1symbolic_1_1_rational_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_relational_formula_cell.html">RelationalFormulaCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the base class for relational operators (==, !=, &lt;, &lt;=, &gt;, &gt;=).  <a href="classdrake_1_1symbolic_1_1_relational_formula_cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html">RewritingRule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html" title="A RewritingRule, lhs =&gt; rhs, consists of two Patterns lhs and rhs.">RewritingRule</a></code>, <code>lhs =&gt; rhs</code>, consists of two Patterns <code>lhs</code> and <code>rhs</code>.  <a href="classdrake_1_1symbolic_1_1_rewriting_rule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1symbolic_1_1_sin_cos.html">SinCos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a pair of <a class="el" href="classdrake_1_1symbolic_1_1_variables.html" title="Represents a set of variables.">Variables</a> corresponding to sin(q) and cos(q).  <a href="structdrake_1_1symbolic_1_1_sin_cos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_unary_expression_cell.html">UnaryExpressionCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the base class for unary expressions.  <a href="classdrake_1_1symbolic_1_1_unary_expression_cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a symbolic variable.  <a href="classdrake_1_1symbolic_1_1_variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a set of variables.  <a href="classdrake_1_1symbolic_1_1_variables.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acbfe43d34e6c71c503d4de11da53bbb7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acbfe43d34e6c71c503d4de11da53bbb7">Substitution</a> = std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;</td></tr>
<tr class="separator:acbfe43d34e6c71c503d4de11da53bbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f60d4b8ada97a4fb724b2d66d273892"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a4f60d4b8ada97a4fb724b2d66d273892"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a> = std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial_basis_element.html">PolynomialBasisElement</a>, BasisElement &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &gt;</td></tr>
<tr class="memdesc:a4f60d4b8ada97a4fb724b2d66d273892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an explicit SFINAE alias for use with return types to dissuade CTAD from trying to instantiate an invalid GenericElement&lt;&gt; for operator overloads, (if that's actually the case).  <a href="#a4f60d4b8ada97a4fb724b2d66d273892">More...</a><br /></td></tr>
<tr class="separator:a4f60d4b8ada97a4fb724b2d66d273892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb27ddf30420e620beb8e6725d83208f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aeb27ddf30420e620beb8e6725d83208f">Pattern</a> = <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a></td></tr>
<tr class="memdesc:aeb27ddf30420e620beb8e6725d83208f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern is an expression which possibly includes variables which represent placeholders.  <a href="#aeb27ddf30420e620beb8e6725d83208f">More...</a><br /></td></tr>
<tr class="separator:aeb27ddf30420e620beb8e6725d83208f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134e54042165751a5e5369b4631c90eb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a134e54042165751a5e5369b4631c90eb">Rewriter</a> = std::function&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>(const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a134e54042165751a5e5369b4631c90eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>Rewriter</code> is a function from an <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">Expression</a> to an <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">Expression</a>.  <a href="#a134e54042165751a5e5369b4631c90eb">More...</a><br /></td></tr>
<tr class="separator:a134e54042165751a5e5369b4631c90eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c5d9eccfc9643fdd5764d6e72b8faf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a13c5d9eccfc9643fdd5764d6e72b8faf">SinCosSubstitution</a> = std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, <a class="el" href="structdrake_1_1symbolic_1_1_sin_cos.html">SinCos</a> &gt;</td></tr>
<tr class="separator:a13c5d9eccfc9643fdd5764d6e72b8faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a245f75ee96839b12e22fea09c6f3ec91"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91">ExpressionKind</a> : std::uint16_t { <br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91acb17869fe51048b5a5c4c6106551a255">Constant</a> = 0, 
<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91a5a92344ee95acf10c31901b36418be77">Var</a> = 0x7FF1u, 
<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91aec211f7c20af43e742bf2570c3cb84f9">Add</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91a62b6d55816cf737bfc6f42e60df1a3f2">Mul</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91a43d11850893d2fe84a1e618121c1cc0a">Div</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91ace0be71e33226e4c1db2bcea5959f16b">Log</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91a1e34af023adeb7d5f484f8eb4b9826b6">Abs</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91acad39a154bffb61175f674d6eefaf6d0">Exp</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91aae77f3ad25595e35b327334d89410054">Sqrt</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91a8be6d3e955290ee50c00a4bc92aa7749">Pow</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91a0986d137604183312e6d3599578bc6cd">Sin</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91affca562be079b9e4e41ea9d6a86c582b">Cos</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91a1266b4e6f81e60733ec6c717e0181f60">Tan</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91a76cfc54de4e2b9cde17334c821217d11">Asin</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91aed4629033ecb516ed7d1536e162030bb">Acos</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91ac9968ab1fa8103acbb3a4f22265f2def">Atan</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91a5816dfcaf3b6dbb486ef9c8c006ff613">Atan2</a> = 0xFFF1u, 
<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91a98ed804abf4edd1f3be3fa894fa8cc3d">Sinh</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91a4371c3565b771b40c187487cc0190392">Cosh</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91acc132a41cab5676334f353a22a0aa5c5">Tanh</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91a78d811e98514cd165dda532286610fd2">Min</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91a6a061313d22e51e0f25b7cd4dc065233">Max</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91ab95a01ffffa8fcdd2a9af961937c097c">Ceil</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91af3f6d0343d56ce88ce7958170ed05cb3">Floor</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91aaff6933d8331eca27edc911467980c9c">IfThenElse</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91a7ecfb3bf076a6a9635f975fe96ac97fd">NaN</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91a2e59a51ac43bc3415c1b8ce7b3f98579">UninterpretedFunction</a>
<br />
 }</td></tr>
<tr class="memdesc:a245f75ee96839b12e22fea09c6f3ec91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kinds of symbolic expressions.  <a href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91">More...</a><br /></td></tr>
<tr class="separator:a245f75ee96839b12e22fea09c6f3ec91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6869e7044dd90be5d972ee7dd4e821b6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a> { <br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6af8320b26d30ab433c5a54546d21f414c">False</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6af827cf462f62848df37c5e1e94a4da74">True</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a5a92344ee95acf10c31901b36418be77">Var</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a3718b5ecf60aa0dba49e150e96cb1fc3">Eq</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6ae4ecc5da3c6dbb4448f25990dc609727">Neq</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a086cb8308e5a36e7c4ed1f8873ad801f">Gt</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a5dabfebb89e6e45a8cf8573d92746ed3">Geq</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a50033c15af7795cd6617f117b29d6922">Lt</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6abe5721bf93d718a79358217ec9b88176">Leq</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6ac33315685a0cba3ce53be378b3c7874b">And</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a3a2d5fe857d8f9541136a124c2edec6c">Or</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6aa74c05d080620f087c4e523977230666">Not</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a43cfe3c750a08acb91df1e3384548078">Forall</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6afd116e3418522ffc34d7423bc601510d">Isnan</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a1fbc164d3e50b7fd20690a21f1b7b2f2">PositiveSemidefinite</a>
<br />
 }</td></tr>
<tr class="memdesc:a6869e7044dd90be5d972ee7dd4e821b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kinds of symbolic formulas.  <a href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">More...</a><br /></td></tr>
<tr class="separator:a6869e7044dd90be5d972ee7dd4e821b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7729e9ae50c2b5ca1d86021ad1ae44"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0f7729e9ae50c2b5ca1d86021ad1ae44">SinCosSubstitutionType</a> { <a class="el" href="namespacedrake_1_1symbolic.html#a0f7729e9ae50c2b5ca1d86021ad1ae44af4d2017f452ed392e963b2d8ddf591bb">kAngle</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a0f7729e9ae50c2b5ca1d86021ad1ae44aea1eea0840dd2bfd79a5cbfdf49ea143">kHalfAnglePreferSin</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a0f7729e9ae50c2b5ca1d86021ad1ae44acdf5f9e766a4e04d5ac3bf38e82da0f0">kHalfAnglePreferCos</a>
 }</td></tr>
<tr class="separator:a0f7729e9ae50c2b5ca1d86021ad1ae44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a76deccd3cd3f64d9b875dd5116792c07"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a>, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a76deccd3cd3f64d9b875dd5116792c07">operator *</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a> &amp;a, const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a> &amp;b)</td></tr>
<tr class="memdesc:a76deccd3cd3f64d9b875dd5116792c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of two Chebyshev basis elements.  <a href="#a76deccd3cd3f64d9b875dd5116792c07">More...</a><br /></td></tr>
<tr class="separator:a76deccd3cd3f64d9b875dd5116792c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af975c2571c59b1d8b03b213a15096336"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af975c2571c59b1d8b03b213a15096336">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a> &amp;m)</td></tr>
<tr class="separator:af975c2571c59b1d8b03b213a15096336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d454a069abf89b2a0b6c71222ec221"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a31d454a069abf89b2a0b6c71222ec221">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_polynomial.html">ChebyshevPolynomial</a> &amp;p)</td></tr>
<tr class="separator:a31d454a069abf89b2a0b6c71222ec221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc20898a64bbcee2ec07efd585e7c39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abcc20898a64bbcee2ec07efd585e7c39">EvaluateChebyshevPolynomial</a> (<a class="el" href="classdouble.html">double</a> var_val, <a class="el" href="classint.html">int</a> degree)</td></tr>
<tr class="memdesc:abcc20898a64bbcee2ec07efd585e7c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a Chebyshev polynomial at a given value.  <a href="#abcc20898a64bbcee2ec07efd585e7c39">More...</a><br /></td></tr>
<tr class="separator:abcc20898a64bbcee2ec07efd585e7c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d07751d060ddf51dad4702d441f651a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__codegen.html#ga2d07751d060ddf51dad4702d441f651a">CodeGen</a> (const std::string &amp;function_name, const std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;parameters, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ga2d07751d060ddf51dad4702d441f651a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given symbolic expression <code>e</code>, generates two C functions, <code>&lt;function_name&gt;</code> and <code>&lt;function_name&gt;_meta</code>.  <a href="group__codegen.html#ga2d07751d060ddf51dad4702d441f651a">More...</a><br /></td></tr>
<tr class="separator:ga2d07751d060ddf51dad4702d441f651a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga141de7c1e3ce45784c62e57a034a71ac"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ga141de7c1e3ce45784c62e57a034a71ac"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__codegen.html#ga141de7c1e3ce45784c62e57a034a71ac">CodeGen</a> (const std::string &amp;function_name, const std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;parameters, const Eigen::PlainObjectBase&lt; Derived &gt; &amp;M)</td></tr>
<tr class="memdesc:ga141de7c1e3ce45784c62e57a034a71ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given symbolic dense matrix <code>M</code>, generates two C functions, <code>&lt;function_name&gt;</code> and <code>&lt;function_name&gt;_meta</code>.  <a href="group__codegen.html#ga141de7c1e3ce45784c62e57a034a71ac">More...</a><br /></td></tr>
<tr class="separator:ga141de7c1e3ce45784c62e57a034a71ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada538db5c08eaa47546d2df1c6f442cb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__codegen.html#gada538db5c08eaa47546d2df1c6f442cb">CodeGen</a> (const std::string &amp;function_name, const std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;parameters, const Eigen::Ref&lt; const Eigen::SparseMatrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Eigen::ColMajor &gt;&gt; &amp;M)</td></tr>
<tr class="memdesc:gada538db5c08eaa47546d2df1c6f442cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given symbolic column-major sparse matrix <code>M</code>, generates two C functions, <code>&lt;function_name&gt;</code> and <code>&lt;function_name&gt;_meta</code>.  <a href="group__codegen.html#gada538db5c08eaa47546d2df1c6f442cb">More...</a><br /></td></tr>
<tr class="separator:gada538db5c08eaa47546d2df1c6f442cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c0db41d89c9257d2fbfc4928fa5bd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a13c0db41d89c9257d2fbfc4928fa5bd7">IsAffine</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;m, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars)</td></tr>
<tr class="memdesc:a13c0db41d89c9257d2fbfc4928fa5bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if every element in <code>m</code> is affine in <code>vars</code>.  <a href="#a13c0db41d89c9257d2fbfc4928fa5bd7">More...</a><br /></td></tr>
<tr class="separator:a13c0db41d89c9257d2fbfc4928fa5bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8e94c7598bd59e6a5314ffbc3c7f59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9d8e94c7598bd59e6a5314ffbc3c7f59">IsAffine</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;m)</td></tr>
<tr class="memdesc:a9d8e94c7598bd59e6a5314ffbc3c7f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if every element in <code>m</code> is affine.  <a href="#a9d8e94c7598bd59e6a5314ffbc3c7f59">More...</a><br /></td></tr>
<tr class="separator:a9d8e94c7598bd59e6a5314ffbc3c7f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c01361f464b3eae396f7d1a0e92c85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa6c01361f464b3eae396f7d1a0e92c85">DecomposeLinearExpressions</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;expressions, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;vars, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::MatrixXd &gt; M)</td></tr>
<tr class="memdesc:aa6c01361f464b3eae396f7d1a0e92c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decomposes <code>expressions</code> into <code>M</code> * <code>vars</code>.  <a href="#aa6c01361f464b3eae396f7d1a0e92c85">More...</a><br /></td></tr>
<tr class="separator:aa6c01361f464b3eae396f7d1a0e92c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c152941a4e06624bac5926fac2d4e32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0c152941a4e06624bac5926fac2d4e32">DecomposeAffineExpressions</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;expressions, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;vars, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::MatrixXd &gt; M, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::VectorXd &gt; v)</td></tr>
<tr class="memdesc:a0c152941a4e06624bac5926fac2d4e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decomposes <code>expressions</code> into <code>M</code> * <code>vars</code> + <code>v</code>.  <a href="#a0c152941a4e06624bac5926fac2d4e32">More...</a><br /></td></tr>
<tr class="separator:a0c152941a4e06624bac5926fac2d4e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bfdbf915c3b1d2d0d13fa2110c97066"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5bfdbf915c3b1d2d0d13fa2110c97066">ExtractAndAppendVariablesFromExpression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; *vars, std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, <a class="el" href="classint.html">int</a> &gt; *map_var_to_index)</td></tr>
<tr class="memdesc:a5bfdbf915c3b1d2d0d13fa2110c97066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an expression <code>e</code>, extracts all variables inside <code>e</code>, appends these variables to <code>vars</code> if they are not included in <code>vars</code> yet.  <a href="#a5bfdbf915c3b1d2d0d13fa2110c97066">More...</a><br /></td></tr>
<tr class="separator:a5bfdbf915c3b1d2d0d13fa2110c97066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9f98ac0c3db06d72227b0502cf8934"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;, std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4f9f98ac0c3db06d72227b0502cf8934">ExtractVariablesFromExpression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a4f9f98ac0c3db06d72227b0502cf8934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an expression <code>e</code>, extracts all variables inside <code>e</code>.  <a href="#a4f9f98ac0c3db06d72227b0502cf8934">More...</a><br /></td></tr>
<tr class="separator:a4f9f98ac0c3db06d72227b0502cf8934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9ab6787ea570003b69621c52bfa5cc"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;, std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">Variable::Id</a>, <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acd9ab6787ea570003b69621c52bfa5cc">ExtractVariablesFromExpression</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;expressions)</td></tr>
<tr class="memdesc:acd9ab6787ea570003b69621c52bfa5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads ExtractVariablesFromExpression but with a vector of expressions.  <a href="#acd9ab6787ea570003b69621c52bfa5cc">More...</a><br /></td></tr>
<tr class="separator:acd9ab6787ea570003b69621c52bfa5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168045cc4df5fee36f317095c2a9f891"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a168045cc4df5fee36f317095c2a9f891">DecomposeQuadraticPolynomial</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;poly, const std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, <a class="el" href="classint.html">int</a> &gt; &amp;map_var_to_index, Eigen::MatrixXd *Q, Eigen::VectorXd *b, <a class="el" href="classdouble.html">double</a> *c)</td></tr>
<tr class="memdesc:a168045cc4df5fee36f317095c2a9f891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a quadratic polynomial <code>poly</code>, decomposes it into the form 0.5 * x' Q * x + b' * x + c.  <a href="#a168045cc4df5fee36f317095c2a9f891">More...</a><br /></td></tr>
<tr class="separator:a168045cc4df5fee36f317095c2a9f891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c6a31812dc3e509644dbbc95c9778e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae3c6a31812dc3e509644dbbc95c9778e">DecomposeAffineExpressions</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;v, Eigen::MatrixXd *A, Eigen::VectorXd *b, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; *vars)</td></tr>
<tr class="memdesc:ae3c6a31812dc3e509644dbbc95c9778e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of affine expressions v, decompose it to \( v = A vars + b \).  <a href="#ae3c6a31812dc3e509644dbbc95c9778e">More...</a><br /></td></tr>
<tr class="separator:ae3c6a31812dc3e509644dbbc95c9778e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d95a6b1bc2f740b30a4735cc6dcd3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a47d95a6b1bc2f740b30a4735cc6dcd3c">DecomposeAffineExpression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, const std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, <a class="el" href="classint.html">int</a> &gt; &amp;map_var_to_index, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::RowVectorXd &gt; coeffs, <a class="el" href="classdouble.html">double</a> *constant_term)</td></tr>
<tr class="memdesc:a47d95a6b1bc2f740b30a4735cc6dcd3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decomposes an affine combination <code>e</code> = c0 + c1 * v1 + ...  <a href="#a47d95a6b1bc2f740b30a4735cc6dcd3c">More...</a><br /></td></tr>
<tr class="separator:a47d95a6b1bc2f740b30a4735cc6dcd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c85e424b3109ed84a5bb309238bc3c"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae8c85e424b3109ed84a5bb309238bc3c">DecomposeLumpedParameters</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;f, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;parameters)</td></tr>
<tr class="memdesc:ae8c85e424b3109ed84a5bb309238bc3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of Expressions <code>f</code> and a list of <code>parameters</code> we define all additional variables in <code>f</code> to be a vector of "non-parameter variables", n.  <a href="#ae8c85e424b3109ed84a5bb309238bc3c">More...</a><br /></td></tr>
<tr class="separator:ae8c85e424b3109ed84a5bb309238bc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c5b25729d776ddbbcc40dd07e7f617"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; bool, Eigen::MatrixXd, Eigen::VectorXd, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a20c5b25729d776ddbbcc40dd07e7f617">DecomposeL2NormExpression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, <a class="el" href="classdouble.html">double</a> psd_tol=1e-8, double coefficient_tol=1e-8)</td></tr>
<tr class="memdesc:a20c5b25729d776ddbbcc40dd07e7f617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decomposes an L2 norm <code>e</code> = |Ax+b|₂ into A, b, and the variable vector x (or returns false if the decomposition is not possible).  <a href="#a20c5b25729d776ddbbcc40dd07e7f617">More...</a><br /></td></tr>
<tr class="separator:a20c5b25729d776ddbbcc40dd07e7f617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50e3bc4e34ea64ae4d7065ad1fc72ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af50e3bc4e34ea64ae4d7065ad1fc72ac">PopulateRandomVariables</a> (<a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> env, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;variables, <a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *random_generator)</td></tr>
<tr class="memdesc:af50e3bc4e34ea64ae4d7065ad1fc72ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the environment <code>env</code> by sampling values for the unassigned random variables in <code>variables</code> using <code>random_generator</code>.  <a href="#af50e3bc4e34ea64ae4d7065ad1fc72ac">More...</a><br /></td></tr>
<tr class="separator:af50e3bc4e34ea64ae4d7065ad1fc72ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3293ffe3812fbfa2dbd63263fcf6c4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af3293ffe3812fbfa2dbd63263fcf6c4c">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:af3293ffe3812fbfa2dbd63263fcf6c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1519bc7275ec68c904b395067f8ff775"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1519bc7275ec68c904b395067f8ff775">operator+=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a1519bc7275ec68c904b395067f8ff775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105ae15b8e85984cf3ae81a7b67de38c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a105ae15b8e85984cf3ae81a7b67de38c">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a105ae15b8e85984cf3ae81a7b67de38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d3a7da7b3275333a0f2d67d649ead8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab8d3a7da7b3275333a0f2d67d649ead8">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:ab8d3a7da7b3275333a0f2d67d649ead8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380b68d6baf2cb5ab4212e435d1104ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a380b68d6baf2cb5ab4212e435d1104ee">operator-=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a380b68d6baf2cb5ab4212e435d1104ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554e434566b78163855f96829c244e37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a554e434566b78163855f96829c244e37">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a554e434566b78163855f96829c244e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbec6a09664cb563d86071a7be38913"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1dbec6a09664cb563d86071a7be38913">operator *</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a1dbec6a09664cb563d86071a7be38913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee2268a69d74bce563c043848528741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6ee2268a69d74bce563c043848528741">operator *=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a6ee2268a69d74bce563c043848528741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e7c74e8b9ea1c9c5843c590e388009"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a43e7c74e8b9ea1c9c5843c590e388009">operator/</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a43e7c74e8b9ea1c9c5843c590e388009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5d6073354479ca8e507536cd36f844"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1c5d6073354479ca8e507536cd36f844">operator/=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a1c5d6073354479ca8e507536cd36f844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6702577f951bca3006ab02f3313484e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab6702577f951bca3006ab02f3313484e">log</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:ab6702577f951bca3006ab02f3313484e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ba050d5b6f088d5fe578396b3ad646"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a24ba050d5b6f088d5fe578396b3ad646">abs</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a24ba050d5b6f088d5fe578396b3ad646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683b7c0db1ce737fc0e3af3323a4fed1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a683b7c0db1ce737fc0e3af3323a4fed1">exp</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a683b7c0db1ce737fc0e3af3323a4fed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a5c97c514e6a5cb74438c6c2f5e760"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a65a5c97c514e6a5cb74438c6c2f5e760">sqrt</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a65a5c97c514e6a5cb74438c6c2f5e760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abe49c1083796a8b370bab55535aa72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3abe49c1083796a8b370bab55535aa72">pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:a3abe49c1083796a8b370bab55535aa72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90efdc7cf4be8bddc1fa365fb78b8e4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a90efdc7cf4be8bddc1fa365fb78b8e4a">sin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a90efdc7cf4be8bddc1fa365fb78b8e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4d1b24311f37c799ef18498b95020c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6b4d1b24311f37c799ef18498b95020c">cos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a6b4d1b24311f37c799ef18498b95020c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9900f71e1c1ceb9d59553adfa2db2b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab9900f71e1c1ceb9d59553adfa2db2b5">tan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:ab9900f71e1c1ceb9d59553adfa2db2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12acbb0b86d35d1de9280e699d3999d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa12acbb0b86d35d1de9280e699d3999d">asin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:aa12acbb0b86d35d1de9280e699d3999d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6244fef922874b743a272fe683cf068b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6244fef922874b743a272fe683cf068b">acos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a6244fef922874b743a272fe683cf068b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5beb575f1104a060ab02a89544fef1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab5beb575f1104a060ab02a89544fef1d">atan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:ab5beb575f1104a060ab02a89544fef1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d536a13db7de62414f5279c60148aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a03d536a13db7de62414f5279c60148aa">atan2</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:a03d536a13db7de62414f5279c60148aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d1119f8ec23bd6d918a984ce5820b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a96d1119f8ec23bd6d918a984ce5820b9">sinh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a96d1119f8ec23bd6d918a984ce5820b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d98cdd1dd5802fe6c341ecfe9c6cce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a79d98cdd1dd5802fe6c341ecfe9c6cce">cosh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a79d98cdd1dd5802fe6c341ecfe9c6cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb3ea44b1cf2fd877d782b8486d5aeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acbb3ea44b1cf2fd877d782b8486d5aeb">tanh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:acbb3ea44b1cf2fd877d782b8486d5aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368c7616ccd2ce8d1587aa7343575d52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a368c7616ccd2ce8d1587aa7343575d52">min</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:a368c7616ccd2ce8d1587aa7343575d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6413d336e52ed76599cc96a8c87eee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3f6413d336e52ed76599cc96a8c87eee">max</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:a3f6413d336e52ed76599cc96a8c87eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5470db9b5571df2d904addff09a2b98e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5470db9b5571df2d904addff09a2b98e">clamp</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;v, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;lo, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;hi)</td></tr>
<tr class="separator:a5470db9b5571df2d904addff09a2b98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4ba82d6dffb1c0c6f40a768f86eae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9d4ba82d6dffb1c0c6f40a768f86eae7">ceil</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a9d4ba82d6dffb1c0c6f40a768f86eae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b28c66fdf5d2b582a677660936abca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a56b28c66fdf5d2b582a677660936abca">floor</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a56b28c66fdf5d2b582a677660936abca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfe436e1c70779badecad19c8a039fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1dfe436e1c70779badecad19c8a039fe">if_then_else</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f_cond, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e_then, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e_else)</td></tr>
<tr class="separator:a1dfe436e1c70779badecad19c8a039fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986094e62cf81f5b0c1d4f33df8f8e3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a986094e62cf81f5b0c1d4f33df8f8e3f">uninterpreted_function</a> (std::string name, std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; arguments)</td></tr>
<tr class="memdesc:a986094e62cf81f5b0c1d4f33df8f8e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an uninterpreted-function expression with <code>name</code> and <code>arguments</code>.  <a href="#a986094e62cf81f5b0c1d4f33df8f8e3f">More...</a><br /></td></tr>
<tr class="separator:a986094e62cf81f5b0c1d4f33df8f8e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78354ef5dda9c52bbc103d57712c303e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a78354ef5dda9c52bbc103d57712c303e">swap</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;a, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;b)</td></tr>
<tr class="separator:a78354ef5dda9c52bbc103d57712c303e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a0c468c43eb087bc5e98af3c3ad278"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a30a0c468c43eb087bc5e98af3c3ad278">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a30a0c468c43eb087bc5e98af3c3ad278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f809da2a5c679df2b90aadedde5350"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae0f809da2a5c679df2b90aadedde5350">is_constant</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ae0f809da2a5c679df2b90aadedde5350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a constant expression.  <a href="#ae0f809da2a5c679df2b90aadedde5350">More...</a><br /></td></tr>
<tr class="separator:ae0f809da2a5c679df2b90aadedde5350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993384c5125c55ca3f5a11586a9bb675"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a993384c5125c55ca3f5a11586a9bb675">is_constant</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, <a class="el" href="classdouble.html">double</a> v)</td></tr>
<tr class="memdesc:a993384c5125c55ca3f5a11586a9bb675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a constant expression representing <code>v</code>.  <a href="#a993384c5125c55ca3f5a11586a9bb675">More...</a><br /></td></tr>
<tr class="separator:a993384c5125c55ca3f5a11586a9bb675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717f1ae4a1d038bc7870416276167f19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a717f1ae4a1d038bc7870416276167f19">is_zero</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a717f1ae4a1d038bc7870416276167f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is 0.0.  <a href="#a717f1ae4a1d038bc7870416276167f19">More...</a><br /></td></tr>
<tr class="separator:a717f1ae4a1d038bc7870416276167f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f342ca12fff0fb252625b2f62afe97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a45f342ca12fff0fb252625b2f62afe97">is_one</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a45f342ca12fff0fb252625b2f62afe97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is 1.0.  <a href="#a45f342ca12fff0fb252625b2f62afe97">More...</a><br /></td></tr>
<tr class="separator:a45f342ca12fff0fb252625b2f62afe97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef684b8834080c14e7dc13d497db9c22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aef684b8834080c14e7dc13d497db9c22">is_neg_one</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aef684b8834080c14e7dc13d497db9c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is -1.0.  <a href="#aef684b8834080c14e7dc13d497db9c22">More...</a><br /></td></tr>
<tr class="separator:aef684b8834080c14e7dc13d497db9c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c7e1bd2b1367487d36a6cd6871af0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a71c7e1bd2b1367487d36a6cd6871af0c">is_two</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a71c7e1bd2b1367487d36a6cd6871af0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is 2.0.  <a href="#a71c7e1bd2b1367487d36a6cd6871af0c">More...</a><br /></td></tr>
<tr class="separator:a71c7e1bd2b1367487d36a6cd6871af0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b9f0534ca861f03dbaa96ec1712f7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a92b9f0534ca861f03dbaa96ec1712f7f">is_nan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a92b9f0534ca861f03dbaa96ec1712f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is NaN.  <a href="#a92b9f0534ca861f03dbaa96ec1712f7f">More...</a><br /></td></tr>
<tr class="separator:a92b9f0534ca861f03dbaa96ec1712f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184038d04f0ab628e12fb53a6f7cb5d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a184038d04f0ab628e12fb53a6f7cb5d9">is_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a184038d04f0ab628e12fb53a6f7cb5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a variable expression.  <a href="#a184038d04f0ab628e12fb53a6f7cb5d9">More...</a><br /></td></tr>
<tr class="separator:a184038d04f0ab628e12fb53a6f7cb5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdaf0abb22b9280fc9622bd2d488a3e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acdaf0abb22b9280fc9622bd2d488a3e1">is_addition</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:acdaf0abb22b9280fc9622bd2d488a3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an addition expression.  <a href="#acdaf0abb22b9280fc9622bd2d488a3e1">More...</a><br /></td></tr>
<tr class="separator:acdaf0abb22b9280fc9622bd2d488a3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7c3de3be1c5f350b439dcdc7e8b24d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aee7c3de3be1c5f350b439dcdc7e8b24d">is_multiplication</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aee7c3de3be1c5f350b439dcdc7e8b24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a multiplication expression.  <a href="#aee7c3de3be1c5f350b439dcdc7e8b24d">More...</a><br /></td></tr>
<tr class="separator:aee7c3de3be1c5f350b439dcdc7e8b24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ddcd6effc0d16b4ab5e71008a84fd5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a60ddcd6effc0d16b4ab5e71008a84fd5">is_division</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a60ddcd6effc0d16b4ab5e71008a84fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a division expression.  <a href="#a60ddcd6effc0d16b4ab5e71008a84fd5">More...</a><br /></td></tr>
<tr class="separator:a60ddcd6effc0d16b4ab5e71008a84fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5dcbc71dc0b20b3debbeafdd5f1614"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8f5dcbc71dc0b20b3debbeafdd5f1614">is_log</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a8f5dcbc71dc0b20b3debbeafdd5f1614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a log expression.  <a href="#a8f5dcbc71dc0b20b3debbeafdd5f1614">More...</a><br /></td></tr>
<tr class="separator:a8f5dcbc71dc0b20b3debbeafdd5f1614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942b47a07cae421b3152f11536e6579c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a942b47a07cae421b3152f11536e6579c">is_abs</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a942b47a07cae421b3152f11536e6579c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an abs expression.  <a href="#a942b47a07cae421b3152f11536e6579c">More...</a><br /></td></tr>
<tr class="separator:a942b47a07cae421b3152f11536e6579c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f471231c119fee48c6dba7a2d5ab18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa8f471231c119fee48c6dba7a2d5ab18">is_exp</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aa8f471231c119fee48c6dba7a2d5ab18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an exp expression.  <a href="#aa8f471231c119fee48c6dba7a2d5ab18">More...</a><br /></td></tr>
<tr class="separator:aa8f471231c119fee48c6dba7a2d5ab18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe3f1787c60c08adf6af1e1f29ff6cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acfe3f1787c60c08adf6af1e1f29ff6cf">is_sqrt</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:acfe3f1787c60c08adf6af1e1f29ff6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a square-root expression.  <a href="#acfe3f1787c60c08adf6af1e1f29ff6cf">More...</a><br /></td></tr>
<tr class="separator:acfe3f1787c60c08adf6af1e1f29ff6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceba5fef90cbd2790037fa685e3ffdce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aceba5fef90cbd2790037fa685e3ffdce">is_pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aceba5fef90cbd2790037fa685e3ffdce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a power-function expression.  <a href="#aceba5fef90cbd2790037fa685e3ffdce">More...</a><br /></td></tr>
<tr class="separator:aceba5fef90cbd2790037fa685e3ffdce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b9105cdfbe657bfe90eaf47d9e8f11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a23b9105cdfbe657bfe90eaf47d9e8f11">is_sin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a23b9105cdfbe657bfe90eaf47d9e8f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a sine expression.  <a href="#a23b9105cdfbe657bfe90eaf47d9e8f11">More...</a><br /></td></tr>
<tr class="separator:a23b9105cdfbe657bfe90eaf47d9e8f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208a1c5a02e5bff9ba66d7b7db588ba0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a208a1c5a02e5bff9ba66d7b7db588ba0">is_cos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a208a1c5a02e5bff9ba66d7b7db588ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a cosine expression.  <a href="#a208a1c5a02e5bff9ba66d7b7db588ba0">More...</a><br /></td></tr>
<tr class="separator:a208a1c5a02e5bff9ba66d7b7db588ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd352ee762ef421653cd8941fa5ce22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8dd352ee762ef421653cd8941fa5ce22">is_tan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a8dd352ee762ef421653cd8941fa5ce22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a tangent expression.  <a href="#a8dd352ee762ef421653cd8941fa5ce22">More...</a><br /></td></tr>
<tr class="separator:a8dd352ee762ef421653cd8941fa5ce22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa5bc007d1b065d2afc30e2f6ced7a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acfa5bc007d1b065d2afc30e2f6ced7a9">is_asin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:acfa5bc007d1b065d2afc30e2f6ced7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an arcsine expression.  <a href="#acfa5bc007d1b065d2afc30e2f6ced7a9">More...</a><br /></td></tr>
<tr class="separator:acfa5bc007d1b065d2afc30e2f6ced7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fcf1da78e47a4afb20e0a4e85ac7dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac2fcf1da78e47a4afb20e0a4e85ac7dd">is_acos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ac2fcf1da78e47a4afb20e0a4e85ac7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an arccosine expression.  <a href="#ac2fcf1da78e47a4afb20e0a4e85ac7dd">More...</a><br /></td></tr>
<tr class="separator:ac2fcf1da78e47a4afb20e0a4e85ac7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a94b6eea9d24d8415703bfc07a1c05"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af5a94b6eea9d24d8415703bfc07a1c05">is_atan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:af5a94b6eea9d24d8415703bfc07a1c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an arctangent expression.  <a href="#af5a94b6eea9d24d8415703bfc07a1c05">More...</a><br /></td></tr>
<tr class="separator:af5a94b6eea9d24d8415703bfc07a1c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac54d0c8fa80bf084505f90528c9f5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4ac54d0c8fa80bf084505f90528c9f5e">is_atan2</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a4ac54d0c8fa80bf084505f90528c9f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an arctangent2 expression.  <a href="#a4ac54d0c8fa80bf084505f90528c9f5e">More...</a><br /></td></tr>
<tr class="separator:a4ac54d0c8fa80bf084505f90528c9f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66cbc3a6c390d0d04bf3839e4377850"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa66cbc3a6c390d0d04bf3839e4377850">is_sinh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aa66cbc3a6c390d0d04bf3839e4377850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a hyperbolic-sine expression.  <a href="#aa66cbc3a6c390d0d04bf3839e4377850">More...</a><br /></td></tr>
<tr class="separator:aa66cbc3a6c390d0d04bf3839e4377850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e09e7b40ee56f60a121014f02603fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a93e09e7b40ee56f60a121014f02603fb">is_cosh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a93e09e7b40ee56f60a121014f02603fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a hyperbolic-cosine expression.  <a href="#a93e09e7b40ee56f60a121014f02603fb">More...</a><br /></td></tr>
<tr class="separator:a93e09e7b40ee56f60a121014f02603fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da61282d0c5ccefeaa2068d84a19273"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9da61282d0c5ccefeaa2068d84a19273">is_tanh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a9da61282d0c5ccefeaa2068d84a19273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a hyperbolic-tangent expression.  <a href="#a9da61282d0c5ccefeaa2068d84a19273">More...</a><br /></td></tr>
<tr class="separator:a9da61282d0c5ccefeaa2068d84a19273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911dd37b6ac155198d923500bbc97135"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a911dd37b6ac155198d923500bbc97135">is_min</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a911dd37b6ac155198d923500bbc97135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a min expression.  <a href="#a911dd37b6ac155198d923500bbc97135">More...</a><br /></td></tr>
<tr class="separator:a911dd37b6ac155198d923500bbc97135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a84ca31e769b94d1adcc69789826934"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0a84ca31e769b94d1adcc69789826934">is_max</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a0a84ca31e769b94d1adcc69789826934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a max expression.  <a href="#a0a84ca31e769b94d1adcc69789826934">More...</a><br /></td></tr>
<tr class="separator:a0a84ca31e769b94d1adcc69789826934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1525a5e26f678130b369bc1414d9891a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1525a5e26f678130b369bc1414d9891a">is_ceil</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a1525a5e26f678130b369bc1414d9891a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a ceil expression.  <a href="#a1525a5e26f678130b369bc1414d9891a">More...</a><br /></td></tr>
<tr class="separator:a1525a5e26f678130b369bc1414d9891a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7a6656f58842adedcc8024b14bc06c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abc7a6656f58842adedcc8024b14bc06c">is_floor</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:abc7a6656f58842adedcc8024b14bc06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a floor expression.  <a href="#abc7a6656f58842adedcc8024b14bc06c">More...</a><br /></td></tr>
<tr class="separator:abc7a6656f58842adedcc8024b14bc06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12b990bcc72a788e6d8176894d0d8a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa12b990bcc72a788e6d8176894d0d8a2">is_if_then_else</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aa12b990bcc72a788e6d8176894d0d8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an if-then-else expression.  <a href="#aa12b990bcc72a788e6d8176894d0d8a2">More...</a><br /></td></tr>
<tr class="separator:aa12b990bcc72a788e6d8176894d0d8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c97ad4e8b82b5c045695eb76fc1256"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab6c97ad4e8b82b5c045695eb76fc1256">is_uninterpreted_function</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ab6c97ad4e8b82b5c045695eb76fc1256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an uninterpreted-function expression.  <a href="#ab6c97ad4e8b82b5c045695eb76fc1256">More...</a><br /></td></tr>
<tr class="separator:ab6c97ad4e8b82b5c045695eb76fc1256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b317498b02b74b0937f7cdb31b0ef52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1b317498b02b74b0937f7cdb31b0ef52">get_constant_value</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a1b317498b02b74b0937f7cdb31b0ef52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant value of the constant expression <code>e</code>.  <a href="#a1b317498b02b74b0937f7cdb31b0ef52">More...</a><br /></td></tr>
<tr class="separator:a1b317498b02b74b0937f7cdb31b0ef52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd6758ef1c73c0ab835a7e8c6aad187"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aebd6758ef1c73c0ab835a7e8c6aad187">get_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aebd6758ef1c73c0ab835a7e8c6aad187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the embedded variable in the variable expression <code>e</code>.  <a href="#aebd6758ef1c73c0ab835a7e8c6aad187">More...</a><br /></td></tr>
<tr class="separator:aebd6758ef1c73c0ab835a7e8c6aad187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af785f16951e394debcd11a9225ef469c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af785f16951e394debcd11a9225ef469c">get_argument</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:af785f16951e394debcd11a9225ef469c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the argument in the unary expression <code>e</code>.  <a href="#af785f16951e394debcd11a9225ef469c">More...</a><br /></td></tr>
<tr class="separator:af785f16951e394debcd11a9225ef469c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f904009d1e4f9ad6f5ed22a4e4c41b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a38f904009d1e4f9ad6f5ed22a4e4c41b">get_first_argument</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a38f904009d1e4f9ad6f5ed22a4e4c41b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first argument of the binary expression <code>e</code>.  <a href="#a38f904009d1e4f9ad6f5ed22a4e4c41b">More...</a><br /></td></tr>
<tr class="separator:a38f904009d1e4f9ad6f5ed22a4e4c41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da800513f72f528dffddd89f9263b3a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8da800513f72f528dffddd89f9263b3a">get_second_argument</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a8da800513f72f528dffddd89f9263b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the second argument of the binary expression <code>e</code>.  <a href="#a8da800513f72f528dffddd89f9263b3a">More...</a><br /></td></tr>
<tr class="separator:a8da800513f72f528dffddd89f9263b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3d5ca2b76943558837ffa2a47162e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#afe3d5ca2b76943558837ffa2a47162e1">get_constant_in_addition</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:afe3d5ca2b76943558837ffa2a47162e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant part of the addition expression <code>e</code>.  <a href="#afe3d5ca2b76943558837ffa2a47162e1">More...</a><br /></td></tr>
<tr class="separator:afe3d5ca2b76943558837ffa2a47162e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20be18c2d4942e2e64987a30c7e37c1d"><td class="memItemLeft" align="right" valign="top">const std::map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a20be18c2d4942e2e64987a30c7e37c1d">get_expr_to_coeff_map_in_addition</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a20be18c2d4942e2e64987a30c7e37c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map from an expression to its coefficient in the addition expression <code>e</code>.  <a href="#a20be18c2d4942e2e64987a30c7e37c1d">More...</a><br /></td></tr>
<tr class="separator:a20be18c2d4942e2e64987a30c7e37c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56c1d979ba67b0eceaac7f0ba54235c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af56c1d979ba67b0eceaac7f0ba54235c">get_constant_in_multiplication</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:af56c1d979ba67b0eceaac7f0ba54235c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant part of the multiplication expression <code>e</code>.  <a href="#af56c1d979ba67b0eceaac7f0ba54235c">More...</a><br /></td></tr>
<tr class="separator:af56c1d979ba67b0eceaac7f0ba54235c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffaee70b54f60b4d1b9f1771f78ddf7"><td class="memItemLeft" align="right" valign="top">const std::map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acffaee70b54f60b4d1b9f1771f78ddf7">get_base_to_exponent_map_in_multiplication</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:acffaee70b54f60b4d1b9f1771f78ddf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map from a base expression to its exponent expression in the multiplication expression <code>e</code>.  <a href="#acffaee70b54f60b4d1b9f1771f78ddf7">More...</a><br /></td></tr>
<tr class="separator:acffaee70b54f60b4d1b9f1771f78ddf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901d5aa27994e415a1eb4145968dc25c"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a901d5aa27994e415a1eb4145968dc25c">get_uninterpreted_function_name</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a901d5aa27994e415a1eb4145968dc25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of an uninterpreted-function expression <code>e</code>.  <a href="#a901d5aa27994e415a1eb4145968dc25c">More...</a><br /></td></tr>
<tr class="separator:a901d5aa27994e415a1eb4145968dc25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374ac54710c8173da5ca4b2d7eeec520"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a374ac54710c8173da5ca4b2d7eeec520">get_uninterpreted_function_arguments</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a374ac54710c8173da5ca4b2d7eeec520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the arguments of an uninterpreted-function expression <code>e</code>.  <a href="#a374ac54710c8173da5ca4b2d7eeec520">More...</a><br /></td></tr>
<tr class="separator:a374ac54710c8173da5ca4b2d7eeec520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251f0e1c8ae1894d0a09ccaeb5e79a41"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a251f0e1c8ae1894d0a09ccaeb5e79a41">get_conditional_formula</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a251f0e1c8ae1894d0a09ccaeb5e79a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conditional formula in the if-then-else expression <code>e</code>.  <a href="#a251f0e1c8ae1894d0a09ccaeb5e79a41">More...</a><br /></td></tr>
<tr class="separator:a251f0e1c8ae1894d0a09ccaeb5e79a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd312bc518c0dd20a656021aef3e3c37"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abd312bc518c0dd20a656021aef3e3c37">get_then_expression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:abd312bc518c0dd20a656021aef3e3c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 'then' expression in the if-then-else expression <code>e</code>.  <a href="#abd312bc518c0dd20a656021aef3e3c37">More...</a><br /></td></tr>
<tr class="separator:abd312bc518c0dd20a656021aef3e3c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a1c7093f3e8d89930f0aa748ee188c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae1a1c7093f3e8d89930f0aa748ee188c">get_else_expression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ae1a1c7093f3e8d89930f0aa748ee188c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 'else' expression in the if-then-else expression <code>e</code>.  <a href="#ae1a1c7093f3e8d89930f0aa748ee188c">More...</a><br /></td></tr>
<tr class="separator:ae1a1c7093f3e8d89930f0aa748ee188c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9084a43cdfa02b10cb216c7bfff0dcb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9084a43cdfa02b10cb216c7bfff0dcb3">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="separator:a9084a43cdfa02b10cb216c7bfff0dcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac306b9a9b7ace256330ae3ab8deaafef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac306b9a9b7ace256330ae3ab8deaafef">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="separator:ac306b9a9b7ace256330ae3ab8deaafef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2857d827b306fc80cf6c23e14f211c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aed2857d827b306fc80cf6c23e14f211c">TaylorExpand</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;f, const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;a, <a class="el" href="classint.html">int</a> order)</td></tr>
<tr class="memdesc:aed2857d827b306fc80cf6c23e14f211c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Taylor series expansion of <code>f</code> around <code>a</code> of order <code>order</code>.  <a href="#aed2857d827b306fc80cf6c23e14f211c">More...</a><br /></td></tr>
<tr class="separator:aed2857d827b306fc80cf6c23e14f211c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7acc3dc6f322c6b123be2165123b25"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:a6c7acc3dc6f322c6b123be2165123b25"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, <a class="el" href="classdouble.html">double</a> &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6c7acc3dc6f322c6b123be2165123b25">operator *</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:a6c7acc3dc6f322c6b123be2165123b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following matrix operations:  <a href="#a6c7acc3dc6f322c6b123be2165123b25">More...</a><br /></td></tr>
<tr class="separator:a6c7acc3dc6f322c6b123be2165123b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e74ffdcbc8c474503d2a3249df15b54"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:a1e74ffdcbc8c474503d2a3249df15b54"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, <a class="el" href="classdouble.html">double</a> &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1e74ffdcbc8c474503d2a3249df15b54">operator *</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:a1e74ffdcbc8c474503d2a3249df15b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following matrix operations:  <a href="#a1e74ffdcbc8c474503d2a3249df15b54">More...</a><br /></td></tr>
<tr class="separator:a1e74ffdcbc8c474503d2a3249df15b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeec5ad743203c7161bd07bbb00dd96b"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:aaeec5ad743203c7161bd07bbb00dd96b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aaeec5ad743203c7161bd07bbb00dd96b">operator *</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:aaeec5ad743203c7161bd07bbb00dd96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following matrix operations:  <a href="#aaeec5ad743203c7161bd07bbb00dd96b">More...</a><br /></td></tr>
<tr class="separator:aaeec5ad743203c7161bd07bbb00dd96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36042c0cb53373d2a578f0734b1acd47"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:a36042c0cb53373d2a578f0734b1acd47"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a36042c0cb53373d2a578f0734b1acd47">operator *</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:a36042c0cb53373d2a578f0734b1acd47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following matrix operations:  <a href="#a36042c0cb53373d2a578f0734b1acd47">More...</a><br /></td></tr>
<tr class="separator:a36042c0cb53373d2a578f0734b1acd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d832cf6612451c3eaa079df9ef8ec9"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:af0d832cf6612451c3eaa079df9ef8ec9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, <a class="el" href="classdouble.html">double</a> &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af0d832cf6612451c3eaa079df9ef8ec9">operator *</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:af0d832cf6612451c3eaa079df9ef8ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following matrix operations:  <a href="#af0d832cf6612451c3eaa079df9ef8ec9">More...</a><br /></td></tr>
<tr class="separator:af0d832cf6612451c3eaa079df9ef8ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6895bc9ae9e9e84f8f6a9bbc434b4e9"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:ae6895bc9ae9e9e84f8f6a9bbc434b4e9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, <a class="el" href="classdouble.html">double</a> &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae6895bc9ae9e9e84f8f6a9bbc434b4e9">operator *</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:ae6895bc9ae9e9e84f8f6a9bbc434b4e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following matrix operations:  <a href="#ae6895bc9ae9e9e84f8f6a9bbc434b4e9">More...</a><br /></td></tr>
<tr class="separator:ae6895bc9ae9e9e84f8f6a9bbc434b4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b295edb3a60b6a961bbc6f42e24547"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:a99b295edb3a60b6a961bbc6f42e24547"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a99b295edb3a60b6a961bbc6f42e24547">operator *</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:a99b295edb3a60b6a961bbc6f42e24547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following matrix operations:  <a href="#a99b295edb3a60b6a961bbc6f42e24547">More...</a><br /></td></tr>
<tr class="separator:a99b295edb3a60b6a961bbc6f42e24547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee491180204fc8aa2b1c73da8ca18b85"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:aee491180204fc8aa2b1c73da8ca18b85"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt; &amp;&amp;std::is_same_v&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&amp;std::is_same_v&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, internal::ExpressionMatMulResult&lt; MatrixL, MatrixR &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aee491180204fc8aa2b1c73da8ca18b85">operator *</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:aee491180204fc8aa2b1c73da8ca18b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following matrix operations:  <a href="#aee491180204fc8aa2b1c73da8ca18b85">More...</a><br /></td></tr>
<tr class="separator:aee491180204fc8aa2b1c73da8ca18b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac78e96efaa07849f158591192b2dca"><td class="memTemplParams" colspan="2">template&lt;int Dim, int LhsMode, int RhsMode, int LhsOptions, int RhsOptions&gt; </td></tr>
<tr class="memitem:adac78e96efaa07849f158591192b2dca"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#adac78e96efaa07849f158591192b2dca">operator *</a> (const Eigen::Transform&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Dim, LhsMode, LhsOptions &gt; &amp;t1, const Eigen::Transform&lt; <a class="el" href="classdouble.html">double</a>, Dim, RhsMode, RhsOptions &gt; &amp;t2)</td></tr>
<tr class="memdesc:adac78e96efaa07849f158591192b2dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform&lt;double&gt; * Transform&lt;Expression&gt; =&gt; Transform&lt;Expression&gt;  <a href="#adac78e96efaa07849f158591192b2dca">More...</a><br /></td></tr>
<tr class="separator:adac78e96efaa07849f158591192b2dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac410f7e82c9d06e796d7fcb4508f5e4"><td class="memTemplParams" colspan="2">template&lt;int Dim, int LhsMode, int RhsMode, int LhsOptions, int RhsOptions&gt; </td></tr>
<tr class="memitem:aac410f7e82c9d06e796d7fcb4508f5e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aac410f7e82c9d06e796d7fcb4508f5e4">operator *</a> (const Eigen::Transform&lt; <a class="el" href="classdouble.html">double</a>, Dim, LhsMode, LhsOptions &gt; &amp;t1, const Eigen::Transform&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Dim, RhsMode, RhsOptions &gt; &amp;t2)</td></tr>
<tr class="memdesc:aac410f7e82c9d06e796d7fcb4508f5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform&lt;Expression&gt; * Transform&lt;double&gt; =&gt; Transform&lt;Expression&gt;  <a href="#aac410f7e82c9d06e796d7fcb4508f5e4">More...</a><br /></td></tr>
<tr class="separator:aac410f7e82c9d06e796d7fcb4508f5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71af97c3ebea42d1b33aa8a41b975d0e"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a71af97c3ebea42d1b33aa8a41b975d0e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, <a class="el" href="namespacedrake.html#aaadcdc21cc0c381e5879b1b7f023d82d">MatrixLikewise</a>&lt; <a class="el" href="classdouble.html">double</a>, Derived &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a71af97c3ebea42d1b33aa8a41b975d0e">Evaluate</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;env=<a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a>{}, <a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *random_generator=nullptr)</td></tr>
<tr class="memdesc:a71af97c3ebea42d1b33aa8a41b975d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a symbolic matrix <code>m</code> using <code>env</code> and <code>random_generator</code>.  <a href="#a71af97c3ebea42d1b33aa8a41b975d0e">More...</a><br /></td></tr>
<tr class="separator:a71af97c3ebea42d1b33aa8a41b975d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0355c03127b4d0312e5f761a0f530a"><td class="memItemLeft" align="right" valign="top">Eigen::SparseMatrix&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8f0355c03127b4d0312e5f761a0f530a">Evaluate</a> (const Eigen::Ref&lt; const Eigen::SparseMatrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;m, const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;env=<a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a>{})</td></tr>
<tr class="memdesc:a8f0355c03127b4d0312e5f761a0f530a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates <code>m</code> using a given environment (by default, an empty environment).  <a href="#a8f0355c03127b4d0312e5f761a0f530a">More...</a><br /></td></tr>
<tr class="separator:a8f0355c03127b4d0312e5f761a0f530a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf922c7aec2a7797cc4c9c22dcdada1f"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:acf922c7aec2a7797cc4c9c22dcdada1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#aaadcdc21cc0c381e5879b1b7f023d82d">MatrixLikewise</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acf922c7aec2a7797cc4c9c22dcdada1f">Substitute</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const <a class="el" href="namespacedrake_1_1symbolic.html#acbfe43d34e6c71c503d4de11da53bbb7">Substitution</a> &amp;subst)</td></tr>
<tr class="memdesc:acf922c7aec2a7797cc4c9c22dcdada1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes a symbolic matrix <code>m</code> using a given substitution <code>subst</code>.  <a href="#acf922c7aec2a7797cc4c9c22dcdada1f">More...</a><br /></td></tr>
<tr class="separator:acf922c7aec2a7797cc4c9c22dcdada1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a16b2f5eca5672442bb9dc25be825c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aa1a16b2f5eca5672442bb9dc25be825c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#aaadcdc21cc0c381e5879b1b7f023d82d">MatrixLikewise</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa1a16b2f5eca5672442bb9dc25be825c">Substitute</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aa1a16b2f5eca5672442bb9dc25be825c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes <code>var</code> with <code>e</code> in a symbolic matrix <code>m</code>.  <a href="#aa1a16b2f5eca5672442bb9dc25be825c">More...</a><br /></td></tr>
<tr class="separator:aa1a16b2f5eca5672442bb9dc25be825c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9d66ba97f4b64c29eafee3b952fb9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aeb9d66ba97f4b64c29eafee3b952fb9c">GetVariableVector</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;expressions)</td></tr>
<tr class="memdesc:aeb9d66ba97f4b64c29eafee3b952fb9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a vector of variables from the vector of variable expressions.  <a href="#aeb9d66ba97f4b64c29eafee3b952fb9c">More...</a><br /></td></tr>
<tr class="separator:aeb9d66ba97f4b64c29eafee3b952fb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f56048cec3e53d98346a36df54a006"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad0f56048cec3e53d98346a36df54a006">Jacobian</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;f, const std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:ad0f56048cec3e53d98346a36df54a006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian matrix J of the vector function <code>f</code> with respect to <code>vars</code>.  <a href="#ad0f56048cec3e53d98346a36df54a006">More...</a><br /></td></tr>
<tr class="separator:ad0f56048cec3e53d98346a36df54a006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a3b8e65cfeb6d57deb7fe9d70f1d4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a71a3b8e65cfeb6d57deb7fe9d70f1d4d">Jacobian</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;f, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;vars)</td></tr>
<tr class="memdesc:a71a3b8e65cfeb6d57deb7fe9d70f1d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian matrix J of the vector function <code>f</code> with respect to <code>vars</code>.  <a href="#a71a3b8e65cfeb6d57deb7fe9d70f1d4d">More...</a><br /></td></tr>
<tr class="separator:a71a3b8e65cfeb6d57deb7fe9d70f1d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ebc87f878cdb6a3f0339711d591a26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab1ebc87f878cdb6a3f0339711d591a26">GetDistinctVariables</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;v)</td></tr>
<tr class="memdesc:ab1ebc87f878cdb6a3f0339711d591a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distinct variables in the matrix of expressions.  <a href="#ab1ebc87f878cdb6a3f0339711d591a26">More...</a><br /></td></tr>
<tr class="separator:ab1ebc87f878cdb6a3f0339711d591a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c13478861afcc48abcec64900b0c66"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:ac3c13478861afcc48abcec64900b0c66"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_base_of_v&lt; Eigen::MatrixBase&lt; DerivedA &gt;, DerivedA &gt; &amp;&amp;std::is_base_of_v&lt; Eigen::MatrixBase&lt; DerivedB &gt;, DerivedB &gt; &amp;&amp;std::is_same_v&lt; typename DerivedA::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&amp;std::is_same_v&lt; typename DerivedB::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac3c13478861afcc48abcec64900b0c66">CheckStructuralEquality</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:ac3c13478861afcc48abcec64900b0c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two Eigen::Matrix&lt;Expression&gt; <code>m1</code> and <code>m2</code> are structurally equal.  <a href="#ac3c13478861afcc48abcec64900b0c66">More...</a><br /></td></tr>
<tr class="separator:ac3c13478861afcc48abcec64900b0c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0aaf128d1ed75cbab9c4ca238e0ae6c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad0aaf128d1ed75cbab9c4ca238e0ae6c">is_integer</a> (<a class="el" href="classdouble.html">double</a> v)</td></tr>
<tr class="separator:ad0aaf128d1ed75cbab9c4ca238e0ae6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859d0e7196b00ffd99a347ff8a7d4d76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a859d0e7196b00ffd99a347ff8a7d4d76">is_positive_integer</a> (<a class="el" href="classdouble.html">double</a> v)</td></tr>
<tr class="separator:a859d0e7196b00ffd99a347ff8a7d4d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0169dcd3572d7e3c626f154d1db8b7a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0169dcd3572d7e3c626f154d1db8b7a3">is_non_negative_integer</a> (<a class="el" href="classdouble.html">double</a> v)</td></tr>
<tr class="separator:a0169dcd3572d7e3c626f154d1db8b7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2196a9e544a94c2e7c277b18c7b7716b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2196a9e544a94c2e7c277b18c7b7716b">is_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a2196a9e544a94c2e7c277b18c7b7716b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a variable expression.  <a href="#a2196a9e544a94c2e7c277b18c7b7716b">More...</a><br /></td></tr>
<tr class="separator:a2196a9e544a94c2e7c277b18c7b7716b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac919050a36dacd7f943da0813c91f400"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac919050a36dacd7f943da0813c91f400">is_unary</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:ac919050a36dacd7f943da0813c91f400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a unary expression.  <a href="#ac919050a36dacd7f943da0813c91f400">More...</a><br /></td></tr>
<tr class="separator:ac919050a36dacd7f943da0813c91f400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82da118fd73ba6ccc41e3eb2f00125b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab82da118fd73ba6ccc41e3eb2f00125b">is_binary</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:ab82da118fd73ba6ccc41e3eb2f00125b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a binary expression.  <a href="#ab82da118fd73ba6ccc41e3eb2f00125b">More...</a><br /></td></tr>
<tr class="separator:ab82da118fd73ba6ccc41e3eb2f00125b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9dfc929a3e771ece5e5d20312e96abd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae9dfc929a3e771ece5e5d20312e96abd">is_addition</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:ae9dfc929a3e771ece5e5d20312e96abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an addition expression.  <a href="#ae9dfc929a3e771ece5e5d20312e96abd">More...</a><br /></td></tr>
<tr class="separator:ae9dfc929a3e771ece5e5d20312e96abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a56ae8b296df9d9285c93e00b82dc7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a19a56ae8b296df9d9285c93e00b82dc7">is_multiplication</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a19a56ae8b296df9d9285c93e00b82dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an multiplication expression.  <a href="#a19a56ae8b296df9d9285c93e00b82dc7">More...</a><br /></td></tr>
<tr class="separator:a19a56ae8b296df9d9285c93e00b82dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1eddc430d6a33fc13db8d53a51bdfd3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac1eddc430d6a33fc13db8d53a51bdfd3">is_division</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:ac1eddc430d6a33fc13db8d53a51bdfd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a division expression.  <a href="#ac1eddc430d6a33fc13db8d53a51bdfd3">More...</a><br /></td></tr>
<tr class="separator:ac1eddc430d6a33fc13db8d53a51bdfd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee17d0564b198d4c784811945707ddbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aee17d0564b198d4c784811945707ddbf">is_log</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:aee17d0564b198d4c784811945707ddbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a log expression.  <a href="#aee17d0564b198d4c784811945707ddbf">More...</a><br /></td></tr>
<tr class="separator:aee17d0564b198d4c784811945707ddbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6c5829257cf5c28c162ffad2bd3f58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8e6c5829257cf5c28c162ffad2bd3f58">is_abs</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a8e6c5829257cf5c28c162ffad2bd3f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an absolute-value-function expression.  <a href="#a8e6c5829257cf5c28c162ffad2bd3f58">More...</a><br /></td></tr>
<tr class="separator:a8e6c5829257cf5c28c162ffad2bd3f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1633315c1c26cbd8411a7ea0d860a9c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1633315c1c26cbd8411a7ea0d860a9c2">is_exp</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a1633315c1c26cbd8411a7ea0d860a9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an exp expression.  <a href="#a1633315c1c26cbd8411a7ea0d860a9c2">More...</a><br /></td></tr>
<tr class="separator:a1633315c1c26cbd8411a7ea0d860a9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a645e5342fb66cd3fc7de8c38eac6b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6a645e5342fb66cd3fc7de8c38eac6b4">is_sqrt</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a6a645e5342fb66cd3fc7de8c38eac6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a square-root expression.  <a href="#a6a645e5342fb66cd3fc7de8c38eac6b4">More...</a><br /></td></tr>
<tr class="separator:a6a645e5342fb66cd3fc7de8c38eac6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae3c8118eef15cc3a9dafe14c6d48c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1ae3c8118eef15cc3a9dafe14c6d48c2">is_pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a1ae3c8118eef15cc3a9dafe14c6d48c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a power-function expression.  <a href="#a1ae3c8118eef15cc3a9dafe14c6d48c2">More...</a><br /></td></tr>
<tr class="separator:a1ae3c8118eef15cc3a9dafe14c6d48c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790f1dea22ffa64d7c75849403aae060"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a790f1dea22ffa64d7c75849403aae060">is_sin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a790f1dea22ffa64d7c75849403aae060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a sine expression.  <a href="#a790f1dea22ffa64d7c75849403aae060">More...</a><br /></td></tr>
<tr class="separator:a790f1dea22ffa64d7c75849403aae060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78259c13b2add79a1ad23e2cc8f5b314"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a78259c13b2add79a1ad23e2cc8f5b314">is_cos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a78259c13b2add79a1ad23e2cc8f5b314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a cosine expression.  <a href="#a78259c13b2add79a1ad23e2cc8f5b314">More...</a><br /></td></tr>
<tr class="separator:a78259c13b2add79a1ad23e2cc8f5b314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eaf3f36c1f3fdf51121f77083894794"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7eaf3f36c1f3fdf51121f77083894794">is_tan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a7eaf3f36c1f3fdf51121f77083894794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a tangent expression.  <a href="#a7eaf3f36c1f3fdf51121f77083894794">More...</a><br /></td></tr>
<tr class="separator:a7eaf3f36c1f3fdf51121f77083894794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f6cc91aa5d1f9133526887cec35cd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab3f6cc91aa5d1f9133526887cec35cd4">is_asin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:ab3f6cc91aa5d1f9133526887cec35cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an arcsine expression.  <a href="#ab3f6cc91aa5d1f9133526887cec35cd4">More...</a><br /></td></tr>
<tr class="separator:ab3f6cc91aa5d1f9133526887cec35cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70b034dae56512552b00315c20edaf4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa70b034dae56512552b00315c20edaf4">is_acos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:aa70b034dae56512552b00315c20edaf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an arccosine expression.  <a href="#aa70b034dae56512552b00315c20edaf4">More...</a><br /></td></tr>
<tr class="separator:aa70b034dae56512552b00315c20edaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4927daffb66b9bd137c174d41d94444"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae4927daffb66b9bd137c174d41d94444">is_atan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:ae4927daffb66b9bd137c174d41d94444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an arctangent expression.  <a href="#ae4927daffb66b9bd137c174d41d94444">More...</a><br /></td></tr>
<tr class="separator:ae4927daffb66b9bd137c174d41d94444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb998316cfc15506d72b2f2843b4fa62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acb998316cfc15506d72b2f2843b4fa62">is_atan2</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:acb998316cfc15506d72b2f2843b4fa62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a arctangent2 expression.  <a href="#acb998316cfc15506d72b2f2843b4fa62">More...</a><br /></td></tr>
<tr class="separator:acb998316cfc15506d72b2f2843b4fa62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0373300d4207624b99351d0f7c347b85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0373300d4207624b99351d0f7c347b85">is_sinh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a0373300d4207624b99351d0f7c347b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a hyperbolic-sine expression.  <a href="#a0373300d4207624b99351d0f7c347b85">More...</a><br /></td></tr>
<tr class="separator:a0373300d4207624b99351d0f7c347b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9729350280d57ceaa1fd4c01c46ab48c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9729350280d57ceaa1fd4c01c46ab48c">is_cosh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a9729350280d57ceaa1fd4c01c46ab48c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a hyperbolic-cosine expression.  <a href="#a9729350280d57ceaa1fd4c01c46ab48c">More...</a><br /></td></tr>
<tr class="separator:a9729350280d57ceaa1fd4c01c46ab48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06c87629b60cbdc34b8e2a9f715cd41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac06c87629b60cbdc34b8e2a9f715cd41">is_tanh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:ac06c87629b60cbdc34b8e2a9f715cd41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a hyperbolic-tangent expression.  <a href="#ac06c87629b60cbdc34b8e2a9f715cd41">More...</a><br /></td></tr>
<tr class="separator:ac06c87629b60cbdc34b8e2a9f715cd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429537da181b9861e8e1b51648691059"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a429537da181b9861e8e1b51648691059">is_min</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a429537da181b9861e8e1b51648691059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a min expression.  <a href="#a429537da181b9861e8e1b51648691059">More...</a><br /></td></tr>
<tr class="separator:a429537da181b9861e8e1b51648691059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409d972b3926adbbb031a5c3aef3d153"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a409d972b3926adbbb031a5c3aef3d153">is_max</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a409d972b3926adbbb031a5c3aef3d153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a max expression.  <a href="#a409d972b3926adbbb031a5c3aef3d153">More...</a><br /></td></tr>
<tr class="separator:a409d972b3926adbbb031a5c3aef3d153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358f01574b969ec8e0b75498929b9d95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a358f01574b969ec8e0b75498929b9d95">is_ceil</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a358f01574b969ec8e0b75498929b9d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a ceil expression.  <a href="#a358f01574b969ec8e0b75498929b9d95">More...</a><br /></td></tr>
<tr class="separator:a358f01574b969ec8e0b75498929b9d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568d4712bfb6ef78d4908efce797ebd2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a568d4712bfb6ef78d4908efce797ebd2">is_floor</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a568d4712bfb6ef78d4908efce797ebd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a floor expression.  <a href="#a568d4712bfb6ef78d4908efce797ebd2">More...</a><br /></td></tr>
<tr class="separator:a568d4712bfb6ef78d4908efce797ebd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9473fec0f5aba36ac7c89281bf4d524"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af9473fec0f5aba36ac7c89281bf4d524">is_if_then_else</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:af9473fec0f5aba36ac7c89281bf4d524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an if-then-else expression.  <a href="#af9473fec0f5aba36ac7c89281bf4d524">More...</a><br /></td></tr>
<tr class="separator:af9473fec0f5aba36ac7c89281bf4d524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47a95b03c275d9687461839c5612472"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa47a95b03c275d9687461839c5612472">is_uninterpreted_function</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:aa47a95b03c275d9687461839c5612472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an uninterpreted-function expression.  <a href="#aa47a95b03c275d9687461839c5612472">More...</a><br /></td></tr>
<tr class="separator:aa47a95b03c275d9687461839c5612472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b5e99a86a85837124c6a006f7ec60a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a70b5e99a86a85837124c6a006f7ec60a">operator&lt;</a> (<a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91">ExpressionKind</a> k1, <a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91">ExpressionKind</a> k2)</td></tr>
<tr class="memdesc:a70b5e99a86a85837124c6a006f7ec60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total ordering between ExpressionKinds.  <a href="#a70b5e99a86a85837124c6a006f7ec60a">More...</a><br /></td></tr>
<tr class="separator:a70b5e99a86a85837124c6a006f7ec60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a61c45c20176e91159639186b26e35e"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Visitor , typename... Args&gt; </td></tr>
<tr class="memitem:a0a61c45c20176e91159639186b26e35e"><td class="memTemplItemLeft" align="right" valign="top">Result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0a61c45c20176e91159639186b26e35e">VisitPolynomial</a> (Visitor *v, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a0a61c45c20176e91159639186b26e35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls visitor object <code>v</code> with a polynomial symbolic-expression <code>e</code>, and arguments <code>args</code>.  <a href="#a0a61c45c20176e91159639186b26e35e">More...</a><br /></td></tr>
<tr class="separator:a0a61c45c20176e91159639186b26e35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58092344918003fc7e186b1c57bbc7f"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Visitor , typename... Args&gt; </td></tr>
<tr class="memitem:ab58092344918003fc7e186b1c57bbc7f"><td class="memTemplItemLeft" align="right" valign="top">Result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab58092344918003fc7e186b1c57bbc7f">VisitExpression</a> (Visitor *v, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab58092344918003fc7e186b1c57bbc7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls visitor object <code>v</code> with a symbolic-expression <code>e</code>, and arguments <code>args</code>.  <a href="#ab58092344918003fc7e186b1c57bbc7f">More...</a><br /></td></tr>
<tr class="separator:ab58092344918003fc7e186b1c57bbc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1245bbf1795b4f97ec4c04cd79dcde3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad1245bbf1795b4f97ec4c04cd79dcde3">operator&lt;</a> (<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a> k1, <a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a> k2)</td></tr>
<tr class="separator:ad1245bbf1795b4f97ec4c04cd79dcde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6d2ea09c3aa020cf408bc9472ec9eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1c6d2ea09c3aa020cf408bc9472ec9eb">forall</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a1c6d2ea09c3aa020cf408bc9472ec9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a formula <code>f</code>, universally quantified by variables <code>vars</code>.  <a href="#a1c6d2ea09c3aa020cf408bc9472ec9eb">More...</a><br /></td></tr>
<tr class="separator:a1c6d2ea09c3aa020cf408bc9472ec9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aaadf953e1753ea5c2ff78a3bb030ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5aaadf953e1753ea5c2ff78a3bb030ec">make_conjunction</a> (const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp;formulas)</td></tr>
<tr class="memdesc:a5aaadf953e1753ea5c2ff78a3bb030ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a conjunction of <code>formulas</code>.  <a href="#a5aaadf953e1753ea5c2ff78a3bb030ec">More...</a><br /></td></tr>
<tr class="separator:a5aaadf953e1753ea5c2ff78a3bb030ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e40924c21a4f08a5cc274eaf7ddebd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a71e40924c21a4f08a5cc274eaf7ddebd">operator &amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f1, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f2)</td></tr>
<tr class="separator:a71e40924c21a4f08a5cc274eaf7ddebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39da4f4e5f916079f201f92852399f45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a39da4f4e5f916079f201f92852399f45">operator &amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="separator:a39da4f4e5f916079f201f92852399f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea3ce465525b0c357d1c5115e49a626"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aaea3ce465525b0c357d1c5115e49a626">operator &amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="separator:aaea3ce465525b0c357d1c5115e49a626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4758fb8f36a1a85b9fa932003216fe2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4758fb8f36a1a85b9fa932003216fe2e">operator &amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v1, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v2)</td></tr>
<tr class="separator:a4758fb8f36a1a85b9fa932003216fe2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6dff8519d02993c6699ddb3ebb28cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#afc6dff8519d02993c6699ddb3ebb28cf">make_disjunction</a> (const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp;formulas)</td></tr>
<tr class="memdesc:afc6dff8519d02993c6699ddb3ebb28cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a disjunction of <code>formulas</code>.  <a href="#afc6dff8519d02993c6699ddb3ebb28cf">More...</a><br /></td></tr>
<tr class="separator:afc6dff8519d02993c6699ddb3ebb28cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600c585cf975dd9a8dd94b118f0bd161"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a600c585cf975dd9a8dd94b118f0bd161">operator||</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f1, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f2)</td></tr>
<tr class="separator:a600c585cf975dd9a8dd94b118f0bd161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41223d30845a91ba757f6277ad8f8a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac41223d30845a91ba757f6277ad8f8a1">operator||</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="separator:ac41223d30845a91ba757f6277ad8f8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc2f3979d06df08b80d2b280b9728c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aafc2f3979d06df08b80d2b280b9728c7">operator||</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="separator:aafc2f3979d06df08b80d2b280b9728c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237ee4f068e65a6a4614af59482889eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a237ee4f068e65a6a4614af59482889eb">operator||</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v1, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v2)</td></tr>
<tr class="separator:a237ee4f068e65a6a4614af59482889eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489c472556030b17c10028a04ba70aad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a489c472556030b17c10028a04ba70aad">operator!</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="separator:a489c472556030b17c10028a04ba70aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f34a1136227779b18433cd0a2f4dde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac9f34a1136227779b18433cd0a2f4dde">operator!</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="separator:ac9f34a1136227779b18433cd0a2f4dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463b86323b82db42856d70b2537759e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a463b86323b82db42856d70b2537759e3">operator==</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:a463b86323b82db42856d70b2537759e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c1c4bfd4434de52e240126b78853c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac5c1c4bfd4434de52e240126b78853c0">operator!=</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:ac5c1c4bfd4434de52e240126b78853c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad84d6691fb2bf9627d894d56b8ef6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0ad84d6691fb2bf9627d894d56b8ef6f">operator&lt;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:a0ad84d6691fb2bf9627d894d56b8ef6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba9db65867379d7603eeaeb9be56451"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aaba9db65867379d7603eeaeb9be56451">operator&lt;=</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:aaba9db65867379d7603eeaeb9be56451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a12a5db3a9b2e8520e002e437354717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5a12a5db3a9b2e8520e002e437354717">operator&gt;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:a5a12a5db3a9b2e8520e002e437354717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642d11dbe47e027614a5a3bcfe12d34e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a642d11dbe47e027614a5a3bcfe12d34e">operator&gt;=</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:a642d11dbe47e027614a5a3bcfe12d34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66d112b9b6d693ee82d08c7a01f7a14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac66d112b9b6d693ee82d08c7a01f7a14">isnan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ac66d112b9b6d693ee82d08c7a01f7a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a> for the predicate isnan(e) to the given expression.  <a href="#ac66d112b9b6d693ee82d08c7a01f7a14">More...</a><br /></td></tr>
<tr class="separator:ac66d112b9b6d693ee82d08c7a01f7a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac460ea048a6b4cddcaf88672a6abcf46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac460ea048a6b4cddcaf88672a6abcf46">isinf</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ac460ea048a6b4cddcaf88672a6abcf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a> determining if the given expression <code>e</code> is a positive or negative infinity.  <a href="#ac460ea048a6b4cddcaf88672a6abcf46">More...</a><br /></td></tr>
<tr class="separator:ac460ea048a6b4cddcaf88672a6abcf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fbe2690e2170be14656811a9d860d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa9fbe2690e2170be14656811a9d860d5">isfinite</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aa9fbe2690e2170be14656811a9d860d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a> determining if the given expression <code>e</code> has a finite value.  <a href="#aa9fbe2690e2170be14656811a9d860d5">More...</a><br /></td></tr>
<tr class="separator:aa9fbe2690e2170be14656811a9d860d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648f540fa40e1e281133b972e394574a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a648f540fa40e1e281133b972e394574a">positive_semidefinite</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;m)</td></tr>
<tr class="memdesc:a648f540fa40e1e281133b972e394574a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula constraining <code>m</code> to be a positive-semidefinite matrix.  <a href="#a648f540fa40e1e281133b972e394574a">More...</a><br /></td></tr>
<tr class="separator:a648f540fa40e1e281133b972e394574a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514b594b37dbb603af40803e175b5f6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a514b594b37dbb603af40803e175b5f6a">positive_semidefinite</a> (const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;m, Eigen::UpLoType mode)</td></tr>
<tr class="memdesc:a514b594b37dbb603af40803e175b5f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a symbolic positive-semidefinite formula from <code>m</code>.  <a href="#a514b594b37dbb603af40803e175b5f6a">More...</a><br /></td></tr>
<tr class="separator:a514b594b37dbb603af40803e175b5f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097b1381843c0314529765995289c063"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a097b1381843c0314529765995289c063"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a097b1381843c0314529765995289c063">positive_semidefinite</a> (const Eigen::TriangularView&lt; Derived, Eigen::Lower &gt; &amp;l)</td></tr>
<tr class="memdesc:a097b1381843c0314529765995289c063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a symbolic positive-semidefinite formula from a lower triangular-view <code>l</code>.  <a href="#a097b1381843c0314529765995289c063">More...</a><br /></td></tr>
<tr class="separator:a097b1381843c0314529765995289c063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2c6f4240ba42744712ab5f5c73c1db"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a2b2c6f4240ba42744712ab5f5c73c1db"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2b2c6f4240ba42744712ab5f5c73c1db">positive_semidefinite</a> (const Eigen::TriangularView&lt; Derived, Eigen::Upper &gt; &amp;u)</td></tr>
<tr class="memdesc:a2b2c6f4240ba42744712ab5f5c73c1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a symbolic positive-semidefinite formula from an upper triangular-view <code>u</code>.  <a href="#a2b2c6f4240ba42744712ab5f5c73c1db">More...</a><br /></td></tr>
<tr class="separator:a2b2c6f4240ba42744712ab5f5c73c1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c794bfc916c077b16d9c7d47031f68c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3c794bfc916c077b16d9c7d47031f68c">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="separator:a3c794bfc916c077b16d9c7d47031f68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3821701f71cdfe8c9fbb277e017b384d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3821701f71cdfe8c9fbb277e017b384d">is_false</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a3821701f71cdfe8c9fbb277e017b384d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is structurally equal to False formula.  <a href="#a3821701f71cdfe8c9fbb277e017b384d">More...</a><br /></td></tr>
<tr class="separator:a3821701f71cdfe8c9fbb277e017b384d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a71b252df5a615ff80f712e2983ab53"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1a71b252df5a615ff80f712e2983ab53">is_true</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a1a71b252df5a615ff80f712e2983ab53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is structurally equal to True formula.  <a href="#a1a71b252df5a615ff80f712e2983ab53">More...</a><br /></td></tr>
<tr class="separator:a1a71b252df5a615ff80f712e2983ab53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571adc7bcdc056eec761a657f9354cd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a571adc7bcdc056eec761a657f9354cd7">is_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a571adc7bcdc056eec761a657f9354cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a variable formula.  <a href="#a571adc7bcdc056eec761a657f9354cd7">More...</a><br /></td></tr>
<tr class="separator:a571adc7bcdc056eec761a657f9354cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff01b0d18262c1673124bd659870a3a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aff01b0d18262c1673124bd659870a3a4">is_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:aff01b0d18262c1673124bd659870a3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing equality (==).  <a href="#aff01b0d18262c1673124bd659870a3a4">More...</a><br /></td></tr>
<tr class="separator:aff01b0d18262c1673124bd659870a3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf5f88e2f5295758117375a30de6386"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1cf5f88e2f5295758117375a30de6386">is_not_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a1cf5f88e2f5295758117375a30de6386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing disequality (!=).  <a href="#a1cf5f88e2f5295758117375a30de6386">More...</a><br /></td></tr>
<tr class="separator:a1cf5f88e2f5295758117375a30de6386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c7242773fe5a8413bf3505e34e8477"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af6c7242773fe5a8413bf3505e34e8477">is_greater_than</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:af6c7242773fe5a8413bf3505e34e8477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing greater-than (&gt;).  <a href="#af6c7242773fe5a8413bf3505e34e8477">More...</a><br /></td></tr>
<tr class="separator:af6c7242773fe5a8413bf3505e34e8477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71ff98005aa4a5b0d0639c055fb295f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa71ff98005aa4a5b0d0639c055fb295f">is_greater_than_or_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:aa71ff98005aa4a5b0d0639c055fb295f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing greater-than-or-equal-to (&gt;=).  <a href="#aa71ff98005aa4a5b0d0639c055fb295f">More...</a><br /></td></tr>
<tr class="separator:aa71ff98005aa4a5b0d0639c055fb295f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50548d8092f6c0fa9796daf743a91d56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a50548d8092f6c0fa9796daf743a91d56">is_less_than</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a50548d8092f6c0fa9796daf743a91d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing less-than (&lt;).  <a href="#a50548d8092f6c0fa9796daf743a91d56">More...</a><br /></td></tr>
<tr class="separator:a50548d8092f6c0fa9796daf743a91d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bd0f6e944bac326e6e943f26d3d043"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad4bd0f6e944bac326e6e943f26d3d043">is_less_than_or_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:ad4bd0f6e944bac326e6e943f26d3d043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing less-than-or-equal-to (&lt;=).  <a href="#ad4bd0f6e944bac326e6e943f26d3d043">More...</a><br /></td></tr>
<tr class="separator:ad4bd0f6e944bac326e6e943f26d3d043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0abfc50fd5ff7cda1e5709688b4569"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aac0abfc50fd5ff7cda1e5709688b4569">is_relational</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:aac0abfc50fd5ff7cda1e5709688b4569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a relational formula ({==, !=, &gt;, &gt;=, &lt;, &lt;=}).  <a href="#aac0abfc50fd5ff7cda1e5709688b4569">More...</a><br /></td></tr>
<tr class="separator:aac0abfc50fd5ff7cda1e5709688b4569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52208f3bf9cb2720f5d99223c20382f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a52208f3bf9cb2720f5d99223c20382f9">is_conjunction</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a52208f3bf9cb2720f5d99223c20382f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a conjunction (∧).  <a href="#a52208f3bf9cb2720f5d99223c20382f9">More...</a><br /></td></tr>
<tr class="separator:a52208f3bf9cb2720f5d99223c20382f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f5414ecb9fa8f70d2303a3408aa95b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a96f5414ecb9fa8f70d2303a3408aa95b">is_disjunction</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a96f5414ecb9fa8f70d2303a3408aa95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a disjunction (∨).  <a href="#a96f5414ecb9fa8f70d2303a3408aa95b">More...</a><br /></td></tr>
<tr class="separator:a96f5414ecb9fa8f70d2303a3408aa95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce383d57808e711c1517e9bd461cde2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abce383d57808e711c1517e9bd461cde2">is_nary</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:abce383d57808e711c1517e9bd461cde2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a n-ary formula ({∧, ∨}).  <a href="#abce383d57808e711c1517e9bd461cde2">More...</a><br /></td></tr>
<tr class="separator:abce383d57808e711c1517e9bd461cde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcebff63e5d9aa57da4a45df326a2acf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abcebff63e5d9aa57da4a45df326a2acf">is_negation</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:abcebff63e5d9aa57da4a45df326a2acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a negation (¬).  <a href="#abcebff63e5d9aa57da4a45df326a2acf">More...</a><br /></td></tr>
<tr class="separator:abcebff63e5d9aa57da4a45df326a2acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2266fd8f32067b29eed7e0345658af9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae2266fd8f32067b29eed7e0345658af9">is_forall</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:ae2266fd8f32067b29eed7e0345658af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a Forall formula (∀).  <a href="#ae2266fd8f32067b29eed7e0345658af9">More...</a><br /></td></tr>
<tr class="separator:ae2266fd8f32067b29eed7e0345658af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819538a0900f5b91b88a5a5b25f756d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a819538a0900f5b91b88a5a5b25f756d1">is_isnan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a819538a0900f5b91b88a5a5b25f756d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is an isnan formula.  <a href="#a819538a0900f5b91b88a5a5b25f756d1">More...</a><br /></td></tr>
<tr class="separator:a819538a0900f5b91b88a5a5b25f756d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8a8cf51365e956ea445cf6b77d2577"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9a8a8cf51365e956ea445cf6b77d2577">is_positive_semidefinite</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a9a8a8cf51365e956ea445cf6b77d2577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a positive-semidefinite formula.  <a href="#a9a8a8cf51365e956ea445cf6b77d2577">More...</a><br /></td></tr>
<tr class="separator:a9a8a8cf51365e956ea445cf6b77d2577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486a9821c4235aeda4e39ff0652f72e7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a486a9821c4235aeda4e39ff0652f72e7">get_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a486a9821c4235aeda4e39ff0652f72e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the embedded variable in the variable formula <code>f</code>.  <a href="#a486a9821c4235aeda4e39ff0652f72e7">More...</a><br /></td></tr>
<tr class="separator:a486a9821c4235aeda4e39ff0652f72e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef2e4ae842f5cec22644a1627929c20"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#afef2e4ae842f5cec22644a1627929c20">get_lhs_expression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:afef2e4ae842f5cec22644a1627929c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lhs-argument of a relational formula <code>f</code>.  <a href="#afef2e4ae842f5cec22644a1627929c20">More...</a><br /></td></tr>
<tr class="separator:afef2e4ae842f5cec22644a1627929c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952d7f91d0e9e67110274daf0d17f132"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a952d7f91d0e9e67110274daf0d17f132">get_rhs_expression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a952d7f91d0e9e67110274daf0d17f132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rhs-argument of a relational formula <code>f</code>.  <a href="#a952d7f91d0e9e67110274daf0d17f132">More...</a><br /></td></tr>
<tr class="separator:a952d7f91d0e9e67110274daf0d17f132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71017b418d6504f2947c3a1a0e04d799"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a71017b418d6504f2947c3a1a0e04d799">get_unary_expression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a71017b418d6504f2947c3a1a0e04d799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the expression in a unary expression formula <code>f</code>.  <a href="#a71017b418d6504f2947c3a1a0e04d799">More...</a><br /></td></tr>
<tr class="separator:a71017b418d6504f2947c3a1a0e04d799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2362f52cf6b8c750209340520e7bc9b4"><td class="memItemLeft" align="right" valign="top">const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2362f52cf6b8c750209340520e7bc9b4">get_operands</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a2362f52cf6b8c750209340520e7bc9b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of formulas in a n-ary formula <code>f</code>.  <a href="#a2362f52cf6b8c750209340520e7bc9b4">More...</a><br /></td></tr>
<tr class="separator:a2362f52cf6b8c750209340520e7bc9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7303caa2be22b055163dc4e7134834"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2c7303caa2be22b055163dc4e7134834">get_operand</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a2c7303caa2be22b055163dc4e7134834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the formula in a negation formula <code>f</code>.  <a href="#a2c7303caa2be22b055163dc4e7134834">More...</a><br /></td></tr>
<tr class="separator:a2c7303caa2be22b055163dc4e7134834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5db567077a794c0bb1653699c84a95"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3f5db567077a794c0bb1653699c84a95">get_quantified_variables</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a3f5db567077a794c0bb1653699c84a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the quantified variables in a forall formula <code>f</code>.  <a href="#a3f5db567077a794c0bb1653699c84a95">More...</a><br /></td></tr>
<tr class="separator:a3f5db567077a794c0bb1653699c84a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfcc66d64e8756ae983891059050205"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acbfcc66d64e8756ae983891059050205">get_quantified_formula</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:acbfcc66d64e8756ae983891059050205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the quantified formula in a forall formula <code>f</code>.  <a href="#acbfcc66d64e8756ae983891059050205">More...</a><br /></td></tr>
<tr class="separator:acbfcc66d64e8756ae983891059050205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19aa57dcc28c59559eef51f7cbba8cba"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a19aa57dcc28c59559eef51f7cbba8cba">get_matrix_in_positive_semidefinite</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a19aa57dcc28c59559eef51f7cbba8cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the matrix in a positive-semidefinite formula <code>f</code>.  <a href="#a19aa57dcc28c59559eef51f7cbba8cba">More...</a><br /></td></tr>
<tr class="separator:a19aa57dcc28c59559eef51f7cbba8cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322e2ae11441c6769b244c680c9b565a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a322e2ae11441c6769b244c680c9b565a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()==typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a322e2ae11441c6769b244c680c9b565a">operator==</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a322e2ae11441c6769b244c680c9b565a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise symbolic-equality of two arrays <code>m1</code> and <code>m2</code>.  <a href="#a322e2ae11441c6769b244c680c9b565a">More...</a><br /></td></tr>
<tr class="separator:a322e2ae11441c6769b244c680c9b565a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ac705adb39eafdc363379ce4ea950c"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ScalarType &gt; </td></tr>
<tr class="memitem:ac4ac705adb39eafdc363379ce4ea950c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar()==ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac4ac705adb39eafdc363379ce4ea950c">operator==</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:ac4ac705adb39eafdc363379ce4ea950c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using equal-to operator (==).  <a href="#ac4ac705adb39eafdc363379ce4ea950c">More...</a><br /></td></tr>
<tr class="separator:ac4ac705adb39eafdc363379ce4ea950c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b8a2415edb336f8f0362518bbf183f"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Derived &gt; </td></tr>
<tr class="memitem:ac1b8a2415edb336f8f0362518bbf183f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType()==typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac1b8a2415edb336f8f0362518bbf183f">operator==</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:ac1b8a2415edb336f8f0362518bbf183f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> equal-to operator (==).  <a href="#ac1b8a2415edb336f8f0362518bbf183f">More...</a><br /></td></tr>
<tr class="separator:ac1b8a2415edb336f8f0362518bbf183f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0de903abee4a9e39dbc9148d86c770c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:ad0de903abee4a9e39dbc9148d86c770c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()&lt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad0de903abee4a9e39dbc9148d86c770c">operator&lt;=</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:ad0de903abee4a9e39dbc9148d86c770c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using less-than-or-equal operator (&lt;=).  <a href="#ad0de903abee4a9e39dbc9148d86c770c">More...</a><br /></td></tr>
<tr class="separator:ad0de903abee4a9e39dbc9148d86c770c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6718d0b755c47edc3fade14221574a03"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ScalarType &gt; </td></tr>
<tr class="memitem:a6718d0b755c47edc3fade14221574a03"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar()&lt;=ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6718d0b755c47edc3fade14221574a03">operator&lt;=</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:a6718d0b755c47edc3fade14221574a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using less-than-or-equal operator (&lt;=).  <a href="#a6718d0b755c47edc3fade14221574a03">More...</a><br /></td></tr>
<tr class="separator:a6718d0b755c47edc3fade14221574a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52479ecb229048e750782273796768c2"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Derived &gt; </td></tr>
<tr class="memitem:a52479ecb229048e750782273796768c2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType()&lt;=typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a52479ecb229048e750782273796768c2">operator&lt;=</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a52479ecb229048e750782273796768c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than-or-equal operator (&lt;=).  <a href="#a52479ecb229048e750782273796768c2">More...</a><br /></td></tr>
<tr class="separator:a52479ecb229048e750782273796768c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40dd892a8b6492f65a8995abc666b3f3"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a40dd892a8b6492f65a8995abc666b3f3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()&lt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a40dd892a8b6492f65a8995abc666b3f3">operator&lt;</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a40dd892a8b6492f65a8995abc666b3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using less-than operator (&lt;).  <a href="#a40dd892a8b6492f65a8995abc666b3f3">More...</a><br /></td></tr>
<tr class="separator:a40dd892a8b6492f65a8995abc666b3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528367e2321df46235c2fed21eb0d433"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ScalarType &gt; </td></tr>
<tr class="memitem:a528367e2321df46235c2fed21eb0d433"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar()&lt; ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a528367e2321df46235c2fed21eb0d433">operator&lt;</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:a528367e2321df46235c2fed21eb0d433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using less-than operator (&lt;).  <a href="#a528367e2321df46235c2fed21eb0d433">More...</a><br /></td></tr>
<tr class="separator:a528367e2321df46235c2fed21eb0d433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f5aab12f951d127ecfaf06b4f175c5"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Derived &gt; </td></tr>
<tr class="memitem:aa4f5aab12f951d127ecfaf06b4f175c5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType()&lt; typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa4f5aab12f951d127ecfaf06b4f175c5">operator&lt;</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:aa4f5aab12f951d127ecfaf06b4f175c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than operator (&lt;).  <a href="#aa4f5aab12f951d127ecfaf06b4f175c5">More...</a><br /></td></tr>
<tr class="separator:aa4f5aab12f951d127ecfaf06b4f175c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1028ce4a4b55e7bf85a37d6282c3bf20"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a1028ce4a4b55e7bf85a37d6282c3bf20"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() &gt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1028ce4a4b55e7bf85a37d6282c3bf20">operator&gt;=</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a1028ce4a4b55e7bf85a37d6282c3bf20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using greater-than-or-equal operator (&gt;=).  <a href="#a1028ce4a4b55e7bf85a37d6282c3bf20">More...</a><br /></td></tr>
<tr class="separator:a1028ce4a4b55e7bf85a37d6282c3bf20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ab06a3823da2ab0e41fb23fe64d2e9"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ScalarType &gt; </td></tr>
<tr class="memitem:a92ab06a3823da2ab0e41fb23fe64d2e9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar() &gt;=ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a92ab06a3823da2ab0e41fb23fe64d2e9">operator&gt;=</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:a92ab06a3823da2ab0e41fb23fe64d2e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using greater-than-or-equal operator (&gt;=).  <a href="#a92ab06a3823da2ab0e41fb23fe64d2e9">More...</a><br /></td></tr>
<tr class="separator:a92ab06a3823da2ab0e41fb23fe64d2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47616389df9ab060d41105d51db82be4"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Derived &gt; </td></tr>
<tr class="memitem:a47616389df9ab060d41105d51db82be4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType() &gt;=typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a47616389df9ab060d41105d51db82be4">operator&gt;=</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a47616389df9ab060d41105d51db82be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than-or-equal operator (&lt;=) instead of greater-than-or-equal operator (&gt;=).  <a href="#a47616389df9ab060d41105d51db82be4">More...</a><br /></td></tr>
<tr class="separator:a47616389df9ab060d41105d51db82be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d3790aa8f813be2264913fd250bbcf"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a45d3790aa8f813be2264913fd250bbcf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() &gt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a45d3790aa8f813be2264913fd250bbcf">operator&gt;</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a45d3790aa8f813be2264913fd250bbcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using greater-than operator (&gt;).  <a href="#a45d3790aa8f813be2264913fd250bbcf">More...</a><br /></td></tr>
<tr class="separator:a45d3790aa8f813be2264913fd250bbcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6035c678aac2dd9201f9e8e294ece8d6"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ScalarType &gt; </td></tr>
<tr class="memitem:a6035c678aac2dd9201f9e8e294ece8d6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar() &gt; ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6035c678aac2dd9201f9e8e294ece8d6">operator&gt;</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:a6035c678aac2dd9201f9e8e294ece8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using greater-than operator (&gt;).  <a href="#a6035c678aac2dd9201f9e8e294ece8d6">More...</a><br /></td></tr>
<tr class="separator:a6035c678aac2dd9201f9e8e294ece8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20133edf27869418d18ec4fb7a29d03a"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Derived &gt; </td></tr>
<tr class="memitem:a20133edf27869418d18ec4fb7a29d03a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType() &gt; typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a20133edf27869418d18ec4fb7a29d03a">operator&gt;</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a20133edf27869418d18ec4fb7a29d03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than operator (&lt;) instead of greater-than operator (&gt;).  <a href="#a20133edf27869418d18ec4fb7a29d03a">More...</a><br /></td></tr>
<tr class="separator:a20133edf27869418d18ec4fb7a29d03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9516e5b0429edb615ec0b2cc0cb7fae9"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a9516e5b0429edb615ec0b2cc0cb7fae9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() !=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9516e5b0429edb615ec0b2cc0cb7fae9">operator!=</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a9516e5b0429edb615ec0b2cc0cb7fae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using not-equal operator (!=).  <a href="#a9516e5b0429edb615ec0b2cc0cb7fae9">More...</a><br /></td></tr>
<tr class="separator:a9516e5b0429edb615ec0b2cc0cb7fae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2adc95d21c8bb34168d15514bf00a3d6"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ScalarType &gt; </td></tr>
<tr class="memitem:a2adc95d21c8bb34168d15514bf00a3d6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar() !=ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2adc95d21c8bb34168d15514bf00a3d6">operator!=</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:a2adc95d21c8bb34168d15514bf00a3d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using not-equal operator (!=).  <a href="#a2adc95d21c8bb34168d15514bf00a3d6">More...</a><br /></td></tr>
<tr class="separator:a2adc95d21c8bb34168d15514bf00a3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912368173773912a9b75abfaf208e1e1"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Derived &gt; </td></tr>
<tr class="memitem:a912368173773912a9b75abfaf208e1e1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType() !=typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a912368173773912a9b75abfaf208e1e1">operator!=</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a912368173773912a9b75abfaf208e1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> not-equal operator (!=).  <a href="#a912368173773912a9b75abfaf208e1e1">More...</a><br /></td></tr>
<tr class="separator:a912368173773912a9b75abfaf208e1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea231d5704136799bf6fa221bdbb69bd"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:aea231d5704136799bf6fa221bdbb69bd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()==typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aea231d5704136799bf6fa221bdbb69bd">operator==</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:aea231d5704136799bf6fa221bdbb69bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula checking if two matrices <code>m1</code> and <code>m2</code> are equal.  <a href="#aea231d5704136799bf6fa221bdbb69bd">More...</a><br /></td></tr>
<tr class="separator:aea231d5704136799bf6fa221bdbb69bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665bbf538eb986af44631f116c34a83d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a665bbf538eb986af44631f116c34a83d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() !=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a665bbf538eb986af44631f116c34a83d">operator!=</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:a665bbf538eb986af44631f116c34a83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing the condition whether <code>m1</code> and <code>m2</code> are not the same.  <a href="#a665bbf538eb986af44631f116c34a83d">More...</a><br /></td></tr>
<tr class="separator:a665bbf538eb986af44631f116c34a83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3e369561e0984adadbfddf3acb84f3"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a3e3e369561e0984adadbfddf3acb84f3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()&lt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3e3e369561e0984adadbfddf3acb84f3">operator&lt;</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:a3e3e369561e0984adadbfddf3acb84f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using less-than (&lt;) operator.  <a href="#a3e3e369561e0984adadbfddf3acb84f3">More...</a><br /></td></tr>
<tr class="separator:a3e3e369561e0984adadbfddf3acb84f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6bb943d7aab03288d67ad8f657c2758"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:af6bb943d7aab03288d67ad8f657c2758"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()&lt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af6bb943d7aab03288d67ad8f657c2758">operator&lt;=</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:af6bb943d7aab03288d67ad8f657c2758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using less-than-or-equal operator (&lt;=).  <a href="#af6bb943d7aab03288d67ad8f657c2758">More...</a><br /></td></tr>
<tr class="separator:af6bb943d7aab03288d67ad8f657c2758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81230526e0921e5d17d5e08c2817cc7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:ad81230526e0921e5d17d5e08c2817cc7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() &gt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad81230526e0921e5d17d5e08c2817cc7">operator&gt;</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:ad81230526e0921e5d17d5e08c2817cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using greater-than operator (&gt;).  <a href="#ad81230526e0921e5d17d5e08c2817cc7">More...</a><br /></td></tr>
<tr class="separator:ad81230526e0921e5d17d5e08c2817cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9594d5ed428f5fac27aced9c9fcd28d1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a9594d5ed428f5fac27aced9c9fcd28d1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() &gt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9594d5ed428f5fac27aced9c9fcd28d1">operator&gt;=</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:a9594d5ed428f5fac27aced9c9fcd28d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using greater-than-or-equal operator (&gt;=).  <a href="#a9594d5ed428f5fac27aced9c9fcd28d1">More...</a><br /></td></tr>
<tr class="separator:a9594d5ed428f5fac27aced9c9fcd28d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe1f207a7dfa971bf80a1d44041368b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9fe1f207a7dfa971bf80a1d44041368b">is_false</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a9fe1f207a7dfa971bf80a1d44041368b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is structurally equal to False formula.  <a href="#a9fe1f207a7dfa971bf80a1d44041368b">More...</a><br /></td></tr>
<tr class="separator:a9fe1f207a7dfa971bf80a1d44041368b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3654df643f4d7840fd8548eb81f4a9ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3654df643f4d7840fd8548eb81f4a9ae">is_true</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a3654df643f4d7840fd8548eb81f4a9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is structurally equal to True formula.  <a href="#a3654df643f4d7840fd8548eb81f4a9ae">More...</a><br /></td></tr>
<tr class="separator:a3654df643f4d7840fd8548eb81f4a9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac014e89da18637b81f9c1fbe6306e689"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac014e89da18637b81f9c1fbe6306e689">is_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:ac014e89da18637b81f9c1fbe6306e689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a variable formula.  <a href="#ac014e89da18637b81f9c1fbe6306e689">More...</a><br /></td></tr>
<tr class="separator:ac014e89da18637b81f9c1fbe6306e689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ce3ca5629e2672f177ff3c0cc088ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a09ce3ca5629e2672f177ff3c0cc088ae">is_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a09ce3ca5629e2672f177ff3c0cc088ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing equality (==).  <a href="#a09ce3ca5629e2672f177ff3c0cc088ae">More...</a><br /></td></tr>
<tr class="separator:a09ce3ca5629e2672f177ff3c0cc088ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5cfac124e8ae1c7450c4e0c91c2bc07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac5cfac124e8ae1c7450c4e0c91c2bc07">is_not_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:ac5cfac124e8ae1c7450c4e0c91c2bc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing disequality (!=).  <a href="#ac5cfac124e8ae1c7450c4e0c91c2bc07">More...</a><br /></td></tr>
<tr class="separator:ac5cfac124e8ae1c7450c4e0c91c2bc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aab22ba7b7baeb20a13b0aa90172fc1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0aab22ba7b7baeb20a13b0aa90172fc1">is_greater_than</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a0aab22ba7b7baeb20a13b0aa90172fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing greater-than (&gt;).  <a href="#a0aab22ba7b7baeb20a13b0aa90172fc1">More...</a><br /></td></tr>
<tr class="separator:a0aab22ba7b7baeb20a13b0aa90172fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788e2bbb344403337e7b77edf2bd92fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a788e2bbb344403337e7b77edf2bd92fa">is_greater_than_or_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a788e2bbb344403337e7b77edf2bd92fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing greater-than-or-equal-to (&gt;=).  <a href="#a788e2bbb344403337e7b77edf2bd92fa">More...</a><br /></td></tr>
<tr class="separator:a788e2bbb344403337e7b77edf2bd92fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed4c523512b2ee45d906c0f9d0b1d13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aaed4c523512b2ee45d906c0f9d0b1d13">is_less_than</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:aaed4c523512b2ee45d906c0f9d0b1d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing less-than (&lt;).  <a href="#aaed4c523512b2ee45d906c0f9d0b1d13">More...</a><br /></td></tr>
<tr class="separator:aaed4c523512b2ee45d906c0f9d0b1d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfca6086d970d576d51fa5364416a297"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#adfca6086d970d576d51fa5364416a297">is_less_than_or_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:adfca6086d970d576d51fa5364416a297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing less-than-or-equal-to (&lt;=).  <a href="#adfca6086d970d576d51fa5364416a297">More...</a><br /></td></tr>
<tr class="separator:adfca6086d970d576d51fa5364416a297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500b46690e6bd8926394ccf7c8482a70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a500b46690e6bd8926394ccf7c8482a70">is_relational</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a500b46690e6bd8926394ccf7c8482a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a relational formula ({==, !=, &gt;, &gt;=, &lt;, &lt;=}).  <a href="#a500b46690e6bd8926394ccf7c8482a70">More...</a><br /></td></tr>
<tr class="separator:a500b46690e6bd8926394ccf7c8482a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60a650ffd29c64c25be2dc84bfefccc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad60a650ffd29c64c25be2dc84bfefccc">is_conjunction</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:ad60a650ffd29c64c25be2dc84bfefccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a conjunction (∧).  <a href="#ad60a650ffd29c64c25be2dc84bfefccc">More...</a><br /></td></tr>
<tr class="separator:ad60a650ffd29c64c25be2dc84bfefccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb95d50cf0c445f6be7d3d1e5a356a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9fb95d50cf0c445f6be7d3d1e5a356a9">is_disjunction</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a9fb95d50cf0c445f6be7d3d1e5a356a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a disjunction (∨).  <a href="#a9fb95d50cf0c445f6be7d3d1e5a356a9">More...</a><br /></td></tr>
<tr class="separator:a9fb95d50cf0c445f6be7d3d1e5a356a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450bcac9577de0ca8d380d2a70d5fb12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a450bcac9577de0ca8d380d2a70d5fb12">is_nary</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a450bcac9577de0ca8d380d2a70d5fb12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is N-ary.  <a href="#a450bcac9577de0ca8d380d2a70d5fb12">More...</a><br /></td></tr>
<tr class="separator:a450bcac9577de0ca8d380d2a70d5fb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a463fed830ca5aa9b3ff7bdef8f67a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a18a463fed830ca5aa9b3ff7bdef8f67a">is_negation</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a18a463fed830ca5aa9b3ff7bdef8f67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a negation (¬).  <a href="#a18a463fed830ca5aa9b3ff7bdef8f67a">More...</a><br /></td></tr>
<tr class="separator:a18a463fed830ca5aa9b3ff7bdef8f67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aeb30cdaf6f0d8f4d324afee241ae89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1aeb30cdaf6f0d8f4d324afee241ae89">is_forall</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a1aeb30cdaf6f0d8f4d324afee241ae89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a Forall formula (∀).  <a href="#a1aeb30cdaf6f0d8f4d324afee241ae89">More...</a><br /></td></tr>
<tr class="separator:a1aeb30cdaf6f0d8f4d324afee241ae89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726023da52d6033c2565368b6def1e16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a726023da52d6033c2565368b6def1e16">is_isnan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a726023da52d6033c2565368b6def1e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is an isnan formula.  <a href="#a726023da52d6033c2565368b6def1e16">More...</a><br /></td></tr>
<tr class="separator:a726023da52d6033c2565368b6def1e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a59dcaebd746af03b1996daf8d8901"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a42a59dcaebd746af03b1996daf8d8901">is_positive_semidefinite</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a42a59dcaebd746af03b1996daf8d8901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a positive semidefinite formula.  <a href="#a42a59dcaebd746af03b1996daf8d8901">More...</a><br /></td></tr>
<tr class="separator:a42a59dcaebd746af03b1996daf8d8901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba2673fe37620dcc2a3b06ab7b72bec"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_false.html">FormulaFalse</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1ba2673fe37620dcc2a3b06ab7b72bec">to_false</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a1ba2673fe37620dcc2a3b06ab7b72bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaFalse&gt;</code>.  <a href="#a1ba2673fe37620dcc2a3b06ab7b72bec">More...</a><br /></td></tr>
<tr class="separator:a1ba2673fe37620dcc2a3b06ab7b72bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85772f75f073405ed82017151b4cb279"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_true.html">FormulaTrue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a85772f75f073405ed82017151b4cb279">to_true</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a85772f75f073405ed82017151b4cb279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaTrue&gt;</code>.  <a href="#a85772f75f073405ed82017151b4cb279">More...</a><br /></td></tr>
<tr class="separator:a85772f75f073405ed82017151b4cb279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b78dde9ca32fe1ee12cc232a9a4e85c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_var.html">FormulaVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3b78dde9ca32fe1ee12cc232a9a4e85c">to_variable</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a3b78dde9ca32fe1ee12cc232a9a4e85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaVar&gt;</code>.  <a href="#a3b78dde9ca32fe1ee12cc232a9a4e85c">More...</a><br /></td></tr>
<tr class="separator:a3b78dde9ca32fe1ee12cc232a9a4e85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259612bbd9405f24d4ac3b60d54575e6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_relational_formula_cell.html">RelationalFormulaCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a259612bbd9405f24d4ac3b60d54575e6">to_relational</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a259612bbd9405f24d4ac3b60d54575e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const RelationalFormulaCell&gt;</code>.  <a href="#a259612bbd9405f24d4ac3b60d54575e6">More...</a><br /></td></tr>
<tr class="separator:a259612bbd9405f24d4ac3b60d54575e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a6204418091c1fbf26c9d2ad03389f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_eq.html">FormulaEq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a10a6204418091c1fbf26c9d2ad03389f">to_equal_to</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a10a6204418091c1fbf26c9d2ad03389f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaEq&gt;</code>.  <a href="#a10a6204418091c1fbf26c9d2ad03389f">More...</a><br /></td></tr>
<tr class="separator:a10a6204418091c1fbf26c9d2ad03389f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e880ce60c41c7e65085dbf911edded"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_neq.html">FormulaNeq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a70e880ce60c41c7e65085dbf911edded">to_not_equal_to</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a70e880ce60c41c7e65085dbf911edded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaNeq&gt;</code>.  <a href="#a70e880ce60c41c7e65085dbf911edded">More...</a><br /></td></tr>
<tr class="separator:a70e880ce60c41c7e65085dbf911edded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352fe19778d77b7095580950d8e298b4"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_gt.html">FormulaGt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a352fe19778d77b7095580950d8e298b4">to_greater_than</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a352fe19778d77b7095580950d8e298b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaGt&gt;</code>.  <a href="#a352fe19778d77b7095580950d8e298b4">More...</a><br /></td></tr>
<tr class="separator:a352fe19778d77b7095580950d8e298b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8cbb802de92188843f8531d6b05827"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_geq.html">FormulaGeq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7f8cbb802de92188843f8531d6b05827">to_greater_than_or_equal_to</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a7f8cbb802de92188843f8531d6b05827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaGeq&gt;</code>.  <a href="#a7f8cbb802de92188843f8531d6b05827">More...</a><br /></td></tr>
<tr class="separator:a7f8cbb802de92188843f8531d6b05827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7488de67ca4d6bc69cec3bb0f67ae4c3"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_lt.html">FormulaLt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7488de67ca4d6bc69cec3bb0f67ae4c3">to_less_than</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a7488de67ca4d6bc69cec3bb0f67ae4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaLt&gt;</code>.  <a href="#a7488de67ca4d6bc69cec3bb0f67ae4c3">More...</a><br /></td></tr>
<tr class="separator:a7488de67ca4d6bc69cec3bb0f67ae4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb39c33945b763922fe0fcacc6c369b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_leq.html">FormulaLeq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acfb39c33945b763922fe0fcacc6c369b">to_less_than_or_equal_to</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:acfb39c33945b763922fe0fcacc6c369b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaLeq&gt;</code>.  <a href="#acfb39c33945b763922fe0fcacc6c369b">More...</a><br /></td></tr>
<tr class="separator:acfb39c33945b763922fe0fcacc6c369b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180aa6c7637801b158099a87a59a4185"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_and.html">FormulaAnd</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a180aa6c7637801b158099a87a59a4185">to_conjunction</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a180aa6c7637801b158099a87a59a4185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaAnd&gt;</code>.  <a href="#a180aa6c7637801b158099a87a59a4185">More...</a><br /></td></tr>
<tr class="separator:a180aa6c7637801b158099a87a59a4185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0758b788047cb3d6b4737c6d54cee2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_or.html">FormulaOr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0b0758b788047cb3d6b4737c6d54cee2">to_disjunction</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a0b0758b788047cb3d6b4737c6d54cee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaOr&gt;</code>.  <a href="#a0b0758b788047cb3d6b4737c6d54cee2">More...</a><br /></td></tr>
<tr class="separator:a0b0758b788047cb3d6b4737c6d54cee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f9249b5c150485c3c7cff61d5c0416"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_nary_formula_cell.html">NaryFormulaCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad0f9249b5c150485c3c7cff61d5c0416">to_nary</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:ad0f9249b5c150485c3c7cff61d5c0416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const NaryFormulaCell&gt;</code>.  <a href="#ad0f9249b5c150485c3c7cff61d5c0416">More...</a><br /></td></tr>
<tr class="separator:ad0f9249b5c150485c3c7cff61d5c0416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceef2c41a1ce6c5f7eed83c1d2df9381"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_not.html">FormulaNot</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aceef2c41a1ce6c5f7eed83c1d2df9381">to_negation</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:aceef2c41a1ce6c5f7eed83c1d2df9381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaNot&gt;</code>.  <a href="#aceef2c41a1ce6c5f7eed83c1d2df9381">More...</a><br /></td></tr>
<tr class="separator:aceef2c41a1ce6c5f7eed83c1d2df9381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c587017789ff28f462e87ba0a44872d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_forall.html">FormulaForall</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7c587017789ff28f462e87ba0a44872d">to_forall</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a7c587017789ff28f462e87ba0a44872d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaForall&gt;</code>.  <a href="#a7c587017789ff28f462e87ba0a44872d">More...</a><br /></td></tr>
<tr class="separator:a7c587017789ff28f462e87ba0a44872d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f46f5ae1e9130eb9214a2ae0611f52"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_isnan.html">FormulaIsnan</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad4f46f5ae1e9130eb9214a2ae0611f52">to_isnan</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:ad4f46f5ae1e9130eb9214a2ae0611f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaIsnan&gt;</code>.  <a href="#ad4f46f5ae1e9130eb9214a2ae0611f52">More...</a><br /></td></tr>
<tr class="separator:ad4f46f5ae1e9130eb9214a2ae0611f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6854fa16fb68d99c3cbe16d2c9afc584"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_positive_semidefinite.html">FormulaPositiveSemidefinite</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6854fa16fb68d99c3cbe16d2c9afc584">to_positive_semidefinite</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a6854fa16fb68d99c3cbe16d2c9afc584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaPositiveSemidefinite&gt;</code>.  <a href="#a6854fa16fb68d99c3cbe16d2c9afc584">More...</a><br /></td></tr>
<tr class="separator:a6854fa16fb68d99c3cbe16d2c9afc584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2748b5dc34bc17a6c6e98ac1d0cc1ad"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Visitor , typename... Args&gt; </td></tr>
<tr class="memitem:aa2748b5dc34bc17a6c6e98ac1d0cc1ad"><td class="memTemplItemLeft" align="right" valign="top">Result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa2748b5dc34bc17a6c6e98ac1d0cc1ad">VisitFormula</a> (Visitor *v, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa2748b5dc34bc17a6c6e98ac1d0cc1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls visitor object <code>v</code> with a symbolic formula <code>f</code>, and arguments <code>args</code>.  <a href="#aa2748b5dc34bc17a6c6e98ac1d0cc1ad">More...</a><br /></td></tr>
<tr class="separator:aa2748b5dc34bc17a6c6e98ac1d0cc1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e0055c99275292d22eb59c103fb0ae"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab6e0055c99275292d22eb59c103fb0ae">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">Variable::Type</a> type)</td></tr>
<tr class="separator:ab6e0055c99275292d22eb59c103fb0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b2869ab43577cdf4d1641ef1d832ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a90b2869ab43577cdf4d1641ef1d832ef">MakeMatrixVariable</a> (<a class="el" href="classint.html">int</a> rows, <a class="el" href="classint.html">int</a> cols, const std::string &amp;name, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">Variable::Type</a> type=<a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479ab1fa9dd3af034b3ef4291579aa673c07">Variable::Type::CONTINUOUS</a>)</td></tr>
<tr class="memdesc:a90b2869ab43577cdf4d1641ef1d832ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen matrix of symbolic variables.  <a href="#a90b2869ab43577cdf4d1641ef1d832ef">More...</a><br /></td></tr>
<tr class="separator:a90b2869ab43577cdf4d1641ef1d832ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8fedc6cdc53869462f7aebaafa32c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4a8fedc6cdc53869462f7aebaafa32c0">MakeMatrixBooleanVariable</a> (<a class="el" href="classint.html">int</a> rows, <a class="el" href="classint.html">int</a> cols, const std::string &amp;name)</td></tr>
<tr class="memdesc:a4a8fedc6cdc53869462f7aebaafa32c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen matrix of symbolic Boolean variables.  <a href="#a4a8fedc6cdc53869462f7aebaafa32c0">More...</a><br /></td></tr>
<tr class="separator:a4a8fedc6cdc53869462f7aebaafa32c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61ece2fbaa79f8aad11313fa4b36150"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab61ece2fbaa79f8aad11313fa4b36150">MakeMatrixBinaryVariable</a> (<a class="el" href="classint.html">int</a> rows, <a class="el" href="classint.html">int</a> cols, const std::string &amp;name)</td></tr>
<tr class="memdesc:ab61ece2fbaa79f8aad11313fa4b36150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen matrix of symbolic binary variables.  <a href="#ab61ece2fbaa79f8aad11313fa4b36150">More...</a><br /></td></tr>
<tr class="separator:ab61ece2fbaa79f8aad11313fa4b36150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29875ac163c78c1d1e75106b5890c949"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a29875ac163c78c1d1e75106b5890c949">MakeMatrixContinuousVariable</a> (<a class="el" href="classint.html">int</a> rows, <a class="el" href="classint.html">int</a> cols, const std::string &amp;name)</td></tr>
<tr class="memdesc:a29875ac163c78c1d1e75106b5890c949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen matrix of symbolic continuous variables.  <a href="#a29875ac163c78c1d1e75106b5890c949">More...</a><br /></td></tr>
<tr class="separator:a29875ac163c78c1d1e75106b5890c949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6779284f55bfadabde9c015ad694d093"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6779284f55bfadabde9c015ad694d093">MakeMatrixIntegerVariable</a> (<a class="el" href="classint.html">int</a> rows, <a class="el" href="classint.html">int</a> cols, const std::string &amp;name)</td></tr>
<tr class="memdesc:a6779284f55bfadabde9c015ad694d093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen matrix of symbolic integer variables.  <a href="#a6779284f55bfadabde9c015ad694d093">More...</a><br /></td></tr>
<tr class="separator:a6779284f55bfadabde9c015ad694d093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43a4b68b6447c593384282b8a9bc1bc"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:ac43a4b68b6447c593384282b8a9bc1bc"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac43a4b68b6447c593384282b8a9bc1bc">MakeMatrixVariable</a> (const std::string &amp;name, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">Variable::Type</a> type=<a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479ab1fa9dd3af034b3ef4291579aa673c07">Variable::Type::CONTINUOUS</a>)</td></tr>
<tr class="memdesc:ac43a4b68b6447c593384282b8a9bc1bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen matrix of symbolic variables.  <a href="#ac43a4b68b6447c593384282b8a9bc1bc">More...</a><br /></td></tr>
<tr class="separator:ac43a4b68b6447c593384282b8a9bc1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab43ed8981b8575f24e83fdf4b26295"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:a2ab43ed8981b8575f24e83fdf4b26295"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2ab43ed8981b8575f24e83fdf4b26295">MakeMatrixBooleanVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a2ab43ed8981b8575f24e83fdf4b26295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen matrix of symbolic Boolean variables.  <a href="#a2ab43ed8981b8575f24e83fdf4b26295">More...</a><br /></td></tr>
<tr class="separator:a2ab43ed8981b8575f24e83fdf4b26295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803dbab92e520549b625dde70f05fe47"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:a803dbab92e520549b625dde70f05fe47"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a803dbab92e520549b625dde70f05fe47">MakeMatrixBinaryVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a803dbab92e520549b625dde70f05fe47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen matrix of symbolic binary variables.  <a href="#a803dbab92e520549b625dde70f05fe47">More...</a><br /></td></tr>
<tr class="separator:a803dbab92e520549b625dde70f05fe47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93b9abfad06da819d5460018eb49b5c"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:ad93b9abfad06da819d5460018eb49b5c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad93b9abfad06da819d5460018eb49b5c">MakeMatrixContinuousVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ad93b9abfad06da819d5460018eb49b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen matrix of symbolic continuous variables.  <a href="#ad93b9abfad06da819d5460018eb49b5c">More...</a><br /></td></tr>
<tr class="separator:ad93b9abfad06da819d5460018eb49b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b71b38080ba3cd1d36172c4577ed445"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:a6b71b38080ba3cd1d36172c4577ed445"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6b71b38080ba3cd1d36172c4577ed445">MakeMatrixIntegerVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a6b71b38080ba3cd1d36172c4577ed445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen matrix of symbolic integer variables.  <a href="#a6b71b38080ba3cd1d36172c4577ed445">More...</a><br /></td></tr>
<tr class="separator:a6b71b38080ba3cd1d36172c4577ed445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8075d8a54d9c85d7b0cdcdff660ee1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3d8075d8a54d9c85d7b0cdcdff660ee1">MakeVectorVariable</a> (<a class="el" href="classint.html">int</a> rows, const std::string &amp;name, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">Variable::Type</a> type=<a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479ab1fa9dd3af034b3ef4291579aa673c07">Variable::Type::CONTINUOUS</a>)</td></tr>
<tr class="memdesc:a3d8075d8a54d9c85d7b0cdcdff660ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen vector of symbolic variables.  <a href="#a3d8075d8a54d9c85d7b0cdcdff660ee1">More...</a><br /></td></tr>
<tr class="separator:a3d8075d8a54d9c85d7b0cdcdff660ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db73b37d01f12010d12cd426f7f5054"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0db73b37d01f12010d12cd426f7f5054">MakeVectorBooleanVariable</a> (<a class="el" href="classint.html">int</a> rows, const std::string &amp;name)</td></tr>
<tr class="memdesc:a0db73b37d01f12010d12cd426f7f5054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen vector of symbolic Boolean variables.  <a href="#a0db73b37d01f12010d12cd426f7f5054">More...</a><br /></td></tr>
<tr class="separator:a0db73b37d01f12010d12cd426f7f5054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486a6cf03a93f8f8693c94e57d29e0ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a486a6cf03a93f8f8693c94e57d29e0ea">MakeVectorBinaryVariable</a> (<a class="el" href="classint.html">int</a> rows, const std::string &amp;name)</td></tr>
<tr class="memdesc:a486a6cf03a93f8f8693c94e57d29e0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen vector of symbolic binary variables.  <a href="#a486a6cf03a93f8f8693c94e57d29e0ea">More...</a><br /></td></tr>
<tr class="separator:a486a6cf03a93f8f8693c94e57d29e0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abc75a1263e517c17a4fcb5944ba474"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3abc75a1263e517c17a4fcb5944ba474">MakeVectorContinuousVariable</a> (<a class="el" href="classint.html">int</a> rows, const std::string &amp;name)</td></tr>
<tr class="memdesc:a3abc75a1263e517c17a4fcb5944ba474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen vector of symbolic continuous variables.  <a href="#a3abc75a1263e517c17a4fcb5944ba474">More...</a><br /></td></tr>
<tr class="separator:a3abc75a1263e517c17a4fcb5944ba474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7493090d0f80fbec7343113df05f6b90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7493090d0f80fbec7343113df05f6b90">MakeVectorIntegerVariable</a> (<a class="el" href="classint.html">int</a> rows, const std::string &amp;name)</td></tr>
<tr class="memdesc:a7493090d0f80fbec7343113df05f6b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen vector of symbolic integer variables.  <a href="#a7493090d0f80fbec7343113df05f6b90">More...</a><br /></td></tr>
<tr class="separator:a7493090d0f80fbec7343113df05f6b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b123dcb60415c706814483e6b6d2a8"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:ac3b123dcb60415c706814483e6b6d2a8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac3b123dcb60415c706814483e6b6d2a8">MakeVectorVariable</a> (const std::string &amp;name, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">Variable::Type</a> type=<a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479ab1fa9dd3af034b3ef4291579aa673c07">Variable::Type::CONTINUOUS</a>)</td></tr>
<tr class="memdesc:ac3b123dcb60415c706814483e6b6d2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen vector of symbolic variables.  <a href="#ac3b123dcb60415c706814483e6b6d2a8">More...</a><br /></td></tr>
<tr class="separator:ac3b123dcb60415c706814483e6b6d2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2f37fa21183f09e3544a4c6891494b"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a4d2f37fa21183f09e3544a4c6891494b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4d2f37fa21183f09e3544a4c6891494b">MakeVectorBooleanVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a4d2f37fa21183f09e3544a4c6891494b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen vector of symbolic Boolean variables.  <a href="#a4d2f37fa21183f09e3544a4c6891494b">More...</a><br /></td></tr>
<tr class="separator:a4d2f37fa21183f09e3544a4c6891494b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698dcb5dd4fea36841d305e89f52dd97"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a698dcb5dd4fea36841d305e89f52dd97"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a698dcb5dd4fea36841d305e89f52dd97">MakeVectorBinaryVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a698dcb5dd4fea36841d305e89f52dd97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen vector of symbolic binary variables.  <a href="#a698dcb5dd4fea36841d305e89f52dd97">More...</a><br /></td></tr>
<tr class="separator:a698dcb5dd4fea36841d305e89f52dd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a6b5840c741f1869738945cef3d8c5"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a86a6b5840c741f1869738945cef3d8c5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a86a6b5840c741f1869738945cef3d8c5">MakeVectorContinuousVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a86a6b5840c741f1869738945cef3d8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen vector of symbolic continuous variables.  <a href="#a86a6b5840c741f1869738945cef3d8c5">More...</a><br /></td></tr>
<tr class="separator:a86a6b5840c741f1869738945cef3d8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a22da2ebae3f3ca478d07976adfca85"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a2a22da2ebae3f3ca478d07976adfca85"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2a22da2ebae3f3ca478d07976adfca85">MakeVectorIntegerVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a2a22da2ebae3f3ca478d07976adfca85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen vector of symbolic integer variables.  <a href="#a2a22da2ebae3f3ca478d07976adfca85">More...</a><br /></td></tr>
<tr class="separator:a2a22da2ebae3f3ca478d07976adfca85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16b3f1c2c4dba6f5b0f7d9a76766f7a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:ab16b3f1c2c4dba6f5b0f7d9a76766f7a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt; DerivedA, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;::value &amp;&amp;<a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt; DerivedB, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab16b3f1c2c4dba6f5b0f7d9a76766f7a">CheckStructuralEquality</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:ab16b3f1c2c4dba6f5b0f7d9a76766f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two Eigen::Matrix&lt;Variable&gt; <code>m1</code> and <code>m2</code> are structurally equal.  <a href="#ab16b3f1c2c4dba6f5b0f7d9a76766f7a">More...</a><br /></td></tr>
<tr class="separator:ab16b3f1c2c4dba6f5b0f7d9a76766f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac861cf2992e3fa03746df6ca291c5020"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac861cf2992e3fa03746df6ca291c5020">operator+=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars1, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars2)</td></tr>
<tr class="memdesc:ac861cf2992e3fa03746df6ca291c5020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <code>var1</code> with the result of set-union(<code>var1</code>, <code>var2</code>).  <a href="#ac861cf2992e3fa03746df6ca291c5020">More...</a><br /></td></tr>
<tr class="separator:ac861cf2992e3fa03746df6ca291c5020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee8a097ba9d2c5d5ee4643471c945ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3ee8a097ba9d2c5d5ee4643471c945ce">operator+=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="memdesc:a3ee8a097ba9d2c5d5ee4643471c945ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <code>vars</code> with the result of set-union(<code>vars</code>, { <code>var</code> }).  <a href="#a3ee8a097ba9d2c5d5ee4643471c945ce">More...</a><br /></td></tr>
<tr class="separator:a3ee8a097ba9d2c5d5ee4643471c945ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2399f6ee5b4c18bc26dc3fd5b6c07a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aba2399f6ee5b4c18bc26dc3fd5b6c07a">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> vars1, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars2)</td></tr>
<tr class="memdesc:aba2399f6ee5b4c18bc26dc3fd5b6c07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set-union of <code>var1</code> and <code>var2</code>.  <a href="#aba2399f6ee5b4c18bc26dc3fd5b6c07a">More...</a><br /></td></tr>
<tr class="separator:aba2399f6ee5b4c18bc26dc3fd5b6c07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497331a32f5911a18cef34b07df6c04a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a497331a32f5911a18cef34b07df6c04a">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> vars, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="memdesc:a497331a32f5911a18cef34b07df6c04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set-union of <code>vars</code> and {<code>var}</code>.  <a href="#a497331a32f5911a18cef34b07df6c04a">More...</a><br /></td></tr>
<tr class="separator:a497331a32f5911a18cef34b07df6c04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae117a884f72a1a73cc2863ec026c011"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aae117a884f72a1a73cc2863ec026c011">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var, <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> vars)</td></tr>
<tr class="memdesc:aae117a884f72a1a73cc2863ec026c011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set-union of {<code>var}</code> and <code>vars</code>.  <a href="#aae117a884f72a1a73cc2863ec026c011">More...</a><br /></td></tr>
<tr class="separator:aae117a884f72a1a73cc2863ec026c011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668d0a0cca975453784c6cd77d638c56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a668d0a0cca975453784c6cd77d638c56">operator-=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars1, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars2)</td></tr>
<tr class="memdesc:a668d0a0cca975453784c6cd77d638c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <code>var1</code> with the result of set-minus(<code>var1</code>, <code>var2</code>).  <a href="#a668d0a0cca975453784c6cd77d638c56">More...</a><br /></td></tr>
<tr class="separator:a668d0a0cca975453784c6cd77d638c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ee50ee4e70ef4393128598d143a2a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a50ee50ee4e70ef4393128598d143a2a6">operator-=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="memdesc:a50ee50ee4e70ef4393128598d143a2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <code>vars</code> with the result of set-minus(<code>vars</code>, {<code>var}</code>).  <a href="#a50ee50ee4e70ef4393128598d143a2a6">More...</a><br /></td></tr>
<tr class="separator:a50ee50ee4e70ef4393128598d143a2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d93012a42e93f92eb3b7fab8bd60733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3d93012a42e93f92eb3b7fab8bd60733">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> vars1, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars2)</td></tr>
<tr class="memdesc:a3d93012a42e93f92eb3b7fab8bd60733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set-minus(<code>var1</code>, <code>vars2</code>).  <a href="#a3d93012a42e93f92eb3b7fab8bd60733">More...</a><br /></td></tr>
<tr class="separator:a3d93012a42e93f92eb3b7fab8bd60733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062f8182804bd14f76a6f2ac17718a80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a062f8182804bd14f76a6f2ac17718a80">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> vars, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="memdesc:a062f8182804bd14f76a6f2ac17718a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set-minus(<code>vars</code>, { <code>var</code> }).  <a href="#a062f8182804bd14f76a6f2ac17718a80">More...</a><br /></td></tr>
<tr class="separator:a062f8182804bd14f76a6f2ac17718a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc4e8320720218ee84dc1fdc7439d17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8dc4e8320720218ee84dc1fdc7439d17">intersect</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars1, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars2)</td></tr>
<tr class="memdesc:a8dc4e8320720218ee84dc1fdc7439d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection of <code>vars1</code> and <code>vars2</code>.  <a href="#a8dc4e8320720218ee84dc1fdc7439d17">More...</a><br /></td></tr>
<tr class="separator:a8dc4e8320720218ee84dc1fdc7439d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9f5fa3d4c2770a38947956973fe27e"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a5e9f5fa3d4c2770a38947956973fe27e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5e9f5fa3d4c2770a38947956973fe27e">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;p)</td></tr>
<tr class="separator:a5e9f5fa3d4c2770a38947956973fe27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687f88372c74f4500af3df50cb687b88"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a687f88372c74f4500af3df50cb687b88"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a687f88372c74f4500af3df50cb687b88">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p1, const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;p2)</td></tr>
<tr class="separator:a687f88372c74f4500af3df50cb687b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af9f402cc780cda79d4f27807f75d39"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a4af9f402cc780cda79d4f27807f75d39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4af9f402cc780cda79d4f27807f75d39">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p, const BasisElement &amp;m)</td></tr>
<tr class="separator:a4af9f402cc780cda79d4f27807f75d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2296b14ee573d8deafe90b3615281e68"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a2296b14ee573d8deafe90b3615281e68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2296b14ee573d8deafe90b3615281e68">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p, <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:a2296b14ee573d8deafe90b3615281e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2176f7eb786ddec5cd9ea0683a019482"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a2176f7eb786ddec5cd9ea0683a019482"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2176f7eb786ddec5cd9ea0683a019482">operator+</a> (const BasisElement &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p)</td></tr>
<tr class="separator:a2176f7eb786ddec5cd9ea0683a019482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a635f8429c26e19e7582b7753751636"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a6a635f8429c26e19e7582b7753751636"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6a635f8429c26e19e7582b7753751636">operator+</a> (const BasisElement &amp;m1, const BasisElement &amp;m2)</td></tr>
<tr class="separator:a6a635f8429c26e19e7582b7753751636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b919a53ae2bebde988b237088cb822"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a94b919a53ae2bebde988b237088cb822"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a94b919a53ae2bebde988b237088cb822">operator+</a> (const BasisElement &amp;m, <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:a94b919a53ae2bebde988b237088cb822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434f1953d9800d1c40dc223609904ecf"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a434f1953d9800d1c40dc223609904ecf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a434f1953d9800d1c40dc223609904ecf">operator+</a> (<a class="el" href="classdouble.html">double</a> c, <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p)</td></tr>
<tr class="separator:a434f1953d9800d1c40dc223609904ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34397d7d032b5c4214a92123e3c6752d"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a34397d7d032b5c4214a92123e3c6752d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a34397d7d032b5c4214a92123e3c6752d">operator+</a> (<a class="el" href="classdouble.html">double</a> c, const BasisElement &amp;m)</td></tr>
<tr class="separator:a34397d7d032b5c4214a92123e3c6752d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580ca04916246340e08ec69b45276827"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a580ca04916246340e08ec69b45276827"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a580ca04916246340e08ec69b45276827">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="separator:a580ca04916246340e08ec69b45276827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d8313aa6cdb78da3f2cd6d84b92e39"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a21d8313aa6cdb78da3f2cd6d84b92e39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a21d8313aa6cdb78da3f2cd6d84b92e39">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p)</td></tr>
<tr class="separator:a21d8313aa6cdb78da3f2cd6d84b92e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed13274bad687cfe8b3a1effa40d3117"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:aed13274bad687cfe8b3a1effa40d3117"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aed13274bad687cfe8b3a1effa40d3117">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p1, const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;p2)</td></tr>
<tr class="separator:aed13274bad687cfe8b3a1effa40d3117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0c3464fe7d151d7846e659e8e1d281"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:aac0c3464fe7d151d7846e659e8e1d281"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aac0c3464fe7d151d7846e659e8e1d281">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p, const BasisElement &amp;m)</td></tr>
<tr class="separator:aac0c3464fe7d151d7846e659e8e1d281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7632adf109d2b13d0a4fb81e7cb81f96"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a7632adf109d2b13d0a4fb81e7cb81f96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7632adf109d2b13d0a4fb81e7cb81f96">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p, <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:a7632adf109d2b13d0a4fb81e7cb81f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb122f4c4c5c71d0734c3b517a146df9"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:abb122f4c4c5c71d0734c3b517a146df9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abb122f4c4c5c71d0734c3b517a146df9">operator-</a> (const BasisElement &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p)</td></tr>
<tr class="separator:abb122f4c4c5c71d0734c3b517a146df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaab72f1cd4050603b25467fa909ec24"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:abaab72f1cd4050603b25467fa909ec24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abaab72f1cd4050603b25467fa909ec24">operator-</a> (const BasisElement &amp;m1, const BasisElement &amp;m2)</td></tr>
<tr class="separator:abaab72f1cd4050603b25467fa909ec24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ff0b6772551662f2b02b77b5889504"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:ad6ff0b6772551662f2b02b77b5889504"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad6ff0b6772551662f2b02b77b5889504">operator-</a> (const BasisElement &amp;m, <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:ad6ff0b6772551662f2b02b77b5889504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51133160077bdcba90013d1f21b88410"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a51133160077bdcba90013d1f21b88410"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a51133160077bdcba90013d1f21b88410">operator-</a> (<a class="el" href="classdouble.html">double</a> c, <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p)</td></tr>
<tr class="separator:a51133160077bdcba90013d1f21b88410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc778273d730c518678796b632e4de8f"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:afc778273d730c518678796b632e4de8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#afc778273d730c518678796b632e4de8f">operator-</a> (<a class="el" href="classdouble.html">double</a> c, const BasisElement &amp;m)</td></tr>
<tr class="separator:afc778273d730c518678796b632e4de8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120ae90dfc24dd3f7b4f42aededbabfd"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a120ae90dfc24dd3f7b4f42aededbabfd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a120ae90dfc24dd3f7b4f42aededbabfd">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="separator:a120ae90dfc24dd3f7b4f42aededbabfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfcadf9b33656022c0c071a8af3fd85e"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:adfcadf9b33656022c0c071a8af3fd85e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#adfcadf9b33656022c0c071a8af3fd85e">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p)</td></tr>
<tr class="separator:adfcadf9b33656022c0c071a8af3fd85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8ec1d6463a6936e7865e8cef04082f"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:acf8ec1d6463a6936e7865e8cef04082f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acf8ec1d6463a6936e7865e8cef04082f">operator *</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p1, const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;p2)</td></tr>
<tr class="separator:acf8ec1d6463a6936e7865e8cef04082f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876c3318865d9ffaadd1c3f7a711fdfa"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a876c3318865d9ffaadd1c3f7a711fdfa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a876c3318865d9ffaadd1c3f7a711fdfa">operator *</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p, const BasisElement &amp;m)</td></tr>
<tr class="separator:a876c3318865d9ffaadd1c3f7a711fdfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173be3cb77f72bb9481db5c8fd04741e"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a173be3cb77f72bb9481db5c8fd04741e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a173be3cb77f72bb9481db5c8fd04741e">operator *</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p, <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:a173be3cb77f72bb9481db5c8fd04741e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46745f049faa36c24020902f121e900c"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a46745f049faa36c24020902f121e900c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a46745f049faa36c24020902f121e900c">operator *</a> (const BasisElement &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p)</td></tr>
<tr class="separator:a46745f049faa36c24020902f121e900c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca14414fd5dcd3628a3a5aff79eabebc"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:aca14414fd5dcd3628a3a5aff79eabebc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aca14414fd5dcd3628a3a5aff79eabebc">operator *</a> (const BasisElement &amp;m, <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:aca14414fd5dcd3628a3a5aff79eabebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5300a119664e3092e90248af90a376"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a4e5300a119664e3092e90248af90a376"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4e5300a119664e3092e90248af90a376">operator *</a> (<a class="el" href="classdouble.html">double</a> c, <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p)</td></tr>
<tr class="separator:a4e5300a119664e3092e90248af90a376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d786db05bfa5937e62a34b9519424f3"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a8d786db05bfa5937e62a34b9519424f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8d786db05bfa5937e62a34b9519424f3">operator *</a> (<a class="el" href="classdouble.html">double</a> c, const BasisElement &amp;m)</td></tr>
<tr class="separator:a8d786db05bfa5937e62a34b9519424f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5935b2c56af883d2bacdfa61998c0d2e"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a5935b2c56af883d2bacdfa61998c0d2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5935b2c56af883d2bacdfa61998c0d2e">operator *</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="separator:a5935b2c56af883d2bacdfa61998c0d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e51bfc83d5ab488518b664db9e5cd34"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a6e51bfc83d5ab488518b664db9e5cd34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6e51bfc83d5ab488518b664db9e5cd34">operator *</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p)</td></tr>
<tr class="separator:a6e51bfc83d5ab488518b664db9e5cd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1504176a6220b744ee8b07a0ed920f15"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a1504176a6220b744ee8b07a0ed920f15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1504176a6220b744ee8b07a0ed920f15">operator/</a> (<a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; p, <a class="el" href="classdouble.html">double</a> v)</td></tr>
<tr class="memdesc:a1504176a6220b744ee8b07a0ed920f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>p / v</code>.  <a href="#a1504176a6220b744ee8b07a0ed920f15">More...</a><br /></td></tr>
<tr class="separator:a1504176a6220b744ee8b07a0ed920f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830fbf97ac01bf807b4915e3087585da"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a830fbf97ac01bf807b4915e3087585da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt; BasisElement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a830fbf97ac01bf807b4915e3087585da">pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;p, <a class="el" href="classint.html">int</a> n)</td></tr>
<tr class="memdesc:a830fbf97ac01bf807b4915e3087585da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns polynomial <code>raised</code> to <code>n</code>.  <a href="#a830fbf97ac01bf807b4915e3087585da">More...</a><br /></td></tr>
<tr class="separator:a830fbf97ac01bf807b4915e3087585da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673a4c5428fa87d2279c587959d5e3e7"><td class="memTemplParams" colspan="2">template&lt;typename BasisElement &gt; </td></tr>
<tr class="memitem:a673a4c5428fa87d2279c587959d5e3e7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a673a4c5428fa87d2279c587959d5e3e7">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;p)</td></tr>
<tr class="separator:a673a4c5428fa87d2279c587959d5e3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f946a2d656be1b946c8f2f6bf00810"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a50f946a2d656be1b946c8f2f6bf00810">ToLatex</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, <a class="el" href="classint.html">int</a> precision=3)</td></tr>
<tr class="memdesc:a50f946a2d656be1b946c8f2f6bf00810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a LaTeX string representation of <code>e</code> with floating point coefficients displayed using <code>precision</code>.  <a href="#a50f946a2d656be1b946c8f2f6bf00810">More...</a><br /></td></tr>
<tr class="separator:a50f946a2d656be1b946c8f2f6bf00810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb78ec8e49199eaff087d9637301041"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#accb78ec8e49199eaff087d9637301041">ToLatex</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f, <a class="el" href="classint.html">int</a> precision=3)</td></tr>
<tr class="memdesc:accb78ec8e49199eaff087d9637301041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a LaTeX string representation of <code>f</code> with floating point coefficients displayed using <code>precision</code>.  <a href="#accb78ec8e49199eaff087d9637301041">More...</a><br /></td></tr>
<tr class="separator:accb78ec8e49199eaff087d9637301041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b1d770b9e21d7e4f36649630b10891"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a38b1d770b9e21d7e4f36649630b10891">ToLatex</a> (<a class="el" href="classdouble.html">double</a> val, <a class="el" href="classint.html">int</a> precision=3)</td></tr>
<tr class="memdesc:a38b1d770b9e21d7e4f36649630b10891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a Latex string representation of <code>val</code> displayed with <code>precision</code>, with one exception.  <a href="#a38b1d770b9e21d7e4f36649630b10891">More...</a><br /></td></tr>
<tr class="separator:a38b1d770b9e21d7e4f36649630b10891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14d755813030ea14c7207a4e0e71f9f"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aa14d755813030ea14c7207a4e0e71f9f"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa14d755813030ea14c7207a4e0e71f9f">ToLatex</a> (const Eigen::PlainObjectBase&lt; Derived &gt; &amp;M, <a class="el" href="classint.html">int</a> precision=3)</td></tr>
<tr class="memdesc:aa14d755813030ea14c7207a4e0e71f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a LaTeX string representation of <code>M</code> with floating point coefficients displayed using <code>precision</code>.  <a href="#aa14d755813030ea14c7207a4e0e71f9f">More...</a><br /></td></tr>
<tr class="separator:aa14d755813030ea14c7207a4e0e71f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8505db5f6e70df16a3cecda394bdcb24"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8505db5f6e70df16a3cecda394bdcb24">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:a8505db5f6e70df16a3cecda394bdcb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791475e9d37a8e5fd5f1314045428997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a791475e9d37a8e5fd5f1314045428997">operator *</a> (<a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> m1, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m2)</td></tr>
<tr class="memdesc:a791475e9d37a8e5fd5f1314045428997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a multiplication of two monomials, <code>m1</code> and <code>m2</code>.  <a href="#a791475e9d37a8e5fd5f1314045428997">More...</a><br /></td></tr>
<tr class="separator:a791475e9d37a8e5fd5f1314045428997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3d409cea5e6c6495394208c8c8c6ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8b3d409cea5e6c6495394208c8c8c6ee">pow</a> (<a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> m, <a class="el" href="classint.html">int</a> p)</td></tr>
<tr class="memdesc:a8b3d409cea5e6c6495394208c8c8c6ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>m</code> raised to <code>p</code>.  <a href="#a8b3d409cea5e6c6495394208c8c8c6ee">More...</a><br /></td></tr>
<tr class="separator:a8b3d409cea5e6c6495394208c8c8c6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71ffcec2b8e06d52b7c6e8f53106160"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af71ffcec2b8e06d52b7c6e8f53106160">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a> &amp;m)</td></tr>
<tr class="separator:af71ffcec2b8e06d52b7c6e8f53106160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5885669a7b9958dc209c13778d48e6ef"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a>, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5885669a7b9958dc209c13778d48e6ef">operator *</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a> &amp;m1, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a> &amp;m2)</td></tr>
<tr class="memdesc:a5885669a7b9958dc209c13778d48e6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a multiplication of two monomials, <code>m1</code> and <code>m2</code>.  <a href="#a5885669a7b9958dc209c13778d48e6ef">More...</a><br /></td></tr>
<tr class="separator:a5885669a7b9958dc209c13778d48e6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1d54669ca8ae5ea474b5904c50e85e"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a>, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aec1d54669ca8ae5ea474b5904c50e85e">pow</a> (<a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a> m, <a class="el" href="classint.html">int</a> p)</td></tr>
<tr class="memdesc:aec1d54669ca8ae5ea474b5904c50e85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>m</code> raised to <code>p</code>.  <a href="#aec1d54669ca8ae5ea474b5904c50e85e">More...</a><br /></td></tr>
<tr class="separator:aec1d54669ca8ae5ea474b5904c50e85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c0029b04f957181b0cb2bdae701514"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a04c0029b04f957181b0cb2bdae701514">MonomialBasis</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars, <a class="el" href="classint.html">int</a> degree)</td></tr>
<tr class="memdesc:a04c0029b04f957181b0cb2bdae701514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all monomials up to a given degree under the graded reverse lexicographic order.  <a href="#a04c0029b04f957181b0cb2bdae701514">More...</a><br /></td></tr>
<tr class="separator:a04c0029b04f957181b0cb2bdae701514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40528027cce753aacb377913342f536"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa40528027cce753aacb377913342f536">NChooseK</a> (<a class="el" href="classint.html">int</a> n, <a class="el" href="classint.html">int</a> k)</td></tr>
<tr class="separator:aa40528027cce753aacb377913342f536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af297794f22c0458592aeea637cce060a"><td class="memTemplParams" colspan="2">template&lt;int n, int degree&gt; </td></tr>
<tr class="memitem:af297794f22c0458592aeea637cce060a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, <a class="el" href="namespacedrake_1_1symbolic.html#aa40528027cce753aacb377913342f536">NChooseK</a>(n+degree, degree), 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af297794f22c0458592aeea637cce060a">MonomialBasis</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars)</td></tr>
<tr class="memdesc:af297794f22c0458592aeea637cce060a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all monomials up to a given degree under the graded reverse lexicographic order.  <a href="#af297794f22c0458592aeea637cce060a">More...</a><br /></td></tr>
<tr class="separator:af297794f22c0458592aeea637cce060a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a514c95fcf3b0d8ec0965e59ae9be6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a30a514c95fcf3b0d8ec0965e59ae9be6">MonomialBasis</a> (const std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>, <a class="el" href="classint.html">int</a> &gt; &amp;variables_degree)</td></tr>
<tr class="memdesc:a30a514c95fcf3b0d8ec0965e59ae9be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all the monomials (in graded reverse lexicographic order) such that the total degree for each set of variables is no larger than a specific degree.  <a href="#a30a514c95fcf3b0d8ec0965e59ae9be6">More...</a><br /></td></tr>
<tr class="separator:a30a514c95fcf3b0d8ec0965e59ae9be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff00cd9261b602f7ce7708286d2dae05"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aff00cd9261b602f7ce7708286d2dae05">EvenDegreeMonomialBasis</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars, <a class="el" href="classint.html">int</a> degree)</td></tr>
<tr class="memdesc:aff00cd9261b602f7ce7708286d2dae05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all even degree monomials up to a given degree under the graded reverse lexicographic order.  <a href="#aff00cd9261b602f7ce7708286d2dae05">More...</a><br /></td></tr>
<tr class="separator:aff00cd9261b602f7ce7708286d2dae05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6ac4e26dcd9023a9f8146aa75454c7"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ade6ac4e26dcd9023a9f8146aa75454c7">OddDegreeMonomialBasis</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars, <a class="el" href="classint.html">int</a> degree)</td></tr>
<tr class="memdesc:ade6ac4e26dcd9023a9f8146aa75454c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all odd degree monomials up to a given degree under the graded reverse lexicographic order.  <a href="#ade6ac4e26dcd9023a9f8146aa75454c7">More...</a><br /></td></tr>
<tr class="separator:ade6ac4e26dcd9023a9f8146aa75454c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9487e2826e1e3dda3bed0697b25a11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#afe9487e2826e1e3dda3bed0697b25a11">CalcMonomialBasisOrderUpToOne</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;<a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, bool sort_monomial=false)</td></tr>
<tr class="memdesc:afe9487e2826e1e3dda3bed0697b25a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates all the monomials of <code>x</code>, such that the degree for x(i) is no larger than 1 for every x(i) in <code>x</code>.  <a href="#afe9487e2826e1e3dda3bed0697b25a11">More...</a><br /></td></tr>
<tr class="separator:afe9487e2826e1e3dda3bed0697b25a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade37df718218bcbdbc1edd9a0b6a596a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ade37df718218bcbdbc1edd9a0b6a596a">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="memdesc:ade37df718218bcbdbc1edd9a0b6a596a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operation for polynomial.  <a href="#ade37df718218bcbdbc1edd9a0b6a596a">More...</a><br /></td></tr>
<tr class="separator:ade37df718218bcbdbc1edd9a0b6a596a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb3773f2d585ffce0253cb15c8c00a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#affb3773f2d585ffce0253cb15c8c00a0">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p1, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p2)</td></tr>
<tr class="separator:affb3773f2d585ffce0253cb15c8c00a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a4be02d87d5a6d31efbbcb5d3ba934"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a52a4be02d87d5a6d31efbbcb5d3ba934">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:a52a4be02d87d5a6d31efbbcb5d3ba934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b091bab8bb06edd276c6b4a420903c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a96b091bab8bb06edd276c6b4a420903c">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:a96b091bab8bb06edd276c6b4a420903c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04dff9a90e39ac9985d520d3e66f5c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af04dff9a90e39ac9985d520d3e66f5c3">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="separator:af04dff9a90e39ac9985d520d3e66f5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e02326d779ba8c55ad9d9f6eb54f3d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4e02326d779ba8c55ad9d9f6eb54f3d8">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m1, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m2)</td></tr>
<tr class="separator:a4e02326d779ba8c55ad9d9f6eb54f3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd958cf7990638bdd2576c2ab62ad43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8dd958cf7990638bdd2576c2ab62ad43">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:a8dd958cf7990638bdd2576c2ab62ad43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289b47480364e01b67e3c86aa33a0fe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a289b47480364e01b67e3c86aa33a0fe4">operator+</a> (<a class="el" href="classdouble.html">double</a> c, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="separator:a289b47480364e01b67e3c86aa33a0fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee4b0876c4a92c7bd3030b193ce0dbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5ee4b0876c4a92c7bd3030b193ce0dbd">operator+</a> (<a class="el" href="classdouble.html">double</a> c, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:a5ee4b0876c4a92c7bd3030b193ce0dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42522d07a4a9c32a89e8b4eea9a00a60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a42522d07a4a9c32a89e8b4eea9a00a60">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="separator:a42522d07a4a9c32a89e8b4eea9a00a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab876f48eb96e82b718df0050b9d57d8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab876f48eb96e82b718df0050b9d57d8b">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="separator:ab876f48eb96e82b718df0050b9d57d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bfdaed2217f9183cde2f08246cece4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad8bfdaed2217f9183cde2f08246cece4">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:ad8bfdaed2217f9183cde2f08246cece4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5e34034488d988d8349100bbdc359c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2f5e34034488d988d8349100bbdc359c">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a2f5e34034488d988d8349100bbdc359c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa3f21ab39b7fb01be90ed9255df5f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1aa3f21ab39b7fb01be90ed9255df5f9">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p1, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p2)</td></tr>
<tr class="separator:a1aa3f21ab39b7fb01be90ed9255df5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc89061cd63bf0e4d0d79c57d3b72e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aacc89061cd63bf0e4d0d79c57d3b72e4">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:aacc89061cd63bf0e4d0d79c57d3b72e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f8b6bfe08648f4a0dac518e1abb0bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a48f8b6bfe08648f4a0dac518e1abb0bd">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:a48f8b6bfe08648f4a0dac518e1abb0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada023ba3d82bbf8137d74409bf596457"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ada023ba3d82bbf8137d74409bf596457">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="separator:ada023ba3d82bbf8137d74409bf596457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4fa4bbef7ce58efc247dd1717a2ded"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0e4fa4bbef7ce58efc247dd1717a2ded">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m1, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m2)</td></tr>
<tr class="separator:a0e4fa4bbef7ce58efc247dd1717a2ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369ea32ea396cc86951892020d5c4a4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a369ea32ea396cc86951892020d5c4a4b">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:a369ea32ea396cc86951892020d5c4a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6ad1d11dea0eafbfed0db238957d64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abe6ad1d11dea0eafbfed0db238957d64">operator-</a> (<a class="el" href="classdouble.html">double</a> c, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="separator:abe6ad1d11dea0eafbfed0db238957d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448e985024e32143f3ca12d8596211d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a448e985024e32143f3ca12d8596211d4">operator-</a> (<a class="el" href="classdouble.html">double</a> c, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:a448e985024e32143f3ca12d8596211d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03731fe9a001a20e071a7a9e106061bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a03731fe9a001a20e071a7a9e106061bd">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="separator:a03731fe9a001a20e071a7a9e106061bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f8eee8c5c646b5f3fc43baf3ce5854"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a30f8eee8c5c646b5f3fc43baf3ce5854">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:a30f8eee8c5c646b5f3fc43baf3ce5854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975e86e30c5c98ede0b2a1f49d1d8c7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a975e86e30c5c98ede0b2a1f49d1d8c7d">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:a975e86e30c5c98ede0b2a1f49d1d8c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac596e9b191c4eaa992bcb9d7718e9554"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac596e9b191c4eaa992bcb9d7718e9554">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:ac596e9b191c4eaa992bcb9d7718e9554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b6eea79253234902bbcf4643e34d81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae3b6eea79253234902bbcf4643e34d81">operator *</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p1, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p2)</td></tr>
<tr class="separator:ae3b6eea79253234902bbcf4643e34d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e804fc81cb6d40414b816f559f81a7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9e804fc81cb6d40414b816f559f81a7d">operator *</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:a9e804fc81cb6d40414b816f559f81a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38134e3394d8c40a7a91490154de2b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af38134e3394d8c40a7a91490154de2b3">operator *</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:af38134e3394d8c40a7a91490154de2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04739aabb37142340b869a126cc54a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab04739aabb37142340b869a126cc54a1">operator *</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="separator:ab04739aabb37142340b869a126cc54a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812892dbfc6443dc1eed055e1915f5e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a812892dbfc6443dc1eed055e1915f5e4">operator *</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:a812892dbfc6443dc1eed055e1915f5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fe276a728b54ce277fcc972fd28d78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a46fe276a728b54ce277fcc972fd28d78">operator *</a> (<a class="el" href="classdouble.html">double</a> c, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="separator:a46fe276a728b54ce277fcc972fd28d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78d0e5127e0fa0fab9f26c075c6ad9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa78d0e5127e0fa0fab9f26c075c6ad9d">operator *</a> (<a class="el" href="classdouble.html">double</a> c, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:aa78d0e5127e0fa0fab9f26c075c6ad9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0eab276a88883d8e2607630cb93bc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1a0eab276a88883d8e2607630cb93bc5">operator *</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="separator:a1a0eab276a88883d8e2607630cb93bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66975f1892907d118eb8cb98d6465c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab66975f1892907d118eb8cb98d6465c7">operator *</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="separator:ab66975f1892907d118eb8cb98d6465c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed4b0b5f2e0f804d54ab68b0195ec7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9ed4b0b5f2e0f804d54ab68b0195ec7a">operator *</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:a9ed4b0b5f2e0f804d54ab68b0195ec7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7664d13fc20b1e7e30ebb16f3dfdeaac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7664d13fc20b1e7e30ebb16f3dfdeaac">operator *</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a7664d13fc20b1e7e30ebb16f3dfdeaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9423440606bd13d4767c72dd97ec6a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae9423440606bd13d4767c72dd97ec6a2">operator/</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, <a class="el" href="classdouble.html">double</a> v)</td></tr>
<tr class="memdesc:ae9423440606bd13d4767c72dd97ec6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>p / v</code>.  <a href="#ae9423440606bd13d4767c72dd97ec6a2">More...</a><br /></td></tr>
<tr class="separator:ae9423440606bd13d4767c72dd97ec6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d4982fe5eb3fd118c9a1cfed0f8efa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a84d4982fe5eb3fd118c9a1cfed0f8efa">operator/</a> (<a class="el" href="classdouble.html">double</a> v, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:a84d4982fe5eb3fd118c9a1cfed0f8efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98465062118b5f7461c5fc510842de10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a98465062118b5f7461c5fc510842de10">operator/</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:a98465062118b5f7461c5fc510842de10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4709897ce3846a69f2882e2bdfbd5dff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4709897ce3846a69f2882e2bdfbd5dff">operator/</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a4709897ce3846a69f2882e2bdfbd5dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa3b0259a14e44faf2d959f540e9446"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8fa3b0259a14e44faf2d959f540e9446">pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, <a class="el" href="classint.html">int</a> n)</td></tr>
<tr class="memdesc:a8fa3b0259a14e44faf2d959f540e9446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns polynomial <code>p</code> raised to <code>n</code>.  <a href="#a8fa3b0259a14e44faf2d959f540e9446">More...</a><br /></td></tr>
<tr class="separator:a8fa3b0259a14e44faf2d959f540e9446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9eb2f0937be3e670ccdca9c4d30c63d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad9eb2f0937be3e670ccdca9c4d30c63d">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:ad9eb2f0937be3e670ccdca9c4d30c63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9527491f78970e42f830e74808a0048"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:ab9527491f78970e42f830e74808a0048"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab9527491f78970e42f830e74808a0048">operator *</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:ab9527491f78970e42f830e74808a0048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following matrix operations:  <a href="#ab9527491f78970e42f830e74808a0048">More...</a><br /></td></tr>
<tr class="separator:ab9527491f78970e42f830e74808a0048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2508a6626d1a63a77670c760e4a2241e"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a2508a6626d1a63a77670c760e4a2241e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &gt;, <a class="el" href="namespacedrake.html#aaadcdc21cc0c381e5879b1b7f023d82d">MatrixLikewise</a>&lt; <a class="el" href="classdouble.html">double</a>, Derived &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2508a6626d1a63a77670c760e4a2241e">Evaluate</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;env)</td></tr>
<tr class="memdesc:a2508a6626d1a63a77670c760e4a2241e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a matrix <code>m</code> of symbolic polynomials using <code>env</code>.  <a href="#a2508a6626d1a63a77670c760e4a2241e">More...</a><br /></td></tr>
<tr class="separator:a2508a6626d1a63a77670c760e4a2241e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e355d7c9eb6bff11199a94c16ed5c8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5e355d7c9eb6bff11199a94c16ed5c8a">Jacobian</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &gt;&gt; &amp;f, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;vars)</td></tr>
<tr class="memdesc:a5e355d7c9eb6bff11199a94c16ed5c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian matrix J of the vector function <code>f</code> with respect to <code>vars</code>.  <a href="#a5e355d7c9eb6bff11199a94c16ed5c8a">More...</a><br /></td></tr>
<tr class="separator:a5e355d7c9eb6bff11199a94c16ed5c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2eee496b130c9d1acbff60e3fd3eb1"><td class="memTemplParams" colspan="2">template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a1b2eee496b130c9d1acbff60e3fd3eb1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt; Derived1, <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;::value &amp;&amp;(<a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt; Derived2, <a class="el" href="classdouble.html">double</a> &gt;::value||<a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt; Derived2, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;::value||<a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt; Derived2, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;::value), <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1b2eee496b130c9d1acbff60e3fd3eb1">CalcPolynomialWLowerTriangularPart</a> (const Eigen::MatrixBase&lt; Derived1 &gt; &amp;monomial_basis, const Eigen::MatrixBase&lt; Derived2 &gt; &amp;gram_lower)</td></tr>
<tr class="memdesc:a1b2eee496b130c9d1acbff60e3fd3eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the polynomial m(x)ᵀ * Q * m(x), where m(x) is the monomial basis, and Q is the Gram matrix.  <a href="#a1b2eee496b130c9d1acbff60e3fd3eb1">More...</a><br /></td></tr>
<tr class="separator:a1b2eee496b130c9d1acbff60e3fd3eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a29f70485ada14c4bba67192ac4efc"><td class="memTemplParams" colspan="2">template&lt;int rows, typename BasisElement &gt; </td></tr>
<tr class="memitem:a83a29f70485ada14c4bba67192ac4efc"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; BasisElement, rows, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a83a29f70485ada14c4bba67192ac4efc">ComputePolynomialBasisUpToDegree</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars, <a class="el" href="classint.html">int</a> degree, internal::DegreeType degree_type)</td></tr>
<tr class="memdesc:a83a29f70485ada14c4bba67192ac4efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all polynomial basis elements up to a given degree under the graded reverse lexicographic order.  <a href="#a83a29f70485ada14c4bba67192ac4efc">More...</a><br /></td></tr>
<tr class="separator:a83a29f70485ada14c4bba67192ac4efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8327415ae13cae1b0d450c384079a49e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8327415ae13cae1b0d450c384079a49e">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f1, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f2)</td></tr>
<tr class="separator:a8327415ae13cae1b0d450c384079a49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6364a2e4727b0af4071b15da0cad509"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac6364a2e4727b0af4071b15da0cad509">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:ac6364a2e4727b0af4071b15da0cad509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185c9ab6bca14a042a837aadf2064546"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a185c9ab6bca14a042a837aadf2064546">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="separator:a185c9ab6bca14a042a837aadf2064546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181410366c9b16014e81127717a13314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a181410366c9b16014e81127717a13314">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="separator:a181410366c9b16014e81127717a13314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d99af1951c74ac5377ce5e7ec953eb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6d99af1951c74ac5377ce5e7ec953eb6">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:a6d99af1951c74ac5377ce5e7ec953eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167d0d14d66effceeb5834371626452b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a167d0d14d66effceeb5834371626452b">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:a167d0d14d66effceeb5834371626452b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc08ea95543252bcf2b31fdfe723d26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0dc08ea95543252bcf2b31fdfe723d26">operator+</a> (<a class="el" href="classdouble.html">double</a> c, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="separator:a0dc08ea95543252bcf2b31fdfe723d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ea1fd857bdf8fa5c18f570118640ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af9ea1fd857bdf8fa5c18f570118640ff">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f1, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f2)</td></tr>
<tr class="separator:af9ea1fd857bdf8fa5c18f570118640ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec6e83953a4663403fcb08592e16b01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0ec6e83953a4663403fcb08592e16b01">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:a0ec6e83953a4663403fcb08592e16b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9120c262586410f015a00fcdd6fed2a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9120c262586410f015a00fcdd6fed2a7">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f)</td></tr>
<tr class="separator:a9120c262586410f015a00fcdd6fed2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad564d8bc7c97743e2ca0654c2c417c8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad564d8bc7c97743e2ca0654c2c417c8d">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:ad564d8bc7c97743e2ca0654c2c417c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f74050260696325581c3087d07fab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a22f74050260696325581c3087d07fab7">operator-</a> (<a class="el" href="classdouble.html">double</a> c, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="separator:a22f74050260696325581c3087d07fab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a9560b5bbc179968621e3df178742c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a44a9560b5bbc179968621e3df178742c">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="separator:a44a9560b5bbc179968621e3df178742c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579d06e36f094bf2eebf127dcbb46a1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a579d06e36f094bf2eebf127dcbb46a1c">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:a579d06e36f094bf2eebf127dcbb46a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97671d479c281451e703b58530b17082"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a97671d479c281451e703b58530b17082">operator *</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f1, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f2)</td></tr>
<tr class="separator:a97671d479c281451e703b58530b17082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71ee73fb966e97f0de864fa7cdb3692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad71ee73fb966e97f0de864fa7cdb3692">operator *</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:ad71ee73fb966e97f0de864fa7cdb3692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5c62b680b89f6fe992e5bc6b01e6c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1c5c62b680b89f6fe992e5bc6b01e6c7">operator *</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="separator:a1c5c62b680b89f6fe992e5bc6b01e6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1611c62700b00b9861c339879899a121"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1611c62700b00b9861c339879899a121">operator *</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:a1611c62700b00b9861c339879899a121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347249d56768661c610bf3bafb5ff167"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a347249d56768661c610bf3bafb5ff167">operator *</a> (<a class="el" href="classdouble.html">double</a> c, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="separator:a347249d56768661c610bf3bafb5ff167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad764207511a8257dbd13ac05ee5b85e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad764207511a8257dbd13ac05ee5b85e9">operator *</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="separator:ad764207511a8257dbd13ac05ee5b85e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c94dcccf4c09c83515332980d6a8eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac3c94dcccf4c09c83515332980d6a8eb">operator *</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:ac3c94dcccf4c09c83515332980d6a8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8b6db1763f8f7a5d98de636b9cd7c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3c8b6db1763f8f7a5d98de636b9cd7c9">operator/</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f1, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f2)</td></tr>
<tr class="separator:a3c8b6db1763f8f7a5d98de636b9cd7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8d6fb5671a17bf0c89c1c5aef9efaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4a8d6fb5671a17bf0c89c1c5aef9efaf">operator/</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:a4a8d6fb5671a17bf0c89c1c5aef9efaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ad135e8775cf9d721b1223218fff2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a27ad135e8775cf9d721b1223218fff2d">operator/</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f)</td></tr>
<tr class="separator:a27ad135e8775cf9d721b1223218fff2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687c99f46e854d9237083b2f34e6665c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a687c99f46e854d9237083b2f34e6665c">operator/</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="separator:a687c99f46e854d9237083b2f34e6665c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb47877c3cad48fe6a8e25edb0620495"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abb47877c3cad48fe6a8e25edb0620495">operator/</a> (<a class="el" href="classdouble.html">double</a> c, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f)</td></tr>
<tr class="separator:abb47877c3cad48fe6a8e25edb0620495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17039bebdf3cf731833b0ea132b431f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a17039bebdf3cf731833b0ea132b431f9">operator/</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="separator:a17039bebdf3cf731833b0ea132b431f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3765260423d079969572ed50b80934"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aff3765260423d079969572ed50b80934">operator/</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:aff3765260423d079969572ed50b80934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d86ae3f21714ef199febddf60550fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a43d86ae3f21714ef199febddf60550fe">pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f, <a class="el" href="classint.html">int</a> n)</td></tr>
<tr class="memdesc:a43d86ae3f21714ef199febddf60550fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rational function <code>f</code> raised to <code>n</code>.  <a href="#a43d86ae3f21714ef199febddf60550fe">More...</a><br /></td></tr>
<tr class="separator:a43d86ae3f21714ef199febddf60550fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267c5d854d55ce16b1e58490ff426661"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:a267c5d854d55ce16b1e58490ff426661"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a267c5d854d55ce16b1e58490ff426661">operator *</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:a267c5d854d55ce16b1e58490ff426661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following operations:  <a href="#a267c5d854d55ce16b1e58490ff426661">More...</a><br /></td></tr>
<tr class="separator:a267c5d854d55ce16b1e58490ff426661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04799bc5337c8999ef3f10e82dd979cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a04799bc5337c8999ef3f10e82dd979cd">ReplaceBilinearTerms</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;<a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;y, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;W)</td></tr>
<tr class="memdesc:a04799bc5337c8999ef3f10e82dd979cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all the bilinear product terms in the expression <code>e</code>, with the corresponding terms in <code>W</code>, where <code>W</code> represents the matrix x * yᵀ, such that after replacement, <code>e</code> does not have bilinear terms involving <code>x</code> and <code>y</code>.  <a href="#a04799bc5337c8999ef3f10e82dd979cd">More...</a><br /></td></tr>
<tr class="separator:a04799bc5337c8999ef3f10e82dd979cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697784ea0eafd05039e3a0c97b7c1415"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a134e54042165751a5e5369b4631c90eb">Rewriter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a697784ea0eafd05039e3a0c97b7c1415">MakeRuleRewriter</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html">RewritingRule</a> &amp;r)</td></tr>
<tr class="memdesc:a697784ea0eafd05039e3a0c97b7c1415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a rewriter based on a rewriting rule <code>r</code>.  <a href="#a697784ea0eafd05039e3a0c97b7c1415">More...</a><br /></td></tr>
<tr class="separator:a697784ea0eafd05039e3a0c97b7c1415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6639ded5e13e34eee457b3ceb92a1d62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6639ded5e13e34eee457b3ceb92a1d62">Substitute</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, const <a class="el" href="namespacedrake_1_1symbolic.html#a13c5d9eccfc9643fdd5764d6e72b8faf">SinCosSubstitution</a> &amp;subs)</td></tr>
<tr class="memdesc:a6639ded5e13e34eee457b3ceb92a1d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a substitution map q =&gt; {s, c}, substitutes instances of sin(q) and cos(q) in <code>e</code> with <code>s</code> and <code>c</code>, with partial support for trigonometric expansions.  <a href="#a6639ded5e13e34eee457b3ceb92a1d62">More...</a><br /></td></tr>
<tr class="separator:a6639ded5e13e34eee457b3ceb92a1d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db53e224c37b630f7ec9d1615215449"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a1db53e224c37b630f7ec9d1615215449"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#aaadcdc21cc0c381e5879b1b7f023d82d">MatrixLikewise</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1db53e224c37b630f7ec9d1615215449">Substitute</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const <a class="el" href="namespacedrake_1_1symbolic.html#a13c5d9eccfc9643fdd5764d6e72b8faf">SinCosSubstitution</a> &amp;subs)</td></tr>
<tr class="memdesc:a1db53e224c37b630f7ec9d1615215449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix version of sin/cos substitution.  <a href="#a1db53e224c37b630f7ec9d1615215449">More...</a><br /></td></tr>
<tr class="separator:a1db53e224c37b630f7ec9d1615215449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88f58019962d307b9da7ebc9d32ec87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">symbolic::RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad88f58019962d307b9da7ebc9d32ec87">SubstituteStereographicProjection</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;e, const std::vector&lt; <a class="el" href="structdrake_1_1symbolic_1_1_sin_cos.html">SinCos</a> &gt; &amp;sin_cos, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &amp;t)</td></tr>
<tr class="memdesc:ad88f58019962d307b9da7ebc9d32ec87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes the variables representing sine and cosine functions with their stereographic projection.  <a href="#ad88f58019962d307b9da7ebc9d32ec87">More...</a><br /></td></tr>
<tr class="separator:ad88f58019962d307b9da7ebc9d32ec87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a4f60d4b8ada97a4fb724b2d66d273892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f60d4b8ada97a4fb724b2d66d273892">&#9670;&nbsp;</a></span>GenericPolynomialEnable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a> =  std::enable_if_t&lt;std::is_base_of_v&lt;<a class="el" href="classdrake_1_1symbolic_1_1_polynomial_basis_element.html">PolynomialBasisElement</a>, BasisElement&gt;, <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt;BasisElement&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines an explicit SFINAE alias for use with return types to dissuade CTAD from trying to instantiate an invalid GenericElement&lt;&gt; for operator overloads, (if that's actually the case). </p>
<p>See discussion for more info: <a href="https://github.com/robotlocomotion/drake/pull/14053#pullrequestreview-488744679">https://github.com/robotlocomotion/drake/pull/14053#pullrequestreview-488744679</a> </p>

</div>
</div>
<a id="aeb27ddf30420e620beb8e6725d83208f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb27ddf30420e620beb8e6725d83208f">&#9670;&nbsp;</a></span>Pattern</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1symbolic.html#aeb27ddf30420e620beb8e6725d83208f">Pattern</a> =  <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pattern is an expression which possibly includes variables which represent placeholders. </p>
<p>It is used to construct a <code><a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html" title="A RewritingRule, lhs =&gt; rhs, consists of two Patterns lhs and rhs.">RewritingRule</a></code>. </p>

</div>
</div>
<a id="a134e54042165751a5e5369b4631c90eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134e54042165751a5e5369b4631c90eb">&#9670;&nbsp;</a></span>Rewriter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1symbolic.html#a134e54042165751a5e5369b4631c90eb">Rewriter</a> =  std::function&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>(const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code>Rewriter</code> is a function from an <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">Expression</a> to an <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">Expression</a>. </p>

</div>
</div>
<a id="a13c5d9eccfc9643fdd5764d6e72b8faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c5d9eccfc9643fdd5764d6e72b8faf">&#9670;&nbsp;</a></span>SinCosSubstitution</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1symbolic.html#a13c5d9eccfc9643fdd5764d6e72b8faf">SinCosSubstitution</a> =  std::unordered_map&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, <a class="el" href="structdrake_1_1symbolic_1_1_sin_cos.html">SinCos</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbfe43d34e6c71c503d4de11da53bbb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbfe43d34e6c71c503d4de11da53bbb7">&#9670;&nbsp;</a></span>Substitution</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1symbolic.html#acbfe43d34e6c71c503d4de11da53bbb7">Substitution</a> =  std::unordered_map&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a245f75ee96839b12e22fea09c6f3ec91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245f75ee96839b12e22fea09c6f3ec91">&#9670;&nbsp;</a></span>ExpressionKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91">ExpressionKind</a> : std::uint16_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kinds of symbolic expressions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91acb17869fe51048b5a5c4c6106551a255"></a>Constant&#160;</td><td class="fielddoc"><p>constant (double) </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a5a92344ee95acf10c31901b36418be77"></a>Var&#160;</td><td class="fielddoc"><p>variable </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91aec211f7c20af43e742bf2570c3cb84f9"></a>Add&#160;</td><td class="fielddoc"><p>addition (+) </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a62b6d55816cf737bfc6f42e60df1a3f2"></a>Mul&#160;</td><td class="fielddoc"><p>multiplication (*) </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a43d11850893d2fe84a1e618121c1cc0a"></a>Div&#160;</td><td class="fielddoc"><p>division (/) </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91ace0be71e33226e4c1db2bcea5959f16b"></a>Log&#160;</td><td class="fielddoc"><p>logarithms </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a1e34af023adeb7d5f484f8eb4b9826b6"></a>Abs&#160;</td><td class="fielddoc"><p>absolute value function </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91acad39a154bffb61175f674d6eefaf6d0"></a>Exp&#160;</td><td class="fielddoc"><p>exponentiation </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91aae77f3ad25595e35b327334d89410054"></a>Sqrt&#160;</td><td class="fielddoc"><p>square root </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a8be6d3e955290ee50c00a4bc92aa7749"></a>Pow&#160;</td><td class="fielddoc"><p>power function </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a0986d137604183312e6d3599578bc6cd"></a>Sin&#160;</td><td class="fielddoc"><p>sine </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91affca562be079b9e4e41ea9d6a86c582b"></a>Cos&#160;</td><td class="fielddoc"><p>cosine </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a1266b4e6f81e60733ec6c717e0181f60"></a>Tan&#160;</td><td class="fielddoc"><p>tangent </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a76cfc54de4e2b9cde17334c821217d11"></a>Asin&#160;</td><td class="fielddoc"><p>arcsine </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91aed4629033ecb516ed7d1536e162030bb"></a>Acos&#160;</td><td class="fielddoc"><p>arccosine </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91ac9968ab1fa8103acbb3a4f22265f2def"></a>Atan&#160;</td><td class="fielddoc"><p>arctangent </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a5816dfcaf3b6dbb486ef9c8c006ff613"></a>Atan2&#160;</td><td class="fielddoc"><p>arctangent2 (atan2(y,x) = atan(y/x)) </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a98ed804abf4edd1f3be3fa894fa8cc3d"></a>Sinh&#160;</td><td class="fielddoc"><p>hyperbolic sine </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a4371c3565b771b40c187487cc0190392"></a>Cosh&#160;</td><td class="fielddoc"><p>hyperbolic cosine </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91acc132a41cab5676334f353a22a0aa5c5"></a>Tanh&#160;</td><td class="fielddoc"><p>hyperbolic tangent </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a78d811e98514cd165dda532286610fd2"></a>Min&#160;</td><td class="fielddoc"><p>min </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a6a061313d22e51e0f25b7cd4dc065233"></a>Max&#160;</td><td class="fielddoc"><p>max </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91ab95a01ffffa8fcdd2a9af961937c097c"></a>Ceil&#160;</td><td class="fielddoc"><p>ceil </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91af3f6d0343d56ce88ce7958170ed05cb3"></a>Floor&#160;</td><td class="fielddoc"><p>floor </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91aaff6933d8331eca27edc911467980c9c"></a>IfThenElse&#160;</td><td class="fielddoc"><p>if then else </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a7ecfb3bf076a6a9635f975fe96ac97fd"></a>NaN&#160;</td><td class="fielddoc"><p>NaN. </p>
</td></tr>
<tr><td class="fieldname"><a id="a245f75ee96839b12e22fea09c6f3ec91a2e59a51ac43bc3415c1b8ce7b3f98579"></a>UninterpretedFunction&#160;</td><td class="fielddoc"><p>Uninterpreted function. </p>
</td></tr>
</table>

</div>
</div>
<a id="a6869e7044dd90be5d972ee7dd4e821b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6869e7044dd90be5d972ee7dd4e821b6">&#9670;&nbsp;</a></span>FormulaKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kinds of symbolic formulas. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6af8320b26d30ab433c5a54546d21f414c"></a>False&#160;</td><td class="fielddoc"><p>⊥ </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6af827cf462f62848df37c5e1e94a4da74"></a>True&#160;</td><td class="fielddoc"><p>⊤ </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a5a92344ee95acf10c31901b36418be77"></a>Var&#160;</td><td class="fielddoc"><p>Boolean <a class="el" href="classdrake_1_1symbolic_1_1_variable.html" title="Represents a symbolic variable.">Variable</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a3718b5ecf60aa0dba49e150e96cb1fc3"></a>Eq&#160;</td><td class="fielddoc"><p>= </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6ae4ecc5da3c6dbb4448f25990dc609727"></a>Neq&#160;</td><td class="fielddoc"><p>!= </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a086cb8308e5a36e7c4ed1f8873ad801f"></a>Gt&#160;</td><td class="fielddoc"><p>&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a5dabfebb89e6e45a8cf8573d92746ed3"></a>Geq&#160;</td><td class="fielddoc"><p>&gt;= </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a50033c15af7795cd6617f117b29d6922"></a>Lt&#160;</td><td class="fielddoc"><p>&lt; </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6abe5721bf93d718a79358217ec9b88176"></a>Leq&#160;</td><td class="fielddoc"><p>&lt;= </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6ac33315685a0cba3ce53be378b3c7874b"></a>And&#160;</td><td class="fielddoc"><p>Conjunction (∧) </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a3a2d5fe857d8f9541136a124c2edec6c"></a>Or&#160;</td><td class="fielddoc"><p>Disjunction (∨) </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6aa74c05d080620f087c4e523977230666"></a>Not&#160;</td><td class="fielddoc"><p>Negation (¬) </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a43cfe3c750a08acb91df1e3384548078"></a>Forall&#160;</td><td class="fielddoc"><p>Universal quantification (∀) </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6afd116e3418522ffc34d7423bc601510d"></a>Isnan&#160;</td><td class="fielddoc"><p>NaN check predicate. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a1fbc164d3e50b7fd20690a21f1b7b2f2"></a>PositiveSemidefinite&#160;</td><td class="fielddoc"><p>Positive semidefinite matrix. </p>
</td></tr>
</table>

</div>
</div>
<a id="a0f7729e9ae50c2b5ca1d86021ad1ae44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7729e9ae50c2b5ca1d86021ad1ae44">&#9670;&nbsp;</a></span>SinCosSubstitutionType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1symbolic.html#a0f7729e9ae50c2b5ca1d86021ad1ae44">SinCosSubstitutionType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0f7729e9ae50c2b5ca1d86021ad1ae44af4d2017f452ed392e963b2d8ddf591bb"></a>kAngle&#160;</td><td class="fielddoc"><p>Substitutes s &lt;=&gt; sin(q), c &lt;=&gt; cos(q). </p>
</td></tr>
<tr><td class="fieldname"><a id="a0f7729e9ae50c2b5ca1d86021ad1ae44aea1eea0840dd2bfd79a5cbfdf49ea143"></a>kHalfAnglePreferSin&#160;</td><td class="fielddoc"><p>Substitutes s &lt;=&gt; sin(q/2), c &lt;=&gt; cos(q/2), and prefers sin when the choice is ambiguous; e.g. </p>
<p>cos(q) =&gt; 1 - 2s². </p>
</td></tr>
<tr><td class="fieldname"><a id="a0f7729e9ae50c2b5ca1d86021ad1ae44acdf5f9e766a4e04d5ac3bf38e82da0f0"></a>kHalfAnglePreferCos&#160;</td><td class="fielddoc"><p>Substitutes s &lt;=&gt; sin(q/2), c &lt;=&gt; cos(q/2), and prefers cos when the choice is ambiguous; e.g. </p>
<p>cos(q) =&gt; 2c² - 1. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a24ba050d5b6f088d5fe578396b3ad646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ba050d5b6f088d5fe578396b3ad646">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6244fef922874b743a272fe683cf068b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6244fef922874b743a272fe683cf068b">&#9670;&nbsp;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa12acbb0b86d35d1de9280e699d3999d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12acbb0b86d35d1de9280e699d3999d">&#9670;&nbsp;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5beb575f1104a060ab02a89544fef1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5beb575f1104a060ab02a89544fef1d">&#9670;&nbsp;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03d536a13db7de62414f5279c60148aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d536a13db7de62414f5279c60148aa">&#9670;&nbsp;</a></span>atan2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::atan2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe9487e2826e1e3dda3bed0697b25a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9487e2826e1e3dda3bed0697b25a11">&#9670;&nbsp;</a></span>CalcMonomialBasisOrderUpToOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>&gt; drake::symbolic::CalcMonomialBasisOrderUpToOne </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort_monomial</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates all the monomials of <code>x</code>, such that the degree for x(i) is no larger than 1 for every x(i) in <code>x</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The variables whose monomials are generated. </td></tr>
    <tr><td class="paramname">sort_monomial</td><td>If true, the returned monomials are sorted in the graded reverse lexicographic order. For example if x = (x₀, x₁) with x₀&lt; x₁, then this function returns [x₀x₁, x₁, x₀, 1]. If sort_monomial=false, then we return the monomials in an arbitrary order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b2eee496b130c9d1acbff60e3fd3eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2eee496b130c9d1acbff60e3fd3eb1">&#9670;&nbsp;</a></span>CalcPolynomialWLowerTriangularPart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt;Derived1, <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a>&gt;::value &amp;&amp; (<a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt;Derived2, <a class="el" href="classdouble.html">double</a>&gt;::value || <a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt;Derived2, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&gt;::value || <a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt;Derived2, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt;::value), <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>&gt;::type drake::symbolic::CalcPolynomialWLowerTriangularPart </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>monomial_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>gram_lower</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the polynomial m(x)ᵀ * Q * m(x), where m(x) is the monomial basis, and Q is the Gram matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">monomial_basis</td><td>m(x) in the documentation. A vector of monomials. </td></tr>
    <tr><td class="paramname">gram_lower</td><td>The lower triangular entries in Q, stacked columnwise into a vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d4ba82d6dffb1c0c6f40a768f86eae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4ba82d6dffb1c0c6f40a768f86eae7">&#9670;&nbsp;</a></span>ceil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab16b3f1c2c4dba6f5b0f7d9a76766f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16b3f1c2c4dba6f5b0f7d9a76766f7a">&#9670;&nbsp;</a></span>CheckStructuralEquality() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt;DerivedA, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt;::value &amp;&amp; <a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt;DerivedB, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt;::value, bool&gt; drake::symbolic::CheckStructuralEquality </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if two Eigen::Matrix&lt;Variable&gt; <code>m1</code> and <code>m2</code> are structurally equal. </p>
<p>That is, it returns true if and only if <code>m1(i, j)</code> is structurally equal to <code>m2(i, j)</code> for all <code>i</code>, <code>j</code>. </p>

</div>
</div>
<a id="ac3c13478861afcc48abcec64900b0c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c13478861afcc48abcec64900b0c66">&#9670;&nbsp;</a></span>CheckStructuralEquality() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of_v&lt;Eigen::MatrixBase&lt;DerivedA&gt;, DerivedA&gt; &amp;&amp; std::is_base_of_v&lt;Eigen::MatrixBase&lt;DerivedB&gt;, DerivedB&gt; &amp;&amp; std::is_same_v&lt;typename DerivedA::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt; &amp;&amp; std::is_same_v&lt;typename DerivedB::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;, bool&gt; drake::symbolic::CheckStructuralEquality </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if two Eigen::Matrix&lt;Expression&gt; <code>m1</code> and <code>m2</code> are structurally equal. </p>
<p>That is, it returns true if and only if <code>m1(i, j)</code> is structurally equal to <code>m2(i, j)</code> for all <code>i</code>, <code>j</code>. </p>

</div>
</div>
<a id="a5470db9b5571df2d904addff09a2b98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5470db9b5571df2d904addff09a2b98e">&#9670;&nbsp;</a></span>clamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::clamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a83a29f70485ada14c4bba67192ac4efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a29f70485ada14c4bba67192ac4efc">&#9670;&nbsp;</a></span>ComputePolynomialBasisUpToDegree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;BasisElement, rows, 1&gt; drake::symbolic::ComputePolynomialBasisUpToDegree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::DegreeType&#160;</td>
          <td class="paramname"><em>degree_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all polynomial basis elements up to a given degree under the graded reverse lexicographic order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>Number of rows or Eigen::Dynamic. </td></tr>
    <tr><td class="paramname">BasisElement</td><td>A derived class of <a class="el" href="classdrake_1_1symbolic_1_1_polynomial_basis_element.html" title="Each polynomial p(x) can be written as a linear combination of its basis elements p(x) = ∑ᵢ cᵢ * ϕᵢ(x...">PolynomialBasisElement</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vars</td><td>The variables appearing in the polynomial basis. </td></tr>
    <tr><td class="paramname">degree</td><td>The highest total degree of the polynomial basis elements. </td></tr>
    <tr><td class="paramname">degree_type</td><td>If degree_type is kAny, then the polynomial basis elements' degrees are no larger than <code>degree</code>. If degree_type is kEven, then the elements' degrees are even numbers no larger than <code>degree</code>. If degree_type is kOdd, then the elements' degrees are odd numbers no larger than <code>degree</code>. TODO(hongkai.dai): this will replace ComputeMonomialBasis in <a class="el" href="monomial__util_8h.html">monomial_util.h</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b4d1b24311f37c799ef18498b95020c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4d1b24311f37c799ef18498b95020c">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79d98cdd1dd5802fe6c341ecfe9c6cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d98cdd1dd5802fe6c341ecfe9c6cce">&#9670;&nbsp;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a47d95a6b1bc2f740b30a4735cc6dcd3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d95a6b1bc2f740b30a4735cc6dcd3c">&#9670;&nbsp;</a></span>DecomposeAffineExpression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> drake::symbolic::DecomposeAffineExpression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>map_var_to_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::RowVectorXd &gt;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>constant_term</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decomposes an affine combination <code>e</code> = c0 + c1 * v1 + ... </p>
<p>cn * vn into the following: </p><pre class="fragment"> constant term      : c0
 coefficient vector : [c1, ..., cn]
 variable vector    : [v1, ..., vn]
</pre><p>Then, it extracts the coefficient and the constant term. A map from variable ID to int, <code>map_var_to_index</code>, is used to decide a variable's index in a linear combination.</p>
<dl class="section pre"><dt>Precondition</dt><dd><ol type="1">
<li><code>coeffs</code> is a row vector of double, whose length matches with the size of <code>map_var_to_index</code>.</li>
<li>e.is_polynomial() is true.</li>
<li>e is an affine expression.</li>
<li>all values in <code>map_var_to_index</code> should be in the range [0, map_var_to_index.size())</li>
</ol>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>The symbolic affine expression </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_var_to_index</td><td>A mapping from variable ID to variable index, such that map_var_to_index[vi.get_ID()] = i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coeffs</td><td>A row vector. coeffs(i) = ci. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">constant_term</td><td>c0 in the equation above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>num_variable. Number of variables in the expression. 2 * x(0) + 3 has 1 variable; 2 * x(0) + 3 * x(1) - 2 * x(0) has 1 variable, since the x(0) term cancels.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the input expression is not affine. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c152941a4e06624bac5926fac2d4e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c152941a4e06624bac5926fac2d4e32">&#9670;&nbsp;</a></span>DecomposeAffineExpressions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::symbolic::DecomposeAffineExpressions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>expressions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::MatrixXd &gt;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::VectorXd &gt;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decomposes <code>expressions</code> into <code>M</code> * <code>vars</code> + <code>v</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>expressions</code> is not affine in <code>vars</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>M.rows() == expressions.rows() &amp;&amp; M.cols() == vars.rows(). </dd>
<dd>
v.rows() == expressions.rows(). </dd></dl>

</div>
</div>
<a id="ae3c6a31812dc3e509644dbbc95c9778e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c6a31812dc3e509644dbbc95c9778e">&#9670;&nbsp;</a></span>DecomposeAffineExpressions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::symbolic::DecomposeAffineExpressions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; *&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector of affine expressions v, decompose it to \( v = A vars + b \). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>A vector of affine expressions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>The matrix containing the linear coefficients. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>The vector containing all the constant terms. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vars</td><td>All variables.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the input expressions are not affine. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20c5b25729d776ddbbcc40dd07e7f617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c5b25729d776ddbbcc40dd07e7f617">&#9670;&nbsp;</a></span>DecomposeL2NormExpression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;bool, Eigen::MatrixXd, Eigen::VectorXd, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; &gt; drake::symbolic::DecomposeL2NormExpression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>psd_tol</em> = <code>1e-8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>coefficient_tol</em> = <code>1e-8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decomposes an L2 norm <code>e</code> = |Ax+b|₂ into A, b, and the variable vector x (or returns false if the decomposition is not possible). </p>
<p>In order for the decomposition to succeed, the following conditions must be met:</p><ol type="1">
<li>e is a sqrt expression.</li>
<li><a class="el" href="namespacedrake_1_1symbolic.html#af785f16951e394debcd11a9225ef469c" title="Returns the argument in the unary expression e.">e.get_argument()</a> is a polynomial of degree 2, which can be expressed as a quadratic form (Ax+b)ᵀ(Ax+b).</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The symbolic affine expression </td></tr>
    <tr><td class="paramname">psd_tol</td><td>The tolerance for checking positive semidefiniteness. Eigenvalues less that this threshold are considered to be zero. Matrices with negative eigenvalues less than this threshold are considered to be not positive semidefinite, and will cause the decomposition to fail. </td></tr>
    <tr><td class="paramname">coefficient_tol</td><td>The absolute tolerance for checking that the coefficients of the expression inside the sqrt match the coefficients of |Ax+b|₂².</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>[is_l2norm, A, b, vars] where is_l2norm is true iff the decomposition was successful, and if is_l2norm is true then |A*vars + b|₂ = e. </dd></dl>

</div>
</div>
<a id="aa6c01361f464b3eae396f7d1a0e92c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c01361f464b3eae396f7d1a0e92c85">&#9670;&nbsp;</a></span>DecomposeLinearExpressions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::symbolic::DecomposeLinearExpressions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>expressions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::MatrixXd &gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decomposes <code>expressions</code> into <code>M</code> * <code>vars</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>expressions</code> is not linear in <code>vars</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>M.rows() == expressions.rows() &amp;&amp; M.cols() == vars.rows(). </dd></dl>

</div>
</div>
<a id="ae8c85e424b3109ed84a5bb309238bc3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c85e424b3109ed84a5bb309238bc3c">&#9670;&nbsp;</a></span>DecomposeLumpedParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt; &gt; drake::symbolic::DecomposeLumpedParameters </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector of Expressions <code>f</code> and a list of <code>parameters</code> we define all additional variables in <code>f</code> to be a vector of "non-parameter variables", n. </p>
<p>This method returns a factorization of <code>f</code> into an equivalent "data
matrix", W, which depends only on the non-parameter variables, and a "lumped
parameter vector", α, which depends only on <code>parameters:</code> f = W(n)*α(parameters) + w0(n).</p>
<dl class="section note"><dt>Note</dt><dd>The current implementation makes some simple attempts to minimize the number of lumped parameters, but more simplification could be implemented relatively easily. Optimal simplification, however, involves the complexity of comparing two arbitrary Expressions (see <a class="el" href="classdrake_1_1symbolic_1_1_expression.html#abb771e5bf5c37eb4753daf77f77adab0" title="Checks structural equality.">Expression::EqualTo</a> for more details).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>f</code> is not decomposable in this way (cells containing <code>parameters</code> may only be added or multiplied with cells containing non-parameter variables).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>W(n), α(parameters), and w0(n). </dd></dl>

</div>
</div>
<a id="a168045cc4df5fee36f317095c2a9f891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168045cc4df5fee36f317095c2a9f891">&#9670;&nbsp;</a></span>DecomposeQuadraticPolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::symbolic::DecomposeQuadraticPolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>map_var_to_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd *&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a quadratic polynomial <code>poly</code>, decomposes it into the form 0.5 * x' Q * x + b' * x + c. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poly</td><td>Quadratic polynomial to decompose. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_var_to_index</td><td>maps variables in <code>poly.GetVariables()</code> to the index in the vector <code>x</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>The Hessian of the quadratic expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The size of Q should be <code>num_variables x num_variables</code>. Q is a symmetric matrix. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>linear term of the quadratic expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The size of <code>b</code> should be <code>num_variables</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>The constant term of the quadratic expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2508a6626d1a63a77670c760e4a2241e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2508a6626d1a63a77670c760e4a2241e">&#9670;&nbsp;</a></span>Evaluate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&gt;, <a class="el" href="namespacedrake.html#aaadcdc21cc0c381e5879b1b7f023d82d">MatrixLikewise</a>&lt;<a class="el" href="classdouble.html">double</a>, Derived&gt; &gt; drake::symbolic::Evaluate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a matrix <code>m</code> of symbolic polynomials using <code>env</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>a matrix of double whose size is the size of <code>m</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if NaN is detected during evaluation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71af97c3ebea42d1b33aa8a41b975d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71af97c3ebea42d1b33aa8a41b975d0e">&#9670;&nbsp;</a></span>Evaluate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_same_v&lt;typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;, <a class="el" href="namespacedrake.html#aaadcdc21cc0c381e5879b1b7f023d82d">MatrixLikewise</a>&lt;<a class="el" href="classdouble.html">double</a>, Derived&gt; &gt; drake::symbolic::Evaluate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>env</em> = <code><a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *&#160;</td>
          <td class="paramname"><em>random_generator</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a symbolic matrix <code>m</code> using <code>env</code> and <code>random_generator</code>. </p>
<p>If there is a random variable in <code>m</code> which is unassigned in <code>env</code>, this function uses <code>random_generator</code> to sample a value and use the value to substitute all occurrences of the random variable in <code>m</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>a matrix of double whose size is the size of <code>m</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if NaN is detected during evaluation. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <code>m</code> includes unassigned random variables but <code>random_generator</code> is <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f0355c03127b4d0312e5f761a0f530a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0355c03127b4d0312e5f761a0f530a">&#9670;&nbsp;</a></span>Evaluate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::SparseMatrix&lt;<a class="el" href="classdouble.html">double</a>&gt; drake::symbolic::Evaluate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::SparseMatrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>env</em> = <code><a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates <code>m</code> using a given environment (by default, an empty environment). </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there exists a variable in <code>m</code> whose value is not provided by <code>env</code>. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if NaN is detected during evaluation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcc20898a64bbcee2ec07efd585e7c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc20898a64bbcee2ec07efd585e7c39">&#9670;&nbsp;</a></span>EvaluateChebyshevPolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> drake::symbolic::EvaluateChebyshevPolynomial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>var_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a Chebyshev polynomial at a given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var_val</td><td>The value of the variable. </td></tr>
    <tr><td class="paramname">degree</td><td>The degree of the Chebyshev polynomial. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff00cd9261b602f7ce7708286d2dae05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff00cd9261b602f7ce7708286d2dae05">&#9670;&nbsp;</a></span>EvenDegreeMonomialBasis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, Eigen::Dynamic, 1&gt; drake::symbolic::EvenDegreeMonomialBasis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all even degree monomials up to a given degree under the graded reverse lexicographic order. </p>
<p>A monomial has an even degree if its total degree is even. So xy is an even degree monomial (degree 2) while x²y is not (degree 3). Note that graded reverse lexicographic order uses the total order among <a class="el" href="classdrake_1_1symbolic_1_1_variable.html" title="Represents a symbolic variable.">Variable</a> which is based on a variable's unique ID. For example, for a given variable ordering x &gt; y &gt; z, <code>EvenDegreeMonomialBasis({x, y, z}, 2)</code> returns a column vector <code>[x², xy, y², xz, yz, z², 1]</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>vars</code> is a non-empty set. </dd>
<dd>
<code>degree</code> is a non-negative integer. </dd></dl>

</div>
</div>
<a id="a683b7c0db1ce737fc0e3af3323a4fed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683b7c0db1ce737fc0e3af3323a4fed1">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5bfdbf915c3b1d2d0d13fa2110c97066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bfdbf915c3b1d2d0d13fa2110c97066">&#9670;&nbsp;</a></span>ExtractAndAppendVariablesFromExpression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::symbolic::ExtractAndAppendVariablesFromExpression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; *&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, <a class="el" href="classint.html">int</a> &gt; *&#160;</td>
          <td class="paramname"><em>map_var_to_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an expression <code>e</code>, extracts all variables inside <code>e</code>, appends these variables to <code>vars</code> if they are not included in <code>vars</code> yet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>A symbolic expression. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vars</td><td>As an input, <code>vars</code> contain the variables before extracting expression <code>e</code>. As an output, the variables in <code>e</code> that were not included in <code>vars</code>, will be appended to the end of <code>vars</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">map_var_to_index</td><td>is of the same size as <code>vars</code>, and map_var_to_index[vars(i).get_id()] = i. This invariance holds for map_var_to_index both as the input and as the output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f9f98ac0c3db06d72227b0502cf8934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f9f98ac0c3db06d72227b0502cf8934">&#9670;&nbsp;</a></span>ExtractVariablesFromExpression() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt;, std::unordered_map&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, <a class="el" href="classint.html">int</a>&gt; &gt; drake::symbolic::ExtractVariablesFromExpression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an expression <code>e</code>, extracts all variables inside <code>e</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>A symbolic expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">pair</td><td>pair.first is the variables in <code>e</code>. pair.second is the mapping from the variable ID to the index in pair.first, such that pair.second[pair.first(i).get_id()] = i </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd9ab6787ea570003b69621c52bfa5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9ab6787ea570003b69621c52bfa5cc">&#9670;&nbsp;</a></span>ExtractVariablesFromExpression() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt;, std::unordered_map&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">Variable::Id</a>, <a class="el" href="classint.html">int</a>&gt; &gt; drake::symbolic::ExtractVariablesFromExpression </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>expressions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads ExtractVariablesFromExpression but with a vector of expressions. </p>

</div>
</div>
<a id="a56b28c66fdf5d2b582a677660936abca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b28c66fdf5d2b582a677660936abca">&#9670;&nbsp;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c6d2ea09c3aa020cf408bc9472ec9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c6d2ea09c3aa020cf408bc9472ec9eb">&#9670;&nbsp;</a></span>forall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::forall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a formula <code>f</code>, universally quantified by variables <code>vars</code>. </p>

</div>
</div>
<a id="af785f16951e394debcd11a9225ef469c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af785f16951e394debcd11a9225ef469c">&#9670;&nbsp;</a></span>get_argument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp; drake::symbolic::get_argument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the argument in the unary expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is a unary expression.} </dd></dl>

</div>
</div>
<a id="acffaee70b54f60b4d1b9f1771f78ddf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acffaee70b54f60b4d1b9f1771f78ddf7">&#9670;&nbsp;</a></span>get_base_to_exponent_map_in_multiplication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;&amp; drake::symbolic::get_base_to_exponent_map_in_multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the map from a base expression to its exponent expression in the multiplication expression <code>e</code>. </p>
<p>For instance, given 7 * x^2 * y^3 * z^x, the return value maps 'x' to 2, 'y' to 3, and 'z' to 'x'. </p><dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is a multiplication expression.} </dd></dl>

</div>
</div>
<a id="a251f0e1c8ae1894d0a09ccaeb5e79a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251f0e1c8ae1894d0a09ccaeb5e79a41">&#9670;&nbsp;</a></span>get_conditional_formula()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&amp; drake::symbolic::get_conditional_formula </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the conditional formula in the if-then-else expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>e</code> is an if-then-else expression. </dd></dl>

</div>
</div>
<a id="afe3d5ca2b76943558837ffa2a47162e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3d5ca2b76943558837ffa2a47162e1">&#9670;&nbsp;</a></span>get_constant_in_addition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> drake::symbolic::get_constant_in_addition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the constant part of the addition expression <code>e</code>. </p>
<p>For instance, given 7 + 2 * x + 3 * y, it returns 7. </p><dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is an addition expression.} </dd></dl>

</div>
</div>
<a id="af56c1d979ba67b0eceaac7f0ba54235c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af56c1d979ba67b0eceaac7f0ba54235c">&#9670;&nbsp;</a></span>get_constant_in_multiplication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> drake::symbolic::get_constant_in_multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the constant part of the multiplication expression <code>e</code>. </p>
<p>For instance, given 7 * x^2 * y^3, it returns 7. </p><dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is a multiplication expression.} </dd></dl>

</div>
</div>
<a id="a1b317498b02b74b0937f7cdb31b0ef52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b317498b02b74b0937f7cdb31b0ef52">&#9670;&nbsp;</a></span>get_constant_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> drake::symbolic::get_constant_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the constant value of the constant expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is a constant expression.} </dd></dl>

</div>
</div>
<a id="ae1a1c7093f3e8d89930f0aa748ee188c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a1c7093f3e8d89930f0aa748ee188c">&#9670;&nbsp;</a></span>get_else_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp; drake::symbolic::get_else_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 'else' expression in the if-then-else expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>e</code> is an if-then-else expression. </dd></dl>

</div>
</div>
<a id="a20be18c2d4942e2e64987a30c7e37c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20be18c2d4942e2e64987a30c7e37c1d">&#9670;&nbsp;</a></span>get_expr_to_coeff_map_in_addition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, <a class="el" href="classdouble.html">double</a>&gt;&amp; drake::symbolic::get_expr_to_coeff_map_in_addition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the map from an expression to its coefficient in the addition expression <code>e</code>. </p>
<p>For instance, given 7 + 2 * x + 3 * y, the return value maps 'x' to 2 and 'y' to 3. </p><dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is an addition expression.} </dd></dl>

</div>
</div>
<a id="a38f904009d1e4f9ad6f5ed22a4e4c41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f904009d1e4f9ad6f5ed22a4e4c41b">&#9670;&nbsp;</a></span>get_first_argument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp; drake::symbolic::get_first_argument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first argument of the binary expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is a binary expression.} </dd></dl>

</div>
</div>
<a id="afef2e4ae842f5cec22644a1627929c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef2e4ae842f5cec22644a1627929c20">&#9670;&nbsp;</a></span>get_lhs_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp; drake::symbolic::get_lhs_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the lhs-argument of a relational formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>f</code> is a relational formula.} </dd></dl>

</div>
</div>
<a id="a19aa57dcc28c59559eef51f7cbba8cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19aa57dcc28c59559eef51f7cbba8cba">&#9670;&nbsp;</a></span>get_matrix_in_positive_semidefinite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;&amp; drake::symbolic::get_matrix_in_positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the matrix in a positive-semidefinite formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>f</code> is a positive-semidefinite formula.} </dd></dl>

</div>
</div>
<a id="a2c7303caa2be22b055163dc4e7134834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7303caa2be22b055163dc4e7134834">&#9670;&nbsp;</a></span>get_operand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&amp; drake::symbolic::get_operand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the formula in a negation formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>f</code> is a negation formula.} </dd></dl>

</div>
</div>
<a id="a2362f52cf6b8c750209340520e7bc9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2362f52cf6b8c750209340520e7bc9b4">&#9670;&nbsp;</a></span>get_operands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;&amp; drake::symbolic::get_operands </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of formulas in a n-ary formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>f</code> is a n-ary formula.} </dd></dl>

</div>
</div>
<a id="acbfcc66d64e8756ae983891059050205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbfcc66d64e8756ae983891059050205">&#9670;&nbsp;</a></span>get_quantified_formula()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&amp; drake::symbolic::get_quantified_formula </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the quantified formula in a forall formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>f</code> is a forall formula.} </dd></dl>

</div>
</div>
<a id="a3f5db567077a794c0bb1653699c84a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5db567077a794c0bb1653699c84a95">&#9670;&nbsp;</a></span>get_quantified_variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&amp; drake::symbolic::get_quantified_variables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the quantified variables in a forall formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>f</code> is a forall formula.} </dd></dl>

</div>
</div>
<a id="a952d7f91d0e9e67110274daf0d17f132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952d7f91d0e9e67110274daf0d17f132">&#9670;&nbsp;</a></span>get_rhs_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp; drake::symbolic::get_rhs_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the rhs-argument of a relational formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>f</code> is a relational formula.} </dd></dl>

</div>
</div>
<a id="a8da800513f72f528dffddd89f9263b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da800513f72f528dffddd89f9263b3a">&#9670;&nbsp;</a></span>get_second_argument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp; drake::symbolic::get_second_argument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the second argument of the binary expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is a binary expression.} </dd></dl>

</div>
</div>
<a id="abd312bc518c0dd20a656021aef3e3c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd312bc518c0dd20a656021aef3e3c37">&#9670;&nbsp;</a></span>get_then_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp; drake::symbolic::get_then_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 'then' expression in the if-then-else expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>e</code> is an if-then-else expression. </dd></dl>

</div>
</div>
<a id="a71017b418d6504f2947c3a1a0e04d799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71017b418d6504f2947c3a1a0e04d799">&#9670;&nbsp;</a></span>get_unary_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp; drake::symbolic::get_unary_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the expression in a unary expression formula <code>f</code>. </p>
<p>Currently, an <a class="el" href="namespacedrake_1_1symbolic.html#ac66d112b9b6d693ee82d08c7a01f7a14" title="Returns a Formula for the predicate isnan(e) to the given expression.">isnan()</a> formula is the only kind of unary expression formula. </p><dl class="section pre"><dt>Precondition</dt><dd>{<code>f</code> is a unary expression formula.} </dd></dl>

</div>
</div>
<a id="a374ac54710c8173da5ca4b2d7eeec520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374ac54710c8173da5ca4b2d7eeec520">&#9670;&nbsp;</a></span>get_uninterpreted_function_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;&amp; drake::symbolic::get_uninterpreted_function_arguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the arguments of an uninterpreted-function expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>e</code> is an uninterpreted-function expression. </dd></dl>

</div>
</div>
<a id="a901d5aa27994e415a1eb4145968dc25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901d5aa27994e415a1eb4145968dc25c">&#9670;&nbsp;</a></span>get_uninterpreted_function_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; drake::symbolic::get_uninterpreted_function_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of an uninterpreted-function expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>e</code> is an uninterpreted-function expression. </dd></dl>

</div>
</div>
<a id="a486a9821c4235aeda4e39ff0652f72e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486a9821c4235aeda4e39ff0652f72e7">&#9670;&nbsp;</a></span>get_variable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&amp; drake::symbolic::get_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the embedded variable in the variable formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>f</code> is a variable formula. </dd></dl>

</div>
</div>
<a id="aebd6758ef1c73c0ab835a7e8c6aad187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd6758ef1c73c0ab835a7e8c6aad187">&#9670;&nbsp;</a></span>get_variable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&amp; drake::symbolic::get_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the embedded variable in the variable expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is a variable expression.} </dd></dl>

</div>
</div>
<a id="ab1ebc87f878cdb6a3f0339711d591a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ebc87f878cdb6a3f0339711d591a26">&#9670;&nbsp;</a></span>GetDistinctVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> drake::symbolic::GetDistinctVariables </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the distinct variables in the matrix of expressions. </p>

</div>
</div>
<a id="aeb9d66ba97f4b64c29eafee3b952fb9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9d66ba97f4b64c29eafee3b952fb9c">&#9670;&nbsp;</a></span>GetVariableVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; drake::symbolic::GetVariableVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>expressions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a vector of variables from the vector of variable expressions. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there is an expression in <code>vec</code> which is not a variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1dfe436e1c70779badecad19c8a039fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dfe436e1c70779badecad19c8a039fe">&#9670;&nbsp;</a></span>if_then_else()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::if_then_else </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e_then</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e_else</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">  if_then_else(cond, expr_then, expr_else)
</pre><p>The value returned by the above if-then-else expression is <code>expr_then</code> if <code>cond</code> is evaluated to true. Otherwise, it returns <code>expr_else</code>.</p>
<p>The semantics is similar to the C++'s conditional expression constructed by its ternary operator, <code></code>?:. However, there is a key difference between the C++'s conditional expression and our <code>if_then_else</code> expression in a way the arguments are evaluated during the construction.</p>
<ul>
<li>In case of the C++'s conditional expression, <code> cond ? expr_then : expr_else</code>, the then expression <code>expr_then</code> (respectively, the else expression <code>expr_else</code>) is <b>only</b> evaluated when the conditional expression <code>cond</code> is evaluated to <b>true</b> (respectively, when <code>cond</code> is evaluated to <b>false</b>).</li>
<li>In case of the symbolic expression, <code>if_then_else(cond, expr_then, expr_else)</code>, however, <b>both</b> arguments <code>expr_then</code> and <code>expr_else</code> are evaluated first and then passed to the <code>if_then_else</code> function.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function returns an <b>expression</b> and it is different from the C++'s if-then-else <b>statement</b>.</dd>
<dd>
While it is still possible to define <code> min, max, abs</code> math functions using <code>if_then_else</code> expression, it is highly <b>recommended</b> to use the provided native definitions for them because it allows solvers to detect specific math functions and to have a room for special optimizations.</dd>
<dd>
More information about the C++'s conditional expression and ternary operator is available at <a href="http://en.cppreference.com/w/cpp/language/operator_other#Conditional_operator">http://en.cppreference.com/w/cpp/language/operator_other#Conditional_operator</a>. </dd></dl>

</div>
</div>
<a id="a8dc4e8320720218ee84dc1fdc7439d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc4e8320720218ee84dc1fdc7439d17">&#9670;&nbsp;</a></span>intersect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> drake::symbolic::intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the intersection of <code>vars1</code> and <code>vars2</code>. </p>
<p>This function has a time complexity of <code>O(N₁ + N₂)</code> where <code>N₁</code> and <code>N₂</code> are the size of <code>vars1</code> and <code>vars2</code> respectively. </p>

</div>
</div>
<a id="a942b47a07cae421b3152f11536e6579c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942b47a07cae421b3152f11536e6579c">&#9670;&nbsp;</a></span>is_abs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an abs expression. </p>

</div>
</div>
<a id="a8e6c5829257cf5c28c162ffad2bd3f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6c5829257cf5c28c162ffad2bd3f58">&#9670;&nbsp;</a></span>is_abs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an absolute-value-function expression. </p>

</div>
</div>
<a id="ac2fcf1da78e47a4afb20e0a4e85ac7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fcf1da78e47a4afb20e0a4e85ac7dd">&#9670;&nbsp;</a></span>is_acos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an arccosine expression. </p>

</div>
</div>
<a id="aa70b034dae56512552b00315c20edaf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70b034dae56512552b00315c20edaf4">&#9670;&nbsp;</a></span>is_acos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an arccosine expression. </p>

</div>
</div>
<a id="acdaf0abb22b9280fc9622bd2d488a3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdaf0abb22b9280fc9622bd2d488a3e1">&#9670;&nbsp;</a></span>is_addition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_addition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an addition expression. </p>

</div>
</div>
<a id="ae9dfc929a3e771ece5e5d20312e96abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9dfc929a3e771ece5e5d20312e96abd">&#9670;&nbsp;</a></span>is_addition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_addition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an addition expression. </p>

</div>
</div>
<a id="acfa5bc007d1b065d2afc30e2f6ced7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa5bc007d1b065d2afc30e2f6ced7a9">&#9670;&nbsp;</a></span>is_asin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an arcsine expression. </p>

</div>
</div>
<a id="ab3f6cc91aa5d1f9133526887cec35cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f6cc91aa5d1f9133526887cec35cd4">&#9670;&nbsp;</a></span>is_asin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an arcsine expression. </p>

</div>
</div>
<a id="af5a94b6eea9d24d8415703bfc07a1c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a94b6eea9d24d8415703bfc07a1c05">&#9670;&nbsp;</a></span>is_atan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an arctangent expression. </p>

</div>
</div>
<a id="ae4927daffb66b9bd137c174d41d94444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4927daffb66b9bd137c174d41d94444">&#9670;&nbsp;</a></span>is_atan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an arctangent expression. </p>

</div>
</div>
<a id="a4ac54d0c8fa80bf084505f90528c9f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac54d0c8fa80bf084505f90528c9f5e">&#9670;&nbsp;</a></span>is_atan2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_atan2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an arctangent2 expression. </p>

</div>
</div>
<a id="acb998316cfc15506d72b2f2843b4fa62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb998316cfc15506d72b2f2843b4fa62">&#9670;&nbsp;</a></span>is_atan2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_atan2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a arctangent2 expression. </p>

</div>
</div>
<a id="ab82da118fd73ba6ccc41e3eb2f00125b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82da118fd73ba6ccc41e3eb2f00125b">&#9670;&nbsp;</a></span>is_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a binary expression. </p>

</div>
</div>
<a id="a1525a5e26f678130b369bc1414d9891a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1525a5e26f678130b369bc1414d9891a">&#9670;&nbsp;</a></span>is_ceil() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a ceil expression. </p>

</div>
</div>
<a id="a358f01574b969ec8e0b75498929b9d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358f01574b969ec8e0b75498929b9d95">&#9670;&nbsp;</a></span>is_ceil() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a ceil expression. </p>

</div>
</div>
<a id="a52208f3bf9cb2720f5d99223c20382f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52208f3bf9cb2720f5d99223c20382f9">&#9670;&nbsp;</a></span>is_conjunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_conjunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a conjunction (∧). </p>

</div>
</div>
<a id="ad60a650ffd29c64c25be2dc84bfefccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad60a650ffd29c64c25be2dc84bfefccc">&#9670;&nbsp;</a></span>is_conjunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_conjunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a conjunction (∧). </p>

</div>
</div>
<a id="ae0f809da2a5c679df2b90aadedde5350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f809da2a5c679df2b90aadedde5350">&#9670;&nbsp;</a></span>is_constant() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_constant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a constant expression. </p>

</div>
</div>
<a id="a993384c5125c55ca3f5a11586a9bb675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a993384c5125c55ca3f5a11586a9bb675">&#9670;&nbsp;</a></span>is_constant() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_constant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a constant expression representing <code>v</code>. </p>

</div>
</div>
<a id="a208a1c5a02e5bff9ba66d7b7db588ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208a1c5a02e5bff9ba66d7b7db588ba0">&#9670;&nbsp;</a></span>is_cos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a cosine expression. </p>

</div>
</div>
<a id="a78259c13b2add79a1ad23e2cc8f5b314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78259c13b2add79a1ad23e2cc8f5b314">&#9670;&nbsp;</a></span>is_cos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a cosine expression. </p>

</div>
</div>
<a id="a93e09e7b40ee56f60a121014f02603fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e09e7b40ee56f60a121014f02603fb">&#9670;&nbsp;</a></span>is_cosh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a hyperbolic-cosine expression. </p>

</div>
</div>
<a id="a9729350280d57ceaa1fd4c01c46ab48c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9729350280d57ceaa1fd4c01c46ab48c">&#9670;&nbsp;</a></span>is_cosh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a hyperbolic-cosine expression. </p>

</div>
</div>
<a id="a96f5414ecb9fa8f70d2303a3408aa95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f5414ecb9fa8f70d2303a3408aa95b">&#9670;&nbsp;</a></span>is_disjunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_disjunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a disjunction (∨). </p>

</div>
</div>
<a id="a9fb95d50cf0c445f6be7d3d1e5a356a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb95d50cf0c445f6be7d3d1e5a356a9">&#9670;&nbsp;</a></span>is_disjunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_disjunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a disjunction (∨). </p>

</div>
</div>
<a id="a60ddcd6effc0d16b4ab5e71008a84fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ddcd6effc0d16b4ab5e71008a84fd5">&#9670;&nbsp;</a></span>is_division() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_division </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a division expression. </p>

</div>
</div>
<a id="ac1eddc430d6a33fc13db8d53a51bdfd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1eddc430d6a33fc13db8d53a51bdfd3">&#9670;&nbsp;</a></span>is_division() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_division </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a division expression. </p>

</div>
</div>
<a id="aff01b0d18262c1673124bd659870a3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff01b0d18262c1673124bd659870a3a4">&#9670;&nbsp;</a></span>is_equal_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing equality (==). </p>

</div>
</div>
<a id="a09ce3ca5629e2672f177ff3c0cc088ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ce3ca5629e2672f177ff3c0cc088ae">&#9670;&nbsp;</a></span>is_equal_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing equality (==). </p>

</div>
</div>
<a id="aa8f471231c119fee48c6dba7a2d5ab18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f471231c119fee48c6dba7a2d5ab18">&#9670;&nbsp;</a></span>is_exp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an exp expression. </p>

</div>
</div>
<a id="a1633315c1c26cbd8411a7ea0d860a9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1633315c1c26cbd8411a7ea0d860a9c2">&#9670;&nbsp;</a></span>is_exp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an exp expression. </p>

</div>
</div>
<a id="a3821701f71cdfe8c9fbb277e017b384d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3821701f71cdfe8c9fbb277e017b384d">&#9670;&nbsp;</a></span>is_false() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_false </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is structurally equal to False formula. </p>

</div>
</div>
<a id="a9fe1f207a7dfa971bf80a1d44041368b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe1f207a7dfa971bf80a1d44041368b">&#9670;&nbsp;</a></span>is_false() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_false </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is structurally equal to False formula. </p>

</div>
</div>
<a id="abc7a6656f58842adedcc8024b14bc06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7a6656f58842adedcc8024b14bc06c">&#9670;&nbsp;</a></span>is_floor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a floor expression. </p>

</div>
</div>
<a id="a568d4712bfb6ef78d4908efce797ebd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568d4712bfb6ef78d4908efce797ebd2">&#9670;&nbsp;</a></span>is_floor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a floor expression. </p>

</div>
</div>
<a id="ae2266fd8f32067b29eed7e0345658af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2266fd8f32067b29eed7e0345658af9">&#9670;&nbsp;</a></span>is_forall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_forall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a Forall formula (∀). </p>

</div>
</div>
<a id="a1aeb30cdaf6f0d8f4d324afee241ae89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aeb30cdaf6f0d8f4d324afee241ae89">&#9670;&nbsp;</a></span>is_forall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_forall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a Forall formula (∀). </p>

</div>
</div>
<a id="af6c7242773fe5a8413bf3505e34e8477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c7242773fe5a8413bf3505e34e8477">&#9670;&nbsp;</a></span>is_greater_than() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_greater_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing greater-than (&gt;). </p>

</div>
</div>
<a id="a0aab22ba7b7baeb20a13b0aa90172fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aab22ba7b7baeb20a13b0aa90172fc1">&#9670;&nbsp;</a></span>is_greater_than() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_greater_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing greater-than (&gt;). </p>

</div>
</div>
<a id="aa71ff98005aa4a5b0d0639c055fb295f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71ff98005aa4a5b0d0639c055fb295f">&#9670;&nbsp;</a></span>is_greater_than_or_equal_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_greater_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing greater-than-or-equal-to (&gt;=). </p>

</div>
</div>
<a id="a788e2bbb344403337e7b77edf2bd92fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788e2bbb344403337e7b77edf2bd92fa">&#9670;&nbsp;</a></span>is_greater_than_or_equal_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_greater_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing greater-than-or-equal-to (&gt;=). </p>

</div>
</div>
<a id="aa12b990bcc72a788e6d8176894d0d8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12b990bcc72a788e6d8176894d0d8a2">&#9670;&nbsp;</a></span>is_if_then_else() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_if_then_else </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an if-then-else expression. </p>

</div>
</div>
<a id="af9473fec0f5aba36ac7c89281bf4d524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9473fec0f5aba36ac7c89281bf4d524">&#9670;&nbsp;</a></span>is_if_then_else() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_if_then_else </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an if-then-else expression. </p>

</div>
</div>
<a id="ad0aaf128d1ed75cbab9c4ca238e0ae6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0aaf128d1ed75cbab9c4ca238e0ae6c">&#9670;&nbsp;</a></span>is_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_integer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a819538a0900f5b91b88a5a5b25f756d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819538a0900f5b91b88a5a5b25f756d1">&#9670;&nbsp;</a></span>is_isnan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is an isnan formula. </p>

</div>
</div>
<a id="a726023da52d6033c2565368b6def1e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726023da52d6033c2565368b6def1e16">&#9670;&nbsp;</a></span>is_isnan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is an isnan formula. </p>

</div>
</div>
<a id="a50548d8092f6c0fa9796daf743a91d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50548d8092f6c0fa9796daf743a91d56">&#9670;&nbsp;</a></span>is_less_than() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_less_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing less-than (&lt;). </p>

</div>
</div>
<a id="aaed4c523512b2ee45d906c0f9d0b1d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed4c523512b2ee45d906c0f9d0b1d13">&#9670;&nbsp;</a></span>is_less_than() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_less_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing less-than (&lt;). </p>

</div>
</div>
<a id="ad4bd0f6e944bac326e6e943f26d3d043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4bd0f6e944bac326e6e943f26d3d043">&#9670;&nbsp;</a></span>is_less_than_or_equal_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_less_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing less-than-or-equal-to (&lt;=). </p>

</div>
</div>
<a id="adfca6086d970d576d51fa5364416a297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfca6086d970d576d51fa5364416a297">&#9670;&nbsp;</a></span>is_less_than_or_equal_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_less_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing less-than-or-equal-to (&lt;=). </p>

</div>
</div>
<a id="a8f5dcbc71dc0b20b3debbeafdd5f1614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5dcbc71dc0b20b3debbeafdd5f1614">&#9670;&nbsp;</a></span>is_log() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a log expression. </p>

</div>
</div>
<a id="aee17d0564b198d4c784811945707ddbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee17d0564b198d4c784811945707ddbf">&#9670;&nbsp;</a></span>is_log() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a log expression. </p>

</div>
</div>
<a id="a0a84ca31e769b94d1adcc69789826934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a84ca31e769b94d1adcc69789826934">&#9670;&nbsp;</a></span>is_max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a max expression. </p>

</div>
</div>
<a id="a409d972b3926adbbb031a5c3aef3d153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409d972b3926adbbb031a5c3aef3d153">&#9670;&nbsp;</a></span>is_max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a max expression. </p>

</div>
</div>
<a id="a911dd37b6ac155198d923500bbc97135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911dd37b6ac155198d923500bbc97135">&#9670;&nbsp;</a></span>is_min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a min expression. </p>

</div>
</div>
<a id="a429537da181b9861e8e1b51648691059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429537da181b9861e8e1b51648691059">&#9670;&nbsp;</a></span>is_min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a min expression. </p>

</div>
</div>
<a id="aee7c3de3be1c5f350b439dcdc7e8b24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7c3de3be1c5f350b439dcdc7e8b24d">&#9670;&nbsp;</a></span>is_multiplication() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a multiplication expression. </p>

</div>
</div>
<a id="a19a56ae8b296df9d9285c93e00b82dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a56ae8b296df9d9285c93e00b82dc7">&#9670;&nbsp;</a></span>is_multiplication() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an multiplication expression. </p>

</div>
</div>
<a id="a92b9f0534ca861f03dbaa96ec1712f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b9f0534ca861f03dbaa96ec1712f7f">&#9670;&nbsp;</a></span>is_nan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_nan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is NaN. </p>

</div>
</div>
<a id="abce383d57808e711c1517e9bd461cde2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce383d57808e711c1517e9bd461cde2">&#9670;&nbsp;</a></span>is_nary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_nary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a n-ary formula ({∧, ∨}). </p>

</div>
</div>
<a id="a450bcac9577de0ca8d380d2a70d5fb12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450bcac9577de0ca8d380d2a70d5fb12">&#9670;&nbsp;</a></span>is_nary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_nary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is N-ary. </p>

</div>
</div>
<a id="aef684b8834080c14e7dc13d497db9c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef684b8834080c14e7dc13d497db9c22">&#9670;&nbsp;</a></span>is_neg_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_neg_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is -1.0. </p>

</div>
</div>
<a id="abcebff63e5d9aa57da4a45df326a2acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcebff63e5d9aa57da4a45df326a2acf">&#9670;&nbsp;</a></span>is_negation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_negation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a negation (¬). </p>

</div>
</div>
<a id="a18a463fed830ca5aa9b3ff7bdef8f67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a463fed830ca5aa9b3ff7bdef8f67a">&#9670;&nbsp;</a></span>is_negation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_negation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a negation (¬). </p>

</div>
</div>
<a id="a0169dcd3572d7e3c626f154d1db8b7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0169dcd3572d7e3c626f154d1db8b7a3">&#9670;&nbsp;</a></span>is_non_negative_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_non_negative_integer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1cf5f88e2f5295758117375a30de6386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf5f88e2f5295758117375a30de6386">&#9670;&nbsp;</a></span>is_not_equal_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_not_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing disequality (!=). </p>

</div>
</div>
<a id="ac5cfac124e8ae1c7450c4e0c91c2bc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5cfac124e8ae1c7450c4e0c91c2bc07">&#9670;&nbsp;</a></span>is_not_equal_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_not_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing disequality (!=). </p>

</div>
</div>
<a id="a45f342ca12fff0fb252625b2f62afe97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f342ca12fff0fb252625b2f62afe97">&#9670;&nbsp;</a></span>is_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is 1.0. </p>

</div>
</div>
<a id="a859d0e7196b00ffd99a347ff8a7d4d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859d0e7196b00ffd99a347ff8a7d4d76">&#9670;&nbsp;</a></span>is_positive_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_positive_integer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a8a8cf51365e956ea445cf6b77d2577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8a8cf51365e956ea445cf6b77d2577">&#9670;&nbsp;</a></span>is_positive_semidefinite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a positive-semidefinite formula. </p>

</div>
</div>
<a id="a42a59dcaebd746af03b1996daf8d8901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a59dcaebd746af03b1996daf8d8901">&#9670;&nbsp;</a></span>is_positive_semidefinite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a positive semidefinite formula. </p>

</div>
</div>
<a id="aceba5fef90cbd2790037fa685e3ffdce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceba5fef90cbd2790037fa685e3ffdce">&#9670;&nbsp;</a></span>is_pow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a power-function expression. </p>

</div>
</div>
<a id="a1ae3c8118eef15cc3a9dafe14c6d48c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae3c8118eef15cc3a9dafe14c6d48c2">&#9670;&nbsp;</a></span>is_pow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a power-function expression. </p>

</div>
</div>
<a id="aac0abfc50fd5ff7cda1e5709688b4569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0abfc50fd5ff7cda1e5709688b4569">&#9670;&nbsp;</a></span>is_relational() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_relational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a relational formula ({==, !=, &gt;, &gt;=, &lt;, &lt;=}). </p>

</div>
</div>
<a id="a500b46690e6bd8926394ccf7c8482a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500b46690e6bd8926394ccf7c8482a70">&#9670;&nbsp;</a></span>is_relational() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_relational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a relational formula ({==, !=, &gt;, &gt;=, &lt;, &lt;=}). </p>

</div>
</div>
<a id="a23b9105cdfbe657bfe90eaf47d9e8f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b9105cdfbe657bfe90eaf47d9e8f11">&#9670;&nbsp;</a></span>is_sin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a sine expression. </p>

</div>
</div>
<a id="a790f1dea22ffa64d7c75849403aae060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790f1dea22ffa64d7c75849403aae060">&#9670;&nbsp;</a></span>is_sin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a sine expression. </p>

</div>
</div>
<a id="aa66cbc3a6c390d0d04bf3839e4377850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66cbc3a6c390d0d04bf3839e4377850">&#9670;&nbsp;</a></span>is_sinh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a hyperbolic-sine expression. </p>

</div>
</div>
<a id="a0373300d4207624b99351d0f7c347b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0373300d4207624b99351d0f7c347b85">&#9670;&nbsp;</a></span>is_sinh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a hyperbolic-sine expression. </p>

</div>
</div>
<a id="acfe3f1787c60c08adf6af1e1f29ff6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe3f1787c60c08adf6af1e1f29ff6cf">&#9670;&nbsp;</a></span>is_sqrt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a square-root expression. </p>

</div>
</div>
<a id="a6a645e5342fb66cd3fc7de8c38eac6b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a645e5342fb66cd3fc7de8c38eac6b4">&#9670;&nbsp;</a></span>is_sqrt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a square-root expression. </p>

</div>
</div>
<a id="a8dd352ee762ef421653cd8941fa5ce22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd352ee762ef421653cd8941fa5ce22">&#9670;&nbsp;</a></span>is_tan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a tangent expression. </p>

</div>
</div>
<a id="a7eaf3f36c1f3fdf51121f77083894794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eaf3f36c1f3fdf51121f77083894794">&#9670;&nbsp;</a></span>is_tan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a tangent expression. </p>

</div>
</div>
<a id="a9da61282d0c5ccefeaa2068d84a19273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da61282d0c5ccefeaa2068d84a19273">&#9670;&nbsp;</a></span>is_tanh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a hyperbolic-tangent expression. </p>

</div>
</div>
<a id="ac06c87629b60cbdc34b8e2a9f715cd41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac06c87629b60cbdc34b8e2a9f715cd41">&#9670;&nbsp;</a></span>is_tanh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a hyperbolic-tangent expression. </p>

</div>
</div>
<a id="a1a71b252df5a615ff80f712e2983ab53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a71b252df5a615ff80f712e2983ab53">&#9670;&nbsp;</a></span>is_true() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_true </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is structurally equal to True formula. </p>

</div>
</div>
<a id="a3654df643f4d7840fd8548eb81f4a9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3654df643f4d7840fd8548eb81f4a9ae">&#9670;&nbsp;</a></span>is_true() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_true </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is structurally equal to True formula. </p>

</div>
</div>
<a id="a71c7e1bd2b1367487d36a6cd6871af0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c7e1bd2b1367487d36a6cd6871af0c">&#9670;&nbsp;</a></span>is_two()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_two </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is 2.0. </p>

</div>
</div>
<a id="ac919050a36dacd7f943da0813c91f400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac919050a36dacd7f943da0813c91f400">&#9670;&nbsp;</a></span>is_unary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_unary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a unary expression. </p>

</div>
</div>
<a id="ab6c97ad4e8b82b5c045695eb76fc1256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c97ad4e8b82b5c045695eb76fc1256">&#9670;&nbsp;</a></span>is_uninterpreted_function() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_uninterpreted_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an uninterpreted-function expression. </p>

</div>
</div>
<a id="aa47a95b03c275d9687461839c5612472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47a95b03c275d9687461839c5612472">&#9670;&nbsp;</a></span>is_uninterpreted_function() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_uninterpreted_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an uninterpreted-function expression. </p>

</div>
</div>
<a id="a571adc7bcdc056eec761a657f9354cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571adc7bcdc056eec761a657f9354cd7">&#9670;&nbsp;</a></span>is_variable() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a variable formula. </p>

</div>
</div>
<a id="ac014e89da18637b81f9c1fbe6306e689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac014e89da18637b81f9c1fbe6306e689">&#9670;&nbsp;</a></span>is_variable() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a variable formula. </p>

</div>
</div>
<a id="a184038d04f0ab628e12fb53a6f7cb5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184038d04f0ab628e12fb53a6f7cb5d9">&#9670;&nbsp;</a></span>is_variable() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a variable expression. </p>

</div>
</div>
<a id="a2196a9e544a94c2e7c277b18c7b7716b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2196a9e544a94c2e7c277b18c7b7716b">&#9670;&nbsp;</a></span>is_variable() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a variable expression. </p>

</div>
</div>
<a id="a717f1ae4a1d038bc7870416276167f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717f1ae4a1d038bc7870416276167f19">&#9670;&nbsp;</a></span>is_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_zero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is 0.0. </p>

</div>
</div>
<a id="a13c0db41d89c9257d2fbfc4928fa5bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c0db41d89c9257d2fbfc4928fa5bd7">&#9670;&nbsp;</a></span>IsAffine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::IsAffine </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if every element in <code>m</code> is affine in <code>vars</code>. </p>
<dl class="section note"><dt>Note</dt><dd>If <code>m</code> is an empty matrix, it returns true. </dd></dl>

</div>
</div>
<a id="a9d8e94c7598bd59e6a5314ffbc3c7f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8e94c7598bd59e6a5314ffbc3c7f59">&#9670;&nbsp;</a></span>IsAffine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::IsAffine </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if every element in <code>m</code> is affine. </p>
<dl class="section note"><dt>Note</dt><dd>If <code>m</code> is an empty matrix, it returns true. </dd></dl>

</div>
</div>
<a id="aa9fbe2690e2170be14656811a9d860d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9fbe2690e2170be14656811a9d860d5">&#9670;&nbsp;</a></span>isfinite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::isfinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a> determining if the given expression <code>e</code> has a finite value. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if NaN is detected during evaluation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac460ea048a6b4cddcaf88672a6abcf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac460ea048a6b4cddcaf88672a6abcf46">&#9670;&nbsp;</a></span>isinf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::isinf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a> determining if the given expression <code>e</code> is a positive or negative infinity. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if NaN is detected during evaluation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac66d112b9b6d693ee82d08c7a01f7a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66d112b9b6d693ee82d08c7a01f7a14">&#9670;&nbsp;</a></span>isnan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a> for the predicate isnan(e) to the given expression. </p>
<p>This serves as the argument-dependent lookup related to std::isnan(double).</p>
<p>When this formula is evaluated, there are two possible outcomes:</p><ul>
<li>Returns false if the <a class="el" href="namespacedrake_1_1symbolic.html#a71af97c3ebea42d1b33aa8a41b975d0e" title="Evaluates a symbolic matrix m using env and random_generator.">e.Evaluate()</a> is not NaN.</li>
<li>Throws std::exception if NaN is detected during evaluation. Note that the evaluation of <code>isnan(e)</code> never returns true. </li>
</ul>

</div>
</div>
<a id="a5e355d7c9eb6bff11199a94c16ed5c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e355d7c9eb6bff11199a94c16ed5c8a">&#9670;&nbsp;</a></span>Jacobian() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&gt; drake::symbolic::Jacobian </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Jacobian matrix J of the vector function <code>f</code> with respect to <code>vars</code>. </p>
<p>J(i,j) contains ∂f(i)/∂vars(j). </p><dl class="section pre"><dt>Precondition</dt><dd><code>vars</code> is non-empty. </dd></dl>

</div>
</div>
<a id="ad0f56048cec3e53d98346a36df54a006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f56048cec3e53d98346a36df54a006">&#9670;&nbsp;</a></span>Jacobian() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt; drake::symbolic::Jacobian </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Jacobian matrix J of the vector function <code>f</code> with respect to <code>vars</code>. </p>
<p>J(i,j) contains ∂f(i)/∂vars(j).</p>
<p>For example, Jacobian([x * cos(y), x * sin(y), x^2], {x, y}) returns the following 3x2 matrix: </p><pre>
 = |cos(y)   -x * sin(y)|
   |sin(y)    x * cos(y)|
   | 2 * x             0|
 </pre><dl class="section pre"><dt>Precondition</dt><dd>{<code>vars</code> is non-empty}. </dd></dl>

</div>
</div>
<a id="a71a3b8e65cfeb6d57deb7fe9d70f1d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a3b8e65cfeb6d57deb7fe9d70f1d4d">&#9670;&nbsp;</a></span>Jacobian() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt; drake::symbolic::Jacobian </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Jacobian matrix J of the vector function <code>f</code> with respect to <code>vars</code>. </p>
<p>J(i,j) contains ∂f(i)/∂vars(j).</p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>vars</code> is non-empty}. </dd></dl>

</div>
</div>
<a id="ab6702577f951bca3006ab02f3313484e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6702577f951bca3006ab02f3313484e">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5aaadf953e1753ea5c2ff78a3bb030ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aaadf953e1753ea5c2ff78a3bb030ec">&#9670;&nbsp;</a></span>make_conjunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::make_conjunction </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>formulas</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a conjunction of <code>formulas</code>. </p>
<p>It performs the following simplification:</p>
<ul>
<li>make_conjunction({}) returns True.</li>
<li>make_conjunction({f₁}) returns f₁.</li>
<li>If False ∈ <code>formulas</code>, it returns False.</li>
<li>If True ∈ <code>formulas</code>, it will not appear in the return value.</li>
<li>Nested conjunctions will be flattened. For example, make_conjunction({f₁, f₂ ∧ f₃}) returns f₁ ∧ f₂ ∧ f₃. </li>
</ul>

</div>
</div>
<a id="afc6dff8519d02993c6699ddb3ebb28cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6dff8519d02993c6699ddb3ebb28cf">&#9670;&nbsp;</a></span>make_disjunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::make_disjunction </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>formulas</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a disjunction of <code>formulas</code>. </p>
<p>It performs the following simplification:</p>
<ul>
<li>make_disjunction({}) returns False.</li>
<li>make_disjunction({f₁}) returns f₁.</li>
<li>If True ∈ <code>formulas</code>, it returns True.</li>
<li>If False ∈ <code>formulas</code>, it will not appear in the return value.</li>
<li>Nested disjunctions will be flattened. For example, make_disjunction({f₁, f₂ ∨ f₃}) returns f₁ ∨ f₂ ∨ f₃. </li>
</ul>

</div>
</div>
<a id="ab61ece2fbaa79f8aad11313fa4b36150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61ece2fbaa79f8aad11313fa4b36150">&#9670;&nbsp;</a></span>MakeMatrixBinaryVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; drake::symbolic::MakeMatrixBinaryVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen matrix of symbolic binary variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a803dbab92e520549b625dde70f05fe47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803dbab92e520549b625dde70f05fe47">&#9670;&nbsp;</a></span>MakeMatrixBinaryVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols&gt; drake::symbolic::MakeMatrixBinaryVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen matrix of symbolic binary variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a8fedc6cdc53869462f7aebaafa32c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8fedc6cdc53869462f7aebaafa32c0">&#9670;&nbsp;</a></span>MakeMatrixBooleanVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; drake::symbolic::MakeMatrixBooleanVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen matrix of symbolic Boolean variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ab43ed8981b8575f24e83fdf4b26295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab43ed8981b8575f24e83fdf4b26295">&#9670;&nbsp;</a></span>MakeMatrixBooleanVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols&gt; drake::symbolic::MakeMatrixBooleanVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen matrix of symbolic Boolean variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29875ac163c78c1d1e75106b5890c949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29875ac163c78c1d1e75106b5890c949">&#9670;&nbsp;</a></span>MakeMatrixContinuousVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; drake::symbolic::MakeMatrixContinuousVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen matrix of symbolic continuous variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad93b9abfad06da819d5460018eb49b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93b9abfad06da819d5460018eb49b5c">&#9670;&nbsp;</a></span>MakeMatrixContinuousVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols&gt; drake::symbolic::MakeMatrixContinuousVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen matrix of symbolic continuous variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6779284f55bfadabde9c015ad694d093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6779284f55bfadabde9c015ad694d093">&#9670;&nbsp;</a></span>MakeMatrixIntegerVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; drake::symbolic::MakeMatrixIntegerVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen matrix of symbolic integer variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b71b38080ba3cd1d36172c4577ed445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b71b38080ba3cd1d36172c4577ed445">&#9670;&nbsp;</a></span>MakeMatrixIntegerVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols&gt; drake::symbolic::MakeMatrixIntegerVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen matrix of symbolic integer variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90b2869ab43577cdf4d1641ef1d832ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b2869ab43577cdf4d1641ef1d832ef">&#9670;&nbsp;</a></span>MakeMatrixVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; drake::symbolic::MakeMatrixVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">Variable::Type</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479ab1fa9dd3af034b3ef4291579aa673c07">Variable::Type::CONTINUOUS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen matrix of symbolic variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
    <tr><td class="paramname">type</td><td>The type of variables in the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac43a4b68b6447c593384282b8a9bc1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43a4b68b6447c593384282b8a9bc1bc">&#9670;&nbsp;</a></span>MakeMatrixVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols&gt; drake::symbolic::MakeMatrixVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">Variable::Type</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479ab1fa9dd3af034b3ef4291579aa673c07">Variable::Type::CONTINUOUS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen matrix of symbolic variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
    <tr><td class="paramname">type</td><td>The type of variables in the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a697784ea0eafd05039e3a0c97b7c1415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a697784ea0eafd05039e3a0c97b7c1415">&#9670;&nbsp;</a></span>MakeRuleRewriter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a134e54042165751a5e5369b4631c90eb">Rewriter</a> drake::symbolic::MakeRuleRewriter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html">RewritingRule</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a rewriter based on a rewriting rule <code>r</code>. </p>

</div>
</div>
<a id="a486a6cf03a93f8f8693c94e57d29e0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486a6cf03a93f8f8693c94e57d29e0ea">&#9670;&nbsp;</a></span>MakeVectorBinaryVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; drake::symbolic::MakeVectorBinaryVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen vector of symbolic binary variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a698dcb5dd4fea36841d305e89f52dd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698dcb5dd4fea36841d305e89f52dd97">&#9670;&nbsp;</a></span>MakeVectorBinaryVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1&gt; drake::symbolic::MakeVectorBinaryVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen vector of symbolic binary variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0db73b37d01f12010d12cd426f7f5054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db73b37d01f12010d12cd426f7f5054">&#9670;&nbsp;</a></span>MakeVectorBooleanVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; drake::symbolic::MakeVectorBooleanVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen vector of symbolic Boolean variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d2f37fa21183f09e3544a4c6891494b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2f37fa21183f09e3544a4c6891494b">&#9670;&nbsp;</a></span>MakeVectorBooleanVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1&gt; drake::symbolic::MakeVectorBooleanVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen vector of symbolic Boolean variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3abc75a1263e517c17a4fcb5944ba474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3abc75a1263e517c17a4fcb5944ba474">&#9670;&nbsp;</a></span>MakeVectorContinuousVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; drake::symbolic::MakeVectorContinuousVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen vector of symbolic continuous variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86a6b5840c741f1869738945cef3d8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a6b5840c741f1869738945cef3d8c5">&#9670;&nbsp;</a></span>MakeVectorContinuousVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1&gt; drake::symbolic::MakeVectorContinuousVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen vector of symbolic continuous variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7493090d0f80fbec7343113df05f6b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7493090d0f80fbec7343113df05f6b90">&#9670;&nbsp;</a></span>MakeVectorIntegerVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; drake::symbolic::MakeVectorIntegerVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen vector of symbolic integer variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a22da2ebae3f3ca478d07976adfca85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a22da2ebae3f3ca478d07976adfca85">&#9670;&nbsp;</a></span>MakeVectorIntegerVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1&gt; drake::symbolic::MakeVectorIntegerVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen vector of symbolic integer variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d8075d8a54d9c85d7b0cdcdff660ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8075d8a54d9c85d7b0cdcdff660ee1">&#9670;&nbsp;</a></span>MakeVectorVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; drake::symbolic::MakeVectorVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">Variable::Type</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479ab1fa9dd3af034b3ef4291579aa673c07">Variable::Type::CONTINUOUS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen vector of symbolic variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
    <tr><td class="paramname">type</td><td>The type of variables in the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3b123dcb60415c706814483e6b6d2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b123dcb60415c706814483e6b6d2a8">&#9670;&nbsp;</a></span>MakeVectorVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1&gt; drake::symbolic::MakeVectorVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">Variable::Type</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479ab1fa9dd3af034b3ef4291579aa673c07">Variable::Type::CONTINUOUS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen vector of symbolic variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
    <tr><td class="paramname">type</td><td>The type of variables in the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f6413d336e52ed76599cc96a8c87eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6413d336e52ed76599cc96a8c87eee">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a368c7616ccd2ce8d1587aa7343575d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368c7616ccd2ce8d1587aa7343575d52">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04c0029b04f957181b0cb2bdae701514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c0029b04f957181b0cb2bdae701514">&#9670;&nbsp;</a></span>MonomialBasis() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, Eigen::Dynamic, 1&gt; drake::symbolic::MonomialBasis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all monomials up to a given degree under the graded reverse lexicographic order. </p>
<p>Note that graded reverse lexicographic order uses the total order among <a class="el" href="classdrake_1_1symbolic_1_1_variable.html" title="Represents a symbolic variable.">Variable</a> which is based on a variable's unique ID. For example, for a given variable ordering x &gt; y &gt; z, <code>MonomialBasis({x, y, z}, 2)</code> returns a column vector <code>[x^2, xy, y^2, xz, yz, z^2, x, y, z, 1]</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>vars</code> is a non-empty set. </dd>
<dd>
<code>degree</code> is a non-negative integer. </dd></dl>

</div>
</div>
<a id="af297794f22c0458592aeea637cce060a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af297794f22c0458592aeea637cce060a">&#9670;&nbsp;</a></span>MonomialBasis() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, <a class="el" href="namespacedrake_1_1symbolic.html#aa40528027cce753aacb377913342f536">NChooseK</a>(n + degree, degree), 1&gt; drake::symbolic::MonomialBasis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all monomials up to a given degree under the graded reverse lexicographic order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">n</td><td>number of variables. </td></tr>
    <tr><td class="paramname">degree</td><td>maximum total degree of monomials to compute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>vars</code> is a non-empty set. </dd>
<dd>
vars.size() == <code>n</code>. </dd></dl>

</div>
</div>
<a id="a30a514c95fcf3b0d8ec0965e59ae9be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a514c95fcf3b0d8ec0965e59ae9be6">&#9670;&nbsp;</a></span>MonomialBasis() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>&gt; drake::symbolic::MonomialBasis </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>, <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables_degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all the monomials (in graded reverse lexicographic order) such that the total degree for each set of variables is no larger than a specific degree. </p>
<p>For example if x_set = {x₀, x₁} and y_set = {y₀, y₁}, then MonomialBasis({{x_set, 2}, {y_set, 1}}) will include all the monomials, whose total degree of x_set is no larger than 2, and the total degree of y_set is no larger than 1. Hence it can include monomials such as x₀x₁y₀, but not x₀y₀y₁ because the total degree for y_set is 2. So it would return the following set of monomials (ignoring the ordering) {x₀²y₀, x₀²y₁, x₀x₁y₀, x₀x₁y₁, x₁²y₀, x₁²y₀, x₀y₀, x₀y₁, x₁y₀, x₁y₁, x₀², x₀x₁, x₁², x₀, x₁, y₀, y₁, 1}. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables_degree</td><td><code>(vars, degree)</code> maps each set of variables <code>vars</code> to the maximal degree of these variables in the monomial. Namely the summation of the degree of each variable in <code>vars</code> is no larger than <code>degree</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The variables in <code>variables_degree</code> don't overlap. </dd>
<dd>
The degree in <code>variables_degree</code> are non-negative. </dd></dl>

</div>
</div>
<a id="aa40528027cce753aacb377913342f536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40528027cce753aacb377913342f536">&#9670;&nbsp;</a></span>NChooseK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classint.html">int</a> drake::symbolic::NChooseK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade6ac4e26dcd9023a9f8146aa75454c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6ac4e26dcd9023a9f8146aa75454c7">&#9670;&nbsp;</a></span>OddDegreeMonomialBasis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, Eigen::Dynamic, 1&gt; drake::symbolic::OddDegreeMonomialBasis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all odd degree monomials up to a given degree under the graded reverse lexicographic order. </p>
<p>A monomial has an odd degree if its total degree is odd. So x²y is an odd degree monomial (degree 3) while xy is not (degree 2). Note that graded reverse lexicographic order uses the total order among <a class="el" href="classdrake_1_1symbolic_1_1_variable.html" title="Represents a symbolic variable.">Variable</a> which is based on a variable's unique ID. For example, for a given variable ordering x &gt; y &gt; z, <code>OddDegreeMonomialBasis({x, y, z}, 3)</code> returns a column vector <code>[x³, x²y, xy², y³, x²z, xyz, y²z, xz², yz², z³, x, y, z]</code></p>
<dl class="section pre"><dt>Precondition</dt><dd><code>vars</code> is a non-empty set. </dd>
<dd>
<code>degree</code> is a non-negative integer. </dd></dl>

</div>
</div>
<a id="a71e40924c21a4f08a5cc274eaf7ddebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e40924c21a4f08a5cc274eaf7ddebd">&#9670;&nbsp;</a></span>operator &amp;&amp;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator &amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a39da4f4e5f916079f201f92852399f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39da4f4e5f916079f201f92852399f45">&#9670;&nbsp;</a></span>operator &amp;&amp;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator &amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaea3ce465525b0c357d1c5115e49a626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea3ce465525b0c357d1c5115e49a626">&#9670;&nbsp;</a></span>operator &amp;&amp;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator &amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4758fb8f36a1a85b9fa932003216fe2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4758fb8f36a1a85b9fa932003216fe2e">&#9670;&nbsp;</a></span>operator &amp;&amp;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator &amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a76deccd3cd3f64d9b875dd5116792c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76deccd3cd3f64d9b875dd5116792c07">&#9670;&nbsp;</a></span>operator *() <span class="overload">[1/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a>, <a class="el" href="classdouble.html">double</a>&gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the product of two Chebyshev basis elements. </p>
<p>Since Tₘ(x) * Tₙ(x) = 0.5 (Tₘ₊ₙ(x) + Tₘ₋ₙ(x)) if m &gt;= n, the product of Chebyshev basis elements is the weighted sum of several Chebyshev basis elements. For example T₁(x)T₂(y) * T₃(x)T₁(y) = 0.25*(T₄(x)T₃(y) + T₂(x)T₃(y)</p><ul>
<li>T₄(x)T₁(y) + T₂(x)T₁(y)) <dl class="section return"><dt>Returns</dt><dd>the result of the product, from each <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html" title="ChebyshevBasisElement represents an element of Chebyshev polynomial basis, written as the product of ...">ChebyshevBasisElement</a> to its coefficient. In the example above, it returns (T₄(x)T₃(y) -&gt; 0.25), (T₂(x)T₃(y) -&gt; 0.25), (T₄(x)T₁(y) -&gt; 0.25) and (T₂(x)T₁(y) -&gt; 0.25) </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a791475e9d37a8e5fd5f1314045428997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791475e9d37a8e5fd5f1314045428997">&#9670;&nbsp;</a></span>operator *() <span class="overload">[2/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a multiplication of two monomials, <code>m1</code> and <code>m2</code>. </p>

</div>
</div>
<a id="a97671d479c281451e703b58530b17082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97671d479c281451e703b58530b17082">&#9670;&nbsp;</a></span>operator *() <span class="overload">[3/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad71ee73fb966e97f0de864fa7cdb3692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad71ee73fb966e97f0de864fa7cdb3692">&#9670;&nbsp;</a></span>operator *() <span class="overload">[4/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c5c62b680b89f6fe992e5bc6b01e6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5c62b680b89f6fe992e5bc6b01e6c7">&#9670;&nbsp;</a></span>operator *() <span class="overload">[5/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1611c62700b00b9861c339879899a121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1611c62700b00b9861c339879899a121">&#9670;&nbsp;</a></span>operator *() <span class="overload">[6/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a347249d56768661c610bf3bafb5ff167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347249d56768661c610bf3bafb5ff167">&#9670;&nbsp;</a></span>operator *() <span class="overload">[7/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad764207511a8257dbd13ac05ee5b85e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad764207511a8257dbd13ac05ee5b85e9">&#9670;&nbsp;</a></span>operator *() <span class="overload">[8/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3c94dcccf4c09c83515332980d6a8eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c94dcccf4c09c83515332980d6a8eb">&#9670;&nbsp;</a></span>operator *() <span class="overload">[9/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5885669a7b9958dc209c13778d48e6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5885669a7b9958dc209c13778d48e6ef">&#9670;&nbsp;</a></span>operator *() <span class="overload">[10/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a>, <a class="el" href="classdouble.html">double</a>&gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a multiplication of two monomials, <code>m1</code> and <code>m2</code>. </p>
<dl class="section note"><dt>Note</dt><dd>that we return a map from the monomial product to its coefficient. This map has size 1, and the coefficient is also 1. We return a map instead of the <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html" title="MonomialBasisElement represents a monomial, a product of powers of variables with non-negative intege...">MonomialBasisElement</a> directly, because we want operator* to have the same return signature as other <a class="el" href="classdrake_1_1symbolic_1_1_polynomial_basis_element.html" title="Each polynomial p(x) can be written as a linear combination of its basis elements p(x) = ∑ᵢ cᵢ * ϕᵢ(x...">PolynomialBasisElement</a>. For example, the product between two <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html" title="ChebyshevBasisElement represents an element of Chebyshev polynomial basis, written as the product of ...">ChebyshevBasisElement</a> objects is a weighted sum of <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html" title="ChebyshevBasisElement represents an element of Chebyshev polynomial basis, written as the product of ...">ChebyshevBasisElement</a> objects. </dd>
<dd>
we do not provide operator*= function for this class, since operator*= would return <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html" title="MonomialBasisElement represents a monomial, a product of powers of variables with non-negative intege...">MonomialBasisElement</a>, which is different from operator*. </dd></dl>

</div>
</div>
<a id="a267c5d854d55ce16b1e58490ff426661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267c5d854d55ce16b1e58490ff426661">&#9670;&nbsp;</a></span>operator *() <span class="overload">[11/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime&gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following operations: </p>
<ul>
<li>Matrix&lt;RF&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;RF&gt;</li>
<li>Matrix&lt;RF&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;RF&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;RF&gt; =&gt; Matrix&lt;RF&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;RF&gt; =&gt; Matrix&lt;RF&gt;</li>
</ul>
<p>where RF is a shorthand for <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html" title="Represents symbolic rational function.">RationalFunction</a>.</p>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information</dd></dl>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information.</dd></dl>
<ul>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt; <dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="acf8ec1d6463a6936e7865e8cef04082f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8ec1d6463a6936e7865e8cef04082f">&#9670;&nbsp;</a></span>operator *() <span class="overload">[12/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a876c3318865d9ffaadd1c3f7a711fdfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a876c3318865d9ffaadd1c3f7a711fdfa">&#9670;&nbsp;</a></span>operator *() <span class="overload">[13/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisElement &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3b6eea79253234902bbcf4643e34d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b6eea79253234902bbcf4643e34d81">&#9670;&nbsp;</a></span>operator *() <span class="overload">[14/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a173be3cb77f72bb9481db5c8fd04741e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173be3cb77f72bb9481db5c8fd04741e">&#9670;&nbsp;</a></span>operator *() <span class="overload">[15/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e804fc81cb6d40414b816f559f81a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e804fc81cb6d40414b816f559f81a7d">&#9670;&nbsp;</a></span>operator *() <span class="overload">[16/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af38134e3394d8c40a7a91490154de2b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38134e3394d8c40a7a91490154de2b3">&#9670;&nbsp;</a></span>operator *() <span class="overload">[17/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab04739aabb37142340b869a126cc54a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab04739aabb37142340b869a126cc54a1">&#9670;&nbsp;</a></span>operator *() <span class="overload">[18/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a46745f049faa36c24020902f121e900c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46745f049faa36c24020902f121e900c">&#9670;&nbsp;</a></span>operator *() <span class="overload">[19/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const BasisElement &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a812892dbfc6443dc1eed055e1915f5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812892dbfc6443dc1eed055e1915f5e4">&#9670;&nbsp;</a></span>operator *() <span class="overload">[20/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a46fe276a728b54ce277fcc972fd28d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46fe276a728b54ce277fcc972fd28d78">&#9670;&nbsp;</a></span>operator *() <span class="overload">[21/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa78d0e5127e0fa0fab9f26c075c6ad9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78d0e5127e0fa0fab9f26c075c6ad9d">&#9670;&nbsp;</a></span>operator *() <span class="overload">[22/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a0eab276a88883d8e2607630cb93bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0eab276a88883d8e2607630cb93bc5">&#9670;&nbsp;</a></span>operator *() <span class="overload">[23/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab66975f1892907d118eb8cb98d6465c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66975f1892907d118eb8cb98d6465c7">&#9670;&nbsp;</a></span>operator *() <span class="overload">[24/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ed4b0b5f2e0f804d54ab68b0195ec7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed4b0b5f2e0f804d54ab68b0195ec7a">&#9670;&nbsp;</a></span>operator *() <span class="overload">[25/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca14414fd5dcd3628a3a5aff79eabebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca14414fd5dcd3628a3a5aff79eabebc">&#9670;&nbsp;</a></span>operator *() <span class="overload">[26/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const BasisElement &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7664d13fc20b1e7e30ebb16f3dfdeaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7664d13fc20b1e7e30ebb16f3dfdeaac">&#9670;&nbsp;</a></span>operator *() <span class="overload">[27/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e5300a119664e3092e90248af90a376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5300a119664e3092e90248af90a376">&#9670;&nbsp;</a></span>operator *() <span class="overload">[28/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d786db05bfa5937e62a34b9519424f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d786db05bfa5937e62a34b9519424f3">&#9670;&nbsp;</a></span>operator *() <span class="overload">[29/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisElement &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5935b2c56af883d2bacdfa61998c0d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5935b2c56af883d2bacdfa61998c0d2e">&#9670;&nbsp;</a></span>operator *() <span class="overload">[30/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e51bfc83d5ab488518b664db9e5cd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e51bfc83d5ab488518b664db9e5cd34">&#9670;&nbsp;</a></span>operator *() <span class="overload">[31/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9527491f78970e42f830e74808a0048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9527491f78970e42f830e74808a0048">&#9670;&nbsp;</a></span>operator *() <span class="overload">[32/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime &gt; operator * </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following matrix operations: </p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information.</dd></dl>
<ul>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt; <dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a1dbec6a09664cb563d86071a7be38913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbec6a09664cb563d86071a7be38913">&#9670;&nbsp;</a></span>operator *() <span class="overload">[33/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c7acc3dc6f322c6b123be2165123b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7acc3dc6f322c6b123be2165123b25">&#9670;&nbsp;</a></span>operator *() <span class="overload">[34/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of_v&lt;Eigen::MatrixBase&lt;MatrixL&gt;, MatrixL&gt; &amp;&amp; std::is_base_of_v&lt;Eigen::MatrixBase&lt;MatrixR&gt;, MatrixR&gt; &amp;&amp; std::is_same_v&lt;typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt; &amp;&amp; std::is_same_v&lt;typename MatrixR::Scalar, <a class="el" href="classdouble.html">double</a>&gt;, internal::ExpressionMatMulResult&lt;MatrixL, MatrixR&gt; &gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following matrix operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information.</dd></dl>
<ul>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt; <dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a1e74ffdcbc8c474503d2a3249df15b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e74ffdcbc8c474503d2a3249df15b54">&#9670;&nbsp;</a></span>operator *() <span class="overload">[35/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of_v&lt;Eigen::MatrixBase&lt;MatrixL&gt;, MatrixL&gt; &amp;&amp; std::is_base_of_v&lt;Eigen::MatrixBase&lt;MatrixR&gt;, MatrixR&gt; &amp;&amp; std::is_same_v&lt;typename MatrixL::Scalar, <a class="el" href="classdouble.html">double</a>&gt; &amp;&amp; std::is_same_v&lt;typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;, internal::ExpressionMatMulResult&lt;MatrixL, MatrixR&gt; &gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following matrix operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information.</dd></dl>
<ul>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt; <dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="aaeec5ad743203c7161bd07bbb00dd96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeec5ad743203c7161bd07bbb00dd96b">&#9670;&nbsp;</a></span>operator *() <span class="overload">[36/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of_v&lt;Eigen::MatrixBase&lt;MatrixL&gt;, MatrixL&gt; &amp;&amp; std::is_base_of_v&lt;Eigen::MatrixBase&lt;MatrixR&gt;, MatrixR&gt; &amp;&amp; std::is_same_v&lt;typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt; &amp;&amp; std::is_same_v&lt;typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt;, internal::ExpressionMatMulResult&lt;MatrixL, MatrixR&gt; &gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following matrix operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information.</dd></dl>
<ul>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt; <dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a36042c0cb53373d2a578f0734b1acd47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36042c0cb53373d2a578f0734b1acd47">&#9670;&nbsp;</a></span>operator *() <span class="overload">[37/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of_v&lt;Eigen::MatrixBase&lt;MatrixL&gt;, MatrixL&gt; &amp;&amp; std::is_base_of_v&lt;Eigen::MatrixBase&lt;MatrixR&gt;, MatrixR&gt; &amp;&amp; std::is_same_v&lt;typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; &amp;&amp; std::is_same_v&lt;typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;, internal::ExpressionMatMulResult&lt;MatrixL, MatrixR&gt; &gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following matrix operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information.</dd></dl>
<ul>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt; <dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="af0d832cf6612451c3eaa079df9ef8ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d832cf6612451c3eaa079df9ef8ec9">&#9670;&nbsp;</a></span>operator *() <span class="overload">[38/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of_v&lt;Eigen::MatrixBase&lt;MatrixL&gt;, MatrixL&gt; &amp;&amp; std::is_base_of_v&lt;Eigen::MatrixBase&lt;MatrixR&gt;, MatrixR&gt; &amp;&amp; std::is_same_v&lt;typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; &amp;&amp; std::is_same_v&lt;typename MatrixR::Scalar, <a class="el" href="classdouble.html">double</a>&gt;, internal::ExpressionMatMulResult&lt;MatrixL, MatrixR&gt; &gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following matrix operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information.</dd></dl>
<ul>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt; <dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ae6895bc9ae9e9e84f8f6a9bbc434b4e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6895bc9ae9e9e84f8f6a9bbc434b4e9">&#9670;&nbsp;</a></span>operator *() <span class="overload">[39/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of_v&lt;Eigen::MatrixBase&lt;MatrixL&gt;, MatrixL&gt; &amp;&amp; std::is_base_of_v&lt;Eigen::MatrixBase&lt;MatrixR&gt;, MatrixR&gt; &amp;&amp; std::is_same_v&lt;typename MatrixL::Scalar, <a class="el" href="classdouble.html">double</a>&gt; &amp;&amp; std::is_same_v&lt;typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt;, internal::ExpressionMatMulResult&lt;MatrixL, MatrixR&gt; &gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following matrix operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information.</dd></dl>
<ul>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt; <dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a99b295edb3a60b6a961bbc6f42e24547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b295edb3a60b6a961bbc6f42e24547">&#9670;&nbsp;</a></span>operator *() <span class="overload">[40/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of_v&lt;Eigen::MatrixBase&lt;MatrixL&gt;, MatrixL&gt; &amp;&amp; std::is_base_of_v&lt;Eigen::MatrixBase&lt;MatrixR&gt;, MatrixR&gt; &amp;&amp; std::is_same_v&lt;typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; &amp;&amp; std::is_same_v&lt;typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt;, internal::ExpressionMatMulResult&lt;MatrixL, MatrixR&gt; &gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following matrix operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information.</dd></dl>
<ul>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt; <dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="aee491180204fc8aa2b1c73da8ca18b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee491180204fc8aa2b1c73da8ca18b85">&#9670;&nbsp;</a></span>operator *() <span class="overload">[41/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_base_of_v&lt;Eigen::MatrixBase&lt;MatrixL&gt;, MatrixL&gt; &amp;&amp; std::is_base_of_v&lt;Eigen::MatrixBase&lt;MatrixR&gt;, MatrixR&gt; &amp;&amp; std::is_same_v&lt;typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt; &amp;&amp; std::is_same_v&lt;typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;, internal::ExpressionMatMulResult&lt;MatrixL, MatrixR&gt; &gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following matrix operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Variable&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Variable&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information.</dd></dl>
<ul>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Expression&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Expression&gt; =&gt; Matrix&lt;Expression&gt; <dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="adac78e96efaa07849f158591192b2dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac78e96efaa07849f158591192b2dca">&#9670;&nbsp;</a></span>operator *() <span class="overload">[42/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Transform&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Dim, LhsMode, LhsOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; <a class="el" href="classdouble.html">double</a>, Dim, RhsMode, RhsOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform&lt;double&gt; * Transform&lt;Expression&gt; =&gt; Transform&lt;Expression&gt; </p>

</div>
</div>
<a id="aac410f7e82c9d06e796d7fcb4508f5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac410f7e82c9d06e796d7fcb4508f5e4">&#9670;&nbsp;</a></span>operator *() <span class="overload">[43/43]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Transform&lt; <a class="el" href="classdouble.html">double</a>, Dim, LhsMode, LhsOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Dim, RhsMode, RhsOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform&lt;Expression&gt; * Transform&lt;double&gt; =&gt; Transform&lt;Expression&gt; </p>

</div>
</div>
<a id="a6ee2268a69d74bce563c043848528741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee2268a69d74bce563c043848528741">&#9670;&nbsp;</a></span>operator *=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp; drake::symbolic::operator *= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a489c472556030b17c10028a04ba70aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489c472556030b17c10028a04ba70aad">&#9670;&nbsp;</a></span>operator!() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator! </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9f34a1136227779b18433cd0a2f4dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f34a1136227779b18433cd0a2f4dde">&#9670;&nbsp;</a></span>operator!() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator! </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5c1c4bfd4434de52e240126b78853c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c1c4bfd4434de52e240126b78853c0">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> <a class="el" href="namespacedrake_1_1symbolic.html#a489c472556030b17c10028a04ba70aad">drake::symbolic::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9516e5b0429edb615ec0b2cc0cb7fae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9516e5b0429edb615ec0b2cc0cb7fae9">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(typename DerivedA::Scalar() != typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, typename internal::RelationalOpTraits&lt;DerivedA, DerivedB&gt;::ReturnType&gt; <a class="el" href="namespacedrake_1_1symbolic.html#a489c472556030b17c10028a04ba70aad">drake::symbolic::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using not-equal operator (!=). </p>

</div>
</div>
<a id="a2adc95d21c8bb34168d15514bf00a3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2adc95d21c8bb34168d15514bf00a3d6">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(typename Derived::Scalar() != ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt; <a class="el" href="namespacedrake_1_1symbolic.html#a489c472556030b17c10028a04ba70aad">drake::symbolic::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using not-equal operator (!=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(a != v)</code> has a symbolic formula <code>a(i, j) != v</code>. </p>

</div>
</div>
<a id="a912368173773912a9b75abfaf208e1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912368173773912a9b75abfaf208e1e1">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(ScalarType() != typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt; <a class="el" href="namespacedrake_1_1symbolic.html#a489c472556030b17c10028a04ba70aad">drake::symbolic::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> not-equal operator (!=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(v != a)</code> has a symbolic formula <code>v != a(i, j)</code>. </p>

</div>
</div>
<a id="a665bbf538eb986af44631f116c34a83d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665bbf538eb986af44631f116c34a83d">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::MatrixXpr&gt; &amp;&amp; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::MatrixXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(typename DerivedA::Scalar() != typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt; <a class="el" href="namespacedrake_1_1symbolic.html#a489c472556030b17c10028a04ba70aad">drake::symbolic::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula representing the condition whether <code>m1</code> and <code>m2</code> are not the same. </p>
<p>The following table describes the return type of <code>m1</code> != <code>m2</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LHS \ RHS  </th><th class="markdownTableHeadNone">EM&lt;Expression&gt;  </th><th class="markdownTableHeadNone">EM&lt;Variable&gt;  </th><th class="markdownTableHeadNone">EM&lt;double&gt;   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;Expression&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EM&lt;Variable&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;double&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone">bool   </td></tr>
</table>
<p>In the table, <code>EM</code> is a short-hand of <code>Eigen::Matrix</code>.</p>
<p>Note that this function does <em>not</em> provide operator overloading for the following case. It returns <code>bool</code> and is provided by Eigen.</p>
<ul>
<li>Eigen::Matrix&lt;double&gt; != Eigen::Matrix&lt;double&gt; </li>
</ul>

</div>
</div>
<a id="a8327415ae13cae1b0d450c384079a49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8327415ae13cae1b0d450c384079a49e">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6364a2e4727b0af4071b15da0cad509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6364a2e4727b0af4071b15da0cad509">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a185c9ab6bca14a042a837aadf2064546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185c9ab6bca14a042a837aadf2064546">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a181410366c9b16014e81127717a13314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181410366c9b16014e81127717a13314">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba2399f6ee5b4c18bc26dc3fd5b6c07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2399f6ee5b4c18bc26dc3fd5b6c07a">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td>
          <td class="paramname"><em>vars1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns set-union of <code>var1</code> and <code>var2</code>. </p>

</div>
</div>
<a id="a6d99af1951c74ac5377ce5e7ec953eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d99af1951c74ac5377ce5e7ec953eb6">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a167d0d14d66effceeb5834371626452b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167d0d14d66effceeb5834371626452b">&#9670;&nbsp;</a></span>operator+() <span class="overload">[7/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a497331a32f5911a18cef34b07df6c04a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497331a32f5911a18cef34b07df6c04a">&#9670;&nbsp;</a></span>operator+() <span class="overload">[8/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns set-union of <code>vars</code> and {<code>var}</code>. </p>

</div>
</div>
<a id="a0dc08ea95543252bcf2b31fdfe723d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc08ea95543252bcf2b31fdfe723d26">&#9670;&nbsp;</a></span>operator+() <span class="overload">[9/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aae117a884f72a1a73cc2863ec026c011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae117a884f72a1a73cc2863ec026c011">&#9670;&nbsp;</a></span>operator+() <span class="overload">[10/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns set-union of {<code>var}</code> and <code>vars</code>. </p>

</div>
</div>
<a id="a687f88372c74f4500af3df50cb687b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687f88372c74f4500af3df50cb687b88">&#9670;&nbsp;</a></span>operator+() <span class="overload">[11/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4af9f402cc780cda79d4f27807f75d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af9f402cc780cda79d4f27807f75d39">&#9670;&nbsp;</a></span>operator+() <span class="overload">[12/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisElement &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2296b14ee573d8deafe90b3615281e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2296b14ee573d8deafe90b3615281e68">&#9670;&nbsp;</a></span>operator+() <span class="overload">[13/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2176f7eb786ddec5cd9ea0683a019482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2176f7eb786ddec5cd9ea0683a019482">&#9670;&nbsp;</a></span>operator+() <span class="overload">[14/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const BasisElement &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a635f8429c26e19e7582b7753751636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a635f8429c26e19e7582b7753751636">&#9670;&nbsp;</a></span>operator+() <span class="overload">[15/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const BasisElement &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisElement &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a94b919a53ae2bebde988b237088cb822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b919a53ae2bebde988b237088cb822">&#9670;&nbsp;</a></span>operator+() <span class="overload">[16/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const BasisElement &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a434f1953d9800d1c40dc223609904ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434f1953d9800d1c40dc223609904ecf">&#9670;&nbsp;</a></span>operator+() <span class="overload">[17/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34397d7d032b5c4214a92123e3c6752d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34397d7d032b5c4214a92123e3c6752d">&#9670;&nbsp;</a></span>operator+() <span class="overload">[18/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisElement &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a580ca04916246340e08ec69b45276827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580ca04916246340e08ec69b45276827">&#9670;&nbsp;</a></span>operator+() <span class="overload">[19/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21d8313aa6cdb78da3f2cd6d84b92e39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d8313aa6cdb78da3f2cd6d84b92e39">&#9670;&nbsp;</a></span>operator+() <span class="overload">[20/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="affb3773f2d585ffce0253cb15c8c00a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb3773f2d585ffce0253cb15c8c00a0">&#9670;&nbsp;</a></span>operator+() <span class="overload">[21/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52a4be02d87d5a6d31efbbcb5d3ba934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a4be02d87d5a6d31efbbcb5d3ba934">&#9670;&nbsp;</a></span>operator+() <span class="overload">[22/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96b091bab8bb06edd276c6b4a420903c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b091bab8bb06edd276c6b4a420903c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[23/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af04dff9a90e39ac9985d520d3e66f5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04dff9a90e39ac9985d520d3e66f5c3">&#9670;&nbsp;</a></span>operator+() <span class="overload">[24/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e02326d779ba8c55ad9d9f6eb54f3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e02326d779ba8c55ad9d9f6eb54f3d8">&#9670;&nbsp;</a></span>operator+() <span class="overload">[25/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8dd958cf7990638bdd2576c2ab62ad43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd958cf7990638bdd2576c2ab62ad43">&#9670;&nbsp;</a></span>operator+() <span class="overload">[26/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a289b47480364e01b67e3c86aa33a0fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289b47480364e01b67e3c86aa33a0fe4">&#9670;&nbsp;</a></span>operator+() <span class="overload">[27/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ee4b0876c4a92c7bd3030b193ce0dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee4b0876c4a92c7bd3030b193ce0dbd">&#9670;&nbsp;</a></span>operator+() <span class="overload">[28/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42522d07a4a9c32a89e8b4eea9a00a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42522d07a4a9c32a89e8b4eea9a00a60">&#9670;&nbsp;</a></span>operator+() <span class="overload">[29/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab876f48eb96e82b718df0050b9d57d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab876f48eb96e82b718df0050b9d57d8b">&#9670;&nbsp;</a></span>operator+() <span class="overload">[30/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8bfdaed2217f9183cde2f08246cece4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8bfdaed2217f9183cde2f08246cece4">&#9670;&nbsp;</a></span>operator+() <span class="overload">[31/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f5e34034488d988d8349100bbdc359c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f5e34034488d988d8349100bbdc359c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[32/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3293ffe3812fbfa2dbd63263fcf6c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3293ffe3812fbfa2dbd63263fcf6c4c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[33/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a105ae15b8e85984cf3ae81a7b67de38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105ae15b8e85984cf3ae81a7b67de38c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[34/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9084a43cdfa02b10cb216c7bfff0dcb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9084a43cdfa02b10cb216c7bfff0dcb3">&#9670;&nbsp;</a></span>operator+() <span class="overload">[35/35]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac861cf2992e3fa03746df6ca291c5020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac861cf2992e3fa03746df6ca291c5020">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&amp; drake::symbolic::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates <code>var1</code> with the result of set-union(<code>var1</code>, <code>var2</code>). </p>

</div>
</div>
<a id="a3ee8a097ba9d2c5d5ee4643471c945ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee8a097ba9d2c5d5ee4643471c945ce">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&amp; drake::symbolic::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates <code>vars</code> with the result of set-union(<code>vars</code>, { <code>var</code> }). </p>

</div>
</div>
<a id="a1519bc7275ec68c904b395067f8ff775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1519bc7275ec68c904b395067f8ff775">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp; drake::symbolic::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af9ea1fd857bdf8fa5c18f570118640ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ea1fd857bdf8fa5c18f570118640ff">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ec6e83953a4663403fcb08592e16b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec6e83953a4663403fcb08592e16b01">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9120c262586410f015a00fcdd6fed2a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9120c262586410f015a00fcdd6fed2a7">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad564d8bc7c97743e2ca0654c2c417c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad564d8bc7c97743e2ca0654c2c417c8d">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a22f74050260696325581c3087d07fab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f74050260696325581c3087d07fab7">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a44a9560b5bbc179968621e3df178742c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44a9560b5bbc179968621e3df178742c">&#9670;&nbsp;</a></span>operator-() <span class="overload">[6/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a579d06e36f094bf2eebf127dcbb46a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579d06e36f094bf2eebf127dcbb46a1c">&#9670;&nbsp;</a></span>operator-() <span class="overload">[7/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d93012a42e93f92eb3b7fab8bd60733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d93012a42e93f92eb3b7fab8bd60733">&#9670;&nbsp;</a></span>operator-() <span class="overload">[8/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td>
          <td class="paramname"><em>vars1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns set-minus(<code>var1</code>, <code>vars2</code>). </p>

</div>
</div>
<a id="a062f8182804bd14f76a6f2ac17718a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062f8182804bd14f76a6f2ac17718a80">&#9670;&nbsp;</a></span>operator-() <span class="overload">[9/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns set-minus(<code>vars</code>, { <code>var</code> }). </p>

</div>
</div>
<a id="a5e9f5fa3d4c2770a38947956973fe27e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9f5fa3d4c2770a38947956973fe27e">&#9670;&nbsp;</a></span>operator-() <span class="overload">[10/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed13274bad687cfe8b3a1effa40d3117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed13274bad687cfe8b3a1effa40d3117">&#9670;&nbsp;</a></span>operator-() <span class="overload">[11/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac0c3464fe7d151d7846e659e8e1d281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0c3464fe7d151d7846e659e8e1d281">&#9670;&nbsp;</a></span>operator-() <span class="overload">[12/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisElement &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7632adf109d2b13d0a4fb81e7cb81f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7632adf109d2b13d0a4fb81e7cb81f96">&#9670;&nbsp;</a></span>operator-() <span class="overload">[13/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb122f4c4c5c71d0734c3b517a146df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb122f4c4c5c71d0734c3b517a146df9">&#9670;&nbsp;</a></span>operator-() <span class="overload">[14/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const BasisElement &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abaab72f1cd4050603b25467fa909ec24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaab72f1cd4050603b25467fa909ec24">&#9670;&nbsp;</a></span>operator-() <span class="overload">[15/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const BasisElement &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisElement &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6ff0b6772551662f2b02b77b5889504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ff0b6772551662f2b02b77b5889504">&#9670;&nbsp;</a></span>operator-() <span class="overload">[16/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const BasisElement &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a51133160077bdcba90013d1f21b88410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51133160077bdcba90013d1f21b88410">&#9670;&nbsp;</a></span>operator-() <span class="overload">[17/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc778273d730c518678796b632e4de8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc778273d730c518678796b632e4de8f">&#9670;&nbsp;</a></span>operator-() <span class="overload">[18/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisElement &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade37df718218bcbdbc1edd9a0b6a596a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade37df718218bcbdbc1edd9a0b6a596a">&#9670;&nbsp;</a></span>operator-() <span class="overload">[19/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unary minus operation for polynomial. </p>

</div>
</div>
<a id="a120ae90dfc24dd3f7b4f42aededbabfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120ae90dfc24dd3f7b4f42aededbabfd">&#9670;&nbsp;</a></span>operator-() <span class="overload">[20/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfcadf9b33656022c0c071a8af3fd85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfcadf9b33656022c0c071a8af3fd85e">&#9670;&nbsp;</a></span>operator-() <span class="overload">[21/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1aa3f21ab39b7fb01be90ed9255df5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa3f21ab39b7fb01be90ed9255df5f9">&#9670;&nbsp;</a></span>operator-() <span class="overload">[22/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aacc89061cd63bf0e4d0d79c57d3b72e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc89061cd63bf0e4d0d79c57d3b72e4">&#9670;&nbsp;</a></span>operator-() <span class="overload">[23/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48f8b6bfe08648f4a0dac518e1abb0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f8b6bfe08648f4a0dac518e1abb0bd">&#9670;&nbsp;</a></span>operator-() <span class="overload">[24/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada023ba3d82bbf8137d74409bf596457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada023ba3d82bbf8137d74409bf596457">&#9670;&nbsp;</a></span>operator-() <span class="overload">[25/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e4fa4bbef7ce58efc247dd1717a2ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4fa4bbef7ce58efc247dd1717a2ded">&#9670;&nbsp;</a></span>operator-() <span class="overload">[26/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a369ea32ea396cc86951892020d5c4a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369ea32ea396cc86951892020d5c4a4b">&#9670;&nbsp;</a></span>operator-() <span class="overload">[27/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe6ad1d11dea0eafbfed0db238957d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6ad1d11dea0eafbfed0db238957d64">&#9670;&nbsp;</a></span>operator-() <span class="overload">[28/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a448e985024e32143f3ca12d8596211d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448e985024e32143f3ca12d8596211d4">&#9670;&nbsp;</a></span>operator-() <span class="overload">[29/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03731fe9a001a20e071a7a9e106061bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03731fe9a001a20e071a7a9e106061bd">&#9670;&nbsp;</a></span>operator-() <span class="overload">[30/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30f8eee8c5c646b5f3fc43baf3ce5854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f8eee8c5c646b5f3fc43baf3ce5854">&#9670;&nbsp;</a></span>operator-() <span class="overload">[31/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a975e86e30c5c98ede0b2a1f49d1d8c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975e86e30c5c98ede0b2a1f49d1d8c7d">&#9670;&nbsp;</a></span>operator-() <span class="overload">[32/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac596e9b191c4eaa992bcb9d7718e9554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac596e9b191c4eaa992bcb9d7718e9554">&#9670;&nbsp;</a></span>operator-() <span class="overload">[33/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8d3a7da7b3275333a0f2d67d649ead8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d3a7da7b3275333a0f2d67d649ead8">&#9670;&nbsp;</a></span>operator-() <span class="overload">[34/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a554e434566b78163855f96829c244e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a554e434566b78163855f96829c244e37">&#9670;&nbsp;</a></span>operator-() <span class="overload">[35/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac306b9a9b7ace256330ae3ab8deaafef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac306b9a9b7ace256330ae3ab8deaafef">&#9670;&nbsp;</a></span>operator-() <span class="overload">[36/36]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a668d0a0cca975453784c6cd77d638c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668d0a0cca975453784c6cd77d638c56">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&amp; drake::symbolic::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates <code>var1</code> with the result of set-minus(<code>var1</code>, <code>var2</code>). </p>

</div>
</div>
<a id="a50ee50ee4e70ef4393128598d143a2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ee50ee4e70ef4393128598d143a2a6">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&amp; drake::symbolic::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates <code>vars</code> with the result of set-minus(<code>vars</code>, {<code>var}</code>). </p>

</div>
</div>
<a id="a380b68d6baf2cb5ab4212e435d1104ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380b68d6baf2cb5ab4212e435d1104ee">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp; drake::symbolic::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c8b6db1763f8f7a5d98de636b9cd7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8b6db1763f8f7a5d98de636b9cd7c9">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the numerator of the divisor is structurally equal to zero. Note that this does not guarantee that the denominator of the result is not zero after expansion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a8d6fb5671a17bf0c89c1c5aef9efaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8d6fb5671a17bf0c89c1c5aef9efaf">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the divisor is structurally equal to zero. Note that this does not guarantee that the denominator of the result is not zero after expansion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27ad135e8775cf9d721b1223218fff2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ad135e8775cf9d721b1223218fff2d">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the numerator of the divisor is structurally equal to zero. Note that this does not guarantee that the denominator of the result is not zero after expansion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a687c99f46e854d9237083b2f34e6665c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687c99f46e854d9237083b2f34e6665c">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if c is 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb47877c3cad48fe6a8e25edb0620495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb47877c3cad48fe6a8e25edb0620495">&#9670;&nbsp;</a></span>operator/() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the numerator of the divisor is structurally equal to zero. Note that this does not guarantee that the denominator of the result is not zero after expansion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17039bebdf3cf731833b0ea132b431f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17039bebdf3cf731833b0ea132b431f9">&#9670;&nbsp;</a></span>operator/() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff3765260423d079969572ed50b80934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3765260423d079969572ed50b80934">&#9670;&nbsp;</a></span>operator/() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9423440606bd13d4767c72dd97ec6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9423440606bd13d4767c72dd97ec6a2">&#9670;&nbsp;</a></span>operator/() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>p / v</code>. </p>

</div>
</div>
<a id="a84d4982fe5eb3fd118c9a1cfed0f8efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d4982fe5eb3fd118c9a1cfed0f8efa">&#9670;&nbsp;</a></span>operator/() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98465062118b5f7461c5fc510842de10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98465062118b5f7461c5fc510842de10">&#9670;&nbsp;</a></span>operator/() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4709897ce3846a69f2882e2bdfbd5dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4709897ce3846a69f2882e2bdfbd5dff">&#9670;&nbsp;</a></span>operator/() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1504176a6220b744ee8b07a0ed920f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1504176a6220b744ee8b07a0ed920f15">&#9670;&nbsp;</a></span>operator/() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>p / v</code>. </p>

</div>
</div>
<a id="a43e7c74e8b9ea1c9c5843c590e388009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e7c74e8b9ea1c9c5843c590e388009">&#9670;&nbsp;</a></span>operator/() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c5d6073354479ca8e507536cd36f844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5d6073354479ca8e507536cd36f844">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp; drake::symbolic::operator/= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1245bbf1795b4f97ec4c04cd79dcde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1245bbf1795b4f97ec4c04cd79dcde3">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a>&#160;</td>
          <td class="paramname"><em>k1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a>&#160;</td>
          <td class="paramname"><em>k2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70b5e99a86a85837124c6a006f7ec60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b5e99a86a85837124c6a006f7ec60a">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91">ExpressionKind</a>&#160;</td>
          <td class="paramname"><em>k1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1symbolic.html#a245f75ee96839b12e22fea09c6f3ec91">ExpressionKind</a>&#160;</td>
          <td class="paramname"><em>k2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total ordering between ExpressionKinds. </p>

</div>
</div>
<a id="a0ad84d6691fb2bf9627d894d56b8ef6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad84d6691fb2bf9627d894d56b8ef6f">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4f5aab12f951d127ecfaf06b4f175c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f5aab12f951d127ecfaf06b4f175c5">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(ScalarType() &lt; typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt; drake::symbolic::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than operator (&lt;). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(v &lt; a)</code> has a symbolic formula <code>v &lt; a(i, j)</code>. </p>

</div>
</div>
<a id="a528367e2321df46235c2fed21eb0d433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528367e2321df46235c2fed21eb0d433">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(typename Derived::Scalar() &lt; ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt; drake::symbolic::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using less-than operator (&lt;). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(a &lt; v)</code> has a symbolic formula <code>a(i, j) &lt; v</code>. </p>

</div>
</div>
<a id="a40dd892a8b6492f65a8995abc666b3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40dd892a8b6492f65a8995abc666b3f3">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(typename DerivedA::Scalar() &lt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, typename internal::RelationalOpTraits&lt;DerivedA, DerivedB&gt;::ReturnType&gt; drake::symbolic::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using less-than operator (&lt;). </p>

</div>
</div>
<a id="a3e3e369561e0984adadbfddf3acb84f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3e369561e0984adadbfddf3acb84f3">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::MatrixXpr&gt; &amp;&amp; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::MatrixXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(typename DerivedA::Scalar() &lt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt; drake::symbolic::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using less-than (&lt;) operator. </p>
<p>The following table describes the return type of <code>m1</code> &lt; <code>m2</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LHS \ RHS  </th><th class="markdownTableHeadNone">EM&lt;Expression&gt;  </th><th class="markdownTableHeadNone">EM&lt;Variable&gt;  </th><th class="markdownTableHeadNone">EM&lt;double&gt;   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;Expression&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EM&lt;Variable&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;double&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone">N/A   </td></tr>
</table>
<p>In the table, <code>EM</code> is a short-hand of <code>Eigen::Matrix</code>. </p>

</div>
</div>
<a id="a31d454a069abf89b2a0b6c71222ec221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d454a069abf89b2a0b6c71222ec221">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::symbolic::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_polynomial.html">ChebyshevPolynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6e0055c99275292d22eb59c103fb0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e0055c99275292d22eb59c103fb0ae">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::symbolic::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479">Variable::Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af975c2571c59b1d8b03b213a15096336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af975c2571c59b1d8b03b213a15096336">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::symbolic::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8505db5f6e70df16a3cecda394bdcb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8505db5f6e70df16a3cecda394bdcb24">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::symbolic::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af71ffcec2b8e06d52b7c6e8f53106160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71ffcec2b8e06d52b7c6e8f53106160">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::symbolic::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c794bfc916c077b16d9c7d47031f68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c794bfc916c077b16d9c7d47031f68c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::symbolic::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9eb2f0937be3e670ccdca9c4d30c63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9eb2f0937be3e670ccdca9c4d30c63d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::symbolic::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a673a4c5428fa87d2279c587959d5e3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673a4c5428fa87d2279c587959d5e3e7">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::symbolic::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30a0c468c43eb087bc5e98af3c3ad278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a0c468c43eb087bc5e98af3c3ad278">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::symbolic::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaba9db65867379d7603eeaeb9be56451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba9db65867379d7603eeaeb9be56451">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0de903abee4a9e39dbc9148d86c770c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0de903abee4a9e39dbc9148d86c770c">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(typename DerivedA::Scalar() &lt;= typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, typename internal::RelationalOpTraits&lt;DerivedA, DerivedB&gt;::ReturnType&gt; drake::symbolic::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using less-than-or-equal operator (&lt;=). </p>

</div>
</div>
<a id="a6718d0b755c47edc3fade14221574a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6718d0b755c47edc3fade14221574a03">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(typename Derived::Scalar() &lt;= ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt; drake::symbolic::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using less-than-or-equal operator (&lt;=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(a &lt;= v)</code> has a symbolic formula <code>a(i, j) &lt;= v</code>. </p>

</div>
</div>
<a id="a52479ecb229048e750782273796768c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52479ecb229048e750782273796768c2">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(ScalarType() &lt;= typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt; drake::symbolic::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than-or-equal operator (&lt;=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(v &lt;= a)</code> has a symbolic formula <code>v &lt;= a(i, j)</code>. </p>

</div>
</div>
<a id="af6bb943d7aab03288d67ad8f657c2758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6bb943d7aab03288d67ad8f657c2758">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::MatrixXpr&gt; &amp;&amp; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::MatrixXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(typename DerivedA::Scalar() &lt;= typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt; drake::symbolic::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using less-than-or-equal operator (&lt;=). </p>
<p>The following table describes the return type of <code>m1</code> &lt;= <code>m2</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LHS \ RHS  </th><th class="markdownTableHeadNone">EM&lt;Expression&gt;  </th><th class="markdownTableHeadNone">EM&lt;Variable&gt;  </th><th class="markdownTableHeadNone">EM&lt;double&gt;   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;Expression&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EM&lt;Variable&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;double&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone">N/A   </td></tr>
</table>
<p>In the table, <code>EM</code> is a short-hand of <code>Eigen::Matrix</code>. </p>

</div>
</div>
<a id="a463b86323b82db42856d70b2537759e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463b86323b82db42856d70b2537759e3">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a322e2ae11441c6769b244c680c9b565a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322e2ae11441c6769b244c680c9b565a">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(typename DerivedA::Scalar() == typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, typename internal::RelationalOpTraits&lt;DerivedA, DerivedB&gt;::ReturnType&gt; drake::symbolic::operator== </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise symbolic-equality of two arrays <code>m1</code> and <code>m2</code>. </p>
<p>The following table describes the return type of <code>m1</code> == <code>m2</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LHS \ RHS  </th><th class="markdownTableHeadNone">EA&lt;Expression&gt;  </th><th class="markdownTableHeadNone">EA&lt;Variable&gt;  </th><th class="markdownTableHeadNone">EA&lt;double&gt;   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EA&lt;Expression&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EA&lt;Variable&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EA&lt;double&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;  </td><td class="markdownTableBodyNone">EA&lt;bool&gt;   </td></tr>
</table>
<p>In the table, <code>EA</code> is a short-hand of <code>Eigen::Array</code>.</p>
<p>Note that this function does <em>not</em> provide operator overloading for the following case. It returns <code>Eigen::Array&lt;bool&gt;</code> and is provided by Eigen.</p>
<ul>
<li>Eigen::Array&lt;double&gt; == Eigen::Array&lt;double&gt; </li>
</ul>

</div>
</div>
<a id="ac4ac705adb39eafdc363379ce4ea950c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ac705adb39eafdc363379ce4ea950c">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(typename Derived::Scalar() == ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt; drake::symbolic::operator== </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using equal-to operator (==). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(a == v)</code> has a symbolic formula <code>a(i, j) == v</code>.</p>
<p>Here is an example using this operator overloading. </p><div class="fragment"><div class="line">Eigen::Array&lt;Variable, 2, 2&gt; a;</div><div class="line">a &lt;&lt; Variable{<span class="stringliteral">&quot;x&quot;</span>}, Variable{<span class="stringliteral">&quot;y&quot;</span>},</div><div class="line">     Variable{<span class="stringliteral">&quot;z&quot;</span>}, Variable{<span class="stringliteral">&quot;w&quot;</span>};</div><div class="line">Eigen::Array&lt;Formula, 2, 2&gt; f = (a == 3.5);</div><div class="line"><span class="comment">// Here f = |(x == 3.5)  (y == 3.5)|</span></div><div class="line"><span class="comment">//          |(z == 3.5)  (w == 3.5)|.</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ac1b8a2415edb336f8f0362518bbf183f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b8a2415edb336f8f0362518bbf183f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(ScalarType() == typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt; drake::symbolic::operator== </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> equal-to operator (==). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(v == a)</code> has a symbolic formula <code>v == a(i, j)</code>.</p>
<p>Here is an example using this operator overloading. </p><div class="fragment"><div class="line">Eigen::Array&lt;Variable, 2, 2&gt; a;</div><div class="line">a &lt;&lt; Variable{<span class="stringliteral">&quot;x&quot;</span>}, Variable{<span class="stringliteral">&quot;y&quot;</span>},</div><div class="line">     Variable{<span class="stringliteral">&quot;z&quot;</span>}, Variable{<span class="stringliteral">&quot;w&quot;</span>};</div><div class="line">Eigen::Array&lt;Formula, 2, 2&gt; f = (3.5 == a);</div><div class="line"><span class="comment">// Here f = |(3.5 == x)  (3.5 == y)|</span></div><div class="line"><span class="comment">//          |(3.5 == z)  (3.5 == w)|.</span></div></div><!-- fragment --> 
</div>
</div>
<a id="aea231d5704136799bf6fa221bdbb69bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea231d5704136799bf6fa221bdbb69bd">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::MatrixXpr&gt; &amp;&amp; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::MatrixXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(typename DerivedA::Scalar() == typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt; drake::symbolic::operator== </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula checking if two matrices <code>m1</code> and <code>m2</code> are equal. </p>
<p>The following table describes the return type of <code>m1</code> == <code>m2</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LHS \ RHS  </th><th class="markdownTableHeadNone">EM&lt;Expression&gt;  </th><th class="markdownTableHeadNone">EM&lt;Variable&gt;  </th><th class="markdownTableHeadNone">EM&lt;double&gt;   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;Expression&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EM&lt;Variable&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;double&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone">bool   </td></tr>
</table>
<p>In the table, <code>EM</code> is a short-hand of <code>Eigen::Matrix</code>.</p>
<p>Note that this function does <em>not</em> provide operator overloading for the following case. It returns <code>bool</code> and is provided by Eigen.</p>
<ul>
<li>Eigen::Matrix&lt;double&gt; == Eigen::Matrix&lt;double&gt;</li>
</ul>
<p>Note that this method returns a conjunctive formula which keeps its conjuncts as <code>std::set&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>&gt;</code> internally. This set is ordered by <code><a class="el" href="classdrake_1_1symbolic_1_1_formula.html#abd2677c76ddb28c10321b8178cfc6292" title="Checks lexicographical ordering between this and e.">Formula::Less</a></code> and this ordering can be <em>different</em> from the one in inputs. Also, any duplicated formulas are removed in construction. Please check the following example.</p>
<div class="fragment"><div class="line"><span class="comment">// set up v1 = [y x y] and v2 = [1 2 1]</span></div><div class="line">VectorX&lt;Expression&gt; v1{3};</div><div class="line">VectorX&lt;Expression&gt; v2{3};</div><div class="line"><span class="keyword">const</span> Variable <a class="code" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>{<span class="stringliteral">&quot;x&quot;</span>};</div><div class="line"><span class="keyword">const</span> Variable y{<span class="stringliteral">&quot;y&quot;</span>};</div><div class="line">v1 &lt;&lt; y, <a class="code" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, y;</div><div class="line">v2 &lt;&lt; 1, 2, 1;</div><div class="line"><span class="comment">// Here v1_eq_v2 = ((x = 2) ∧ (y = 1))</span></div><div class="line"><span class="keyword">const</span> Formula v1_eq_v2{v1 == v2};</div><div class="line"><span class="keyword">const</span> std::set&lt;Formula&gt; conjuncts{<a class="code" href="namespacedrake_1_1symbolic.html#a2362f52cf6b8c750209340520e7bc9b4">get_operands</a>(v1_eq_v2)};</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> Formula&amp; f : conjuncts) {</div><div class="line">  std::cerr &lt;&lt; f &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"><span class="comment">// The outcome of the above loop is:</span></div><div class="line">(<a class="code" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> = 2)</div><div class="line">(y = 1)</div></div><!-- fragment --> 
</div>
</div>
<a id="a5a12a5db3a9b2e8520e002e437354717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a12a5db3a9b2e8520e002e437354717">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45d3790aa8f813be2264913fd250bbcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d3790aa8f813be2264913fd250bbcf">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(typename DerivedA::Scalar() &gt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, typename internal::RelationalOpTraits&lt;DerivedA, DerivedB&gt;::ReturnType&gt; drake::symbolic::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using greater-than operator (&gt;). </p>

</div>
</div>
<a id="a6035c678aac2dd9201f9e8e294ece8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6035c678aac2dd9201f9e8e294ece8d6">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(typename Derived::Scalar() &gt; ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt; drake::symbolic::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using greater-than operator (&gt;). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(a &gt; v)</code> has a symbolic formula <code>a(i, j) &gt; v</code>. </p>

</div>
</div>
<a id="a20133edf27869418d18ec4fb7a29d03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20133edf27869418d18ec4fb7a29d03a">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(ScalarType() &gt; typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt; drake::symbolic::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than operator (&lt;) instead of greater-than operator (&gt;). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(v &gt; a)</code> has a symbolic formula <code>a(i, j) &lt; v</code>.</p>
<p>Note that given <code>v &gt; a</code>, this methods returns the result of <code>a &lt; v</code>. First of all, this formulation is mathematically equivalent to the original formulation. We implement this method in this way to be consistent with Eigen's semantics. See the definition of <code>EIGEN_MAKE_CWISE_COMP_R_OP</code> in ArrayCwiseBinaryOps.h file in Eigen. </p>

</div>
</div>
<a id="ad81230526e0921e5d17d5e08c2817cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81230526e0921e5d17d5e08c2817cc7">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::MatrixXpr&gt; &amp;&amp; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::MatrixXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(typename DerivedA::Scalar() &gt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt; drake::symbolic::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using greater-than operator (&gt;). </p>
<p>The following table describes the return type of <code>m1</code> &gt; <code>m2</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LHS \ RHS  </th><th class="markdownTableHeadNone">EM&lt;Expression&gt;  </th><th class="markdownTableHeadNone">EM&lt;Variable&gt;  </th><th class="markdownTableHeadNone">EM&lt;double&gt;   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;Expression&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EM&lt;Variable&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;double&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone">N/A   </td></tr>
</table>
<p>In the table, <code>EM</code> is a short-hand of <code>Eigen::Matrix</code>. </p>

</div>
</div>
<a id="a642d11dbe47e027614a5a3bcfe12d34e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642d11dbe47e027614a5a3bcfe12d34e">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1028ce4a4b55e7bf85a37d6282c3bf20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1028ce4a4b55e7bf85a37d6282c3bf20">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(typename DerivedA::Scalar() &gt;= typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, typename internal::RelationalOpTraits&lt;DerivedA, DerivedB&gt;::ReturnType&gt; drake::symbolic::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using greater-than-or-equal operator (&gt;=). </p>

</div>
</div>
<a id="a92ab06a3823da2ab0e41fb23fe64d2e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ab06a3823da2ab0e41fb23fe64d2e9">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(typename Derived::Scalar() &gt;= ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt; drake::symbolic::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using greater-than-or-equal operator (&gt;=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(a &gt;= v)</code> has a symbolic formula <code>a(i, j) &gt;= v</code>. </p>

</div>
</div>
<a id="a47616389df9ab060d41105d51db82be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47616389df9ab060d41105d51db82be4">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(ScalarType() &gt;= typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt; drake::symbolic::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than-or-equal operator (&lt;=) instead of greater-than-or-equal operator (&gt;=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(v &gt;= a)</code> has a symbolic formula <code>a(i, j) &lt;= v</code>.</p>
<p>Note that given <code>v &gt;= a</code>, this methods returns the result of <code>a &lt;= v</code>. First of all, this formulation is mathematically equivalent to the original formulation. We implement this method in this way to be consistent with Eigen's semantics. See the definition of <code>EIGEN_MAKE_CWISE_COMP_R_OP</code> in ArrayCwiseBinaryOps.h file in Eigen. </p>

</div>
</div>
<a id="a9594d5ed428f5fac27aced9c9fcd28d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9594d5ed428f5fac27aced9c9fcd28d1">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::MatrixXpr&gt; &amp;&amp; std::is_same_v&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::MatrixXpr&gt; &amp;&amp; std::is_same_v&lt;decltype(typename DerivedA::Scalar() &gt;= typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt; drake::symbolic::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using greater-than-or-equal operator (&gt;=). </p>
<p>The following table describes the return type of <code>m1</code> &gt;= <code>m2</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LHS \ RHS  </th><th class="markdownTableHeadNone">EM&lt;Expression&gt;  </th><th class="markdownTableHeadNone">EM&lt;Variable&gt;  </th><th class="markdownTableHeadNone">EM&lt;double&gt;   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;Expression&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EM&lt;Variable&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;double&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone">N/A   </td></tr>
</table>
<p>In the table, <code>EM</code> is a short-hand of <code>Eigen::Matrix</code>. </p>

</div>
</div>
<a id="a600c585cf975dd9a8dd94b118f0bd161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600c585cf975dd9a8dd94b118f0bd161">&#9670;&nbsp;</a></span>operator||() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac41223d30845a91ba757f6277ad8f8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41223d30845a91ba757f6277ad8f8a1">&#9670;&nbsp;</a></span>operator||() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aafc2f3979d06df08b80d2b280b9728c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc2f3979d06df08b80d2b280b9728c7">&#9670;&nbsp;</a></span>operator||() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a237ee4f068e65a6a4614af59482889eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237ee4f068e65a6a4614af59482889eb">&#9670;&nbsp;</a></span>operator||() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af50e3bc4e34ea64ae4d7065ad1fc72ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af50e3bc4e34ea64ae4d7065ad1fc72ac">&#9670;&nbsp;</a></span>PopulateRandomVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> drake::symbolic::PopulateRandomVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a>&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *&#160;</td>
          <td class="paramname"><em>random_generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the environment <code>env</code> by sampling values for the unassigned random variables in <code>variables</code> using <code>random_generator</code>. </p>

</div>
</div>
<a id="a648f540fa40e1e281133b972e394574a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648f540fa40e1e281133b972e394574a">&#9670;&nbsp;</a></span>positive_semidefinite() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula constraining <code>m</code> to be a positive-semidefinite matrix. </p>
<p>By definition, a symmetric matrix <code>m</code> is positive-semidefinte if xᵀ m x ≥ 0 for all vector x ∈ ℝⁿ.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>m</code> is not symmetric.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method checks if <code>m</code> is symmetric, which can be costly. If you want to avoid it, please consider using <code>positive_semidefinite(m.triangularView&lt;Eigen::Lower&gt;())</code> or <code>positive_semidefinite(m.triangularView&lt;Eigen::Upper&gt;())</code> instead of <code>positive_semidefinite(m)</code>. </dd></dl>

</div>
</div>
<a id="a514b594b37dbb603af40803e175b5f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514b594b37dbb603af40803e175b5f6a">&#9670;&nbsp;</a></span>positive_semidefinite() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::UpLoType&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs and returns a symbolic positive-semidefinite formula from <code>m</code>. </p>
<p>If <code>mode</code> is Eigen::Lower, it's using the lower-triangular part of <code>m</code> to construct a positive-semidefinite formula. If <code>mode</code> is Eigen::Upper, the upper-triangular part of <code>m</code> is used. It throws std::exception if <code>has</code> other values. See the following code snippet.</p>
<div class="fragment"><div class="line">Eigen::Matrix&lt;Expression, 2, 2&gt; m;</div><div class="line">m &lt;&lt; 1.0, 2.0,</div><div class="line">     3.0, 4.0;</div><div class="line"></div><div class="line"><span class="keyword">const</span> Formula psd_l{<a class="code" href="namespacedrake_1_1symbolic.html#a648f540fa40e1e281133b972e394574a">positive_semidefinite</a>(m, Eigen::Lower)};</div><div class="line"><span class="comment">// psd_l includes [1.0 3.0]</span></div><div class="line"><span class="comment">//                [3.0 4.0].</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> Formula psd_u{<a class="code" href="namespacedrake_1_1symbolic.html#a648f540fa40e1e281133b972e394574a">positive_semidefinite</a>(m, Eigen::Upper)};</div><div class="line"><span class="comment">// psd_u includes [1.0 2.0]</span></div><div class="line"><span class="comment">//                [2.0 4.0].</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a097b1381843c0314529765995289c063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a097b1381843c0314529765995289c063">&#9670;&nbsp;</a></span>positive_semidefinite() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::MatrixXpr&gt; &amp;&amp; std::is_same_v&lt;typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt; drake::symbolic::positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const Eigen::TriangularView&lt; Derived, Eigen::Lower &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs and returns a symbolic positive-semidefinite formula from a lower triangular-view <code>l</code>. </p>
<p>See the following code snippet.</p>
<div class="fragment"><div class="line">Eigen::Matrix&lt;Expression, 2, 2&gt; m;</div><div class="line">m &lt;&lt; 1.0, 2.0,</div><div class="line">     3.0, 4.0;</div><div class="line"></div><div class="line">Formula psd{<a class="code" href="namespacedrake_1_1symbolic.html#a648f540fa40e1e281133b972e394574a">positive_semidefinite</a>(m.triangularView&lt;Eigen::Lower&gt;())};</div><div class="line"><span class="comment">// psd includes [1.0 3.0]</span></div><div class="line"><span class="comment">//              [3.0 4.0].</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a2b2c6f4240ba42744712ab5f5c73c1db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2c6f4240ba42744712ab5f5c73c1db">&#9670;&nbsp;</a></span>positive_semidefinite() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::MatrixXpr&gt; &amp;&amp; std::is_same_v&lt;typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt; drake::symbolic::positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const Eigen::TriangularView&lt; Derived, Eigen::Upper &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs and returns a symbolic positive-semidefinite formula from an upper triangular-view <code>u</code>. </p>
<p>See the following code snippet.</p>
<div class="fragment"><div class="line">Eigen::Matrix&lt;Expression, 2, 2&gt; m;</div><div class="line">m &lt;&lt; 1.0, 2.0,</div><div class="line">     3.0, 4.0;</div><div class="line"></div><div class="line">Formula psd{<a class="code" href="namespacedrake_1_1symbolic.html#a648f540fa40e1e281133b972e394574a">positive_semidefinite</a>(m.triangularView&lt;Eigen::Upper&gt;())};</div><div class="line"><span class="comment">// psd includes [1.0 2.0]</span></div><div class="line"><span class="comment">//              [2.0 4.0].</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a8b3d409cea5e6c6495394208c8c8c6ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b3d409cea5e6c6495394208c8c8c6ee">&#9670;&nbsp;</a></span>pow() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> drake::symbolic::pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>m</code> raised to <code>p</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>p</code> is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec1d54669ca8ae5ea474b5904c50e85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1d54669ca8ae5ea474b5904c50e85e">&#9670;&nbsp;</a></span>pow() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a>, <a class="el" href="classdouble.html">double</a>&gt; drake::symbolic::pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>m</code> raised to <code>p</code>. </p>
<dl class="section note"><dt>Note</dt><dd>that we return a map from the monomial power to its coefficient. This map has size 1, and the coefficient is also 1. We return a map instead of the <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html" title="MonomialBasisElement represents a monomial, a product of powers of variables with non-negative intege...">MonomialBasisElement</a> directly, because we want <a class="el" href="namespacedrake_1_1symbolic.html#a3abe49c1083796a8b370bab55535aa72">pow()</a> to have the same return signature as other <a class="el" href="classdrake_1_1symbolic_1_1_polynomial_basis_element.html" title="Each polynomial p(x) can be written as a linear combination of its basis elements p(x) = ∑ᵢ cᵢ * ϕᵢ(x...">PolynomialBasisElement</a>. For example, the power of a <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html" title="ChebyshevBasisElement represents an element of Chebyshev polynomial basis, written as the product of ...">ChebyshevBasisElement</a> object is a weighted sum of <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html" title="ChebyshevBasisElement represents an element of Chebyshev polynomial basis, written as the product of ...">ChebyshevBasisElement</a> objects. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>p</code> is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43d86ae3f21714ef199febddf60550fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d86ae3f21714ef199febddf60550fe">&#9670;&nbsp;</a></span>pow() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the rational function <code>f</code> raised to <code>n</code>. </p>
<p>If n is positive, (f/g)ⁿ = fⁿ / gⁿ; If n is negative, (f/g)ⁿ = g⁻ⁿ / f⁻ⁿ; (f/g)⁰ = 1 / 1. </p>

</div>
</div>
<a id="a8fa3b0259a14e44faf2d959f540e9446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa3b0259a14e44faf2d959f540e9446">&#9670;&nbsp;</a></span>pow() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns polynomial <code>p</code> raised to <code>n</code>. </p>

</div>
</div>
<a id="a830fbf97ac01bf807b4915e3087585da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a830fbf97ac01bf807b4915e3087585da">&#9670;&nbsp;</a></span>pow() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a4f60d4b8ada97a4fb724b2d66d273892">GenericPolynomialEnable</a>&lt;BasisElement&gt; drake::symbolic::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_generic_polynomial.html">GenericPolynomial</a>&lt; BasisElement &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns polynomial <code>raised</code> to <code>n</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The base polynomial. </td></tr>
    <tr><td class="paramname">n</td><td>The exponent of the power. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>n&gt;=0. </dd></dl>

</div>
</div>
<a id="a3abe49c1083796a8b370bab55535aa72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3abe49c1083796a8b370bab55535aa72">&#9670;&nbsp;</a></span>pow() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04799bc5337c8999ef3f10e82dd979cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04799bc5337c8999ef3f10e82dd979cd">&#9670;&nbsp;</a></span>ReplaceBilinearTerms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> drake::symbolic::ReplaceBilinearTerms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all the bilinear product terms in the expression <code>e</code>, with the corresponding terms in <code>W</code>, where <code>W</code> represents the matrix x * yᵀ, such that after replacement, <code>e</code> does not have bilinear terms involving <code>x</code> and <code>y</code>. </p>
<p>For example, if e = x(0)*y(0) + 2 * x(0)*y(1) + x(1) * y(1) + 3 * x(1), <code>e</code> has bilinear terms x(0)*y(0), x(0) * y(1) and x(2) * y(1), if we call ReplaceBilinearTerms(e, x, y, W) where W(i, j) represent the term x(i) * y(j), then this function returns W(0, 0) + 2 * W(0, 1) + W(1, 1) + 3 * x(1). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>An expression potentially contains bilinear products between x and y. </td></tr>
    <tr><td class="paramname">x</td><td>The bilinear product between <code>x</code> and <code>y</code> will be replaced by the corresponding term in <code>W</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>x</code> contains duplicate entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>The bilinear product between <code>x</code> and <code>y</code> will be replaced by the corresponding term in <code>W</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>y</code> contains duplicate entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">W</td><td>Bilinear product term x(i) * y(j) will be replaced by W(i, j). If W(i,j) is not a single variable, but an expression, then this expression cannot contain a variable in either x or y. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception,if</td><td>W(i, j) is not a single variable, and also contains a variable in x or y. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>W.rows() == x.rows() and W.cols() == y.rows(). </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The symbolic expression after replacing x(i) * y(j) with W(i, j). </dd></dl>

</div>
</div>
<a id="a90efdc7cf4be8bddc1fa365fb78b8e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90efdc7cf4be8bddc1fa365fb78b8e4a">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96d1119f8ec23bd6d918a984ce5820b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d1119f8ec23bd6d918a984ce5820b9">&#9670;&nbsp;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a65a5c97c514e6a5cb74438c6c2f5e760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a5c97c514e6a5cb74438c6c2f5e760">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6639ded5e13e34eee457b3ceb92a1d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6639ded5e13e34eee457b3ceb92a1d62">&#9670;&nbsp;</a></span>Substitute() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::Substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1symbolic.html#a13c5d9eccfc9643fdd5764d6e72b8faf">SinCosSubstitution</a> &amp;&#160;</td>
          <td class="paramname"><em>subs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a substitution map q =&gt; {s, c}, substitutes instances of sin(q) and cos(q) in <code>e</code> with <code>s</code> and <code>c</code>, with partial support for trigonometric expansions. </p>
<p>For instance, </p><pre class="fragment">  Variable x{"x"}, y{"y"};
  Variable sx{"sx"}, cx{"cx"}, sy{"sy"}, cy{"cy"};
  SinCosSubstitution subs;
  subs.emplace(x, SinCos(sx, cx));
  subs.emplace(y, SinCos(sy, cy));
  Expression e = Substitute(x * sin(x + y), subs);
</pre><p> will result in the expression <code>x * (sx*cy + cx*sy)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subs</td><td>When set to one of the half_angle options, then the same workflow replaces instances of sin(q/2) and cos(q/2) in <code>e</code> will be replaced with <code>s</code>, and <code>c</code>. <br />
 <em>Default:</em> false.</td></tr>
  </table>
  </dd>
</dl>
<p>The half-angle representation is more natural in many analysis computations for robots, for instance: <a href="https://underactuated.csail.mit.edu/lyapunov.html#trig_quadratic">https://underactuated.csail.mit.edu/lyapunov.html#trig_quadratic</a></p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if a trigonometric function is not a trigonometric polynomial in <code>q</code> or if the <code>e</code> requires a trigonometric expansion that not supported yet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1db53e224c37b630f7ec9d1615215449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db53e224c37b630f7ec9d1615215449">&#9670;&nbsp;</a></span>Substitute() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#aaadcdc21cc0c381e5879b1b7f023d82d">MatrixLikewise</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Derived&gt; drake::symbolic::Substitute </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1symbolic.html#a13c5d9eccfc9643fdd5764d6e72b8faf">SinCosSubstitution</a> &amp;&#160;</td>
          <td class="paramname"><em>subs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix version of sin/cos substitution. </p>

</div>
</div>
<a id="acf922c7aec2a7797cc4c9c22dcdada1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf922c7aec2a7797cc4c9c22dcdada1f">&#9670;&nbsp;</a></span>Substitute() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#aaadcdc21cc0c381e5879b1b7f023d82d">MatrixLikewise</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Derived&gt; drake::symbolic::Substitute </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1symbolic.html#acbfe43d34e6c71c503d4de11da53bbb7">Substitution</a> &amp;&#160;</td>
          <td class="paramname"><em>subst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutes a symbolic matrix <code>m</code> using a given substitution <code>subst</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>a matrix of symbolic expressions whose size is the size of <code>m</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if NaN is detected during substitution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1a16b2f5eca5672442bb9dc25be825c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a16b2f5eca5672442bb9dc25be825c">&#9670;&nbsp;</a></span>Substitute() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#aaadcdc21cc0c381e5879b1b7f023d82d">MatrixLikewise</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Derived&gt; drake::symbolic::Substitute </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutes <code>var</code> with <code>e</code> in a symbolic matrix <code>m</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>a matrix of symbolic expressions whose size is the size of <code>m</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if NaN is detected during substitution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad88f58019962d307b9da7ebc9d32ec87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad88f58019962d307b9da7ebc9d32ec87">&#9670;&nbsp;</a></span>SubstituteStereographicProjection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">symbolic::RationalFunction</a> drake::symbolic::SubstituteStereographicProjection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structdrake_1_1symbolic_1_1_sin_cos.html">SinCos</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sin_cos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutes the variables representing sine and cosine functions with their stereographic projection. </p>
<p>We replace cosθᵢ with (1-tᵢ²)/(1+tᵢ²), and sinθᵢ with 2tᵢ/(1+tᵢ²), and get a rational polynomial. The indeterminates of this rational polynomial are t together with the indeterminates in <code>e</code> that are not cosθ or sinθ. If the input expression doesn't contain the sine and cosine functions, then the returned rational has denominator being 1. Notice that the indeterminates of <code>e</code> can include variables other than cosθ and sinθ, and we impose no requirements on these variables that are not cosθ or sinθ.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The symbolic polynomial to be substituted. </td></tr>
    <tr><td class="paramname">sin_cos</td><td>sin_cos(i) is the pair of variables (sᵢ, cᵢ), (where sᵢ=sinθᵢ, cᵢ=cosθᵢ) as documented above. </td></tr>
    <tr><td class="paramname">t</td><td>New variables to express cos and sin as rationals of t. tᵢ = tan(θᵢ/2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>t.rows() == sin_cos.size() </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>e_rational The rational polynomial of e after replacement. The indeterminates of the polynomials are <code>t</code> together with the indeterminates in <code>e</code> that are not cosθ or sinθ. Example <pre class="fragment">* std::vector&lt;SinCos&gt; sin_cos;
* sin_cos.emplace_back(symbolic::Variable("s0"), symbolic::Variable("c0"));
* sin_cos.emplace_back(symbolic::Variable("s1"), symbolic::Variable("c1"));
* Vector2&lt;symbolic::Variable&gt; t(symbolic::Variable("t0"),
*                               symbolic::Variable("t1"));
* const auto e_rational =
* SubstituteStereographicProjection(t(0) * sin_cos[0].s*sin_cos[1].c + 1,
*                                   sin_cos, t);
* // e_rational should be
* // (2*t0*t0*(1-t1*t1) + (1+t0*t0)*(1+t1*t1))
* // --------------------------------------------
* //        ((1+t0*t0)*(1+t1*t1))
* </pre> </dd></dl>

</div>
</div>
<a id="a78354ef5dda9c52bbc103d57712c303e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78354ef5dda9c52bbc103d57712c303e">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::symbolic::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9900f71e1c1ceb9d59553adfa2db2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9900f71e1c1ceb9d59553adfa2db2b5">&#9670;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbb3ea44b1cf2fd877d782b8486d5aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb3ea44b1cf2fd877d782b8486d5aeb">&#9670;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed2857d827b306fc80cf6c23e14f211c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2857d827b306fc80cf6c23e14f211c">&#9670;&nbsp;</a></span>TaylorExpand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::TaylorExpand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Taylor series expansion of <code>f</code> around <code>a</code> of order <code>order</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Symbolic expression to approximate using Taylor series expansion. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Symbolic environment which specifies the point of approximation. If a partial environment is provided, the unspecified variables are treated as symbolic variables (e.g. decision variable). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Positive integer which specifies the maximum order of the resulting polynomial approximating <code>f</code> around <code>a</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a180aa6c7637801b158099a87a59a4185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180aa6c7637801b158099a87a59a4185">&#9670;&nbsp;</a></span>to_conjunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_and.html">FormulaAnd</a>&gt; drake::symbolic::to_conjunction </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaAnd&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_conjunction(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a0b0758b788047cb3d6b4737c6d54cee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0758b788047cb3d6b4737c6d54cee2">&#9670;&nbsp;</a></span>to_disjunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_or.html">FormulaOr</a>&gt; drake::symbolic::to_disjunction </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaOr&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_disjunction(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a10a6204418091c1fbf26c9d2ad03389f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a6204418091c1fbf26c9d2ad03389f">&#9670;&nbsp;</a></span>to_equal_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_eq.html">FormulaEq</a>&gt; drake::symbolic::to_equal_to </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaEq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_equal_to(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a1ba2673fe37620dcc2a3b06ab7b72bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba2673fe37620dcc2a3b06ab7b72bec">&#9670;&nbsp;</a></span>to_false()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_false.html">FormulaFalse</a>&gt; drake::symbolic::to_false </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaFalse&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_false(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a7c587017789ff28f462e87ba0a44872d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c587017789ff28f462e87ba0a44872d">&#9670;&nbsp;</a></span>to_forall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_forall.html">FormulaForall</a>&gt; drake::symbolic::to_forall </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaForall&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_forall(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a352fe19778d77b7095580950d8e298b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352fe19778d77b7095580950d8e298b4">&#9670;&nbsp;</a></span>to_greater_than()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_gt.html">FormulaGt</a>&gt; drake::symbolic::to_greater_than </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaGt&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_greater_than(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a7f8cbb802de92188843f8531d6b05827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f8cbb802de92188843f8531d6b05827">&#9670;&nbsp;</a></span>to_greater_than_or_equal_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_geq.html">FormulaGeq</a>&gt; drake::symbolic::to_greater_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaGeq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_greater_than_or_equal_to(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="ad4f46f5ae1e9130eb9214a2ae0611f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f46f5ae1e9130eb9214a2ae0611f52">&#9670;&nbsp;</a></span>to_isnan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_isnan.html">FormulaIsnan</a>&gt; drake::symbolic::to_isnan </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaIsnan&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_isnan(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a7488de67ca4d6bc69cec3bb0f67ae4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7488de67ca4d6bc69cec3bb0f67ae4c3">&#9670;&nbsp;</a></span>to_less_than()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_lt.html">FormulaLt</a>&gt; drake::symbolic::to_less_than </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaLt&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_less_than(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="acfb39c33945b763922fe0fcacc6c369b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb39c33945b763922fe0fcacc6c369b">&#9670;&nbsp;</a></span>to_less_than_or_equal_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_leq.html">FormulaLeq</a>&gt; drake::symbolic::to_less_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaLeq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_less_than_or_equal_to(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="ad0f9249b5c150485c3c7cff61d5c0416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f9249b5c150485c3c7cff61d5c0416">&#9670;&nbsp;</a></span>to_nary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_nary_formula_cell.html">NaryFormulaCell</a>&gt; drake::symbolic::to_nary </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const NaryFormulaCell&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_nary(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="aceef2c41a1ce6c5f7eed83c1d2df9381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceef2c41a1ce6c5f7eed83c1d2df9381">&#9670;&nbsp;</a></span>to_negation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_not.html">FormulaNot</a>&gt; drake::symbolic::to_negation </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaNot&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_negation(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a70e880ce60c41c7e65085dbf911edded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e880ce60c41c7e65085dbf911edded">&#9670;&nbsp;</a></span>to_not_equal_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_neq.html">FormulaNeq</a>&gt; drake::symbolic::to_not_equal_to </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaNeq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_not_equal_to(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a6854fa16fb68d99c3cbe16d2c9afc584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6854fa16fb68d99c3cbe16d2c9afc584">&#9670;&nbsp;</a></span>to_positive_semidefinite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_positive_semidefinite.html">FormulaPositiveSemidefinite</a>&gt; drake::symbolic::to_positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaPositiveSemidefinite&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_positive_semidefinite(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a259612bbd9405f24d4ac3b60d54575e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259612bbd9405f24d4ac3b60d54575e6">&#9670;&nbsp;</a></span>to_relational()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_relational_formula_cell.html">RelationalFormulaCell</a>&gt; drake::symbolic::to_relational </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const RelationalFormulaCell&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_relational(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a85772f75f073405ed82017151b4cb279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85772f75f073405ed82017151b4cb279">&#9670;&nbsp;</a></span>to_true()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_true.html">FormulaTrue</a>&gt; drake::symbolic::to_true </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaTrue&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_true(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a3b78dde9ca32fe1ee12cc232a9a4e85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b78dde9ca32fe1ee12cc232a9a4e85c">&#9670;&nbsp;</a></span>to_variable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_var.html">FormulaVar</a>&gt; drake::symbolic::to_variable </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaVar&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_variable(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a50f946a2d656be1b946c8f2f6bf00810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f946a2d656be1b946c8f2f6bf00810">&#9670;&nbsp;</a></span>ToLatex() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string drake::symbolic::ToLatex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a LaTeX string representation of <code>e</code> with floating point coefficients displayed using <code>precision</code>. </p>

</div>
</div>
<a id="accb78ec8e49199eaff087d9637301041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb78ec8e49199eaff087d9637301041">&#9670;&nbsp;</a></span>ToLatex() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string drake::symbolic::ToLatex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a LaTeX string representation of <code>f</code> with floating point coefficients displayed using <code>precision</code>. </p>

</div>
</div>
<a id="a38b1d770b9e21d7e4f36649630b10891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b1d770b9e21d7e4f36649630b10891">&#9670;&nbsp;</a></span>ToLatex() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string drake::symbolic::ToLatex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a Latex string representation of <code>val</code> displayed with <code>precision</code>, with one exception. </p>
<p>If the fractional part of <code>val</code> is exactly zero, then <code>val</code> is represented perfectly as an integer, and is displayed without the trailing decimal point and zeros (in this case, the <code>precision</code> argument is ignored). </p>

</div>
</div>
<a id="aa14d755813030ea14c7207a4e0e71f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14d755813030ea14c7207a4e0e71f9f">&#9670;&nbsp;</a></span>ToLatex() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string drake::symbolic::ToLatex </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a LaTeX string representation of <code>M</code> with floating point coefficients displayed using <code>precision</code>. </p>

</div>
</div>
<a id="a986094e62cf81f5b0c1d4f33df8f8e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a986094e62cf81f5b0c1d4f33df8f8e3f">&#9670;&nbsp;</a></span>uninterpreted_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::uninterpreted_function </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an uninterpreted-function expression with <code>name</code> and <code>arguments</code>. </p>
<p>An uninterpreted function is an opaque function that has no other property than its name and a list of its arguments. This is useful to applications where it is good enough to provide abstract information of a function without exposing full details. Declaring sparsity of a system is a typical example. </p>

</div>
</div>
<a id="ab58092344918003fc7e186b1c57bbc7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58092344918003fc7e186b1c57bbc7f">&#9670;&nbsp;</a></span>VisitExpression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Result drake::symbolic::VisitExpression </td>
          <td>(</td>
          <td class="paramtype">Visitor *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls visitor object <code>v</code> with a symbolic-expression <code>e</code>, and arguments <code>args</code>. </p>
<p>Visitor object is expected to implement the following methods which take <code>f</code> and <code>args:</code> <code>VisitConstant</code>, <code>VisitVariable</code>, <code>VisitAddition</code>, <code>VisitMultiplication</code>, <code>VisitDivision</code>, <code>VisitLog</code>, <code>VisitAbs</code>, <code>VisitExp</code>, <code>VisitSqrt</code>, <code>VisitPow</code>, <code>VisitSin</code>, <code>VisitCos</code>, <code>VisitTan</code>, <code>VisitAsin</code>, <code>VisitAtan</code>, <code>VisitAtan2</code>, <code>VisitSinh</code>, <code>VisitCosh</code>, <code>VisitTanh</code>, <code>VisitMin</code>, <code>VisitMax</code>, <code>VisitCeil</code>, <code>VisitFloor</code>, <code>VisitIfThenElse</code>, <code>VisitUninterpretedFunction</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if NaN is detected during a visit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2748b5dc34bc17a6c6e98ac1d0cc1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2748b5dc34bc17a6c6e98ac1d0cc1ad">&#9670;&nbsp;</a></span>VisitFormula()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Result drake::symbolic::VisitFormula </td>
          <td>(</td>
          <td class="paramtype">Visitor *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls visitor object <code>v</code> with a symbolic formula <code>f</code>, and arguments <code>args</code>. </p>
<p>Visitor object is expected to implement the following methods which take <code>f</code> and <code>args:</code> <code>VisitFalse</code>, <code>VisitTrue</code>, <code>VisitVariable</code>, <code>VisitEqualTo</code>, VisitNotEqualTo, VisitGreaterThan, <code>VisitGreaterThanOrEqualTo</code>, <code>VisitLessThan</code>, <code>VisitLessThanOrEqualTo</code>, <code>VisitConjunction</code>, <code>VisitDisjunction</code>, <code>VisitNegation</code>, <code>VisitForall</code>, <code>VisitIsnan</code>, <code>VisitPositiveSemidefinite</code>.</p>
<p>Check the implementation of <code>NegationNormalFormConverter</code> class in drake/common/test/symbolic_formula_visitor_test.cc file to find an example. </p>

</div>
</div>
<a id="a0a61c45c20176e91159639186b26e35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a61c45c20176e91159639186b26e35e">&#9670;&nbsp;</a></span>VisitPolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Result drake::symbolic::VisitPolynomial </td>
          <td>(</td>
          <td class="paramtype">Visitor *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls visitor object <code>v</code> with a polynomial symbolic-expression <code>e</code>, and arguments <code>args</code>. </p>
<p>Visitor object is expected to implement the following methods which take <code>f</code> and <code>args:</code> <code>VisitConstant</code>, <code>VisitVariable</code>, <code>VisitAddition</code>, <code>VisitMultiplication</code>, <code>VisitDivision</code>, <code>VisitPow</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if NaN is detected during a visit.</td></tr>
  </table>
  </dd>
</dl>
<p>See the implementation of <code>DegreeVisitor</code> class and <code>Degree</code> function in drake/common/symbolic_monomial.cc as an example usage.</p>
<dl class="section pre"><dt>Precondition</dt><dd>e.is_polynomial() is true. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1symbolic.html">symbolic</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().value = searchBox.searchLabel;
</script>
</body>
</html>
