<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: IntegratorBase&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1systems_1_1_integrator_base.html','','classdrake_1_1systems_1_1_integrator_base-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">IntegratorBase&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel abstract">abstract</span></span><div class="ingroups"><a class="el" href="group__algorithms.html">Algorithms</a> &raquo; <a class="el" href="group__simulation.html">Simulation</a> &raquo; <a class="el" href="group__integrators.html">Integrators</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T&gt;<br />
class drake::systems::IntegratorBase&lt; T &gt;</div><p>An abstract class for an integrator for ODEs and DAEs as represented by a Drake <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>. </p>
<p>Integrators solve initial value problems of the form:</p><pre>
ẋ(t) = f(t, x(t)) with f : ℝ × ℝⁿ → ℝⁿ
</pre><p> (i.e., <span class="tt">f()</span> is an ordinary differential equation) given initial conditions (t₀, x₀). Thus, integrators advance the continuous state of a dynamical system forward in time.</p>
<p>Drake's subclasses of IntegratorBase&lt;T&gt; should follow the naming pattern <span class="tt">FooIntegrator&lt;T&gt;</span> by convention.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/systems/analysis/integrator_base.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a95ae527571e3f25c4415b93d12cb0ad9" id="r_a95ae527571e3f25c4415b93d12cb0ad9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95ae527571e3f25c4415b93d12cb0ad9">StepResult</a> { <br />
&#160;&#160;<a class="el" href="#a95ae527571e3f25c4415b93d12cb0ad9a1eb5c205e3572ba9946f3c86f093c845">kReachedPublishTime</a> = 1
, <a class="el" href="#a95ae527571e3f25c4415b93d12cb0ad9a1d1f7136371fa0489571cddeb08084e8">kReachedZeroCrossing</a> = 2
, <a class="el" href="#a95ae527571e3f25c4415b93d12cb0ad9a804060ac669eb47e5d384d3800e59d9c">kReachedUpdateTime</a> = 3
, <a class="el" href="#a95ae527571e3f25c4415b93d12cb0ad9a8d552f806d347dcd4031fbce86195737">kTimeHasAdvanced</a> = 4
, <br />
&#160;&#160;<a class="el" href="#a95ae527571e3f25c4415b93d12cb0ad9ab50d451e0bcc5385a4bdfd6b3bf5482c">kReachedBoundaryTime</a> = 5
, <a class="el" href="#a95ae527571e3f25c4415b93d12cb0ad9a7ea4dacf674c208f87e90fa976d0829f">kReachedStepLimit</a> = 6
<br />
 }</td></tr>
<tr class="memdesc:a95ae527571e3f25c4415b93d12cb0ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status returned by <a class="el" href="#a02875acba81c8be7dd0c7a2ae89db212" title="(Internal use only) Integrates the system forward in time by a single step with step size subject to ...">IntegrateNoFurtherThanTime()</a>.  <a href="#a95ae527571e3f25c4415b93d12cb0ad9">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a447030379c5091a36af0c158a0945c6e" id="r_a447030379c5091a36af0c158a0945c6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a447030379c5091a36af0c158a0945c6e">IntegratorBase</a> (const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &amp;system, <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context=nullptr)</td></tr>
<tr class="memdesc:a447030379c5091a36af0c158a0945c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains references to the system being integrated and the context used to specify the initial conditions for that system (if any).  <br /></td></tr>
<tr class="memitem:a94d8cc81230c7f1f3d751bfd14b01cdc" id="r_a94d8cc81230c7f1f3d751bfd14b01cdc"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94d8cc81230c7f1f3d751bfd14b01cdc">~IntegratorBase</a> ()</td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:a3ecc7a468ab5fc69c4dd0beefd4aab08" id="r_a3ecc7a468ab5fc69c4dd0beefd4aab08"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ecc7a468ab5fc69c4dd0beefd4aab08">IntegratorBase</a> (const IntegratorBase &amp;)=delete</td></tr>
<tr class="memitem:ab897e6180da38fdb008bfc9aea3967b0" id="r_ab897e6180da38fdb008bfc9aea3967b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3ecc7a468ab5fc69c4dd0beefd4aab08">IntegratorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab897e6180da38fdb008bfc9aea3967b0">operator=</a> (const <a class="el" href="#a3ecc7a468ab5fc69c4dd0beefd4aab08">IntegratorBase</a> &amp;)=delete</td></tr>
<tr class="memitem:aa0d908b973947061eaa9041e6a2b1442" id="r_aa0d908b973947061eaa9041e6a2b1442"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0d908b973947061eaa9041e6a2b1442">IntegratorBase</a> (IntegratorBase &amp;&amp;)=delete</td></tr>
<tr class="memitem:ade9156bf8b8283f60dd3f9caca08cb78" id="r_ade9156bf8b8283f60dd3f9caca08cb78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3ecc7a468ab5fc69c4dd0beefd4aab08">IntegratorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade9156bf8b8283f60dd3f9caca08cb78">operator=</a> (<a class="el" href="#a3ecc7a468ab5fc69c4dd0beefd4aab08">IntegratorBase</a> &amp;&amp;)=delete</td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Methods for getting and setting integrator accuracy</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="integrator-accuracy"></a> The precise meaning of <em>accuracy</em> is a complicated discussion, but it translates roughly to the number of significant digits you want in the results.</p>
<p>By convention it is supplied as <span class="tt">10^-digits</span>, meaning that an accuracy of 1e-3 provides about three significant digits. For more discussion of accuracy, see <a class="el" href="group__accuracy__and__tolerance.html">Accuracy, Tolerance, and Precision</a> and ref. <a href="https://dx.doi.org/10.1016/j.piutam.2011.04.023">[1]</a>.</p>
<p>Integrators vary in the range of accuracy (loosest to tightest) that they can support, and each integrator will choose a default accuracy to be used that lies somewhere within this range and attempts to balance computation and accuracy. If you request accuracy outside the supported range for the chosen integrator it will be quietly adjusted to be in range. You can find out the accuracy setting actually being used using <span class="tt"><a class="el" href="#a4ecfd0a8cbb76b7f43921e284b2a6980" title="Gets the accuracy in use by the integrator.">get_accuracy_in_use()</a></span>.</p>
<p>Implicit integrators additionally use the accuracy setting for determining when the underlying Newton-Raphson root finding process has converged. For those integrators, the accuracy setting also limits the allowable iteration error in the Newton-Raphson process. Looser accuracy in that process certainly implies greater error in the ODE solution and might impact the stability of the solution negatively as well.</p>
<ul>
<li>[1] M. Sherman, A. Seth, S. Delp. Procedia IUTAM 2:241-261 (2011), Section 3.3. <a href="https://dx.doi.org/10.1016/j.piutam.2011.04.023">https://dx.doi.org/10.1016/j.piutam.2011.04.023</a> </li>
</ul>
</div></td></tr>
<tr class="memitem:a6dbb07017a30541d06b2b597d1e4f30f" id="r_a6dbb07017a30541d06b2b597d1e4f30f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dbb07017a30541d06b2b597d1e4f30f">set_target_accuracy</a> (<a class="el" href="classdouble.html">double</a> accuracy)</td></tr>
<tr class="memdesc:a6dbb07017a30541d06b2b597d1e4f30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request that the integrator attempt to achieve a particular accuracy for the continuous portions of the simulation.  <br /></td></tr>
<tr class="memitem:a630ba1d30cec20bb83e5a678945ffaa2" id="r_a630ba1d30cec20bb83e5a678945ffaa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a630ba1d30cec20bb83e5a678945ffaa2">get_target_accuracy</a> () const</td></tr>
<tr class="memdesc:a630ba1d30cec20bb83e5a678945ffaa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the target accuracy.  <br /></td></tr>
<tr class="memitem:a4ecfd0a8cbb76b7f43921e284b2a6980" id="r_a4ecfd0a8cbb76b7f43921e284b2a6980"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ecfd0a8cbb76b7f43921e284b2a6980">get_accuracy_in_use</a> () const</td></tr>
<tr class="memdesc:a4ecfd0a8cbb76b7f43921e284b2a6980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the accuracy in use by the integrator.  <br /></td></tr>
<tr id="pub-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Methods related to error estimation and control</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="error-estimation-and-control"></a> Established methods for integrating ordinary differential equations invariably make provisions for estimating the "local error" (i.e., the error over a small time interval) of a solution.</p>
<p>Although the relationship between local error and global error (i.e., the accumulated error over multiple time steps) can be tenuous, such error estimates can allow integrators to work adaptively, subdividing time intervals as necessary (if, e.g., the system is particularly dynamic or stationary in an interval). Even for applications that do not recommend such adaptive integration- like direct transcription methods for trajectory optimization- error estimation allows the user to assess the accuracy of the solution. </p>
</div></td></tr>
<tr class="memitem:a5fa66573f5abb1dc153098d2920c32b7" id="r_a5fa66573f5abb1dc153098d2920c32b7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fa66573f5abb1dc153098d2920c32b7">supports_error_estimation</a> () const =0</td></tr>
<tr class="memdesc:a5fa66573f5abb1dc153098d2920c32b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes must override this function to indicate whether the integrator supports error estimation.  <br /></td></tr>
<tr class="memitem:ab09a2cc2db0a776ca7bb11c8d8fe4831" id="r_ab09a2cc2db0a776ca7bb11c8d8fe4831"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab09a2cc2db0a776ca7bb11c8d8fe4831">get_error_estimate_order</a> () const =0</td></tr>
<tr class="memdesc:ab09a2cc2db0a776ca7bb11c8d8fe4831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes must override this function to return the order of the asymptotic term in the integrator's error estimate.  <br /></td></tr>
<tr class="memitem:a55be09edf29a71aff2a1774622b04e2a" id="r_a55be09edf29a71aff2a1774622b04e2a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55be09edf29a71aff2a1774622b04e2a">get_error_estimate</a> () const</td></tr>
<tr class="memdesc:a55be09edf29a71aff2a1774622b04e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the error estimate (used only for integrators that support error estimation).  <br /></td></tr>
<tr class="memitem:a8a5d955e6a56d941233b9db657bc5a66" id="r_a8a5d955e6a56d941233b9db657bc5a66"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a5d955e6a56d941233b9db657bc5a66">get_ideal_next_step_size</a> () const</td></tr>
<tr class="memdesc:a8a5d955e6a56d941233b9db657bc5a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the step size the integrator would like to take next, based primarily on the integrator's accuracy prediction.  <br /></td></tr>
<tr class="memitem:a53f8dced020f4fa9c3ccfc2eb6982a86" id="r_a53f8dced020f4fa9c3ccfc2eb6982a86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53f8dced020f4fa9c3ccfc2eb6982a86">set_fixed_step_mode</a> (bool flag)</td></tr>
<tr class="memdesc:a53f8dced020f4fa9c3ccfc2eb6982a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an integrator with error control to fixed step mode.  <br /></td></tr>
<tr class="memitem:ae35b01e013bbfa64d9cdccfa01f034fe" id="r_ae35b01e013bbfa64d9cdccfa01f034fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae35b01e013bbfa64d9cdccfa01f034fe">get_fixed_step_mode</a> () const</td></tr>
<tr class="memdesc:ae35b01e013bbfa64d9cdccfa01f034fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether an integrator is running in fixed step mode.  <br /></td></tr>
<tr id="pub-methods-3" class="groupHeader"><td colspan="2"><div class="groupHeader">Methods for weighting state variable errors (in the context of error control)</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="weighting-state-errors"></a> This group of methods describes how errors for state variables with heterogeneous units are weighted in the context of error-controlled integration.</p>
<p>This is an advanced topic and most users can simply specify desired accuracy and accept the default state variable weights.</p>
<p>A collection of state variables is generally defined in heterogeneous units (e.g. length, angles, velocities, energy). Some of the state variables cannot even be expressed in meaningful units, like quaternions. Certain integrators provide an estimate of the absolute error made in each state variable during an integration step. These errors must be properly weighted to obtain an "accuracy" <em>with respect to each particular variable</em>. These per-variable accuracy determinations can be compared against the user's requirements and used to select an appropriate size for the next step [Sherman 2011]. The weights are normally determined automatically using the system's characteristic dimensions, so <em>most users can stop reading now!</em> Custom weighting is primarily useful for performance improvement; an optimal weighting would allow an error-controlled integrator to provide the desired level of accuracy across all state variables without wasting computation achieving superfluous accuracy for some of those variables.</p>
<p>Users interested in more precise control over state variable weighting may use the methods in this group to access and modify weighting factors for individual state variables. Changes to these weights can only be made prior to integrator initialization or as a result of an event being triggered and then followed by re-initialization.</p>
<p><em>Relative versus absolute accuracy</em>:</p>
<p>State variable integration error, as estimated by an integrator, is an absolute quantity with the same units as the variable. At each time step we therefore need to determine an absolute error that would be deemed "good enough", i.e. satisfies the user's accuracy requirement. If a variable is maintained to a <em>relative</em> accuracy then that "good enough" value is defined to be the required accuracy <span class="tt">a</span> (a fraction like 0.001) times the current value of the variable, as long as that value is far from zero. For variables maintained to an <em>absolute</em> accuracy, or relative variables that are at or near zero (where relative accuracy would be undefined or too strict, respectively), we need a different way to determine the "good enough" absolute error. The methods in this section control how that absolute error value is calculated.</p>
<p><em>How to choose weights</em>:</p>
<p>The weight <span class="tt">wᵢ</span> for a state variable <span class="tt">xᵢ</span> should be chosen so that the product <span class="tt">wᵢ * dxᵢ</span> is unitless, and in particular is 1 when <span class="tt">dxᵢ</span> represents a "unit effect" of state variable <span class="tt">xᵢ</span>; that is, the change in <span class="tt">xᵢ</span> that produces a unit change in some quantity of interest in the system being simulated. Why unity (1)? Aside from normalizing the values, unity "grounds" the weighted error to the user-specified accuracy. A weighting can be applied individually to each state variable, but typically it is done approximately by combining the known type of the variable (e.g. length, angle) with a "characteristic scale" for that quantity. For example, if a "characteristic length" for the system being simulated is 0.1 meters, and <span class="tt">x₀</span> is a length variable measured in meters, then <span class="tt">w₀</span> should be 10 so that <span class="tt">w₀*dx₀=1</span> when <span class="tt">dx₀=0.1</span>. For angles representing pointing accuracy (say a camera direction) we typically assume a "characteristic angle" is one radian (about 60 degrees), so if x₁ is a pointing direction then w₁=1 is an appropriate weight. We can now scale an error vector <span class="tt">e=[dx₀ dx₁]</span> to a unitless fractional error vector <span class="tt">f=[w₀*dx₀ w₁*dx₁]</span>. Now to achieve a given accuracy <span class="tt">a</span>, say <span class="tt">a=.0001</span>, we need only check that <span class="tt">|fᵢ|&lt;=a</span> for each element <span class="tt">i</span> of <span class="tt">f</span>. Further, this gives us a quantitative measure of "worst accuracy" that we can use to increase or reduce size of the next attempted step, so that we will just achieve the required accuracy but not much more. We'll be more precise about this below.</p>
<p><a class="anchor" id="quasi_coordinates"></a><em>Some subtleties for second-order dynamic systems</em>:</p>
<p>Systems governed by 2nd-order differential equations are typically split into second order (configuration) variables q, and rate (velocity) variables v, where the time derivatives qdot of q are linearly related to v by the kinematic differential equation <span class="tt">qdot = dq/dt = N(q)*v</span>. Velocity variables are chosen to be physically significant, but configuration variables may be chosen for convenience and do not necessarily have direct physical interpretation. For examples, quaternions are chosen as a numerically stable orientation representation. This is problematic for choosing weights which must be done by physical reasoning as sketched above. We resolve this by introducing the notion of "quasi-coordinates" ꝗ (pronounced "qbar") which are defined by the equation <span class="tt">ꝗdot = dꝗ/dt = v</span>. Other than time scaling, quasi-coordinates have the same units as their corresponding velocity variables. That is, for weighting we need to think of the configuration coordinates in the same physical space as the velocity variables; weight those by their physical significance; and then map back to an instantaneous weighting on the actual configuration variables q. This mapping is performed automatically; you need only to be concerned about physical weightings.</p>
<p>Note that generalized quasi-coordinates <span class="tt">ꝗ</span> can only be defined locally for a particular configuration <span class="tt">q</span>. There is in general no meaningful set of <span class="tt">n</span> generalized coordinates which can be differentiated with respect to time to yield <span class="tt">v</span>. For example, the Hairy Ball Theorem implies that it is not possible for three orientation variables to represent all 3D rotations without singularities, yet three velocity variables can represent angular velocity in 3D without singularities.</p>
<p>To summarize, separate weights can be provided for each of</p><ul>
<li><span class="tt">n</span> generalized quasi-coordinates <span class="tt">ꝗ</span> (configuration variables in the velocity variable space), and</li>
<li><span class="tt">nz</span> miscellaneous continuous state variables <span class="tt">z</span>.</li>
</ul>
<p>Weights on the generalized velocity variables <span class="tt">v (= dꝗ/dt)</span> are derived directly from the weights on <span class="tt">ꝗ</span>, weighted by a characteristic time. Weights on the actual <span class="tt">nq</span> generalized coordinates can be calculated efficiently from weights on the quasi-coordinates (details below).</p>
<p><em>How the weights are used</em>:</p>
<p>The errors in the <span class="tt">ꝗ</span> and <span class="tt">z</span> variables are weighted by the diagonal elements of diagonal weighting matrices Wꝗ and Wz, respectively. (The block-diagonal weighting matrix <span class="tt">Wq</span> on the original generalized coordinates <span class="tt">q</span> is calculated from <span class="tt">N</span> and <span class="tt">Wꝗ</span>; see below.) In the absence of other information, the default for all weighting values is one, so <span class="tt">Wꝗ</span> and <span class="tt">Wz</span> are <span class="tt">n × n</span> and <span class="tt">nz × nz</span> identity matrices. The weighting matrix <span class="tt">Wv</span> for the velocity variables is just <span class="tt">Wv = τ*Wꝗ</span> where <span class="tt">τ</span> is a "characteristic time" for the system, that is, a quantity in time units that represents a significant evolution of the trajectory. This serves to control the accuracy with which velocity is determined relative to configuration. Note that larger values of <span class="tt">τ</span> are more conservative since they increase the velocity weights. Typically we use <span class="tt">τ=1.0</span> or <span class="tt">0.1</span> seconds for human-scale mechanical systems.</p>
<p>The weighting matrices <span class="tt">Wq</span>, <span class="tt">Wv</span>, and <span class="tt">Wz</span> are used to compute a weighted infinity norm as follows. Although <span class="tt">Wv</span> and <span class="tt">Wz</span> are constant, the actual weightings may be state dependent for relative-error calculations. Define block diagonal error weighting matrix <span class="tt">E=diag(Eq,Ev,Ez)</span> as follows: </p><pre>
  Eq = Wq
  Ev: Ev(i,i) = { min(Wv(i,i), 1/|vᵢ|)     if vᵢ is relative
                { Wv(i,i)                  if vᵢ is absolute
  Ez: Ez(i,i) = { min(Wz(i,i), 1/|zᵢ|)     if zᵢ is relative
                { Wz(i,i)                  if zᵢ is absolute
</pre><p> (<span class="tt">Ev</span> and <span class="tt">Ez</span> are diagonal.) A <span class="tt">v</span> or <span class="tt">z</span> will be maintained to relative accuracy unless (a) it is "close" to zero (less than 1), or (b) the variable has been defined as requiring absolute accuracy. Position variables <span class="tt">q</span> are always maintained to absolute accuracy (see [Sherman 2011] for rationale).</p>
<p>Now given an error estimate vector <span class="tt">e=[eq ev ez]</span>, the vector <span class="tt">f=E*e</span> can be considered to provide a unitless fractional error for each of the state variables. To achieve a given user-specified accuracy <span class="tt">a</span>, we require that norm_inf(<span class="tt">f</span>) &lt;= <span class="tt">a</span>. That is, no element of <span class="tt">f</span> can have absolute value larger than <span class="tt">a</span>. We also use <span class="tt">f</span> to determine an ideal next step size using an appropriate integrator-specific computation.</p>
<p><em>Determining weights for q</em>:</p>
<p>The kinematic differential equations <span class="tt">qdot=N(q)*v</span> employ an <span class="tt">nq × n</span> matrix <span class="tt">N</span>. By construction, this relationship is invertible using <span class="tt">N</span>'s left pseudo-inverse <span class="tt">N⁺</span> so that <span class="tt">v=N⁺ qdot</span> and <span class="tt">N⁺ N = I</span> (the identity matrix); however, <span class="tt">N N⁺ != I</span>, as <span class="tt">N</span> has more rows than columns generally. [Nikravesh 1988] shows how such a matrix <span class="tt">N</span> can be determined and provides more information. Given this relationship between <span class="tt">N</span> and <span class="tt">N⁺</span>, we can relate weighted errors in configuration coordinates <span class="tt">q</span> to weighted errors in generalized quasi-coordinates <span class="tt">ꝗ</span>, as the following derivation shows: </p><pre>
           v = N⁺ qdot         Inverse kinematic differential equation
       dꝗ/dt = N⁺ dq/dt        Use synonyms for v and qdot
          dꝗ = N⁺ dq           Change time derivatives to differentials
       Wꝗ dꝗ = Wꝗ N⁺ dq        Pre-multiply both sides by Wꝗ
     N Wꝗ dꝗ = N Wꝗ N⁺ dq      Pre-multiply both sides by N
     N Wꝗ dꝗ = Wq dq           Define Wq := N Wꝗ N⁺
      N Wꝗ v = Wq qdot         Back to time derivatives.
</pre><p> The last two equations show that <span class="tt">Wq</span> as defined above provides the expected relationship between the weighted <span class="tt">ꝗ</span> or <span class="tt">v</span> variables in velocity space and the weighted <span class="tt">q</span> or <span class="tt">qdot</span> (resp.) variables in configuration space.</p>
<p>Finally, note that a diagonal entry of one of the weighting matrices can be set to zero to disable error estimation for that state variable (i.e., auxiliary variable or configuration/velocity variable pair), but that setting an entry to a negative value will cause an exception to be thrown when the integrator is initialized.</p>
<ul>
<li>[Nikravesh 1988] P. Nikravesh. Computer-Aided Analysis of Mechanical Systems. Prentice Hall, 1988. Sec. 6.3.</li>
<li>[Sherman 2011] M. Sherman, et al. Procedia IUTAM 2:241-261 (2011), Section 3.3. <a href="http://dx.doi.org/10.1016/j.piutam.2011.04.023">http://dx.doi.org/10.1016/j.piutam.2011.04.023</a></li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a251c75be3ec4f5b14aeaf5ca2467416f" title="Computes the infinity norm of a change in continuous state.">CalcStateChangeNorm()</a> </dd></dl>
</div></td></tr>
<tr class="memitem:ae80a14e4cb31118d49dd48613c24bcac" id="r_ae80a14e4cb31118d49dd48613c24bcac"><td class="memItemLeft" align="right" valign="top">const Eigen::VectorXd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae80a14e4cb31118d49dd48613c24bcac">get_generalized_state_weight_vector</a> () const</td></tr>
<tr class="memdesc:ae80a14e4cb31118d49dd48613c24bcac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the weighting vector (equivalent to a diagonal matrix) applied to weighting both generalized coordinate and velocity state variable errors, as described in the group documentation.  <br /></td></tr>
<tr class="memitem:ad4245130a64e9aa0bc0ca3d0e06c8d5f" id="r_ad4245130a64e9aa0bc0ca3d0e06c8d5f"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; Eigen::VectorXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4245130a64e9aa0bc0ca3d0e06c8d5f">get_mutable_generalized_state_weight_vector</a> ()</td></tr>
<tr class="memdesc:ad4245130a64e9aa0bc0ca3d0e06c8d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a mutable weighting vector (equivalent to a diagonal matrix) applied to weighting both generalized coordinate and velocity state variable errors, as described in the group documentation.  <br /></td></tr>
<tr class="memitem:aa66eac04db4502fc0bbb571b50f4490b" id="r_aa66eac04db4502fc0bbb571b50f4490b"><td class="memItemLeft" align="right" valign="top">const Eigen::VectorXd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa66eac04db4502fc0bbb571b50f4490b">get_misc_state_weight_vector</a> () const</td></tr>
<tr class="memdesc:aa66eac04db4502fc0bbb571b50f4490b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the weighting vector (equivalent to a diagonal matrix) for weighting errors in miscellaneous continuous state variables <span class="tt">z</span>.  <br /></td></tr>
<tr class="memitem:ae35c375f7ce5d26345168f4f24e9c347" id="r_ae35c375f7ce5d26345168f4f24e9c347"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; Eigen::VectorXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae35c375f7ce5d26345168f4f24e9c347">get_mutable_misc_state_weight_vector</a> ()</td></tr>
<tr class="memdesc:ae35c375f7ce5d26345168f4f24e9c347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a mutable weighting vector (equivalent to a diagonal matrix) for weighting errors in miscellaneous continuous state variables <span class="tt">z</span>.  <br /></td></tr>
<tr id="pub-methods-4" class="groupHeader"><td colspan="2"><div class="groupHeader">Methods related to initial step size</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="integrator-initial-step-size"></a> From [Watts 1983], "One of the more critical issues in solving ordinary
differential equations by a step-by-step process occurs in the starting
phase.

 Somehow the procedure must be supplied with an initial step size that
is on scale for the problem at hand. It must be small enough to yield a
reliable solution by the process, but it should not be so small as to
significantly affect the efficiency of solution. The more important of these
two possibilities is obviously the reliability question. The first step taken
by the code must reflect how fast the solution changes near the initial
point. For general purpose computing, an automatic step size adjustment
procedure for choosing subsequent steps is essential to produce an accurate
solution efficiently. This step size control is usually based on estimates of
the local errors incurred by the numerical method. Because most codes also
employ algorithmic devices which restrict the step size control to be
moderately varying (for reliability), subsequent steps usually tend to stay
on scale of the problem. This is not always so, as sometimes happens when
working with crude tolerances on problems having rapidly varying components.
Nevertheless, most step size adjustment procedures deal reasonably well with
all but the most abrupt changes, leaving the most serious danger confined to
the starting step size."</p>
<p>Users may not have a good idea of an initial step size to take, so integration codes usually attempt to automatically select an initial step size. Sophisticated algorithms for initial step size selection are described in [Hindmarsh 1980], [Watts 1983], [Gladwell 1987], and [Hairer 2008]. These algorithms can fail to produce a good initial step size as well (see discussion in [Watts 1983]). Drake's integrators use a fraction (generally 1/10th of the maximum step size) to set the initial step size. If you have a problem that operates at wildly varying time scales, e.g., Robertson's canonical stiff system problem (that requires a large maximum step size to be efficient), consider setting both the initial and maximum step sizes (i.e., not using the defaults) to keep from missing phenomena that occur over small time scales near the beginning of the time interval being integrated.</p>
<ul>
<li>[Gladwell 1987] I. Gladwell, L. F. Shampine, and R. W. Brankin. Automatic selection of the initial step size for an ODE solver. J. Comp. Appl. Math., Vol. 18, pp. 175-192, 1987.</li>
<li>[Hairer 2008] E. Hairer, S. P. Norsett, and G. Wanner. Solving Ordinary Differential Equations I (Nonstiff Problems), 2nd ed. Springer, 2008.</li>
<li>[Hindmarsh 1980] A. C. Hindmarsh. LSODE and LSODI, two new initial value ordinary differential equation solvers. ACM Signum Newletter 15, 4, 1980.</li>
<li>[Robertson 1966] H.H. Robertson. The solution of a set of reaction rate equations, pp. 178–182. Academic Press, 1966.</li>
<li>[Watts 1983] H. A. Watts. Starting stepsize for an ODE solver. J. Comp. Appl. Math., Vol. 8, pp. 177-191, 1983. </li>
</ul>
</div></td></tr>
<tr class="memitem:aaa818a52a133131208f51b1c0a3a906c" id="r_aaa818a52a133131208f51b1c0a3a906c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa818a52a133131208f51b1c0a3a906c">request_initial_step_size_target</a> (const T &amp;step_size)</td></tr>
<tr class="memdesc:aaa818a52a133131208f51b1c0a3a906c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request that the first attempted integration step have a particular size.  <br /></td></tr>
<tr class="memitem:a39de0d04194f2a315271e605b48c1b11" id="r_a39de0d04194f2a315271e605b48c1b11"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39de0d04194f2a315271e605b48c1b11">get_initial_step_size_target</a> () const</td></tr>
<tr class="memdesc:a39de0d04194f2a315271e605b48c1b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the target size of the first integration step.  <br /></td></tr>
<tr id="pub-methods-5" class="groupHeader"><td colspan="2"><div class="groupHeader">Methods related to maximum integration step size</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="integrator-maxstep"></a> Sets the <em>nominal</em> maximum step size- the actual maximum step size taken may be slightly larger (see <a class="el" href="#ae878ce4cdab7a01165423d8a902df452" title="Sets the maximum step size that may be taken by this integrator.">set_maximum_step_size()</a> and <a class="el" href="#ab693dd7dd1da02154fc0f0ff6ef20692" title="Gets the stretch factor (&gt; 1), which is multiplied by the maximum (typically user-designated) integra...">get_stretch_factor()</a>)- that an integrator will take. Each integrator has a default maximum step size, which might be infinite. </p>
</div></td></tr>
<tr class="memitem:ae878ce4cdab7a01165423d8a902df452" id="r_ae878ce4cdab7a01165423d8a902df452"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae878ce4cdab7a01165423d8a902df452">set_maximum_step_size</a> (const T &amp;max_step_size)</td></tr>
<tr class="memdesc:ae878ce4cdab7a01165423d8a902df452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum step size that may be taken by this integrator.  <br /></td></tr>
<tr class="memitem:af96a8bb1db3721dc63beb85fe4cb1457" id="r_af96a8bb1db3721dc63beb85fe4cb1457"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af96a8bb1db3721dc63beb85fe4cb1457">get_maximum_step_size</a> () const</td></tr>
<tr class="memdesc:af96a8bb1db3721dc63beb85fe4cb1457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum step size that may be taken by this integrator.  <br /></td></tr>
<tr class="memitem:ab693dd7dd1da02154fc0f0ff6ef20692" id="r_ab693dd7dd1da02154fc0f0ff6ef20692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab693dd7dd1da02154fc0f0ff6ef20692">get_stretch_factor</a> () const</td></tr>
<tr class="memdesc:ab693dd7dd1da02154fc0f0ff6ef20692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the stretch factor (&gt; 1), which is multiplied by the maximum (typically user-designated) integration step size to obtain the amount that the integrator is able to stretch the maximum time step toward hitting an upcoming publish or update event in <a class="el" href="#a02875acba81c8be7dd0c7a2ae89db212" title="(Internal use only) Integrates the system forward in time by a single step with step size subject to ...">IntegrateNoFurtherThanTime()</a>.  <br /></td></tr>
<tr id="pub-methods-6" class="groupHeader"><td colspan="2"><div class="groupHeader">Methods related to minimum integration step size selection and behavior</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="integrator-minstep"></a> Variable step integrators reduce their step sizes as needed to achieve requirements such as specified accuracy or step convergence. However, it is not possible to take an arbitrarily small step. Normally integrators choose an appropriate minimum step and throw an exception if the requirements can't be achieved without going below that. Methods in this section allow you to influence two aspects of this procedure:</p>
<ul>
<li>you can increase the minimum step size, and</li>
<li>you can control whether an exception is thrown if a smaller step would have been needed to achieve the aforementioned integrator requirements.</li>
</ul>
<p>By default, integrators allow a very small minimum step which can result in long run times. Setting a larger minimum can be helpful as a diagnostic to figure out what aspect of your simulation is requiring small steps. You can set the minimum to what should be a "reasonable" minimum based on what you know about the physical system. You will then get an std::runtime_error exception thrown at any point in time where your model behaves unexpectedly (due to, e.g., a discontinuity in the derivative evaluation function).</p>
<p>If you disable the exception (via <span class="tt">set_throw_on_minimum_step_size_violation(false)</span>), the integrator will simply proceed with a step of the minimum size: accuracy is guaranteed only when the minimum step size is not violated. Beware that there can be no guarantee about the magnitude of any errors introduced by violating the accuracy "requirements" in this manner, so disabling the exception should be done warily.</p>
<h4>Details</h4>
<p>Because time is maintained to finite precision, the integrator uses a scalar <span class="tt">h_floor</span> to constrain time step h ≥ <span class="tt">h_floor</span> such that <span class="tt">current_time + h &gt;
current_time</span> will be strictly satisfied. The integrator will never automatically decrease its step below <span class="tt">h_floor</span>. We calculate <span class="tt">h_floor=max(ε,
ε⋅abs(t))</span>, where t is the current time and ε is a small multiple of machine precision, typically a number like 1e-14. Note that <span class="tt">h_floor</span> necessarily grows with time; if that is a concern you should limit how long your simulations are allowed to run without resetting time.</p>
<p>You may request a larger minimum step size <span class="tt">h_min</span>. Then at every time t, the integrator determines a "working" minimum <span class="tt">h_work=max(h_min, h_floor)</span>. If the step size selection algorithm determines that a step smaller than <span class="tt">h_work</span> is needed to meet accuracy or other needs, then a std::runtime_error exception will be thrown and the simulation halted. On the other hand, if you have suppressed the exception (again, via <span class="tt">set_throw_on_minimum_step_size_violation(false)</span>), the integration will continue, taking a step of size <span class="tt">h_work</span>.</p>
<p>Under some circumstances the integrator may legitimately take a step of size <span class="tt">h</span> smaller than your specified <span class="tt">h_min</span>, although never smaller than <span class="tt">h_floor</span>. For example, occasionally the integrator may reach an event or time limit that occurs a very short time after the end of a previous step, necessitating that a tiny "sliver" of a step be taken to complete the interval. That does not indicate an error, and required accuracy and convergence goals are achieved. Larger steps can resume immediately afterwards. Another circumstance is when one of the integrator's stepping methods is called directly requesting a very small step, for example <span class="tt">IntegrateWithMultipleStepsToTime(h)</span>. No exception will be thrown in either of these cases. </p>
</div></td></tr>
<tr class="memitem:a0f186af10e0fc1fc8f32fafa4fed7ba7" id="r_a0f186af10e0fc1fc8f32fafa4fed7ba7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f186af10e0fc1fc8f32fafa4fed7ba7">set_requested_minimum_step_size</a> (const T &amp;min_step_size)</td></tr>
<tr class="memdesc:a0f186af10e0fc1fc8f32fafa4fed7ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the requested minimum step size <span class="tt">h_min</span> that may be taken by this integrator.  <br /></td></tr>
<tr class="memitem:af3e06e95adf0fad713e3e4b2ba18eccc" id="r_af3e06e95adf0fad713e3e4b2ba18eccc"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3e06e95adf0fad713e3e4b2ba18eccc">get_requested_minimum_step_size</a> () const</td></tr>
<tr class="memdesc:af3e06e95adf0fad713e3e4b2ba18eccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the requested minimum step size <span class="tt">h_min</span> for this integrator.  <br /></td></tr>
<tr class="memitem:a78773e63a07381351e18380040f5fc13" id="r_a78773e63a07381351e18380040f5fc13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78773e63a07381351e18380040f5fc13">set_throw_on_minimum_step_size_violation</a> (bool throws)</td></tr>
<tr class="memdesc:a78773e63a07381351e18380040f5fc13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the integrator should throw a std::exception when the integrator's step size selection algorithm determines that it must take a step smaller than the minimum step size (for, e.g., purposes of error control).  <br /></td></tr>
<tr class="memitem:a5b89a6384ec3f94a33c8fd2f4c384369" id="r_a5b89a6384ec3f94a33c8fd2f4c384369"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b89a6384ec3f94a33c8fd2f4c384369">get_throw_on_minimum_step_size_violation</a> () const</td></tr>
<tr class="memdesc:a5b89a6384ec3f94a33c8fd2f4c384369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the current setting of the throw_on_minimum_step_size_violation flag.  <br /></td></tr>
<tr class="memitem:a47399e48a6a661ce1b8252d86a305b54" id="r_a47399e48a6a661ce1b8252d86a305b54"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47399e48a6a661ce1b8252d86a305b54">get_working_minimum_step_size</a> () const</td></tr>
<tr class="memdesc:a47399e48a6a661ce1b8252d86a305b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current value of the working minimum step size <span class="tt">h_work(t)</span> for this integrator, which may vary with the current time t as stored in the integrator's context.  <br /></td></tr>
<tr class="memitem:a372de693ad40b3f42839c8ec6ac845f4" id="r_a372de693ad40b3f42839c8ec6ac845f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a372de693ad40b3f42839c8ec6ac845f4">Reset</a> ()</td></tr>
<tr class="memdesc:a372de693ad40b3f42839c8ec6ac845f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the integrator to initial values, i.e., default construction values.  <br /></td></tr>
<tr class="memitem:a98b1050f09da390896f964fb7a892391" id="r_a98b1050f09da390896f964fb7a892391"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98b1050f09da390896f964fb7a892391">Initialize</a> ()</td></tr>
<tr class="memdesc:a98b1050f09da390896f964fb7a892391"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integrator must be initialized before being used.  <br /></td></tr>
<tr class="memitem:a02875acba81c8be7dd0c7a2ae89db212" id="r_a02875acba81c8be7dd0c7a2ae89db212"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a95ae527571e3f25c4415b93d12cb0ad9">StepResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02875acba81c8be7dd0c7a2ae89db212">IntegrateNoFurtherThanTime</a> (const T &amp;publish_time, const T &amp;update_time, const T &amp;boundary_time)</td></tr>
<tr class="memdesc:a02875acba81c8be7dd0c7a2ae89db212"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Integrates the system forward in time by a single step with step size subject to integration error tolerances (assuming that the integrator supports error estimation).  <br /></td></tr>
<tr class="memitem:acb2ebec0fff763d592464afb49bffe13" id="r_acb2ebec0fff763d592464afb49bffe13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb2ebec0fff763d592464afb49bffe13">IntegrateWithMultipleStepsToTime</a> (const T &amp;t_final)</td></tr>
<tr class="memdesc:acb2ebec0fff763d592464afb49bffe13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stepping function for integrators operating outside of <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> that advances the continuous state exactly to <span class="tt">t_final</span>.  <br /></td></tr>
<tr class="memitem:a33ee182a7a34894a888a3bcd3dfd5674" id="r_a33ee182a7a34894a888a3bcd3dfd5674"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33ee182a7a34894a888a3bcd3dfd5674">IntegrateWithSingleFixedStepToTime</a> (const T &amp;t_target)</td></tr>
<tr class="memdesc:a33ee182a7a34894a888a3bcd3dfd5674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stepping function for integrators operating outside of <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> that advances the continuous state <em>using a single step</em> to <span class="tt">t_target</span>.  <br /></td></tr>
<tr id="pub-methods-7" class="groupHeader"><td colspan="2"><div class="groupHeader">Integrator statistics methods</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>These methods allow the caller to manipulate and query integrator statistics.</p>
<p>Generally speaking, the larger the integration step taken, the faster a simulation will run. These methods allow querying (and resetting) the integrator statistics as one means of determining how to make a simulation run faster. </p>
</div></td></tr>
<tr class="memitem:a64a01ac56f8a0086cc6ed335ee9e5caa" id="r_a64a01ac56f8a0086cc6ed335ee9e5caa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64a01ac56f8a0086cc6ed335ee9e5caa">ResetStatistics</a> ()</td></tr>
<tr class="memdesc:a64a01ac56f8a0086cc6ed335ee9e5caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forget accumulated statistics.  <br /></td></tr>
<tr class="memitem:afa1597c69b7f633624a3693142ad3f04" id="r_afa1597c69b7f633624a3693142ad3f04"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa1597c69b7f633624a3693142ad3f04">get_num_substep_failures</a> () const</td></tr>
<tr class="memdesc:afa1597c69b7f633624a3693142ad3f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of failed sub-steps (implying one or more step size reductions was required to permit solving the necessary nonlinear system of equations).  <br /></td></tr>
<tr class="memitem:a64333e8ed51bb6a29af25c2c4da153aa" id="r_a64333e8ed51bb6a29af25c2c4da153aa"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64333e8ed51bb6a29af25c2c4da153aa">get_num_step_shrinkages_from_substep_failures</a> () const</td></tr>
<tr class="memdesc:a64333e8ed51bb6a29af25c2c4da153aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of step size shrinkages due to sub-step failures (e.g., integrator convergence failures) since the last call to <a class="el" href="#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics.">ResetStatistics()</a> or <a class="el" href="#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used.">Initialize()</a>.  <br /></td></tr>
<tr class="memitem:a2b588edb71f956edad8a88d5c8b86479" id="r_a2b588edb71f956edad8a88d5c8b86479"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b588edb71f956edad8a88d5c8b86479">get_num_step_shrinkages_from_error_control</a> () const</td></tr>
<tr class="memdesc:a2b588edb71f956edad8a88d5c8b86479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of step size shrinkages due to failure to meet targeted error tolerances, since the last call to ResetStatistics or <a class="el" href="#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used.">Initialize()</a>.  <br /></td></tr>
<tr class="memitem:ac3152b858f89491817273d05fa518289" id="r_ac3152b858f89491817273d05fa518289"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3152b858f89491817273d05fa518289">get_num_derivative_evaluations</a> () const</td></tr>
<tr class="memdesc:ac3152b858f89491817273d05fa518289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of ODE function evaluations (calls to CalcTimeDerivatives()) since the last call to <a class="el" href="#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics.">ResetStatistics()</a> or <a class="el" href="#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used.">Initialize()</a>.  <br /></td></tr>
<tr class="memitem:a1f18a0e9534aa1fdc80621deab88c45f" id="r_a1f18a0e9534aa1fdc80621deab88c45f"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f18a0e9534aa1fdc80621deab88c45f">get_actual_initial_step_size_taken</a> () const</td></tr>
<tr class="memdesc:a1f18a0e9534aa1fdc80621deab88c45f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual size of the successful first step.  <br /></td></tr>
<tr class="memitem:a84a2a25041ff2c07dc27911a93de7a2e" id="r_a84a2a25041ff2c07dc27911a93de7a2e"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84a2a25041ff2c07dc27911a93de7a2e">get_smallest_adapted_step_size_taken</a> () const</td></tr>
<tr class="memdesc:a84a2a25041ff2c07dc27911a93de7a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the smallest step taken <em>as the result of a controlled integration step adjustment</em> since the last <a class="el" href="#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used.">Initialize()</a> or <a class="el" href="#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics.">ResetStatistics()</a> call.  <br /></td></tr>
<tr class="memitem:abec4f2df9432897c463e101646f37b76" id="r_abec4f2df9432897c463e101646f37b76"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abec4f2df9432897c463e101646f37b76">get_largest_step_size_taken</a> () const</td></tr>
<tr class="memdesc:abec4f2df9432897c463e101646f37b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the largest step taken since the last <a class="el" href="#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used.">Initialize()</a> or <a class="el" href="#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics.">ResetStatistics()</a> call.  <br /></td></tr>
<tr class="memitem:a215741958afe19af17a62470f883878b" id="r_a215741958afe19af17a62470f883878b"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a215741958afe19af17a62470f883878b">get_num_steps_taken</a> () const</td></tr>
<tr class="memdesc:a215741958afe19af17a62470f883878b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of integration steps taken since the last <a class="el" href="#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used.">Initialize()</a> or <a class="el" href="#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics.">ResetStatistics()</a> call.  <br /></td></tr>
<tr class="memitem:a644f18faa19a24bd106100bd575e1934" id="r_a644f18faa19a24bd106100bd575e1934"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a644f18faa19a24bd106100bd575e1934">add_derivative_evaluations</a> (<a class="el" href="classdouble.html">double</a> evals)</td></tr>
<tr class="memdesc:a644f18faa19a24bd106100bd575e1934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manually increments the statistic for the number of ODE evaluations.  <br /></td></tr>
<tr class="memitem:a5febad6c2edc61891575e64fed4fdb83" id="r_a5febad6c2edc61891575e64fed4fdb83"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5febad6c2edc61891575e64fed4fdb83">get_context</a> () const</td></tr>
<tr class="memdesc:a5febad6c2edc61891575e64fed4fdb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the internally-maintained <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> holding the most recent state in the trajectory.  <br /></td></tr>
<tr class="memitem:a289399d8ca051bafdd906b50aa544218" id="r_a289399d8ca051bafdd906b50aa544218"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a289399d8ca051bafdd906b50aa544218">get_mutable_context</a> ()</td></tr>
<tr class="memdesc:a289399d8ca051bafdd906b50aa544218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable pointer to the internally-maintained <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> holding the most recent state in the trajectory.  <br /></td></tr>
<tr class="memitem:ae9ec42d998ad39014c3dc64c50cfbc4d" id="r_ae9ec42d998ad39014c3dc64c50cfbc4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9ec42d998ad39014c3dc64c50cfbc4d">reset_context</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context)</td></tr>
<tr class="memdesc:ae9ec42d998ad39014c3dc64c50cfbc4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the pointer to the internally-maintained <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> with a different one.  <br /></td></tr>
<tr class="memitem:a2edc40e3430189fa7dd54ab20268e020" id="r_a2edc40e3430189fa7dd54ab20268e020"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2edc40e3430189fa7dd54ab20268e020">reset_context</a> (std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &gt; context)</td></tr>
<tr class="memdesc:a2edc40e3430189fa7dd54ab20268e020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but allows the integrator to take ownership of the context.  <br /></td></tr>
<tr id="pub-methods-8" class="groupHeader"><td colspan="2"><div class="groupHeader">Methods for dense output computation</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="dense_output_computation"></a> In general, dense output computations entail both CPU load and memory footprint increases during numerical integration. For some applications, the performance penalty may be prohibitive. As such, these computations are only carried out by explicit user request. The API to start and stop a <em>dense integration</em> process (i.e. a numerical integration process that also computes dense output) is consistent with this design choice.</p>
<p>Once dense integration is started, and until it is stopped, all subsequent integration steps taken will update the allocated dense output. </p>
</div></td></tr>
<tr class="memitem:a0cdd4796b7f98a09da058b9764f13b86" id="r_a0cdd4796b7f98a09da058b9764f13b86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cdd4796b7f98a09da058b9764f13b86">StartDenseIntegration</a> ()</td></tr>
<tr class="memdesc:a0cdd4796b7f98a09da058b9764f13b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts dense integration, allocating a new dense output for this integrator to use.  <br /></td></tr>
<tr class="memitem:a1c2f896b4ffe9a23da8ad4b12c8dc746" id="r_a1c2f896b4ffe9a23da8ad4b12c8dc746"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">trajectories::PiecewisePolynomial</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c2f896b4ffe9a23da8ad4b12c8dc746">get_dense_output</a> () const</td></tr>
<tr class="memdesc:a1c2f896b4ffe9a23da8ad4b12c8dc746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const pointer to the integrator's current PiecewisePolynomial instance, holding a representation of the continuous state trajectory since the last <a class="el" href="#a0cdd4796b7f98a09da058b9764f13b86" title="Starts dense integration, allocating a new dense output for this integrator to use.">StartDenseIntegration()</a> call.  <br /></td></tr>
<tr class="memitem:aec1b43d020ade4db105e454ec595c21e" id="r_aec1b43d020ade4db105e454ec595c21e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">trajectories::PiecewisePolynomial</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec1b43d020ade4db105e454ec595c21e">StopDenseIntegration</a> ()</td></tr>
<tr class="memdesc:aec1b43d020ade4db105e454ec595c21e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops dense integration, yielding ownership of the current dense output to the caller.  <br /></td></tr>
<tr class="memitem:ab6175b31bc7d4a8e02470e716aa92a2e" id="r_ab6175b31bc7d4a8e02470e716aa92a2e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6175b31bc7d4a8e02470e716aa92a2e">get_system</a> () const</td></tr>
<tr class="memdesc:ab6175b31bc7d4a8e02470e716aa92a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a constant reference to the system that is being integrated (and was provided to the constructor of the integrator).  <br /></td></tr>
<tr class="memitem:a7a2108348656c73efe1d72702c96d5c5" id="r_a7a2108348656c73efe1d72702c96d5c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a2108348656c73efe1d72702c96d5c5">is_initialized</a> () const</td></tr>
<tr class="memdesc:a7a2108348656c73efe1d72702c96d5c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the integrator has been initialized.  <br /></td></tr>
<tr class="memitem:ae1e39e721e714a393b1669513eb36fb3" id="r_ae1e39e721e714a393b1669513eb36fb3"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1e39e721e714a393b1669513eb36fb3">get_previous_integration_step_size</a> () const</td></tr>
<tr class="memdesc:ae1e39e721e714a393b1669513eb36fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the last (previous) integration step.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Methods for cloning</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="cloning"></a> This function makes a copy of an integrator. </p>
</td></tr>
<tr class="memitem:aea26ed3984a0356a5ad9a2b259ec473b" id="r_aea26ed3984a0356a5ad9a2b259ec473b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="#a3ecc7a468ab5fc69c4dd0beefd4aab08">IntegratorBase</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea26ed3984a0356a5ad9a2b259ec473b">Clone</a> () const</td></tr>
<tr class="memdesc:aea26ed3984a0356a5ad9a2b259ec473b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of this integrator with reset statistics, reinitialized internal integrator states, and a cloned system context.  <br /></td></tr>
<tr class="memitem:ac5f5259be2ac9352879b53f559cbd567" id="r_ac5f5259be2ac9352879b53f559cbd567"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5f5259be2ac9352879b53f559cbd567">DoResetStatistics</a> ()</td></tr>
<tr class="memdesc:ac5f5259be2ac9352879b53f559cbd567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets any statistics particular to a specific integrator.  <br /></td></tr>
<tr class="memitem:a292084d64056c43eeb8af93dbc9a5ce9" id="r_a292084d64056c43eeb8af93dbc9a5ce9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a292084d64056c43eeb8af93dbc9a5ce9">EvalTimeDerivatives</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context)</td></tr>
<tr class="memdesc:a292084d64056c43eeb8af93dbc9a5ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the derivative function and updates call statistics.  <br /></td></tr>
<tr class="memitem:aaa3101a0f9d8116dc8d07e0a73c51aef" id="r_aaa3101a0f9d8116dc8d07e0a73c51aef"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:aaa3101a0f9d8116dc8d07e0a73c51aef template"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; U &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa3101a0f9d8116dc8d07e0a73c51aef">EvalTimeDerivatives</a> (const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; U &gt; &amp;system, const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; U &gt; &amp;context)</td></tr>
<tr class="memdesc:aaa3101a0f9d8116dc8d07e0a73c51aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the derivative function (and updates call statistics).  <br /></td></tr>
<tr class="memitem:a5296d2467ea109300a687233eb159a46" id="r_a5296d2467ea109300a687233eb159a46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5296d2467ea109300a687233eb159a46">set_accuracy_in_use</a> (<a class="el" href="classdouble.html">double</a> accuracy)</td></tr>
<tr class="memdesc:a5296d2467ea109300a687233eb159a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the working ("in use") accuracy for this integrator.  <br /></td></tr>
<tr class="memitem:a818099c976f6b62d04c9c5d525556a9d" id="r_a818099c976f6b62d04c9c5d525556a9d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a818099c976f6b62d04c9c5d525556a9d">StepOnceErrorControlledAtMost</a> (const T &amp;h_max)</td></tr>
<tr class="memdesc:a818099c976f6b62d04c9c5d525556a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default code for advancing the continuous state of the system by a single step of <code class="param">h_max</code> (or smaller, depending on error control).  <br /></td></tr>
<tr class="memitem:a251c75be3ec4f5b14aeaf5ca2467416f" id="r_a251c75be3ec4f5b14aeaf5ca2467416f"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a251c75be3ec4f5b14aeaf5ca2467416f">CalcStateChangeNorm</a> (const <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &amp;dx_state) const</td></tr>
<tr class="memdesc:a251c75be3ec4f5b14aeaf5ca2467416f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the infinity norm of a change in continuous state.  <br /></td></tr>
<tr class="memitem:a673eb33420503190006ca91d01ec779e" id="r_a673eb33420503190006ca91d01ec779e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a673eb33420503190006ca91d01ec779e">CalcAdjustedStepSize</a> (const T &amp;err, const T &amp;attempted_step_size, bool *at_minimum_step_size) const</td></tr>
<tr class="memdesc:a673eb33420503190006ca91d01ec779e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates adjusted integrator step sizes toward keeping state variables within error bounds on the next integration step.  <br /></td></tr>
<tr class="memitem:ae1949ad54a9dc1dc95f632a066aa12e6" id="r_ae1949ad54a9dc1dc95f632a066aa12e6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1949ad54a9dc1dc95f632a066aa12e6">DoInitialize</a> ()</td></tr>
<tr class="memdesc:ae1949ad54a9dc1dc95f632a066aa12e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes can override this method to perform special initialization.  <br /></td></tr>
<tr class="memitem:a22d9215849b8b5dfbdfce1cf00ce3221" id="r_a22d9215849b8b5dfbdfce1cf00ce3221"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22d9215849b8b5dfbdfce1cf00ce3221">DoReset</a> ()</td></tr>
<tr class="memdesc:a22d9215849b8b5dfbdfce1cf00ce3221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes can override this method to perform routines when <a class="el" href="#a372de693ad40b3f42839c8ec6ac845f4" title="Resets the integrator to initial values, i.e., default construction values.">Reset()</a> is called.  <br /></td></tr>
<tr class="memitem:a0b75f57a458608cb5c351bcfb239fbd5" id="r_a0b75f57a458608cb5c351bcfb239fbd5"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="#a3ecc7a468ab5fc69c4dd0beefd4aab08">IntegratorBase</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b75f57a458608cb5c351bcfb239fbd5">DoClone</a> () const</td></tr>
<tr class="memdesc:a0b75f57a458608cb5c351bcfb239fbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes must implement this method to return a copy of themselves as an <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html" title="An abstract class for an integrator for ODEs and DAEs as represented by a Drake System.">IntegratorBase</a> instance.  <br /></td></tr>
<tr class="memitem:ad4f1973bf8ef0a22d007b13b71a54f40" id="r_ad4f1973bf8ef0a22d007b13b71a54f40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">trajectories::PiecewisePolynomial</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4f1973bf8ef0a22d007b13b71a54f40">get_mutable_dense_output</a> ()</td></tr>
<tr class="memdesc:ad4f1973bf8ef0a22d007b13b71a54f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable pointer to the internally-maintained PiecewisePolynomial instance, holding a representation of the continuous state trajectory since the last time <a class="el" href="#a0cdd4796b7f98a09da058b9764f13b86" title="Starts dense integration, allocating a new dense output for this integrator to use.">StartDenseIntegration()</a> was called.  <br /></td></tr>
<tr class="memitem:a896ef63038c6eb979ed9b5e3fbc4a16f" id="r_a896ef63038c6eb979ed9b5e3fbc4a16f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a896ef63038c6eb979ed9b5e3fbc4a16f">DoStep</a> (const T &amp;h)=0</td></tr>
<tr class="memdesc:a896ef63038c6eb979ed9b5e3fbc4a16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes must implement this method to (1) integrate the continuous portion of this system forward by a single step of size <code class="param">h</code> and (2) set the error estimate (via <a class="el" href="#a237cfe4eca20cecf6227dfe0ccc0dab3" title="Gets an error estimate of the state variables recorded by the last call to StepOnceFixedSize().">get_mutable_error_estimate()</a>).  <br /></td></tr>
<tr class="memitem:ad197f82788b0f33f15e71ec5a261be99" id="r_ad197f82788b0f33f15e71ec5a261be99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad197f82788b0f33f15e71ec5a261be99">DoDenseStep</a> (const T &amp;h)</td></tr>
<tr class="memdesc:ad197f82788b0f33f15e71ec5a261be99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls DoStep(h) while recording the resulting step in the dense output.  <br /></td></tr>
<tr class="memitem:a237cfe4eca20cecf6227dfe0ccc0dab3" id="r_a237cfe4eca20cecf6227dfe0ccc0dab3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a237cfe4eca20cecf6227dfe0ccc0dab3">get_mutable_error_estimate</a> ()</td></tr>
<tr class="memdesc:a237cfe4eca20cecf6227dfe0ccc0dab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an error estimate of the state variables recorded by the last call to StepOnceFixedSize().  <br /></td></tr>
<tr class="memitem:afa5f6af023ede03e36fd44a079f7440d" id="r_afa5f6af023ede03e36fd44a079f7440d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa5f6af023ede03e36fd44a079f7440d">set_actual_initial_step_size_taken</a> (const T &amp;h)</td></tr>
<tr class="memitem:a2cd5795eec65555263f9b804260b6dcd" id="r_a2cd5795eec65555263f9b804260b6dcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cd5795eec65555263f9b804260b6dcd">set_smallest_adapted_step_size_taken</a> (const T &amp;h)</td></tr>
<tr class="memdesc:a2cd5795eec65555263f9b804260b6dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the smallest-step-taken statistic as the result of a controlled integration step adjustment.  <br /></td></tr>
<tr class="memitem:ab0fd2440d87169f64766fee57612d577" id="r_ab0fd2440d87169f64766fee57612d577"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0fd2440d87169f64766fee57612d577">set_largest_step_size_taken</a> (const T &amp;h)</td></tr>
<tr class="memitem:ac04da433607f913e10ee9d485d675fb1" id="r_ac04da433607f913e10ee9d485d675fb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac04da433607f913e10ee9d485d675fb1">set_ideal_next_step_size</a> (const T &amp;h)</td></tr>
</table>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Member Enumeration Documentation</h2>
<a id="a95ae527571e3f25c4415b93d12cb0ad9" name="a95ae527571e3f25c4415b93d12cb0ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ae527571e3f25c4415b93d12cb0ad9">&#9670;&#160;</a></span>StepResult</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a95ae527571e3f25c4415b93d12cb0ad9">StepResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Status returned by <a class="el" href="#a02875acba81c8be7dd0c7a2ae89db212" title="(Internal use only) Integrates the system forward in time by a single step with step size subject to ...">IntegrateNoFurtherThanTime()</a>. </p>
<p>When a step is successful, it will return an indication of what caused it to stop where it did. When unsuccessful it will throw an exception so you won't see any return value. When return of control is due ONLY to reaching a publish time, (status is kReachedPublishTime) the context may return an interpolated value at an earlier time.</p>
<dl class="section note"><dt>Note</dt><dd>the simulation step must always end at an update time but can end after a publish time. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a95ae527571e3f25c4415b93d12cb0ad9a1eb5c205e3572ba9946f3c86f093c845" name="a95ae527571e3f25c4415b93d12cb0ad9a1eb5c205e3572ba9946f3c86f093c845"></a>kReachedPublishTime&#160;</td><td class="fielddoc"><p>Indicates a publish time has been reached but not an update time. </p>
</td></tr>
<tr><td class="fieldname"><a id="a95ae527571e3f25c4415b93d12cb0ad9a1d1f7136371fa0489571cddeb08084e8" name="a95ae527571e3f25c4415b93d12cb0ad9a1d1f7136371fa0489571cddeb08084e8"></a>kReachedZeroCrossing&#160;</td><td class="fielddoc"><p>Localized an event; this is the <em>before</em> state (interpolated). </p>
</td></tr>
<tr><td class="fieldname"><a id="a95ae527571e3f25c4415b93d12cb0ad9a804060ac669eb47e5d384d3800e59d9c" name="a95ae527571e3f25c4415b93d12cb0ad9a804060ac669eb47e5d384d3800e59d9c"></a>kReachedUpdateTime&#160;</td><td class="fielddoc"><p>Indicates that integration terminated at an update time. </p>
</td></tr>
<tr><td class="fieldname"><a id="a95ae527571e3f25c4415b93d12cb0ad9a8d552f806d347dcd4031fbce86195737" name="a95ae527571e3f25c4415b93d12cb0ad9a8d552f806d347dcd4031fbce86195737"></a>kTimeHasAdvanced&#160;</td><td class="fielddoc"><p>User requested control whenever an internal step is successful. </p>
</td></tr>
<tr><td class="fieldname"><a id="a95ae527571e3f25c4415b93d12cb0ad9ab50d451e0bcc5385a4bdfd6b3bf5482c" name="a95ae527571e3f25c4415b93d12cb0ad9ab50d451e0bcc5385a4bdfd6b3bf5482c"></a>kReachedBoundaryTime&#160;</td><td class="fielddoc"><p>Reached the desired integration time without reaching an update time. </p>
</td></tr>
<tr><td class="fieldname"><a id="a95ae527571e3f25c4415b93d12cb0ad9a7ea4dacf674c208f87e90fa976d0829f" name="a95ae527571e3f25c4415b93d12cb0ad9a7ea4dacf674c208f87e90fa976d0829f"></a>kReachedStepLimit&#160;</td><td class="fielddoc"><p>Took maximum number of steps without finishing integrating over the interval. </p>
</td></tr>
</table>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3ecc7a468ab5fc69c4dd0beefd4aab08" name="a3ecc7a468ab5fc69c4dd0beefd4aab08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ecc7a468ab5fc69c4dd0beefd4aab08">&#9670;&#160;</a></span>IntegratorBase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegratorBase </td>
          <td>(</td>
          <td class="paramtype">const IntegratorBase&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0d908b973947061eaa9041e6a2b1442" name="aa0d908b973947061eaa9041e6a2b1442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d908b973947061eaa9041e6a2b1442">&#9670;&#160;</a></span>IntegratorBase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegratorBase </td>
          <td>(</td>
          <td class="paramtype">IntegratorBase&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a447030379c5091a36af0c158a0945c6e" name="a447030379c5091a36af0c158a0945c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447030379c5091a36af0c158a0945c6e">&#9670;&#160;</a></span>IntegratorBase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegratorBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>system</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maintains references to the system being integrated and the context used to specify the initial conditions for that system (if any). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">system</td><td>A reference to the system to be integrated; the integrator will maintain a reference to the system in perpetuity, so the integrator must not outlive the system. </td></tr>
    <tr><td class="paramname">context</td><td>A pointer to a writeable context (nullptr is ok, but a non-null pointer must be set before <a class="el" href="#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used.">Initialize()</a> is called). The integrator will advance the system state using the pointer to this context. The pointer to the context will be maintained internally. The integrator must not outlive the context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94d8cc81230c7f1f3d751bfd14b01cdc" name="a94d8cc81230c7f1f3d751bfd14b01cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d8cc81230c7f1f3d751bfd14b01cdc">&#9670;&#160;</a></span>~IntegratorBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="#a3ecc7a468ab5fc69c4dd0beefd4aab08">IntegratorBase</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a644f18faa19a24bd106100bd575e1934" name="a644f18faa19a24bd106100bd575e1934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644f18faa19a24bd106100bd575e1934">&#9670;&#160;</a></span>add_derivative_evaluations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void add_derivative_evaluations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>evals</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manually increments the statistic for the number of ODE evaluations. </p>
<dl class="section warning"><dt>Warning</dt><dd>Implementations should generally avoid calling this method; evaluating the ODEs using <a class="el" href="#a292084d64056c43eeb8af93dbc9a5ce9" title="Evaluates the derivative function and updates call statistics.">EvalTimeDerivatives()</a> updates this statistic automatically and intelligently (by leveraging the caching system to avoid incrementing the count when cached evaluations are used). </dd></dl>

</div>
</div>
<a id="a673eb33420503190006ca91d01ec779e" name="a673eb33420503190006ca91d01ec779e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673eb33420503190006ca91d01ec779e">&#9670;&#160;</a></span>CalcAdjustedStepSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bool, T &gt; CalcAdjustedStepSize </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>err</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>attempted_step_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>at_minimum_step_size</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates adjusted integrator step sizes toward keeping state variables within error bounds on the next integration step. </p>
<p>Note that it is not guaranteed that the (possibly) reduced step size will keep state variables within error bounds; however, the process of (1) taking a trial integration step, (2) calculating the error, and (3) adjusting the step size can be repeated until convergence. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">err</td><td>The norm of the integrator error that was computed using <code class="param">attempted_step_size</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">attempted_step_size</td><td>The step size that was attempted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">at_minimum_step_size</td><td>If <span class="tt">true</span> on entry, the error control mechanism is not allowed to shrink the step because the integrator is stepping at the minimum step size (note that this condition will only occur if <span class="tt"><a class="el" href="#a5b89a6384ec3f94a33c8fd2f4c384369" title="Reports the current setting of the throw_on_minimum_step_size_violation flag.">get_throw_on_minimum_step_size_violation()</a> == false</span>- an exception would be thrown otherwise). If <span class="tt">true</span> on entry and <span class="tt">false</span> on exit, the error control mechanism has managed to increase the step size above the working minimum; if <span class="tt">true</span> on entry and <span class="tt">true</span> on exit, error control would like to shrink the step size but cannot. If <span class="tt">false</span> on entry and <span class="tt">true</span> on exit, error control shrank the step to the working minimum step size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of types bool and T; the bool will be set to <span class="tt">true</span> if the integration step was to be considered successful and <span class="tt">false</span> otherwise. The value of the T type will be set to the recommended next step size. </dd></dl>

</div>
</div>
<a id="a251c75be3ec4f5b14aeaf5ca2467416f" name="a251c75be3ec4f5b14aeaf5ca2467416f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251c75be3ec4f5b14aeaf5ca2467416f">&#9670;&#160;</a></span>CalcStateChangeNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T CalcStateChangeNorm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dx_state</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the infinity norm of a change in continuous state. </p>
<p>We use the infinity norm to capture the idea that, by providing accuracy requirements, the user can indirectly specify error tolerances that act to limit the largest error in any state vector component. </p><dl class="section return"><dt>Returns</dt><dd>the norm (a non-negative value) </dd></dl>

</div>
</div>
<a id="aea26ed3984a0356a5ad9a2b259ec473b" name="aea26ed3984a0356a5ad9a2b259ec473b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea26ed3984a0356a5ad9a2b259ec473b">&#9670;&#160;</a></span>Clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="#a3ecc7a468ab5fc69c4dd0beefd4aab08">IntegratorBase</a>&lt; T &gt; &gt; Clone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of this integrator with reset statistics, reinitialized internal integrator states, and a cloned system context. </p>
<dl class="section note"><dt>Note</dt><dd>Because the internal integrator states (e.g. value of <a class="el" href="#a8a5d955e6a56d941233b9db657bc5a66" title="Return the step size the integrator would like to take next, based primarily on the integrator&#39;s accu...">get_ideal_next_step_size()</a>) are reinitialized, integration starting with the new clone won't necessarily produce an exact match against integration using the original integrator started at the point it was cloned. </dd></dl>

</div>
</div>
<a id="a0b75f57a458608cb5c351bcfb239fbd5" name="a0b75f57a458608cb5c351bcfb239fbd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b75f57a458608cb5c351bcfb239fbd5">&#9670;&#160;</a></span>DoClone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="#a3ecc7a468ab5fc69c4dd0beefd4aab08">IntegratorBase</a>&lt; T &gt; &gt; DoClone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived classes must implement this method to return a copy of themselves as an <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html" title="An abstract class for an integrator for ODEs and DAEs as represented by a Drake System.">IntegratorBase</a> instance. </p>
<p>The returned object must correctly duplicate all member variables specific to the derived class, while the parent class members are assumed to be handled by the parent class. </p>

</div>
</div>
<a id="ad197f82788b0f33f15e71ec5a261be99" name="ad197f82788b0f33f15e71ec5a261be99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad197f82788b0f33f15e71ec5a261be99">&#9670;&#160;</a></span>DoDenseStep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DoDenseStep </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>h</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls DoStep(h) while recording the resulting step in the dense output. </p>
<p>If the current dense output is already non-empty, then the time in the current context must match either the final segment time of the dense output, or the penultimate segment time (to support the case where the same integration step is attempted multiple times, which occurs e.g. in witness function isolation). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The integration step to take. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if successful, <span class="tt">false</span> if either the integrator was unable to take a single step of size <code class="param">h</code> or to advance its dense output an equal step. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a896ef63038c6eb979ed9b5e3fbc4a16f" title="Derived classes must implement this method to (1) integrate the continuous portion of this system for...">DoStep()</a> </dd></dl>

</div>
</div>
<a id="ae1949ad54a9dc1dc95f632a066aa12e6" name="ae1949ad54a9dc1dc95f632a066aa12e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1949ad54a9dc1dc95f632a066aa12e6">&#9670;&#160;</a></span>DoInitialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoInitialize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived classes can override this method to perform special initialization. </p>
<p>This method is called during the <a class="el" href="#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used.">Initialize()</a> method. This default method does nothing. </p>

</div>
</div>
<a id="a22d9215849b8b5dfbdfce1cf00ce3221" name="a22d9215849b8b5dfbdfce1cf00ce3221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d9215849b8b5dfbdfce1cf00ce3221">&#9670;&#160;</a></span>DoReset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoReset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived classes can override this method to perform routines when <a class="el" href="#a372de693ad40b3f42839c8ec6ac845f4" title="Resets the integrator to initial values, i.e., default construction values.">Reset()</a> is called. </p>
<p>This default method does nothing. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_implicit_integrator.html#ad517b4fc0abf71c5f437fc349befd0ee">ImplicitIntegrator&lt; T &gt;</a>.</p>

</div>
</div>
<a id="ac5f5259be2ac9352879b53f559cbd567" name="ac5f5259be2ac9352879b53f559cbd567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f5259be2ac9352879b53f559cbd567">&#9670;&#160;</a></span>DoResetStatistics()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoResetStatistics </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets any statistics particular to a specific integrator. </p>
<p>The default implementation of this function does nothing. If your integrator collects its own statistics, you should re-implement this method and reset them there. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_implicit_integrator.html#a70de1ab086cb5b5b3e6f2281b1cf7f82">ImplicitIntegrator&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a896ef63038c6eb979ed9b5e3fbc4a16f" name="a896ef63038c6eb979ed9b5e3fbc4a16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896ef63038c6eb979ed9b5e3fbc4a16f">&#9670;&#160;</a></span>DoStep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool DoStep </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>h</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived classes must implement this method to (1) integrate the continuous portion of this system forward by a single step of size <code class="param">h</code> and (2) set the error estimate (via <a class="el" href="#a237cfe4eca20cecf6227dfe0ccc0dab3" title="Gets an error estimate of the state variables recorded by the last call to StepOnceFixedSize().">get_mutable_error_estimate()</a>). </p>
<p>This method is called during the integration process (via <a class="el" href="#a818099c976f6b62d04c9c5d525556a9d" title="Default code for advancing the continuous state of the system by a single step of h_max (or smaller,...">StepOnceErrorControlledAtMost()</a>, <a class="el" href="#a02875acba81c8be7dd0c7a2ae89db212" title="(Internal use only) Integrates the system forward in time by a single step with step size subject to ...">IntegrateNoFurtherThanTime()</a>, and <a class="el" href="#a33ee182a7a34894a888a3bcd3dfd5674" title="Stepping function for integrators operating outside of Simulator that advances the continuous state u...">IntegrateWithSingleFixedStepToTime()</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>The integration step to take. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if successful, <span class="tt">false</span> if the integrator was unable to take a single step of size <code class="param">h</code> (due to, e.g., an integrator convergence failure). </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If the time on entry is denoted <span class="tt">t</span>, the time and state will be advanced to <span class="tt">t+h</span> if the method returns <span class="tt">true</span>; otherwise, the time and state should be reset to those at <span class="tt">t</span>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is expected that <a class="el" href="#a896ef63038c6eb979ed9b5e3fbc4a16f" title="Derived classes must implement this method to (1) integrate the continuous portion of this system for...">DoStep()</a> will return <span class="tt">true</span> for some, albeit possibly very small, positive value of <code class="param">h</code>. The derived integrator's stepping algorithm can make this guarantee, for example, by switching to an algorithm not subject to convergence failures (e.g., explicit Euler) for very small step sizes. </dd></dl>

</div>
</div>
<a id="a292084d64056c43eeb8af93dbc9a5ce9" name="a292084d64056c43eeb8af93dbc9a5ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292084d64056c43eeb8af93dbc9a5ce9">&#9670;&#160;</a></span>EvalTimeDerivatives() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &amp; EvalTimeDerivatives </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the derivative function and updates call statistics. </p>
<p>Subclasses should call this function rather than calling system.EvalTimeDerivatives() directly. </p>

</div>
</div>
<a id="aaa3101a0f9d8116dc8d07e0a73c51aef" name="aaa3101a0f9d8116dc8d07e0a73c51aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3101a0f9d8116dc8d07e0a73c51aef">&#9670;&#160;</a></span>EvalTimeDerivatives() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; U &gt; &amp; EvalTimeDerivatives </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>system</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the derivative function (and updates call statistics). </p>
<p>Subclasses should call this function rather than calling system.EvalTimeDerivatives() directly. This version of this function exists to allow integrators to include AutoDiff'd systems in derivative function evaluations. </p>

</div>
</div>
<a id="a4ecfd0a8cbb76b7f43921e284b2a6980" name="a4ecfd0a8cbb76b7f43921e284b2a6980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ecfd0a8cbb76b7f43921e284b2a6980">&#9670;&#160;</a></span>get_accuracy_in_use()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> get_accuracy_in_use </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the accuracy in use by the integrator. </p>
<p>This number may differ from the target accuracy if, for example, the user has requested an accuracy not attainable or not recommended for the particular integrator. </p>

</div>
</div>
<a id="a1f18a0e9534aa1fdc80621deab88c45f" name="a1f18a0e9534aa1fdc80621deab88c45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f18a0e9534aa1fdc80621deab88c45f">&#9670;&#160;</a></span>get_actual_initial_step_size_taken()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; get_actual_initial_step_size_taken </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The actual size of the successful first step. </p>

</div>
</div>
<a id="a5febad6c2edc61891575e64fed4fdb83" name="a5febad6c2edc61891575e64fed4fdb83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5febad6c2edc61891575e64fed4fdb83">&#9670;&#160;</a></span>get_context()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp; get_context </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const reference to the internally-maintained <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> holding the most recent state in the trajectory. </p>
<p>This is suitable for publishing or extracting information about this trajectory step. </p>

</div>
</div>
<a id="a1c2f896b4ffe9a23da8ad4b12c8dc746" name="a1c2f896b4ffe9a23da8ad4b12c8dc746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c2f896b4ffe9a23da8ad4b12c8dc746">&#9670;&#160;</a></span>get_dense_output()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">trajectories::PiecewisePolynomial</a>&lt; T &gt; * get_dense_output </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const pointer to the integrator's current PiecewisePolynomial instance, holding a representation of the continuous state trajectory since the last <a class="el" href="#a0cdd4796b7f98a09da058b9764f13b86" title="Starts dense integration, allocating a new dense output for this integrator to use.">StartDenseIntegration()</a> call. </p>
<p>This is suitable to query the integrator's current dense output, if any (may be nullptr). </p>

</div>
</div>
<a id="a55be09edf29a71aff2a1774622b04e2a" name="a55be09edf29a71aff2a1774622b04e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55be09edf29a71aff2a1774622b04e2a">&#9670;&#160;</a></span>get_error_estimate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; * get_error_estimate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the error estimate (used only for integrators that support error estimation). </p>
<p>If the integrator does not support error estimation, nullptr is returned. </p>

</div>
</div>
<a id="ab09a2cc2db0a776ca7bb11c8d8fe4831" name="ab09a2cc2db0a776ca7bb11c8d8fe4831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09a2cc2db0a776ca7bb11c8d8fe4831">&#9670;&#160;</a></span>get_error_estimate_order()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int get_error_estimate_order </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived classes must override this function to return the order of the asymptotic term in the integrator's error estimate. </p>
<p>An error estimator approximates the truncation error in an integrator's solution. That truncation error e(.) is approximated by a Taylor Series expansion in the neighborhood around t: </p><pre class="fragment">e(t+h) ≈ e(t) + he(t) + he'(t) + ½h²e''(t) + ...
       ≈ e(t) + he(t) + he'(t) + ½h²e''(t) + O(h³)
</pre><p> where we have replaced the "..." with the asymptotic error of all terms truncated from the series.</p>
<p>Implementions should return the order of the asymptotic term in the Taylor Series expansion around the expression for the error. For an integrator that propagates a second-order solution and provides an estimate of the error using an embedded first-order method, this method should return "2", as can be seen in the derivation below, using y* as the true solution: </p><pre class="fragment">y̅ = y* + O(h³)   [second order solution]
ŷ = y* + O(h²)   [embedded first-order method]
e = (y̅ - ŷ) = O(h²)
</pre><p>If the integrator does not provide an error estimate, the derived class implementation should return 0. </p>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_cenic_integrator.html#a447328b1aaa3ed12450855b792983d24">CenicIntegrator&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_bogacki_shampine3_integrator.html#a7932e0cc0f116b8a625cb025616d73ab">BogackiShampine3Integrator&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_explicit_euler_integrator.html#a7932e0cc0f116b8a625cb025616d73ab">ExplicitEulerIntegrator&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_implicit_euler_integrator.html#a447328b1aaa3ed12450855b792983d24">ImplicitEulerIntegrator&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_radau_integrator.html#a447328b1aaa3ed12450855b792983d24">RadauIntegrator&lt; T, num_stages &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_radau_integrator.html#a447328b1aaa3ed12450855b792983d24">RadauIntegrator&lt; T, 1 &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_radau_integrator.html#a447328b1aaa3ed12450855b792983d24">RadauIntegrator&lt; T, 2 &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_runge_kutta2_integrator.html#a7932e0cc0f116b8a625cb025616d73ab">RungeKutta2Integrator&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_runge_kutta3_integrator.html#a7932e0cc0f116b8a625cb025616d73ab">RungeKutta3Integrator&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_runge_kutta5_integrator.html#a7932e0cc0f116b8a625cb025616d73ab">RungeKutta5Integrator&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_semi_explicit_euler_integrator.html#a7932e0cc0f116b8a625cb025616d73ab">SemiExplicitEulerIntegrator&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_velocity_implicit_euler_integrator.html#a447328b1aaa3ed12450855b792983d24">VelocityImplicitEulerIntegrator&lt; T &gt;</a>.</p>

</div>
</div>
<a id="ae35b01e013bbfa64d9cdccfa01f034fe" name="ae35b01e013bbfa64d9cdccfa01f034fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35b01e013bbfa64d9cdccfa01f034fe">&#9670;&#160;</a></span>get_fixed_step_mode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool get_fixed_step_mode </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets whether an integrator is running in fixed step mode. </p>
<p>If the integrator does not support error estimation, this function will always return <span class="tt">true</span>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a53f8dced020f4fa9c3ccfc2eb6982a86" title="Sets an integrator with error control to fixed step mode.">set_fixed_step_mode()</a> </dd></dl>

</div>
</div>
<a id="ae80a14e4cb31118d49dd48613c24bcac" name="ae80a14e4cb31118d49dd48613c24bcac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae80a14e4cb31118d49dd48613c24bcac">&#9670;&#160;</a></span>get_generalized_state_weight_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::VectorXd &amp; get_generalized_state_weight_vector </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the weighting vector (equivalent to a diagonal matrix) applied to weighting both generalized coordinate and velocity state variable errors, as described in the group documentation. </p>
<p>Only used for integrators that support error estimation. </p>

</div>
</div>
<a id="a8a5d955e6a56d941233b9db657bc5a66" name="a8a5d955e6a56d941233b9db657bc5a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5d955e6a56d941233b9db657bc5a66">&#9670;&#160;</a></span>get_ideal_next_step_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; get_ideal_next_step_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the step size the integrator would like to take next, based primarily on the integrator's accuracy prediction. </p>
<p>This value will not be computed for integrators that do not support error estimation and NaN will be returned. </p>

</div>
</div>
<a id="a39de0d04194f2a315271e605b48c1b11" name="a39de0d04194f2a315271e605b48c1b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39de0d04194f2a315271e605b48c1b11">&#9670;&#160;</a></span>get_initial_step_size_target()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; get_initial_step_size_target </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the target size of the first integration step. </p>
<p>You can find out what step size was <em>actually</em> used for the first integration step with <span class="tt"><a class="el" href="#a1f18a0e9534aa1fdc80621deab88c45f" title="The actual size of the successful first step.">get_actual_initial_step_size_taken()</a></span>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aaa818a52a133131208f51b1c0a3a906c" title="Request that the first attempted integration step have a particular size.">request_initial_step_size_target()</a> </dd></dl>

</div>
</div>
<a id="abec4f2df9432897c463e101646f37b76" name="abec4f2df9432897c463e101646f37b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec4f2df9432897c463e101646f37b76">&#9670;&#160;</a></span>get_largest_step_size_taken()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; get_largest_step_size_taken </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size of the largest step taken since the last <a class="el" href="#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used.">Initialize()</a> or <a class="el" href="#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics.">ResetStatistics()</a> call. </p>

</div>
</div>
<a id="af96a8bb1db3721dc63beb85fe4cb1457" name="af96a8bb1db3721dc63beb85fe4cb1457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96a8bb1db3721dc63beb85fe4cb1457">&#9670;&#160;</a></span>get_maximum_step_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; get_maximum_step_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the maximum step size that may be taken by this integrator. </p>
<p>This is a soft maximum: the integrator may stretch it by as much as 1% to hit a discrete event. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0f186af10e0fc1fc8f32fafa4fed7ba7" title="Sets the requested minimum step size h_min that may be taken by this integrator.">set_requested_minimum_step_size()</a> </dd></dl>

</div>
</div>
<a id="aa66eac04db4502fc0bbb571b50f4490b" name="aa66eac04db4502fc0bbb571b50f4490b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66eac04db4502fc0bbb571b50f4490b">&#9670;&#160;</a></span>get_misc_state_weight_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::VectorXd &amp; get_misc_state_weight_vector </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the weighting vector (equivalent to a diagonal matrix) for weighting errors in miscellaneous continuous state variables <span class="tt">z</span>. </p>
<p>Only used for integrators that support error estimation. </p>

</div>
</div>
<a id="a289399d8ca051bafdd906b50aa544218" name="a289399d8ca051bafdd906b50aa544218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289399d8ca051bafdd906b50aa544218">&#9670;&#160;</a></span>get_mutable_context()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; * get_mutable_context </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable pointer to the internally-maintained <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> holding the most recent state in the trajectory. </p>

</div>
</div>
<a id="ad4f1973bf8ef0a22d007b13b71a54f40" name="ad4f1973bf8ef0a22d007b13b71a54f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f1973bf8ef0a22d007b13b71a54f40">&#9670;&#160;</a></span>get_mutable_dense_output()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">trajectories::PiecewisePolynomial</a>&lt; T &gt; * get_mutable_dense_output </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a mutable pointer to the internally-maintained PiecewisePolynomial instance, holding a representation of the continuous state trajectory since the last time <a class="el" href="#a0cdd4796b7f98a09da058b9764f13b86" title="Starts dense integration, allocating a new dense output for this integrator to use.">StartDenseIntegration()</a> was called. </p>
<p>This is useful for derived classes to update the integrator's current dense output, if any (may be nullptr). </p>

</div>
</div>
<a id="a237cfe4eca20cecf6227dfe0ccc0dab3" name="a237cfe4eca20cecf6227dfe0ccc0dab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237cfe4eca20cecf6227dfe0ccc0dab3">&#9670;&#160;</a></span>get_mutable_error_estimate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; * get_mutable_error_estimate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an error estimate of the state variables recorded by the last call to StepOnceFixedSize(). </p>
<p>If the integrator does not support error estimation, this function will return nullptr. </p>

</div>
</div>
<a id="ad4245130a64e9aa0bc0ca3d0e06c8d5f" name="ad4245130a64e9aa0bc0ca3d0e06c8d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4245130a64e9aa0bc0ca3d0e06c8d5f">&#9670;&#160;</a></span>get_mutable_generalized_state_weight_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt; Eigen::VectorXd &gt; get_mutable_generalized_state_weight_vector </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a mutable weighting vector (equivalent to a diagonal matrix) applied to weighting both generalized coordinate and velocity state variable errors, as described in the group documentation. </p>
<p>Only used for integrators that support error estimation. Returns a VectorBlock to make the values mutable without permitting changing the size of the vector. Requires re-initializing the integrator after calling this method; if <a class="el" href="#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used.">Initialize()</a> is not called afterward, an exception will be thrown when attempting to call <a class="el" href="#a02875acba81c8be7dd0c7a2ae89db212" title="(Internal use only) Integrates the system forward in time by a single step with step size subject to ...">IntegrateNoFurtherThanTime()</a>. If the caller sets one of the entries to a negative value, an exception will be thrown when the integrator is initialized. </p>

</div>
</div>
<a id="ae35c375f7ce5d26345168f4f24e9c347" name="ae35c375f7ce5d26345168f4f24e9c347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae35c375f7ce5d26345168f4f24e9c347">&#9670;&#160;</a></span>get_mutable_misc_state_weight_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt; Eigen::VectorXd &gt; get_mutable_misc_state_weight_vector </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a mutable weighting vector (equivalent to a diagonal matrix) for weighting errors in miscellaneous continuous state variables <span class="tt">z</span>. </p>
<p>Only used for integrators that support error estimation. Returns a VectorBlock to make the values mutable without permitting changing the size of the vector. Requires re-initializing the integrator after calling this method. If <a class="el" href="#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used.">Initialize()</a> is not called afterward, an exception will be thrown when attempting to call <a class="el" href="#a02875acba81c8be7dd0c7a2ae89db212" title="(Internal use only) Integrates the system forward in time by a single step with step size subject to ...">IntegrateNoFurtherThanTime()</a>. If the caller sets one of the entries to a negative value, an exception will be thrown when the integrator is initialized. </p>

</div>
</div>
<a id="ac3152b858f89491817273d05fa518289" name="ac3152b858f89491817273d05fa518289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3152b858f89491817273d05fa518289">&#9670;&#160;</a></span>get_num_derivative_evaluations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int64_t get_num_derivative_evaluations </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of ODE function evaluations (calls to CalcTimeDerivatives()) since the last call to <a class="el" href="#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics.">ResetStatistics()</a> or <a class="el" href="#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used.">Initialize()</a>. </p>
<p>This count includes <em>all</em> such calls including (1) those necessary to compute Jacobian matrices; (2) those used in rejected integrated steps (for, e.g., purposes of error control); (3) those used strictly for integrator error estimation; and (4) calls that exhibit little cost (due to results being cached). </p>

</div>
</div>
<a id="a2b588edb71f956edad8a88d5c8b86479" name="a2b588edb71f956edad8a88d5c8b86479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b588edb71f956edad8a88d5c8b86479">&#9670;&#160;</a></span>get_num_step_shrinkages_from_error_control()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int64_t get_num_step_shrinkages_from_error_control </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of step size shrinkages due to failure to meet targeted error tolerances, since the last call to ResetStatistics or <a class="el" href="#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used.">Initialize()</a>. </p>

</div>
</div>
<a id="a64333e8ed51bb6a29af25c2c4da153aa" name="a64333e8ed51bb6a29af25c2c4da153aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64333e8ed51bb6a29af25c2c4da153aa">&#9670;&#160;</a></span>get_num_step_shrinkages_from_substep_failures()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int64_t get_num_step_shrinkages_from_substep_failures </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of step size shrinkages due to sub-step failures (e.g., integrator convergence failures) since the last call to <a class="el" href="#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics.">ResetStatistics()</a> or <a class="el" href="#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used.">Initialize()</a>. </p>

</div>
</div>
<a id="a215741958afe19af17a62470f883878b" name="a215741958afe19af17a62470f883878b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215741958afe19af17a62470f883878b">&#9670;&#160;</a></span>get_num_steps_taken()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int64_t get_num_steps_taken </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of integration steps taken since the last <a class="el" href="#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used.">Initialize()</a> or <a class="el" href="#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics.">ResetStatistics()</a> call. </p>

</div>
</div>
<a id="afa1597c69b7f633624a3693142ad3f04" name="afa1597c69b7f633624a3693142ad3f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1597c69b7f633624a3693142ad3f04">&#9670;&#160;</a></span>get_num_substep_failures()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int64_t get_num_substep_failures </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of failed sub-steps (implying one or more step size reductions was required to permit solving the necessary nonlinear system of equations). </p>

</div>
</div>
<a id="ae1e39e721e714a393b1669513eb36fb3" name="ae1e39e721e714a393b1669513eb36fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e39e721e714a393b1669513eb36fb3">&#9670;&#160;</a></span>get_previous_integration_step_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; get_previous_integration_step_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of the last (previous) integration step. </p>
<p>If no integration steps have been taken, value will be NaN. </p>

</div>
</div>
<a id="af3e06e95adf0fad713e3e4b2ba18eccc" name="af3e06e95adf0fad713e3e4b2ba18eccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e06e95adf0fad713e3e4b2ba18eccc">&#9670;&#160;</a></span>get_requested_minimum_step_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; get_requested_minimum_step_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the requested minimum step size <span class="tt">h_min</span> for this integrator. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0f186af10e0fc1fc8f32fafa4fed7ba7" title="Sets the requested minimum step size h_min that may be taken by this integrator.">set_requested_minimum_step_size()</a> </dd>
<dd>
get_working_minimum_step_size(T) </dd></dl>

</div>
</div>
<a id="a84a2a25041ff2c07dc27911a93de7a2e" name="a84a2a25041ff2c07dc27911a93de7a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a2a25041ff2c07dc27911a93de7a2e">&#9670;&#160;</a></span>get_smallest_adapted_step_size_taken()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; get_smallest_adapted_step_size_taken </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size of the smallest step taken <em>as the result of a controlled integration step adjustment</em> since the last <a class="el" href="#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used.">Initialize()</a> or <a class="el" href="#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics.">ResetStatistics()</a> call. </p>
<p>This value will be NaN for integrators without error estimation. </p>

</div>
</div>
<a id="ab693dd7dd1da02154fc0f0ff6ef20692" name="ab693dd7dd1da02154fc0f0ff6ef20692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab693dd7dd1da02154fc0f0ff6ef20692">&#9670;&#160;</a></span>get_stretch_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> get_stretch_factor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the stretch factor (&gt; 1), which is multiplied by the maximum (typically user-designated) integration step size to obtain the amount that the integrator is able to stretch the maximum time step toward hitting an upcoming publish or update event in <a class="el" href="#a02875acba81c8be7dd0c7a2ae89db212" title="(Internal use only) Integrates the system forward in time by a single step with step size subject to ...">IntegrateNoFurtherThanTime()</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a02875acba81c8be7dd0c7a2ae89db212" title="(Internal use only) Integrates the system forward in time by a single step with step size subject to ...">IntegrateNoFurtherThanTime()</a> </dd></dl>

</div>
</div>
<a id="ab6175b31bc7d4a8e02470e716aa92a2e" name="ab6175b31bc7d4a8e02470e716aa92a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6175b31bc7d4a8e02470e716aa92a2e">&#9670;&#160;</a></span>get_system()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &amp; get_system </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a constant reference to the system that is being integrated (and was provided to the constructor of the integrator). </p>

</div>
</div>
<a id="a630ba1d30cec20bb83e5a678945ffaa2" name="a630ba1d30cec20bb83e5a678945ffaa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630ba1d30cec20bb83e5a678945ffaa2">&#9670;&#160;</a></span>get_target_accuracy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> get_target_accuracy </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the target accuracy. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4ecfd0a8cbb76b7f43921e284b2a6980" title="Gets the accuracy in use by the integrator.">get_accuracy_in_use()</a> </dd></dl>

</div>
</div>
<a id="a5b89a6384ec3f94a33c8fd2f4c384369" name="a5b89a6384ec3f94a33c8fd2f4c384369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b89a6384ec3f94a33c8fd2f4c384369">&#9670;&#160;</a></span>get_throw_on_minimum_step_size_violation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool get_throw_on_minimum_step_size_violation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the current setting of the throw_on_minimum_step_size_violation flag. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a78773e63a07381351e18380040f5fc13" title="Sets whether the integrator should throw a std::exception when the integrator&#39;s step size selection a...">set_throw_on_minimum_step_size_violation()</a>. </dd></dl>

</div>
</div>
<a id="a47399e48a6a661ce1b8252d86a305b54" name="a47399e48a6a661ce1b8252d86a305b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47399e48a6a661ce1b8252d86a305b54">&#9670;&#160;</a></span>get_working_minimum_step_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T get_working_minimum_step_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current value of the working minimum step size <span class="tt">h_work(t)</span> for this integrator, which may vary with the current time t as stored in the integrator's context. </p>
<p>See <a class="el" href="#integrator-minstep">this section</a> for more detail. </p>

</div>
</div>
<a id="a98b1050f09da390896f964fb7a892391" name="a98b1050f09da390896f964fb7a892391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b1050f09da390896f964fb7a892391">&#9670;&#160;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Initialize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An integrator must be initialized before being used. </p>
<p>The pointer to the context must be set before <a class="el" href="#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used.">Initialize()</a> is called (or an std::exception will be thrown). If <a class="el" href="#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used.">Initialize()</a> is not called, an exception will be thrown when attempting to call <a class="el" href="#a02875acba81c8be7dd0c7a2ae89db212" title="(Internal use only) Integrates the system forward in time by a single step with step size subject to ...">IntegrateNoFurtherThanTime()</a>. To reinitialize the integrator, <a class="el" href="#a372de693ad40b3f42839c8ec6ac845f4" title="Resets the integrator to initial values, i.e., default construction values.">Reset()</a> should be called followed by <a class="el" href="#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used.">Initialize()</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>If the context has not been set or a user-set parameter has been set illogically (i.e., one of the weighting matrix coefficients is set to a negative value- this check is only performed for integrators that support error estimation; the maximum step size is smaller than the minimum step size; the requested initial step size is outside of the interval [minimum step size, maximum step size]). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a372de693ad40b3f42839c8ec6ac845f4" title="Resets the integrator to initial values, i.e., default construction values.">Reset()</a> </dd></dl>

</div>
</div>
<a id="a02875acba81c8be7dd0c7a2ae89db212" name="a02875acba81c8be7dd0c7a2ae89db212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02875acba81c8be7dd0c7a2ae89db212">&#9670;&#160;</a></span>IntegrateNoFurtherThanTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a95ae527571e3f25c4415b93d12cb0ad9">StepResult</a> IntegrateNoFurtherThanTime </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>publish_time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>update_time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>boundary_time</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Integrates the system forward in time by a single step with step size subject to integration error tolerances (assuming that the integrator supports error estimation). </p>
<p>The integrator must already have been initialized or an exception will be thrown. The context will be integrated to a time that will never exceed the minimum of <span class="tt">publish_time</span>, <span class="tt">update_time</span>, and the current time plus <span class="tt">1.01 * <a class="el" href="#af96a8bb1db3721dc63beb85fe4cb1457" title="Gets the maximum step size that may be taken by this integrator.">get_maximum_step_size()</a></span>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">publish_time</td><td>The present or future time (exception will be thrown if this is not the case) at which the next publish will occur. </td></tr>
    <tr><td class="paramname">update_time</td><td>The present or future time (exception will be thrown if this is not the case) at which the next update will occur. </td></tr>
    <tr><td class="paramname">boundary_time</td><td>The present or future time (exception will be thrown if this is not the case) marking the end of the user-designated simulated interval. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>If the integrator has not been initialized or one of publish_time, update_time, or boundary_time is in the past. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reason for the integration step ending. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The time in the context will be no greater than <span class="tt">min(publish_time, update_time, boundary_time)</span>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Users should generally not call this function directly; within simulation circumstances, users will typically call <span class="tt"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#aba4b04299c9b1d41d9dd85563600012d" title="Advances the System&#39;s trajectory until boundary_time is reached in the Context or some other terminat...">Simulator::AdvanceTo()</a></span>. In other circumstances, users will typically call <span class="tt"><a class="el" href="#acb2ebec0fff763d592464afb49bffe13" title="Stepping function for integrators operating outside of Simulator that advances the continuous state e...">IntegratorBase::IntegrateWithMultipleStepsToTime()</a></span>.</dd></dl>
<p>This method at a glance:</p><ul>
<li>For integrating ODEs/DAEs via <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a></li>
<li>Supports fixed step and variable step integration schemes</li>
<li>Takes only a single step forward. </li>
</ul>

</div>
</div>
<a id="acb2ebec0fff763d592464afb49bffe13" name="acb2ebec0fff763d592464afb49bffe13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2ebec0fff763d592464afb49bffe13">&#9670;&#160;</a></span>IntegrateWithMultipleStepsToTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void IntegrateWithMultipleStepsToTime </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t_final</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stepping function for integrators operating outside of <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> that advances the continuous state exactly to <span class="tt">t_final</span>. </p>
<p>This method is designed for integrator users that do not wish to consider publishing or discontinuous, mid-interval updates. This method will step the integrator multiple times, as necessary, to attain requested error tolerances and to ensure the integrator converges. </p><dl class="section warning"><dt>Warning</dt><dd>Users should simulate systems using <span class="tt"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#aba4b04299c9b1d41d9dd85563600012d" title="Advances the System&#39;s trajectory until boundary_time is reached in the Context or some other terminat...">Simulator::AdvanceTo()</a></span> in place of this function (which was created for off-simulation purposes), generally. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_final</td><td>The current or future time to integrate to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>If the integrator has not been initialized or t_final is in the past. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a02875acba81c8be7dd0c7a2ae89db212" title="(Internal use only) Integrates the system forward in time by a single step with step size subject to ...">IntegrateNoFurtherThanTime()</a>, which is designed to be operated by <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> and accounts for publishing and state reinitialization. </dd>
<dd>
<a class="el" href="#a33ee182a7a34894a888a3bcd3dfd5674" title="Stepping function for integrators operating outside of Simulator that advances the continuous state u...">IntegrateWithSingleFixedStepToTime()</a>, which is also designed to be operated <em>outside of</em> <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a>, but throws an exception if the integrator cannot advance time to <span class="tt">t_final</span> in a single step.</dd></dl>
<p>This method at a glance:</p><ul>
<li>For integrating ODEs/DAEs not using <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a></li>
<li>Supports fixed step and variable step integration schemes</li>
<li>Takes as many steps as necessary until time has advanced to <span class="tt">t_final</span> </li>
</ul>

</div>
</div>
<a id="a33ee182a7a34894a888a3bcd3dfd5674" name="a33ee182a7a34894a888a3bcd3dfd5674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ee182a7a34894a888a3bcd3dfd5674">&#9670;&#160;</a></span>IntegrateWithSingleFixedStepToTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IntegrateWithSingleFixedStepToTime </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>t_target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stepping function for integrators operating outside of <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> that advances the continuous state <em>using a single step</em> to <span class="tt">t_target</span>. </p>
<p>This method is designed for integrator users that do not wish to consider publishing or discontinuous, mid-interval updates. One such example application is that of direct transcription for trajectory optimization, for which the integration process should be <em>consistent</em>: it should execute the same sequence of arithmetic operations for all values of the nonlinear programming variables. In keeping with the naming semantics of this function, error controlled integration is not supported (though error estimates will be computed for integrators that support that feature), which is a minimal requirement for "consistency". </p><dl class="section warning"><dt>Warning</dt><dd>Users should simulate systems using <span class="tt"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#aba4b04299c9b1d41d9dd85563600012d" title="Advances the System&#39;s trajectory until boundary_time is reached in the Context or some other terminat...">Simulator::AdvanceTo()</a></span> in place of this function (which was created for off-simulation purposes), generally. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t_target</td><td>The current or future time to integrate to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>If the integrator has not been initialized or <span class="tt">t_target</span> is in the past or the integrator is not operating in fixed step mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a02875acba81c8be7dd0c7a2ae89db212" title="(Internal use only) Integrates the system forward in time by a single step with step size subject to ...">IntegrateNoFurtherThanTime()</a>, which is designed to be operated by <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> and accounts for publishing and state reinitialization. </dd>
<dd>
<a class="el" href="#acb2ebec0fff763d592464afb49bffe13" title="Stepping function for integrators operating outside of Simulator that advances the continuous state e...">IntegrateWithMultipleStepsToTime()</a>, which is also designed to be operated <em>outside of</em> <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a>, but will take as many integration steps as necessary until time has been stepped forward to <span class="tt">t_target</span>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the integrator was able to take a single fixed step to <span class="tt">t_target</span>.</dd></dl>
<p>This method at a glance:</p>
<ul>
<li>For integrating ODEs/DAEs not using <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a></li>
<li>Fixed step integration (no step size reductions for error control or integrator convergence)</li>
<li>Takes only a single step forward. </li>
</ul>

</div>
</div>
<a id="a7a2108348656c73efe1d72702c96d5c5" name="a7a2108348656c73efe1d72702c96d5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2108348656c73efe1d72702c96d5c5">&#9670;&#160;</a></span>is_initialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_initialized </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether the integrator has been initialized. </p>

</div>
</div>
<a id="ab897e6180da38fdb008bfc9aea3967b0" name="ab897e6180da38fdb008bfc9aea3967b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab897e6180da38fdb008bfc9aea3967b0">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3ecc7a468ab5fc69c4dd0beefd4aab08">IntegratorBase</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a3ecc7a468ab5fc69c4dd0beefd4aab08">IntegratorBase</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade9156bf8b8283f60dd3f9caca08cb78" name="ade9156bf8b8283f60dd3f9caca08cb78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9156bf8b8283f60dd3f9caca08cb78">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3ecc7a468ab5fc69c4dd0beefd4aab08">IntegratorBase</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a3ecc7a468ab5fc69c4dd0beefd4aab08">IntegratorBase</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa818a52a133131208f51b1c0a3a906c" name="aaa818a52a133131208f51b1c0a3a906c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa818a52a133131208f51b1c0a3a906c">&#9670;&#160;</a></span>request_initial_step_size_target()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void request_initial_step_size_target </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>step_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request that the first attempted integration step have a particular size. </p>
<p>If no request is made, the integrator will estimate a suitable size for the initial step attempt. <em>If the integrator does not support error control</em>, this method will throw a std::exception (call <a class="el" href="#a5fa66573f5abb1dc153098d2920c32b7" title="Derived classes must override this function to indicate whether the integrator supports error estimat...">supports_error_estimation()</a> to verify before calling this method). For variable-step integration, the initial target will be treated as a maximum step size subject to accuracy requirements and event occurrences. You can find out what size <em>actually</em> worked with <span class="tt"><a class="el" href="#a1f18a0e9534aa1fdc80621deab88c45f" title="The actual size of the successful first step.">get_actual_initial_step_size_taken()</a></span>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>If the integrator does not support error estimation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a372de693ad40b3f42839c8ec6ac845f4" name="a372de693ad40b3f42839c8ec6ac845f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372de693ad40b3f42839c8ec6ac845f4">&#9670;&#160;</a></span>Reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Reset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the integrator to initial values, i.e., default construction values. </p>

</div>
</div>
<a id="ae9ec42d998ad39014c3dc64c50cfbc4d" name="ae9ec42d998ad39014c3dc64c50cfbc4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ec42d998ad39014c3dc64c50cfbc4d">&#9670;&#160;</a></span>reset_context() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void reset_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the pointer to the internally-maintained <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> with a different one. </p>
<p>This is useful for supplying a new set of initial conditions or wiping out the current context (by passing in a null pointer). You should invoke <a class="el" href="#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used.">Initialize()</a> after replacing the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> unless the context is null. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the new context or nullptr to wipe out the current context without replacing it with another. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2edc40e3430189fa7dd54ab20268e020" name="a2edc40e3430189fa7dd54ab20268e020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2edc40e3430189fa7dd54ab20268e020">&#9670;&#160;</a></span>reset_context() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void reset_context </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above but allows the integrator to take ownership of the context. </p>

</div>
</div>
<a id="a64a01ac56f8a0086cc6ed335ee9e5caa" name="a64a01ac56f8a0086cc6ed335ee9e5caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a01ac56f8a0086cc6ed335ee9e5caa">&#9670;&#160;</a></span>ResetStatistics()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ResetStatistics </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forget accumulated statistics. </p>
<p>These are reset to the values they have post construction or immediately after <span class="tt"><a class="el" href="#a98b1050f09da390896f964fb7a892391" title="An integrator must be initialized before being used.">Initialize()</a></span>. </p>

</div>
</div>
<a id="a5296d2467ea109300a687233eb159a46" name="a5296d2467ea109300a687233eb159a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5296d2467ea109300a687233eb159a46">&#9670;&#160;</a></span>set_accuracy_in_use()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_accuracy_in_use </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>accuracy</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the working ("in use") accuracy for this integrator. </p>
<p>The working accuracy may not be equivalent to the target accuracy when the latter is too loose or tight for an integrator's capabilities. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4ecfd0a8cbb76b7f43921e284b2a6980" title="Gets the accuracy in use by the integrator.">get_accuracy_in_use()</a> </dd>
<dd>
<a class="el" href="#a630ba1d30cec20bb83e5a678945ffaa2" title="Gets the target accuracy.">get_target_accuracy()</a> </dd></dl>

</div>
</div>
<a id="afa5f6af023ede03e36fd44a079f7440d" name="afa5f6af023ede03e36fd44a079f7440d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5f6af023ede03e36fd44a079f7440d">&#9670;&#160;</a></span>set_actual_initial_step_size_taken()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_actual_initial_step_size_taken </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>h</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a53f8dced020f4fa9c3ccfc2eb6982a86" name="a53f8dced020f4fa9c3ccfc2eb6982a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f8dced020f4fa9c3ccfc2eb6982a86">&#9670;&#160;</a></span>set_fixed_step_mode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_fixed_step_mode </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an integrator with error control to fixed step mode. </p>
<p>If the integrator runs in fixed step mode, it will always take the maximum step size directed (which may be that determined by <a class="el" href="#af96a8bb1db3721dc63beb85fe4cb1457" title="Gets the maximum step size that may be taken by this integrator.">get_maximum_step_size()</a>, or may be smaller, as directed by, e.g., <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> for event handling purposes). </p><dl class="section warning"><dt>Warning</dt><dd>The error estimation process will still be active (so <a class="el" href="#a55be09edf29a71aff2a1774622b04e2a" title="Gets the error estimate (used only for integrators that support error estimation).">get_error_estimate()</a> will still return a correct result), meaning that the additional (typically, but not necessarily small) computation required for error estimation will still be performed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if integrator does not support error estimation and <code class="param">flag</code> is set to <span class="tt">false</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac04da433607f913e10ee9d485d675fb1" name="ac04da433607f913e10ee9d485d675fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04da433607f913e10ee9d485d675fb1">&#9670;&#160;</a></span>set_ideal_next_step_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_ideal_next_step_size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>h</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0fd2440d87169f64766fee57612d577" name="ab0fd2440d87169f64766fee57612d577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0fd2440d87169f64766fee57612d577">&#9670;&#160;</a></span>set_largest_step_size_taken()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_largest_step_size_taken </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>h</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae878ce4cdab7a01165423d8a902df452" name="ae878ce4cdab7a01165423d8a902df452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae878ce4cdab7a01165423d8a902df452">&#9670;&#160;</a></span>set_maximum_step_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_maximum_step_size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>max_step_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum step size that may be taken by this integrator. </p>
<p>This setting should be used if you know the maximum time scale of your problem. The integrator may stretch the maximum step size by as much as 1% to reach a discrete event. For fixed step integrators, all steps will be taken at the maximum step size <em>unless</em> an event would be missed. </p><dl class="section warning"><dt>Warning</dt><dd>See <a class="el" href="#integrator-initial-step-size">Initial step size selection</a> </dd></dl>

</div>
</div>
<a id="a0f186af10e0fc1fc8f32fafa4fed7ba7" name="a0f186af10e0fc1fc8f32fafa4fed7ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f186af10e0fc1fc8f32fafa4fed7ba7">&#9670;&#160;</a></span>set_requested_minimum_step_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_requested_minimum_step_size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>min_step_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the requested minimum step size <span class="tt">h_min</span> that may be taken by this integrator. </p>
<p>No step smaller than this will be taken except under circumstances as described <a class="el" href="#integrator-minstep">above</a>. This setting will be ignored if it is smaller than the absolute minimum <span class="tt">h_floor</span> also described above. Default value is zero. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_step_size</td><td>a non-negative value. Setting this value to zero will cause the integrator to use a reasonable value instead (see <a class="el" href="#a47399e48a6a661ce1b8252d86a305b54" title="Gets the current value of the working minimum step size h_work(t) for this integrator,...">get_working_minimum_step_size()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af3e06e95adf0fad713e3e4b2ba18eccc" title="Gets the requested minimum step size h_min for this integrator.">get_requested_minimum_step_size()</a> </dd>
<dd>
<a class="el" href="#a47399e48a6a661ce1b8252d86a305b54" title="Gets the current value of the working minimum step size h_work(t) for this integrator,...">get_working_minimum_step_size()</a> </dd></dl>

</div>
</div>
<a id="a2cd5795eec65555263f9b804260b6dcd" name="a2cd5795eec65555263f9b804260b6dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd5795eec65555263f9b804260b6dcd">&#9670;&#160;</a></span>set_smallest_adapted_step_size_taken()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_smallest_adapted_step_size_taken </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>h</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the size of the smallest-step-taken statistic as the result of a controlled integration step adjustment. </p>

</div>
</div>
<a id="a6dbb07017a30541d06b2b597d1e4f30f" name="a6dbb07017a30541d06b2b597d1e4f30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dbb07017a30541d06b2b597d1e4f30f">&#9670;&#160;</a></span>set_target_accuracy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_target_accuracy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>accuracy</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request that the integrator attempt to achieve a particular accuracy for the continuous portions of the simulation. </p>
<p>Otherwise a default accuracy is chosen for you. This may be ignored for fixed-step integration since accuracy control requires variable step sizes. You should call <a class="el" href="#a5fa66573f5abb1dc153098d2920c32b7" title="Derived classes must override this function to indicate whether the integrator supports error estimat...">supports_error_estimation()</a> to ensure that the integrator supports this capability before calling this function; if the integrator does not support it, this method will throw an exception.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if integrator does not support error estimation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78773e63a07381351e18380040f5fc13" name="a78773e63a07381351e18380040f5fc13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78773e63a07381351e18380040f5fc13">&#9670;&#160;</a></span>set_throw_on_minimum_step_size_violation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_throw_on_minimum_step_size_violation </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>throws</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether the integrator should throw a std::exception when the integrator's step size selection algorithm determines that it must take a step smaller than the minimum step size (for, e.g., purposes of error control). </p>
<p>Default is <span class="tt">true</span>. If <span class="tt">false</span>, the integrator will advance time and state using the minimum specified step size in such situations. See <a class="el" href="#integrator-minstep">this section</a> for more detail. </p>

</div>
</div>
<a id="a0cdd4796b7f98a09da058b9764f13b86" name="a0cdd4796b7f98a09da058b9764f13b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdd4796b7f98a09da058b9764f13b86">&#9670;&#160;</a></span>StartDenseIntegration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StartDenseIntegration </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts dense integration, allocating a new dense output for this integrator to use. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The integrator has been initialized. </dd>
<dd>
The system being integrated has continuous state. </dd>
<dd>
No dense integration is in progress (no dense output is held by the integrator) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if any of the preconditions is not met. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Dense integration may incur significant overhead. </dd></dl>

</div>
</div>
<a id="a818099c976f6b62d04c9c5d525556a9d" name="a818099c976f6b62d04c9c5d525556a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818099c976f6b62d04c9c5d525556a9d">&#9670;&#160;</a></span>StepOnceErrorControlledAtMost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StepOnceErrorControlledAtMost </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>h_max</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default code for advancing the continuous state of the system by a single step of <code class="param">h_max</code> (or smaller, depending on error control). </p>
<p>This particular function is designed to be called directly by an error estimating integrator's <a class="el" href="#a896ef63038c6eb979ed9b5e3fbc4a16f" title="Derived classes must implement this method to (1) integrate the continuous portion of this system for...">DoStep()</a> method to effect error-controlled integration. The integrator can effect error controlled integration without calling this method, if the implementer so chooses, but this default method is expected to function well in most circumstances. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h_max</td><td>The maximum step size to be taken. The integrator may take a smaller step than specified to satisfy accuracy requirements, to resolve integrator convergence problems, or to respect the integrator's maximum step size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if integrator does not support error estimation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function will shrink the integration step as necessary whenever the integrator's <a class="el" href="#a896ef63038c6eb979ed9b5e3fbc4a16f" title="Derived classes must implement this method to (1) integrate the continuous portion of this system for...">DoStep()</a> fails to take the requested step e.g., due to integrator convergence failure. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the full step of size <code class="param">h_max</code> is taken and <span class="tt">false</span> otherwise (i.e., a smaller step than <code class="param">h_max</code> was taken). </dd></dl>

</div>
</div>
<a id="aec1b43d020ade4db105e454ec595c21e" name="aec1b43d020ade4db105e454ec595c21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1b43d020ade4db105e454ec595c21e">&#9670;&#160;</a></span>StopDenseIntegration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">trajectories::PiecewisePolynomial</a>&lt; T &gt; &gt; StopDenseIntegration </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops dense integration, yielding ownership of the current dense output to the caller. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This process is irreversible. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A PiecewisePolynomial instance, i.e. a representation of the continuous state trajectory of the system being integrated that can be evaluated at any time within its extension. This representation is defined starting at the context time of the last <a class="el" href="#a0cdd4796b7f98a09da058b9764f13b86" title="Starts dense integration, allocating a new dense output for this integrator to use.">StartDenseIntegration()</a> call and finishing at the current context time. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Dense integration is in progress (a dense output is held by this integrator, after a call to <a class="el" href="#a0cdd4796b7f98a09da058b9764f13b86" title="Starts dense integration, allocating a new dense output for this integrator to use.">StartDenseIntegration()</a>). </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Previously held dense output is not updated nor referenced by the integrator anymore. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if any of the preconditions is not met. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fa66573f5abb1dc153098d2920c32b7" name="a5fa66573f5abb1dc153098d2920c32b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa66573f5abb1dc153098d2920c32b7">&#9670;&#160;</a></span>supports_error_estimation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool supports_error_estimation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived classes must override this function to indicate whether the integrator supports error estimation. </p>
<p>Without error estimation, the target accuracy setting (see <a class="el" href="#integrator-accuracy">accuracy settings</a>) will be unused. </p>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_cenic_integrator.html#acd7fceaaf1d3c2b328b675c8d911f450">CenicIntegrator&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_bogacki_shampine3_integrator.html#a52ddb8ce13134e8e8afdfcfde6fd75ec">BogackiShampine3Integrator&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_explicit_euler_integrator.html#a52ddb8ce13134e8e8afdfcfde6fd75ec">ExplicitEulerIntegrator&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_implicit_euler_integrator.html#acd7fceaaf1d3c2b328b675c8d911f450">ImplicitEulerIntegrator&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_radau_integrator.html#acd7fceaaf1d3c2b328b675c8d911f450">RadauIntegrator&lt; T, num_stages &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_radau_integrator.html#acd7fceaaf1d3c2b328b675c8d911f450">RadauIntegrator&lt; T, 1 &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_radau_integrator.html#acd7fceaaf1d3c2b328b675c8d911f450">RadauIntegrator&lt; T, 2 &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_runge_kutta2_integrator.html#a52ddb8ce13134e8e8afdfcfde6fd75ec">RungeKutta2Integrator&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_runge_kutta3_integrator.html#a52ddb8ce13134e8e8afdfcfde6fd75ec">RungeKutta3Integrator&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_runge_kutta5_integrator.html#a52ddb8ce13134e8e8afdfcfde6fd75ec">RungeKutta5Integrator&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_semi_explicit_euler_integrator.html#a52ddb8ce13134e8e8afdfcfde6fd75ec">SemiExplicitEulerIntegrator&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_velocity_implicit_euler_integrator.html#acd7fceaaf1d3c2b328b675c8d911f450">VelocityImplicitEulerIntegrator&lt; T &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/systems/analysis/<a class="el" href="integrator__base_8h.html">integrator_base.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1systems.html">systems</a></li><li class="navelem"><a href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
