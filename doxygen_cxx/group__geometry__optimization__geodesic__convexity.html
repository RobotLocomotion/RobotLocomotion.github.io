<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: Geodesic Convexity</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__geometry__optimization__geodesic__convexity.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Geodesic Convexity <div class="ingroups"><a class="el" href="group__geometry.html">Geometric Representations</a> &#124; <a class="el" href="group__solvers.html">Formulating and Solving Optimization Problems</a> &raquo; <a class="el" href="group__geometry__optimization.html">Geometry Optimization</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>A robot that has revolute joints without any limits has an inherently non-Euclidean configuration space, but one can still consider "geodesically-convex" sets, akin to convex sets in Euclidean space. </p>
<p>In practice, this only requires that the width of the set along each dimension corresponding to an unbounded revolute joint be strictly less than π. These functions are primarily used by GcsTrajectoryOptimization to make motion plans for these types of robots. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga80f9e107223dafa631c82a743f5ee64f" id="r_ga80f9e107223dafa631c82a743f5ee64f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga80f9e107223dafa631c82a743f5ee64f">CheckIfSatisfiesConvexityRadius</a> (const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">geometry::optimization::ConvexSet</a> &amp;convex_set, const std::vector&lt; int &gt; &amp;continuous_revolute_joints)</td></tr>
<tr class="memdesc:ga80f9e107223dafa631c82a743f5ee64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a convex set, and a list of indices corresponding to continuous revolute joints, checks whether or not the set satisfies the convexity radius.  <br /></td></tr>
<tr class="memitem:ga4cc1511a0a4979afa70ee7d5964bc0d5" id="r_ga4cc1511a0a4979afa70ee7d5964bc0d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">geometry::optimization::ConvexSets</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4cc1511a0a4979afa70ee7d5964bc0d5">PartitionConvexSet</a> (const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">geometry::optimization::ConvexSet</a> &amp;convex_set, const std::vector&lt; int &gt; &amp;continuous_revolute_joints, const double epsilon=1e-5)</td></tr>
<tr class="memdesc:ga4cc1511a0a4979afa70ee7d5964bc0d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions a convex set into (smaller) convex sets whose union is the original set and that each respect the convexity radius as in CheckIfSatisfiesConvexityRadius.  <br /></td></tr>
<tr class="memitem:ga40707ecfcee3ff6cc60fdf7cd0956166" id="r_ga40707ecfcee3ff6cc60fdf7cd0956166"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">geometry::optimization::ConvexSets</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga40707ecfcee3ff6cc60fdf7cd0956166">PartitionConvexSet</a> (const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">geometry::optimization::ConvexSets</a> &amp;convex_sets, const std::vector&lt; int &gt; &amp;continuous_revolute_joints, const double epsilon=1e-5)</td></tr>
<tr class="memdesc:ga40707ecfcee3ff6cc60fdf7cd0956166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function overload to take in a list of convex sets, and partition all so as to respect the convexity radius.  <br /></td></tr>
<tr class="memitem:ga6fbf6cf1ac5a9ea873bac401fc705117" id="r_ga6fbf6cf1ac5a9ea873bac401fc705117"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt;, std::vector&lt; Eigen::VectorXd &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6fbf6cf1ac5a9ea873bac401fc705117">ComputePairwiseIntersections</a> (const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;convex_sets_A, const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;convex_sets_B, const std::vector&lt; int &gt; &amp;continuous_revolute_joints, bool preprocess_bbox=true, <a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a> parallelism=<a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>())</td></tr>
<tr class="memdesc:ga6fbf6cf1ac5a9ea873bac401fc705117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the pairwise intersections between two lists of convex sets, returning a list of edges, and a list of their corresponding offsets.  <br /></td></tr>
<tr class="memitem:ga8f0d035a7345f68adf751858f6b37a90" id="r_ga8f0d035a7345f68adf751858f6b37a90"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt;, std::vector&lt; Eigen::VectorXd &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8f0d035a7345f68adf751858f6b37a90">ComputePairwiseIntersections</a> (const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;convex_sets_A, const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;convex_sets_B, const std::vector&lt; int &gt; &amp;continuous_revolute_joints, const std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_hyperrectangle.html">geometry::optimization::Hyperrectangle</a> &gt; &amp;bboxes_A, const std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_hyperrectangle.html">geometry::optimization::Hyperrectangle</a> &gt; &amp;bboxes_B, <a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a> parallelism=<a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>())</td></tr>
<tr class="memdesc:ga8f0d035a7345f68adf751858f6b37a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <span class="tt"><a class="el" href="#ga6fbf6cf1ac5a9ea873bac401fc705117" title="Computes the pairwise intersections between two lists of convex sets, returning a list of edges,...">ComputePairwiseIntersections</a></span> allowing the user to supply axis- aligned bounding boxes if they're known a priori, to save on computation time.  <br /></td></tr>
<tr class="memitem:ga509c29f785727d4dbc7291a25a7da515" id="r_ga509c29f785727d4dbc7291a25a7da515"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt;, std::vector&lt; Eigen::VectorXd &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga509c29f785727d4dbc7291a25a7da515">ComputePairwiseIntersections</a> (const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;convex_sets, const std::vector&lt; int &gt; &amp;continuous_revolute_joints, bool preprocess_bbox=true, <a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a> parallelism=<a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>())</td></tr>
<tr class="memdesc:ga509c29f785727d4dbc7291a25a7da515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience overload to compute pairwise intersections within a list of convex sets.  <br /></td></tr>
<tr class="memitem:ga377049edc6e3731c7695c876af7a7fc6" id="r_ga377049edc6e3731c7695c876af7a7fc6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt;, std::vector&lt; Eigen::VectorXd &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga377049edc6e3731c7695c876af7a7fc6">ComputePairwiseIntersections</a> (const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;convex_sets, const std::vector&lt; int &gt; &amp;continuous_revolute_joints, const std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_hyperrectangle.html">geometry::optimization::Hyperrectangle</a> &gt; &amp;bboxes, <a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a> parallelism=<a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>())</td></tr>
<tr class="memdesc:ga377049edc6e3731c7695c876af7a7fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <span class="tt"><a class="el" href="#ga6fbf6cf1ac5a9ea873bac401fc705117" title="Computes the pairwise intersections between two lists of convex sets, returning a list of edges,...">ComputePairwiseIntersections</a></span> allowing the user to supply axis- aligned bounding boxes if they're known a priori, to save on computation time.  <br /></td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga80f9e107223dafa631c82a743f5ee64f" name="ga80f9e107223dafa631c82a743f5ee64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80f9e107223dafa631c82a743f5ee64f">&#9670;&#160;</a></span>CheckIfSatisfiesConvexityRadius()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CheckIfSatisfiesConvexityRadius </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">geometry::optimization::ConvexSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>convex_set</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>continuous_revolute_joints</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a convex set, and a list of indices corresponding to continuous revolute joints, checks whether or not the set satisfies the convexity radius. </p>
<p>See §6.5.3 of "A Panoramic View of Riemannian Geometry", Marcel Berger for a general definition of convexity radius. When dealing with continuous revolute joints, respecting the convexity radius entails that each convex set has a width of stricty less than π along each dimension corresponding to a continuous revolute joint. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if continuous_revolute_joints has repeated entries, or if any entry is outside the interval [0, convex_set.ambient_dimension()). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga509c29f785727d4dbc7291a25a7da515" name="ga509c29f785727d4dbc7291a25a7da515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga509c29f785727d4dbc7291a25a7da515">&#9670;&#160;</a></span>ComputePairwiseIntersections() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt;, std::vector&lt; Eigen::VectorXd &gt; &gt; ComputePairwiseIntersections </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>convex_sets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>continuous_revolute_joints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>preprocess_bbox</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a></td>          <td class="paramname"><span class="paramname"><em>parallelism</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience overload to compute pairwise intersections within a list of convex sets. </p>
<p>Equivalent to calling ComputePairwiseIntersections(convex_sets,
convex_sets, continuous_revolute_joints).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">convex_sets</td><td>is a vector of convex sets. Pairwise intersections will be computed within <span class="tt">convex_sets</span>. </td></tr>
    <tr><td class="paramname">continuous_revolute_joints</td><td>is a list of joint indices corresponding to continuous revolute joints. </td></tr>
    <tr><td class="paramname">preprocess_bbox</td><td>is a flag for whether the function should precompute axis-aligned bounding boxes for every set. This can speed up the pairwise intersection checks, by determining some sets to be disjoint without needing to solve an optimization problem. </td></tr>
    <tr><td class="paramname">parallelism</td><td>specifies the number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><span class="tt">continuous_revolute_joints</span> has repeated entries, or if any entry is outside the interval [0, ambient_dimension), where ambient_dimension is the ambient dimension of the convex sets in <span class="tt">convex_sets</span>. </td></tr>
    <tr><td class="paramname">if</td><td><span class="tt">convex_sets</span> is empty. </td></tr>
    <tr><td class="paramname">if</td><td>any entry of <span class="tt">convex_sets</span> is a nullptr. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga377049edc6e3731c7695c876af7a7fc6" name="ga377049edc6e3731c7695c876af7a7fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga377049edc6e3731c7695c876af7a7fc6">&#9670;&#160;</a></span>ComputePairwiseIntersections() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt;, std::vector&lt; Eigen::VectorXd &gt; &gt; ComputePairwiseIntersections </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>convex_sets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>continuous_revolute_joints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_hyperrectangle.html">geometry::optimization::Hyperrectangle</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bboxes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a></td>          <td class="paramname"><span class="paramname"><em>parallelism</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of <span class="tt"><a class="el" href="#ga6fbf6cf1ac5a9ea873bac401fc705117" title="Computes the pairwise intersections between two lists of convex sets, returning a list of edges,...">ComputePairwiseIntersections</a></span> allowing the user to supply axis- aligned bounding boxes if they're known a priori, to save on computation time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bboxes</td><td>is a vector of Hyperrectangles, allowing the user to manually pass in the AABBs of each set in <span class="tt">convex_sets</span> to avoid recomputation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The function does not check that the entries are indeed the AABBs corresponding to the sets in <span class="tt">convex_sets</span>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><span class="tt">convex_sets.size() != bboxes.size()</span> </td></tr>
    <tr><td class="paramname">if</td><td>not all entries of <span class="tt">convex_sets</span> and <span class="tt">bboxes</span> have the same ambient dimension. </td></tr>
    <tr><td class="paramname">if</td><td>any entry of <span class="tt">convex_sets</span> is a nullptr. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6fbf6cf1ac5a9ea873bac401fc705117" name="ga6fbf6cf1ac5a9ea873bac401fc705117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fbf6cf1ac5a9ea873bac401fc705117">&#9670;&#160;</a></span>ComputePairwiseIntersections() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt;, std::vector&lt; Eigen::VectorXd &gt; &gt; ComputePairwiseIntersections </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>convex_sets_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>convex_sets_B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>continuous_revolute_joints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>preprocess_bbox</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a></td>          <td class="paramname"><span class="paramname"><em>parallelism</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the pairwise intersections between two lists of convex sets, returning a list of edges, and a list of their corresponding offsets. </p>
<p>Each edge is a tuple in the form [index_A, index_B], where index_A is the index of the set in <span class="tt">convex_sets_A</span> and index_B is the index of the set in <span class="tt">convex_sets_B</span>. The corresponding entry in the list of offsets (i.e., the entry at the same index) is the translation that is applied to all the points in the index_A'th set in <span class="tt">convex_sets_A</span> to align them with the index_B'th set in <span class="tt">convex_sets_B</span>. This translation may only have non-zero entries along the dimensions corresponding to <span class="tt">continuous_revolute_joints</span>. All non-zero entries are integer multiples of 2π as the translation of the sets still represents the same configurations for the indices in <span class="tt">continuous_revolute_joints</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">convex_sets_A</td><td>is a vector of convex sets. Pairwise intersections will be computed between <span class="tt">convex_sets_A</span> and <span class="tt">convex_sets_B</span>. </td></tr>
    <tr><td class="paramname">convex_sets_B</td><td>is the other vector of convex sets. </td></tr>
    <tr><td class="paramname">continuous_revolute_joints</td><td>is a list of joint indices corresponding to continuous revolute joints. </td></tr>
    <tr><td class="paramname">preprocess_bbox</td><td>is a flag for whether the function should precompute axis-aligned bounding boxes (AABBs) for every set. This can speed up the pairwise intersection checks, by determining some sets to be disjoint without needing to solve an optimization problem. However, it does require some overhead to compute those bounding boxes. </td></tr>
    <tr><td class="paramname">parallelism</td><td>specifies the number of threads to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><span class="tt">continuous_revolute_joints</span> has repeated entries, or if any entry is outside the interval [0, ambient_dimension), where ambient_dimension is the ambient dimension of the convex sets in <span class="tt">convex_sets_A</span> and <span class="tt">convex_sets_B</span>. </td></tr>
    <tr><td class="paramname">if</td><td><span class="tt">convex_sets_A</span> or <span class="tt">convex_sets_B</span> are empty. </td></tr>
    <tr><td class="paramname">if</td><td>any entry of <span class="tt">convex_sets_A</span> or <span class="tt">convex_sets_B</span> is a nullptr. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8f0d035a7345f68adf751858f6b37a90" name="ga8f0d035a7345f68adf751858f6b37a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f0d035a7345f68adf751858f6b37a90">&#9670;&#160;</a></span>ComputePairwiseIntersections() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::pair&lt; int, int &gt; &gt;, std::vector&lt; Eigen::VectorXd &gt; &gt; ComputePairwiseIntersections </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>convex_sets_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>convex_sets_B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>continuous_revolute_joints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_hyperrectangle.html">geometry::optimization::Hyperrectangle</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bboxes_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_hyperrectangle.html">geometry::optimization::Hyperrectangle</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bboxes_B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a></td>          <td class="paramname"><span class="paramname"><em>parallelism</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of <span class="tt"><a class="el" href="#ga6fbf6cf1ac5a9ea873bac401fc705117" title="Computes the pairwise intersections between two lists of convex sets, returning a list of edges,...">ComputePairwiseIntersections</a></span> allowing the user to supply axis- aligned bounding boxes if they're known a priori, to save on computation time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bboxes_A</td><td>is a vector of Hyperrectangles, allowing the user to manually pass in the AABBs of each set in <span class="tt">convex_sets_A</span> to avoid recomputation. </td></tr>
    <tr><td class="paramname">bboxes_B</td><td>serves the same role to <span class="tt">convex_sets_B</span> as <span class="tt">bboxes_A</span> does to <span class="tt">convex_sets_A</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The function does not check that the entries of bboxes_A are indeed the AABBs corresponding to the sets in <span class="tt">convex_sets_A</span> (and likewise for bboxes_B).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><span class="tt">convex_sets_A.size() != bboxes_A.size()</span> </td></tr>
    <tr><td class="paramname">if</td><td><span class="tt">convex_sets_B.size() != bboxes_B.size()</span> </td></tr>
    <tr><td class="paramname">if</td><td>not all entries of <span class="tt">convex_sets_A</span>, <span class="tt">convex_sets_B</span>, <span class="tt">bboxes_A</span>, and <span class="tt">bboxes_B</span> have the same ambient dimension. </td></tr>
    <tr><td class="paramname">if</td><td>any entry of <span class="tt">convex_sets_A</span> or <span class="tt">convex_sets_B</span> is a nullptr. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4cc1511a0a4979afa70ee7d5964bc0d5" name="ga4cc1511a0a4979afa70ee7d5964bc0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cc1511a0a4979afa70ee7d5964bc0d5">&#9670;&#160;</a></span>PartitionConvexSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">geometry::optimization::ConvexSets</a> PartitionConvexSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">geometry::optimization::ConvexSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>convex_set</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>continuous_revolute_joints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>epsilon</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-5</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partitions a convex set into (smaller) convex sets whose union is the original set and that each respect the convexity radius as in CheckIfSatisfiesConvexityRadius. </p>
<p>In practice, this is implemented as partitioning sets into pieces whose width is less than or equal to π-ϵ. Each entry in continuous_revolute_joints must be non-negative, less than num_positions, and unique. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">epsilon</td><td>is the ϵ value used for the convexity radius inequality. The partitioned sets are made by intersecting convex_set with axis-aligned bounding boxes that respect the convexity radius. These boxes are made to overlap by ϵ radians along each dimension, for numerical purposes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vector of convex sets that each respect convexity radius. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if ϵ &lt;= 0 or ϵ &gt;= π. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the input convex set is unbounded along dimensions corresponding to continuous revolute joints. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if continuous_revolute_joints has repeated entries, or if any entry is outside the interval [0, convex_set.ambient_dimension()). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga40707ecfcee3ff6cc60fdf7cd0956166" name="ga40707ecfcee3ff6cc60fdf7cd0956166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40707ecfcee3ff6cc60fdf7cd0956166">&#9670;&#160;</a></span>PartitionConvexSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">geometry::optimization::ConvexSets</a> PartitionConvexSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">geometry::optimization::ConvexSets</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>convex_sets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>continuous_revolute_joints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>epsilon</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-5</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function overload to take in a list of convex sets, and partition all so as to respect the convexity radius. </p>
<p>Every set must be bounded and have the same ambient dimension. Each entry in continuous_revolute_joints must be non-negative, less than num_positions, and unique. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>unless every <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html" title="Abstract base class for defining a convex set.">ConvexSet</a> in convex_sets has the same ambient_dimension. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if ϵ &lt;= 0 or ϵ &gt;= π. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if any input convex set is unbounded along dimensions corresponding to continuous revolute joints. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if continuous_revolute_joints has repeated entries, or if any entry is outside the interval [0, ambient_dimension). </td></tr>
    <tr><td class="paramname">if</td><td>any entry of <span class="tt">convex_sets</span> is a nullptr. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="https://accessibility.mit.edu/" class="site-menu-item">Accessibility</a>
        </li>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
