<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: SurfaceMesh&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1geometry_1_1_surface_mesh.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdrake_1_1geometry_1_1_surface_mesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SurfaceMesh&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class drake::geometry::SurfaceMesh&lt; T &gt;</h3>

<p>SurfaceMesh represents a triangulated surface. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The underlying scalar type for coordinates, e.g., double or AutoDiffXd. Must be a valid Eigen scalar. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/geometry/proximity/surface_mesh.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a386190f8d3a1bcb42e5c997df1eb0d3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a386190f8d3a1bcb42e5c997df1eb0d3f">SurfaceMesh</a> (std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1_surface_face.html">SurfaceFace</a> &gt; &amp;&amp;<a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a0c7411608834b8d21a5b5c5981f3b625">faces</a>, std::vector&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;&amp;<a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#ae7f810a1d8f914db3d27e1fb817e7341">vertices</a>)</td></tr>
<tr class="memdesc:a386190f8d3a1bcb42e5c997df1eb0d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html" title="SurfaceMesh represents a triangulated surface.">SurfaceMesh</a> from faces and vertices.  <a href="#a386190f8d3a1bcb42e5c997df1eb0d3f">More...</a><br /></td></tr>
<tr class="separator:a386190f8d3a1bcb42e5c997df1eb0d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505ea28f0f6274285a379c870c44bb37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a505ea28f0f6274285a379c870c44bb37">TransformVertices</a> (const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;X_NM)</td></tr>
<tr class="memdesc:a505ea28f0f6274285a379c870c44bb37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the vertices of this mesh from its initial frame M to the new frame N.  <a href="#a505ea28f0f6274285a379c870c44bb37">More...</a><br /></td></tr>
<tr class="separator:a505ea28f0f6274285a379c870c44bb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9e33a8f7704980ea0a0f3a4455eaf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a3c9e33a8f7704980ea0a0f3a4455eaf7">ReverseFaceWinding</a> ()</td></tr>
<tr class="memdesc:a3c9e33a8f7704980ea0a0f3a4455eaf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the ordering of all the faces' indices &ndash; see <a class="el" href="classdrake_1_1geometry_1_1_surface_face.html#abbf26ae8eecf8c41273ed83dd213cbf1" title="Reverses the order of the vertex indices – this essentially flips the face normal based on the right-...">SurfaceFace::ReverseWinding()</a>.  <a href="#a3c9e33a8f7704980ea0a0f3a4455eaf7">More...</a><br /></td></tr>
<tr class="separator:a3c9e33a8f7704980ea0a0f3a4455eaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132d1bbcbcc1ac76319da744805bd865"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a132d1bbcbcc1ac76319da744805bd865">num_faces</a> () const</td></tr>
<tr class="memdesc:a132d1bbcbcc1ac76319da744805bd865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of triangular elements in the mesh.  <a href="#a132d1bbcbcc1ac76319da744805bd865">More...</a><br /></td></tr>
<tr class="separator:a132d1bbcbcc1ac76319da744805bd865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3140454e38db89c3828b2a7403b7d31b"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a3140454e38db89c3828b2a7403b7d31b">area</a> (<a class="el" href="namespacedrake_1_1geometry.html#a831785d5225564e2a531b4fd2445e1d6">SurfaceFaceIndex</a> f) const</td></tr>
<tr class="memdesc:a3140454e38db89c3828b2a7403b7d31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns area of a triangular element.  <a href="#a3140454e38db89c3828b2a7403b7d31b">More...</a><br /></td></tr>
<tr class="separator:a3140454e38db89c3828b2a7403b7d31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8645defeea4264d39cf1bdf5a66f79"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a5d8645defeea4264d39cf1bdf5a66f79">total_area</a> () const</td></tr>
<tr class="memdesc:a5d8645defeea4264d39cf1bdf5a66f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total area of all the faces of this surface mesh.  <a href="#a5d8645defeea4264d39cf1bdf5a66f79">More...</a><br /></td></tr>
<tr class="separator:a5d8645defeea4264d39cf1bdf5a66f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cea9ade9f49af04428bf8a5e0d45d3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#ad4cea9ade9f49af04428bf8a5e0d45d3">face_normal</a> (<a class="el" href="namespacedrake_1_1geometry.html#a831785d5225564e2a531b4fd2445e1d6">SurfaceFaceIndex</a> f) const</td></tr>
<tr class="memdesc:ad4cea9ade9f49af04428bf8a5e0d45d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unit face normal vector of a triangle.  <a href="#ad4cea9ade9f49af04428bf8a5e0d45d3">More...</a><br /></td></tr>
<tr class="separator:ad4cea9ade9f49af04428bf8a5e0d45d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819bca2023eaa88015e3e51f6e9f557e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a819bca2023eaa88015e3e51f6e9f557e">centroid</a> () const</td></tr>
<tr class="memdesc:a819bca2023eaa88015e3e51f6e9f557e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the area-weighted geometric centroid of this surface mesh.  <a href="#a819bca2023eaa88015e3e51f6e9f557e">More...</a><br /></td></tr>
<tr class="separator:a819bca2023eaa88015e3e51f6e9f557e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa6c922c0f29dfb284258ec90cc033b"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:a3aa6c922c0f29dfb284258ec90cc033b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="namespacedrake_1_1geometry.html#a74b8d905842571b365085fdd17378772">promoted_numerical_t</a>&lt; T, B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a3aa6c922c0f29dfb284258ec90cc033b">CalcCartesianFromBarycentric</a> (<a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a48adb138392ceecf5c0bf71621b112c2">ElementIndex</a> element_index, const <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a5e229cb5af7ebca7873b3cd7b92f0d61">Barycentric</a>&lt; B &gt; &amp;b_Q) const</td></tr>
<tr class="memdesc:a3aa6c922c0f29dfb284258ec90cc033b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the barycentric coordinates <code>Q_barycentric</code> of a point Q in <code>element_index</code> to its position vector p_MQ.  <a href="#a3aa6c922c0f29dfb284258ec90cc033b">More...</a><br /></td></tr>
<tr class="separator:a3aa6c922c0f29dfb284258ec90cc033b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a86ccf3206f923e2f7117d9af7fa4a3"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a9a86ccf3206f923e2f7117d9af7fa4a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="namespacedrake_1_1geometry.html#a74b8d905842571b365085fdd17378772">promoted_numerical_t</a>&lt; T, C &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a9a86ccf3206f923e2f7117d9af7fa4a3">CalcBarycentric</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; C &gt; &amp;p_MQ, <a class="el" href="namespacedrake_1_1geometry.html#a831785d5225564e2a531b4fd2445e1d6">SurfaceFaceIndex</a> f) const</td></tr>
<tr class="memdesc:a9a86ccf3206f923e2f7117d9af7fa4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate barycentric coordinates with respect to the triangular face <code>f</code> of the point Q'.  <a href="#a9a86ccf3206f923e2f7117d9af7fa4a3">More...</a><br /></td></tr>
<tr class="separator:a9a86ccf3206f923e2f7117d9af7fa4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972cf7cd80fb7a8357c8202a6c163612"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;, <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a972cf7cd80fb7a8357c8202a6c163612">CalcBoundingBox</a> () const</td></tr>
<tr class="memdesc:a972cf7cd80fb7a8357c8202a6c163612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the axis-aligned bounding box of this surface mesh M.  <a href="#a972cf7cd80fb7a8357c8202a6c163612">More...</a><br /></td></tr>
<tr class="separator:a972cf7cd80fb7a8357c8202a6c163612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb47c1c5d4b900ae43af5f0fb2be1135"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#abb47c1c5d4b900ae43af5f0fb2be1135">Equal</a> (const <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&lt; T &gt; &amp;mesh) const</td></tr>
<tr class="memdesc:abb47c1c5d4b900ae43af5f0fb2be1135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see whether the given <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html" title="SurfaceMesh represents a triangulated surface.">SurfaceMesh</a> object is equal via deep exact comparison.  <a href="#abb47c1c5d4b900ae43af5f0fb2be1135">More...</a><br /></td></tr>
<tr class="separator:abb47c1c5d4b900ae43af5f0fb2be1135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab604c0b9035b1aba5e1c5f44e5922875"><td class="memTemplParams" colspan="2">template&lt;typename FieldValue &gt; </td></tr>
<tr class="memitem:ab604c0b9035b1aba5e1c5f44e5922875"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; FieldValue &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#ab604c0b9035b1aba5e1c5f44e5922875">CalcGradientVectorOfLinearField</a> (const std::array&lt; FieldValue, 3 &gt; &amp;field_value, <a class="el" href="namespacedrake_1_1geometry.html#a831785d5225564e2a531b4fd2445e1d6">SurfaceFaceIndex</a> f) const</td></tr>
<tr class="memdesc:ab604c0b9035b1aba5e1c5f44e5922875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the gradient ∇u of a linear field u on the triangle <code>f</code>.  <a href="#ab604c0b9035b1aba5e1c5f44e5922875">More...</a><br /></td></tr>
<tr class="separator:ab604c0b9035b1aba5e1c5f44e5922875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:afdbad8c2048d841ad236bd4d21bf8020"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#afdbad8c2048d841ad236bd4d21bf8020">SurfaceMesh</a> (const <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a> &amp;)=default</td></tr>
<tr class="separator:afdbad8c2048d841ad236bd4d21bf8020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41ba3aab00f72747105e9a6260ebffb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#ab41ba3aab00f72747105e9a6260ebffb">operator=</a> (const <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a> &amp;)=default</td></tr>
<tr class="separator:ab41ba3aab00f72747105e9a6260ebffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b8c0082bf0fb73fd0bfb583f7c4576"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#ae0b8c0082bf0fb73fd0bfb583f7c4576">SurfaceMesh</a> (<a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ae0b8c0082bf0fb73fd0bfb583f7c4576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c74f3a8e177d94bd19b0542754bb51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a06c74f3a8e177d94bd19b0542754bb51">operator=</a> (<a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a06c74f3a8e177d94bd19b0542754bb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a078f09c85e0286978572a6624027b71b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a078f09c85e0286978572a6624027b71b">internal::MeshDeformer&lt; SurfaceMesh&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:a078f09c85e0286978572a6624027b71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58584b0686ae529c43df85ba38cef480"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a58584b0686ae529c43df85ba38cef480">SurfaceMeshTester&lt; T &gt;</a></td></tr>
<tr class="separator:a58584b0686ae529c43df85ba38cef480"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Mesh type traits</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpfc37eb5631f33a34b4f8b7fd41bb2a6b"></a>A collection of type traits to enable mesh consumers to be templated on mesh type.</p>
<p>Each mesh type provides specific definitions of <em>vertex</em>, <em>element</em>, and <em>barycentric coordinates</em>. For SurfaceMesh, an element is a triangle. </p>
</td></tr>
<tr class="memitem:a6aec7d49d25322d8fae54028059d27aa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a6aec7d49d25322d8fae54028059d27aa">ScalarType</a> = T</td></tr>
<tr class="separator:a6aec7d49d25322d8fae54028059d27aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6d6a4887cc355b6024af7a2a5417a2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a6a6d6a4887cc355b6024af7a2a5417a2">VertexIndex</a> = <a class="el" href="namespacedrake_1_1geometry.html#a4b6bae4ff910e57daa4b0ac8e4f481b8">SurfaceVertexIndex</a></td></tr>
<tr class="memdesc:a6a6d6a4887cc355b6024af7a2a5417a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index for identifying a vertex.  <a href="#a6a6d6a4887cc355b6024af7a2a5417a2">More...</a><br /></td></tr>
<tr class="separator:a6a6d6a4887cc355b6024af7a2a5417a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48adb138392ceecf5c0bf71621b112c2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a48adb138392ceecf5c0bf71621b112c2">ElementIndex</a> = <a class="el" href="namespacedrake_1_1geometry.html#a831785d5225564e2a531b4fd2445e1d6">SurfaceFaceIndex</a></td></tr>
<tr class="memdesc:a48adb138392ceecf5c0bf71621b112c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index for identifying a triangular element.  <a href="#a48adb138392ceecf5c0bf71621b112c2">More...</a><br /></td></tr>
<tr class="separator:a48adb138392ceecf5c0bf71621b112c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e229cb5af7ebca7873b3cd7b92f0d61"><td class="memTemplParams" colspan="2">template&lt;typename U  = T&gt; </td></tr>
<tr class="memitem:a5e229cb5af7ebca7873b3cd7b92f0d61"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a5e229cb5af7ebca7873b3cd7b92f0d61">Barycentric</a> = <a class="el" href="namespacedrake.html#a01ae662d5635b7c9efe03d15d976f7a8">Vector</a>&lt; U, <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a39b0509ce7179535d6b30f11fb305dc6">kVertexPerElement</a> &gt;</td></tr>
<tr class="memdesc:a5e229cb5af7ebca7873b3cd7b92f0d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of barycentric coordinates on a triangular element.  <a href="#a5e229cb5af7ebca7873b3cd7b92f0d61">More...</a><br /></td></tr>
<tr class="separator:a5e229cb5af7ebca7873b3cd7b92f0d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b0509ce7179535d6b30f11fb305dc6"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a39b0509ce7179535d6b30f11fb305dc6">kVertexPerElement</a> = 3</td></tr>
<tr class="memdesc:a39b0509ce7179535d6b30f11fb305dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of vertices per element.  <a href="#a39b0509ce7179535d6b30f11fb305dc6">More...</a><br /></td></tr>
<tr class="separator:a39b0509ce7179535d6b30f11fb305dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7520f8d9a0d5e63e46cea0cb40db45"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1geometry_1_1_surface_face.html">SurfaceFace</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a0e7520f8d9a0d5e63e46cea0cb40db45">element</a> (<a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a48adb138392ceecf5c0bf71621b112c2">ElementIndex</a> e) const</td></tr>
<tr class="memdesc:a0e7520f8d9a0d5e63e46cea0cb40db45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the triangular element identified by a given index.  <a href="#a0e7520f8d9a0d5e63e46cea0cb40db45">More...</a><br /></td></tr>
<tr class="separator:a0e7520f8d9a0d5e63e46cea0cb40db45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7411608834b8d21a5b5c5981f3b625"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1_surface_face.html">SurfaceFace</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a0c7411608834b8d21a5b5c5981f3b625">faces</a> () const</td></tr>
<tr class="memdesc:a0c7411608834b8d21a5b5c5981f3b625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the faces.  <a href="#a0c7411608834b8d21a5b5c5981f3b625">More...</a><br /></td></tr>
<tr class="separator:a0c7411608834b8d21a5b5c5981f3b625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f810a1d8f914db3d27e1fb817e7341"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#ae7f810a1d8f914db3d27e1fb817e7341">vertices</a> () const</td></tr>
<tr class="memdesc:ae7f810a1d8f914db3d27e1fb817e7341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vertices.  <a href="#ae7f810a1d8f914db3d27e1fb817e7341">More...</a><br /></td></tr>
<tr class="separator:ae7f810a1d8f914db3d27e1fb817e7341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdc05463135b39ff5b4892a33a1faf2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#abbdc05463135b39ff5b4892a33a1faf2">vertex</a> (<a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a6a6d6a4887cc355b6024af7a2a5417a2">VertexIndex</a> v) const</td></tr>
<tr class="memdesc:abbdc05463135b39ff5b4892a33a1faf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vertex identified by a given index.  <a href="#abbdc05463135b39ff5b4892a33a1faf2">More...</a><br /></td></tr>
<tr class="separator:abbdc05463135b39ff5b4892a33a1faf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319e621fc359dd8daad48247f95b12fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a319e621fc359dd8daad48247f95b12fa">num_vertices</a> () const</td></tr>
<tr class="memdesc:a319e621fc359dd8daad48247f95b12fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of vertices in the mesh.  <a href="#a319e621fc359dd8daad48247f95b12fa">More...</a><br /></td></tr>
<tr class="separator:a319e621fc359dd8daad48247f95b12fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f8a4ac27c2c8008728ae504e8e68bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a98f8a4ac27c2c8008728ae504e8e68bc">num_elements</a> () const</td></tr>
<tr class="memdesc:a98f8a4ac27c2c8008728ae504e8e68bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of triangles in the mesh.  <a href="#a98f8a4ac27c2c8008728ae504e8e68bc">More...</a><br /></td></tr>
<tr class="separator:a98f8a4ac27c2c8008728ae504e8e68bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5e229cb5af7ebca7873b3cd7b92f0d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e229cb5af7ebca7873b3cd7b92f0d61">&#9670;&nbsp;</a></span>Barycentric</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a5e229cb5af7ebca7873b3cd7b92f0d61">Barycentric</a> =  <a class="el" href="namespacedrake.html#a01ae662d5635b7c9efe03d15d976f7a8">Vector</a>&lt;U, <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a39b0509ce7179535d6b30f11fb305dc6">kVertexPerElement</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of barycentric coordinates on a triangular element. </p>
<p>Barycentric coordinates (b₀, b₁, b₂) satisfy b₀ + b₁ + b₂ = 1. It corresponds to a position on the plane of the triangle. If all bᵢ &gt;= 0, it corresponds to a position inside the triangle or on the edges of the triangle. If some bᵢ &lt; 0, it corresponds to a position on the plane of the triangle that is outside the triangle. Technically we could calculate one of the bᵢ from the others; however, there is no standard way to omit one of the coordinates.</p>
<p>The barycentric coordinates for a point Q are notated a b_Q. </p>

</div>
</div>
<a id="a48adb138392ceecf5c0bf71621b112c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48adb138392ceecf5c0bf71621b112c2">&#9670;&nbsp;</a></span>ElementIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a48adb138392ceecf5c0bf71621b112c2">ElementIndex</a> =  <a class="el" href="namespacedrake_1_1geometry.html#a831785d5225564e2a531b4fd2445e1d6">SurfaceFaceIndex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index for identifying a triangular element. </p>

</div>
</div>
<a id="a6aec7d49d25322d8fae54028059d27aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aec7d49d25322d8fae54028059d27aa">&#9670;&nbsp;</a></span>ScalarType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a6aec7d49d25322d8fae54028059d27aa">ScalarType</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a6d6a4887cc355b6024af7a2a5417a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6d6a4887cc355b6024af7a2a5417a2">&#9670;&nbsp;</a></span>VertexIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a6a6d6a4887cc355b6024af7a2a5417a2">VertexIndex</a> =  <a class="el" href="namespacedrake_1_1geometry.html#a4b6bae4ff910e57daa4b0ac8e4f481b8">SurfaceVertexIndex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index for identifying a vertex. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afdbad8c2048d841ad236bd4d21bf8020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdbad8c2048d841ad236bd4d21bf8020">&#9670;&nbsp;</a></span>SurfaceMesh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0b8c0082bf0fb73fd0bfb583f7c4576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b8c0082bf0fb73fd0bfb583f7c4576">&#9670;&nbsp;</a></span>SurfaceMesh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a386190f8d3a1bcb42e5c997df1eb0d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386190f8d3a1bcb42e5c997df1eb0d3f">&#9670;&nbsp;</a></span>SurfaceMesh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1_surface_face.html">SurfaceFace</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html" title="SurfaceMesh represents a triangulated surface.">SurfaceMesh</a> from faces and vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">faces</td><td>The triangular faces. </td></tr>
    <tr><td class="paramname">vertices</td><td>The vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3140454e38db89c3828b2a7403b7d31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3140454e38db89c3828b2a7403b7d31b">&#9670;&nbsp;</a></span>area()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; area </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a831785d5225564e2a531b4fd2445e1d6">SurfaceFaceIndex</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns area of a triangular element. </p>

</div>
</div>
<a id="a9a86ccf3206f923e2f7117d9af7fa4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a86ccf3206f923e2f7117d9af7fa4a3">&#9670;&nbsp;</a></span>CalcBarycentric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;<a class="el" href="namespacedrake_1_1geometry.html#a74b8d905842571b365085fdd17378772">promoted_numerical_t</a>&lt;T, C&gt; &gt; CalcBarycentric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_MQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a831785d5225564e2a531b4fd2445e1d6">SurfaceFaceIndex</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate barycentric coordinates with respect to the triangular face <code>f</code> of the point Q'. </p>
<p>Q' is the projection of the provided point Q on the plane of triangle <code>f</code>. If Q lies on the plane, Q = Q'. This operation is expensive compared with going from barycentric to Cartesian.</p>
<p>The return type depends on both the mesh's vertex position scalar type <code>T</code> and the Cartesian coordinate type <code>C</code> of the query point. See <a class="el" href="structdrake_1_1geometry_1_1promoted__numerical.html">promoted_numerical_t</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_MQ</td><td>The position of point Q measured and expressed in the mesh's frame M. </td></tr>
    <tr><td class="paramname">f</td><td>The index of a triangular face. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">b_Q'</td><td>The barycentric coordinates of Q' (projection of Q onto <code>f</code>'s plane) relative to triangle f. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If Q' is outside the triangle, the barycentric coordinates (b₀, b₁, b₂) still satisfy b₀ + b₁ + b₂ = 1; however, some bᵢ will be negative. </dd></dl>

</div>
</div>
<a id="a972cf7cd80fb7a8357c8202a6c163612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972cf7cd80fb7a8357c8202a6c163612">&#9670;&nbsp;</a></span>CalcBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt;, <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt; &gt; CalcBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the axis-aligned bounding box of this surface mesh M. </p>
<dl class="section return"><dt>Returns</dt><dd>the center and the size vector of the box expressed in M's frame. </dd></dl>

</div>
</div>
<a id="a3aa6c922c0f29dfb284258ec90cc033b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa6c922c0f29dfb284258ec90cc033b">&#9670;&nbsp;</a></span>CalcCartesianFromBarycentric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;<a class="el" href="namespacedrake_1_1geometry.html#a74b8d905842571b365085fdd17378772">promoted_numerical_t</a>&lt;T, B&gt; &gt; CalcCartesianFromBarycentric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a48adb138392ceecf5c0bf71621b112c2">ElementIndex</a>&#160;</td>
          <td class="paramname"><em>element_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a5e229cb5af7ebca7873b3cd7b92f0d61">Barycentric</a>&lt; B &gt; &amp;&#160;</td>
          <td class="paramname"><em>b_Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps the barycentric coordinates <code>Q_barycentric</code> of a point Q in <code>element_index</code> to its position vector p_MQ. </p>
<p>The return type depends on both the mesh's vertex position scalar type <code>T</code> and the Barycentric coordinate type <code>B</code> of the query point. See <a class="el" href="structdrake_1_1geometry_1_1promoted__numerical.html">promoted_numerical_t</a> for details. </p>

</div>
</div>
<a id="ab604c0b9035b1aba5e1c5f44e5922875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab604c0b9035b1aba5e1c5f44e5922875">&#9670;&nbsp;</a></span>CalcGradientVectorOfLinearField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;FieldValue&gt; CalcGradientVectorOfLinearField </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; FieldValue, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>field_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a831785d5225564e2a531b4fd2445e1d6">SurfaceFaceIndex</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the gradient ∇u of a linear field u on the triangle <code>f</code>. </p>
<p>Field u is defined by the three field values <code>field_value[i]</code> at the i-th vertex of the triangle. The gradient ∇u is expressed in the coordinates frame of this mesh M. </p>

</div>
</div>
<a id="a819bca2023eaa88015e3e51f6e9f557e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819bca2023eaa88015e3e51f6e9f557e">&#9670;&nbsp;</a></span>centroid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt;&amp; centroid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the area-weighted geometric centroid of this surface mesh. </p>
<p>The returned value is the position vector p_MSc from M's origin to the centroid Sc, expressed in frame M. (M is the frame in which this mesh's vertices are measured and expressed.) Note that the centroid is not necessarily a point on the surface. If the total mesh area is exactly zero, we define the centroid to be (0,0,0).</p>
<p>The centroid location is calculated <em>per face</em> not <em>per vertex</em> so is insensitive to whether vertices are shared by faces. </p>

</div>
</div>
<a id="a0e7520f8d9a0d5e63e46cea0cb40db45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7520f8d9a0d5e63e46cea0cb40db45">&#9670;&nbsp;</a></span>element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1geometry_1_1_surface_face.html">SurfaceFace</a>&amp; element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a48adb138392ceecf5c0bf71621b112c2">ElementIndex</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the triangular element identified by a given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The index of the triangular element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>e ∈ {0, 1, 2,..., <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a132d1bbcbcc1ac76319da744805bd865" title="Returns the number of triangular elements in the mesh.">num_faces()</a>-1}. </dd></dl>

</div>
</div>
<a id="abb47c1c5d4b900ae43af5f0fb2be1135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb47c1c5d4b900ae43af5f0fb2be1135">&#9670;&nbsp;</a></span>Equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see whether the given <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html" title="SurfaceMesh represents a triangulated surface.">SurfaceMesh</a> object is equal via deep exact comparison. </p>
<p>NaNs are treated as not equal as per the IEEE standard. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh for comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given mesh is equal. </dd></dl>

</div>
</div>
<a id="ad4cea9ade9f49af04428bf8a5e0d45d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cea9ade9f49af04428bf8a5e0d45d3">&#9670;&nbsp;</a></span>face_normal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt;&amp; face_normal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a831785d5225564e2a531b4fd2445e1d6">SurfaceFaceIndex</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the unit face normal vector of a triangle. </p>
<p>It respects the right-handed normal rule. A near-zero-area triangle may get an unreliable normal vector. A zero-area triangle will get a zero vector. </p><dl class="section pre"><dt>Precondition</dt><dd>f ∈ {0, 1, 2,..., <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a132d1bbcbcc1ac76319da744805bd865" title="Returns the number of triangular elements in the mesh.">num_faces()</a>-1}. </dd></dl>

</div>
</div>
<a id="a0c7411608834b8d21a5b5c5981f3b625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7411608834b8d21a5b5c5981f3b625">&#9670;&nbsp;</a></span>faces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdrake_1_1geometry_1_1_surface_face.html">SurfaceFace</a>&gt;&amp; faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the faces. </p>

</div>
</div>
<a id="a98f8a4ac27c2c8008728ae504e8e68bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f8a4ac27c2c8008728ae504e8e68bc">&#9670;&nbsp;</a></span>num_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of triangles in the mesh. </p>
<p>For SurfaceMesh, an element is a triangle. Returns the same number as <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a132d1bbcbcc1ac76319da744805bd865" title="Returns the number of triangular elements in the mesh.">num_faces()</a> and enables mesh consumers to be templated on mesh type. </p>

</div>
</div>
<a id="a132d1bbcbcc1ac76319da744805bd865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132d1bbcbcc1ac76319da744805bd865">&#9670;&nbsp;</a></span>num_faces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of triangular elements in the mesh. </p>

</div>
</div>
<a id="a319e621fc359dd8daad48247f95b12fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319e621fc359dd8daad48247f95b12fa">&#9670;&nbsp;</a></span>num_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of vertices in the mesh. </p>

</div>
</div>
<a id="ab41ba3aab00f72747105e9a6260ebffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41ba3aab00f72747105e9a6260ebffb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06c74f3a8e177d94bd19b0542754bb51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c74f3a8e177d94bd19b0542754bb51">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c9e33a8f7704980ea0a0f3a4455eaf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c9e33a8f7704980ea0a0f3a4455eaf7">&#9670;&nbsp;</a></span>ReverseFaceWinding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReverseFaceWinding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the ordering of all the faces' indices &ndash; see <a class="el" href="classdrake_1_1geometry_1_1_surface_face.html#abbf26ae8eecf8c41273ed83dd213cbf1" title="Reverses the order of the vertex indices – this essentially flips the face normal based on the right-...">SurfaceFace::ReverseWinding()</a>. </p>

</div>
</div>
<a id="a5d8645defeea4264d39cf1bdf5a66f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8645defeea4264d39cf1bdf5a66f79">&#9670;&nbsp;</a></span>total_area()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; total_area </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total area of all the faces of this surface mesh. </p>

</div>
</div>
<a id="a505ea28f0f6274285a379c870c44bb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505ea28f0f6274285a379c870c44bb37">&#9670;&nbsp;</a></span>TransformVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TransformVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_NM</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms the vertices of this mesh from its initial frame M to the new frame N. </p>

</div>
</div>
<a id="abbdc05463135b39ff5b4892a33a1faf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbdc05463135b39ff5b4892a33a1faf2">&#9670;&nbsp;</a></span>vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt;&amp; vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a6a6d6a4887cc355b6024af7a2a5417a2">VertexIndex</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vertex identified by a given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The index of the vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>v ∈ {0, 1, 2,...,<a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html#a319e621fc359dd8daad48247f95b12fa" title="Returns the number of vertices in the mesh.">num_vertices()</a>-1}. </dd></dl>

</div>
</div>
<a id="ae7f810a1d8f914db3d27e1fb817e7341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f810a1d8f914db3d27e1fb817e7341">&#9670;&nbsp;</a></span>vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt; &gt;&amp; vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vertices. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a078f09c85e0286978572a6624027b71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078f09c85e0286978572a6624027b71b">&#9670;&nbsp;</a></span>internal::MeshDeformer&lt; SurfaceMesh&lt; T &gt; &gt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::MeshDeformer&lt; <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&lt; T &gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a58584b0686ae529c43df85ba38cef480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58584b0686ae529c43df85ba38cef480">&#9670;&nbsp;</a></span>SurfaceMeshTester&lt; T &gt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh_tester.html">SurfaceMeshTester</a>&lt; T &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a39b0509ce7179535d6b30f11fb305dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b0509ce7179535d6b30f11fb305dc6">&#9670;&nbsp;</a></span>kVertexPerElement</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classint.html">int</a> kVertexPerElement = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of vertices per element. </p>
<p>A triangle has 3 vertices. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/geometry/proximity/<a class="el" href="surface__mesh_8h.html">surface_mesh.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1geometry.html">geometry</a></li><li class="navelem"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
