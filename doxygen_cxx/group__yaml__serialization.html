<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: YAML Serialization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__yaml__serialization.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">YAML Serialization <div class="ingroups"><a class="el" href="group__technical__notes.html">Technical Notes</a></div></div></div>
</div><!--header-->
<div class="contents">
<h2>Overview</h2>
<p>Drake provides infrastructure for reading YAML files into C++ structs, and writing C++ structs into YAML files. These functions are often used to read or write configuration data, but may also be used to serialize runtime data such as Diagram connections or OutputPort traces. Any C++ struct to be serialized must provide a <a class="el" href="#implementing_serialize">Serialize()</a> function to enumerate its fields.</p>
<h2>Examples</h2>
<p>Given a struct definition:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyData {</div>
<div class="line">  ...</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> foo{0.0};</div>
<div class="line">  std::vector&lt;double&gt; bar;</div>
<div class="line">};</div>
</div><!-- fragment --><h3>Loading</h3>
<p>Given a YAML data file:</p>
<div class="fragment"><div class="line">foo: 1.0</div>
<div class="line">bar: [2.0, 3.0]</div>
</div><!-- fragment --><p>We can use LoadYamlFile() to load the file:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  <span class="keyword">const</span> MyData data = LoadYamlFile&lt;MyData&gt;(<span class="stringliteral">&quot;filename.yaml&quot;</span>);</div>
<div class="line">  std::cout &lt;&lt; fmt::format(<span class="stringliteral">&quot;foo = {:.1f}\n&quot;</span>, data.foo);</div>
<div class="line">  std::cout &lt;&lt; fmt::format(<span class="stringliteral">&quot;bar = {:.1f}\n&quot;</span>, fmt::join(data.bar, <span class="stringliteral">&quot;, &quot;</span>));</div>
<div class="line">}</div>
</div><!-- fragment --><p>Output:</p>
<div class="fragment"><div class="line">foo = 1.0</div>
<div class="line">bar = 2.0, 3.0</div>
</div><!-- fragment --><h3>Saving</h3>
<p>We can use SaveYamlFile() to save to a file:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  MyData data{4.0, {5.0, 6.0}};</div>
<div class="line">  <a class="code hl_function" href="namespacedrake_1_1yaml.html#ab3b6d04d37236596751e626ed6aa3b5e">SaveYamlFile</a>(<span class="stringliteral">&quot;filename.yaml&quot;</span>, data);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacedrake_1_1yaml_html_ab3b6d04d37236596751e626ed6aa3b5e"><div class="ttname"><a href="namespacedrake_1_1yaml.html#ab3b6d04d37236596751e626ed6aa3b5e">drake::yaml::SaveYamlFile</a></div><div class="ttdeci">void SaveYamlFile(const std::string &amp;filename, const Serializable &amp;data, const std::optional&lt; std::string &gt; &amp;child_name=std::nullopt, const std::optional&lt; Serializable &gt; &amp;defaults=std::nullopt)</div><div class="ttdoc">Saves data as a YAML-formatted file.</div><div class="ttdef"><b>Definition</b> yaml_io.h:200</div></div>
</div><!-- fragment --><p>Output file:</p>
<div class="fragment"><div class="line">foo: 4.0</div>
<div class="line">bar: [5.0, 6.0]</div>
</div><!-- fragment --><p>The following sections explain each of these steps in more detail, along with the customization options that are available for each one.</p>
<p><a class="anchor" id="implementing_serialize"></a></p><h2>Implementing Serialize</h2>
<p>Any C++ struct to be serialized must provide a templated <span class="tt">Serialize()</span> function that enumerates the fields. Typically, <span class="tt">Serialize()</span> will be implemented via a member function on the struct, but if necessary it can also be a free function obtained via argument-dependent lookup.</p>
<p>Here is an example of implementing a Serialize member function:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyData {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Archive&gt;</div>
<div class="line">  <span class="keywordtype">void</span> Serialize(Archive* a) {</div>
<div class="line">    a-&gt;Visit(<a class="code hl_define" href="name__value_8h.html#a1e095c8e1bdc141709c1bb22aca6d944">DRAKE_NVP</a>(foo));</div>
<div class="line">    a-&gt;Visit(<a class="code hl_define" href="name__value_8h.html#a1e095c8e1bdc141709c1bb22aca6d944">DRAKE_NVP</a>(bar));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> foo{0.0};</div>
<div class="line">  std::vector&lt;double&gt; bar;</div>
<div class="line">};</div>
<div class="ttc" id="aname__value_8h_html_a1e095c8e1bdc141709c1bb22aca6d944"><div class="ttname"><a href="name__value_8h.html#a1e095c8e1bdc141709c1bb22aca6d944">DRAKE_NVP</a></div><div class="ttdeci">#define DRAKE_NVP(x)</div><div class="ttdoc">Creates a NameValue pair for an lvalue x.</div><div class="ttdef"><b>Definition</b> name_value.h:62</div></div>
</div><!-- fragment --><p>Structures can be arbitrarily nested, as long as each <span class="tt">struct</span> has a <span class="tt">Serialize()</span> function:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MoreData {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Archive&gt;</div>
<div class="line">  <span class="keywordtype">void</span> Serialize(Archive* a) {</div>
<div class="line">    a-&gt;Visit(<a class="code hl_define" href="name__value_8h.html#a1e095c8e1bdc141709c1bb22aca6d944">DRAKE_NVP</a>(baz));</div>
<div class="line">    a-&gt;Visit(<a class="code hl_define" href="name__value_8h.html#a1e095c8e1bdc141709c1bb22aca6d944">DRAKE_NVP</a>(quux));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::string baz;</div>
<div class="line">  std::map&lt;std::string, MyData&gt; quux;</div>
<div class="line">};</div>
</div><!-- fragment --><p>For background information about visitor-based serialization, see also the <a href="https://www.boost.org/doc/libs/release/libs/serialization/doc/tutorial.html">Boost.Serialization Tutorial</a>, which served as the inspiration for Drake's design.</p>
<h3>Style guide for Serialize</h3>
<p>By convention, we place the Serialize function prior to the data members per <a href="https://drake.mit.edu/styleguide/cppguide.html#Declaration_Order">the styleguide rule</a>. Each data member has a matching <span class="tt">Visit</span> line in the Serialize function, in the same order as the member fields appear.</p>
<p>By convention, we declare all of the member fields as public, since they are effectively so anyway (because anything that calls the Serialize function receives a mutable pointer to them). The typical way to do this is to declare the data as a <span class="tt">struct</span>, instead of a <span class="tt">class</span>.</p>
<p>However, if <a href="https://drake.mit.edu/styleguide/cppguide.html#Structs_vs._Classes">the styleguide rule</a> for struct vs class points towards using a <span class="tt">class</span> instead, then we follow that advice and make it a <span class="tt">class</span>, but we explicitly label the member fields as <span class="tt">public</span>. We also omit the trailing underscore from the field names, so that the Serialize API presented to the caller of the class is indifferent to whether it is phrased as a <span class="tt">struct</span> or a <span class="tt">class</span>. See <a class="el" href="classdrake_1_1schema_1_1_gaussian.html" title="A gaussian distribution with mean and stddev.">drake::schema::Gaussian</a> for an example of this situation.</p>
<p>If the member fields have invariants that must be immediately enforced during de-serialization, then we add invariant checks to the end of the <span class="tt">Serialize()</span> function to enforce that, and we mark the class fields private (adding back the usual trailing underscore). See <a class="el" href="classdrake_1_1math_1_1_bspline_basis.html" title="Given a set of non-descending breakpoints t₀ ≤ t₁ ≤ ⋅⋅⋅ ≤ tₘ, a B-spline basis of order k is a set of...">drake::math::BsplineBasis</a> for an example of this situation.</p>
<h3>Built-in types</h3>
<p>Drake's YAML I/O functions provide built-in support for many common types:</p><ul>
<li>bool</li>
<li>double</li>
<li>float</li>
<li>int32_t</li>
<li>int64_t</li>
<li>uint32_t</li>
<li>uint64_t</li>
<li>std::array</li>
<li>std::map</li>
<li>std::optional</li>
<li>std::string</li>
<li>std::unordered_map</li>
<li>std::variant</li>
<li>std::vector</li>
<li>Eigen::Matrix (including 1-dimensional matrices, i.e., vectors)</li>
</ul>
<h3>YAML correspondence</h3>
<p>The simple types (<span class="tt">std::string</span>, <span class="tt">bool</span>, floating-point number, integers) all serialize to a <a href="https://yaml.org/spec/1.2.2/#scalars">Scalar</a> node in YAML.</p>
<p>The array-like types (<span class="tt">std::array</span>, <span class="tt">std::vector</span>, <span class="tt">Eigen::Matrix</span>) all serialize to a <a href="https://yaml.org/spec/1.2.2/#collections">Sequence</a> node in YAML.</p>
<p>User-defined structs and the native maps (<span class="tt">std::map</span>, <span class="tt">std::unordered_map</span>) all serialize to a <a href="https://yaml.org/spec/1.2.2/#collections">Mapping</a> node in YAML.</p>
<p>For the treatment of <span class="tt">std::optional</span>, refer to <a class="el" href="#serialize_nullable">Nullable types</a>, below. For the treatment of <span class="tt">std::variant</span>, refer to <a class="el" href="#serialize_variant">Sum types</a>, below.</p>
<h2>Reading YAML files</h2>
<p>Use LoadYamlFile() or LoadYamlString() to de-serialize YAML-formatted string data into C++ structure.</p>
<p>It's often useful to write a helper function to load using a specific schema, in this case the <span class="tt">MyData</span> schema:</p>
<div class="fragment"><div class="line">MyData LoadMyData(<span class="keyword">const</span> std::string&amp; filename) {</div>
<div class="line">  <span class="keywordflow">return</span> LoadYamlFile&lt;MyData&gt;(filename);</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  <span class="keyword">const</span> MyData data = LoadMyData(<span class="stringliteral">&quot;filename.yaml&quot;</span>);</div>
<div class="line">  std::cout &lt;&lt; fmt::format(<span class="stringliteral">&quot;foo = {:.1f}\n&quot;</span>, data.foo);</div>
<div class="line">  std::cout &lt;&lt; fmt::format(<span class="stringliteral">&quot;bar = {:.1f}\n&quot;</span>, fmt::join(data.bar, <span class="stringliteral">&quot;, &quot;</span>));</div>
<div class="line">}</div>
</div><!-- fragment --><p>Sample data in <span class="tt">filename.yaml</span>: </p><div class="fragment"><div class="line">foo: 1.0</div>
<div class="line">bar: [2.0, 3.0]</div>
</div><!-- fragment --><p>Sample output:</p>
<div class="fragment"><div class="line">foo = 1.0</div>
<div class="line">bar = 2.0, 3.0</div>
</div><!-- fragment --><p>There is also an option to load from a top-level child in the document:</p>
<div class="fragment"><div class="line">data_1:</div>
<div class="line">  foo: 1.0</div>
<div class="line">  bar: [2.0, 3.0]</div>
<div class="line">data_2:</div>
<div class="line">  foo: 4.0</div>
<div class="line">  bar: [5.0, 6.0]</div>
</div><!-- fragment --><div class="fragment"><div class="line">MyData LoadMyData2(<span class="keyword">const</span> std::string&amp; filename) {</div>
<div class="line">  <span class="keywordflow">return</span> LoadYamlFile&lt;MyData&gt;(filename, <span class="stringliteral">&quot;data_2&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Sample output:</p>
<div class="fragment"><div class="line">foo = 4.0</div>
<div class="line">bar = 5.0, 6.0</div>
</div><!-- fragment --><h3>Defaults</h3>
<p>The LoadYamlFile() function offers a <span class="tt">defaults = ...</span> argument. When provided, the yaml file's contents will overwrite the provided defaults, but any fields that are not mentioned in the yaml file will remain intact at their default values.</p>
<p>When merging file data atop any defaults, any <span class="tt">std::map</span> or <span class="tt">std::unordered_map</span> collections will merge the contents of the file alongside the existing map values, keeping anything in the default that is unchanged. Any other collections such as <span class="tt">std::vector</span> are entirely reset, even if they already had some values in place (in particular, they are not merely appended to).</p>
<h3>Merge keys</h3>
<p>YAML's "merge keys" (<a href="https://yaml.org/type/merge.html">https://yaml.org/type/merge.html</a>) are supported during loading. (However, the graph-aliasing relationship implied by nominal YAML semantics is not implemented; the merge keys are fully deep-copied.)</p>
<p>Example:</p>
<div class="fragment"><div class="line">_template: &amp;common_foo</div>
<div class="line">  foo: 1.0</div>
<div class="line">data_1:</div>
<div class="line">  &lt;&lt; : *common_foo</div>
<div class="line">  bar: [2.0, 3.0]</div>
<div class="line">data_2:</div>
<div class="line">  &lt;&lt; : *common_foo</div>
<div class="line">  bar: [5.0, 6.0]</div>
</div><!-- fragment --><h2>Writing YAML files</h2>
<p>Use SaveYamlFile() or SaveYamlString() to output a YAML-formatted serialization of a C++ structure.</p>
<p>The serialized output is always deterministic, even for unordered datatypes such as <span class="tt">std::unordered_map</span>.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyData {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Archive&gt;</div>
<div class="line">  <span class="keywordtype">void</span> Serialize(Archive* a) {</div>
<div class="line">    a-&gt;Visit(<a class="code hl_define" href="name__value_8h.html#a1e095c8e1bdc141709c1bb22aca6d944">DRAKE_NVP</a>(foo));</div>
<div class="line">    a-&gt;Visit(<a class="code hl_define" href="name__value_8h.html#a1e095c8e1bdc141709c1bb22aca6d944">DRAKE_NVP</a>(bar));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> foo{0.0};</div>
<div class="line">  std::vector&lt;double&gt; bar;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  MyData data{1.0, {2.0, 3.0}};</div>
<div class="line">  std::cout &lt;&lt; <a class="code hl_function" href="namespacedrake_1_1yaml.html#aaf418985a2d3d598d6191b2dc7576e4a">SaveYamlString</a>(data, <span class="stringliteral">&quot;root&quot;</span>);</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacedrake_1_1yaml_html_aaf418985a2d3d598d6191b2dc7576e4a"><div class="ttname"><a href="namespacedrake_1_1yaml.html#aaf418985a2d3d598d6191b2dc7576e4a">drake::yaml::SaveYamlString</a></div><div class="ttdeci">std::string SaveYamlString(const Serializable &amp;data, const std::optional&lt; std::string &gt; &amp;child_name=std::nullopt, const std::optional&lt; Serializable &gt; &amp;defaults=std::nullopt)</div><div class="ttdoc">Saves data as a YAML-formatted string.</div><div class="ttdef"><b>Definition</b> yaml_io.h:210</div></div>
</div><!-- fragment --><p>Output: </p><div class="fragment"><div class="line">root:</div>
<div class="line">  foo: 1.0</div>
<div class="line">  bar: [2.0, 3.0]</div>
</div><!-- fragment --><h2>Document root</h2>
<p>Usually, YAML reading or writing requires a serializable struct that matches the top-level YAML document. However, sometimes it's convenient to parse the document in the special case of a C++ <span class="tt">std::map</span> at the top level, without the need to define an enclosing struct.</p>
<div class="fragment"><div class="line">data_1:</div>
<div class="line">  foo: 1.0</div>
<div class="line">  bar: [2.0, 3.0]</div>
<div class="line">data_2:</div>
<div class="line">  foo: 4.0</div>
<div class="line">  bar: [5.0, 6.0]</div>
</div><!-- fragment --><div class="fragment"><div class="line">std::map&lt;std::string, MyData&gt; LoadAllMyData(<span class="keyword">const</span> std::string&amp; filename) {</div>
<div class="line">  <span class="keywordflow">return</span> LoadYamlFile&lt;std::map&lt;std::string, MyData&gt;&gt;(filename);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="serialize_nullable"></a></p><h2>Nullable types (std::optional)</h2>
<p>When a C++ field of type <span class="tt">std::optional</span> is present, then:</p><ul>
<li>when saving its enclosing struct as YAML data, if the optional is nullopt, then no mapping entry will be emitted.</li>
<li>when load its enclosing struct from YAML data, if no mapping entry is present in the YAML, then it is not an error.</li>
</ul>
<p><a class="anchor" id="serialize_variant"></a></p><h2>Sum types (std::variant)</h2>
<p>When reading into a std::variant&lt;&gt;, we match its <a href="https://yaml.org/spec/1.2.2/#tags">YAML tag</a> to the shortened C++ class name of the variant selection. For example, to read into this sample struct:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Foo {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Archive&gt;</div>
<div class="line">  <span class="keywordtype">void</span> Serialize(Archive* a) {</div>
<div class="line">    a-&gt;Visit(<a class="code hl_define" href="name__value_8h.html#a1e095c8e1bdc141709c1bb22aca6d944">DRAKE_NVP</a>(data));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::string data;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Bar {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Archive&gt;</div>
<div class="line">  <span class="keywordtype">void</span> Serialize(Archive* a) {</div>
<div class="line">    a-&gt;Visit(<a class="code hl_define" href="name__value_8h.html#a1e095c8e1bdc141709c1bb22aca6d944">DRAKE_NVP</a>(value));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::variant&lt;std::string, double, Foo&gt; value;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Some valid YAML examples are:</p>
<div class="fragment"><div class="line"># For the first type declared in the variant&lt;&gt;, the tag is optional.</div>
<div class="line">bar:</div>
<div class="line">  value: hello</div>
<div class="line"> </div>
<div class="line"># YAML has built-in tags for string, float, int.</div>
<div class="line">bar2:</div>
<div class="line">  value: !!str hello</div>
<div class="line"> </div>
<div class="line"># For any other type within the variant&lt;&gt;, the tag is required.</div>
<div class="line">bar3:</div>
<div class="line">  value: !!float 1.0</div>
<div class="line"> </div>
<div class="line"># User-defined types use a single exclamation point.</div>
<div class="line">bar4:</div>
<div class="line">  value: !Foo</div>
<div class="line">    data: hello</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
