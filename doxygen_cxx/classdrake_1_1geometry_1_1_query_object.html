<!-- HTML header for doxygen 1.14.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: QueryObject&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1geometry_1_1_query_object.html','','classdrake_1_1geometry_1_1_query_object-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">QueryObject&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class drake::geometry::QueryObject&lt; T &gt;</div><p>The QueryObject serves as a mechanism to perform geometry queries on the world's geometry. </p>
<p>The <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> has an abstract-valued port that contains a QueryObject (i.e., a QueryObject-valued output port).</p>
<p>To perform geometry queries on <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>:</p><ul>
<li>a LeafSystem must have a QueryObject-valued input port and connect it to the corresponding query output port on <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>,</li>
<li>the querying LeafSystem can evaluate the input port, retrieving a <span class="tt">const
    <a class="el" href="classdrake_1_1geometry_1_1_query_object.html" title="The QueryObject serves as a mechanism to perform geometry queries on the world&#39;s geometry.">QueryObject</a>&amp;</span> in return, and, finally,</li>
<li>invoke the appropriate method on the QueryObject.</li>
</ul>
<p>The const reference returned by the input port is considered "live" - it is linked to the context, system, and cache (making full use of all of those mechanisms). This const reference should <em>never</em> be persisted; doing so can lead to erroneous query results. It is simpler and more advisable to acquire it for evaluation in a limited scope (e.g., CalcTimeDerivatives()) and then discard it. If a QueryObject is needed for many separate functions in a LeafSystem, each should re-evaluate the input port. The underlying caching mechanism should make the cost of this negligible.</p>
<p>The QueryObject <em>can</em> be copied. The copied instance is no longer "live"; it is now "baked". Essentially, it freezes the state of the live scene graph in its current configuration and disconnects it from the system and context. This means, even if the original context changes values, the copied/baked instance will always reproduce the same query results. This baking process is not cheap and should not be done without consideration.</p>
<p><a class="anchor" id="query_object_precision_methodology"></a></p><h2>Queries and scalar type</h2>
<p>A QueryObject <em>cannot</em> be converted to a different scalar type. A QueryObject of scalar type T can only be acquired from the output port of a <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> of type T evaluated on a corresponding Context, also of type T.</p>
<p>QueryObject's support for arbitrary scalar type is incomplete. Not all queries support all scalar types to the same degree. Furthermore, the queries are typically served by <em>families</em> of algorithms. The evaluation of a query between a particular pair of geometries will depend on the query, the pair of geometry types involved, and the scalar type. From query to query, the treatment of a geometry (or geometry pair) for a given scalar type can vary in many ways, including but not limited to: ignoring the geometry, throwing an exception, results with limited precision, or full, accurate support. The queries below provide tables to help inform your expectations when evaluating queries. The tables all use a common methodology and admit a common interpretation.</p>
<p>For each (query, geometry-pair, scalar) combination, we create a set of geometric configurations with known answers. We evaluate the precision of the query result (if supported at all) over the entire set and report the <em>worst</em> observed error. This is a purely empirical approach and doesn't fully characterize the families of underlying algorithms, and the reported error may be misleading in that we've missed far worse latent error or that the error reported doesn't well represent the average case.</p>
<p>The families of algorithms also differ in how their inherent errors scale with the scale of the problem (e.g., size of geometries, magnitude of distance/depth, etc.) Attempting to fully characterize that aspect is both arduous and problematic, so, we've chosen a more <em>representative</em> approach.</p>
<p>Because Drake is primarily intended for robot simulation, we've created geometric configurations on the scale of common robot manipulators (on the order of 20cm). We position them with a known penetration depth (or separating distance) of 2 mm. The error reported is the deviation from that expected result.</p>
<p>When interpreting the tables, keep the following in mind:</p><ul>
<li>The table illustrates trends in <em>broad</em> strokes, only. It does not represent an exhaustive analysis.</li>
<li>If your problem involves larger geometries, greater penetration depths, or larger separating distances, the error will vary. Do not assume that observed error in this context is necessarily relative &ndash; there truly is that much variability in the families of algorithms.</li>
<li>These values are an attempt to capture the <em>worst</em> case outcome. The error shown is a single-significant-digit approximation of that observed error.</li>
<li>These values may not actually represent the true worst case; discovering the true worst case is generally challenging. These represent our best effort to date. If you find outcomes that are worse those reported here, please <a href="https://github.com/RobotLocomotion/drake/issues/new">submit a bug</a>.</li>
<li>These tables represent Drake's transient state. The eventual goal is to report no more than 1e-14 error across all supportable geometry pairs and scalars. At that point, the table will simply disappear.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/geometry/query_object.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab3ead3718ecc338ebf8ffdd60f8206ed" id="r_ab3ead3718ecc338ebf8ffdd60f8206ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3ead3718ecc338ebf8ffdd60f8206ed">QueryObject</a> ()=default</td></tr>
<tr class="memdesc:ab3ead3718ecc338ebf8ffdd60f8206ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a default <a class="el" href="classdrake_1_1geometry_1_1_query_object.html" title="The QueryObject serves as a mechanism to perform geometry queries on the world&#39;s geometry.">QueryObject</a> (all pointers are null).  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>Calling the copy constructor or assignment will turn a <em>live</em> QueryObject into a <em>baked</em> QueryObject (an expensive operation).</p>
<p>Copying baked QueryObjects is cheap. </p>
</div></td></tr>
<tr class="memitem:ac84d9a202933205a92cf0823b94ba512" id="r_ac84d9a202933205a92cf0823b94ba512"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac84d9a202933205a92cf0823b94ba512">QueryObject</a> (const <a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a> &amp;other)</td></tr>
<tr class="memitem:aaff0f1a21871c2b63a2dda795380655d" id="r_aaff0f1a21871c2b63a2dda795380655d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaff0f1a21871c2b63a2dda795380655d">operator=</a> (const <a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a> &amp;)</td></tr>
<tr class="memitem:a16c29c5b277b7b1aa84d111afca6c55c" id="r_a16c29c5b277b7b1aa84d111afca6c55c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16c29c5b277b7b1aa84d111afca6c55c">QueryObject</a> (<a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a> &amp;&amp;)=default</td></tr>
<tr class="memitem:a178aee469235aaf82788e93b8168709c" id="r_a178aee469235aaf82788e93b8168709c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a178aee469235aaf82788e93b8168709c">operator=</a> (<a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a> &amp;&amp;)=default</td></tr>
<tr class="memitem:a627247d114da429b0b6ed85f6b5db381" id="r_a627247d114da429b0b6ed85f6b5db381"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html">SceneGraphInspector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a627247d114da429b0b6ed85f6b5db381">inspector</a> () const</td></tr>
<tr class="memdesc:a627247d114da429b0b6ed85f6b5db381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an inspector for the topological structure of the underlying scene graph data (see <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html" title="The SceneGraphInspector serves as a mechanism to query the topological structure of a SceneGraph inst...">SceneGraphInspector</a> for details).  <br /></td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Configuration-dependent Introspection</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>These methods provide access to introspect geometry and frame quantities that directly depend on the poses of the frames or configurations of deformable geometries.</p>
<p>For geometry and frame quantities that do not depend on the poses of frames, such as X_FG, use <a class="el" href="#a627247d114da429b0b6ed85f6b5db381" title="Provides an inspector for the topological structure of the underlying scene graph data (see SceneGrap...">inspector()</a> to access the <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html" title="The SceneGraphInspector serves as a mechanism to query the topological structure of a SceneGraph inst...">SceneGraphInspector</a>. </p>
</div></td></tr>
<tr class="memitem:a1e53a99014cc2b67b021fe159770908a" id="r_a1e53a99014cc2b67b021fe159770908a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e53a99014cc2b67b021fe159770908a">GetPoseInWorld</a> (<a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> frame_id) const</td></tr>
<tr class="memdesc:a1e53a99014cc2b67b021fe159770908a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the position of the frame indicated by <span class="tt">frame_id</span> relative to the world frame.  <br /></td></tr>
<tr class="memitem:a584c93dc0a7b1158871450f4d136d675" id="r_a584c93dc0a7b1158871450f4d136d675"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a584c93dc0a7b1158871450f4d136d675">GetPoseInParent</a> (<a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> frame_id) const</td></tr>
<tr class="memdesc:a584c93dc0a7b1158871450f4d136d675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the position of the frame indicated by <span class="tt">frame_id</span> relative to its parent frame.  <br /></td></tr>
<tr class="memitem:a8872fd6fffbdf59c19d0905cd9523b85" id="r_a8872fd6fffbdf59c19d0905cd9523b85"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8872fd6fffbdf59c19d0905cd9523b85">GetPoseInWorld</a> (<a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> geometry_id) const</td></tr>
<tr class="memdesc:a8872fd6fffbdf59c19d0905cd9523b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the position of the frame of the rigid geometry indicated by <span class="tt">geometry_id</span> relative to the world frame (X_WG).  <br /></td></tr>
<tr class="memitem:a0191e5d7528f261a271151338dc44fb7" id="r_a0191e5d7528f261a271151338dc44fb7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0191e5d7528f261a271151338dc44fb7">GetConfigurationsInWorld</a> (<a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> deformable_geometry_id) const</td></tr>
<tr class="memdesc:a0191e5d7528f261a271151338dc44fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the configuration of the deformable geometry indicated by <span class="tt">deformable_geometry_id</span> relative to the world frame.  <br /></td></tr>
<tr class="memitem:a6a474808e4b2931a73d6bcc686ab18da" id="r_a6a474808e4b2931a73d6bcc686ab18da"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a474808e4b2931a73d6bcc686ab18da">GetDrivenMeshConfigurationsInWorld</a> (<a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> deformable_geometry_id, <a class="el" href="namespacedrake_1_1geometry.html#acdd79a1a4f81dd6ee5cddcb21149b951">Role</a> role) const</td></tr>
<tr class="memdesc:a6a474808e4b2931a73d6bcc686ab18da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the configurations of the driven meshes associated with the given role for the deformable geometry indicated by <span class="tt">deformable_geometry_id</span> relative to the world frame if the deformable geometry has that role.  <br /></td></tr>
<tr class="memitem:a90cfa8ff753b055816e55dc038c1cee5" id="r_a90cfa8ff753b055816e55dc038c1cee5"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classdrake_1_1geometry_1_1_aabb.html">Aabb</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90cfa8ff753b055816e55dc038c1cee5">ComputeAabbInWorld</a> (<a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> geometry_id) const</td></tr>
<tr class="memdesc:a90cfa8ff753b055816e55dc038c1cee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the axis-aligned bounding box of the geometry indicated by <span class="tt">geometry_id</span> in the world frame.  <br /></td></tr>
<tr class="memitem:a37ea340e42cf3b0296b6adb11a757d48" id="r_a37ea340e42cf3b0296b6adb11a757d48"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classdrake_1_1geometry_1_1_obb.html">Obb</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37ea340e42cf3b0296b6adb11a757d48">ComputeObbInWorld</a> (<a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> geometry_id) const</td></tr>
<tr class="memdesc:a37ea340e42cf3b0296b6adb11a757d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the oriented bounding box of the geometry indicated by <span class="tt">geometry_id</span> in the world frame.  <br /></td></tr>
<tr id="pub-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Collision Queries</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="collision_queries"></a> These queries detect <em>collisions</em> between geometry. Two geometries collide if they overlap each other and are not explicitly excluded through <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html#scene_graph_collision_filter_manager">collision filtering</a>. These algorithms find those colliding cases, characterize them, and report the essential characteristics of that collision.</p>
<p>For two colliding geometries g_A and g_B, it is guaranteed that they will map to <span class="tt">id_A</span> and <span class="tt">id_B</span> in a fixed, repeatable manner, where <span class="tt">id_A</span> and <span class="tt">id_B</span> are <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html" title="Type used to identify geometry instances in SceneGraph.">GeometryId</a>'s of geometries g_A and g_B respectively.</p>
<p>These methods are affected by collision filtering; element pairs that have been filtered will not produce contacts, even if their collision geometry is penetrating. </p>
</div></td></tr>
<tr class="memitem:a2ccfa575edc89670bddb94bb54acc7da" id="r_a2ccfa575edc89670bddb94bb54acc7da"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html">PenetrationAsPointPair</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ccfa575edc89670bddb94bb54acc7da">ComputePointPairPenetration</a> () const</td></tr>
<tr class="memdesc:a2ccfa575edc89670bddb94bb54acc7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the penetrations across all pairs of geometries in the world with the penetrations characterized by pairs of points (see <a class="el" href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html" title="A characterization of the intersection of two penetrating geometries.">PenetrationAsPointPair</a>), providing some measure of the penetration "depth" of the two objects, but <em>not</em> the overlapping volume.  <br /></td></tr>
<tr class="memitem:a5f3ed3fb982c7a42090728675389d1d6" id="r_a5f3ed3fb982c7a42090728675389d1d6"><td class="memTemplParams" colspan="2">template&lt;typename T1 = T&gt; </td></tr>
<tr class="memitem:a5f3ed3fb982c7a42090728675389d1d6 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structdrake_1_1scalar__predicate.html">scalar_predicate</a>&lt; T1 &gt;::is_bool, std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f3ed3fb982c7a42090728675389d1d6">ComputeContactSurfaces</a> (<a class="el" href="namespacedrake_1_1geometry.html#a227f80cb57c9c87f6ecc4e839e364979">HydroelasticContactRepresentation</a> representation) const</td></tr>
<tr class="memdesc:a5f3ed3fb982c7a42090728675389d1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports pairwise intersections and characterizes each non-empty intersection as a <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html" title="The ContactSurface characterizes the intersection of two geometries M and N as a contact surface with...">ContactSurface</a> for hydroelastic contact model.  <br /></td></tr>
<tr class="memitem:a90b21f750f9cb220fa8025f38b91c9dc" id="r_a90b21f750f9cb220fa8025f38b91c9dc"><td class="memTemplParams" colspan="2">template&lt;typename T1 = T&gt; </td></tr>
<tr class="memitem:a90b21f750f9cb220fa8025f38b91c9dc template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structdrake_1_1scalar__predicate.html">scalar_predicate</a>&lt; T1 &gt;::is_bool, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90b21f750f9cb220fa8025f38b91c9dc">ComputeContactSurfacesWithFallback</a> (<a class="el" href="namespacedrake_1_1geometry.html#a227f80cb57c9c87f6ecc4e839e364979">HydroelasticContactRepresentation</a> representation, std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a>&lt; T &gt; &gt; *surfaces, std::vector&lt; <a class="el" href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html">PenetrationAsPointPair</a>&lt; T &gt; &gt; *point_pairs) const</td></tr>
<tr class="memdesc:a90b21f750f9cb220fa8025f38b91c9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports pairwise intersections and characterizes each non-empty intersection as a <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html" title="The ContactSurface characterizes the intersection of two geometries M and N as a contact surface with...">ContactSurface</a> <em>where possible</em> and as a <a class="el" href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html" title="A characterization of the intersection of two penetrating geometries.">PenetrationAsPointPair</a> where not.  <br /></td></tr>
<tr class="memitem:add449eece58f297003b8b238e8b40b6b" id="r_add449eece58f297003b8b238e8b40b6b"><td class="memTemplParams" colspan="2">template&lt;typename T1 = T&gt; </td></tr>
<tr class="memitem:add449eece58f297003b8b238e8b40b6b template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; T1, <a class="el" href="classdouble.html">double</a> &gt;, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add449eece58f297003b8b238e8b40b6b">ComputeDeformableContact</a> (internal::DeformableContact&lt; T &gt; *deformable_contact) const</td></tr>
<tr class="memdesc:add449eece58f297003b8b238e8b40b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports contact information among all deformable geometries.  <br /></td></tr>
<tr class="memitem:abe41ea509666ff17cd6479b6981e8bd2" id="r_abe41ea509666ff17cd6479b6981e8bd2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe41ea509666ff17cd6479b6981e8bd2">FindCollisionCandidates</a> () const</td></tr>
<tr class="memdesc:abe41ea509666ff17cd6479b6981e8bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a conservative culling mechanism to create a subset of all possible geometry pairs based on non-zero intersections.  <br /></td></tr>
<tr class="memitem:a3f702eb73e7464c00b82974d0c5ff6c9" id="r_a3f702eb73e7464c00b82974d0c5ff6c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f702eb73e7464c00b82974d0c5ff6c9">HasCollisions</a> () const</td></tr>
<tr class="memdesc:a3f702eb73e7464c00b82974d0c5ff6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports true if there are <em>any</em> collisions between unfiltered pairs in the world.  <br /></td></tr>
<tr id="pub-methods-3" class="groupHeader"><td colspan="2"><div class="groupHeader">Signed Distance Queries</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="signed_distance_query"></a> These queries provide the signed distance between two objects. Each query has a specific definition of the signed distance being positive, negative, or zero associated with some notions of being outside, inside, or on the boundary.</p>
<p>These queries provide bookkeeping data like geometry id(s) of the geometries involved and the important locations on the boundaries of these geometries.</p>
<p>The signed distance function is a continuous function. Its partial derivatives are continuous almost everywhere. </p>
</div></td></tr>
<tr class="memitem:a9635a78abfdafe01871579fdd3961bea" id="r_a9635a78abfdafe01871579fdd3961bea"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structdrake_1_1geometry_1_1_signed_distance_pair.html">SignedDistancePair</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9635a78abfdafe01871579fdd3961bea">ComputeSignedDistancePairwiseClosestPoints</a> (const <a class="el" href="classdouble.html">double</a> max_distance=std::numeric_limits&lt; <a class="el" href="classdouble.html">double</a> &gt;::infinity()) const</td></tr>
<tr class="memdesc:a9635a78abfdafe01871579fdd3961bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the signed distance together with the nearest points across all pairs of geometries in the world.  <br /></td></tr>
<tr class="memitem:a29c2be44ce16d6f7b49fdfe8b9cad4bb" id="r_a29c2be44ce16d6f7b49fdfe8b9cad4bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1geometry_1_1_signed_distance_pair.html">SignedDistancePair</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29c2be44ce16d6f7b49fdfe8b9cad4bb">ComputeSignedDistancePairClosestPoints</a> (<a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> geometry_id_A, <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> geometry_id_B) const</td></tr>
<tr class="memdesc:a29c2be44ce16d6f7b49fdfe8b9cad4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant of <a class="el" href="#a9635a78abfdafe01871579fdd3961bea" title="Computes the signed distance together with the nearest points across all pairs of geometries in the w...">ComputeSignedDistancePairwiseClosestPoints()</a> which computes the signed distance (and witnesses) between a specific pair of geometries indicated by id.  <br /></td></tr>
<tr class="memitem:aeca0215b59030bb92a966389601bd1b0" id="r_aeca0215b59030bb92a966389601bd1b0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structdrake_1_1geometry_1_1_signed_distance_to_point.html">SignedDistanceToPoint</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeca0215b59030bb92a966389601bd1b0">ComputeSignedDistanceToPoint</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_WQ, const <a class="el" href="classdouble.html">double</a> threshold=std::numeric_limits&lt; <a class="el" href="classdouble.html">double</a> &gt;::infinity()) const</td></tr>
<tr class="memdesc:aeca0215b59030bb92a966389601bd1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the signed distances and gradients to a query point from each geometry in the scene.  <br /></td></tr>
<tr class="memitem:a5ec0f91a112964aba5fc2fe39e8b100f" id="r_a5ec0f91a112964aba5fc2fe39e8b100f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structdrake_1_1geometry_1_1_signed_distance_to_point.html">SignedDistanceToPoint</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ec0f91a112964aba5fc2fe39e8b100f">ComputeSignedDistanceGeometryToPoint</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_WQ, const <a class="el" href="classdrake_1_1geometry_1_1_geometry_set.html">GeometrySet</a> &amp;geometries) const</td></tr>
<tr class="memdesc:a5ec0f91a112964aba5fc2fe39e8b100f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant of <a class="el" href="#aeca0215b59030bb92a966389601bd1b0" title="Computes the signed distances and gradients to a query point from each geometry in the scene.">ComputeSignedDistanceToPoint()</a>.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Render Queries</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="render_queries"></a> The methods support queries along the lines of "What do I see?" They support simulation of sensors. External entities define a sensor camera &ndash; its extrinsic and intrinsic properties and QueryObject renders into the provided image.</p>
</td></tr>
<tr class="memitem:a09e32deb354fd5ca0cc04c6f6110bcb7" id="r_a09e32deb354fd5ca0cc04c6f6110bcb7"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09e32deb354fd5ca0cc04c6f6110bcb7">SceneGraph&lt; T &gt;</a></td></tr>
<tr class="memitem:a4afb6aad87f505d5a5ae0031d1e1a707" id="r_a4afb6aad87f505d5a5ae0031d1e1a707"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4afb6aad87f505d5a5ae0031d1e1a707">QueryObjectTest</a></td></tr>
<tr class="memitem:a4cfc105838770263cb1e1ca3a6934945" id="r_a4cfc105838770263cb1e1ca3a6934945"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cfc105838770263cb1e1ca3a6934945">RenderColorImage</a> (const <a class="el" href="classdrake_1_1geometry_1_1render_1_1_color_render_camera.html">render::ColorRenderCamera</a> &amp;camera, <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> parent_frame, const math::RigidTransformd &amp;X_PC, <a class="el" href="namespacedrake_1_1systems_1_1sensors.html#af5afae0f791341ac7ad11eb6bcb092bd">systems::sensors::ImageRgba8U</a> *color_image_out) const</td></tr>
<tr class="memdesc:a4cfc105838770263cb1e1ca3a6934945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders an RGB image for the given <span class="tt">camera</span> posed with respect to the indicated parent frame P.  <br /></td></tr>
<tr class="memitem:aa611fe62e12ad13ca9ef218844542210" id="r_aa611fe62e12ad13ca9ef218844542210"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa611fe62e12ad13ca9ef218844542210">RenderDepthImage</a> (const <a class="el" href="classdrake_1_1geometry_1_1render_1_1_depth_render_camera.html">render::DepthRenderCamera</a> &amp;camera, <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> parent_frame, const math::RigidTransformd &amp;X_PC, <a class="el" href="namespacedrake_1_1systems_1_1sensors.html#a0558960d25000bd7cc8607cef2fd223b">systems::sensors::ImageDepth32F</a> *depth_image_out) const</td></tr>
<tr class="memdesc:aa611fe62e12ad13ca9ef218844542210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a depth image for the given <span class="tt">camera</span> posed with respect to the indicated parent frame P.  <br /></td></tr>
<tr class="memitem:aba077b59ee3574bbe9a0a602c14293c3" id="r_aba077b59ee3574bbe9a0a602c14293c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba077b59ee3574bbe9a0a602c14293c3">RenderLabelImage</a> (const <a class="el" href="classdrake_1_1geometry_1_1render_1_1_color_render_camera.html">render::ColorRenderCamera</a> &amp;camera, <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> parent_frame, const math::RigidTransformd &amp;X_PC, <a class="el" href="namespacedrake_1_1systems_1_1sensors.html#af9f2ff2c09bd6626d594951724ed1d9a">systems::sensors::ImageLabel16I</a> *label_image_out) const</td></tr>
<tr class="memdesc:aba077b59ee3574bbe9a0a602c14293c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a label image for the given <span class="tt">camera</span> posed with respect to the indicated parent frame P.  <br /></td></tr>
<tr class="memitem:a50a46a53be3d4f848b9e5532e4f2f89f" id="r_a50a46a53be3d4f848b9e5532e4f2f89f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1geometry_1_1render_1_1_render_engine.html">render::RenderEngine</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50a46a53be3d4f848b9e5532e4f2f89f">GetRenderEngineByName</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a50a46a53be3d4f848b9e5532e4f2f89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the named render engine, if it exists.  <br /></td></tr>
</table>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab3ead3718ecc338ebf8ffdd60f8206ed" name="ab3ead3718ecc338ebf8ffdd60f8206ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ead3718ecc338ebf8ffdd60f8206ed">&#9670;&#160;</a></span>QueryObject() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a default <a class="el" href="classdrake_1_1geometry_1_1_query_object.html" title="The QueryObject serves as a mechanism to perform geometry queries on the world&#39;s geometry.">QueryObject</a> (all pointers are null). </p>

</div>
</div>
<a id="ac84d9a202933205a92cf0823b94ba512" name="ac84d9a202933205a92cf0823b94ba512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84d9a202933205a92cf0823b94ba512">&#9670;&#160;</a></span>QueryObject() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16c29c5b277b7b1aa84d111afca6c55c" name="a16c29c5b277b7b1aa84d111afca6c55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c29c5b277b7b1aa84d111afca6c55c">&#9670;&#160;</a></span>QueryObject() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a90cfa8ff753b055816e55dc038c1cee5" name="a90cfa8ff753b055816e55dc038c1cee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90cfa8ff753b055816e55dc038c1cee5">&#9670;&#160;</a></span>ComputeAabbInWorld()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classdrake_1_1geometry_1_1_aabb.html">Aabb</a> &gt; ComputeAabbInWorld </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a></td>          <td class="paramname"><span class="paramname"><em>geometry_id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the axis-aligned bounding box of the geometry indicated by <span class="tt">geometry_id</span> in the world frame. </p>
<p>Returns std::nullopt if the geometry is not supported for this query. Currently, only deformable geometries are supported. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <span class="tt">geometry_id</span> is not valid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f3ed3fb982c7a42090728675389d1d6" name="a5f3ed3fb982c7a42090728675389d1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3ed3fb982c7a42090728675389d1d6">&#9670;&#160;</a></span>ComputeContactSurfaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename T1 = T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structdrake_1_1scalar__predicate.html">scalar_predicate</a>&lt; T1 &gt;::is_bool, std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a>&lt; T &gt; &gt; &gt; ComputeContactSurfaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a227f80cb57c9c87f6ecc4e839e364979">HydroelasticContactRepresentation</a></td>          <td class="paramname"><span class="paramname"><em>representation</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports pairwise intersections and characterizes each non-empty intersection as a <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html" title="The ContactSurface characterizes the intersection of two geometries M and N as a contact surface with...">ContactSurface</a> for hydroelastic contact model. </p>
<p>The computation is subject to collision filtering.</p>
<p>For two intersecting geometries g_A and g_B, it is guaranteed that they will map to <span class="tt">id_A</span> and <span class="tt">id_B</span> in a fixed, repeatable manner, where <span class="tt">id_A</span> and <span class="tt">id_B</span> are <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html" title="Type used to identify geometry instances in SceneGraph.">GeometryId</a>'s of geometries g_A and g_B respectively.</p>
<p>In the current incarnation, this function represents an incomplete implementation. That has several implications, as described below:</p>
<ul>
<li>This table shows which shapes can be declared for use in hydroelastic contact, and what compliance can be assigned.</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter"><a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The abstract base class for all shape specifications.">Shape</a>  </th><th class="markdownTableHeadCenter">Compliant  </th><th class="markdownTableHeadCenter">Rigid  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><a class="el" href="classdrake_1_1geometry_1_1_sphere.html" title="Definition of sphere.">Sphere</a>  </td><td class="markdownTableBodyCenter">yes  </td><td class="markdownTableBodyCenter">yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><a class="el" href="classdrake_1_1geometry_1_1_cylinder.html" title="Definition of a cylinder.">Cylinder</a>  </td><td class="markdownTableBodyCenter">yes  </td><td class="markdownTableBodyCenter">yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><a class="el" href="classdrake_1_1geometry_1_1_box.html" title="Definition of a box.">Box</a>  </td><td class="markdownTableBodyCenter">yes  </td><td class="markdownTableBodyCenter">yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><a class="el" href="classdrake_1_1geometry_1_1_capsule.html" title="Definition of a capsule.">Capsule</a>  </td><td class="markdownTableBodyCenter">yes  </td><td class="markdownTableBodyCenter">yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><a class="el" href="classdrake_1_1geometry_1_1_ellipsoid.html" title="Definition of an ellipsoid.">Ellipsoid</a>  </td><td class="markdownTableBodyCenter">yes  </td><td class="markdownTableBodyCenter">yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><a class="el" href="classdrake_1_1geometry_1_1_half_space.html" title="Definition of a half space.">HalfSpace</a>  </td><td class="markdownTableBodyCenter">yes  </td><td class="markdownTableBodyCenter">yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Definition of a general (possibly non-convex) mesh.">Mesh</a>  </td><td class="markdownTableBodyCenter">yesᵃ  </td><td class="markdownTableBodyCenter">yesᵇ  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><a class="el" href="classdrake_1_1geometry_1_1_convex.html" title="Definition of a convex surface mesh.">Convex</a>  </td><td class="markdownTableBodyCenter">yesᶜ  </td><td class="markdownTableBodyCenter">yesᶜ  </td></tr>
</table>
<ul>
<li>ᵃ The exact representation of a compliant mesh depends on the type of mesh file it references:<ul>
<li>.obj: the convex hull of the mesh will be used (as if it were declared to be a <a class="el" href="classdrake_1_1geometry_1_1_convex.html" title="Definition of a convex surface mesh.">Convex</a> shape).</li>
<li>.vtk: the tetrahedral mesh will be used directly. This external working <a href="https://docs.google.com/document/d/1VZtVsxIjOLKvgQ8SNSrF6PtWuPW5z9PP7-dQuxfmqpc/edit?usp=sharing">document</a> provides guidance how to generate a tetrahedral mesh in a VTK file from a surface mesh in an OBJ file.</li>
</ul>
</li>
<li>ᵇ For rigid <a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Definition of a general (possibly non-convex) mesh.">Mesh</a>, please specify a surface mesh in an OBJ file in Mesh(filename). A tetrahedral mesh in a VTK file can also be specified.</li>
<li>ᶜ The <a class="el" href="classdrake_1_1geometry_1_1_convex.html" title="Definition of a convex surface mesh.">Convex</a> shape can reference either an .obj or a .vtk tetrahedral mesh. In both cases, its convex hull will be used to define the hydroelastic representation.</li>
<li>We do not support contact between two rigid geometries. One geometry must* be compliant, and the other could be rigid or compliant. If two rigid geometries collide, an exception will be thrown. More particularly, if such a geometry pair <em>cannot be culled</em> an exception will be thrown. No exception is thrown if the pair has been filtered.</li>
<li>If you need all combinations of rigid-rigid contact, rigid-compliant contact, and compliant-compliant contact, you might consider <a class="el" href="#a90b21f750f9cb220fa8025f38b91c9dc" title="Reports pairwise intersections and characterizes each non-empty intersection as a ContactSurface wher...">ComputeContactSurfacesWithFallback()</a>.</li>
<li>The hydroelastic modulus (N/m^2) of each compliant geometry is set in <a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html" title="The set of properties for geometry used in a proximity role.">ProximityProperties</a> by <a class="el" href="namespacedrake_1_1geometry.html#a7cccbced57eb9c31f3e5e9ad26099257" title="Adds properties to the given set of proximity properties sufficient to cause the associated geometry ...">AddCompliantHydroelasticProperties()</a>.</li>
<li>The tessellation of the corresponding meshes is controlled by the resolution hint (where appropriate), as defined by <a class="el" href="namespacedrake_1_1geometry.html#a7cccbced57eb9c31f3e5e9ad26099257" title="Adds properties to the given set of proximity properties sufficient to cause the associated geometry ...">AddCompliantHydroelasticProperties()</a> and <a class="el" href="namespacedrake_1_1geometry.html#a6c74afc9942060de51e7c6a65f0ade08" title="Adds properties to the given set of proximity properties sufficient to cause the associated geometry ...">AddRigidHydroelasticProperties()</a>.</li>
</ul>
<h3>Scalar support</h3>
<p>This method provides support for both double and <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc" title="An autodiff variable with a dynamic number of partials.">AutoDiffXd</a>, but not Expression. Like with the other proximity queries, derivatives can only be introduced via geometry <em>poses</em>. We cannot differentiate w.r.t. geometric properties (e.g., radius, length, etc.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">representation</td><td>Controls the mesh representation of the contact surface. See <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#contact_surface_discrete_representation">contact surface representation</a> for more details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector populated with all detected intersections characterized as contact surfaces. The ordering of the results is guaranteed to be consistent &ndash; for fixed geometry poses, the results will remain the same. </dd></dl>

</div>
</div>
<a id="a90b21f750f9cb220fa8025f38b91c9dc" name="a90b21f750f9cb220fa8025f38b91c9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b21f750f9cb220fa8025f38b91c9dc">&#9670;&#160;</a></span>ComputeContactSurfacesWithFallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename T1 = T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structdrake_1_1scalar__predicate.html">scalar_predicate</a>&lt; T1 &gt;::is_bool, void &gt; ComputeContactSurfacesWithFallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a227f80cb57c9c87f6ecc4e839e364979">HydroelasticContactRepresentation</a></td>          <td class="paramname"><span class="paramname"><em>representation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a>&lt; T &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>surfaces</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html">PenetrationAsPointPair</a>&lt; T &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>point_pairs</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports pairwise intersections and characterizes each non-empty intersection as a <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html" title="The ContactSurface characterizes the intersection of two geometries M and N as a contact surface with...">ContactSurface</a> <em>where possible</em> and as a <a class="el" href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html" title="A characterization of the intersection of two penetrating geometries.">PenetrationAsPointPair</a> where not. </p>
<p>This method can be thought of as a combination of <a class="el" href="#a5f3ed3fb982c7a42090728675389d1d6" title="Reports pairwise intersections and characterizes each non-empty intersection as a ContactSurface for ...">ComputeContactSurfaces()</a> and <a class="el" href="#a2ccfa575edc89670bddb94bb54acc7da" title="Computes the penetrations across all pairs of geometries in the world with the penetrations character...">ComputePointPairPenetration()</a>. For each geometry pair, we attempt to compute a <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html" title="The ContactSurface characterizes the intersection of two geometries M and N as a contact surface with...">ContactSurface</a>. If that fails, rather than throwing, we attempt to characterize the contact as a point pair. If that fails, we throw. See the documentation of those constituent methods to understand the circumstances in which they fail.</p>
<p>The ordering of the <em>added</em> results is guaranteed to be consistent &ndash; for fixed geometry poses, the results will remain the same.</p>
<h3>Scalar support</h3>
<p>The scalar support is a combination of the scalar support offered by <a class="el" href="#a5f3ed3fb982c7a42090728675389d1d6" title="Reports pairwise intersections and characterizes each non-empty intersection as a ContactSurface for ...">ComputeContactSurfaces()</a> and <a class="el" href="#a2ccfa575edc89670bddb94bb54acc7da" title="Computes the penetrations across all pairs of geometries in the world with the penetrations character...">ComputePointPairPenetration()</a>. This method supports double and <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc" title="An autodiff variable with a dynamic number of partials.">AutoDiffXd</a> to the extent that those constituent methods do, but does not support Expression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">representation</td><td>Controls the mesh representation of the contact surface. See <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#contact_surface_discrete_representation">contact surface representation</a> for more details. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">surfaces</td><td>The vector that contact surfaces will be added to. The vector will <em>not</em> be cleared. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">point_pairs</td><td>The vector that fall back point pair data will be added to. The vector will <em>not</em> be cleared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither <span class="tt">surfaces</span> nor <span class="tt">point_pairs</span> is nullptr. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for the reasons described in <a class="el" href="#a5f3ed3fb982c7a42090728675389d1d6" title="Reports pairwise intersections and characterizes each non-empty intersection as a ContactSurface for ...">ComputeContactSurfaces()</a> and <a class="el" href="#a2ccfa575edc89670bddb94bb54acc7da" title="Computes the penetrations across all pairs of geometries in the world with the penetrations character...">ComputePointPairPenetration()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <span class="tt">surfaces</span> and <span class="tt">point_pairs</span> are output pointers in C++, but are return values in the Python bindings. </dd></dl>

</div>
</div>
<a id="add449eece58f297003b8b238e8b40b6b" name="add449eece58f297003b8b238e8b40b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add449eece58f297003b8b238e8b40b6b">&#9670;&#160;</a></span>ComputeDeformableContact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename T1 = T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; T1, <a class="el" href="classdouble.html">double</a> &gt;, void &gt; ComputeDeformableContact </td>
          <td>(</td>
          <td class="paramtype">internal::DeformableContact&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>deformable_contact</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports contact information among all deformable geometries. </p>
<p>It includes contacts between two deformable geometries or contacts between a deformable geometry and a non-deformable geometry. This function only supports double as the scalar type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">deformable_contact</td><td>Contains all deformable contact data on output. Any data passed in is cleared before the computation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>deformable_contact != nullptr. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This feature is considered to be <b>experimental</b> and may change or be removed at any time, without any deprecation notice ahead of time. </dd></dl>

</div>
</div>
<a id="a37ea340e42cf3b0296b6adb11a757d48" name="a37ea340e42cf3b0296b6adb11a757d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ea340e42cf3b0296b6adb11a757d48">&#9670;&#160;</a></span>ComputeObbInWorld()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classdrake_1_1geometry_1_1_obb.html">Obb</a> &gt; ComputeObbInWorld </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a></td>          <td class="paramname"><span class="paramname"><em>geometry_id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the oriented bounding box of the geometry indicated by <span class="tt">geometry_id</span> in the world frame. </p>
<p>Returns std::nullopt if the geometry is an <a class="el" href="classdrake_1_1geometry_1_1_half_space.html" title="Definition of a half space.">HalfSpace</a> (and doesn't have a bounding box). </p><dl class="section note"><dt>Note</dt><dd>If geometry_id refers to a deformable geometry, the OBB is computed using the deformed mesh in the world frame. See <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html#a985a093e8a37d90bc3b136090e2cd997" title="Returns the oriented bounding box (OBB) associated with the given geometry_id in the geometry&#39;s frame...">SceneGraphInspector::GetObbInGeometryFrame()</a> for computing the OBB of the reference mesh in its canonical frame. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <span class="tt">geometry_id</span> is not valid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ccfa575edc89670bddb94bb54acc7da" name="a2ccfa575edc89670bddb94bb54acc7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ccfa575edc89670bddb94bb54acc7da">&#9670;&#160;</a></span>ComputePointPairPenetration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html">PenetrationAsPointPair</a>&lt; T &gt; &gt; ComputePointPairPenetration </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the penetrations across all pairs of geometries in the world with the penetrations characterized by pairs of points (see <a class="el" href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html" title="A characterization of the intersection of two penetrating geometries.">PenetrationAsPointPair</a>), providing some measure of the penetration "depth" of the two objects, but <em>not</em> the overlapping volume. </p>
<p>Only reports results for <em>penetrating</em> geometries; if two geometries are separated, there will be no result for that pair. Geometries whose surfaces are just touching (osculating) are not considered in penetration. Surfaces whose penetration is within an epsilon of osculation, are likewise not considered penetrating. Pairs of <em>anchored</em> geometry are also not reported. This method is affected by collision filtering.</p>
<p>For two penetrating geometries g_A and g_B, it is guaranteed that they will map to <span class="tt">id_A</span> and <span class="tt">id_B</span> in a fixed, repeatable manner.</p>
<h3>Characterizing the returned values</h3>
<p>As discussed in the <a class="el" href="#query_object_precision_methodology">class's documentation</a>, these tables document the support given by this query for pairs of geometry types and scalar. See the description in the link for details on how to interpret the tables' results. The query is symmetric with respect to shape <em>ordering</em>, the pair (ShapeA, ShapeB) will be the same as (ShapeB, ShapeA), so we only fill in half of each table.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight"></th><th class="markdownTableHeadCenter">Box  </th><th class="markdownTableHeadCenter">Capsule  </th><th class="markdownTableHeadCenter">Convex  </th><th class="markdownTableHeadCenter">Cylinder  </th><th class="markdownTableHeadCenter">Ellipsoid  </th><th class="markdownTableHeadCenter">HalfSpace  </th><th class="markdownTableHeadCenter">Mesh  </th><th class="markdownTableHeadCenter">Sphere  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_box.html" title="Definition of a box.">Box</a>  </td><td class="markdownTableBodyCenter">2e-15  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_capsule.html" title="Definition of a capsule.">Capsule</a>  </td><td class="markdownTableBodyCenter">3e-5ᶜ  </td><td class="markdownTableBodyCenter">2e-5ᶜ  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_convex.html" title="Definition of a convex surface mesh.">Convex</a>  </td><td class="markdownTableBodyCenter">2e-15ᶜ  </td><td class="markdownTableBodyCenter">3e-5ᶜ  </td><td class="markdownTableBodyCenter">2e-15ᶜ  </td><td class="markdownTableBodyCenter">░░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_cylinder.html" title="Definition of a cylinder.">Cylinder</a>  </td><td class="markdownTableBodyCenter">1e-3ᶜ  </td><td class="markdownTableBodyCenter">4e-5ᶜ  </td><td class="markdownTableBodyCenter">1e-3ᶜ  </td><td class="markdownTableBodyCenter">2e-3ᶜ  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_ellipsoid.html" title="Definition of an ellipsoid.">Ellipsoid</a>  </td><td class="markdownTableBodyCenter">4e-4ᶜ  </td><td class="markdownTableBodyCenter">2e-4ᶜ  </td><td class="markdownTableBodyCenter">4e-4ᶜ  </td><td class="markdownTableBodyCenter">2e-3ᶜ  </td><td class="markdownTableBodyCenter">5e-4ᶜ  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_half_space.html" title="Definition of a half space.">HalfSpace</a>  </td><td class="markdownTableBodyCenter">6e-15  </td><td class="markdownTableBodyCenter">4e-15  </td><td class="markdownTableBodyCenter">3e-15ᶜ  </td><td class="markdownTableBodyCenter">4e-15  </td><td class="markdownTableBodyCenter">3e-15  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Definition of a general (possibly non-convex) mesh.">Mesh</a>  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_sphere.html" title="Definition of sphere.">Sphere</a>  </td><td class="markdownTableBodyCenter">3e-15  </td><td class="markdownTableBodyCenter">5e-15  </td><td class="markdownTableBodyCenter">3e-5ᶜ  </td><td class="markdownTableBodyCenter">5e-15  </td><td class="markdownTableBodyCenter">2e-4ᶜ  </td><td class="markdownTableBodyCenter">3e-15  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">5e-15  </td></tr>
</table>
<p><b><em>Table 1</em></b>: Worst observed error (in m) for 2mm penetration between geometries approximately 20cm in size for <span class="tt">T</span> = <span class="tt">double</span>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight"></th><th class="markdownTableHeadCenter">Box  </th><th class="markdownTableHeadCenter">Capsule  </th><th class="markdownTableHeadCenter">Convex  </th><th class="markdownTableHeadCenter">Cylinder  </th><th class="markdownTableHeadCenter">Ellipsoid  </th><th class="markdownTableHeadCenter">HalfSpace  </th><th class="markdownTableHeadCenter">Mesh  </th><th class="markdownTableHeadCenter">Sphere  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_box.html" title="Definition of a box.">Box</a>  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_capsule.html" title="Definition of a capsule.">Capsule</a>  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_convex.html" title="Definition of a convex surface mesh.">Convex</a>  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">░░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_cylinder.html" title="Definition of a cylinder.">Cylinder</a>  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_ellipsoid.html" title="Definition of an ellipsoid.">Ellipsoid</a>  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_half_space.html" title="Definition of a half space.">HalfSpace</a>  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Definition of a general (possibly non-convex) mesh.">Mesh</a>  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_sphere.html" title="Definition of sphere.">Sphere</a>  </td><td class="markdownTableBodyCenter">2e-15  </td><td class="markdownTableBodyCenter">3e-15  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">2e-15  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">2e-15  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">5e-15  </td></tr>
</table>
<p><b><em>Table 2</em></b>: Worst observed error (in m) for 2mm penetration between geometries approximately 20cm in size for <span class="tt">T</span> = <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight"></th><th class="markdownTableHeadCenter">Box  </th><th class="markdownTableHeadCenter">Capsule  </th><th class="markdownTableHeadCenter">Convex  </th><th class="markdownTableHeadCenter">Cylinder  </th><th class="markdownTableHeadCenter">Ellipsoid  </th><th class="markdownTableHeadCenter">HalfSpace  </th><th class="markdownTableHeadCenter">Mesh  </th><th class="markdownTableHeadCenter">Sphere  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_box.html" title="Definition of a box.">Box</a>  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_capsule.html" title="Definition of a capsule.">Capsule</a>  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_convex.html" title="Definition of a convex surface mesh.">Convex</a>  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">░░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_cylinder.html" title="Definition of a cylinder.">Cylinder</a>  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_ellipsoid.html" title="Definition of an ellipsoid.">Ellipsoid</a>  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_half_space.html" title="Definition of a half space.">HalfSpace</a>  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Definition of a general (possibly non-convex) mesh.">Mesh</a>  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_sphere.html" title="Definition of sphere.">Sphere</a>  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">throwsᵉ  </td><td class="markdownTableBodyCenter">ᵇ  </td><td class="markdownTableBodyCenter">throwsᵉ  </td></tr>
</table>
<p><b><em>Table 3</em></b>: Support for <span class="tt">T</span> = <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>.</p>
<ul>
<li>ᵃ Penetration depth between two <a class="el" href="classdrake_1_1geometry_1_1_half_space.html" title="Definition of a half space.">HalfSpace</a> instances has no meaning; either they don't intersect, or they have infinite penetration.</li>
<li>ᵇ Meshes are represented by the <em>convex</em> hull of the mesh, therefore the results for <a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Definition of a general (possibly non-convex) mesh.">Mesh</a> are assumed to be the same as for <a class="el" href="classdrake_1_1geometry_1_1_convex.html" title="Definition of a convex surface mesh.">Convex</a>.</li>
<li>ᶜ These results are computed using an iterative algorithm. For particular configurations, the solution may be correct to machine precision. The values reported here are confirmed, observed worst case answers.</li>
<li>ᵈ These results are simply not supported for <span class="tt">T</span> = <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> at this time.</li>
<li>ᵉ These results are simply not supported for <span class="tt">T</span> = <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> at this time.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>A vector populated with all detected penetrations characterized as point pairs. The ordering of the results is guaranteed to be consistent &ndash; for fixed geometry poses, the results will remain the same. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>For <a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Definition of a general (possibly non-convex) mesh.">Mesh</a> shapes, their convex hulls are used in this query. It is not* computationally efficient or particularly accurate. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if a Shape-Shape pair is in collision and indicated as <span class="tt">throws</span> in the support table above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ec0f91a112964aba5fc2fe39e8b100f" name="a5ec0f91a112964aba5fc2fe39e8b100f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec0f91a112964aba5fc2fe39e8b100f">&#9670;&#160;</a></span>ComputeSignedDistanceGeometryToPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structdrake_1_1geometry_1_1_signed_distance_to_point.html">SignedDistanceToPoint</a>&lt; T &gt; &gt; ComputeSignedDistanceGeometryToPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_WQ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_geometry_set.html">GeometrySet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>geometries</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variant of <a class="el" href="#aeca0215b59030bb92a966389601bd1b0" title="Computes the signed distances and gradients to a query point from each geometry in the scene.">ComputeSignedDistanceToPoint()</a>. </p>
<p>Instead of finding distances to all geometries, provides the distance to only the geometries indicated by the given set of <span class="tt">geometries</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_WQ</td><td>Position of a query point Q in world frame W. </td></tr>
    <tr><td class="paramname">geometries</td><td>The set of geometries to query against. The distances between the surface of each geometry and the point Q will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance measurements. The ordering of the results is guaranteed to be consistent &ndash; for a fixed set of geometries, the results will remain the same.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if any <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html" title="Type used to identify geometry instances in SceneGraph.">GeometryId</a> in <span class="tt">geometries</span> is invalid. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the combination of an indicated geometry's <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The abstract base class for all shape specifications.">Shape</a> type and the given scalar Type T are unsupported in <a class="el" href="#aeca0215b59030bb92a966389601bd1b0" title="Computes the signed distances and gradients to a query point from each geometry in the scene.">ComputeSignedDistanceToPoint()</a>'s support table. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if any indicated geometry is deformable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29c2be44ce16d6f7b49fdfe8b9cad4bb" name="a29c2be44ce16d6f7b49fdfe8b9cad4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c2be44ce16d6f7b49fdfe8b9cad4bb">&#9670;&#160;</a></span>ComputeSignedDistancePairClosestPoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1geometry_1_1_signed_distance_pair.html">SignedDistancePair</a>&lt; T &gt; ComputeSignedDistancePairClosestPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a></td>          <td class="paramname"><span class="paramname"><em>geometry_id_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a></td>          <td class="paramname"><span class="paramname"><em>geometry_id_B</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variant of <a class="el" href="#a9635a78abfdafe01871579fdd3961bea" title="Computes the signed distance together with the nearest points across all pairs of geometries in the w...">ComputeSignedDistancePairwiseClosestPoints()</a> which computes the signed distance (and witnesses) between a specific pair of geometries indicated by id. </p>
<p>This function has the same restrictions on scalar report as <a class="el" href="#a9635a78abfdafe01871579fdd3961bea" title="Computes the signed distance together with the nearest points across all pairs of geometries in the w...">ComputeSignedDistancePairwiseClosestPoints()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This query is unique among the distance queries in that it doesn't respect collision filters. As long as the geometry ids refer to geometries with proximity roles, signed distance can be computed (subject to supported scalar tables above).</dd></dl>
<h3>Characterizing the returned values</h3>
<p>This method merely exercises the same mechanisms as <a class="el" href="#a9635a78abfdafe01871579fdd3961bea" title="Computes the signed distance together with the nearest points across all pairs of geometries in the w...">ComputeSignedDistancePairwiseClosestPoints()</a> for evaluating signed distance. Refer to <a class="el" href="#query_object_compute_pairwise_distance_table">the table for ComputeSignedDistancePairwiseClosestPoints()</a> for details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if either geometry id is invalid (e.g., doesn't refer to an existing geometry, lacking proximity role, etc.), the pair is unsupported as indicated by the scalar support table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>For <a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Definition of a general (possibly non-convex) mesh.">Mesh</a> shapes, their convex hulls are used in this query. It is <em>not</em> computationally efficient or particularly accurate. </dd></dl>

</div>
</div>
<a id="a9635a78abfdafe01871579fdd3961bea" name="a9635a78abfdafe01871579fdd3961bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9635a78abfdafe01871579fdd3961bea">&#9670;&#160;</a></span>ComputeSignedDistancePairwiseClosestPoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structdrake_1_1geometry_1_1_signed_distance_pair.html">SignedDistancePair</a>&lt; T &gt; &gt; ComputeSignedDistancePairwiseClosestPoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>max_distance</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;&#160;<a class="el" href="classdouble.html">double</a>&#160;&gt;::infinity()</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the signed distance together with the nearest points across all pairs of geometries in the world. </p>
<p>Reports both the separating geometries and penetrating geometries.</p>
<p>This query provides φ(A, B), the signed distance between two objects A and B.</p>
<p>If the objects do not overlap (i.e., A ⋂ B = ∅), φ &gt; 0 and represents the minimal distance between the two objects. More formally: φ = min(|Aₚ - Bₚ|) ∀ Aₚ ∈ A and Bₚ ∈ B. </p><dl class="section note"><dt>Note</dt><dd>The pair (Aₚ, Bₚ) is a "witness" of the distance. The pair need not be unique (think of two parallel planes).</dd></dl>
<p>If the objects touch or overlap (i.e., A ⋂ B ≠ ∅), φ ≤ 0 and can be interpreted as the negative penetration depth. It is the smallest length of the vector v, such that by shifting one object along that vector relative to the other, the two objects will no longer be overlapping. More formally, φ(A, B) = -min |v|. s.t (Tᵥ · A) ⋂ B = ∅ where Tᵥ is a rigid transformation that displaces A by the vector v, namely Tᵥ · A = {u + v | ∀ u ∈ A}. By implication, there exist points Aₚ and Bₚ on the surfaces of objects A and B, respectively, such that Aₚ + v = Bₚ, Aₚ ∈ A ∩ B, Bₚ ∈ A ∩ B. These points are the witnesses to the penetration.</p>
<p>This method is affected by collision filtering; geometry pairs that have been filtered will not produce signed distance query results.</p>
<p>For a geometry pair (A, B), the returned results will always be reported in a fixed order (e.g., always (A, B) and never (B, A)). The <em>basis</em> for the ordering is arbitrary (and therefore undocumented), but guaranteed to be fixed and repeatable.</p>
<p>Notice that this is an O(N²) operation, where N is the number of geometries remaining in the world after applying collision filter. We report the distance between dynamic objects, and between dynamic and anchored objects. We DO NOT report the distance between two anchored objects.</p>
<h3>Using maximum distance</h3>
<p>While the algorithm generally has O(N²) complexity in time and space, that can be reduced by the judicious use of the <span class="tt">max_distance</span> parameter. If <span class="tt">φ(A, B) &gt; max_distance</span>, the pair (A, B) will not be included in the results (making it O(M²) in space where M &lt; N). Furthermore, the broadphase culling algorithm can exploit <span class="tt">max_distance</span> to <em>cheaply</em> eliminate pairs of geometry that are "obviously" too far (likewise reducing the time complexity).</p>
<p>Passing <span class="tt">max_distance = 0</span> is conceptually related to calling <a class="el" href="#a3f702eb73e7464c00b82974d0c5ff6c9" title="Reports true if there are any collisions between unfiltered pairs in the world.">HasCollisions()</a>. If contact is sparse (very few actually contacting geometry pairs), the two invocations will be quite similar in cost. However, the distinction between the two is that <em>this</em> method would have to include <em>all</em> pairs that satisfy <span class="tt">φ(A, B) &lt;= 0</span>, whereas <a class="el" href="#a3f702eb73e7464c00b82974d0c5ff6c9" title="Reports true if there are any collisions between unfiltered pairs in the world.">HasCollisions()</a> stops at the first. So, the more actually colliding geometry pairs there are, the bigger the difference in cost between the two approaches.</p>
<p><a class="anchor" id="query_object_compute_pairwise_distance_table"></a> </p><h3>Characterizing the returned values</h3>
<p>As discussed in the <a class="el" href="#query_object_precision_methodology">class's documentation</a>, this table documents the support given by this query for pairs of geometry types and scalar. See the description in the link for details on how to interpret the table results. The query is symmetric with respect to shape <em>ordering</em>, the pair (ShapeA, ShapeB) will be the same as (ShapeB, ShapeA), so we only fill in half the table.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight"></th><th class="markdownTableHeadCenter">Box  </th><th class="markdownTableHeadCenter">Capsule  </th><th class="markdownTableHeadCenter">Convex  </th><th class="markdownTableHeadCenter">Cylinder  </th><th class="markdownTableHeadCenter">Ellipsoid  </th><th class="markdownTableHeadCenter">HalfSpace  </th><th class="markdownTableHeadCenter">Mesh  </th><th class="markdownTableHeadCenter">Sphere  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_box.html" title="Definition of a box.">Box</a>  </td><td class="markdownTableBodyCenter">4e-15  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_capsule.html" title="Definition of a capsule.">Capsule</a>  </td><td class="markdownTableBodyCenter">3e-6  </td><td class="markdownTableBodyCenter">2e-5  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_convex.html" title="Definition of a convex surface mesh.">Convex</a>  </td><td class="markdownTableBodyCenter">3e-15  </td><td class="markdownTableBodyCenter">2e-5  </td><td class="markdownTableBodyCenter">3e-15  </td><td class="markdownTableBodyCenter">░░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_cylinder.html" title="Definition of a cylinder.">Cylinder</a>  </td><td class="markdownTableBodyCenter">6e-6  </td><td class="markdownTableBodyCenter">1e-5  </td><td class="markdownTableBodyCenter">6e-6  </td><td class="markdownTableBodyCenter">2e-5  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_ellipsoid.html" title="Definition of an ellipsoid.">Ellipsoid</a>  </td><td class="markdownTableBodyCenter">9e-6  </td><td class="markdownTableBodyCenter">5e-6  </td><td class="markdownTableBodyCenter">9e-6  </td><td class="markdownTableBodyCenter">5e-5  </td><td class="markdownTableBodyCenter">2e-5  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_half_space.html" title="Definition of a half space.">HalfSpace</a>  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Definition of a general (possibly non-convex) mesh.">Mesh</a>  </td><td class="markdownTableBodyCenter">ᶜ  </td><td class="markdownTableBodyCenter">ᶜ  </td><td class="markdownTableBodyCenter">ᶜ  </td><td class="markdownTableBodyCenter">ᶜ  </td><td class="markdownTableBodyCenter">ᶜ  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">ᶜ  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_sphere.html" title="Definition of sphere.">Sphere</a>  </td><td class="markdownTableBodyCenter">3e-15  </td><td class="markdownTableBodyCenter">6e-15  </td><td class="markdownTableBodyCenter">3e-6  </td><td class="markdownTableBodyCenter">5e-15  </td><td class="markdownTableBodyCenter">4e-5  </td><td class="markdownTableBodyCenter">3e-15  </td><td class="markdownTableBodyCenter">ᶜ  </td><td class="markdownTableBodyCenter">6e-15  </td></tr>
</table>
<p><b><em>Table 4</em></b>: Worst observed error (in m) for 2mm penetration/separation between geometries approximately 20cm in size for <span class="tt">T</span> = <span class="tt">double</span>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight"></th><th class="markdownTableHeadCenter">Box  </th><th class="markdownTableHeadCenter">Capsule  </th><th class="markdownTableHeadCenter">Convex  </th><th class="markdownTableHeadCenter">Cylinder  </th><th class="markdownTableHeadCenter">Ellipsoid  </th><th class="markdownTableHeadCenter">HalfSpace  </th><th class="markdownTableHeadCenter">Mesh  </th><th class="markdownTableHeadCenter">Sphere  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_box.html" title="Definition of a box.">Box</a>  </td><td class="markdownTableBodyCenter">throwsᵇ  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_capsule.html" title="Definition of a capsule.">Capsule</a>  </td><td class="markdownTableBodyCenter">throwsᵇ  </td><td class="markdownTableBodyCenter">throwsᵇ  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_convex.html" title="Definition of a convex surface mesh.">Convex</a>  </td><td class="markdownTableBodyCenter">throwsᵇ  </td><td class="markdownTableBodyCenter">throwsᵇ  </td><td class="markdownTableBodyCenter">throwsᵇ  </td><td class="markdownTableBodyCenter">░░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_cylinder.html" title="Definition of a cylinder.">Cylinder</a>  </td><td class="markdownTableBodyCenter">throwsᵇ  </td><td class="markdownTableBodyCenter">throwsᵇ  </td><td class="markdownTableBodyCenter">throwsᵇ  </td><td class="markdownTableBodyCenter">throwsᵇ  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_ellipsoid.html" title="Definition of an ellipsoid.">Ellipsoid</a>  </td><td class="markdownTableBodyCenter">throwsᵇ  </td><td class="markdownTableBodyCenter">throwsᵇ  </td><td class="markdownTableBodyCenter">throwsᵇ  </td><td class="markdownTableBodyCenter">throwsᵇ  </td><td class="markdownTableBodyCenter">throwsᵇ  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_half_space.html" title="Definition of a half space.">HalfSpace</a>  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Definition of a general (possibly non-convex) mesh.">Mesh</a>  </td><td class="markdownTableBodyCenter">ᶜ  </td><td class="markdownTableBodyCenter">ᶜ  </td><td class="markdownTableBodyCenter">ᶜ  </td><td class="markdownTableBodyCenter">ᶜ  </td><td class="markdownTableBodyCenter">ᶜ  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">ᶜ  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_sphere.html" title="Definition of sphere.">Sphere</a>  </td><td class="markdownTableBodyCenter">2e-15  </td><td class="markdownTableBodyCenter">throwsᵇ  </td><td class="markdownTableBodyCenter">throwsᵇ  </td><td class="markdownTableBodyCenter">throwsᵇ  </td><td class="markdownTableBodyCenter">throwsᵇ  </td><td class="markdownTableBodyCenter">2e-15  </td><td class="markdownTableBodyCenter">ᶜ  </td><td class="markdownTableBodyCenter">5e-15  </td></tr>
</table>
<p><b><em>Table 5</em></b>: Worst observed error (in m) for 2mm penetration/separation between geometries approximately 20cm in size for <span class="tt">T</span> = <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight"></th><th class="markdownTableHeadCenter">Box  </th><th class="markdownTableHeadCenter">Capsule  </th><th class="markdownTableHeadCenter">Convex  </th><th class="markdownTableHeadCenter">Cylinder  </th><th class="markdownTableHeadCenter">Ellipsoid  </th><th class="markdownTableHeadCenter">HalfSpace  </th><th class="markdownTableHeadCenter">Mesh  </th><th class="markdownTableHeadCenter">Sphere  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_box.html" title="Definition of a box.">Box</a>  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_capsule.html" title="Definition of a capsule.">Capsule</a>  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_convex.html" title="Definition of a convex surface mesh.">Convex</a>  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">░░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_cylinder.html" title="Definition of a cylinder.">Cylinder</a>  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_ellipsoid.html" title="Definition of an ellipsoid.">Ellipsoid</a>  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_half_space.html" title="Definition of a half space.">HalfSpace</a>  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Definition of a general (possibly non-convex) mesh.">Mesh</a>  </td><td class="markdownTableBodyCenter">ᶜ  </td><td class="markdownTableBodyCenter">ᶜ  </td><td class="markdownTableBodyCenter">ᶜ  </td><td class="markdownTableBodyCenter">ᶜ  </td><td class="markdownTableBodyCenter">ᶜ  </td><td class="markdownTableBodyCenter">throwsᵃ  </td><td class="markdownTableBodyCenter">ᶜ  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_sphere.html" title="Definition of sphere.">Sphere</a>  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td><td class="markdownTableBodyCenter">ᶜ  </td><td class="markdownTableBodyCenter">throwsᵈ  </td></tr>
</table>
<p><b><em>Table 6</em></b>: Support for <span class="tt">T</span> = <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>.</p>
<ul>
<li>ᵃ We don't currently support queries between <a class="el" href="classdrake_1_1geometry_1_1_half_space.html" title="Definition of a half space.">HalfSpace</a> and any other shape (except for <a class="el" href="classdrake_1_1geometry_1_1_sphere.html" title="Definition of sphere.">Sphere</a>).</li>
<li>ᵇ These results are simply not supported for <span class="tt">T</span> = <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> at this time.</li>
<li>ᶜ Meshes are represented by the <em>convex</em> hull of the mesh, therefore the results for <a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Definition of a general (possibly non-convex) mesh.">Mesh</a> are the same as for <a class="el" href="classdrake_1_1geometry_1_1_convex.html" title="Definition of a convex surface mesh.">Convex</a>.</li>
<li>ᵈ These results are simply not supported for <span class="tt">T</span> = <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> at this time.</li>
</ul>
<p><a class="anchor" id="query_object_compute_pairwise_distance_gradient_table"></a> </p><h3>Characterizing the returned gradients</h3>
<p>In most cases, the returned gradient vectors are the normalized displacement vectors between two witness points. However, when two geometries touch at zero distance, their witness points have a zero displacement vector that we cannot normalize.</p>
<p>When two geometries touch at zero distance, we have special implementation to choose reasonable gradients for some cases shown as "Ok" in the table below. Otherwise, they are "NaN" in the table. In general, we try to choose the gradient, when two geometries touch, in the most consistent way, but the problem sometimes doesn't have a unique solution. For example, any direction is qualified to be the gradient for two concentric spheres. Or two boxes touching at their vertices can pick a gradient from a continuous family of directions.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight"></th><th class="markdownTableHeadCenter">Box  </th><th class="markdownTableHeadCenter">Capsule  </th><th class="markdownTableHeadCenter">Convex  </th><th class="markdownTableHeadCenter">Cylinder  </th><th class="markdownTableHeadCenter">Ellipsoid  </th><th class="markdownTableHeadCenter">HalfSpace  </th><th class="markdownTableHeadCenter">Mesh  </th><th class="markdownTableHeadCenter">Sphere  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_box.html" title="Definition of a box.">Box</a>  </td><td class="markdownTableBodyCenter">Ok  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_capsule.html" title="Definition of a capsule.">Capsule</a>  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_convex.html" title="Definition of a convex surface mesh.">Convex</a>  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">░░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_cylinder.html" title="Definition of a cylinder.">Cylinder</a>  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_ellipsoid.html" title="Definition of an ellipsoid.">Ellipsoid</a>  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">░░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_half_space.html" title="Definition of a half space.">HalfSpace</a>  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">░░░░░  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Definition of a general (possibly non-convex) mesh.">Mesh</a>  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">NaN  </td><td class="markdownTableBodyCenter">░░░░░  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight"><a class="el" href="classdrake_1_1geometry_1_1_sphere.html" title="Definition of sphere.">Sphere</a>  </td><td class="markdownTableBodyCenter">Ok  </td><td class="markdownTableBodyCenter">Ok  </td><td class="markdownTableBodyCenter">Okᵃ  </td><td class="markdownTableBodyCenter">Ok  </td><td class="markdownTableBodyCenter">Okᵃ  </td><td class="markdownTableBodyCenter">Ok  </td><td class="markdownTableBodyCenter">Okᵃ  </td><td class="markdownTableBodyCenter">Ok  </td></tr>
</table>
<p><b><em>Table 7</em></b>: Support for signed-distance gradients when two geometries touch at zero distance.</p>
<ul>
<li>ᵃ Return the gradient as a Vector3d of NaN if the sphere has zero radius.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_distance</td><td>The maximum distance at which distance data is reported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The signed distance (and supporting data) for all unfiltered geometry pairs whose distance is less than or equal to <span class="tt">max_distance</span>. The ordering of the results is guaranteed to be consistent &ndash; for fixed geometry poses, the results will remain the same. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>as indicated in the table above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>For <a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Definition of a general (possibly non-convex) mesh.">Mesh</a> shapes, their convex hulls are used in this query. It is not* computationally efficient or particularly accurate. </dd></dl>

</div>
</div>
<a id="aeca0215b59030bb92a966389601bd1b0" name="aeca0215b59030bb92a966389601bd1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca0215b59030bb92a966389601bd1b0">&#9670;&#160;</a></span>ComputeSignedDistanceToPoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structdrake_1_1geometry_1_1_signed_distance_to_point.html">SignedDistanceToPoint</a>&lt; T &gt; &gt; ComputeSignedDistanceToPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_WQ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>threshold</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;&#160;<a class="el" href="classdouble.html">double</a>&#160;&gt;::infinity()</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the signed distances and gradients to a query point from each geometry in the scene. </p>
<p>This query provides φᵢ(p), φᵢ:ℝ³→ℝ, the signed distance to the position p of a query point from geometry Gᵢ in the scene. It returns an array of the signed distances from all geometries.</p>
<p>Optionally you can specify a threshold distance that will filter out any object beyond the threshold. By default, we report distances from the query point to every object.</p>
<p>This query also provides the gradient vector ∇φᵢ(p) of the signed distance function from geometry Gᵢ. Note that, in general, if p is outside Gᵢ, then ∇φᵢ(p) equals the unit vector in the direction from the nearest point Nᵢ on Gᵢ's surface to p. If p is inside Gᵢ, then ∇φᵢ(p) is in the direction from p to Nᵢ. This observation is written formally as:</p>
<p>∇φᵢ(p) = (p - Nᵢ)/|p - Nᵢ| if p is outside Gᵢ</p>
<p>∇φᵢ(p) = -(p - Nᵢ)/|p - Nᵢ| if p is inside Gᵢ</p>
<p>Note that ∇φᵢ(p) is also defined on Gᵢ's surface, but we cannot use the above formula.</p>
<h3>Characterizing the returned values</h3>
<p>This table is a variant of that described in this <a class="el" href="#query_object_precision_methodology">class's documentation</a>. The query evaluates signed distance between <em>one</em> shape and a point (in contrast to other queries which involve two shapes). Therefore, we don't need a matrix of shape pairs, but a list of shapes. Otherwise, the methodology is the same as described, with the point being represented as a zero-radius sphere.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Scalar  </th><th class="markdownTableHeadCenter">Box  </th><th class="markdownTableHeadCenter">Capsule  </th><th class="markdownTableHeadCenter">Convex  </th><th class="markdownTableHeadCenter">Cylinder  </th><th class="markdownTableHeadCenter">Ellipsoid  </th><th class="markdownTableHeadCenter">HalfSpace  </th><th class="markdownTableHeadCenter">Mesh  </th><th class="markdownTableHeadCenter">Sphere  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">double  </td><td class="markdownTableBodyCenter">2e-15  </td><td class="markdownTableBodyCenter">4e-15  </td><td class="markdownTableBodyCenter">5e-15  </td><td class="markdownTableBodyCenter">3e-15  </td><td class="markdownTableBodyCenter">3e-5ᵇ  </td><td class="markdownTableBodyCenter">5e-15  </td><td class="markdownTableBodyCenter">5e-15ᶜ  </td><td class="markdownTableBodyCenter">4e-15  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc" title="An autodiff variable with a dynamic number of partials.">AutoDiffXd</a>  </td><td class="markdownTableBodyCenter">1e-15  </td><td class="markdownTableBodyCenter">7e-15  </td><td class="markdownTableBodyCenter">ᵃ  </td><td class="markdownTableBodyCenter">ᵃ  </td><td class="markdownTableBodyCenter">ᵃ  </td><td class="markdownTableBodyCenter">5e-15  </td><td class="markdownTableBodyCenter">ᵃ  </td><td class="markdownTableBodyCenter">3e-15  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Expression  </td><td class="markdownTableBodyCenter">ᵃ  </td><td class="markdownTableBodyCenter">ᵃ  </td><td class="markdownTableBodyCenter">ᵃ  </td><td class="markdownTableBodyCenter">ᵃ  </td><td class="markdownTableBodyCenter">ᵃ  </td><td class="markdownTableBodyCenter">ᵃ  </td><td class="markdownTableBodyCenter">ᵃ  </td><td class="markdownTableBodyCenter">ᵃ  </td></tr>
</table>
<p><b><em>Table 8</em></b>: Worst observed error (in m) for 2mm penetration/separation between geometry approximately 20cm in size and a point.</p>
<ul>
<li>ᵃ Unsupported geometry/scalar combinations are simply ignored; no results are reported for that geometry.</li>
<li>ᵇ This uses an <em>iterative</em> algorithm which introduces a relatively large and variable error. For example, as the eccentricity of the ellipsoid increases, this error may get worse. It also depends on the location of the projection of the query point on the ellipsoid; the closer that point is to the high curvature area, the bigger the effect. It is not immediately clear how much worse the answer will get.</li>
<li>ᶜ Only supports OBJ and tetrahedral VTK meshes. Unsupported meshes are simply ignored; no results are reported for that geometry. For OBJ meshes the surface mesh must satisfy specific requirements (see below). Unlike the other Shapes, witness points and gradients can be discontinuous on a mesh's exterior if it is non-convex.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>The Mesh of a triangular surface mesh must be a closed manifold without duplicate vertices or self-intersection, and every triangle's face winding gives an outward-pointing face normal. Drake does not currently validate the input mesh with respect to these properties. Instead, it does a good-faith computation assuming the properties, possibly returning incorrect results. Non-compliant meshes will introduce regions in which the query point will report the wrong sign (and, therefore, the wrong gradient) due to a misclassification of being inside or outside. This leads to discontinuities in the distance field across the boundaries of these regions; the distance sign will flip while the magnitude of the distance value is arbitrarily far away from zero. For open meshes, the same principle holds. The open mesh, which has no true concept of "inside", will nevertheless report some query points as being inside.</dd>
<dd>
The Mesh of a tetrahedral volume mesh has positive-volume tetrahedra, no duplicate vertices, no self-intersection, and any two tetrahedra intersect in a common triangular face, edge, or vertex or not at all. A "tetrahedron soup" is, in general, non-compliant to this condition. Violating meshes will introduce areas inside the volumes that are incorrectly treated as boundary surfaces. The query points near such problematic areas will report the wrong nearest points, distances, and gradients.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For a sphere G, the signed distance function φᵢ(p) has an undefined gradient vector at the center of the sphere&ndash;every point on the sphere's surface has the same distance to the center. In this case, we will assign ∇φᵢ(p) the unit vector Gx (x-directional vector of G's frame) expressed in World frame.</dd>
<dd>
For a box, at a point p on an edge or a corner of the box, the signed distance function φᵢ(p) has an undefined gradient vector. In this case, we will assign a unit vector in the direction of the average of the outward face unit normals of the incident faces of the edge or the corner. A point p is considered being on a face, or an edge, or a corner of the box if it lies within a certain tolerance from them.</dd>
<dd>
For a box B, if a point p is inside the box, and it is equidistant to multiple nearest faces, the signed distance function φᵢ(p) at p will have an undefined gradient vector. There is a nearest point candidate associated with each nearest face. In this case, we arbitrarily pick the point Nᵢ associated with one of the nearest faces. Please note that, due to the possible round off error arising from applying a pose X_WG to B, there is no guarantee which of the nearest faces will be used.</dd>
<dd>
The signed distance function is a continuous function with respect to the position of the query point, but its gradient vector field may not be continuous. Specifically at a position equidistant to multiple nearest points, its gradient vector field is not continuous.</dd>
<dd>
For a convex object, outside the object at positive distance from the boundary, the signed distance function is smooth (having continuous first-order partial derivatives).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_WQ</td><td>Position of a query point Q in world frame W. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>We ignore any object beyond this distance. By default, it is infinity, so we report distances from the query point to every object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">signed_distances</td><td>A vector populated with per-object signed distance values (and supporting data) for every supported geometry as shown in the table. See <a class="el" href="structdrake_1_1geometry_1_1_signed_distance_to_point.html" title="The data for reporting the signed distance from a query point to a geometry.">SignedDistanceToPoint</a>. The ordering of the results is guaranteed to be consistent &ndash; for fixed geometry poses, the results will remain the same.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there are meshes with extremely sharp features where the calculation of feature normals become unstable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe41ea509666ff17cd6479b6981e8bd2" name="abe41ea509666ff17cd6479b6981e8bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe41ea509666ff17cd6479b6981e8bd2">&#9670;&#160;</a></span>FindCollisionCandidates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> &gt; &gt; FindCollisionCandidates </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a conservative culling mechanism to create a subset of all possible geometry pairs based on non-zero intersections. </p>
<p>A geometry pair that is <em>absent</em> from the results is either a) culled by collision filters or b) <em>known</em> to be separated. The caller is responsible for confirming that the remaining, unculled geometry pairs are <em>actually</em> in collision.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector populated with collision pair candidates (the order will remain constant for a fixed population but can change as geometry ids are added/removed). </dd></dl>

</div>
</div>
<a id="a0191e5d7528f261a271151338dc44fb7" name="a0191e5d7528f261a271151338dc44fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0191e5d7528f261a271151338dc44fb7">&#9670;&#160;</a></span>GetConfigurationsInWorld()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp; GetConfigurationsInWorld </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a></td>          <td class="paramname"><span class="paramname"><em>deformable_geometry_id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the configuration of the deformable geometry indicated by <span class="tt">deformable_geometry_id</span> relative to the world frame. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1e53a99014cc2b67b021fe159770908a" title="Reports the position of the frame indicated by frame_id relative to the world frame.">GetPoseInWorld()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the geometry <span class="tt">deformable_geometry_id</span> is not valid or is not a deformable geometry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a474808e4b2931a73d6bcc686ab18da" name="a6a474808e4b2931a73d6bcc686ab18da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a474808e4b2931a73d6bcc686ab18da">&#9670;&#160;</a></span>GetDrivenMeshConfigurationsInWorld()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; GetDrivenMeshConfigurationsInWorld </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a></td>          <td class="paramname"><span class="paramname"><em>deformable_geometry_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#acdd79a1a4f81dd6ee5cddcb21149b951">Role</a></td>          <td class="paramname"><span class="paramname"><em>role</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the configurations of the driven meshes associated with the given role for the deformable geometry indicated by <span class="tt">deformable_geometry_id</span> relative to the world frame if the deformable geometry has that role. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the geometry associated with <span class="tt">deformable_geometry_id</span> is not a registered deformable geometry with the given role. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This feature is considered to be <b>experimental</b> and may change or be removed at any time, without any deprecation notice ahead of time. </dd></dl>

</div>
</div>
<a id="a584c93dc0a7b1158871450f4d136d675" name="a584c93dc0a7b1158871450f4d136d675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584c93dc0a7b1158871450f4d136d675">&#9670;&#160;</a></span>GetPoseInParent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp; GetPoseInParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a></td>          <td class="paramname"><span class="paramname"><em>frame_id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the position of the frame indicated by <span class="tt">frame_id</span> relative to its parent frame. </p>
<p>If the frame was registered with the world frame as its parent frame, this value will be identical to that returned by <a class="el" href="#a1e53a99014cc2b67b021fe159770908a" title="Reports the position of the frame indicated by frame_id relative to the world frame.">GetPoseInWorld()</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the frame <span class="tt">frame_id</span> is not valid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e53a99014cc2b67b021fe159770908a" name="a1e53a99014cc2b67b021fe159770908a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e53a99014cc2b67b021fe159770908a">&#9670;&#160;</a></span>GetPoseInWorld() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp; GetPoseInWorld </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a></td>          <td class="paramname"><span class="paramname"><em>frame_id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the position of the frame indicated by <span class="tt">frame_id</span> relative to the world frame. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the frame <span class="tt">frame_id</span> is not valid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8872fd6fffbdf59c19d0905cd9523b85" name="a8872fd6fffbdf59c19d0905cd9523b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8872fd6fffbdf59c19d0905cd9523b85">&#9670;&#160;</a></span>GetPoseInWorld() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp; GetPoseInWorld </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a></td>          <td class="paramname"><span class="paramname"><em>geometry_id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the position of the frame of the rigid geometry indicated by <span class="tt">geometry_id</span> relative to the world frame (X_WG). </p>
<dl class="section note"><dt>Note</dt><dd>This query is meaningless for deformable geometries. Their current state cannot be represented by a single rigid transformation. Instead, one should use <a class="el" href="#a0191e5d7528f261a271151338dc44fb7" title="Reports the configuration of the deformable geometry indicated by deformable_geometry_id relative to ...">GetConfigurationsInWorld()</a> to get the current vertex positions of the deformable geometry in the world frame. On the other hand, it <em>is</em> meaningful to query the <em>fixed</em> pose of the <em>reference</em> geometry in its parent frame (see <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html#a2355ee377392374a5ece011dda60c440" title="Reports the pose of the geometry G with the given geometry_id in its registered frame F.">SceneGraphInspector::GetPoseInFrame()</a>). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the geometry <span class="tt">geometry_id</span> is not valid or if it is deformable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50a46a53be3d4f848b9e5532e4f2f89f" name="a50a46a53be3d4f848b9e5532e4f2f89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a46a53be3d4f848b9e5532e4f2f89f">&#9670;&#160;</a></span>GetRenderEngineByName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1geometry_1_1render_1_1_render_engine.html">render::RenderEngine</a> * GetRenderEngineByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the named render engine, if it exists. </p>
<p>The RenderEngine is guaranteed to be up to date w.r.t. the poses and data in the context. </p>

</div>
</div>
<a id="a3f702eb73e7464c00b82974d0c5ff6c9" name="a3f702eb73e7464c00b82974d0c5ff6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f702eb73e7464c00b82974d0c5ff6c9">&#9670;&#160;</a></span>HasCollisions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool HasCollisions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports true if there are <em>any</em> collisions between unfiltered pairs in the world. </p>
<dl class="section warning"><dt>Warning</dt><dd>For <a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Definition of a general (possibly non-convex) mesh.">Mesh</a> shapes, their convex hulls are used in this query. It is not* computationally efficient or particularly accurate. </dd></dl>

</div>
</div>
<a id="a627247d114da429b0b6ed85f6b5db381" name="a627247d114da429b0b6ed85f6b5db381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627247d114da429b0b6ed85f6b5db381">&#9670;&#160;</a></span>inspector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html">SceneGraphInspector</a>&lt; T &gt; &amp; inspector </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides an inspector for the topological structure of the underlying scene graph data (see <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html" title="The SceneGraphInspector serves as a mechanism to query the topological structure of a SceneGraph inst...">SceneGraphInspector</a> for details). </p>

</div>
</div>
<a id="aaff0f1a21871c2b63a2dda795380655d" name="aaff0f1a21871c2b63a2dda795380655d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff0f1a21871c2b63a2dda795380655d">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a178aee469235aaf82788e93b8168709c" name="a178aee469235aaf82788e93b8168709c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178aee469235aaf82788e93b8168709c">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4cfc105838770263cb1e1ca3a6934945" name="a4cfc105838770263cb1e1ca3a6934945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cfc105838770263cb1e1ca3a6934945">&#9670;&#160;</a></span>RenderColorImage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RenderColorImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1render_1_1_color_render_camera.html">render::ColorRenderCamera</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>camera</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a></td>          <td class="paramname"><span class="paramname"><em>parent_frame</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const math::RigidTransformd &amp;</td>          <td class="paramname"><span class="paramname"><em>X_PC</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1systems_1_1sensors.html#af5afae0f791341ac7ad11eb6bcb092bd">systems::sensors::ImageRgba8U</a> *</td>          <td class="paramname"><span class="paramname"><em>color_image_out</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders an RGB image for the given <span class="tt">camera</span> posed with respect to the indicated parent frame P. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">camera</td><td>The camera to render from. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parent_frame</td><td>The id for the camera's parent frame. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">X_PC</td><td>The pose of the camera body in the parent frame. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">color_image_out</td><td>The rendered color image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa611fe62e12ad13ca9ef218844542210" name="aa611fe62e12ad13ca9ef218844542210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa611fe62e12ad13ca9ef218844542210">&#9670;&#160;</a></span>RenderDepthImage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RenderDepthImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1render_1_1_depth_render_camera.html">render::DepthRenderCamera</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>camera</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a></td>          <td class="paramname"><span class="paramname"><em>parent_frame</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const math::RigidTransformd &amp;</td>          <td class="paramname"><span class="paramname"><em>X_PC</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1systems_1_1sensors.html#a0558960d25000bd7cc8607cef2fd223b">systems::sensors::ImageDepth32F</a> *</td>          <td class="paramname"><span class="paramname"><em>depth_image_out</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders a depth image for the given <span class="tt">camera</span> posed with respect to the indicated parent frame P. </p>
<p>In contrast to the other rendering methods, rendering depth images doesn't provide the option to display the window; generally, basic depth images are not readily communicative to humans.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">camera</td><td>The camera to render from. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parent_frame</td><td>The id for the camera's parent frame. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">X_PC</td><td>The pose of the camera body in the parent frame. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">depth_image_out</td><td>The rendered depth image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba077b59ee3574bbe9a0a602c14293c3" name="aba077b59ee3574bbe9a0a602c14293c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba077b59ee3574bbe9a0a602c14293c3">&#9670;&#160;</a></span>RenderLabelImage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RenderLabelImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1render_1_1_color_render_camera.html">render::ColorRenderCamera</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>camera</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a></td>          <td class="paramname"><span class="paramname"><em>parent_frame</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const math::RigidTransformd &amp;</td>          <td class="paramname"><span class="paramname"><em>X_PC</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1systems_1_1sensors.html#af9f2ff2c09bd6626d594951724ed1d9a">systems::sensors::ImageLabel16I</a> *</td>          <td class="paramname"><span class="paramname"><em>label_image_out</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders a label image for the given <span class="tt">camera</span> posed with respect to the indicated parent frame P. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">camera</td><td>The camera to render from. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parent_frame</td><td>The id for the camera's parent frame. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">X_PC</td><td>The pose of the camera body in the parent frame. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">label_image_out</td><td>The rendered label image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-related-members" id="doc-related-members"></a><h2 id="header-doc-related-members" class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a4afb6aad87f505d5a5ae0031d1e1a707" name="a4afb6aad87f505d5a5ae0031d1e1a707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4afb6aad87f505d5a5ae0031d1e1a707">&#9670;&#160;</a></span>QueryObjectTest</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class QueryObjectTest</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a09e32deb354fd5ca0cc04c6f6110bcb7" name="a09e32deb354fd5ca0cc04c6f6110bcb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e32deb354fd5ca0cc04c6f6110bcb7">&#9670;&#160;</a></span>SceneGraph&lt; T &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">SceneGraph</a>&lt; T &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/geometry/<a class="el" href="query__object_8h.html">query_object.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1geometry.html">geometry</a></li><li class="navelem"><a href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
