<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: GcsTrajectoryOptimization::Subgraph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html','','classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">GcsTrajectoryOptimization::Subgraph Class Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html" title="A Subgraph is a subset of the larger graph.">Subgraph</a> is a subset of the larger graph. </p>
<p>It is defined by a set of regions and edges between them based on intersection. From an API standpoint, a <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html" title="A Subgraph is a subset of the larger graph.">Subgraph</a> is useful to define a multi-modal motion planning problem. Further, it allows different constraints and objects to be added to different subgraphs. Note that the the GraphOfConvexSets does not differentiate between subgraphs and can't be mixed with other instances of <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization.html" title="GcsTrajectoryOptimization implements a simplified motion planning optimization problem introduced in ...">GcsTrajectoryOptimization</a>. </p>
</div>
<p><code>#include &lt;drake/planning/trajectory_optimization/gcs_trajectory_optimization.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afd4d76dbdc92a7faeadeaeb590c266fa" id="r_afd4d76dbdc92a7faeadeaeb590c266fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd4d76dbdc92a7faeadeaeb590c266fa">~Subgraph</a> ()</td></tr>
<tr class="memitem:a24dcbf29c0d6cd766009a182a6484e3b" id="r_a24dcbf29c0d6cd766009a182a6484e3b"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24dcbf29c0d6cd766009a182a6484e3b">name</a> () const</td></tr>
<tr class="memdesc:a24dcbf29c0d6cd766009a182a6484e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the subgraph.  <br /></td></tr>
<tr class="memitem:abcc41a4e499b9ebcdc71c5e213c7c22f" id="r_abcc41a4e499b9ebcdc71c5e213c7c22f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcc41a4e499b9ebcdc71c5e213c7c22f">order</a> () const</td></tr>
<tr class="memdesc:abcc41a4e499b9ebcdc71c5e213c7c22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the order of the Bézier trajectory within the region.  <br /></td></tr>
<tr class="memitem:af9593d4a5ff4274efaf429cb4f9e57cc" id="r_af9593d4a5ff4274efaf429cb4f9e57cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9593d4a5ff4274efaf429cb4f9e57cc">size</a> () const</td></tr>
<tr class="memdesc:af9593d4a5ff4274efaf429cb4f9e57cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of vertices in the subgraph.  <br /></td></tr>
<tr class="memitem:aa5478d154028f99b63a278a02c3019c7" id="r_aa5478d154028f99b63a278a02c3019c7"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">geometry::optimization::GraphOfConvexSets::Vertex</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5478d154028f99b63a278a02c3019c7">Vertices</a> ()</td></tr>
<tr class="memdesc:aa5478d154028f99b63a278a02c3019c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns constant reference to a vector of mutable pointers to the vertices stored in the subgraph.  <br /></td></tr>
<tr class="memitem:a3b8a74c73da559868474429efb779ddc" id="r_a3b8a74c73da559868474429efb779ddc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">geometry::optimization::GraphOfConvexSets::Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b8a74c73da559868474429efb779ddc">Vertices</a> () const</td></tr>
<tr class="memdesc:a3b8a74c73da559868474429efb779ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointers to the vertices stored in the subgraph.  <br /></td></tr>
<tr class="memitem:a16aa5f1e21cfabaa7b8ea66f0d765c38" id="r_a16aa5f1e21cfabaa7b8ea66f0d765c38"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">geometry::optimization::GraphOfConvexSets::Edge</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16aa5f1e21cfabaa7b8ea66f0d765c38">Edges</a> ()</td></tr>
<tr class="memdesc:a16aa5f1e21cfabaa7b8ea66f0d765c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns constant reference to a vector of mutable pointers to the edges.  <br /></td></tr>
<tr class="memitem:a55b316bc68a341946a49f2a874c3a779" id="r_a55b316bc68a341946a49f2a874c3a779"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">geometry::optimization::GraphOfConvexSets::Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55b316bc68a341946a49f2a874c3a779">Edges</a> () const</td></tr>
<tr class="memdesc:a55b316bc68a341946a49f2a874c3a779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointers to the edges stored in the subgraph.  <br /></td></tr>
<tr class="memitem:afc38c3a4c0d42c7dedc75e4f9fa6697e" id="r_afc38c3a4c0d42c7dedc75e4f9fa6697e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">geometry::optimization::ConvexSets</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc38c3a4c0d42c7dedc75e4f9fa6697e">regions</a> () const</td></tr>
<tr class="memdesc:afc38c3a4c0d42c7dedc75e4f9fa6697e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the regions associated with this subgraph before the CartesianProduct.  <br /></td></tr>
<tr class="memitem:a515805314ae145e3be6b636d0986bb09" id="r_a515805314ae145e3be6b636d0986bb09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a515805314ae145e3be6b636d0986bb09">AddTimeCost</a> (double weight=1.0)</td></tr>
<tr class="memdesc:a515805314ae145e3be6b636d0986bb09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a minimum time cost to all regions in the subgraph.  <br /></td></tr>
<tr class="memitem:a5120b456754eef916922cd73d2ec846a" id="r_a5120b456754eef916922cd73d2ec846a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5120b456754eef916922cd73d2ec846a">AddPathLengthCost</a> (const Eigen::MatrixXd &amp;weight_matrix)</td></tr>
<tr class="memdesc:a5120b456754eef916922cd73d2ec846a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds multiple L2Norm Costs on the upper bound of the path length.  <br /></td></tr>
<tr class="memitem:a26e4396347f05f766a19a64910a338b9" id="r_a26e4396347f05f766a19a64910a338b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26e4396347f05f766a19a64910a338b9">AddPathEnergyCost</a> (const Eigen::MatrixXd &amp;weight_matrix)</td></tr>
<tr class="memdesc:a26e4396347f05f766a19a64910a338b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to AddPathLengthCost in usage, but minimizes ∑ |weight_matrix * (rᵢ₊₁ − rᵢ)|₂².  <br /></td></tr>
<tr class="memitem:a34f92ff4feccc5aa2e289b9a514486ac" id="r_a34f92ff4feccc5aa2e289b9a514486ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34f92ff4feccc5aa2e289b9a514486ac">AddPathLengthCost</a> (double weight=1.0)</td></tr>
<tr class="memdesc:a34f92ff4feccc5aa2e289b9a514486ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds multiple L2Norm Costs on the upper bound of the path length.  <br /></td></tr>
<tr class="memitem:af58fa24cbb7560c4a7551fdcb133d478" id="r_af58fa24cbb7560c4a7551fdcb133d478"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af58fa24cbb7560c4a7551fdcb133d478">AddPathEnergyCost</a> (double weight=1.0)</td></tr>
<tr class="memdesc:af58fa24cbb7560c4a7551fdcb133d478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to AddPathLengthCost in usage, but minimizes ∑ |(rᵢ₊₁ − rᵢ)|₂² with weight being applied uniformly to all dimensions.  <br /></td></tr>
<tr class="memitem:af27492cb5b0dbf8cd8ce10e792486052" id="r_af27492cb5b0dbf8cd8ce10e792486052"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af27492cb5b0dbf8cd8ce10e792486052">AddVelocityBounds</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub)</td></tr>
<tr class="memdesc:af27492cb5b0dbf8cd8ce10e792486052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear velocity constraint to the subgraph <span class="tt">lb</span> ≤ q̇(t) ≤ <span class="tt">ub</span>.  <br /></td></tr>
<tr class="memitem:a096ce11cacbbdc3be3dd3d189d81b93f" id="r_a096ce11cacbbdc3be3dd3d189d81b93f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a096ce11cacbbdc3be3dd3d189d81b93f">AddNonlinearDerivativeBounds</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub, int derivative_order)</td></tr>
<tr class="memdesc:a096ce11cacbbdc3be3dd3d189d81b93f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a nonlinear derivative constraints to the subgraph <span class="tt">lb</span> ≤ dᴺq(t) / dtᴺ ≤ <span class="tt">ub</span>.  <br /></td></tr>
<tr class="memitem:afce2be43547f60d510c7e46154eac653" id="r_afce2be43547f60d510c7e46154eac653"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afce2be43547f60d510c7e46154eac653">AddPathContinuityConstraints</a> (int continuity_order)</td></tr>
<tr class="memdesc:afce2be43547f60d510c7e46154eac653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enforces that for any two subsequent path segments within the subgraph, the <span class="tt">continuity_order</span>th path derivative at the end of the first segment equals that of the start of the second segment.  <br /></td></tr>
<tr class="memitem:a028f009e523ba70f19975c58f6b0bb6d" id="r_a028f009e523ba70f19975c58f6b0bb6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a028f009e523ba70f19975c58f6b0bb6d">AddContinuityConstraints</a> (int continuity_order)</td></tr>
<tr class="memdesc:a028f009e523ba70f19975c58f6b0bb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enforces that for any two subsequent path segments within the subgraph, the <span class="tt">continuity_order</span>th time derivative at the end of the first segment equals that of the start of the second segment.  <br /></td></tr>
<tr class="memitem:a5e7fe2c354ca6688ebc6e50fc8b079c4" id="r_a5e7fe2c354ca6688ebc6e50fc8b079c4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e7fe2c354ca6688ebc6e50fc8b079c4">vertex_duration</a> () const</td></tr>
<tr class="memdesc:a5e7fe2c354ca6688ebc6e50fc8b079c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a placeholder decision variable (not actually declared as a decision variable in the MathematicalProgram) associated with the time scaling of the trajectory in a set within this subgraph.  <br /></td></tr>
<tr class="memitem:ae6d17fd6e01b70a71ff7c2c23367656a" id="r_ae6d17fd6e01b70a71ff7c2c23367656a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">solvers::MatrixXDecisionVariable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6d17fd6e01b70a71ff7c2c23367656a">vertex_control_points</a> () const</td></tr>
<tr class="memdesc:ae6d17fd6e01b70a71ff7c2c23367656a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a placeholder decision variable (not actually declared as a decision variable in the MathematicalProgram) associated with the control points of the trajectory in a set within this subgraph.  <br /></td></tr>
<tr class="memitem:aad8edaa35ca3d51b0d184d2e5b499589" id="r_aad8edaa35ca3d51b0d184d2e5b499589"><td class="memItemLeft" align="right" valign="top">const std::pair&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad8edaa35ca3d51b0d184d2e5b499589">edge_constituent_vertex_durations</a> () const</td></tr>
<tr class="memdesc:aad8edaa35ca3d51b0d184d2e5b499589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair of placeholder decision variables (not actually declared as decision variables in the MathematicalProgram) associated with the time scaling of the trajectory in two sets within this subgraph that are connected by an internal edge.  <br /></td></tr>
<tr class="memitem:aec655c58ca6223d017860ba12cb124d2" id="r_aec655c58ca6223d017860ba12cb124d2"><td class="memItemLeft" align="right" valign="top">const std::pair&lt; <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">solvers::MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">solvers::MatrixXDecisionVariable</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec655c58ca6223d017860ba12cb124d2">edge_constituent_vertex_control_points</a> () const</td></tr>
<tr class="memdesc:aec655c58ca6223d017860ba12cb124d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair of placeholder decision variables (not actually declared as decision variables in the MathematicalProgram) associated with the control points of the trajectory in two sets within this subgraph that are connected by an internal edge.  <br /></td></tr>
<tr class="memitem:a648d5b0ce8cadb962ed9761e7a17bd29" id="r_a648d5b0ce8cadb962ed9761e7a17bd29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a648d5b0ce8cadb962ed9761e7a17bd29">AddVertexCost</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, const std::unordered_set&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5b">geometry::optimization::GraphOfConvexSets::Transcription</a> &gt; &amp;use_in_transcription={ <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5ba058f4d93de65b4c9dd778be760beaa90">geometry::optimization::GraphOfConvexSets::Transcription::kMIP</a>, <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5baf0eaaa21b3713d009fbdbbcfc1f8b9b8">geometry::optimization::GraphOfConvexSets::Transcription::kRelaxation</a>, <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5bae6e3b13561e5aed0294cf5ca5765dd02">geometry::optimization::GraphOfConvexSets::Transcription::kRestriction</a>})</td></tr>
<tr class="memdesc:a648d5b0ce8cadb962ed9761e7a17bd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an arbitrary user-defined cost to every vertex in the subgraph.  <br /></td></tr>
<tr class="memitem:a753c0c124aa5a790f2a4418ea8599607" id="r_a753c0c124aa5a790f2a4418ea8599607"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a753c0c124aa5a790f2a4418ea8599607">AddVertexCost</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">solvers::Cost</a> &gt; &amp;binding, const std::unordered_set&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5b">geometry::optimization::GraphOfConvexSets::Transcription</a> &gt; &amp;use_in_transcription={ <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5ba058f4d93de65b4c9dd778be760beaa90">geometry::optimization::GraphOfConvexSets::Transcription::kMIP</a>, <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5baf0eaaa21b3713d009fbdbbcfc1f8b9b8">geometry::optimization::GraphOfConvexSets::Transcription::kRelaxation</a>, <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5bae6e3b13561e5aed0294cf5ca5765dd02">geometry::optimization::GraphOfConvexSets::Transcription::kRestriction</a>})</td></tr>
<tr class="memdesc:a753c0c124aa5a790f2a4418ea8599607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience overload of AddVertexCost to take in a Binding&lt;Cost&gt;.  <br /></td></tr>
<tr class="memitem:a3345f9cc149be05e3d3215960b93899d" id="r_a3345f9cc149be05e3d3215960b93899d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3345f9cc149be05e3d3215960b93899d">AddVertexConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;e, const std::unordered_set&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5b">geometry::optimization::GraphOfConvexSets::Transcription</a> &gt; &amp;use_in_transcription={ <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5ba058f4d93de65b4c9dd778be760beaa90">geometry::optimization::GraphOfConvexSets::Transcription::kMIP</a>, <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5baf0eaaa21b3713d009fbdbbcfc1f8b9b8">geometry::optimization::GraphOfConvexSets::Transcription::kRelaxation</a>, <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5bae6e3b13561e5aed0294cf5ca5765dd02">geometry::optimization::GraphOfConvexSets::Transcription::kRestriction</a>})</td></tr>
<tr class="memdesc:a3345f9cc149be05e3d3215960b93899d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an arbitrary user-defined constraint to every vertex in the subgraph.  <br /></td></tr>
<tr class="memitem:a761332e0bc3697a2391606f3dc174804" id="r_a761332e0bc3697a2391606f3dc174804"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a761332e0bc3697a2391606f3dc174804">AddVertexConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &amp;binding, const std::unordered_set&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5b">geometry::optimization::GraphOfConvexSets::Transcription</a> &gt; &amp;use_in_transcription={ <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5ba058f4d93de65b4c9dd778be760beaa90">geometry::optimization::GraphOfConvexSets::Transcription::kMIP</a>, <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5baf0eaaa21b3713d009fbdbbcfc1f8b9b8">geometry::optimization::GraphOfConvexSets::Transcription::kRelaxation</a>, <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5bae6e3b13561e5aed0294cf5ca5765dd02">geometry::optimization::GraphOfConvexSets::Transcription::kRestriction</a>})</td></tr>
<tr class="memdesc:a761332e0bc3697a2391606f3dc174804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience overload of AddVertexConstraint to take in a Binding&lt;Constraint&gt;.  <br /></td></tr>
<tr class="memitem:aa9c3a75dd770a5776c3d438c8e5709d4" id="r_aa9c3a75dd770a5776c3d438c8e5709d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9c3a75dd770a5776c3d438c8e5709d4">AddEdgeCost</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, const std::unordered_set&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5b">geometry::optimization::GraphOfConvexSets::Transcription</a> &gt; &amp;use_in_transcription={ <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5ba058f4d93de65b4c9dd778be760beaa90">geometry::optimization::GraphOfConvexSets::Transcription::kMIP</a>, <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5baf0eaaa21b3713d009fbdbbcfc1f8b9b8">geometry::optimization::GraphOfConvexSets::Transcription::kRelaxation</a>, <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5bae6e3b13561e5aed0294cf5ca5765dd02">geometry::optimization::GraphOfConvexSets::Transcription::kRestriction</a>})</td></tr>
<tr class="memdesc:aa9c3a75dd770a5776c3d438c8e5709d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an arbitrary user-defined cost to every internal edge within the subgraph.  <br /></td></tr>
<tr class="memitem:a54efb3ca0f659db696545eeae1838b47" id="r_a54efb3ca0f659db696545eeae1838b47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54efb3ca0f659db696545eeae1838b47">AddEdgeCost</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">solvers::Cost</a> &gt; &amp;binding, const std::unordered_set&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5b">geometry::optimization::GraphOfConvexSets::Transcription</a> &gt; &amp;use_in_transcription={ <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5ba058f4d93de65b4c9dd778be760beaa90">geometry::optimization::GraphOfConvexSets::Transcription::kMIP</a>, <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5baf0eaaa21b3713d009fbdbbcfc1f8b9b8">geometry::optimization::GraphOfConvexSets::Transcription::kRelaxation</a>, <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5bae6e3b13561e5aed0294cf5ca5765dd02">geometry::optimization::GraphOfConvexSets::Transcription::kRestriction</a>})</td></tr>
<tr class="memdesc:a54efb3ca0f659db696545eeae1838b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience overload of AddEdgeCost to take in a Binding&lt;Cost&gt;.  <br /></td></tr>
<tr class="memitem:af167f42cb53ff17e0666e38d54d241bd" id="r_af167f42cb53ff17e0666e38d54d241bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af167f42cb53ff17e0666e38d54d241bd">AddEdgeConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;e, const std::unordered_set&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5b">geometry::optimization::GraphOfConvexSets::Transcription</a> &gt; &amp;use_in_transcription={ <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5ba058f4d93de65b4c9dd778be760beaa90">geometry::optimization::GraphOfConvexSets::Transcription::kMIP</a>, <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5baf0eaaa21b3713d009fbdbbcfc1f8b9b8">geometry::optimization::GraphOfConvexSets::Transcription::kRelaxation</a>, <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5bae6e3b13561e5aed0294cf5ca5765dd02">geometry::optimization::GraphOfConvexSets::Transcription::kRestriction</a>})</td></tr>
<tr class="memdesc:af167f42cb53ff17e0666e38d54d241bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an arbitrary user-defined constraint (in the form of a Formula or Binding&lt;Constraint&gt;) to every internal edge within the subgraph.  <br /></td></tr>
<tr class="memitem:aecf31cc0f9cbf83a3c3f1d446573fb2a" id="r_aecf31cc0f9cbf83a3c3f1d446573fb2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecf31cc0f9cbf83a3c3f1d446573fb2a">AddEdgeConstraint</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &amp;binding, const std::unordered_set&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5b">geometry::optimization::GraphOfConvexSets::Transcription</a> &gt; &amp;use_in_transcription={ <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5ba058f4d93de65b4c9dd778be760beaa90">geometry::optimization::GraphOfConvexSets::Transcription::kMIP</a>, <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5baf0eaaa21b3713d009fbdbbcfc1f8b9b8">geometry::optimization::GraphOfConvexSets::Transcription::kRelaxation</a>, <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5bae6e3b13561e5aed0294cf5ca5765dd02">geometry::optimization::GraphOfConvexSets::Transcription::kRestriction</a>})</td></tr>
<tr class="memdesc:aecf31cc0f9cbf83a3c3f1d446573fb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience overload of AddEdgeConstraint to take in a Binding&lt;Constraint&gt;.  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:af9772f89f467b3eb25e91de87a3d4ee8" id="r_af9772f89f467b3eb25e91de87a3d4ee8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9772f89f467b3eb25e91de87a3d4ee8">Subgraph</a> (const Subgraph &amp;)=delete</td></tr>
<tr class="memitem:a257a41ec38a68f097105892d028519d3" id="r_a257a41ec38a68f097105892d028519d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af9772f89f467b3eb25e91de87a3d4ee8">Subgraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a257a41ec38a68f097105892d028519d3">operator=</a> (const <a class="el" href="#af9772f89f467b3eb25e91de87a3d4ee8">Subgraph</a> &amp;)=delete</td></tr>
<tr class="memitem:a2bed1e04d783671aecf7e72323f48959" id="r_a2bed1e04d783671aecf7e72323f48959"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bed1e04d783671aecf7e72323f48959">Subgraph</a> (Subgraph &amp;&amp;)=delete</td></tr>
<tr class="memitem:ada332620505baeb39b9f76238a471967" id="r_ada332620505baeb39b9f76238a471967"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af9772f89f467b3eb25e91de87a3d4ee8">Subgraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada332620505baeb39b9f76238a471967">operator=</a> (<a class="el" href="#af9772f89f467b3eb25e91de87a3d4ee8">Subgraph</a> &amp;&amp;)=delete</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-friends" class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa69be52668ec461d59f91ad7eaca3a89" id="r_aa69be52668ec461d59f91ad7eaca3a89"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa69be52668ec461d59f91ad7eaca3a89">GcsTrajectoryOptimization</a></td></tr>
</table>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af9772f89f467b3eb25e91de87a3d4ee8" name="af9772f89f467b3eb25e91de87a3d4ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9772f89f467b3eb25e91de87a3d4ee8">&#9670;&#160;</a></span>Subgraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Subgraph </td>
          <td>(</td>
          <td class="paramtype">const Subgraph &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bed1e04d783671aecf7e72323f48959" name="a2bed1e04d783671aecf7e72323f48959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bed1e04d783671aecf7e72323f48959">&#9670;&#160;</a></span>Subgraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Subgraph </td>
          <td>(</td>
          <td class="paramtype">Subgraph &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd4d76dbdc92a7faeadeaeb590c266fa" name="afd4d76dbdc92a7faeadeaeb590c266fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4d76dbdc92a7faeadeaeb590c266fa">&#9670;&#160;</a></span>~Subgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="#af9772f89f467b3eb25e91de87a3d4ee8">Subgraph</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a028f009e523ba70f19975c58f6b0bb6d" name="a028f009e523ba70f19975c58f6b0bb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028f009e523ba70f19975c58f6b0bb6d">&#9670;&#160;</a></span>AddContinuityConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddContinuityConstraints </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>continuity_order</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enforces that for any two subsequent path segments within the subgraph, the <span class="tt">continuity_order</span>th time derivative at the end of the first segment equals that of the start of the second segment. </p>
<p>This adds a nonlinear constraint to the restriction and MIP GraphOfConvexSets::Transcription, while adding a convex surrogate to the relaxation. For more details, see <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#nonconvex_graph_of_convex_sets">Guiding Non-convex Optimization with the GraphOfConvexSets</a>.</p>
<p>The continuity is enforced on the control points of q(t), which appear as nonlinear constraints. </p><pre> (dᴺrᵤ(s=1) / dsᴺ) / hᵤᴺ == (dᴺrᵥ(s=0) / dsᴺ) / hᵥᴺ </pre><p> The convex surrogate is simply the path continuity, where hᵤᴺ and hᵥᴺ are replaced by the characteristic times of the respective sets: </p><pre> (dᴺrᵤ(s=1) / dsᴺ) / hᵤ₀ᴺ == (dᴺrᵥ(s=0) / dsᴺ) / hᵥ₀ᴺ </pre><p>. For now, these are set to one, but future work may involve scaling them by the size of the sets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">continuity_order</td><td>is the order of the continuity constraint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the continuity order is not equal or less than the order the subgraphs. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the continuity order is less than one since path continuity is enforced by default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>To enforce that the trajectory is of class C^k, you must call AddContinuityConstraint for each continuity_order 1 through k. </dd></dl>

</div>
</div>
<a id="aecf31cc0f9cbf83a3c3f1d446573fb2a" name="aecf31cc0f9cbf83a3c3f1d446573fb2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf31cc0f9cbf83a3c3f1d446573fb2a">&#9670;&#160;</a></span>AddEdgeConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddEdgeConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5b">geometry::optimization::GraphOfConvexSets::Transcription</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>use_in_transcription</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5ba058f4d93de65b4c9dd778be760beaa90">geometry::optimization::GraphOfConvexSets::Transcription::kMIP</a>,&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5baf0eaaa21b3713d009fbdbbcfc1f8b9b8">geometry::optimization::GraphOfConvexSets::Transcription::kRelaxation</a>,&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5bae6e3b13561e5aed0294cf5ca5765dd02">geometry::optimization::GraphOfConvexSets::Transcription::kRestriction</a>}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience overload of AddEdgeConstraint to take in a Binding&lt;Constraint&gt;. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if any variables besides those from <a class="el" href="#aad8edaa35ca3d51b0d184d2e5b499589">edge_constituent_vertex_durations</a> and <a class="el" href="#aec655c58ca6223d017860ba12cb124d2">edge_constituent_vertex_control_points</a> are used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af167f42cb53ff17e0666e38d54d241bd" name="af167f42cb53ff17e0666e38d54d241bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af167f42cb53ff17e0666e38d54d241bd">&#9670;&#160;</a></span>AddEdgeConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddEdgeConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5b">geometry::optimization::GraphOfConvexSets::Transcription</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>use_in_transcription</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5ba058f4d93de65b4c9dd778be760beaa90">geometry::optimization::GraphOfConvexSets::Transcription::kMIP</a>,&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5baf0eaaa21b3713d009fbdbbcfc1f8b9b8">geometry::optimization::GraphOfConvexSets::Transcription::kRelaxation</a>,&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5bae6e3b13561e5aed0294cf5ca5765dd02">geometry::optimization::GraphOfConvexSets::Transcription::kRestriction</a>}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an arbitrary user-defined constraint (in the form of a Formula or Binding&lt;Constraint&gt;) to every internal edge within the subgraph. </p>
<p>The constraint should be defined using the placeholder control point variables (obtained from <a class="el" href="#aec655c58ca6223d017860ba12cb124d2" title="Returns a pair of placeholder decision variables (not actually declared as decision variables in the ...">edge_constituent_vertex_control_points()</a>) and the placeholder time scaling variables (obtained from <a class="el" href="#aad8edaa35ca3d51b0d184d2e5b499589" title="Returns a pair of placeholder decision variables (not actually declared as decision variables in the ...">edge_constituent_vertex_durations()</a>). This enables greater modeling freedom, but we cannot guarantee a feasible solution for all possible constraints.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if any variables besides those from <a class="el" href="#aad8edaa35ca3d51b0d184d2e5b499589">edge_constituent_vertex_durations</a> and <a class="el" href="#aec655c58ca6223d017860ba12cb124d2">edge_constituent_vertex_control_points</a> are used.</td></tr>
  </table>
  </dd>
</dl>
<p>Constraints which do not support the perspective operation cannot be used with Transcription::kMIP or Transcription::kRelaxation. Consider providing an appropriate "convex surrogate" that is supported within GraphOfConvexSets, or exclusively using the SolveConvexRestriction method. </p>

</div>
</div>
<a id="a54efb3ca0f659db696545eeae1838b47" name="a54efb3ca0f659db696545eeae1838b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54efb3ca0f659db696545eeae1838b47">&#9670;&#160;</a></span>AddEdgeCost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddEdgeCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">solvers::Cost</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5b">geometry::optimization::GraphOfConvexSets::Transcription</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>use_in_transcription</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5ba058f4d93de65b4c9dd778be760beaa90">geometry::optimization::GraphOfConvexSets::Transcription::kMIP</a>,&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5baf0eaaa21b3713d009fbdbbcfc1f8b9b8">geometry::optimization::GraphOfConvexSets::Transcription::kRelaxation</a>,&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5bae6e3b13561e5aed0294cf5ca5765dd02">geometry::optimization::GraphOfConvexSets::Transcription::kRestriction</a>}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience overload of AddEdgeCost to take in a Binding&lt;Cost&gt;. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if any variables besides those from <a class="el" href="#aad8edaa35ca3d51b0d184d2e5b499589">edge_constituent_vertex_durations</a> and <a class="el" href="#aec655c58ca6223d017860ba12cb124d2">edge_constituent_vertex_control_points</a> are used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9c3a75dd770a5776c3d438c8e5709d4" name="aa9c3a75dd770a5776c3d438c8e5709d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c3a75dd770a5776c3d438c8e5709d4">&#9670;&#160;</a></span>AddEdgeCost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddEdgeCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5b">geometry::optimization::GraphOfConvexSets::Transcription</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>use_in_transcription</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5ba058f4d93de65b4c9dd778be760beaa90">geometry::optimization::GraphOfConvexSets::Transcription::kMIP</a>,&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5baf0eaaa21b3713d009fbdbbcfc1f8b9b8">geometry::optimization::GraphOfConvexSets::Transcription::kRelaxation</a>,&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5bae6e3b13561e5aed0294cf5ca5765dd02">geometry::optimization::GraphOfConvexSets::Transcription::kRestriction</a>}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an arbitrary user-defined cost to every internal edge within the subgraph. </p>
<p>The cost should be defined using the placeholder control point variables (obtained from <a class="el" href="#aec655c58ca6223d017860ba12cb124d2" title="Returns a pair of placeholder decision variables (not actually declared as decision variables in the ...">edge_constituent_vertex_control_points()</a>) and the placeholder time scaling variables (obtained from <a class="el" href="#aad8edaa35ca3d51b0d184d2e5b499589" title="Returns a pair of placeholder decision variables (not actually declared as decision variables in the ...">edge_constituent_vertex_durations()</a>). This enables greater modeling freedom, but we cannot guarantee a feasible solution for all possible costs.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if any variables besides those from <a class="el" href="#aad8edaa35ca3d51b0d184d2e5b499589">edge_constituent_vertex_durations</a> and <a class="el" href="#aec655c58ca6223d017860ba12cb124d2">edge_constituent_vertex_control_points</a> are used.</td></tr>
  </table>
  </dd>
</dl>
<p>Costs which do not support the perspective operation cannot be used with Transcription::kMIP or Transcription::kRelaxation. Consider providing an appropriate "convex surrogate" that is supported within GraphOfConvexSets, or exclusively using the SolveConvexRestriction method. </p>

</div>
</div>
<a id="a096ce11cacbbdc3be3dd3d189d81b93f" name="a096ce11cacbbdc3be3dd3d189d81b93f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096ce11cacbbdc3be3dd3d189d81b93f">&#9670;&#160;</a></span>AddNonlinearDerivativeBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddNonlinearDerivativeBounds </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>derivative_order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a nonlinear derivative constraints to the subgraph <span class="tt">lb</span> ≤ dᴺq(t) / dtᴺ ≤ <span class="tt">ub</span>. </p>
<p>This adds a nonlinear constraint to the restriction and MIP GraphOfConvexSets::Transcription, while adding a convex surrogate to the relaxation. For more details, see <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#nonconvex_graph_of_convex_sets">Guiding Non-convex Optimization with the GraphOfConvexSets</a>.</p>
<p>The nonlinear constraint involves the derivative dᴺq(t) / dtᴺ which is decomposed as dᴺr(s) / dsᴺ / hᴺ. The convex surrogate replaces the nonlinear component hᴺ with h₀ᴺ⁻¹h, where h₀ is the characteristic time of the set. For now, h₀ is set to 1.0 for all sets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>is the lower bound of the derivative. </td></tr>
    <tr><td class="paramname">ub</td><td>is the upper bound of the derivative. </td></tr>
    <tr><td class="paramname">derivative_order</td><td>is the order of the derivative to be constrained.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if subgraph order is less than the derivative order. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the derivative order &lt;= 1, since the linear velocity bounds are preferred. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if lb or ub are not of size num_positions(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afce2be43547f60d510c7e46154eac653" name="afce2be43547f60d510c7e46154eac653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce2be43547f60d510c7e46154eac653">&#9670;&#160;</a></span>AddPathContinuityConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddPathContinuityConstraints </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>continuity_order</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enforces that for any two subsequent path segments within the subgraph, the <span class="tt">continuity_order</span>th path derivative at the end of the first segment equals that of the start of the second segment. </p>
<p>Note that the constraints are on the control points of the derivatives of r(s) and not q(t). This may result in discontinuities of the trajectory return by <span class="tt"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization.html#afa9081b0525ebe3c798eb0718c867db9" title="Formulates and solves the mixed-integer convex formulation of the shortest path problem on the whole ...">SolvePath()</a></span> since the r(s) will get rescaled by the duration h to yield q(t). <span class="tt"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization.html#af905be61c4d0357e5240da1af044fd72" title="Normalizes each trajectory segment to one second in duration.">NormalizeSegmentTimes()</a></span> will return r(s) with valid continuity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">continuity_order</td><td>is the order of the continuity constraint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the continuity order is not equal or less than the order the subgraphs. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the continuity order is less than one since path continuity is enforced by default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>To enforce that the trajectory is of class C^k, you must call AddPathContinuityConstraint for each continuity_order 1 through k. </dd></dl>

</div>
</div>
<a id="a26e4396347f05f766a19a64910a338b9" name="a26e4396347f05f766a19a64910a338b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e4396347f05f766a19a64910a338b9">&#9670;&#160;</a></span>AddPathEnergyCost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddPathEnergyCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>weight_matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to AddPathLengthCost in usage, but minimizes ∑ |weight_matrix * (rᵢ₊₁ − rᵢ)|₂². </p>
<p>In comparison to AddPathLength cost, this cost encourages control points to be evenly spaced but may result in greater number of regions and larger path length on the solution. It is recommended to use this cost only with SolveConvexRestriction when it becomes a quadratic cost for which some solvers show a better performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weight_matrix</td><td>is the relative weight of each component for the cost. The diagonal of the matrix is the weight for each dimension. The off-diagonal elements are the weight for the cross terms, which can be used to penalize diagonal movement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>weight_matrix must be of size num_positions() x num_positions(). </dd></dl>

</div>
</div>
<a id="af58fa24cbb7560c4a7551fdcb133d478" name="af58fa24cbb7560c4a7551fdcb133d478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58fa24cbb7560c4a7551fdcb133d478">&#9670;&#160;</a></span>AddPathEnergyCost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddPathEnergyCost </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to AddPathLengthCost in usage, but minimizes ∑ |(rᵢ₊₁ − rᵢ)|₂² with weight being applied uniformly to all dimensions. </p>
<p>In comparison to AddPathLength cost, this cost encourages control points to be evenly spaced but may result in greater number of regions and larger path length on the solution. It is recommended to use this cost only with SolveConvexRestriction when it becomes a quadratic cost for which some solvers show a better performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weight</td><td>is the relative weight of the cost. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5120b456754eef916922cd73d2ec846a" name="a5120b456754eef916922cd73d2ec846a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5120b456754eef916922cd73d2ec846a">&#9670;&#160;</a></span>AddPathLengthCost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddPathLengthCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>weight_matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds multiple L2Norm Costs on the upper bound of the path length. </p>
<p>Since we cannot directly compute the path length of a Bézier curve, we minimize the upper bound of the path integral by minimizing the sum of distances between control points. For Bézier curves, this is equivalent to the sum of the L2Norm of the derivative control points of the curve divided by the order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weight_matrix</td><td>is the relative weight of each component for the cost. The diagonal of the matrix is the weight for each dimension. The off-diagonal elements are the weight for the cross terms, which can be used to penalize diagonal movement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>weight_matrix must be of size num_positions() x num_positions(). </dd></dl>

</div>
</div>
<a id="a34f92ff4feccc5aa2e289b9a514486ac" name="a34f92ff4feccc5aa2e289b9a514486ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f92ff4feccc5aa2e289b9a514486ac">&#9670;&#160;</a></span>AddPathLengthCost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddPathLengthCost </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds multiple L2Norm Costs on the upper bound of the path length. </p>
<p>We upper bound the trajectory length by the sum of the distances between control points. For Bézier curves, this is equivalent to the sum of the L2Norm of the derivative control points of the curve divided by the order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weight</td><td>is the relative weight of the cost. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a515805314ae145e3be6b636d0986bb09" name="a515805314ae145e3be6b636d0986bb09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515805314ae145e3be6b636d0986bb09">&#9670;&#160;</a></span>AddTimeCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddTimeCost </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a minimum time cost to all regions in the subgraph. </p>
<p>The cost is the sum of the time scaling variables. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weight</td><td>is the relative weight of the cost. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af27492cb5b0dbf8cd8ce10e792486052" name="af27492cb5b0dbf8cd8ce10e792486052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27492cb5b0dbf8cd8ce10e792486052">&#9670;&#160;</a></span>AddVelocityBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddVelocityBounds </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear velocity constraint to the subgraph <span class="tt">lb</span> ≤ q̇(t) ≤ <span class="tt">ub</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>is the lower bound of the velocity. </td></tr>
    <tr><td class="paramname">ub</td><td>is the upper bound of the velocity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if subgraph order is zero, since the velocity is defined as the derivative of the Bézier curve. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if lb or ub are not of size num_positions(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a761332e0bc3697a2391606f3dc174804" name="a761332e0bc3697a2391606f3dc174804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a761332e0bc3697a2391606f3dc174804">&#9670;&#160;</a></span>AddVertexConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddVertexConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5b">geometry::optimization::GraphOfConvexSets::Transcription</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>use_in_transcription</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5ba058f4d93de65b4c9dd778be760beaa90">geometry::optimization::GraphOfConvexSets::Transcription::kMIP</a>,&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5baf0eaaa21b3713d009fbdbbcfc1f8b9b8">geometry::optimization::GraphOfConvexSets::Transcription::kRelaxation</a>,&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5bae6e3b13561e5aed0294cf5ca5765dd02">geometry::optimization::GraphOfConvexSets::Transcription::kRestriction</a>}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience overload of AddVertexConstraint to take in a Binding&lt;Constraint&gt;. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if any variables besides those from <a class="el" href="#a5e7fe2c354ca6688ebc6e50fc8b079c4">vertex_duration</a> and <a class="el" href="#ae6d17fd6e01b70a71ff7c2c23367656a">vertex_control_points</a> are used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3345f9cc149be05e3d3215960b93899d" name="a3345f9cc149be05e3d3215960b93899d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3345f9cc149be05e3d3215960b93899d">&#9670;&#160;</a></span>AddVertexConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddVertexConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5b">geometry::optimization::GraphOfConvexSets::Transcription</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>use_in_transcription</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5ba058f4d93de65b4c9dd778be760beaa90">geometry::optimization::GraphOfConvexSets::Transcription::kMIP</a>,&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5baf0eaaa21b3713d009fbdbbcfc1f8b9b8">geometry::optimization::GraphOfConvexSets::Transcription::kRelaxation</a>,&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5bae6e3b13561e5aed0294cf5ca5765dd02">geometry::optimization::GraphOfConvexSets::Transcription::kRestriction</a>}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an arbitrary user-defined constraint to every vertex in the subgraph. </p>
<p>The constraint should be defined using the placeholder control point variables (obtained from <a class="el" href="#ae6d17fd6e01b70a71ff7c2c23367656a" title="Returns a placeholder decision variable (not actually declared as a decision variable in the Mathemat...">vertex_control_points()</a>) and the placeholder time scaling variable (obtained from <a class="el" href="#a5e7fe2c354ca6688ebc6e50fc8b079c4" title="Returns a placeholder decision variable (not actually declared as a decision variable in the Mathemat...">vertex_duration()</a>). This enables greater modeling freedom, but we cannot guarantee a feasible solution for all possible constraints.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if any variables besides those from <a class="el" href="#a5e7fe2c354ca6688ebc6e50fc8b079c4">vertex_duration</a> and <a class="el" href="#ae6d17fd6e01b70a71ff7c2c23367656a">vertex_control_points</a> are used.</td></tr>
  </table>
  </dd>
</dl>
<p>Constraints which do not support the perspective operation cannot be used with Transcription::kMIP or Transcription::kRelaxation. Consider providing an appropriate "convex surrogate" that is supported within GraphOfConvexSets, or exclusively using the SolveConvexRestriction method. </p>

</div>
</div>
<a id="a753c0c124aa5a790f2a4418ea8599607" name="a753c0c124aa5a790f2a4418ea8599607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753c0c124aa5a790f2a4418ea8599607">&#9670;&#160;</a></span>AddVertexCost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddVertexCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">solvers::Cost</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5b">geometry::optimization::GraphOfConvexSets::Transcription</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>use_in_transcription</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5ba058f4d93de65b4c9dd778be760beaa90">geometry::optimization::GraphOfConvexSets::Transcription::kMIP</a>,&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5baf0eaaa21b3713d009fbdbbcfc1f8b9b8">geometry::optimization::GraphOfConvexSets::Transcription::kRelaxation</a>,&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5bae6e3b13561e5aed0294cf5ca5765dd02">geometry::optimization::GraphOfConvexSets::Transcription::kRestriction</a>}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience overload of AddVertexCost to take in a Binding&lt;Cost&gt;. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if any variables besides those from <a class="el" href="#a5e7fe2c354ca6688ebc6e50fc8b079c4">vertex_duration</a> and <a class="el" href="#ae6d17fd6e01b70a71ff7c2c23367656a">vertex_control_points</a> are used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a648d5b0ce8cadb962ed9761e7a17bd29" name="a648d5b0ce8cadb962ed9761e7a17bd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648d5b0ce8cadb962ed9761e7a17bd29">&#9670;&#160;</a></span>AddVertexCost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddVertexCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5b">geometry::optimization::GraphOfConvexSets::Transcription</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>use_in_transcription</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5ba058f4d93de65b4c9dd778be760beaa90">geometry::optimization::GraphOfConvexSets::Transcription::kMIP</a>,&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5baf0eaaa21b3713d009fbdbbcfc1f8b9b8">geometry::optimization::GraphOfConvexSets::Transcription::kRelaxation</a>,&#160;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5b9188d435083bda24dd1cb73a7b5d5bae6e3b13561e5aed0294cf5ca5765dd02">geometry::optimization::GraphOfConvexSets::Transcription::kRestriction</a>}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an arbitrary user-defined cost to every vertex in the subgraph. </p>
<p>The cost should be defined using the placeholder control point variables (obtained from <a class="el" href="#ae6d17fd6e01b70a71ff7c2c23367656a" title="Returns a placeholder decision variable (not actually declared as a decision variable in the Mathemat...">vertex_control_points()</a>) and the placeholder time scaling variable (obtained from <a class="el" href="#a5e7fe2c354ca6688ebc6e50fc8b079c4" title="Returns a placeholder decision variable (not actually declared as a decision variable in the Mathemat...">vertex_duration()</a>). This enables greater modeling freedom, but we cannot guarantee a feasible solution for all possible costs.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if any variables besides those from <a class="el" href="#a5e7fe2c354ca6688ebc6e50fc8b079c4">vertex_duration</a> and <a class="el" href="#ae6d17fd6e01b70a71ff7c2c23367656a">vertex_control_points</a> are used.</td></tr>
  </table>
  </dd>
</dl>
<p>Costs which do not support the perspective operation cannot be used with Transcription::kMIP or Transcription::kRelaxation. Consider providing an appropriate "convex surrogate" that is supported within GraphOfConvexSets, or exclusively using the SolveConvexRestriction method. </p>

</div>
</div>
<a id="aec655c58ca6223d017860ba12cb124d2" name="aec655c58ca6223d017860ba12cb124d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec655c58ca6223d017860ba12cb124d2">&#9670;&#160;</a></span>edge_constituent_vertex_control_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt; <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">solvers::MatrixXDecisionVariable</a>, <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">solvers::MatrixXDecisionVariable</a> &gt; &amp; edge_constituent_vertex_control_points </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pair of placeholder decision variables (not actually declared as decision variables in the MathematicalProgram) associated with the control points of the trajectory in two sets within this subgraph that are connected by an internal edge. </p>
<p>Each variable will be of shape (num_positions(), order+1), where the ith column is the ith control point. These variables will be substituted for real decision variables in methods like AddEdgeCost and AddEdgeConstraint. Passing this variable directly into objectives/constraints will result in an error. </p>

</div>
</div>
<a id="aad8edaa35ca3d51b0d184d2e5b499589" name="aad8edaa35ca3d51b0d184d2e5b499589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8edaa35ca3d51b0d184d2e5b499589">&#9670;&#160;</a></span>edge_constituent_vertex_durations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &amp; edge_constituent_vertex_durations </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pair of placeholder decision variables (not actually declared as decision variables in the MathematicalProgram) associated with the time scaling of the trajectory in two sets within this subgraph that are connected by an internal edge. </p>
<p>These variables will be substituted for real decision variables in methods like AddEdgeCost and AddEdgeConstraint. Passing this variable directly into objectives/constraints will result in an error. </p>

</div>
</div>
<a id="a16aa5f1e21cfabaa7b8ea66f0d765c38" name="a16aa5f1e21cfabaa7b8ea66f0d765c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16aa5f1e21cfabaa7b8ea66f0d765c38">&#9670;&#160;</a></span>Edges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">geometry::optimization::GraphOfConvexSets::Edge</a> * &gt; &amp; Edges </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns constant reference to a vector of mutable pointers to the edges. </p>

</div>
</div>
<a id="a55b316bc68a341946a49f2a874c3a779" name="a55b316bc68a341946a49f2a874c3a779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b316bc68a341946a49f2a874c3a779">&#9670;&#160;</a></span>Edges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">geometry::optimization::GraphOfConvexSets::Edge</a> * &gt; Edges </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns pointers to the edges stored in the subgraph. </p>

</div>
</div>
<a id="a24dcbf29c0d6cd766009a182a6484e3b" name="a24dcbf29c0d6cd766009a182a6484e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24dcbf29c0d6cd766009a182a6484e3b">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the subgraph. </p>

</div>
</div>
<a id="a257a41ec38a68f097105892d028519d3" name="a257a41ec38a68f097105892d028519d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257a41ec38a68f097105892d028519d3">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af9772f89f467b3eb25e91de87a3d4ee8">Subgraph</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#af9772f89f467b3eb25e91de87a3d4ee8">Subgraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ada332620505baeb39b9f76238a471967" name="ada332620505baeb39b9f76238a471967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada332620505baeb39b9f76238a471967">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af9772f89f467b3eb25e91de87a3d4ee8">Subgraph</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af9772f89f467b3eb25e91de87a3d4ee8">Subgraph</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abcc41a4e499b9ebcdc71c5e213c7c22f" name="abcc41a4e499b9ebcdc71c5e213c7c22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc41a4e499b9ebcdc71c5e213c7c22f">&#9670;&#160;</a></span>order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int order </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the order of the Bézier trajectory within the region. </p>

</div>
</div>
<a id="afc38c3a4c0d42c7dedc75e4f9fa6697e" name="afc38c3a4c0d42c7dedc75e4f9fa6697e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc38c3a4c0d42c7dedc75e4f9fa6697e">&#9670;&#160;</a></span>regions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">geometry::optimization::ConvexSets</a> &amp; regions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the regions associated with this subgraph before the CartesianProduct. </p>

</div>
</div>
<a id="af9593d4a5ff4274efaf429cb4f9e57cc" name="af9593d4a5ff4274efaf429cb4f9e57cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9593d4a5ff4274efaf429cb4f9e57cc">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of vertices in the subgraph. </p>

</div>
</div>
<a id="ae6d17fd6e01b70a71ff7c2c23367656a" name="ae6d17fd6e01b70a71ff7c2c23367656a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d17fd6e01b70a71ff7c2c23367656a">&#9670;&#160;</a></span>vertex_control_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake_1_1solvers.html#a85b6a5d80d5e24442bca8472b116c22a">solvers::MatrixXDecisionVariable</a> &amp; vertex_control_points </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a placeholder decision variable (not actually declared as a decision variable in the MathematicalProgram) associated with the control points of the trajectory in a set within this subgraph. </p>
<p>The variable will be of shape (num_positions(), order+1), where the ith column is the ith control point. This variable will be substituted for real decision variables in methods like AddVertexCost and AddVertexConstraint. Passing this variable directly into objectives/constraints will result in an error. </p>

</div>
</div>
<a id="a5e7fe2c354ca6688ebc6e50fc8b079c4" name="a5e7fe2c354ca6688ebc6e50fc8b079c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e7fe2c354ca6688ebc6e50fc8b079c4">&#9670;&#160;</a></span>vertex_duration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp; vertex_duration </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a placeholder decision variable (not actually declared as a decision variable in the MathematicalProgram) associated with the time scaling of the trajectory in a set within this subgraph. </p>
<p>This variable will be substituted for real decision variables in methods like AddVertexCost and AddVertexConstraint. Passing this variable directly into objectives/constraints will result in an error. </p>

</div>
</div>
<a id="aa5478d154028f99b63a278a02c3019c7" name="aa5478d154028f99b63a278a02c3019c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5478d154028f99b63a278a02c3019c7">&#9670;&#160;</a></span>Vertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">geometry::optimization::GraphOfConvexSets::Vertex</a> * &gt; &amp; Vertices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns constant reference to a vector of mutable pointers to the vertices stored in the subgraph. </p>
<p>The order of the vertices is the same as the order the regions were added. </p>

</div>
</div>
<a id="a3b8a74c73da559868474429efb779ddc" name="a3b8a74c73da559868474429efb779ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8a74c73da559868474429efb779ddc">&#9670;&#160;</a></span>Vertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">geometry::optimization::GraphOfConvexSets::Vertex</a> * &gt; Vertices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns pointers to the vertices stored in the subgraph. </p>
<p>The order of the vertices is the same as the order the regions were added. </p>

</div>
</div>
<a name="doc-related-members" id="doc-related-members"></a><h2 id="header-doc-related-members" class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="aa69be52668ec461d59f91ad7eaca3a89" name="aa69be52668ec461d59f91ad7eaca3a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69be52668ec461d59f91ad7eaca3a89">&#9670;&#160;</a></span>GcsTrajectoryOptimization</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class GcsTrajectoryOptimization</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/planning/trajectory_optimization/<a class="el" href="gcs__trajectory__optimization_8h.html">gcs_trajectory_optimization.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1planning.html">planning</a></li><li class="navelem"><a href="namespacedrake_1_1planning_1_1trajectory__optimization.html">trajectory_optimization</a></li><li class="navelem"><a href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization.html">GcsTrajectoryOptimization</a></li><li class="navelem"><a href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html">Subgraph</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="https://accessibility.mit.edu/" class="site-menu-item">Accessibility</a>
        </li>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
