<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: IrisOptions Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 </div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structdrake_1_1geometry_1_1optimization_1_1_iris_options.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structdrake_1_1geometry_1_1optimization_1_1_iris_options-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IrisOptions Struct Reference<div class="ingroups"><a class="el" href="group__geometry.html">Geometric Representations</a> &#124; <a class="el" href="group__solvers.html">Formulating and Solving Optimization Problems</a> &raquo; <a class="el" href="group__geometry__optimization.html">Geometry Optimization</a><a class="el" href="group__algorithms.html">Algorithms</a> &raquo; <a class="el" href="group__planning.html">Planning</a> &raquo;  &#124; <a class="el" href="group__planning__iris.html">Iris</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Configuration options for the IRIS algorithm. </p>
</div>
<p><code>#include &lt;drake/geometry/optimization/iris.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8e8824802dedfbc36776227f7482b6bc"><td class="memTemplParams" colspan="2">template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:a8e8824802dedfbc36776227f7482b6bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html#a8e8824802dedfbc36776227f7482b6bc">Serialize</a> (Archive *a)</td></tr>
<tr class="memdesc:a8e8824802dedfbc36776227f7482b6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passes this object to an Archive.  <a href="#a8e8824802dedfbc36776227f7482b6bc">More...</a><br /></td></tr>
<tr class="separator:a8e8824802dedfbc36776227f7482b6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a20906a34b629e819d5d8a8df41638c2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html#a20906a34b629e819d5d8a8df41638c2d">require_sample_point_is_contained</a> {false}</td></tr>
<tr class="memdesc:a20906a34b629e819d5d8a8df41638c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial polytope is guaranteed to contain the point if that point is collision-free.  <a href="#a20906a34b629e819d5d8a8df41638c2d">More...</a><br /></td></tr>
<tr class="separator:a20906a34b629e819d5d8a8df41638c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9404d7dc104e7eb4e27ed7e38ccff72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html#ab9404d7dc104e7eb4e27ed7e38ccff72">iteration_limit</a> {100}</td></tr>
<tr class="memdesc:ab9404d7dc104e7eb4e27ed7e38ccff72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of iterations.  <a href="#ab9404d7dc104e7eb4e27ed7e38ccff72">More...</a><br /></td></tr>
<tr class="separator:ab9404d7dc104e7eb4e27ed7e38ccff72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a479517bfa7e6c3d669c72380924ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html#a11a479517bfa7e6c3d669c72380924ca">termination_threshold</a> {2e-2}</td></tr>
<tr class="memdesc:a11a479517bfa7e6c3d669c72380924ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">IRIS will terminate if the change in the <em>volume</em> of the hyperellipsoid between iterations is less that this threshold.  <a href="#a11a479517bfa7e6c3d669c72380924ca">More...</a><br /></td></tr>
<tr class="separator:a11a479517bfa7e6c3d669c72380924ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f1367efbb0c0efddaec6ed273e8bb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html#a49f1367efbb0c0efddaec6ed273e8bb7">relative_termination_threshold</a> {1e-3}</td></tr>
<tr class="memdesc:a49f1367efbb0c0efddaec6ed273e8bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">IRIS will terminate if the change in the <em>volume</em> of the hyperellipsoid between iterations is less that this percent of the previous best volume.  <a href="#a49f1367efbb0c0efddaec6ed273e8bb7">More...</a><br /></td></tr>
<tr class="separator:a49f1367efbb0c0efddaec6ed273e8bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033befdd75124d17abb45b56c75a71db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html#a033befdd75124d17abb45b56c75a71db">configuration_space_margin</a> {1e-2}</td></tr>
<tr class="memdesc:a033befdd75124d17abb45b56c75a71db"><td class="mdescLeft">&#160;</td><td class="mdescRight">For IrisNp, we retreat by this margin from each C-space obstacle in order to avoid the possibility of requiring an infinite number of faces to approximate a curved boundary.  <a href="#a033befdd75124d17abb45b56c75a71db">More...</a><br /></td></tr>
<tr class="separator:a033befdd75124d17abb45b56c75a71db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67295e7681f83a17890571e4b6b0a7dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html#a67295e7681f83a17890571e4b6b0a7dd">num_collision_infeasible_samples</a> {5}</td></tr>
<tr class="memdesc:a67295e7681f83a17890571e4b6b0a7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each possible collision, IRIS will search for a counter-example by formulating a (likely nonconvex) optimization problem.  <a href="#a67295e7681f83a17890571e4b6b0a7dd">More...</a><br /></td></tr>
<tr class="separator:a67295e7681f83a17890571e4b6b0a7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2213eafbc5c4f73c4af52ecd163494c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html#a2213eafbc5c4f73c4af52ecd163494c6">configuration_obstacles</a> {}</td></tr>
<tr class="memdesc:a2213eafbc5c4f73c4af52ecd163494c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For IrisNp, it can be beneficial to not only specify task-space obstacles (passed in through the plant) but also obstacles that are defined by convex sets in the configuration space.  <a href="#a2213eafbc5c4f73c4af52ecd163494c6">More...</a><br /></td></tr>
<tr class="separator:a2213eafbc5c4f73c4af52ecd163494c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65f515b41261e98fb16dd1e810cba48"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_hyperellipsoid.html">Hyperellipsoid</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html#ae65f515b41261e98fb16dd1e810cba48">starting_ellipse</a> {}</td></tr>
<tr class="memdesc:ae65f515b41261e98fb16dd1e810cba48"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial hyperellipsoid that IRIS will use for calculating hyperplanes in the first iteration.  <a href="#ae65f515b41261e98fb16dd1e810cba48">More...</a><br /></td></tr>
<tr class="separator:ae65f515b41261e98fb16dd1e810cba48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0bd9a6fa7b0b7a30e8330f44812655"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">HPolyhedron</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html#a0e0bd9a6fa7b0b7a30e8330f44812655">bounding_region</a> {}</td></tr>
<tr class="memdesc:a0e0bd9a6fa7b0b7a30e8330f44812655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optionally allows the caller to restrict the space within which IRIS regions are allowed to grow.  <a href="#a0e0bd9a6fa7b0b7a30e8330f44812655">More...</a><br /></td></tr>
<tr class="separator:a0e0bd9a6fa7b0b7a30e8330f44812655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7e372f75bda41909e27f92c1e7a7cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html#a0c7e372f75bda41909e27f92c1e7a7cd">verify_domain_boundedness</a> {true}</td></tr>
<tr class="memdesc:a0c7e372f75bda41909e27f92c1e7a7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the user knows the intersection of bounding_region and the domain (for IRIS) or plant joint limits (for IrisNp) is bounded, setting this flag to <code>false</code> will skip the boundedness check that IRIS and IrisNp perform (leading to a small speedup, as checking boundedness requires solving optimization problems).  <a href="#a0c7e372f75bda41909e27f92c1e7a7cd">More...</a><br /></td></tr>
<tr class="separator:a0c7e372f75bda41909e27f92c1e7a7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcf4ea1cbea01d087cc559402acddf2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html#aafcf4ea1cbea01d087cc559402acddf2">prog_with_additional_constraints</a> {}</td></tr>
<tr class="memdesc:aafcf4ea1cbea01d087cc559402acddf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default, IrisNp certifies regions for collision avoidance constraints and joint limits.  <a href="#aafcf4ea1cbea01d087cc559402acddf2">More...</a><br /></td></tr>
<tr class="separator:aafcf4ea1cbea01d087cc559402acddf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985034493b538c4431e48f45ba012e75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html#a985034493b538c4431e48f45ba012e75">num_additional_constraint_infeasible_samples</a> {5}</td></tr>
<tr class="memdesc:a985034493b538c4431e48f45ba012e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each constraint in <code>prog_with_additional_constraints</code>, IRIS will search for a counter-example by formulating a (likely nonconvex) optimization problem.  <a href="#a985034493b538c4431e48f45ba012e75">More...</a><br /></td></tr>
<tr class="separator:a985034493b538c4431e48f45ba012e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9059bc845096b2f05414a66c836b4ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html#ad9059bc845096b2f05414a66c836b4ee">random_seed</a> {1234}</td></tr>
<tr class="memdesc:ad9059bc845096b2f05414a66c836b4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The only randomization in IRIS is the random sampling done to find counter-examples for the additional constraints using in IrisNp.  <a href="#ad9059bc845096b2f05414a66c836b4ee">More...</a><br /></td></tr>
<tr class="separator:ad9059bc845096b2f05414a66c836b4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5394db50dd4c2741c4d3f7dacf50f51d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_meshcat.html">Meshcat</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html#a5394db50dd4c2741c4d3f7dacf50f51d">meshcat</a> {}</td></tr>
<tr class="memdesc:a5394db50dd4c2741c4d3f7dacf50f51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passing a meshcat instance may enable debugging visualizations; this currently only happens in IrisNp and when the configuration space is &lt;= 3 dimensional.  <a href="#a5394db50dd4c2741c4d3f7dacf50f51d">More...</a><br /></td></tr>
<tr class="separator:a5394db50dd4c2741c4d3f7dacf50f51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087724eb9045117415e4d5a93db67ab1"><td class="memItemLeft" align="right" valign="top">std::function&lt; bool(const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">HPolyhedron</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html#a087724eb9045117415e4d5a93db67ab1">termination_func</a> {}</td></tr>
<tr class="memdesc:a087724eb9045117415e4d5a93db67ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A user-defined termination function to determine whether the iterations should stop.  <a href="#a087724eb9045117415e4d5a93db67ab1">More...</a><br /></td></tr>
<tr class="separator:a087724eb9045117415e4d5a93db67ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111e7545f0a4fcae1b8a52fec666594a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html#a111e7545f0a4fcae1b8a52fec666594a">mixing_steps</a> {10}</td></tr>
<tr class="memdesc:a111e7545f0a4fcae1b8a52fec666594a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>mixing_steps</code> parameters is passed to <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html#a99bfbaa0f51a0b3b0e51e0c0b2de0946" title="Draw an (approximately) uniform sample from the set using the hit and run Markov-chain Monte-Carlo st...">HPolyhedron::UniformSample</a> to control the total number of hit-and-run steps taken for each new random sample.  <a href="#a111e7545f0a4fcae1b8a52fec666594a">More...</a><br /></td></tr>
<tr class="separator:a111e7545f0a4fcae1b8a52fec666594a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4438afbf2190941ebeae2f8e16dd11"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">solvers::SolverOptions</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html#a6c4438afbf2190941ebeae2f8e16dd11">solver_options</a></td></tr>
<tr class="memdesc:a6c4438afbf2190941ebeae2f8e16dd11"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SolverOptions used in the optimization program.  <a href="#a6c4438afbf2190941ebeae2f8e16dd11">More...</a><br /></td></tr>
<tr class="separator:a6c4438afbf2190941ebeae2f8e16dd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0386ea4a76c2bfe571cca98200f565"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html#a0d0386ea4a76c2bfe571cca98200f565">convexity_radius_stepback</a> {1e-3}</td></tr>
<tr class="memdesc:a0d0386ea4a76c2bfe571cca98200f565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Artificial joint limits are added to continuous revolute joints and planar joints with an unbounded revolute degree-of-freedom on a per-region basis.  <a href="#a0d0386ea4a76c2bfe571cca98200f565">More...</a><br /></td></tr>
<tr class="separator:a0d0386ea4a76c2bfe571cca98200f565"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8e8824802dedfbc36776227f7482b6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8824802dedfbc36776227f7482b6bc">&#9670;&nbsp;</a></span>Serialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Serialize </td>
          <td>(</td>
          <td class="paramtype">Archive *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Passes this object to an Archive. </p>
<p>Refer to <a class="el" href="group__yaml__serialization.html">YAML Serialization</a> for background. Note: This only serializes options that are YAML built-in types. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0e0bd9a6fa7b0b7a30e8330f44812655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0bd9a6fa7b0b7a30e8330f44812655">&#9670;&nbsp;</a></span>bounding_region</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">HPolyhedron</a>&gt; bounding_region {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optionally allows the caller to restrict the space within which IRIS regions are allowed to grow. </p>
<p>By default, IRIS regions are bounded by the <code>domain</code> argument in the case of <code>Iris</code> or the joint limits of the input <code>plant</code> in the case of <code>IrisNp</code>. If this option is specified, IRIS regions will be confined to the intersection between the domain and <code>bounding_region</code>. </p>

</div>
</div>
<a id="a2213eafbc5c4f73c4af52ecd163494c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2213eafbc5c4f73c4af52ecd163494c6">&#9670;&nbsp;</a></span>configuration_obstacles</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> configuration_obstacles {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For IrisNp, it can be beneficial to not only specify task-space obstacles (passed in through the plant) but also obstacles that are defined by convex sets in the configuration space. </p>
<p>This option can be used to pass in such configuration space obstacles. </p>

</div>
</div>
<a id="a033befdd75124d17abb45b56c75a71db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033befdd75124d17abb45b56c75a71db">&#9670;&nbsp;</a></span>configuration_space_margin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> configuration_space_margin {1e-2}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For IrisNp, we retreat by this margin from each C-space obstacle in order to avoid the possibility of requiring an infinite number of faces to approximate a curved boundary. </p>

</div>
</div>
<a id="a0d0386ea4a76c2bfe571cca98200f565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0386ea4a76c2bfe571cca98200f565">&#9670;&nbsp;</a></span>convexity_radius_stepback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> convexity_radius_stepback {1e-3}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Artificial joint limits are added to continuous revolute joints and planar joints with an unbounded revolute degree-of-freedom on a per-region basis. </p>
<p>If the seed point value for that joint is θ, then the limits are θ - π/2 + convexity_radius_stepback and θ + π/2 - convexity_radius_stepback. Setting this to a negative number allows growing larger regions, but those regions must then be partitioned to be used with GcsTrajectoryOptimization. See <a class="el" href="group__geometry__optimization__geodesic__convexity.html">Geodesic Convexity</a> for more details. IrisNp throws if this value is not smaller than π/2. </p>

</div>
</div>
<a id="ab9404d7dc104e7eb4e27ed7e38ccff72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9404d7dc104e7eb4e27ed7e38ccff72">&#9670;&nbsp;</a></span>iteration_limit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> iteration_limit {100}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of iterations. </p>

</div>
</div>
<a id="a5394db50dd4c2741c4d3f7dacf50f51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5394db50dd4c2741c4d3f7dacf50f51d">&#9670;&nbsp;</a></span>meshcat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1geometry_1_1_meshcat.html">Meshcat</a>&gt; meshcat {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Passing a meshcat instance may enable debugging visualizations; this currently only happens in IrisNp and when the configuration space is &lt;= 3 dimensional. </p>

</div>
</div>
<a id="a111e7545f0a4fcae1b8a52fec666594a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111e7545f0a4fcae1b8a52fec666594a">&#9670;&nbsp;</a></span>mixing_steps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> mixing_steps {10}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <code>mixing_steps</code> parameters is passed to <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html#a99bfbaa0f51a0b3b0e51e0c0b2de0946" title="Draw an (approximately) uniform sample from the set using the hit and run Markov-chain Monte-Carlo st...">HPolyhedron::UniformSample</a> to control the total number of hit-and-run steps taken for each new random sample. </p>

</div>
</div>
<a id="a985034493b538c4431e48f45ba012e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985034493b538c4431e48f45ba012e75">&#9670;&nbsp;</a></span>num_additional_constraint_infeasible_samples</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_additional_constraint_infeasible_samples {5}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each constraint in <code>prog_with_additional_constraints</code>, IRIS will search for a counter-example by formulating a (likely nonconvex) optimization problem. </p>
<p>The initial guess for this optimization is taken by sampling uniformly inside the current IRIS region. This option controls the termination condition for that counter-example search, defining the number of consecutive failures to find a counter-example requested before moving on to the next constraint. </p>

</div>
</div>
<a id="a67295e7681f83a17890571e4b6b0a7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67295e7681f83a17890571e4b6b0a7dd">&#9670;&nbsp;</a></span>num_collision_infeasible_samples</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_collision_infeasible_samples {5}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each possible collision, IRIS will search for a counter-example by formulating a (likely nonconvex) optimization problem. </p>
<p>The initial guess for this optimization is taken by sampling uniformly inside the current IRIS region. This option controls the termination condition for that counter-example search, defining the number of consecutive failures to find a counter-example requested before moving on to the next constraint. </p>

</div>
</div>
<a id="aafcf4ea1cbea01d087cc559402acddf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafcf4ea1cbea01d087cc559402acddf2">&#9670;&nbsp;</a></span>prog_with_additional_constraints</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a>* prog_with_additional_constraints {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>By default, IrisNp certifies regions for collision avoidance constraints and joint limits. </p>
<p>This option can be used to pass additional constraints that should be satisfied by the IRIS region. We accept these in the form of a MathematicalProgram:</p>
<p>find q subject to g(q) ≤ 0.</p>
<p>The decision_variables() for the program are taken to define <code>q</code>. IRIS will silently ignore any costs in <code>prog_with_additional_constraints</code>, and will throw std::runtime_error if it contains any unsupported constraints.</p>
<p>For example, one could create an InverseKinematics problem with rich kinematic constraints, and then pass <code>InverseKinematics::prog()</code> into this option. </p>

</div>
</div>
<a id="ad9059bc845096b2f05414a66c836b4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9059bc845096b2f05414a66c836b4ee">&#9670;&nbsp;</a></span>random_seed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> random_seed {1234}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The only randomization in IRIS is the random sampling done to find counter-examples for the additional constraints using in IrisNp. </p>
<p>Use this option to set the initial seed. </p>

</div>
</div>
<a id="a49f1367efbb0c0efddaec6ed273e8bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f1367efbb0c0efddaec6ed273e8bb7">&#9670;&nbsp;</a></span>relative_termination_threshold</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> relative_termination_threshold {1e-3}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IRIS will terminate if the change in the <em>volume</em> of the hyperellipsoid between iterations is less that this percent of the previous best volume. </p>
<p>This termination condition can be disabled by setting to a negative value. </p>

</div>
</div>
<a id="a20906a34b629e819d5d8a8df41638c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20906a34b629e819d5d8a8df41638c2d">&#9670;&nbsp;</a></span>require_sample_point_is_contained</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool require_sample_point_is_contained {false}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial polytope is guaranteed to contain the point if that point is collision-free. </p>
<p>However, the IRIS alternation objectives do not include (and can not easily include) a constraint that the original sample point is contained. Therefore, the IRIS paper recommends that if containment is a requirement, then the algorithm should simply terminate early if alternations would ever cause the set to not contain the point. </p>

</div>
</div>
<a id="a6c4438afbf2190941ebeae2f8e16dd11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4438afbf2190941ebeae2f8e16dd11">&#9670;&nbsp;</a></span>solver_options</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">solvers::SolverOptions</a>&gt; solver_options</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The SolverOptions used in the optimization program. </p>

</div>
</div>
<a id="ae65f515b41261e98fb16dd1e810cba48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae65f515b41261e98fb16dd1e810cba48">&#9670;&nbsp;</a></span>starting_ellipse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_hyperellipsoid.html">Hyperellipsoid</a>&gt; starting_ellipse {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initial hyperellipsoid that IRIS will use for calculating hyperplanes in the first iteration. </p>
<p>If no hyperellipsoid is provided, a small hypershpere centered at the given sample will be used. </p>

</div>
</div>
<a id="a087724eb9045117415e4d5a93db67ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087724eb9045117415e4d5a93db67ab1">&#9670;&nbsp;</a></span>termination_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;bool(const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">HPolyhedron</a>&amp;)&gt; termination_func {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A user-defined termination function to determine whether the iterations should stop. </p>
<p>This function is called after computing each hyperplane at every IRIS iteration. If the function returns true, then the computations will stop and the last step region will be returned. Therefore, it is highly recommended that the termination function possesses a monotonic property such that for any two HPolyhedrons A and B such that B ⊆ A, we have if termination(A) -&gt; termination(B). For example, a valid termination function is to check whether if the region does not contain any of a set of desired points. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html#a087724eb9045117415e4d5a93db67ab1">termination_func</a> = [](<span class="keyword">const</span> HPolyhedron&amp; set) {</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> VectorXd&amp; point : desired_points) {</div><div class="line">    <span class="keywordflow">if</span> (!set.PointInSet(point)) {</div><div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">};</div></div><!-- fragment --><p> The algorithm will stop when as soon as the region leaves one of the desired points, in a similar way to how <code>require_sample_point_is_contained</code> is enforced. </p>

</div>
</div>
<a id="a11a479517bfa7e6c3d669c72380924ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a479517bfa7e6c3d669c72380924ca">&#9670;&nbsp;</a></span>termination_threshold</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> termination_threshold {2e-2}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IRIS will terminate if the change in the <em>volume</em> of the hyperellipsoid between iterations is less that this threshold. </p>
<p>This termination condition can be disabled by setting to a negative value. </p>

</div>
</div>
<a id="a0c7e372f75bda41909e27f92c1e7a7cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7e372f75bda41909e27f92c1e7a7cd">&#9670;&nbsp;</a></span>verify_domain_boundedness</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool verify_domain_boundedness {true}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the user knows the intersection of bounding_region and the domain (for IRIS) or plant joint limits (for IrisNp) is bounded, setting this flag to <code>false</code> will skip the boundedness check that IRIS and IrisNp perform (leading to a small speedup, as checking boundedness requires solving optimization problems). </p>
<p>If the intersection turns out to be unbounded, this will lead to undefined behavior. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>drake/geometry/optimization/<a class="el" href="iris_8h.html">iris.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1geometry.html">geometry</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html">optimization</a></li><li class="navelem"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">IrisOptions</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().value = searchBox.searchLabel;
</script>
</body>
</html>
