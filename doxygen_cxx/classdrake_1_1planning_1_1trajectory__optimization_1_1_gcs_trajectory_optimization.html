<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: GcsTrajectoryOptimization Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization.html','','classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">GcsTrajectoryOptimization Class Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization.html" title="GcsTrajectoryOptimization implements a simplified motion planning optimization problem introduced in ...">GcsTrajectoryOptimization</a> implements a simplified motion planning optimization problem introduced in the paper <a href="https://arxiv.org/abs/2205.04422">"Motion Planning around Obstacles with Convex Optimization"</a> by Tobia Marcucci, Mark Petersen, David von Wrangel, Russ Tedrake. </p>
<dl class="section warning"><dt>Warning</dt><dd>This feature is considered to be <b>experimental</b> and may change or be removed at any time, without any deprecation notice ahead of time.</dd></dl>
<p>Instead of using the full time-scaling curve, this problem uses a single time-scaling variable for each region. This formulation yields continuous trajectories, which are not differentiable at the transition times between the regions since non-convex continuity constraints are not supported yet. However, it supports continuity on the path r(s) for arbitrary degree. The path r(s) can be reconstructed from the gcs solution q(t) with <span class="tt"><a class="el" href="#af905be61c4d0357e5240da1af044fd72" title="Normalizes each trajectory segment to one second in duration.">NormalizeSegmentTimes()</a></span> and post-processed with e.g. Toppra to enforce acceleration bounds.</p>
<p>The ith piece of the composite trajectory is defined as q(t) = r((t - tᵢ) / hᵢ). r : [0, 1] → ℝⁿ is a the path, parametrized as a Bézier curve with order n. tᵢ and hᵢ are the initial time and duration of the ith sub-trajectory.</p>
<p>This class supports the notion of a <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html" title="A Subgraph is a subset of the larger graph.">Subgraph</a> of regions. This has proven useful to facilitate multi-modal motion planning such as: <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html" title="A Subgraph is a subset of the larger graph.">Subgraph</a> A: find a collision-free trajectory for the robot to a grasping posture, <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html" title="A Subgraph is a subset of the larger graph.">Subgraph</a> B: find a collision-free trajectory for the robot with the object in its hand to a placing posture, etc.</p>
<p><a class="anchor" id="continuous_revolute_joints"></a></p><h3>Continuous Revolute Joints</h3>
<p>This class also supports robots with continuous revolute joints (revolute joints that don't have any joint limits) and mobile bases. Adding or subtracting 2π to such a joint's angle leaves it unchanged; this logic is implemented behind the scenes. To use it, one should specify the joint indices that don't have limits, and ensure all sets satisfy the "convexity radius" property &ndash; their width along a dimension corresponding to a continuous revolute joint must be less than π. This can be enforced when constructing the convex sets, or after the fact with <span class="tt"><a class="el" href="group__geometry__optimization__geodesic__convexity.html#ga4cc1511a0a4979afa70ee7d5964bc0d5" title="Partitions a convex set into (smaller) convex sets whose union is the original set and that each resp...">geometry::optimization::PartitionConvexSet</a></span>. The <span class="tt"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization.html" title="GcsTrajectoryOptimization implements a simplified motion planning optimization problem introduced in ...">GcsTrajectoryOptimization</a></span> methods <span class="tt"><a class="el" href="#a38f9b7b3cb6b154a5743d1bd32e71ec8" title="Creates a Subgraph with the given regions and indices.">AddRegions</a></span> and <span class="tt"><a class="el" href="#acd103aa2fa271ca9db91fc8f0a5bbec1" title="Connects two subgraphs with directed edges.">AddEdges</a></span> will handle all of the intersection checks behind the scenes, including applying the appropriate logic to connect sets that "wrap around" 2π. </p>
</div>
<p><code>#include &lt;drake/planning/trajectory_optimization/gcs_trajectory_optimization.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:EdgesBetweenSubgraphs" id="r_EdgesBetweenSubgraphs"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_edges_between_subgraphs.html">EdgesBetweenSubgraphs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_edges_between_subgraphs.html" title="EdgesBetweenSubgraphs are defined as the connecting edges between two given subgraphs.">EdgesBetweenSubgraphs</a> are defined as the connecting edges between two given subgraphs.  <a href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_edges_between_subgraphs.html#details">More...</a><br /></td></tr>
<tr class="memitem:Subgraph" id="r_Subgraph"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html">Subgraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html" title="A Subgraph is a subset of the larger graph.">Subgraph</a> is a subset of the larger graph.  <a href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad515c3a3a5a3ad8e6f2ad33059021f48" id="r_ad515c3a3a5a3ad8e6f2ad33059021f48"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad515c3a3a5a3ad8e6f2ad33059021f48">GcsTrajectoryOptimization</a> (int <a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553">num_positions</a>, std::vector&lt; int &gt; <a class="el" href="#a35b6df4444d05b5f49f5af17620f79b0">continuous_revolute_joints</a>=std::vector&lt; int &gt;())</td></tr>
<tr class="memdesc:ad515c3a3a5a3ad8e6f2ad33059021f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the motion planning problem.  <br /></td></tr>
<tr class="memitem:a9c41ee6c46e4e39173da8e589408b9ef" id="r_a9c41ee6c46e4e39173da8e589408b9ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c41ee6c46e4e39173da8e589408b9ef">~GcsTrajectoryOptimization</a> ()</td></tr>
<tr class="memitem:aba2887f0ca1fbbdfb49cf6b0ee21e553" id="r_aba2887f0ca1fbbdfb49cf6b0ee21e553"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553">num_positions</a> () const</td></tr>
<tr class="memdesc:aba2887f0ca1fbbdfb49cf6b0ee21e553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of position variables.  <br /></td></tr>
<tr class="memitem:a35b6df4444d05b5f49f5af17620f79b0" id="r_a35b6df4444d05b5f49f5af17620f79b0"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35b6df4444d05b5f49f5af17620f79b0">continuous_revolute_joints</a> ()</td></tr>
<tr class="memdesc:a35b6df4444d05b5f49f5af17620f79b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of indices corresponding to continuous revolute joints.  <br /></td></tr>
<tr class="memitem:ae8e736f8d73a8dec8b0f3b653f5f0145" id="r_ae8e736f8d73a8dec8b0f3b653f5f0145"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8e736f8d73a8dec8b0f3b653f5f0145">GetGraphvizString</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a> *result=nullptr, const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_gcs_graphviz_options.html">geometry::optimization::GcsGraphvizOptions</a> &amp;options={}) const</td></tr>
<tr class="memdesc:ae8e736f8d73a8dec8b0f3b653f5f0145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Graphviz string describing the graph vertices and edges.  <br /></td></tr>
<tr class="memitem:a38f9b7b3cb6b154a5743d1bd32e71ec8" id="r_a38f9b7b3cb6b154a5743d1bd32e71ec8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html">Subgraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38f9b7b3cb6b154a5743d1bd32e71ec8">AddRegions</a> (const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">geometry::optimization::ConvexSets</a> &amp;regions, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;edges_between_regions, int order, double h_min=0, double h_max=20, std::string name=&quot;&quot;, const std::vector&lt; Eigen::VectorXd &gt; *edge_offsets=nullptr)</td></tr>
<tr class="memdesc:a38f9b7b3cb6b154a5743d1bd32e71ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html" title="A Subgraph is a subset of the larger graph.">Subgraph</a> with the given regions and indices.  <br /></td></tr>
<tr class="memitem:a1c86bbba3696c2d3eb43336b3a4c6e60" id="r_a1c86bbba3696c2d3eb43336b3a4c6e60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html">Subgraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c86bbba3696c2d3eb43336b3a4c6e60">AddRegions</a> (const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">geometry::optimization::ConvexSets</a> &amp;regions, int order, double h_min=1e-6, double h_max=20, std::string name=&quot;&quot;)</td></tr>
<tr class="memdesc:a1c86bbba3696c2d3eb43336b3a4c6e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html" title="A Subgraph is a subset of the larger graph.">Subgraph</a> with the given regions.  <br /></td></tr>
<tr class="memitem:a88df1e80fc5caca3da4c817fc3e23338" id="r_a88df1e80fc5caca3da4c817fc3e23338"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88df1e80fc5caca3da4c817fc3e23338">RemoveSubgraph</a> (const <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html">Subgraph</a> &amp;subgraph)</td></tr>
<tr class="memdesc:a88df1e80fc5caca3da4c817fc3e23338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a subgraph and all associated edges found in the subgraph and to and from other subgraphs.  <br /></td></tr>
<tr class="memitem:acd103aa2fa271ca9db91fc8f0a5bbec1" id="r_acd103aa2fa271ca9db91fc8f0a5bbec1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_edges_between_subgraphs.html">EdgesBetweenSubgraphs</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd103aa2fa271ca9db91fc8f0a5bbec1">AddEdges</a> (const <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html">Subgraph</a> &amp;from_subgraph, const <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html">Subgraph</a> &amp;to_subgraph, const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">geometry::optimization::ConvexSet</a> *subspace=nullptr, const std::vector&lt; std::pair&lt; int, int &gt; &gt; *edges_between_regions=nullptr, const std::vector&lt; Eigen::VectorXd &gt; *edge_offsets=nullptr)</td></tr>
<tr class="memdesc:acd103aa2fa271ca9db91fc8f0a5bbec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects two subgraphs with directed edges.  <br /></td></tr>
<tr class="memitem:a515805314ae145e3be6b636d0986bb09" id="r_a515805314ae145e3be6b636d0986bb09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a515805314ae145e3be6b636d0986bb09">AddTimeCost</a> (double weight=1.0)</td></tr>
<tr class="memdesc:a515805314ae145e3be6b636d0986bb09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a minimum time cost to all regions in the whole graph.  <br /></td></tr>
<tr class="memitem:a5120b456754eef916922cd73d2ec846a" id="r_a5120b456754eef916922cd73d2ec846a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5120b456754eef916922cd73d2ec846a">AddPathLengthCost</a> (const Eigen::MatrixXd &amp;weight_matrix)</td></tr>
<tr class="memdesc:a5120b456754eef916922cd73d2ec846a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds multiple L2Norm Costs on the upper bound of the path length.  <br /></td></tr>
<tr class="memitem:a26e4396347f05f766a19a64910a338b9" id="r_a26e4396347f05f766a19a64910a338b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26e4396347f05f766a19a64910a338b9">AddPathEnergyCost</a> (const Eigen::MatrixXd &amp;weight_matrix)</td></tr>
<tr class="memdesc:a26e4396347f05f766a19a64910a338b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to AddPathLengthCost in usage, but minimizes ∑ |weight_matrix * (rᵢ₊₁ − rᵢ)|₂².  <br /></td></tr>
<tr class="memitem:a34f92ff4feccc5aa2e289b9a514486ac" id="r_a34f92ff4feccc5aa2e289b9a514486ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34f92ff4feccc5aa2e289b9a514486ac">AddPathLengthCost</a> (double weight=1.0)</td></tr>
<tr class="memdesc:a34f92ff4feccc5aa2e289b9a514486ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds multiple L2Norm Costs on the upper bound of the path length.  <br /></td></tr>
<tr class="memitem:af58fa24cbb7560c4a7551fdcb133d478" id="r_af58fa24cbb7560c4a7551fdcb133d478"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af58fa24cbb7560c4a7551fdcb133d478">AddPathEnergyCost</a> (double weight=1.0)</td></tr>
<tr class="memdesc:af58fa24cbb7560c4a7551fdcb133d478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to AddPathLengthCost in usage, but minimizes ∑ |(rᵢ₊₁ − rᵢ)|₂² with weight being applied uniformly to all dimensions.  <br /></td></tr>
<tr class="memitem:af27492cb5b0dbf8cd8ce10e792486052" id="r_af27492cb5b0dbf8cd8ce10e792486052"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af27492cb5b0dbf8cd8ce10e792486052">AddVelocityBounds</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub)</td></tr>
<tr class="memdesc:af27492cb5b0dbf8cd8ce10e792486052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a linear velocity constraint to the entire graph <span class="tt">lb</span> ≤ q̇(t) ≤ <span class="tt">ub</span>.  <br /></td></tr>
<tr class="memitem:a096ce11cacbbdc3be3dd3d189d81b93f" id="r_a096ce11cacbbdc3be3dd3d189d81b93f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a096ce11cacbbdc3be3dd3d189d81b93f">AddNonlinearDerivativeBounds</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lb, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;ub, int derivative_order)</td></tr>
<tr class="memdesc:a096ce11cacbbdc3be3dd3d189d81b93f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a nonlinear derivative constraints to the entire graph <span class="tt">lb</span> ≤ dᴺq(t) / dtᴺ ≤ <span class="tt">ub</span>.  <br /></td></tr>
<tr class="memitem:afce2be43547f60d510c7e46154eac653" id="r_afce2be43547f60d510c7e46154eac653"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afce2be43547f60d510c7e46154eac653">AddPathContinuityConstraints</a> (int continuity_order)</td></tr>
<tr class="memdesc:afce2be43547f60d510c7e46154eac653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enforces that for any two subsequent path segments in the entire graph, the <span class="tt">continuity_order</span>th path derivative at the end of the first segment equals that of the start of the second segment.  <br /></td></tr>
<tr class="memitem:a028f009e523ba70f19975c58f6b0bb6d" id="r_a028f009e523ba70f19975c58f6b0bb6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a028f009e523ba70f19975c58f6b0bb6d">AddContinuityConstraints</a> (int continuity_order)</td></tr>
<tr class="memdesc:a028f009e523ba70f19975c58f6b0bb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enforces that for any two subsequent path segments in the entire graph, the <span class="tt">continuity_order</span>th time derivative at the end of the first segment equals that of the start of the second segment.  <br /></td></tr>
<tr class="memitem:afa9081b0525ebe3c798eb0718c867db9" id="r_afa9081b0525ebe3c798eb0718c867db9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdrake_1_1trajectories_1_1_composite_trajectory.html">trajectories::CompositeTrajectory</a>&lt; double &gt;, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa9081b0525ebe3c798eb0718c867db9">SolvePath</a> (const <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html">Subgraph</a> &amp;source, const <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html">Subgraph</a> &amp;target, const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html">geometry::optimization::GraphOfConvexSetsOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:afa9081b0525ebe3c798eb0718c867db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formulates and solves the mixed-integer convex formulation of the shortest path problem on the whole graph.  <br /></td></tr>
<tr class="memitem:a85376f0db20a5121db76203f54a31a48" id="r_a85376f0db20a5121db76203f54a31a48"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdrake_1_1trajectories_1_1_composite_trajectory.html">trajectories::CompositeTrajectory</a>&lt; double &gt;, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85376f0db20a5121db76203f54a31a48">SolveConvexRestriction</a> (const std::vector&lt; const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">geometry::optimization::GraphOfConvexSets::Vertex</a> * &gt; &amp;active_vertices, const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html">geometry::optimization::GraphOfConvexSetsOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:a85376f0db20a5121db76203f54a31a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a trajectory optimization problem through specific vertices.  <br /></td></tr>
<tr class="memitem:a3026f3dacc50a81434a05e8c9348eebf" id="r_a3026f3dacc50a81434a05e8c9348eebf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3026f3dacc50a81434a05e8c9348eebf">EstimateComplexity</a> () const</td></tr>
<tr class="memdesc:a3026f3dacc50a81434a05e8c9348eebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a heuristic estimate of the complexity of the underlying GCS mathematical program, for regression testing purposes.  <br /></td></tr>
<tr class="memitem:a9f6033f373e991b19d66073b1c1b0c9b" id="r_a9f6033f373e991b19d66073b1c1b0c9b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html">Subgraph</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f6033f373e991b19d66073b1c1b0c9b">GetSubgraphs</a> () const</td></tr>
<tr class="memdesc:a9f6033f373e991b19d66073b1c1b0c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of all subgraphs.  <br /></td></tr>
<tr class="memitem:a349ab26c826f53e4eb51c968854c79ec" id="r_a349ab26c826f53e4eb51c968854c79ec"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_edges_between_subgraphs.html">EdgesBetweenSubgraphs</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a349ab26c826f53e4eb51c968854c79ec">GetEdgesBetweenSubgraphs</a> () const</td></tr>
<tr class="memdesc:a349ab26c826f53e4eb51c968854c79ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of all edges between subgraphs.  <br /></td></tr>
<tr class="memitem:a307ad20cb630564d609f91d30df375c8" id="r_a307ad20cb630564d609f91d30df375c8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html">geometry::optimization::GraphOfConvexSets</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a307ad20cb630564d609f91d30df375c8">graph_of_convex_sets</a> () const</td></tr>
<tr class="memdesc:a307ad20cb630564d609f91d30df375c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the underlying GraphOfConvexSets.  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:a168105bb5c3b8e774024bc13eeef01de" id="r_a168105bb5c3b8e774024bc13eeef01de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a168105bb5c3b8e774024bc13eeef01de">GcsTrajectoryOptimization</a> (const GcsTrajectoryOptimization &amp;)=delete</td></tr>
<tr class="memitem:a90325b07ef4f5c7a63184c5f29efedb6" id="r_a90325b07ef4f5c7a63184c5f29efedb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a168105bb5c3b8e774024bc13eeef01de">GcsTrajectoryOptimization</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90325b07ef4f5c7a63184c5f29efedb6">operator=</a> (const <a class="el" href="#a168105bb5c3b8e774024bc13eeef01de">GcsTrajectoryOptimization</a> &amp;)=delete</td></tr>
<tr class="memitem:a74601e7a7d4fab817e64e564b96e98bd" id="r_a74601e7a7d4fab817e64e564b96e98bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74601e7a7d4fab817e64e564b96e98bd">GcsTrajectoryOptimization</a> (GcsTrajectoryOptimization &amp;&amp;)=delete</td></tr>
<tr class="memitem:abedf8ad9db36a3542b267c0d662e834b" id="r_abedf8ad9db36a3542b267c0d662e834b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a168105bb5c3b8e774024bc13eeef01de">GcsTrajectoryOptimization</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abedf8ad9db36a3542b267c0d662e834b">operator=</a> (<a class="el" href="#a168105bb5c3b8e774024bc13eeef01de">GcsTrajectoryOptimization</a> &amp;&amp;)=delete</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af905be61c4d0357e5240da1af044fd72" id="r_af905be61c4d0357e5240da1af044fd72"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1trajectories_1_1_composite_trajectory.html">trajectories::CompositeTrajectory</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af905be61c4d0357e5240da1af044fd72">NormalizeSegmentTimes</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_composite_trajectory.html">trajectories::CompositeTrajectory</a>&lt; double &gt; &amp;trajectory)</td></tr>
<tr class="memdesc:af905be61c4d0357e5240da1af044fd72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes each trajectory segment to one second in duration.  <br /></td></tr>
<tr class="memitem:a208919331fc98ce462f174197a548f17" id="r_a208919331fc98ce462f174197a548f17"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1trajectories_1_1_composite_trajectory.html">trajectories::CompositeTrajectory</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a208919331fc98ce462f174197a548f17">UnwrapToContinuousTrajectory</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_composite_trajectory.html">trajectories::CompositeTrajectory</a>&lt; double &gt; &amp;gcs_trajectory, std::vector&lt; int &gt; <a class="el" href="#a35b6df4444d05b5f49f5af17620f79b0">continuous_revolute_joints</a>, std::optional&lt; std::vector&lt; int &gt; &gt; starting_rounds=std::nullopt, double tol=1e-8)</td></tr>
<tr class="memdesc:a208919331fc98ce462f174197a548f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwraps a trajectory with continuous revolute joints into a continuous trajectory in the Euclidean space.  <br /></td></tr>
</table>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a168105bb5c3b8e774024bc13eeef01de" name="a168105bb5c3b8e774024bc13eeef01de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168105bb5c3b8e774024bc13eeef01de">&#9670;&#160;</a></span>GcsTrajectoryOptimization() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GcsTrajectoryOptimization </td>
          <td>(</td>
          <td class="paramtype">const GcsTrajectoryOptimization &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a74601e7a7d4fab817e64e564b96e98bd" name="a74601e7a7d4fab817e64e564b96e98bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74601e7a7d4fab817e64e564b96e98bd">&#9670;&#160;</a></span>GcsTrajectoryOptimization() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GcsTrajectoryOptimization </td>
          <td>(</td>
          <td class="paramtype">GcsTrajectoryOptimization &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad515c3a3a5a3ad8e6f2ad33059021f48" name="ad515c3a3a5a3ad8e6f2ad33059021f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad515c3a3a5a3ad8e6f2ad33059021f48">&#9670;&#160;</a></span>GcsTrajectoryOptimization() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GcsTrajectoryOptimization </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>continuous_revolute_joints</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::vector&lt;&#160;int&#160;&gt;()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the motion planning problem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_positions</td><td>is the dimension of the configuration space. </td></tr>
    <tr><td class="paramname">continuous_revolute_joints</td><td>is a list of indices corresponding to continuous revolute joints, i.e., revolute joints which don't have any joint limits, and hence "wrap around" at 2π. Each entry in continuous_revolute_joints must be non-negative, less than num_positions, and unique. This feature is currently only supported within a single subgraph: continuous revolute joints won't be taken into account when constructing edges between subgraphs or checking if sets intersect through a subspace. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c41ee6c46e4e39173da8e589408b9ef" name="a9c41ee6c46e4e39173da8e589408b9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c41ee6c46e4e39173da8e589408b9ef">&#9670;&#160;</a></span>~GcsTrajectoryOptimization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="#a168105bb5c3b8e774024bc13eeef01de">GcsTrajectoryOptimization</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a028f009e523ba70f19975c58f6b0bb6d" name="a028f009e523ba70f19975c58f6b0bb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028f009e523ba70f19975c58f6b0bb6d">&#9670;&#160;</a></span>AddContinuityConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddContinuityConstraints </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>continuity_order</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enforces that for any two subsequent path segments in the entire graph, the <span class="tt">continuity_order</span>th time derivative at the end of the first segment equals that of the start of the second segment. </p>
<p>This adds a nonlinear constraint to the restriction and MIP GraphOfConvexSets::Transcription, while adding a convex surrogate to the relaxation. For more details, see <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#nonconvex_graph_of_convex_sets">Guiding Non-convex Optimization with the GraphOfConvexSets</a>.</p>
<p>The continuity is enforced on the control points of q(t), which appear as nonlinear constraints. </p><pre> (dᴺrᵤ(s=1) / dsᴺ) / hᵤᴺ == (dᴺrᵥ(s=0) / dsᴺ) / hᵥᴺ </pre><p> The convex surrogate is simply the path continuity, where hᵤᴺ and hᵥᴺ are replaced by the characteristic times of the respective sets: </p><pre> (dᴺrᵤ(s=1) / dsᴺ) / hᵤ₀ᴺ == (dᴺrᵥ(s=0) / dsᴺ) / hᵥ₀ᴺ </pre><p>. For now, these are set to one, but future work may involve scaling them by the size of the sets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">continuity_order</td><td>is the order of the continuity constraint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the continuity order is less than one since path continuity is enforced by default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>To enforce that the trajectory is of class C^k, you must call AddContinuityConstraint for each continuity_order 1 through k. </dd></dl>

</div>
</div>
<a id="acd103aa2fa271ca9db91fc8f0a5bbec1" name="acd103aa2fa271ca9db91fc8f0a5bbec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd103aa2fa271ca9db91fc8f0a5bbec1">&#9670;&#160;</a></span>AddEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_edges_between_subgraphs.html">EdgesBetweenSubgraphs</a> &amp; AddEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html">Subgraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>from_subgraph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html">Subgraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>to_subgraph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">geometry::optimization::ConvexSet</a> *</td>          <td class="paramname"><span class="paramname"><em>subspace</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>edges_between_regions</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::VectorXd &gt; *</td>          <td class="paramname"><span class="paramname"><em>edge_offsets</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connects two subgraphs with directed edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_subgraph</td><td>is the subgraph to connect from. Must have been created from a call to <a class="el" href="#a38f9b7b3cb6b154a5743d1bd32e71ec8" title="Creates a Subgraph with the given regions and indices.">AddRegions()</a> on this object, not some other optimization program. </td></tr>
    <tr><td class="paramname">to_subgraph</td><td>is the subgraph to connect to. Must have been created from a call to <a class="el" href="#a38f9b7b3cb6b154a5743d1bd32e71ec8" title="Creates a Subgraph with the given regions and indices.">AddRegions()</a> on this object, not some other optimization program. </td></tr>
    <tr><td class="paramname">subspace</td><td>is the subspace that the connecting control points must be in. Subspace is optional. Only edges that connect through the subspace will be added, and the subspace is added as a constraint on the connecting control points. Subspaces of type point or HPolyhedron are supported since other sets require constraints that are not yet supported by the GraphOfConvexSets::Edge constraint, e.g., set containment of a Hyperellipsoid is formulated via LorentzCone constraints. Workaround: Create a subgraph of zero order with the subspace as the region and connect it between the two subgraphs. This works because GraphOfConvexSet::Vertex supports arbitrary instances of ConvexSets. </td></tr>
    <tr><td class="paramname">edges_between_regions</td><td>can be used to manually specify which edges should be added, avoiding the intersection checks. It should be a list of tuples <span class="tt">(i,j)</span>, where an edge will be added from the <span class="tt">i</span>th index region in <span class="tt">from_subgraph</span> to the <span class="tt">j</span>th index region in <span class="tt">to_subgraph</span>. </td></tr>
    <tr><td class="paramname">edge_offsets</td><td>is an optional list of vectors. If defined, the list must contain the same number of entries as <span class="tt">edges_between_regions</span>, and the order must match. In other words, if defined, there must be one edge offset for each specified edge, and they must be at the same index. For each pair of sets listed in <span class="tt">edges_between_regions</span>, the first set is translated (in configuration space) by the corresponding vector in edge_offsets before computing the constraints associated to that edge. This is used to add edges between sets that "wrap around" 2π along some dimension, due to, e.g., a continuous revolute joint. This edge offset corresponds to the translation component of the affine map τ_uv in equation (11) of "Non-Euclidean Motion
Planning with Graphs of Geodesically-Convex Sets", and per the discussion in Subsection VI A, τ_uv has no rotation component. If edge_offsets is nullptr, it will instead be computed automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">edge_offsets</span> is provided, but <span class="tt">edge_offsets.size()
!= edges_between_regions.size()</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a096ce11cacbbdc3be3dd3d189d81b93f" name="a096ce11cacbbdc3be3dd3d189d81b93f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096ce11cacbbdc3be3dd3d189d81b93f">&#9670;&#160;</a></span>AddNonlinearDerivativeBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddNonlinearDerivativeBounds </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>derivative_order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a nonlinear derivative constraints to the entire graph <span class="tt">lb</span> ≤ dᴺq(t) / dtᴺ ≤ <span class="tt">ub</span>. </p>
<p>This adds a nonlinear constraint to the restriction and MIP GraphOfConvexSets::Transcription, while adding a convex surrogate to the relaxation. For more details, see <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#nonconvex_graph_of_convex_sets">Guiding Non-convex Optimization with the GraphOfConvexSets</a>.</p>
<p>The nonlinear constraint involves the derivative dᴺq(t) / dtᴺ which is decomposed as dᴺr(s) / dsᴺ / hᴺ. The convex surrogate replaces the nonlinear component hᴺ with h₀ᴺ⁻¹h, where h₀ is the characteristic time of the set. For now, h₀ is set to 1.0 for all sets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>is the lower bound of the derivative. </td></tr>
    <tr><td class="paramname">ub</td><td>is the upper bound of the derivative. </td></tr>
    <tr><td class="paramname">derivative_order</td><td>is the order of the derivative to be constrained.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if lb or ub are not of size <a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the number of position variables.">num_positions()</a>. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the derivative order &lt;= 1, since the linear velocity bounds are preferred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afce2be43547f60d510c7e46154eac653" name="afce2be43547f60d510c7e46154eac653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce2be43547f60d510c7e46154eac653">&#9670;&#160;</a></span>AddPathContinuityConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddPathContinuityConstraints </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>continuity_order</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enforces that for any two subsequent path segments in the entire graph, the <span class="tt">continuity_order</span>th path derivative at the end of the first segment equals that of the start of the second segment. </p>
<p>Note that the constraints are on the control points of the derivatives of r(s) and not q(t). This may result in discontinuities of the trajectory return by <span class="tt"><a class="el" href="#afa9081b0525ebe3c798eb0718c867db9" title="Formulates and solves the mixed-integer convex formulation of the shortest path problem on the whole ...">SolvePath()</a></span> since the r(s) will get rescaled by the duration h to yield q(t). <span class="tt"><a class="el" href="#af905be61c4d0357e5240da1af044fd72" title="Normalizes each trajectory segment to one second in duration.">NormalizeSegmentTimes()</a></span> will return r(s) with valid continuity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">continuity_order</td><td>is the order of the continuity constraint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the continuity order is less than one since path continuity is enforced by default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>To enforce that the trajectory is of class C^k, you must call AddPathContinuityConstraint for each continuity_order 1 through k. </dd></dl>

</div>
</div>
<a id="a26e4396347f05f766a19a64910a338b9" name="a26e4396347f05f766a19a64910a338b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e4396347f05f766a19a64910a338b9">&#9670;&#160;</a></span>AddPathEnergyCost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddPathEnergyCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>weight_matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to AddPathLengthCost in usage, but minimizes ∑ |weight_matrix * (rᵢ₊₁ − rᵢ)|₂². </p>
<p>In comparison to AddPathLength cost, this cost encourages control points to be evenly spaced but may result in greater number of regions and larger path length on the solution. It is recommended to use this cost only with SolveConvexRestriction when it becomes a quadratic cost for which some solvers show a better performance.</p>
<p>This cost will be added to the entire graph. Since the path length is only defined for Bézier curves that have two or more control points, this cost will only added to all subgraphs with order greater than zero. Note that this cost will be applied even to subgraphs added in the future.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weight_matrix</td><td>is the relative weight of each component for the cost. The diagonal of the matrix is the weight for each dimension. The off-diagonal elements are the weight for the cross terms, which can be used to penalize diagonal movement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>weight_matrix must be of size <a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the number of position variables.">num_positions()</a> x <a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the number of position variables.">num_positions()</a>. </dd></dl>

</div>
</div>
<a id="af58fa24cbb7560c4a7551fdcb133d478" name="af58fa24cbb7560c4a7551fdcb133d478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58fa24cbb7560c4a7551fdcb133d478">&#9670;&#160;</a></span>AddPathEnergyCost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddPathEnergyCost </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to AddPathLengthCost in usage, but minimizes ∑ |(rᵢ₊₁ − rᵢ)|₂² with weight being applied uniformly to all dimensions. </p>
<p>In comparison to AddPathLength cost, this cost encourages control points to be evenly spaced but may result in greater number of regions and larger path length on the solution. It is recommended to use this cost only with SolveConvexRestriction when it becomes a quadratic cost for which some solvers show a better performance.</p>
<p>This cost will be added to the entire graph. Since the path length is only defined for Bézier curves that have two or more control points, this cost will only added to all subgraphs with order greater than zero. Note that this cost will be applied even to subgraphs added in the future.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weight</td><td>is the relative weight of the cost. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5120b456754eef916922cd73d2ec846a" name="a5120b456754eef916922cd73d2ec846a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5120b456754eef916922cd73d2ec846a">&#9670;&#160;</a></span>AddPathLengthCost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddPathLengthCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>weight_matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds multiple L2Norm Costs on the upper bound of the path length. </p>
<p>Since we cannot directly compute the path length of a Bézier curve, we minimize the upper bound of the path integral by minimizing the sum of (weighted) distances between control points: ∑ |weight_matrix * (rᵢ₊₁ − rᵢ)|₂.</p>
<p>This cost will be added to the entire graph. Since the path length is only defined for Bézier curves that have two or more control points, this cost will only added to all subgraphs with order greater than zero. Note that this cost will be applied even to subgraphs added in the future.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weight_matrix</td><td>is the relative weight of each component for the cost. The diagonal of the matrix is the weight for each dimension. The off-diagonal elements are the weight for the cross terms, which can be used to penalize diagonal movement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>weight_matrix must be of size <a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the number of position variables.">num_positions()</a> x <a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the number of position variables.">num_positions()</a>. </dd></dl>

</div>
</div>
<a id="a34f92ff4feccc5aa2e289b9a514486ac" name="a34f92ff4feccc5aa2e289b9a514486ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f92ff4feccc5aa2e289b9a514486ac">&#9670;&#160;</a></span>AddPathLengthCost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddPathLengthCost </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds multiple L2Norm Costs on the upper bound of the path length. </p>
<p>Since we cannot directly compute the path length of a Bézier curve, we minimize the upper bound of the path integral by minimizing the sum of distances between control points. For Bézier curves, this is equivalent to the sum of the L2Norm of the derivative control points of the curve divided by the order.</p>
<p>This cost will be added to the entire graph. Since the path length is only defined for Bézier curves that have two or more control points, this cost will only added to all subgraphs with order greater than zero. Note that this cost will be applied even to subgraphs added in the future.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weight</td><td>is the relative weight of the cost. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38f9b7b3cb6b154a5743d1bd32e71ec8" name="a38f9b7b3cb6b154a5743d1bd32e71ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f9b7b3cb6b154a5743d1bd32e71ec8">&#9670;&#160;</a></span>AddRegions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html">Subgraph</a> &amp; AddRegions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">geometry::optimization::ConvexSets</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>regions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges_between_regions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>h_min</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>h_max</em></span><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::VectorXd &gt; *</td>          <td class="paramname"><span class="paramname"><em>edge_offsets</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html" title="A Subgraph is a subset of the larger graph.">Subgraph</a> with the given regions and indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regions</td><td>represent the valid set a control point can be in. We retain a copy of the regions since other functions may access them. If any of the positions represent revolute joints without limits, each region has a maximum width of strictly less than π along dimensions corresponding to those joints. </td></tr>
    <tr><td class="paramname">edges_between_regions</td><td>is a list of pairs of indices into the regions vector. For each pair representing an edge between two regions, an edge is added within the subgraph. Note that the edges are directed so (i,j) will only add an edge from region i to region j. </td></tr>
    <tr><td class="paramname">order</td><td>is the order of the Bézier curve. </td></tr>
    <tr><td class="paramname">h_max</td><td>is the maximum duration to spend in a region (seconds). Some solvers struggle numerically with large values. </td></tr>
    <tr><td class="paramname">h_min</td><td>is the minimum duration to spend in a region (seconds) if that region is visited on the optimal path. Some cost and constraints are only convex for h &gt; 0. For example the perspective quadratic cost of the path energy ||ṙ(s)||² / h becomes non-convex for h = 0. Otherwise h_min can be set to 0. </td></tr>
    <tr><td class="paramname">name</td><td>is the name of the subgraph. If the passed name is an empty string, a default name will be provided. </td></tr>
    <tr><td class="paramname">edge_offsets</td><td>is an optional list of vectors. If defined, the list must contain the same number of entries as <span class="tt">edges_between_regions</span>. For each pair of sets listed in <span class="tt">edges_between_regions</span>, the first set is translated (in configuration space) by the corresponding vector in edge_offsets before computing the constraints associated to that edge. This is used to add edges between sets that "wrap around" 2π along some dimension, due to, e.g., a continuous revolute joint. This edge offset corresponds to the translation component of the affine map τ_uv in equation (11) of "Non-Euclidean Motion
Planning with Graphs of Geodesically-Convex Sets", and per the discussion in Subsection VI A, τ_uv has no rotation component. If edge_offsets is nullptr, it will instead be computed automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if any index referenced in <span class="tt">edges_between_regions</span> is outside the range [0, ssize(regions)). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c86bbba3696c2d3eb43336b3a4c6e60" name="a1c86bbba3696c2d3eb43336b3a4c6e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c86bbba3696c2d3eb43336b3a4c6e60">&#9670;&#160;</a></span>AddRegions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html">Subgraph</a> &amp; AddRegions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">geometry::optimization::ConvexSets</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>regions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>h_min</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-6</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>h_max</em></span><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html" title="A Subgraph is a subset of the larger graph.">Subgraph</a> with the given regions. </p>
<p>This function will compute the edges between the regions based on the set intersections. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regions</td><td>represent the valid set a control point can be in. We retain a copy of the regions since other functions may access them. If any of the positions represent continuous revolute joints, each region must have a maximum width of strictly less than π along dimensions corresponding to those joints. </td></tr>
    <tr><td class="paramname">order</td><td>is the order of the Bézier curve. </td></tr>
    <tr><td class="paramname">h_min</td><td>is the minimum duration to spend in a region (seconds) if that region is visited on the optimal path. Some cost and constraints are only convex for h &gt; 0. For example the perspective quadratic cost of the path energy ||ṙ(s)||² / h becomes non-convex for h = 0. Otherwise h_min can be set to 0. </td></tr>
    <tr><td class="paramname">h_max</td><td>is the maximum duration to spend in a region (seconds). Some solvers struggle numerically with large values. </td></tr>
    <tr><td class="paramname">name</td><td>is the name of the subgraph. A default name will be provided. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if any of the regions has a width of π or greater along dimensions corresponding to continuous revolute joints. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a515805314ae145e3be6b636d0986bb09" name="a515805314ae145e3be6b636d0986bb09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515805314ae145e3be6b636d0986bb09">&#9670;&#160;</a></span>AddTimeCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddTimeCost </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>weight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a minimum time cost to all regions in the whole graph. </p>
<p>The cost is the sum of the time scaling variables.</p>
<p>This cost will be added to the entire graph. Note that this cost will be applied even to subgraphs added in the future.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weight</td><td>is the relative weight of the cost. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af27492cb5b0dbf8cd8ce10e792486052" name="af27492cb5b0dbf8cd8ce10e792486052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27492cb5b0dbf8cd8ce10e792486052">&#9670;&#160;</a></span>AddVelocityBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddVelocityBounds </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ub</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a linear velocity constraint to the entire graph <span class="tt">lb</span> ≤ q̇(t) ≤ <span class="tt">ub</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>is the lower bound of the velocity. </td></tr>
    <tr><td class="paramname">ub</td><td>is the upper bound of the velocity.</td></tr>
  </table>
  </dd>
</dl>
<p>This constraint will be added to the entire graph. Since the velocity requires forming the derivative of the Bézier curve, this constraint will only added to all subgraphs with order greater than zero. Note that this constraint will be applied even to subgraphs added in the future.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if lb or ub are not of size <a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the number of position variables.">num_positions()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35b6df4444d05b5f49f5af17620f79b0" name="a35b6df4444d05b5f49f5af17620f79b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35b6df4444d05b5f49f5af17620f79b0">&#9670;&#160;</a></span>continuous_revolute_joints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; int &gt; &amp; continuous_revolute_joints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of indices corresponding to continuous revolute joints. </p>

</div>
</div>
<a id="a3026f3dacc50a81434a05e8c9348eebf" name="a3026f3dacc50a81434a05e8c9348eebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3026f3dacc50a81434a05e8c9348eebf">&#9670;&#160;</a></span>EstimateComplexity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double EstimateComplexity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide a heuristic estimate of the complexity of the underlying GCS mathematical program, for regression testing purposes. </p>
<p>Here we sum the total number of variable appearances in our costs and constraints as a rough approximation of the complexity of the subproblems. </p>

</div>
</div>
<a id="a349ab26c826f53e4eb51c968854c79ec" name="a349ab26c826f53e4eb51c968854c79ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a349ab26c826f53e4eb51c968854c79ec">&#9670;&#160;</a></span>GetEdgesBetweenSubgraphs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_edges_between_subgraphs.html">EdgesBetweenSubgraphs</a> * &gt; GetEdgesBetweenSubgraphs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of all edges between subgraphs. </p>

</div>
</div>
<a id="ae8e736f8d73a8dec8b0f3b653f5f0145" name="ae8e736f8d73a8dec8b0f3b653f5f0145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e736f8d73a8dec8b0f3b653f5f0145">&#9670;&#160;</a></span>GetGraphvizString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string GetGraphvizString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a> *</td>          <td class="paramname"><span class="paramname"><em>result</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_gcs_graphviz_options.html">geometry::optimization::GcsGraphvizOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a Graphviz string describing the graph vertices and edges. </p>
<p>If <span class="tt">result</span> is supplied, then the graph will be annotated with the solution values. </p>

</div>
</div>
<a id="a9f6033f373e991b19d66073b1c1b0c9b" name="a9f6033f373e991b19d66073b1c1b0c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6033f373e991b19d66073b1c1b0c9b">&#9670;&#160;</a></span>GetSubgraphs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html">Subgraph</a> * &gt; GetSubgraphs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of all subgraphs. </p>

</div>
</div>
<a id="a307ad20cb630564d609f91d30df375c8" name="a307ad20cb630564d609f91d30df375c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a307ad20cb630564d609f91d30df375c8">&#9670;&#160;</a></span>graph_of_convex_sets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html">geometry::optimization::GraphOfConvexSets</a> &amp; graph_of_convex_sets </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the underlying GraphOfConvexSets. </p>
<p>This is intended primarily for inspecting the resulting programs. </p>

</div>
</div>
<a id="af905be61c4d0357e5240da1af044fd72" name="af905be61c4d0357e5240da1af044fd72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af905be61c4d0357e5240da1af044fd72">&#9670;&#160;</a></span>NormalizeSegmentTimes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_composite_trajectory.html">trajectories::CompositeTrajectory</a>&lt; double &gt; NormalizeSegmentTimes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1trajectories_1_1_composite_trajectory.html">trajectories::CompositeTrajectory</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>trajectory</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalizes each trajectory segment to one second in duration. </p>
<p>Reconstructs the path r(s) from the solution trajectory q(t) of <span class="tt"><a class="el" href="#afa9081b0525ebe3c798eb0718c867db9" title="Formulates and solves the mixed-integer convex formulation of the shortest path problem on the whole ...">SolvePath()</a></span> s.t. each segment of the resulting trajectory will be one second long. The start time will match the original start time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trajectory</td><td>The solution trajectory returned by <span class="tt"><a class="el" href="#afa9081b0525ebe3c798eb0718c867db9" title="Formulates and solves the mixed-integer convex formulation of the shortest path problem on the whole ...">SolvePath()</a></span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if not all trajectory segments of the CompositeTrajectory are of type BezierCurve&lt;double&gt; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba2887f0ca1fbbdfb49cf6b0ee21e553" name="aba2887f0ca1fbbdfb49cf6b0ee21e553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2887f0ca1fbbdfb49cf6b0ee21e553">&#9670;&#160;</a></span>num_positions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int num_positions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of position variables. </p>

</div>
</div>
<a id="a90325b07ef4f5c7a63184c5f29efedb6" name="a90325b07ef4f5c7a63184c5f29efedb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90325b07ef4f5c7a63184c5f29efedb6">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a168105bb5c3b8e774024bc13eeef01de">GcsTrajectoryOptimization</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a168105bb5c3b8e774024bc13eeef01de">GcsTrajectoryOptimization</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abedf8ad9db36a3542b267c0d662e834b" name="abedf8ad9db36a3542b267c0d662e834b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abedf8ad9db36a3542b267c0d662e834b">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a168105bb5c3b8e774024bc13eeef01de">GcsTrajectoryOptimization</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a168105bb5c3b8e774024bc13eeef01de">GcsTrajectoryOptimization</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a88df1e80fc5caca3da4c817fc3e23338" name="a88df1e80fc5caca3da4c817fc3e23338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88df1e80fc5caca3da4c817fc3e23338">&#9670;&#160;</a></span>RemoveSubgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RemoveSubgraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html">Subgraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>subgraph</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a subgraph and all associated edges found in the subgraph and to and from other subgraphs. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The subgraph must have been created from a call to <a class="el" href="#a38f9b7b3cb6b154a5743d1bd32e71ec8" title="Creates a Subgraph with the given regions and indices.">AddRegions()</a> on this object. </dd></dl>

</div>
</div>
<a id="a85376f0db20a5121db76203f54a31a48" name="a85376f0db20a5121db76203f54a31a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85376f0db20a5121db76203f54a31a48">&#9670;&#160;</a></span>SolveConvexRestriction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classdrake_1_1trajectories_1_1_composite_trajectory.html">trajectories::CompositeTrajectory</a>&lt; double &gt;, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a> &gt; SolveConvexRestriction </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">geometry::optimization::GraphOfConvexSets::Vertex</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>active_vertices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html">geometry::optimization::GraphOfConvexSetsOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves a trajectory optimization problem through specific vertices. </p>
<p>This method allows for targeted optimization by considering only selected active vertices, reducing the problem's complexity. See <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a5c50ae80b0c136e138f815b4a83a30d1" title="The non-convexity in a GCS problem comes from the binary variables (phi) associated with the edges be...">geometry::optimization::GraphOfConvexSets::SolveConvexRestriction()</a>. This API prefers a sequence of vertices over edges, as a user may know which regions the solution should pass through. <a class="el" href="#a38f9b7b3cb6b154a5743d1bd32e71ec8" title="Creates a Subgraph with the given regions and indices.">GcsTrajectoryOptimization::AddRegions()</a> automatically manages edge creation and intersection checks, which makes passing a sequence of edges less convenient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">active_vertices</td><td>A sequence of ordered vertices of subgraphs to be included in the problem. </td></tr>
    <tr><td class="paramname">options</td><td>include all settings for solving the shortest path problem.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>There must be at least two vertices in active_vertices. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the vertices are not connected. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if two vertices are connected by multiple edges. This may happen if one connects two graphs through multiple subspaces, which is currently not supported with this method. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the program cannot be written as a convex optimization consumable by one of the standard solvers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa9081b0525ebe3c798eb0718c867db9" name="afa9081b0525ebe3c798eb0718c867db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9081b0525ebe3c798eb0718c867db9">&#9670;&#160;</a></span>SolvePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classdrake_1_1trajectories_1_1_composite_trajectory.html">trajectories::CompositeTrajectory</a>&lt; double &gt;, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a> &gt; SolvePath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html">Subgraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization_1_1_subgraph.html">Subgraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html">geometry::optimization::GraphOfConvexSetsOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formulates and solves the mixed-integer convex formulation of the shortest path problem on the whole graph. </p>
<dl class="section see"><dt>See also</dt><dd><span class="tt"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#a51f263df76c721f1bbdeb5708bf7df86" title="Formulates and solves the mixed-integer convex formulation of the shortest path problem on the graph,...">geometry::optimization::GraphOfConvexSets::SolveShortestPath()</a></span> for further details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>specifies the source subgraph. Must have been created from a call to <a class="el" href="#a38f9b7b3cb6b154a5743d1bd32e71ec8" title="Creates a Subgraph with the given regions and indices.">AddRegions()</a> on this object, not some other optimization program. If the source is a subgraph with more than one region, an empty set will be added and optimizer will choose the best region to start in. To start in a particular point, consider adding a subgraph of order zero with a single region of type Point. </td></tr>
    <tr><td class="paramname">target</td><td>specifies the target subgraph. Must have been created from a call to <a class="el" href="#a38f9b7b3cb6b154a5743d1bd32e71ec8" title="Creates a Subgraph with the given regions and indices.">AddRegions()</a> on this object, not some other optimization program. If the target is a subgraph with more than one region, an empty set will be added and optimizer will choose the best region to end in. To end in a particular point, consider adding a subgraph of order zero with a single region of type Point. </td></tr>
    <tr><td class="paramname">options</td><td>include all settings for solving the shortest path problem. The following default options will be used if they are not provided in <span class="tt">options</span>:<ul>
<li><span class="tt">options.convex_relaxation = true</span>,</li>
<li><span class="tt">options.max_rounded_paths = 5</span>,</li>
<li><span class="tt">options.preprocessing = true</span>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><span class="tt"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html">geometry::optimization::GraphOfConvexSetsOptions</a></span> for further details. </dd></dl>

</div>
</div>
<a id="a208919331fc98ce462f174197a548f17" name="a208919331fc98ce462f174197a548f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208919331fc98ce462f174197a548f17">&#9670;&#160;</a></span>UnwrapToContinuousTrajectory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_composite_trajectory.html">trajectories::CompositeTrajectory</a>&lt; double &gt; UnwrapToContinuousTrajectory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1trajectories_1_1_composite_trajectory.html">trajectories::CompositeTrajectory</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gcs_trajectory</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>continuous_revolute_joints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::vector&lt; int &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>starting_rounds</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-8</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unwraps a trajectory with continuous revolute joints into a continuous trajectory in the Euclidean space. </p>
<p>Trajectories produced by <a class="el" href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization.html" title="GcsTrajectoryOptimization implements a simplified motion planning optimization problem introduced in ...">GcsTrajectoryOptimization</a> for robotic systems with continuous revolute joints may include apparent discontinuities, where a multiple of 2π is instantaneously added to a joint value at the boundary between two adjacent segments of the trajectory. This function removes such discontinuities by adding or subtracting the appropriate multiple of 2π, "unwrapping" the trajectory into a continuous representation suitable for downstream tasks that do not take the joint wraparound into account. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gcs_trajectory</td><td>The trajectory to unwrap. </td></tr>
    <tr><td class="paramname">continuous_revolute_joints</td><td>The indices of the continuous revolute joints. </td></tr>
    <tr><td class="paramname">tol</td><td>The numerical tolerance used to determine if two subsequent segments start and end at the same value modulo 2π for continuous revolute joints. </td></tr>
    <tr><td class="paramname">starting_rounds</td><td>A vector of integers that sets the starting rounds for each continuous revolute joint. Given integer k for the starting_round of a joint, its initial position will be wrapped into [2πk , 2π(k+1)). If the starting rounds are not provided, the initial position of <code class="param">trajectory</code> will be unchanged.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an unwrapped (continous in Euclidean space) CompositeTrajectory.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if starting_rounds.size()!=continuous_revolute_joints.size(). </td></tr>
    <tr><td class="paramname">std::exception</td><td>if continuous_revolute_joints contain repeated indices and/or indices outside the range [0, gcs_trajectory.rows()). </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the gcs_trajectory is not continuous on the manifold defined by the continuous_revolute_joints, i.e., the shift between two consecutive segments is not an integer multiple of 2π (within a tolerance of <span class="tt">tol</span> radians). </td></tr>
    <tr><td class="paramname">std::exception</td><td>if all the segments are not of type BezierCurve. Other types are not supported yet. Note that currently the output of <a class="el" href="#afa9081b0525ebe3c798eb0718c867db9" title="Formulates and solves the mixed-integer convex formulation of the shortest path problem on the whole ...">GcsTrajectoryOptimization::SolvePath()</a> is a CompositeTrajectory of BezierCurves. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/planning/trajectory_optimization/<a class="el" href="gcs__trajectory__optimization_8h.html">gcs_trajectory_optimization.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1planning.html">planning</a></li><li class="navelem"><a href="namespacedrake_1_1planning_1_1trajectory__optimization.html">trajectory_optimization</a></li><li class="navelem"><a href="classdrake_1_1planning_1_1trajectory__optimization_1_1_gcs_trajectory_optimization.html">GcsTrajectoryOptimization</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
