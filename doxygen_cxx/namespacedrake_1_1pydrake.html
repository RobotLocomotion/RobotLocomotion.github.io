<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake::pydrake Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 </div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacedrake_1_1pydrake.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">drake::pydrake Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>For more high-level information, see the <a class="el" href="group__python__bindings.html">Python Bindings</a> technical notes. </p>
<p>Drake developers should prefer any aliases defined here over their full spellings in <code>pybind11</code>.</p>
<p><code>namespace py</code> is a shorthand alias to <code>pybind11</code> for consistency. (This symbol cannot be exposed directly in Doxygen.)</p>
<dl class="section note"><dt>Note</dt><dd>Downstream users should avoid <code>using namespace <a class="el" href="namespacedrake_1_1pydrake.html" title="For more high-level information, see the Python Bindings technical notes.">drake::pydrake</a></code>, as this may create ambiguous aliases (especially for GCC). Instead, consider using your own alias directly to the <code>pybind11</code> namespace. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedrake_1_1pydrake_1_1pysolvers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake_1_1pysolvers.html">pysolvers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1pydrake_1_1pysystems"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake_1_1pysystems.html">pysystems</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1pydrake_1_1_object.html">Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a publicly visible, but minimal, re-implementation of <code>py::object</code> so that a public type can be used with <code><a class="el" href="classdrake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">drake::Value</a>&lt;T&gt;</code>, while still maintaining the revelant semantics with its generic implementation (#13207).  <a href="classdrake_1_1pydrake_1_1_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1pydrake_1_1overload__cast__impl.html">overload_cast_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1pydrake_1_1wrap__arg__default.html">wrap_arg_default</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default case for argument wrapping, with pure pass-through.  <a href="structdrake_1_1pydrake_1_1wrap__arg__default.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a52292ed585da63084b8914356a744d04"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a52292ed585da63084b8914356a744d04">CommonScalarPack</a> = <a class="el" href="structdrake_1_1type__pack.html">type_pack</a>&lt; <a class="el" href="classdouble.html">double</a>, <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a>, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;</td></tr>
<tr class="memdesc:a52292ed585da63084b8914356a744d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type pack defining common scalar types.  <a href="#a52292ed585da63084b8914356a744d04">More...</a><br /></td></tr>
<tr class="separator:a52292ed585da63084b8914356a744d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69fa97ca5615e75170ca0274e32cba2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#aa69fa97ca5615e75170ca0274e32cba2">NonSymbolicScalarPack</a> = <a class="el" href="structdrake_1_1type__pack.html">type_pack</a>&lt; <a class="el" href="classdouble.html">double</a>, <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &gt;</td></tr>
<tr class="memdesc:aa69fa97ca5615e75170ca0274e32cba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type pack for non-symbolic common scalar types.  <a href="#aa69fa97ca5615e75170ca0274e32cba2">More...</a><br /></td></tr>
<tr class="separator:aa69fa97ca5615e75170ca0274e32cba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0999cb00e07db1ec4109413a82b6f4"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; class wrap_arg_policy, typename Signature &gt; </td></tr>
<tr class="memitem:aab0999cb00e07db1ec4109413a82b6f4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#aab0999cb00e07db1ec4109413a82b6f4">wrap_arg_function</a> = typename internal::wrap_function_impl&lt; wrap_arg_policy &gt;::template wrap_arg&lt; std::function&lt; Signature &gt; &gt;</td></tr>
<tr class="memdesc:aab0999cb00e07db1ec4109413a82b6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for explicitly wrapping functions for a given policy.  <a href="#aab0999cb00e07db1ec4109413a82b6f4">More...</a><br /></td></tr>
<tr class="separator:aab0999cb00e07db1ec4109413a82b6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e587c4c8d044dd6eee74dad65c203ed"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a6e587c4c8d044dd6eee74dad65c203ed">py_rvp</a> = py::return_value_policy</td></tr>
<tr class="memdesc:a6e587c4c8d044dd6eee74dad65c203ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortened alias for py::return_value_policy.  <a href="#a6e587c4c8d044dd6eee74dad65c203ed">More...</a><br /></td></tr>
<tr class="separator:a6e587c4c8d044dd6eee74dad65c203ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2274d953c5404b3021085ef6c9891603"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a2274d953c5404b3021085ef6c9891603"><td class="memTemplItemLeft" align="right" valign="top">py::tuple&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a2274d953c5404b3021085ef6c9891603">GetPyParam</a> (<a class="el" href="structdrake_1_1type__pack.html">type_pack</a>&lt; Ts... &gt;={})</td></tr>
<tr class="memdesc:a2274d953c5404b3021085ef6c9891603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the canonical Python parameters for each C++ type.  <a href="#a2274d953c5404b3021085ef6c9891603">More...</a><br /></td></tr>
<tr class="separator:a2274d953c5404b3021085ef6c9891603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4790743839a4b041b37dc3820e2475ae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4790743839a4b041b37dc3820e2475ae"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a4790743839a4b041b37dc3820e2475ae">TemporaryClassName</a> (const std::string &amp;name=&quot;TemporaryName&quot;)</td></tr>
<tr class="memdesc:a4790743839a4b041b37dc3820e2475ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a temporary, unique name for a class instantiation that will be passed to <code>AddTemplateClass</code>.  <a href="#a4790743839a4b041b37dc3820e2475ae">More...</a><br /></td></tr>
<tr class="separator:a4790743839a4b041b37dc3820e2475ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85dae944dd94ece7b256c9c46215268d"><td class="memItemLeft" align="right" valign="top">py::object&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a85dae944dd94ece7b256c9c46215268d">AddTemplateClass</a> (py::handle scope, const std::string &amp;template_name, py::handle py_class, py::tuple param, bool skip_rename=false)</td></tr>
<tr class="memdesc:a85dae944dd94ece7b256c9c46215268d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a template class instantiation.  <a href="#a85dae944dd94ece7b256c9c46215268d">More...</a><br /></td></tr>
<tr class="separator:a85dae944dd94ece7b256c9c46215268d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5aba035d48c052690fe1d1b4a3f414"><td class="memTemplParams" colspan="2">template&lt;typename Class , typename... Options&gt; </td></tr>
<tr class="memitem:abe5aba035d48c052690fe1d1b4a3f414"><td class="memTemplItemLeft" align="right" valign="top">py::class_&lt; Class, Options... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#abe5aba035d48c052690fe1d1b4a3f414">DefineTemplateClassWithDefault</a> (py::handle scope, const std::string &amp;default_name, py::tuple param, const char *doc_string=&quot;&quot;, const std::optional&lt; std::string &gt; &amp;template_suffix={}, std::optional&lt; py::dynamic_attr &gt; dynamic_attr={})</td></tr>
<tr class="memdesc:abe5aba035d48c052690fe1d1b4a3f414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a convenience wrapper for defining a template class instantiation and a default instantiation (if not already defined).  <a href="#abe5aba035d48c052690fe1d1b4a3f414">More...</a><br /></td></tr>
<tr class="separator:abe5aba035d48c052690fe1d1b4a3f414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590ec0531f7c675e373909bb758740db"><td class="memTemplParams" colspan="2">template&lt;typename Func , typename... Extra&gt; </td></tr>
<tr class="memitem:a590ec0531f7c675e373909bb758740db"><td class="memTemplItemLeft" align="right" valign="top">py::object&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a590ec0531f7c675e373909bb758740db">AddTemplateFunction</a> (py::handle scope, const std::string &amp;name, Func &amp;&amp;func, py::tuple param, Extra &amp;&amp;... extra)</td></tr>
<tr class="memdesc:a590ec0531f7c675e373909bb758740db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a template function.  <a href="#a590ec0531f7c675e373909bb758740db">More...</a><br /></td></tr>
<tr class="separator:a590ec0531f7c675e373909bb758740db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab5a60c764576412e9362aaf18cad93"><td class="memTemplParams" colspan="2">template&lt;typename Method , typename... Extra&gt; </td></tr>
<tr class="memitem:a9ab5a60c764576412e9362aaf18cad93"><td class="memTemplItemLeft" align="right" valign="top">py::object&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a9ab5a60c764576412e9362aaf18cad93">AddTemplateMethod</a> (py::handle scope, const std::string &amp;name, Method &amp;&amp;method, py::tuple param, Extra &amp;&amp;... extra)</td></tr>
<tr class="memdesc:a9ab5a60c764576412e9362aaf18cad93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a template method.  <a href="#a9ab5a60c764576412e9362aaf18cad93">More...</a><br /></td></tr>
<tr class="separator:a9ab5a60c764576412e9362aaf18cad93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6294e82ee237c93a7e6cbc2fb4d924b2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PyClass , typename UPack  = typename internal::CastUPack&lt;T&gt;::Pack&gt; </td></tr>
<tr class="memitem:a6294e82ee237c93a7e6cbc2fb4d924b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a6294e82ee237c93a7e6cbc2fb4d924b2">DefCast</a> (PyClass *cls, const char *doc, UPack U_pack={})</td></tr>
<tr class="memdesc:a6294e82ee237c93a7e6cbc2fb4d924b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds <code>cast&lt;T&gt;()</code> explicitly.  <a href="#a6294e82ee237c93a7e6cbc2fb4d924b2">More...</a><br /></td></tr>
<tr class="separator:a6294e82ee237c93a7e6cbc2fb4d924b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b68ce63cf178e7d4e91f95e0e483e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#ab0b68ce63cf178e7d4e91f95e0e483e1">DeprecateAttribute</a> (py::object cls, py::str name, py::str message, std::optional&lt; std::string &gt; date={})</td></tr>
<tr class="memdesc:ab0b68ce63cf178e7d4e91f95e0e483e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecates an attribute <code>name</code> of a class <code>cls</code>.  <a href="#ab0b68ce63cf178e7d4e91f95e0e483e1">More...</a><br /></td></tr>
<tr class="separator:ab0b68ce63cf178e7d4e91f95e0e483e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64efa5d584964d8c233e48c107eae84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#ad64efa5d584964d8c233e48c107eae84">WarnDeprecated</a> (const std::string &amp;message, std::optional&lt; std::string &gt; date={})</td></tr>
<tr class="memdesc:ad64efa5d584964d8c233e48c107eae84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises a deprecation warning.  <a href="#ad64efa5d584964d8c233e48c107eae84">More...</a><br /></td></tr>
<tr class="separator:ad64efa5d584964d8c233e48c107eae84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b9050ef1d00002327354d9b24272c8"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:ab4b9050ef1d00002327354d9b24272c8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#ab4b9050ef1d00002327354d9b24272c8">WrapDeprecated</a> (std::string message, Func &amp;&amp;func)</td></tr>
<tr class="memdesc:ab4b9050ef1d00002327354d9b24272c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps any callable (function pointer, method pointer, lambda, etc.) to emit a deprecation message.  <a href="#ab4b9050ef1d00002327354d9b24272c8">More...</a><br /></td></tr>
<tr class="separator:ab4b9050ef1d00002327354d9b24272c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2b2fc77486a9fc30dcbb117eae3bb1"><td class="memTemplParams" colspan="2">template&lt;typename Class , typename... Args&gt; </td></tr>
<tr class="memitem:a6b2b2fc77486a9fc30dcbb117eae3bb1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a6b2b2fc77486a9fc30dcbb117eae3bb1">py_init_deprecated</a> (std::string message)</td></tr>
<tr class="memdesc:a6b2b2fc77486a9fc30dcbb117eae3bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated wrapping of <code>py::init&lt;&gt;</code>.  <a href="#a6b2b2fc77486a9fc30dcbb117eae3bb1">More...</a><br /></td></tr>
<tr class="separator:a6b2b2fc77486a9fc30dcbb117eae3bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca9238e1190c7ed4a407230858368cc"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a7ca9238e1190c7ed4a407230858368cc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a7ca9238e1190c7ed4a407230858368cc">py_init_deprecated</a> (std::string message, Func &amp;&amp;func)</td></tr>
<tr class="memdesc:a7ca9238e1190c7ed4a407230858368cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated wrapping of <code>py::init(factory)</code>.  <a href="#a7ca9238e1190c7ed4a407230858368cc">More...</a><br /></td></tr>
<tr class="separator:a7ca9238e1190c7ed4a407230858368cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccf8095ae346728e479e818bef071ec"><td class="memTemplParams" colspan="2">template&lt;typename Class &gt; </td></tr>
<tr class="memitem:a0ccf8095ae346728e479e818bef071ec"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a0ccf8095ae346728e479e818bef071ec">DeprecatedParamInit</a> (std::string message)</td></tr>
<tr class="memdesc:a0ccf8095ae346728e479e818bef071ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The deprecated flavor of ParamInit&lt;&gt;.  <a href="#a0ccf8095ae346728e479e818bef071ec">More...</a><br /></td></tr>
<tr class="separator:a0ccf8095ae346728e479e818bef071ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7582877591057ceea633df19d910fa"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a0d7582877591057ceea633df19d910fa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a0d7582877591057ceea633df19d910fa">ToEigenRef</a> (Eigen::VectorBlock&lt; Derived &gt; *derived)</td></tr>
<tr class="memdesc:a0d7582877591057ceea633df19d910fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a mutable Ref&lt;&gt; for a pointer.  <a href="#a0d7582877591057ceea633df19d910fa">More...</a><br /></td></tr>
<tr class="separator:a0d7582877591057ceea633df19d910fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875e25ecdc84790945435e9538a6ef60"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a875e25ecdc84790945435e9538a6ef60"><td class="memTemplItemLeft" align="right" valign="top">py::object&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a875e25ecdc84790945435e9538a6ef60">ToArray</a> (T *ptr, <a class="el" href="classint.html">int</a> size, py::tuple shape, py::return_value_policy policy=py_rvp::reference, py::handle parent=py::handle())</td></tr>
<tr class="memdesc:a875e25ecdc84790945435e9538a6ef60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a raw array to a numpy array.  <a href="#a875e25ecdc84790945435e9538a6ef60">More...</a><br /></td></tr>
<tr class="separator:a875e25ecdc84790945435e9538a6ef60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9047f00f873c1cd6f00d0665365ecf5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab9047f00f873c1cd6f00d0665365ecf5"><td class="memTemplItemLeft" align="right" valign="top">py::object&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#ab9047f00f873c1cd6f00d0665365ecf5">ToArray</a> (const T *ptr, <a class="el" href="classint.html">int</a> size, py::tuple shape, py::return_value_policy policy=py_rvp::reference, py::handle parent=py::handle())</td></tr>
<tr class="memdesc:ab9047f00f873c1cd6f00d0665365ecf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a raw array to a numpy array (<code>const</code> variant).  <a href="#ab9047f00f873c1cd6f00d0665365ecf5">More...</a><br /></td></tr>
<tr class="separator:ab9047f00f873c1cd6f00d0665365ecf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f81d7315477aaa1694d9aa02a1346b"><td class="memItemLeft" align="right" valign="top">py::object&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#af5f81d7315477aaa1694d9aa02a1346b">WrapToMatchInputShape</a> (py::handle func)</td></tr>
<tr class="memdesc:af5f81d7315477aaa1694d9aa02a1346b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a overload instance method to reshape the output to be the same as a given input argument.  <a href="#af5f81d7315477aaa1694d9aa02a1346b">More...</a><br /></td></tr>
<tr class="separator:af5f81d7315477aaa1694d9aa02a1346b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3791768bef1f65b7d83bcd7767e0b307"><td class="memTemplParams" colspan="2">template&lt;typename Class , typename ModuleOrClass &gt; </td></tr>
<tr class="memitem:a3791768bef1f65b7d83bcd7767e0b307"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a3791768bef1f65b7d83bcd7767e0b307">BindIdentifier</a> (ModuleOrClass m, const std::string &amp;name, const char *id_doc)</td></tr>
<tr class="memdesc:a3791768bef1f65b7d83bcd7767e0b307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds an <a class="el" href="classdrake_1_1_identifier.html" title="A simple identifier class.">Identifier</a> instantiation.  <a href="#a3791768bef1f65b7d83bcd7767e0b307">More...</a><br /></td></tr>
<tr class="separator:a3791768bef1f65b7d83bcd7767e0b307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3e8f87bda821cd1fa9a52586e25f1e"><td class="memTemplParams" colspan="2">template&lt;typename PyClass , typename Docs &gt; </td></tr>
<tr class="memitem:a0b3e8f87bda821cd1fa9a52586e25f1e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a0b3e8f87bda821cd1fa9a52586e25f1e">DefAttributesUsingSerialize</a> (PyClass *ppy_class, const Docs &amp;cls_docs)</td></tr>
<tr class="memdesc:a0b3e8f87bda821cd1fa9a52586e25f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the attributes visited by a C++ class Serialize function as readwrite on properties its ppy_class.  <a href="#a0b3e8f87bda821cd1fa9a52586e25f1e">More...</a><br /></td></tr>
<tr class="separator:a0b3e8f87bda821cd1fa9a52586e25f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68be3d37cf9d6c6fcc2afb98d04c046f"><td class="memTemplParams" colspan="2">template&lt;typename PyClass &gt; </td></tr>
<tr class="memitem:a68be3d37cf9d6c6fcc2afb98d04c046f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a68be3d37cf9d6c6fcc2afb98d04c046f">DefAttributesUsingSerialize</a> (PyClass *ppy_class)</td></tr>
<tr class="memdesc:a68be3d37cf9d6c6fcc2afb98d04c046f"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) An overload that doesn't bind docstrings.  <a href="#a68be3d37cf9d6c6fcc2afb98d04c046f">More...</a><br /></td></tr>
<tr class="separator:a68be3d37cf9d6c6fcc2afb98d04c046f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9814a507ba70a62d61b467c3ba06cce"><td class="memTemplParams" colspan="2">template&lt;typename PyClass &gt; </td></tr>
<tr class="memitem:aa9814a507ba70a62d61b467c3ba06cce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#aa9814a507ba70a62d61b467c3ba06cce">DefReprUsingSerialize</a> (PyClass *ppy_class)</td></tr>
<tr class="memdesc:aa9814a507ba70a62d61b467c3ba06cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds <b>repr</b> using a C++ class Serialize function.  <a href="#aa9814a507ba70a62d61b467c3ba06cce">More...</a><br /></td></tr>
<tr class="separator:aa9814a507ba70a62d61b467c3ba06cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236143263d0a18d6ec439f707140d7e1"><td class="memTemplParams" colspan="2">template&lt;typename Class &gt; </td></tr>
<tr class="memitem:a236143263d0a18d6ec439f707140d7e1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a236143263d0a18d6ec439f707140d7e1">BindTypeSafeIndex</a> (py::module m, const std::string &amp;name, const std::string &amp;class_doc=&quot;&quot;)</td></tr>
<tr class="memdesc:a236143263d0a18d6ec439f707140d7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a <a class="el" href="classdrake_1_1_type_safe_index.html" title="A type-safe non-negative index class.">TypeSafeIndex</a> instantiation along with its <a class="el" href="classdrake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">Value</a>[Class] type-erasure wrapper.  <a href="#a236143263d0a18d6ec439f707140d7e1">More...</a><br /></td></tr>
<tr class="separator:a236143263d0a18d6ec439f707140d7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210546c12706075cdd90f811470ac4b0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Class  = drake::Value&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a210546c12706075cdd90f811470ac4b0"><td class="memTemplItemLeft" align="right" valign="top">py::class_&lt; Class, <a class="el" href="classdrake_1_1_abstract_value.html">drake::AbstractValue</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a210546c12706075cdd90f811470ac4b0">AddValueInstantiation</a> (py::module scope)</td></tr>
<tr class="memdesc:a210546c12706075cdd90f811470ac4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an instantiation of <code>pydrake.common.value.Value[...]</code>.  <a href="#a210546c12706075cdd90f811470ac4b0">More...</a><br /></td></tr>
<tr class="separator:a210546c12706075cdd90f811470ac4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b03ea674322481f48a1262e0c607a2"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; class wrap_arg_policy, bool use_functions = true, typename Func  = void&gt; </td></tr>
<tr class="memitem:a52b03ea674322481f48a1262e0c607a2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a52b03ea674322481f48a1262e0c607a2">WrapFunction</a> (Func &amp;&amp;func)</td></tr>
<tr class="memdesc:a52b03ea674322481f48a1262e0c607a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the types used in a function signature to produce a new function with wrapped arguments and return value (if non-void).  <a href="#a52b03ea674322481f48a1262e0c607a2">More...</a><br /></td></tr>
<tr class="separator:a52b03ea674322481f48a1262e0c607a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455a0f794f758f800bce946f37c6be29"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a455a0f794f758f800bce946f37c6be29"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a455a0f794f758f800bce946f37c6be29">WrapCallbacks</a> (Func &amp;&amp;func)</td></tr>
<tr class="memdesc:a455a0f794f758f800bce946f37c6be29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that any <code>std::function&lt;&gt;</code> arguments are wrapped such that any <code>T&amp;</code> (which can infer for <code>T = const U</code>) is wrapped as <code>U*</code> (and conversely unwrapped when returned).  <a href="#a455a0f794f758f800bce946f37c6be29">More...</a><br /></td></tr>
<tr class="separator:a455a0f794f758f800bce946f37c6be29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d8c49a4502029d0167c2aa50f4b624"><td class="memTemplParams" colspan="2">template&lt;typename PyClass , typename Class , typename T &gt; </td></tr>
<tr class="memitem:a03d8c49a4502029d0167c2aa50f4b624"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a03d8c49a4502029d0167c2aa50f4b624">DefReadWriteKeepAlive</a> (PyClass *cls, const char *name, T Class::*member, const char *doc=&quot;&quot;)</td></tr>
<tr class="memdesc:a03d8c49a4502029d0167c2aa50f4b624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Idempotent to pybind11's <code>def_readwrite()</code>, with the exception that the setter is protected with keep_alive on a <code>member</code> variable that is a bare pointer.  <a href="#a03d8c49a4502029d0167c2aa50f4b624">More...</a><br /></td></tr>
<tr class="separator:a03d8c49a4502029d0167c2aa50f4b624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a22cfe187c4d2e58dacdc4fddf69843"><td class="memTemplParams" colspan="2">template&lt;typename PyClass , typename Class , typename T &gt; </td></tr>
<tr class="memitem:a3a22cfe187c4d2e58dacdc4fddf69843"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a3a22cfe187c4d2e58dacdc4fddf69843">DefReadUniquePtr</a> (PyClass *cls, const char *name, const std::unique_ptr&lt; T &gt; Class::*member, const char *doc=&quot;&quot;)</td></tr>
<tr class="memdesc:a3a22cfe187c4d2e58dacdc4fddf69843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Idempotent to pybind11's <code>def_readonly()</code>, which works for unique_ptr elements; the getter is protected with keep_alive on a <code>member</code> variable that is a unique_ptr.  <a href="#a3a22cfe187c4d2e58dacdc4fddf69843">More...</a><br /></td></tr>
<tr class="separator:a3a22cfe187c4d2e58dacdc4fddf69843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50864a5d92c08bf74cf16b6d004aaa6a"><td class="memTemplParams" colspan="2">template&lt;typename PyClass , typename Class , typename T &gt; </td></tr>
<tr class="memitem:a50864a5d92c08bf74cf16b6d004aaa6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a50864a5d92c08bf74cf16b6d004aaa6a">DefReadUniquePtr</a> (PyClass *cls, const char *name, const <a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; T &gt; Class::*member, const char *doc=&quot;&quot;)</td></tr>
<tr class="separator:a50864a5d92c08bf74cf16b6d004aaa6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7429d58f69452750233eb29092d6e679"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a7429d58f69452750233eb29092d6e679">DefineGeometryCommon</a> (py::module m)</td></tr>
<tr class="memdesc:a7429d58f69452750233eb29092d6e679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the common elements in the <a class="el" href="namespacedrake_1_1geometry.html">drake::geometry</a> namespace.  <a href="#a7429d58f69452750233eb29092d6e679">More...</a><br /></td></tr>
<tr class="separator:a7429d58f69452750233eb29092d6e679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb190e42e2f696d5ed3f8d319db6459"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#aeeb190e42e2f696d5ed3f8d319db6459">DefineGeometryHydro</a> (py::module m)</td></tr>
<tr class="memdesc:aeeb190e42e2f696d5ed3f8d319db6459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines all of the hydroelastic-specific entities.  <a href="#aeeb190e42e2f696d5ed3f8d319db6459">More...</a><br /></td></tr>
<tr class="separator:aeeb190e42e2f696d5ed3f8d319db6459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486ee6b32b3daf0b9c433f6a4242174e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a486ee6b32b3daf0b9c433f6a4242174e">DefineGeometryMeshes</a> (py::module m)</td></tr>
<tr class="memdesc:a486ee6b32b3daf0b9c433f6a4242174e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the basic mesh types (and some parsing operations) on those types.  <a href="#a486ee6b32b3daf0b9c433f6a4242174e">More...</a><br /></td></tr>
<tr class="separator:a486ee6b32b3daf0b9c433f6a4242174e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2a66cb1a4fec05d8ec8f5d2dd7b6de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a1e2a66cb1a4fec05d8ec8f5d2dd7b6de">DefineGeometryOptimization</a> (py::module m)</td></tr>
<tr class="memdesc:a1e2a66cb1a4fec05d8ec8f5d2dd7b6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines all elements in the <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html">drake::geometry::optimization</a> namespace.  <a href="#a1e2a66cb1a4fec05d8ec8f5d2dd7b6de">More...</a><br /></td></tr>
<tr class="separator:a1e2a66cb1a4fec05d8ec8f5d2dd7b6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fdf83dabca18e8bee66c72ce462fdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#ad3fdf83dabca18e8bee66c72ce462fdc">DefineGeometryRender</a> (py::module m)</td></tr>
<tr class="memdesc:ad3fdf83dabca18e8bee66c72ce462fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the public API of the drake/geometry/render and drake/geometry/render_* directories.  <a href="#ad3fdf83dabca18e8bee66c72ce462fdc">More...</a><br /></td></tr>
<tr class="separator:ad3fdf83dabca18e8bee66c72ce462fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e766f9fb38d0bcd69a4d11f7fc2efb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a1e766f9fb38d0bcd69a4d11f7fc2efb3">DefineGeometrySceneGraph</a> (py::module m)</td></tr>
<tr class="memdesc:a1e766f9fb38d0bcd69a4d11f7fc2efb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds SceneGraph and its query-related classes.  <a href="#a1e766f9fb38d0bcd69a4d11f7fc2efb3">More...</a><br /></td></tr>
<tr class="separator:a1e766f9fb38d0bcd69a4d11f7fc2efb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1dd02f74528f84556c55239d82ab9b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#af1dd02f74528f84556c55239d82ab9b3">DefineGeometryVisualizers</a> (py::module m)</td></tr>
<tr class="memdesc:af1dd02f74528f84556c55239d82ab9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the visualizers in <a class="el" href="namespacedrake_1_1geometry.html">drake::geometry</a>.  <a href="#af1dd02f74528f84556c55239d82ab9b3">More...</a><br /></td></tr>
<tr class="separator:af1dd02f74528f84556c55239d82ab9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d712eb0a12e5f78078993172f842dfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">geometry::optimization::ConvexSets</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a3d712eb0a12e5f78078993172f842dfe">CloneConvexSets</a> (const std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">geometry::optimization::ConvexSet</a> * &gt; &amp;sets_in)</td></tr>
<tr class="memdesc:a3d712eb0a12e5f78078993172f842dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep-copies the ConvexSet pointers in the given list into the C++-compatible object ConvexSets (which uses <a class="el" href="classdrake_1_1copyable__unique__ptr.html" title="A smart pointer with deep copy semantics.">copyable_unique_ptr</a> ownership).  <a href="#a3d712eb0a12e5f78078993172f842dfe">More...</a><br /></td></tr>
<tr class="separator:a3d712eb0a12e5f78078993172f842dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4937c776ae795edfe27824821a0d14a5"><td class="memTemplParams" colspan="2">template&lt;typename PyClass &gt; </td></tr>
<tr class="memitem:a4937c776ae795edfe27824821a0d14a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a4937c776ae795edfe27824821a0d14a5">DefCopyAndDeepCopy</a> (PyClass *ppy_class)</td></tr>
<tr class="memdesc:a4937c776ae795edfe27824821a0d14a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds Pythonic <code>__copy__</code> and <code>__deepcopy__</code> using class's copy constructor.  <a href="#a4937c776ae795edfe27824821a0d14a5">More...</a><br /></td></tr>
<tr class="separator:a4937c776ae795edfe27824821a0d14a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48601ea388e9d2a662aff6f8b42dca4"><td class="memTemplParams" colspan="2">template&lt;typename PyClass &gt; </td></tr>
<tr class="memitem:ad48601ea388e9d2a662aff6f8b42dca4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#ad48601ea388e9d2a662aff6f8b42dca4">DefClone</a> (PyClass *ppy_class)</td></tr>
<tr class="memdesc:ad48601ea388e9d2a662aff6f8b42dca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds Pythonic <code>__copy__</code> and <code>__deepcopy__</code> for a class, as well as <code>Clone</code> method, using class's <code>Clone</code> method rather than the copy constructor.  <a href="#ad48601ea388e9d2a662aff6f8b42dca4">More...</a><br /></td></tr>
<tr class="separator:ad48601ea388e9d2a662aff6f8b42dca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82c192e2b875f6bd19163b69ba9075a"><td class="memTemplParams" colspan="2">template&lt;typename Class &gt; </td></tr>
<tr class="memitem:ad82c192e2b875f6bd19163b69ba9075a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#ad82c192e2b875f6bd19163b69ba9075a">ParamInit</a> ()</td></tr>
<tr class="memdesc:ad82c192e2b875f6bd19163b69ba9075a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constructor for creating an instance of Class and initializing parameters (bound using <code>def_readwrite</code>).  <a href="#ad82c192e2b875f6bd19163b69ba9075a">More...</a><br /></td></tr>
<tr class="separator:ad82c192e2b875f6bd19163b69ba9075a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cec9d64f8d0017db630acd8740021e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#aa8cec9d64f8d0017db630acd8740021e">ExecuteExtraPythonCode</a> (py::module m, bool use_subdir=false)</td></tr>
<tr class="memdesc:aa8cec9d64f8d0017db630acd8740021e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Python code to introduce additional symbols for a given module.  <a href="#aa8cec9d64f8d0017db630acd8740021e">More...</a><br /></td></tr>
<tr class="separator:aa8cec9d64f8d0017db630acd8740021e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303d4b3541bf8120fd6cabfdb40a61ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a303d4b3541bf8120fd6cabfdb40a61ef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a303d4b3541bf8120fd6cabfdb40a61ef">make_unowned_shared_ptr_from_raw</a> (T *raw)</td></tr>
<tr class="memdesc:a303d4b3541bf8120fd6cabfdb40a61ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a raw pointer, returns a shared_ptr wrapper around it that doesn't own anything &ndash; it's managed object is null, so there is no reference counting.  <a href="#a303d4b3541bf8120fd6cabfdb40a61ef">More...</a><br /></td></tr>
<tr class="separator:a303d4b3541bf8120fd6cabfdb40a61ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b3fef8297fa00d68181a77b7da0d40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#ae4b3fef8297fa00d68181a77b7da0d40">DefineFrameworkPySemantics</a> (py::module m)</td></tr>
<tr class="separator:ae4b3fef8297fa00d68181a77b7da0d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69d9dd260ccb0152ebf2da94f03b0c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#ae69d9dd260ccb0152ebf2da94f03b0c1">DefineFrameworkDiagramBuilder</a> (py::module m)</td></tr>
<tr class="separator:ae69d9dd260ccb0152ebf2da94f03b0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54960a906da6ad2f3b2509a4fd266f5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a54960a906da6ad2f3b2509a4fd266f5b">DefineFrameworkPySystems</a> (py::module m)</td></tr>
<tr class="separator:a54960a906da6ad2f3b2509a4fd266f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae073851bc679a64d47dc27c133b8d89d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#ae073851bc679a64d47dc27c133b8d89d">DefineFrameworkPyValues</a> (py::module m)</td></tr>
<tr class="separator:ae073851bc679a64d47dc27c133b8d89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb2b7de1072472c16fa5fa5bf27486d"><td class="memItemLeft" align="right" valign="top">std::function&lt; std::unique_ptr&lt; <a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a> &gt;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a8bb2b7de1072472c16fa5fa5bf27486d">MakeCppCompatibleAllocateCallback</a> (py::function allocate)</td></tr>
<tr class="separator:a8bb2b7de1072472c16fa5fa5bf27486d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Handling special non-POD scalar types.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Because we use dtype=object in NumPy, we cannot alias (share references to) the data underlying matrix objects when passing data between NumPy and Eigen (see #8116).</p>
<p>The simple policy these functions help enforce:</p>
<ul>
<li>When T is double, allow referencing (do not require copying).</li>
<li>When T is not double (i.e., AutoDiffXd, Expression), copy data (do not reference the data). </li>
</ul>
</div></td></tr>
<tr class="memitem:ad65f25e300d8d606958b3df57c29f5fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad65f25e300d8d606958b3df57c29f5fe"><td class="memTemplItemLeft" align="right" valign="top">py::return_value_policy&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#ad65f25e300d8d606958b3df57c29f5fe">return_value_policy_for_scalar_type</a> ()</td></tr>
<tr class="memdesc:ad65f25e300d8d606958b3df57c29f5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permits referencing for builtin dtypes (e.g., T == double), but then switches to copying for custom dtypes (T ∈ {AutoDiffXd, Expression}).  <a href="#ad65f25e300d8d606958b3df57c29f5fe">More...</a><br /></td></tr>
<tr class="separator:ad65f25e300d8d606958b3df57c29f5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3b7387557e1dd66533247e34770031"><td class="memTemplParams" colspan="2">template&lt;typename SomeBlock &gt; </td></tr>
<tr class="memitem:a8a3b7387557e1dd66533247e34770031"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a8a3b7387557e1dd66533247e34770031">CopyIfNotPodType</a> (const SomeBlock &amp;<a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>)</td></tr>
<tr class="memdesc:a8a3b7387557e1dd66533247e34770031"><td class="mdescLeft">&#160;</td><td class="mdescRight">A no-op for builtin dtypes (e.g., T == double), but then switches to copying for custom dtypes (T ∈ {AutoDiffXd, Expression}).  <a href="#a8a3b7387557e1dd66533247e34770031">More...</a><br /></td></tr>
<tr class="separator:a8a3b7387557e1dd66533247e34770031"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3001fa4c52ff2d0f13a58523f67be8e0"><td class="memTemplParams" colspan="2">template&lt;typename Return , typename... Args&gt; </td></tr>
<tr class="memitem:a3001fa4c52ff2d0f13a58523f67be8e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a3001fa4c52ff2d0f13a58523f67be8e0">overload_cast_explicit</a> = <a class="el" href="structdrake_1_1pydrake_1_1overload__cast__impl.html">overload_cast_impl</a>&lt;Return, Args...&gt;{}</td></tr>
<tr class="memdesc:a3001fa4c52ff2d0f13a58523f67be8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides option to provide explicit signature when <code>py::overload_cast&lt;Args...&gt;</code> fails to infer the Return argument.  <a href="#a3001fa4c52ff2d0f13a58523f67be8e0">More...</a><br /></td></tr>
<tr class="separator:a3001fa4c52ff2d0f13a58523f67be8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d91f25ffb0fba3520dc159dd45b41d1"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(const <a class="el" href="classdrake_1_1systems_1_1_context_base.html">systems::ContextBase</a> &amp;, <a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a0d91f25ffb0fba3520dc159dd45b41d1">MakeCppCompatibleCalcCallback</a> (std::function&lt; void(py::object, py::object)&gt; calc)</td></tr>
<tr class="separator:a0d91f25ffb0fba3520dc159dd45b41d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a52292ed585da63084b8914356a744d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52292ed585da63084b8914356a744d04">&#9670;&nbsp;</a></span>CommonScalarPack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1pydrake.html#a52292ed585da63084b8914356a744d04">CommonScalarPack</a> =  <a class="el" href="structdrake_1_1type__pack.html">type_pack</a>&lt; <a class="el" href="classdouble.html">double</a>, <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a>, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type pack defining common scalar types. </p>

</div>
</div>
<a id="aa69fa97ca5615e75170ca0274e32cba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69fa97ca5615e75170ca0274e32cba2">&#9670;&nbsp;</a></span>NonSymbolicScalarPack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1pydrake.html#aa69fa97ca5615e75170ca0274e32cba2">NonSymbolicScalarPack</a> =  <a class="el" href="structdrake_1_1type__pack.html">type_pack</a>&lt; <a class="el" href="classdouble.html">double</a>, <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type pack for non-symbolic common scalar types. </p>

</div>
</div>
<a id="a6e587c4c8d044dd6eee74dad65c203ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e587c4c8d044dd6eee74dad65c203ed">&#9670;&nbsp;</a></span>py_rvp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1pydrake.html#a6e587c4c8d044dd6eee74dad65c203ed">py_rvp</a> =  py::return_value_policy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shortened alias for py::return_value_policy. </p>
<p>For more information, see the <a class="el" href="group__python__bindings.html#PydrakeReturnValuePolicy">Return Value Policy</a> section. </p>

</div>
</div>
<a id="aab0999cb00e07db1ec4109413a82b6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0999cb00e07db1ec4109413a82b6f4">&#9670;&nbsp;</a></span>wrap_arg_function</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1pydrake.html#aab0999cb00e07db1ec4109413a82b6f4">wrap_arg_function</a> =  typename internal::wrap_function_impl&lt; wrap_arg_policy&gt;::template wrap_arg&lt;std::function&lt;Signature&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Policy for explicitly wrapping functions for a given policy. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a85dae944dd94ece7b256c9c46215268d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85dae944dd94ece7b256c9c46215268d">&#9670;&nbsp;</a></span>AddTemplateClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">py::object drake::pydrake::AddTemplateClass </td>
          <td>(</td>
          <td class="paramtype">py::handle&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>template_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">py::handle&#160;</td>
          <td class="paramname"><em>py_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">py::tuple&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_rename</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a template class instantiation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope</td><td>Parent scope of the template. </td></tr>
    <tr><td class="paramname">template_name</td><td>Name of the template. </td></tr>
    <tr><td class="paramname">py_class</td><td>Class instantiation to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The class name should be <em>unique</em>. If you would like automatic unique names, consider constructing the class binding as <code>py::class_&lt;Class, ...&gt;(m, TemporaryClassName&lt;Class&gt;().c_str())</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Parameters for the instantiation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a590ec0531f7c675e373909bb758740db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590ec0531f7c675e373909bb758740db">&#9670;&nbsp;</a></span>AddTemplateFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">py::object drake::pydrake::AddTemplateFunction </td>
          <td>(</td>
          <td class="paramtype">py::handle&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">py::tuple&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extra &amp;&amp;...&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares a template function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope</td><td>Parent scope of the template. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the template. </td></tr>
    <tr><td class="paramname">func</td><td>Function to be added. </td></tr>
    <tr><td class="paramname">param</td><td>Parameters for the instantiation. </td></tr>
    <tr><td class="paramname">extra</td><td>Additional arguments to pass to <code>py::cpp_function</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ab5a60c764576412e9362aaf18cad93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab5a60c764576412e9362aaf18cad93">&#9670;&nbsp;</a></span>AddTemplateMethod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">py::object drake::pydrake::AddTemplateMethod </td>
          <td>(</td>
          <td class="paramtype">py::handle&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Method &amp;&amp;&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">py::tuple&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extra &amp;&amp;...&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares a template method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope</td><td>Parent scope of the template. This should be a class. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the template. </td></tr>
    <tr><td class="paramname">method</td><td>Method to be added. </td></tr>
    <tr><td class="paramname">param</td><td>Parameters for the instantiation. </td></tr>
    <tr><td class="paramname">extra</td><td>Additional arguments to pass to <code>py::cpp_function</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a210546c12706075cdd90f811470ac4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210546c12706075cdd90f811470ac4b0">&#9670;&nbsp;</a></span>AddValueInstantiation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">py::class_&lt;Class, <a class="el" href="classdrake_1_1_abstract_value.html">drake::AbstractValue</a>&gt; drake::pydrake::AddValueInstantiation </td>
          <td>(</td>
          <td class="paramtype">py::module&#160;</td>
          <td class="paramname"><em>scope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines an instantiation of <code>pydrake.common.value.Value[...]</code>. </p>
<p>This is only meant to bind <code><a class="el" href="classdrake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">Value</a>&lt;T&gt;</code> (or specializations thereof). @prereq <code>T</code> must have already been exposed to <code>pybind11</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope</td><td>Parent scope. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Inner parameter of <code><a class="el" href="classdrake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">Value</a>&lt;T&gt;</code>. </td></tr>
    <tr><td class="paramname">Class</td><td>Class to be bound. By default, <code><a class="el" href="classdrake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">Value</a>&lt;T&gt;</code> is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the registered Python type. </dd></dl>

</div>
</div>
<a id="a3791768bef1f65b7d83bcd7767e0b307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3791768bef1f65b7d83bcd7767e0b307">&#9670;&nbsp;</a></span>BindIdentifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::BindIdentifier </td>
          <td>(</td>
          <td class="paramtype">ModuleOrClass&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id_doc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds an <a class="el" href="classdrake_1_1_identifier.html" title="A simple identifier class.">Identifier</a> instantiation. </p>

</div>
</div>
<a id="a236143263d0a18d6ec439f707140d7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236143263d0a18d6ec439f707140d7e1">&#9670;&nbsp;</a></span>BindTypeSafeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::pydrake::BindTypeSafeIndex </td>
          <td>(</td>
          <td class="paramtype">py::module&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>class_doc</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds a <a class="el" href="classdrake_1_1_type_safe_index.html" title="A type-safe non-negative index class.">TypeSafeIndex</a> instantiation along with its <a class="el" href="classdrake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">Value</a>[Class] type-erasure wrapper. </p>

</div>
</div>
<a id="a3d712eb0a12e5f78078993172f842dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d712eb0a12e5f78078993172f842dfe">&#9670;&nbsp;</a></span>CloneConvexSets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">geometry::optimization::ConvexSets</a> drake::pydrake::CloneConvexSets </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">geometry::optimization::ConvexSet</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>sets_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deep-copies the ConvexSet pointers in the given list into the C++-compatible object ConvexSets (which uses <a class="el" href="classdrake_1_1copyable__unique__ptr.html" title="A smart pointer with deep copy semantics.">copyable_unique_ptr</a> ownership). </p>
<p>This is useful to accept Python-natural function arguments (list of pointers) and then call the C++ API that requires a more complicated type. </p>

</div>
</div>
<a id="a8a3b7387557e1dd66533247e34770031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3b7387557e1dd66533247e34770031">&#9670;&nbsp;</a></span>CopyIfNotPodType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) drake::pydrake::CopyIfNotPodType </td>
          <td>(</td>
          <td class="paramtype">const SomeBlock &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A no-op for builtin dtypes (e.g., T == double), but then switches to copying for custom dtypes (T ∈ {AutoDiffXd, Expression}). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SomeBlock</td><td>an Eigen::Block or Eigen::VectorBlock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b3e8f87bda821cd1fa9a52586e25f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3e8f87bda821cd1fa9a52586e25f1e">&#9670;&nbsp;</a></span>DefAttributesUsingSerialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefAttributesUsingSerialize </td>
          <td>(</td>
          <td class="paramtype">PyClass *&#160;</td>
          <td class="paramname"><em>ppy_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Docs &amp;&#160;</td>
          <td class="paramname"><em>cls_docs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the attributes visited by a C++ class Serialize function as readwrite on properties its ppy_class. </p>
<p>This function only works for classes with a trivial Serialize function that uses DRAKE_NVP on each of its member fields; Serialize functions that use DRAKE_NVP on temporary stack variables are not supported. The class also must be default-constructible. </p>

</div>
</div>
<a id="a68be3d37cf9d6c6fcc2afb98d04c046f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68be3d37cf9d6c6fcc2afb98d04c046f">&#9670;&nbsp;</a></span>DefAttributesUsingSerialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefAttributesUsingSerialize </td>
          <td>(</td>
          <td class="paramtype">PyClass *&#160;</td>
          <td class="paramname"><em>ppy_class</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) An overload that doesn't bind docstrings. </p>
<p>We expect that pydrake bindings should always pass a Docs class (i.e., use the other overload), in some cases (especially downstream projects) that might not be possible. </p>

</div>
</div>
<a id="a6294e82ee237c93a7e6cbc2fb4d924b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6294e82ee237c93a7e6cbc2fb4d924b2">&#9670;&nbsp;</a></span>DefCast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefCast </td>
          <td>(</td>
          <td class="paramtype">PyClass *&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UPack&#160;</td>
          <td class="paramname"><em>U_pack</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds <code>cast&lt;T&gt;()</code> explicitly. </p>

</div>
</div>
<a id="ad48601ea388e9d2a662aff6f8b42dca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48601ea388e9d2a662aff6f8b42dca4">&#9670;&nbsp;</a></span>DefClone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefClone </td>
          <td>(</td>
          <td class="paramtype">PyClass *&#160;</td>
          <td class="paramname"><em>ppy_class</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds Pythonic <code>__copy__</code> and <code>__deepcopy__</code> for a class, as well as <code>Clone</code> method, using class's <code>Clone</code> method rather than the copy constructor. </p>

</div>
</div>
<a id="a4937c776ae795edfe27824821a0d14a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4937c776ae795edfe27824821a0d14a5">&#9670;&nbsp;</a></span>DefCopyAndDeepCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefCopyAndDeepCopy </td>
          <td>(</td>
          <td class="paramtype">PyClass *&#160;</td>
          <td class="paramname"><em>ppy_class</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds Pythonic <code>__copy__</code> and <code>__deepcopy__</code> using class's copy constructor. </p>
<dl class="section note"><dt>Note</dt><dd>Do not use this if the class's copy constructor does not imply a deep copy. </dd></dl>

</div>
</div>
<a id="ae69d9dd260ccb0152ebf2da94f03b0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69d9dd260ccb0152ebf2da94f03b0c1">&#9670;&nbsp;</a></span>DefineFrameworkDiagramBuilder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefineFrameworkDiagramBuilder </td>
          <td>(</td>
          <td class="paramtype">py::module&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4b3fef8297fa00d68181a77b7da0d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b3fef8297fa00d68181a77b7da0d40">&#9670;&nbsp;</a></span>DefineFrameworkPySemantics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefineFrameworkPySemantics </td>
          <td>(</td>
          <td class="paramtype">py::module&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54960a906da6ad2f3b2509a4fd266f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54960a906da6ad2f3b2509a4fd266f5b">&#9670;&nbsp;</a></span>DefineFrameworkPySystems()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefineFrameworkPySystems </td>
          <td>(</td>
          <td class="paramtype">py::module&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae073851bc679a64d47dc27c133b8d89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae073851bc679a64d47dc27c133b8d89d">&#9670;&nbsp;</a></span>DefineFrameworkPyValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefineFrameworkPyValues </td>
          <td>(</td>
          <td class="paramtype">py::module&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7429d58f69452750233eb29092d6e679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7429d58f69452750233eb29092d6e679">&#9670;&nbsp;</a></span>DefineGeometryCommon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefineGeometryCommon </td>
          <td>(</td>
          <td class="paramtype">py::module&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the common elements in the <a class="el" href="namespacedrake_1_1geometry.html">drake::geometry</a> namespace. </p>
<p>See geometry_py_common.cc. </p>

</div>
</div>
<a id="aeeb190e42e2f696d5ed3f8d319db6459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb190e42e2f696d5ed3f8d319db6459">&#9670;&nbsp;</a></span>DefineGeometryHydro()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefineGeometryHydro </td>
          <td>(</td>
          <td class="paramtype">py::module&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines all of the hydroelastic-specific entities. </p>
<p>See geometry_py_hydro.cc </p>

</div>
</div>
<a id="a486ee6b32b3daf0b9c433f6a4242174e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486ee6b32b3daf0b9c433f6a4242174e">&#9670;&nbsp;</a></span>DefineGeometryMeshes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefineGeometryMeshes </td>
          <td>(</td>
          <td class="paramtype">py::module&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the basic mesh types (and some parsing operations) on those types. </p>
<p>See geometry_py_meshes.cc. </p>

</div>
</div>
<a id="a1e2a66cb1a4fec05d8ec8f5d2dd7b6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2a66cb1a4fec05d8ec8f5d2dd7b6de">&#9670;&nbsp;</a></span>DefineGeometryOptimization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefineGeometryOptimization </td>
          <td>(</td>
          <td class="paramtype">py::module&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines all elements in the <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html">drake::geometry::optimization</a> namespace. </p>
<p>See geometry_py_optimization.cc. </p>

</div>
</div>
<a id="ad3fdf83dabca18e8bee66c72ce462fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3fdf83dabca18e8bee66c72ce462fdc">&#9670;&nbsp;</a></span>DefineGeometryRender()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefineGeometryRender </td>
          <td>(</td>
          <td class="paramtype">py::module&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the public API of the drake/geometry/render and drake/geometry/render_* directories. </p>
<p>See geometry_py_render.cc. </p>

</div>
</div>
<a id="a1e766f9fb38d0bcd69a4d11f7fc2efb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e766f9fb38d0bcd69a4d11f7fc2efb3">&#9670;&nbsp;</a></span>DefineGeometrySceneGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefineGeometrySceneGraph </td>
          <td>(</td>
          <td class="paramtype">py::module&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds SceneGraph and its query-related classes. </p>
<p>See geometry_py_scene_graph.cc. </p>

</div>
</div>
<a id="af1dd02f74528f84556c55239d82ab9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1dd02f74528f84556c55239d82ab9b3">&#9670;&nbsp;</a></span>DefineGeometryVisualizers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefineGeometryVisualizers </td>
          <td>(</td>
          <td class="paramtype">py::module&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the visualizers in <a class="el" href="namespacedrake_1_1geometry.html">drake::geometry</a>. </p>
<p>See geometry_py_visualizers.cc. </p>

</div>
</div>
<a id="abe5aba035d48c052690fe1d1b4a3f414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5aba035d48c052690fe1d1b4a3f414">&#9670;&nbsp;</a></span>DefineTemplateClassWithDefault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">py::class_&lt;Class, Options...&gt; drake::pydrake::DefineTemplateClassWithDefault </td>
          <td>(</td>
          <td class="paramtype">py::handle&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>default_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">py::tuple&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>doc_string</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>template_suffix</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; py::dynamic_attr &gt;&#160;</td>
          <td class="paramname"><em>dynamic_attr</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a convenience wrapper for defining a template class instantiation and a default instantiation (if not already defined). </p>
<p>The default instantiation is named <code>default_name</code>, while the template is named <code>default_name + template_suffix</code>. The <code>template_suffix</code> defaults to "_" when not provided. The caller may opt-in to py::dynamic_attr() as the last argument. </p><dl class="section return"><dt>Returns</dt><dd>pybind11 class </dd></dl>

</div>
</div>
<a id="a3a22cfe187c4d2e58dacdc4fddf69843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a22cfe187c4d2e58dacdc4fddf69843">&#9670;&nbsp;</a></span>DefReadUniquePtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefReadUniquePtr </td>
          <td>(</td>
          <td class="paramtype">PyClass *&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; T &gt; Class::*&#160;</td>
          <td class="paramname"><em>member</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>doc</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Idempotent to pybind11's <code>def_readonly()</code>, which works for unique_ptr elements; the getter is protected with keep_alive on a <code>member</code> variable that is a unique_ptr. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PyClass</td><td>the python class. </td></tr>
    <tr><td class="paramname">Class</td><td>the C++ class. </td></tr>
    <tr><td class="paramname">T</td><td>type for the member we wish to apply keep alive semantics. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50864a5d92c08bf74cf16b6d004aaa6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50864a5d92c08bf74cf16b6d004aaa6a">&#9670;&nbsp;</a></span>DefReadUniquePtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefReadUniquePtr </td>
          <td>(</td>
          <td class="paramtype">PyClass *&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; T &gt; Class::*&#160;</td>
          <td class="paramname"><em>member</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>doc</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03d8c49a4502029d0167c2aa50f4b624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d8c49a4502029d0167c2aa50f4b624">&#9670;&nbsp;</a></span>DefReadWriteKeepAlive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefReadWriteKeepAlive </td>
          <td>(</td>
          <td class="paramtype">PyClass *&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T Class::*&#160;</td>
          <td class="paramname"><em>member</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>doc</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Idempotent to pybind11's <code>def_readwrite()</code>, with the exception that the setter is protected with keep_alive on a <code>member</code> variable that is a bare pointer. </p>
<p>Should not be used for unique_ptr members.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PyClass</td><td>the python class. </td></tr>
    <tr><td class="paramname">Class</td><td>the C++ class. </td></tr>
    <tr><td class="paramname">T</td><td>type for the member we wish to apply keep alive semantics. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9814a507ba70a62d61b467c3ba06cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9814a507ba70a62d61b467c3ba06cce">&#9670;&nbsp;</a></span>DefReprUsingSerialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefReprUsingSerialize </td>
          <td>(</td>
          <td class="paramtype">PyClass *&#160;</td>
          <td class="paramname"><em>ppy_class</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds <b>repr</b> using a C++ class Serialize function. </p>
<p>The class must be default-constructible. </p>

</div>
</div>
<a id="ab0b68ce63cf178e7d4e91f95e0e483e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b68ce63cf178e7d4e91f95e0e483e1">&#9670;&nbsp;</a></span>DeprecateAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DeprecateAttribute </td>
          <td>(</td>
          <td class="paramtype">py::object&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">py::str&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">py::str&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>date</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecates an attribute <code>name</code> of a class <code>cls</code>. </p>
<p>This <em>only</em> works with class attributes (unbound members or methods) as it is implemented with a Python property descriptor. </p>

</div>
</div>
<a id="a0ccf8095ae346728e479e818bef071ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccf8095ae346728e479e818bef071ec">&#9670;&nbsp;</a></span>DeprecatedParamInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::pydrake::DeprecatedParamInit </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The deprecated flavor of ParamInit&lt;&gt;. </p>

</div>
</div>
<a id="aa8cec9d64f8d0017db630acd8740021e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cec9d64f8d0017db630acd8740021e">&#9670;&nbsp;</a></span>ExecuteExtraPythonCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::ExecuteExtraPythonCode </td>
          <td>(</td>
          <td class="paramtype">py::module&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_subdir</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Python code to introduce additional symbols for a given module. </p>
<p>For a module with local name <code>{name}</code> and use_subdir=False, the code executed will be <code>_{name}_extra.py</code>; with use_subdir=True, it will be <code>{name}/_{name}_extra.py</code>. See #9599 for relevant background. </p>

</div>
</div>
<a id="a2274d953c5404b3021085ef6c9891603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2274d953c5404b3021085ef6c9891603">&#9670;&nbsp;</a></span>GetPyParam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">py::tuple drake::pydrake::GetPyParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdrake_1_1type__pack.html">type_pack</a>&lt; Ts... &gt;&#160;</td>
          <td class="paramname"> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the canonical Python parameters for each C++ type. </p>
<dl class="section return"><dt>Returns</dt><dd>Python tuple of canonical parameters. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>on the first type it encounters that is neither aliased nor registered in <code>pybind11</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>The types to get C++ types for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Ts must be public symbols. </dd>
<dd>
Ts cannot be a <code>py::</code> symbol (e.g. <code>py::object</code>). On Mac, this may cause failure depending on import order (e.g. trying to use <code><a class="el" href="classdrake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">Value</a>&lt;py::object&gt;</code> between different modules). See #8704 and #13207 for more details. </dd></dl>

</div>
</div>
<a id="a303d4b3541bf8120fd6cabfdb40a61ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303d4b3541bf8120fd6cabfdb40a61ef">&#9670;&nbsp;</a></span>make_unowned_shared_ptr_from_raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::pydrake::make_unowned_shared_ptr_from_raw </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>raw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a raw pointer, returns a shared_ptr wrapper around it that doesn't own anything &ndash; it's managed object is null, so there is no reference counting. </p>
<p>Calling get() on the result will return <code>raw</code>. </p>

</div>
</div>
<a id="a8bb2b7de1072472c16fa5fa5bf27486d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb2b7de1072472c16fa5fa5bf27486d">&#9670;&nbsp;</a></span>MakeCppCompatibleAllocateCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;std::unique_ptr&lt;<a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a>&gt;)&gt; drake::pydrake::MakeCppCompatibleAllocateCallback </td>
          <td>(</td>
          <td class="paramtype">py::function&#160;</td>
          <td class="paramname"><em>allocate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad82c192e2b875f6bd19163b69ba9075a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82c192e2b875f6bd19163b69ba9075a">&#9670;&nbsp;</a></span>ParamInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::pydrake::ParamInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constructor for creating an instance of Class and initializing parameters (bound using <code>def_readwrite</code>). </p>
<p>This provides an alternative to manually enumerating each parameter as an argument using <code>py::init&lt;...&gt;</code> and <code>py::arg(...)</code>, and is useful when the C++ class only has a default constructor. Example: </p><div class="fragment"><div class="line"><span class="keyword">using</span> Class = ExampleClass;</div><div class="line">py::class_&lt;Class&gt;(m, <span class="stringliteral">&quot;ExampleClass&quot;</span>)  <span class="comment">// BR</span></div><div class="line">    .def(ParamInit&lt;Class&gt;());</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Class</td><td>The C++ class. Must have a default constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b2b2fc77486a9fc30dcbb117eae3bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2b2fc77486a9fc30dcbb117eae3bb1">&#9670;&nbsp;</a></span>py_init_deprecated() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::pydrake::py_init_deprecated </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated wrapping of <code>py::init&lt;&gt;</code>. </p>
<dl class="section note"><dt>Note</dt><dd>Only for <code>unique_ptr</code> holders. If using <code>shared_ptr</code>, talk to Eric. </dd></dl>

</div>
</div>
<a id="a7ca9238e1190c7ed4a407230858368cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca9238e1190c7ed4a407230858368cc">&#9670;&nbsp;</a></span>py_init_deprecated() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::pydrake::py_init_deprecated </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated wrapping of <code>py::init(factory)</code>. </p>

</div>
</div>
<a id="ad65f25e300d8d606958b3df57c29f5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65f25e300d8d606958b3df57c29f5fe">&#9670;&nbsp;</a></span>return_value_policy_for_scalar_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">py::return_value_policy drake::pydrake::return_value_policy_for_scalar_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permits referencing for builtin dtypes (e.g., T == double), but then switches to copying for custom dtypes (T ∈ {AutoDiffXd, Expression}). </p>

</div>
</div>
<a id="a4790743839a4b041b37dc3820e2475ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4790743839a4b041b37dc3820e2475ae">&#9670;&nbsp;</a></span>TemporaryClassName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string drake::pydrake::TemporaryClassName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;TemporaryName&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a temporary, unique name for a class instantiation that will be passed to <code>AddTemplateClass</code>. </p>

</div>
</div>
<a id="a875e25ecdc84790945435e9538a6ef60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a875e25ecdc84790945435e9538a6ef60">&#9670;&nbsp;</a></span>ToArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">py::object drake::pydrake::ToArray </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">py::tuple&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">py::return_value_policy&#160;</td>
          <td class="paramname"><em>policy</em> = <code>py_rvp::reference</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">py::handle&#160;</td>
          <td class="paramname"><em>parent</em> = <code>py::handle()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a raw array to a numpy array. </p>

</div>
</div>
<a id="ab9047f00f873c1cd6f00d0665365ecf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9047f00f873c1cd6f00d0665365ecf5">&#9670;&nbsp;</a></span>ToArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">py::object drake::pydrake::ToArray </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">py::tuple&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">py::return_value_policy&#160;</td>
          <td class="paramname"><em>policy</em> = <code>py_rvp::reference</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">py::handle&#160;</td>
          <td class="paramname"><em>parent</em> = <code>py::handle()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a raw array to a numpy array (<code>const</code> variant). </p>

</div>
</div>
<a id="a0d7582877591057ceea633df19d910fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7582877591057ceea633df19d910fa">&#9670;&nbsp;</a></span>ToEigenRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::pydrake::ToEigenRef </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorBlock&lt; Derived &gt; *&#160;</td>
          <td class="paramname"><em>derived</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a mutable Ref&lt;&gt; for a pointer. </p>
<p>Meant to be used for decorating methods passed to <code>pybind11</code> (e.g. virtual function dispatch). </p>

</div>
</div>
<a id="ad64efa5d584964d8c233e48c107eae84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64efa5d584964d8c233e48c107eae84">&#9670;&nbsp;</a></span>WarnDeprecated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::WarnDeprecated </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>date</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raises a deprecation warning. </p>
<dl class="section note"><dt>Note</dt><dd>If you are deprecating a class's member or method, please use <code>DeprecateAttribute</code> so that the warning is issued immediately when accessed, not only when it is called. </dd></dl>

</div>
</div>
<a id="a455a0f794f758f800bce946f37c6be29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455a0f794f758f800bce946f37c6be29">&#9670;&nbsp;</a></span>WrapCallbacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::pydrake::WrapCallbacks </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensures that any <code>std::function&lt;&gt;</code> arguments are wrapped such that any <code>T&amp;</code> (which can infer for <code>T = const U</code>) is wrapped as <code>U*</code> (and conversely unwrapped when returned). </p>
<p>Use this when you have a callback in C++ that has a lvalue reference (const or mutable) to a C++ argument or return value. Otherwise, <code>pybind11</code> may try and copy the object, will be bad if either the type is a non-copyable or if you are trying to mutate the object; in this case, the copy is mutated, but not the original you care about. For more information, see: <a href="https://github.com/pybind/pybind11/issues/1241">https://github.com/pybind/pybind11/issues/1241</a> </p>

</div>
</div>
<a id="ab4b9050ef1d00002327354d9b24272c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b9050ef1d00002327354d9b24272c8">&#9670;&nbsp;</a></span>WrapDeprecated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::pydrake::WrapDeprecated </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps any callable (function pointer, method pointer, lambda, etc.) to emit a deprecation message. </p>

</div>
</div>
<a id="a52b03ea674322481f48a1262e0c607a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b03ea674322481f48a1262e0c607a2">&#9670;&nbsp;</a></span>WrapFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::pydrake::WrapFunction </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps the types used in a function signature to produce a new function with wrapped arguments and return value (if non-void). </p>
<p>The wrapping is based on <code>wrap_arg_policy</code>. Any types that are of the form <code>std::function&lt;F&gt;</code> will be recursively wrapped, such that callbacks will be of a wrapped form (arguments and return types wrapped). The original form of the callbacks will still be called in the wrapped callback. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">wrap_arg_policy</td><td>User-supplied argument wrapper, that must supply the static functions <code>wrap(Arg arg) -&gt; Wrapped</code> and <code>unwrap(Wrapped wrapped) -&gt; Arg</code>. <code>Arg arg</code> is the original argument, and <code>Wrapped wrapped</code> is the wrapped / transformed argument type. N.B. This template template parameter uses a parameter pack to allow for SFINAE. If passing a <code>using</code> template alias, ensure that the alias template template parameter uses a parameter pack of the <em>exact</em> same form. </td></tr>
    <tr><td class="paramname">use_functions</td><td>If true (default), will recursively wrap callbacks. If your policy provides handling for functions, then you should set this to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Functor to be wrapped. Returns a function with wrapped arguments and return type. If functor is a method pointer, it will return a function of the form <code>Return ([const] Class* self, ...)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Wrapped function lambda. N.B. Construct a <code>std::function&lt;&gt;</code> from this if you encounter inference issues downstream of this method. </dd></dl>

</div>
</div>
<a id="af5f81d7315477aaa1694d9aa02a1346b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f81d7315477aaa1694d9aa02a1346b">&#9670;&nbsp;</a></span>WrapToMatchInputShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">py::object drake::pydrake::WrapToMatchInputShape </td>
          <td>(</td>
          <td class="paramtype">py::handle&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps a overload instance method to reshape the output to be the same as a given input argument. </p>
<p>The input should be the first and only argument to trigger reshaping.</p>
<p>This preserves the original docstrings so that they still indicate the shapes of the input and output arrays.</p>
<p>Example:</p>
<div class="fragment"><div class="line">cls  <span class="comment">// BR</span></div><div class="line">  .def(<span class="stringliteral">&quot;multiply&quot;</span>, [](<span class="keyword">const</span> Class&amp; <span class="keyword">self</span>, <span class="keyword">const</span> Class&amp; other) { ... })</div><div class="line">  .def(<span class="stringliteral">&quot;multiply&quot;</span>, [](<span class="keyword">const</span> Class&amp; <span class="keyword">self</span>, <span class="keyword">const</span> Vector3&lt;T&gt;&amp; p) { ... })</div><div class="line">  .def(<span class="stringliteral">&quot;multiply&quot;</span>, [](<span class="keyword">const</span> Class&amp; <span class="keyword">self</span>, <span class="keyword">const</span> Matrix3X&lt;T&gt;&amp; plist) { ... });</div><div class="line">cls.attr(<span class="stringliteral">&quot;multiply&quot;</span>) = <a class="code" href="namespacedrake_1_1pydrake.html#af5f81d7315477aaa1694d9aa02a1346b">WrapToMatchInputShape</a>(cls.attr(<span class="stringliteral">&quot;multiply&quot;</span>));</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__python__bindings.html#PydrakeReturnVectorsOrMatrices">PydrakeReturnVectorsOrMatrices</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a0d91f25ffb0fba3520dc159dd45b41d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d91f25ffb0fba3520dc159dd45b41d1">&#9670;&nbsp;</a></span>MakeCppCompatibleCalcCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(const <a class="el" href="classdrake_1_1systems_1_1_context_base.html">systems::ContextBase</a>&amp;, <a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a>*)&gt; MakeCppCompatibleCalcCallback(std::function&lt; void(py::object, py::object)&gt; calc)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3001fa4c52ff2d0f13a58523f67be8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3001fa4c52ff2d0f13a58523f67be8e0">&#9670;&nbsp;</a></span>overload_cast_explicit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto overload_cast_explicit = <a class="el" href="structdrake_1_1pydrake_1_1overload__cast__impl.html">overload_cast_impl</a>&lt;Return, Args...&gt;{}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides option to provide explicit signature when <code>py::overload_cast&lt;Args...&gt;</code> fails to infer the Return argument. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1pydrake.html">pydrake</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().value = searchBox.searchLabel;
</script>
</body>
</html>
