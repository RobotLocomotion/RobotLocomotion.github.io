<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespacedrake.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">drake Namespace Reference<div class="ingroups"><a class="el" href="group__technical__notes.html">Technical Notes</a> &raquo; <a class="el" href="group__default__scalars.html">Default Scalars</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:ad" id="r_ad"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1ad.html">ad</a></td></tr>
<tr class="memitem:assert" id="r_assert"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1assert.html">assert</a></td></tr>
<tr class="memitem:common" id="r_common"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1common.html">common</a></td></tr>
<tr class="memitem:examples" id="r_examples"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1examples.html">examples</a></td></tr>
<tr class="memitem:geometry" id="r_geometry"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html">geometry</a></td></tr>
<tr class="memitem:lcm" id="r_lcm"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1lcm.html">lcm</a></td></tr>
<tr class="memitem:logging" id="r_logging"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1logging.html">logging</a></td></tr>
<tr class="memitem:manipulation" id="r_manipulation"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1manipulation.html">manipulation</a></td></tr>
<tr class="memitem:math" id="r_math"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1math.html">math</a></td></tr>
<tr class="memitem:multibody" id="r_multibody"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></td></tr>
<tr class="memitem:perception" id="r_perception"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1perception.html">perception</a></td></tr>
<tr class="memitem:planning" id="r_planning"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1planning.html">planning</a></td></tr>
<tr class="memitem:schema" id="r_schema"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1schema.html">schema</a></td></tr>
<tr class="memitem:solvers" id="r_solvers"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html">solvers</a></td></tr>
<tr class="memitem:symbolic" id="r_symbolic"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html">symbolic</a></td></tr>
<tr class="memitem:systems" id="r_systems"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1systems.html">systems</a></td></tr>
<tr class="memitem:trajectories" id="r_trajectories"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1trajectories.html">trajectories</a></td></tr>
<tr class="memitem:visualization" id="r_visualization"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1visualization.html">visualization</a></td></tr>
<tr class="memitem:yaml" id="r_yaml"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1yaml.html">yaml</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:AbstractValue" id="r_AbstractValue"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fully type-erased container class.  <a href="classdrake_1_1_abstract_value.html#details">More...</a><br /></td></tr>
<tr class="memitem:copyable_5Funique_5Fptr" id="r_copyable_5Funique_5Fptr"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A smart pointer with deep copy semantics.  <a href="classdrake_1_1copyable__unique__ptr.html#details">More...</a><br /></td></tr>
<tr class="memitem:DelegatingHasher" id="r_DelegatingHasher"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1_delegating_hasher.html">DelegatingHasher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adapter that forwards the HashAlgorithm::operator(data, length) function concept into a runtime-provided std::function of the same signature.  <a href="structdrake_1_1_delegating_hasher.html#details">More...</a><br /></td></tr>
<tr class="memitem:dummy_5Fvalue" id="r_dummy_5Fvalue"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1dummy__value.html">dummy_value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a "dummy" value for a ScalarType &ndash; a value that is unlikely to be mistaken for a purposefully-computed value, useful for initializing a value before the true result is available.  <a href="structdrake_1_1dummy__value.html#details">More...</a><br /></td></tr>
<tr class="memitem:dummy_5Fvalue_3C_20Eigen_3A_3AAutoDiffScalar_3C_20DerType_20_3E_20_3E" id="r_dummy_5Fvalue_3C_20Eigen_3A_3AAutoDiffScalar_3C_20DerType_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>dummy_value&lt; Eigen::AutoDiffScalar&lt; DerType &gt; &gt;</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes <a class="el" href="dummy__value_8h.html">common/dummy_value.h</a>. <br /></td></tr>
<tr class="memitem:dummy_5Fvalue_3C_20int_20_3E" id="r_dummy_5Fvalue_3C_20int_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1dummy__value_3_01int_01_4.html">dummy_value&lt; int &gt;</a></td></tr>
<tr class="memitem:dummy_5Fvalue_3C_20symbolic_3A_3AExpression_20_3E" id="r_dummy_5Fvalue_3C_20symbolic_3A_3AExpression_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1dummy__value_3_01symbolic_1_1_expression_01_4.html">dummy_value&lt; symbolic::Expression &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes <a class="el" href="dummy__value_8h.html">common/dummy_value.h</a>.  <a href="structdrake_1_1dummy__value_3_01symbolic_1_1_expression_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:EigenPtr" id="r_EigenPtr"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This wrapper class provides a way to write non-template functions taking raw pointers to Eigen objects as parameters while limiting the number of copies, similar to <span class="tt">Eigen::Ref</span>.  <a href="classdrake_1_1_eigen_ptr.html#details">More...</a><br /></td></tr>
<tr class="memitem:FindResourceResult" id="r_FindResourceResult"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_find_resource_result.html">FindResourceResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Models the outcome of <a class="el" href="#a6d12a9fa5bded2c0de25138421b0e1d7" title="(Advanced) Attempts to locate a Drake resource named by the given resource_path.">drake::FindResource</a>.  <a href="classdrake_1_1_find_resource_result.html#details">More...</a><br /></td></tr>
<tr class="memitem:Identifier" id="r_Identifier"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_identifier.html">Identifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple identifier class.  <a href="classdrake_1_1_identifier.html#details">More...</a><br /></td></tr>
<tr class="memitem:is_5Feigen_5Fnonvector_5Fexpression_5Fdouble_5Fpair" id="r_is_5Feigen_5Fnonvector_5Fexpression_5Fdouble_5Fpair"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1is__eigen__nonvector__expression__double__pair.html">is_eigen_nonvector_expression_double_pair</a></td></tr>
<tr class="memitem:is_5Feigen_5Fnonvector_5Fof" id="r_is_5Feigen_5Fnonvector_5Fof"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1is__eigen__nonvector__of.html">is_eigen_nonvector_of</a></td></tr>
<tr class="memitem:is_5Feigen_5Fscalar_5Fsame" id="r_is_5Feigen_5Fscalar_5Fsame"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a></td></tr>
<tr class="memitem:is_5Feigen_5Ftype" id="r_is_5Feigen_5Ftype"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1is__eigen__type.html">is_eigen_type</a></td></tr>
<tr class="memitem:is_5Feigen_5Fvector" id="r_is_5Feigen_5Fvector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1is__eigen__vector.html">is_eigen_vector</a></td></tr>
<tr class="memitem:is_5Feigen_5Fvector_5Fexpression_5Fdouble_5Fpair" id="r_is_5Feigen_5Fvector_5Fexpression_5Fdouble_5Fpair"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1is__eigen__vector__expression__double__pair.html">is_eigen_vector_expression_double_pair</a></td></tr>
<tr class="memitem:is_5Feigen_5Fvector_5Fof" id="r_is_5Feigen_5Fvector_5Fof"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a></td></tr>
<tr class="memitem:ManualTimer" id="r_ManualTimer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_manual_timer.html">ManualTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of timing for use with unit tests that control time manually.  <a href="classdrake_1_1_manual_timer.html#details">More...</a><br /></td></tr>
<tr class="memitem:MemoryFile" id="r_MemoryFile"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_memory_file.html">MemoryFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A virtual file, stored in memory.  <a href="classdrake_1_1_memory_file.html#details">More...</a><br /></td></tr>
<tr class="memitem:NameValue" id="r_NameValue"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_name_value.html">NameValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) A basic implementation of the Name-Value Pair concept as used in the Serialize / Archive pattern.  <a href="classdrake_1_1_name_value.html#details">More...</a><br /></td></tr>
<tr class="memitem:never_5Fdestroyed" id="r_never_5Fdestroyed"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1never__destroyed.html">never_destroyed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps an underlying type T such that its storage is a direct member field of this object (i.e., without any indirection into the heap), but <em>unlike</em> most member fields T's destructor is never invoked.  <a href="classdrake_1_1never__destroyed.html#details">More...</a><br /></td></tr>
<tr class="memitem:NiceTypeName" id="r_NiceTypeName"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_nice_type_name.html">NiceTypeName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains canonicalized, platform-independent, human-readable names for arbitrarily-complicated C++ types.  <a href="classdrake_1_1_nice_type_name.html#details">More...</a><br /></td></tr>
<tr class="memitem:ostream_5Fformatter" id="r_ostream_5Fformatter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1ostream__formatter.html">ostream_formatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">When using fmt &gt;= 9, this is an alias for fmt::ostream_formatter.  <a href="structdrake_1_1ostream__formatter.html#details">More...</a><br /></td></tr>
<tr class="memitem:Parallelism" id="r_Parallelism"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a desired degree of parallelism for a parallelized operation.  <a href="classdrake_1_1_parallelism.html#details">More...</a><br /></td></tr>
<tr class="memitem:Polynomial" id="r_Polynomial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scalar multi-variate polynomial, modeled after the msspoly in spotless.  <a href="classdrake_1_1_polynomial.html#details">More...</a><br /></td></tr>
<tr class="memitem:RandomGenerator" id="r_RandomGenerator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines Drake's canonical implementation of the UniformRandomBitGenerator C++ concept (as well as a few conventional extras beyond the concept, e.g., seeds).  <a href="classdrake_1_1_random_generator.html#details">More...</a><br /></td></tr>
<tr class="memitem:reset_5Fafter_5Fmove" id="r_reset_5Fafter_5Fmove"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1reset__after__move.html">reset_after_move</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type wrapper that performs value-initialization on the wrapped type, and guarantees that when moving from this type that the donor object is reset to its value-initialized value.  <a href="classdrake_1_1reset__after__move.html#details">More...</a><br /></td></tr>
<tr class="memitem:reset_5Fon_5Fcopy" id="r_reset_5Fon_5Fcopy"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1reset__on__copy.html">reset_on_copy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type wrapper that performs value-initialization on copy construction or assignment.  <a href="classdrake_1_1reset__on__copy.html#details">More...</a><br /></td></tr>
<tr class="memitem:RlocationOrError" id="r_RlocationOrError"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1_rlocation_or_error.html">RlocationOrError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced.) The return type of <a class="el" href="#ae7b592b35122cdfc472bd8bf9d35df7a" title="(Advanced.) Returns the absolute path to the given resource_path from Bazel runfiles,...">FindRunfile()</a>.  <a href="structdrake_1_1_rlocation_or_error.html#details">More...</a><br /></td></tr>
<tr class="memitem:scalar_5Fpredicate" id="r_scalar_5Fpredicate"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1scalar__predicate.html">scalar_predicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A traits struct that describes the return type of predicates over a scalar type (named <span class="tt">T</span>).  <a href="structdrake_1_1scalar__predicate.html#details">More...</a><br /></td></tr>
<tr class="memitem:ScopeExit" id="r_ScopeExit"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_scope_exit.html">ScopeExit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to create a scope exit guard &ndash; an object that when destroyed runs <span class="tt">func</span>.  <a href="classdrake_1_1_scope_exit.html#details">More...</a><br /></td></tr>
<tr class="memitem:Sha256" id="r_Sha256"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_sha256.html">Sha256</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a SHA-256 cryptographic checksum.  <a href="classdrake_1_1_sha256.html#details">More...</a><br /></td></tr>
<tr class="memitem:SortedPair" id="r_SortedPair"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is similar to the std::pair class.  <a href="structdrake_1_1_sorted_pair.html#details">More...</a><br /></td></tr>
<tr class="memitem:SteadyTimer" id="r_SteadyTimer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_steady_timer.html">SteadyTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of timing utility that uses monotonic std::chrono::steady_clock.  <a href="classdrake_1_1_steady_timer.html#details">More...</a><br /></td></tr>
<tr class="memitem:Timer" id="r_Timer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for timing utility.  <a href="classdrake_1_1_timer.html#details">More...</a><br /></td></tr>
<tr class="memitem:TypeSafeIndex" id="r_TypeSafeIndex"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-safe non-negative index class.  <a href="classdrake_1_1_type_safe_index.html#details">More...</a><br /></td></tr>
<tr class="memitem:uhash" id="r_uhash"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1uhash.html">uhash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hashing functor, somewhat like <span class="tt">std::hash</span>.  <a href="structdrake_1_1uhash.html#details">More...</a><br /></td></tr>
<tr class="memitem:Value" id="r_Value"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_value.html">Value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container class for an arbitrary type T (with some restrictions).  <a href="classdrake_1_1_value.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3d6302a0051e9403c9df3ed6808f3854" id="r_a3d6302a0051e9403c9df3ed6808f3854"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d6302a0051e9403c9df3ed6808f3854">AutoDiffXd</a> = <a class="el" href="classdrake_1_1ad_1_1_auto_diff.html">drake::ad::AutoDiff</a></td></tr>
<tr class="memdesc:a3d6302a0051e9403c9df3ed6808f3854"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scalar type that performs automatic differentiation.  <br /></td></tr>
<tr class="memitem:a59eaaaa152841d234e829f38163a9981" id="r_a59eaaaa152841d234e829f38163a9981"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59eaaaa152841d234e829f38163a9981">AutoDiffVecXd</a> = Eigen::Matrix&lt;<a class="el" href="#a3d6302a0051e9403c9df3ed6808f3854">AutoDiffXd</a>, Eigen::Dynamic, 1&gt;</td></tr>
<tr class="memdesc:a59eaaaa152841d234e829f38163a9981"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic-sized vector of autodiff variables.  <br /></td></tr>
<tr class="memitem:a1f1c657c4d2cf400649123a7c2573d5b" id="r_a1f1c657c4d2cf400649123a7c2573d5b"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a1f1c657c4d2cf400649123a7c2573d5b template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a> = typename <a class="el" href="structdrake_1_1scalar__predicate.html">scalar_predicate</a>&lt;T&gt;::type</td></tr>
<tr class="memdesc:a1f1c657c4d2cf400649123a7c2573d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for a boolean-like value, conditioned on the scalar type <span class="tt">T</span>.  <br /></td></tr>
<tr class="memitem:a5f4077c4918078fb55bfb6b73968cb0a" id="r_a5f4077c4918078fb55bfb6b73968cb0a"><td class="memTemplParams" colspan="2">template&lt;int num_vars&gt; </td></tr>
<tr class="memitem:a5f4077c4918078fb55bfb6b73968cb0a template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f4077c4918078fb55bfb6b73968cb0a">AutoDiffd</a> = Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, num_vars, 1&gt; &gt;</td></tr>
<tr class="memdesc:a5f4077c4918078fb55bfb6b73968cb0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An autodiff variable with <span class="tt">num_vars</span> partials.  <br /></td></tr>
<tr class="memitem:a790a072a62129732864a20e7a4743298" id="r_a790a072a62129732864a20e7a4743298"><td class="memTemplParams" colspan="2">template&lt;int num_vars, int rows&gt; </td></tr>
<tr class="memitem:a790a072a62129732864a20e7a4743298 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a790a072a62129732864a20e7a4743298">AutoDiffVecd</a> = Eigen::Matrix&lt;<a class="el" href="#a5f4077c4918078fb55bfb6b73968cb0a">AutoDiffd</a>&lt;num_vars&gt;, rows, 1&gt;</td></tr>
<tr class="memdesc:a790a072a62129732864a20e7a4743298"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of <span class="tt">rows</span> autodiff variables, each with <span class="tt">num_vars</span> partials.  <br /></td></tr>
<tr class="memitem:acda0b15d77e4c1701d160b17a2cb2ea8" id="r_acda0b15d77e4c1701d160b17a2cb2ea8"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:acda0b15d77e4c1701d160b17a2cb2ea8 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acda0b15d77e4c1701d160b17a2cb2ea8">Vector0</a> = Eigen::Matrix&lt;Scalar, 0, 1&gt;</td></tr>
<tr class="memdesc:acda0b15d77e4c1701d160b17a2cb2ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The empty column vector (zero rows, one column), templated on scalar type.  <br /></td></tr>
<tr class="memitem:af359dfdb84d6c13b606bb3ed7b821e23" id="r_af359dfdb84d6c13b606bb3ed7b821e23"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:af359dfdb84d6c13b606bb3ed7b821e23 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af359dfdb84d6c13b606bb3ed7b821e23">Vector1</a> = Eigen::Matrix&lt;Scalar, 1, 1&gt;</td></tr>
<tr class="memdesc:af359dfdb84d6c13b606bb3ed7b821e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of size 1 (that is, a scalar), templated on scalar type.  <br /></td></tr>
<tr class="memitem:a6d923e79e6e92c2556edd86520145077" id="r_a6d923e79e6e92c2556edd86520145077"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d923e79e6e92c2556edd86520145077">Vector1d</a> = Eigen::Matrix&lt;double, 1, 1&gt;</td></tr>
<tr class="memdesc:a6d923e79e6e92c2556edd86520145077"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of size 1 of doubles.  <br /></td></tr>
<tr class="memitem:ab9f8b7dbd727440c2dd207bf43812f1e" id="r_ab9f8b7dbd727440c2dd207bf43812f1e"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:ab9f8b7dbd727440c2dd207bf43812f1e template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9f8b7dbd727440c2dd207bf43812f1e">Vector2</a> = Eigen::Matrix&lt;Scalar, 2, 1&gt;</td></tr>
<tr class="memdesc:ab9f8b7dbd727440c2dd207bf43812f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of size 2, templated on scalar type.  <br /></td></tr>
<tr class="memitem:a0ad29daab565ce347c4d1c5aae6a76c2" id="r_a0ad29daab565ce347c4d1c5aae6a76c2"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:a0ad29daab565ce347c4d1c5aae6a76c2 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a> = Eigen::Matrix&lt;Scalar, 3, 1&gt;</td></tr>
<tr class="memdesc:a0ad29daab565ce347c4d1c5aae6a76c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of size 3, templated on scalar type.  <br /></td></tr>
<tr class="memitem:af7e96394aef85f13f3fc84d3c3c238b3" id="r_af7e96394aef85f13f3fc84d3c3c238b3"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:af7e96394aef85f13f3fc84d3c3c238b3 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a> = Eigen::Matrix&lt;Scalar, 4, 1&gt;</td></tr>
<tr class="memdesc:af7e96394aef85f13f3fc84d3c3c238b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of size 4, templated on scalar type.  <br /></td></tr>
<tr class="memitem:a14aa433aedda321a15238f2d4074d4c3" id="r_a14aa433aedda321a15238f2d4074d4c3"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:a14aa433aedda321a15238f2d4074d4c3 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14aa433aedda321a15238f2d4074d4c3">Vector6</a> = Eigen::Matrix&lt;Scalar, 6, 1&gt;</td></tr>
<tr class="memdesc:a14aa433aedda321a15238f2d4074d4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of size 6.  <br /></td></tr>
<tr class="memitem:a44f103cf5fdeb3f539ceeeb9cd3a0a28" id="r_a44f103cf5fdeb3f539ceeeb9cd3a0a28"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44f103cf5fdeb3f539ceeeb9cd3a0a28">Vector6d</a> = Eigen::Matrix&lt;double, 6, 1&gt;</td></tr>
<tr class="memdesc:a44f103cf5fdeb3f539ceeeb9cd3a0a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of size 6 of doubles.  <br /></td></tr>
<tr class="memitem:a01ae662d5635b7c9efe03d15d976f7a8" id="r_a01ae662d5635b7c9efe03d15d976f7a8"><td class="memTemplParams" colspan="2">template&lt;typename Scalar, int Rows&gt; </td></tr>
<tr class="memitem:a01ae662d5635b7c9efe03d15d976f7a8 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01ae662d5635b7c9efe03d15d976f7a8">Vector</a> = Eigen::Matrix&lt;Scalar, Rows, 1&gt;</td></tr>
<tr class="memdesc:a01ae662d5635b7c9efe03d15d976f7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector templated on the number of rows.  <br /></td></tr>
<tr class="memitem:a77dd228fb4dd66a2c17dd3f7f38ffd85" id="r_a77dd228fb4dd66a2c17dd3f7f38ffd85"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:a77dd228fb4dd66a2c17dd3f7f38ffd85 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a> = Eigen::Matrix&lt;Scalar, Eigen::Dynamic, 1&gt;</td></tr>
<tr class="memdesc:a77dd228fb4dd66a2c17dd3f7f38ffd85"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of any size, templated on scalar type.  <br /></td></tr>
<tr class="memitem:adfbacdba0566fe8958cfafd659b4373f" id="r_adfbacdba0566fe8958cfafd659b4373f"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:adfbacdba0566fe8958cfafd659b4373f template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfbacdba0566fe8958cfafd659b4373f">VectorUpTo6</a> = Eigen::Matrix&lt;Scalar, Eigen::Dynamic, 1, 0, 6, 1&gt;</td></tr>
<tr class="memdesc:adfbacdba0566fe8958cfafd659b4373f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of dynamic size templated on scalar type, up to a maximum of 6 elements.  <br /></td></tr>
<tr class="memitem:afc54e1f7aa3341a5f6b305705452d9bd" id="r_afc54e1f7aa3341a5f6b305705452d9bd"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:afc54e1f7aa3341a5f6b305705452d9bd template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc54e1f7aa3341a5f6b305705452d9bd">RowVector2</a> = Eigen::Matrix&lt;Scalar, 1, 2&gt;</td></tr>
<tr class="memdesc:afc54e1f7aa3341a5f6b305705452d9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A row vector of size 2, templated on scalar type.  <br /></td></tr>
<tr class="memitem:aee4ae0d841ea1629551bf77fd5d9ec9e" id="r_aee4ae0d841ea1629551bf77fd5d9ec9e"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:aee4ae0d841ea1629551bf77fd5d9ec9e template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee4ae0d841ea1629551bf77fd5d9ec9e">RowVector3</a> = Eigen::Matrix&lt;Scalar, 1, 3&gt;</td></tr>
<tr class="memdesc:aee4ae0d841ea1629551bf77fd5d9ec9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A row vector of size 3, templated on scalar type.  <br /></td></tr>
<tr class="memitem:aa9b373b2971391d9054b431d8a3e4b33" id="r_aa9b373b2971391d9054b431d8a3e4b33"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:aa9b373b2971391d9054b431d8a3e4b33 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9b373b2971391d9054b431d8a3e4b33">RowVector4</a> = Eigen::Matrix&lt;Scalar, 1, 4&gt;</td></tr>
<tr class="memdesc:aa9b373b2971391d9054b431d8a3e4b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">A row vector of size 4, templated on scalar type.  <br /></td></tr>
<tr class="memitem:a3ad88c2d704ccb2899d475d3ae05de14" id="r_a3ad88c2d704ccb2899d475d3ae05de14"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:a3ad88c2d704ccb2899d475d3ae05de14 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ad88c2d704ccb2899d475d3ae05de14">RowVector6</a> = Eigen::Matrix&lt;Scalar, 1, 6&gt;</td></tr>
<tr class="memdesc:a3ad88c2d704ccb2899d475d3ae05de14"><td class="mdescLeft">&#160;</td><td class="mdescRight">A row vector of size 6.  <br /></td></tr>
<tr class="memitem:a3eb9dffa1f3d48e4c5fe406e5a4617fe" id="r_a3eb9dffa1f3d48e4c5fe406e5a4617fe"><td class="memTemplParams" colspan="2">template&lt;typename Scalar, int Cols&gt; </td></tr>
<tr class="memitem:a3eb9dffa1f3d48e4c5fe406e5a4617fe template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3eb9dffa1f3d48e4c5fe406e5a4617fe">RowVector</a> = Eigen::Matrix&lt;Scalar, 1, Cols&gt;</td></tr>
<tr class="memdesc:a3eb9dffa1f3d48e4c5fe406e5a4617fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A row vector templated on the number of columns.  <br /></td></tr>
<tr class="memitem:a218f39990d2d9090c7a25c9c18cbf832" id="r_a218f39990d2d9090c7a25c9c18cbf832"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:a218f39990d2d9090c7a25c9c18cbf832 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a218f39990d2d9090c7a25c9c18cbf832">RowVectorX</a> = Eigen::Matrix&lt;Scalar, 1, Eigen::Dynamic&gt;</td></tr>
<tr class="memdesc:a218f39990d2d9090c7a25c9c18cbf832"><td class="mdescLeft">&#160;</td><td class="mdescRight">A row vector of any size, templated on scalar type.  <br /></td></tr>
<tr class="memitem:a06406a5da633da84f911e2979aa48549" id="r_a06406a5da633da84f911e2979aa48549"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:a06406a5da633da84f911e2979aa48549 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06406a5da633da84f911e2979aa48549">Matrix2</a> = Eigen::Matrix&lt;Scalar, 2, 2&gt;</td></tr>
<tr class="memdesc:a06406a5da633da84f911e2979aa48549"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 2 rows and 2 columns, templated on scalar type.  <br /></td></tr>
<tr class="memitem:a3922cc0c6264e8ff225a6aa0dd993667" id="r_a3922cc0c6264e8ff225a6aa0dd993667"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:a3922cc0c6264e8ff225a6aa0dd993667 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a> = Eigen::Matrix&lt;Scalar, 3, 3&gt;</td></tr>
<tr class="memdesc:a3922cc0c6264e8ff225a6aa0dd993667"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 3 rows and 3 columns, templated on scalar type.  <br /></td></tr>
<tr class="memitem:ae74155a11dfcdaad0adc0349f0956148" id="r_ae74155a11dfcdaad0adc0349f0956148"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:ae74155a11dfcdaad0adc0349f0956148 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae74155a11dfcdaad0adc0349f0956148">Matrix4</a> = Eigen::Matrix&lt;Scalar, 4, 4&gt;</td></tr>
<tr class="memdesc:ae74155a11dfcdaad0adc0349f0956148"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 4 rows and 4 columns, templated on scalar type.  <br /></td></tr>
<tr class="memitem:a11f9aa896d31437a219ed19fa944fe20" id="r_a11f9aa896d31437a219ed19fa944fe20"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:a11f9aa896d31437a219ed19fa944fe20 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11f9aa896d31437a219ed19fa944fe20">Matrix6</a> = Eigen::Matrix&lt;Scalar, 6, 6&gt;</td></tr>
<tr class="memdesc:a11f9aa896d31437a219ed19fa944fe20"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 6 rows and 6 columns, templated on scalar type.  <br /></td></tr>
<tr class="memitem:af13883859324817e6310d04a6d2fe206" id="r_af13883859324817e6310d04a6d2fe206"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:af13883859324817e6310d04a6d2fe206 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af13883859324817e6310d04a6d2fe206">Matrix2X</a> = Eigen::Matrix&lt;Scalar, 2, Eigen::Dynamic&gt;</td></tr>
<tr class="memdesc:af13883859324817e6310d04a6d2fe206"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 2 rows, dynamic columns, templated on scalar type.  <br /></td></tr>
<tr class="memitem:acfe2dee57bc492bfbd96fe078b65ab00" id="r_acfe2dee57bc492bfbd96fe078b65ab00"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:acfe2dee57bc492bfbd96fe078b65ab00 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a> = Eigen::Matrix&lt;Scalar, 3, Eigen::Dynamic&gt;</td></tr>
<tr class="memdesc:acfe2dee57bc492bfbd96fe078b65ab00"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 3 rows, dynamic columns, templated on scalar type.  <br /></td></tr>
<tr class="memitem:a585f047d94502e00bfb163347abbc771" id="r_a585f047d94502e00bfb163347abbc771"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:a585f047d94502e00bfb163347abbc771 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a585f047d94502e00bfb163347abbc771">Matrix4X</a> = Eigen::Matrix&lt;Scalar, 4, Eigen::Dynamic&gt;</td></tr>
<tr class="memdesc:a585f047d94502e00bfb163347abbc771"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 4 rows, dynamic columns, templated on scalar type.  <br /></td></tr>
<tr class="memitem:a668e1152f8b876967b9093ae4d95298b" id="r_a668e1152f8b876967b9093ae4d95298b"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:a668e1152f8b876967b9093ae4d95298b template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a668e1152f8b876967b9093ae4d95298b">Matrix6X</a> = Eigen::Matrix&lt;Scalar, 6, Eigen::Dynamic&gt;</td></tr>
<tr class="memdesc:a668e1152f8b876967b9093ae4d95298b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 6 rows, dynamic columns, templated on scalar type.  <br /></td></tr>
<tr class="memitem:a28c58d881c60e96f48a7a4e32a699b95" id="r_a28c58d881c60e96f48a7a4e32a699b95"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:a28c58d881c60e96f48a7a4e32a699b95 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a> = Eigen::Matrix&lt;Scalar, Eigen::Dynamic, Eigen::Dynamic&gt;</td></tr>
<tr class="memdesc:a28c58d881c60e96f48a7a4e32a699b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of dynamic size, templated on scalar type.  <br /></td></tr>
<tr class="memitem:abac76c309b7189051aa03fdd116aacd1" id="r_abac76c309b7189051aa03fdd116aacd1"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:abac76c309b7189051aa03fdd116aacd1 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abac76c309b7189051aa03fdd116aacd1">MatrixUpTo6</a></td></tr>
<tr class="memdesc:abac76c309b7189051aa03fdd116aacd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of dynamic size templated on scalar type, up to a maximum of 6 rows and 6 columns.  <br /></td></tr>
<tr class="memitem:ae2b0be18a912f9cacfec6d0a0a6d873c" id="r_ae2b0be18a912f9cacfec6d0a0a6d873c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:ae2b0be18a912f9cacfec6d0a0a6d873c template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2b0be18a912f9cacfec6d0a0a6d873c">Matrix6xUpTo6</a> = Eigen::Matrix&lt;Scalar, 6, Eigen::Dynamic, 0, 6, 6&gt;</td></tr>
<tr class="memdesc:ae2b0be18a912f9cacfec6d0a0a6d873c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix of 6 rows and dynamic column size up to a maximum of 6, templated on scalar type.  <br /></td></tr>
<tr class="memitem:aae413ce2f94f0ecb301727a6781b69ff" id="r_aae413ce2f94f0ecb301727a6781b69ff"><td class="memTemplParams" colspan="2">template&lt;typename Scalar, typename Derived&gt; </td></tr>
<tr class="memitem:aae413ce2f94f0ecb301727a6781b69ff template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a></td></tr>
<tr class="memdesc:aae413ce2f94f0ecb301727a6781b69ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix with the same compile-time sizes and storage order as Derived, but with a different scalar type and its default alignment (Eigen::AutoAlign).  <br /></td></tr>
<tr class="memitem:ad5de4c858064cf0a457d6a18381e837b" id="r_ad5de4c858064cf0a457d6a18381e837b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5de4c858064cf0a457d6a18381e837b">StrideX</a> = Eigen::Stride&lt;Eigen::Dynamic, Eigen::Dynamic&gt;</td></tr>
<tr class="memdesc:ad5de4c858064cf0a457d6a18381e837b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fully dynamic Eigen stride.  <br /></td></tr>
<tr class="memitem:a4156bf453a5b323356d7cc784dfdf084" id="r_a4156bf453a5b323356d7cc784dfdf084"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:a4156bf453a5b323356d7cc784dfdf084 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4156bf453a5b323356d7cc784dfdf084">Quaternion</a> = Eigen::Quaternion&lt;Scalar&gt;</td></tr>
<tr class="memdesc:a4156bf453a5b323356d7cc784dfdf084"><td class="mdescLeft">&#160;</td><td class="mdescRight">A quaternion templated on scalar type.  <br /></td></tr>
<tr class="memitem:a90d91e75997a81a48adea1e83caddde4" id="r_a90d91e75997a81a48adea1e83caddde4"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:a90d91e75997a81a48adea1e83caddde4 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90d91e75997a81a48adea1e83caddde4">AngleAxis</a> = Eigen::AngleAxis&lt;Scalar&gt;</td></tr>
<tr class="memdesc:a90d91e75997a81a48adea1e83caddde4"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="#a90d91e75997a81a48adea1e83caddde4" title="An AngleAxis templated on scalar type.">AngleAxis</a> templated on scalar type.  <br /></td></tr>
<tr class="memitem:a9eb383d64a842ca9002f66b2e10254aa" id="r_a9eb383d64a842ca9002f66b2e10254aa"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:a9eb383d64a842ca9002f66b2e10254aa template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a> = Eigen::Transform&lt;Scalar, 3, Eigen::Isometry&gt;</td></tr>
<tr class="memdesc:a9eb383d64a842ca9002f66b2e10254aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Isometry templated on scalar type.  <br /></td></tr>
<tr class="memitem:a08115460f0d38571bcd4445ca9d6ec18" id="r_a08115460f0d38571bcd4445ca9d6ec18"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08115460f0d38571bcd4445ca9d6ec18">FileSource</a> = std::variant&lt;std::filesystem::path, <a class="el" href="classdrake_1_1_memory_file.html">MemoryFile</a>&gt;</td></tr>
<tr class="memdesc:a08115460f0d38571bcd4445ca9d6ec18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a file.  <br /></td></tr>
<tr class="memitem:a5a11519c4c803fc3f2118df94e858e95" id="r_a5a11519c4c803fc3f2118df94e858e95"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a11519c4c803fc3f2118df94e858e95">DefaultHasher</a> = internal::FNV1aHasher</td></tr>
<tr class="memdesc:a5a11519c4c803fc3f2118df94e858e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default HashAlgorithm concept implementation across Drake.  <br /></td></tr>
<tr class="memitem:a323dc8b0cc629c61d4da8feeaa8cd4f5" id="r_a323dc8b0cc629c61d4da8feeaa8cd4f5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a323dc8b0cc629c61d4da8feeaa8cd4f5">DefaultHash</a> = <a class="el" href="structdrake_1_1uhash.html">drake::uhash</a>&lt;<a class="el" href="#a5a11519c4c803fc3f2118df94e858e95">DefaultHasher</a>&gt;</td></tr>
<tr class="memdesc:a323dc8b0cc629c61d4da8feeaa8cd4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default hashing functor, akin to std::hash.  <br /></td></tr>
<tr class="memitem:a158f68939b94f6c2c5ea353d652919da" id="r_a158f68939b94f6c2c5ea353d652919da"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a158f68939b94f6c2c5ea353d652919da template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a158f68939b94f6c2c5ea353d652919da">is_cloneable</a> = is_cloneable_internal::is_cloneable_helper&lt;T, void&gt;</td></tr>
<tr class="memdesc:a158f68939b94f6c2c5ea353d652919da"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="is_cloneable_doc"></a>Provides method for determining at run time if a class is "cloneable".  <br /></td></tr>
<tr class="memitem:ab0a2621977171e1d2d5b64c55141b9b2" id="r_ab0a2621977171e1d2d5b64c55141b9b2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a></td></tr>
<tr class="memitem:a00cbebcd97766579bb36e35abcf44acf" id="r_a00cbebcd97766579bb36e35abcf44acf"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; <a class="el" href="#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a>, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00cbebcd97766579bb36e35abcf44acf">VectorXPoly</a></td></tr>
<tr class="memdesc:a00cbebcd97766579bb36e35abcf44acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A column vector of polynomials; used in several optimization classes.  <br /></td></tr>
<tr class="memitem:a9de8c1164370b94e59f07071e3d37231" id="r_a9de8c1164370b94e59f07071e3d37231"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a9de8c1164370b94e59f07071e3d37231 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9de8c1164370b94e59f07071e3d37231">string_map</a> = std::map&lt;std::string, T, std::less&lt;void&gt;&gt;</td></tr>
<tr class="memdesc:a9de8c1164370b94e59f07071e3d37231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <span class="tt">std::map&lt;std::string, T&gt;</span>, but with better defaults than the plain <span class="tt">std::map&lt;std::string, T&gt;</span> spelling.  <br /></td></tr>
<tr class="memitem:a5df4f70ad81fe7daff15f9a9ce9b8edf" id="r_a5df4f70ad81fe7daff15f9a9ce9b8edf"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a5df4f70ad81fe7daff15f9a9ce9b8edf template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5df4f70ad81fe7daff15f9a9ce9b8edf">string_multimap</a> = std::multimap&lt;std::string, T, std::less&lt;void&gt;&gt;</td></tr>
<tr class="memdesc:a5df4f70ad81fe7daff15f9a9ce9b8edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <span class="tt">std::multimap&lt;std::string, T&gt;</span>, but with better defaults than the plain <span class="tt">std::multimap&lt;std::string, T&gt;</span> spelling.  <br /></td></tr>
<tr class="memitem:abaab955b1414eeecd13a7fe3d79b6422" id="r_abaab955b1414eeecd13a7fe3d79b6422"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abaab955b1414eeecd13a7fe3d79b6422">string_set</a> = std::set&lt;std::string, std::less&lt;void&gt;&gt;</td></tr>
<tr class="memdesc:abaab955b1414eeecd13a7fe3d79b6422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <span class="tt">std::set&lt;std::string&gt;</span>, but with better defaults than the plain <span class="tt">std::set&lt;std::string&gt;</span> spelling.  <br /></td></tr>
<tr class="memitem:a66eb3331428a0a762d12c6130ae0fdcb" id="r_a66eb3331428a0a762d12c6130ae0fdcb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66eb3331428a0a762d12c6130ae0fdcb">string_multiset</a> = std::multiset&lt;std::string, std::less&lt;void&gt;&gt;</td></tr>
<tr class="memdesc:a66eb3331428a0a762d12c6130ae0fdcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <span class="tt">std::multiset&lt;std::string&gt;</span>, but with better defaults than the plain <span class="tt">std::multiset&lt;std::string&gt;</span> spelling.  <br /></td></tr>
<tr class="memitem:a42ead4ab3ea15652a58208871dde4238" id="r_a42ead4ab3ea15652a58208871dde4238"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a42ead4ab3ea15652a58208871dde4238 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42ead4ab3ea15652a58208871dde4238">string_unordered_map</a></td></tr>
<tr class="memdesc:a42ead4ab3ea15652a58208871dde4238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <span class="tt">std::unordered_map&lt;std::string, T&gt;</span>, but with better defaults than the plain <span class="tt">std::unordered_map&lt;std::string, T&gt;</span> spelling.  <br /></td></tr>
<tr class="memitem:adcca06c39e67c5fb9588f30dd77f868c" id="r_adcca06c39e67c5fb9588f30dd77f868c"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:adcca06c39e67c5fb9588f30dd77f868c template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcca06c39e67c5fb9588f30dd77f868c">string_unordered_multimap</a></td></tr>
<tr class="memdesc:adcca06c39e67c5fb9588f30dd77f868c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <span class="tt">std::unordered_multimap&lt;std::string, T&gt;</span>, but with better defaults than the plain <span class="tt">std::unordered_multimap&lt;std::string, T&gt;</span> spelling.  <br /></td></tr>
<tr class="memitem:a786c9cdb32bd0bdebbaeda107f9dbb2b" id="r_a786c9cdb32bd0bdebbaeda107f9dbb2b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a786c9cdb32bd0bdebbaeda107f9dbb2b">string_unordered_set</a></td></tr>
<tr class="memdesc:a786c9cdb32bd0bdebbaeda107f9dbb2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <span class="tt">std::unordered_set&lt;std::string&gt;</span>, but with better defaults than the plain <span class="tt">std::unordered_set&lt;std::string&gt;</span> spelling.  <br /></td></tr>
<tr class="memitem:acf1f478dc725be9a5579b3ce44f9816e" id="r_acf1f478dc725be9a5579b3ce44f9816e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf1f478dc725be9a5579b3ce44f9816e">string_unordered_multiset</a></td></tr>
<tr class="memdesc:acf1f478dc725be9a5579b3ce44f9816e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <span class="tt">std::unordered_multiset&lt;std::string&gt;</span>, but with better defaults than the plain <span class="tt">std::unordered_multiset&lt;std::string&gt;</span> spelling.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af8777bc10296f9d39d52753861110e26" id="r_af8777bc10296f9d39d52753861110e26"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8777bc10296f9d39d52753861110e26">ToleranceType</a> { <a class="el" href="#af8777bc10296f9d39d52753861110e26abab0767e88027de9944aa55c24c8387a">kAbsolute</a>
, <a class="el" href="#af8777bc10296f9d39d52753861110e26af460a96ab20647996c15854794763384">kRelative</a>
 }</td></tr>
<tr class="memitem:a72383be4710d27584d0821effc6506a5" id="r_a72383be4710d27584d0821effc6506a5"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72383be4710d27584d0821effc6506a5">RandomDistribution</a> { <a class="el" href="#a72383be4710d27584d0821effc6506a5a3ea9f7aca87fd7b64469a0d1119f0b50">kUniform</a> = 0
, <a class="el" href="#a72383be4710d27584d0821effc6506a5ab933cd0242085c2dbf804dbf288ce7f0">kGaussian</a> = 1
, <a class="el" href="#a72383be4710d27584d0821effc6506a5a601bf5851ffd28f5e6219c0f1945c8d6">kExponential</a> = 2
 }</td></tr>
<tr class="memdesc:a72383be4710d27584d0821effc6506a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drake supports explicit reasoning about a few carefully chosen random distributions.  <a href="#a72383be4710d27584d0821effc6506a5">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a76aa07d781c1d9b7db80d218dd28b66a" id="r_a76aa07d781c1d9b7db80d218dd28b66a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76aa07d781c1d9b7db80d218dd28b66a">ExtractDoubleOrThrow</a> (const <a class="el" href="classdrake_1_1ad_1_1_auto_diff.html">ad::AutoDiff</a> &amp;scalar)</td></tr>
<tr class="memdesc:a76aa07d781c1d9b7db80d218dd28b66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the autodiff scalar's value() as a double.  <br /></td></tr>
<tr class="memitem:af77f42953b424b906077b9b7daa0bdf8" id="r_af77f42953b424b906077b9b7daa0bdf8"><td class="memTemplParams" colspan="2">template&lt;int RowsAtCompileTime, int ColsAtCompileTime, int Options, int MaxRowsAtCompileTime, int MaxColsAtCompileTime&gt; </td></tr>
<tr class="memitem:af77f42953b424b906077b9b7daa0bdf8 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af77f42953b424b906077b9b7daa0bdf8">ExtractDoubleOrThrow</a> (const Eigen::MatrixBase&lt; Eigen::Matrix&lt; <a class="el" href="classdrake_1_1ad_1_1_auto_diff.html">ad::AutoDiff</a>, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime &gt; &gt; &amp;matrix)</td></tr>
<tr class="memdesc:af77f42953b424b906077b9b7daa0bdf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">matrix</span> as an Eigen::Matrix&lt;double, ...&gt; with the same size allocation as <span class="tt">matrix</span>.  <br /></td></tr>
<tr class="memitem:a3e8eeef2d39f7e0d858b79aac4efd952" id="r_a3e8eeef2d39f7e0d858b79aac4efd952"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1ad_1_1_auto_diff.html">ad::AutoDiff</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e8eeef2d39f7e0d858b79aac4efd952">if_then_else</a> (bool f_cond, const <a class="el" href="classdrake_1_1ad_1_1_auto_diff.html">ad::AutoDiff</a> &amp;x, const <a class="el" href="classdrake_1_1ad_1_1_auto_diff.html">ad::AutoDiff</a> &amp;y)</td></tr>
<tr class="memdesc:a3e8eeef2d39f7e0d858b79aac4efd952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides if-then-else expression for AutoDiff.  <br /></td></tr>
<tr class="memitem:a032afe843cdaa8b1e28e99344d84ab9d" id="r_a032afe843cdaa8b1e28e99344d84ab9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1ad_1_1_auto_diff.html">ad::AutoDiff</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a032afe843cdaa8b1e28e99344d84ab9d">cond</a> (const <a class="el" href="classdrake_1_1ad_1_1_auto_diff.html">ad::AutoDiff</a> &amp;e)</td></tr>
<tr class="memdesc:a032afe843cdaa8b1e28e99344d84ab9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides cond's base case for AutoDiff.  <br /></td></tr>
<tr class="memitem:a7ac422c010c8ccd5708c43d12459b211" id="r_a7ac422c010c8ccd5708c43d12459b211"><td class="memTemplParams" colspan="2">template&lt;typename... Rest&gt; </td></tr>
<tr class="memitem:a7ac422c010c8ccd5708c43d12459b211 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1ad_1_1_auto_diff.html">ad::AutoDiff</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ac422c010c8ccd5708c43d12459b211">cond</a> (bool f_cond, const <a class="el" href="classdrake_1_1ad_1_1_auto_diff.html">ad::AutoDiff</a> &amp;e_then, Rest... rest)</td></tr>
<tr class="memdesc:a7ac422c010c8ccd5708c43d12459b211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides cond base for AutoDiff.  <br /></td></tr>
<tr class="memitem:ad0da43c947d3694c1051212d4043d07e" id="r_ad0da43c947d3694c1051212d4043d07e"><td class="memTemplParams" colspan="2">template&lt;typename DerType&gt; </td></tr>
<tr class="memitem:ad0da43c947d3694c1051212d4043d07e template"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0da43c947d3694c1051212d4043d07e">ExtractDoubleOrThrow</a> (const Eigen::AutoDiffScalar&lt; DerType &gt; &amp;scalar)</td></tr>
<tr class="memdesc:ad0da43c947d3694c1051212d4043d07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the autodiff scalar's value() as a double.  <br /></td></tr>
<tr class="memitem:a4f91267b864bbde5457e4adac3e417fe" id="r_a4f91267b864bbde5457e4adac3e417fe"><td class="memTemplParams" colspan="2">template&lt;typename DerType, int RowsAtCompileTime, int ColsAtCompileTime, int Options, int MaxRowsAtCompileTime, int MaxColsAtCompileTime&gt; </td></tr>
<tr class="memitem:a4f91267b864bbde5457e4adac3e417fe template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f91267b864bbde5457e4adac3e417fe">ExtractDoubleOrThrow</a> (const Eigen::MatrixBase&lt; Eigen::Matrix&lt; Eigen::AutoDiffScalar&lt; DerType &gt;, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime &gt; &gt; &amp;matrix)</td></tr>
<tr class="memdesc:a4f91267b864bbde5457e4adac3e417fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code class="param">matrix</code> as an Eigen::Matrix&lt;double, ...&gt; with the same size allocation as <code class="param">matrix</code>.  <br /></td></tr>
<tr class="memitem:aeb46699dc47883f5ac4d81f95d8756f1" id="r_aeb46699dc47883f5ac4d81f95d8756f1"><td class="memTemplParams" colspan="2">template&lt;typename DerType1, typename DerType2&gt; </td></tr>
<tr class="memitem:aeb46699dc47883f5ac4d81f95d8756f1 template"><td class="memItemLeft" align="right" valign="top">Eigen::AutoDiffScalar&lt; typename Eigen::internal::remove_all&lt; DerType1 &gt;::type::PlainObject &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb46699dc47883f5ac4d81f95d8756f1">if_then_else</a> (bool f_cond, const Eigen::AutoDiffScalar&lt; DerType1 &gt; &amp;x, const Eigen::AutoDiffScalar&lt; DerType2 &gt; &amp;y)</td></tr>
<tr class="memdesc:aeb46699dc47883f5ac4d81f95d8756f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides if-then-else expression for Eigen::AutoDiffScalar type.  <br /></td></tr>
<tr class="memitem:aa937e4c404b7e9c2c433f4dae17ee783" id="r_aa937e4c404b7e9c2c433f4dae17ee783"><td class="memTemplParams" colspan="2">template&lt;typename DerType, typename... Rest&gt; </td></tr>
<tr class="memitem:aa937e4c404b7e9c2c433f4dae17ee783 template"><td class="memItemLeft" align="right" valign="top">Eigen::AutoDiffScalar&lt; typename Eigen::internal::remove_all&lt; DerType &gt;::type::PlainObject &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa937e4c404b7e9c2c433f4dae17ee783">cond</a> (bool f_cond, const Eigen::AutoDiffScalar&lt; DerType &gt; &amp;e_then, Rest... rest)</td></tr>
<tr class="memdesc:aa937e4c404b7e9c2c433f4dae17ee783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides special case of cond expression for Eigen::AutoDiffScalar type.  <br /></td></tr>
<tr class="memitem:a64f6df74b46df7d595a8510ba6f3a72d" id="r_a64f6df74b46df7d595a8510ba6f3a72d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64f6df74b46df7d595a8510ba6f3a72d">if_then_else</a> (bool f_cond, double v_then, double v_else)</td></tr>
<tr class="memdesc:a64f6df74b46df7d595a8510ba6f3a72d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides if-then-else expression for double.  <br /></td></tr>
<tr class="memitem:a6f017505f166d0b60735ba1c4a9b4f23" id="r_a6f017505f166d0b60735ba1c4a9b4f23"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a6f017505f166d0b60735ba1c4a9b4f23 template"><td class="memItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f017505f166d0b60735ba1c4a9b4f23">all</a> (const Eigen::DenseBase&lt; Derived &gt; &amp;m)</td></tr>
<tr class="memdesc:a6f017505f166d0b60735ba1c4a9b4f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks truth for all elements in matrix <code class="param">m</code>.  <br /></td></tr>
<tr class="memitem:a58bef16b035645d48c9d032a977d7680" id="r_a58bef16b035645d48c9d032a977d7680"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a58bef16b035645d48c9d032a977d7680 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58bef16b035645d48c9d032a977d7680">all_of</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const std::function&lt; <a class="el" href="#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;(const typename Derived::Scalar &amp;)&gt; &amp;pred)</td></tr>
<tr class="memdesc:a58bef16b035645d48c9d032a977d7680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate <code class="param">pred</code> holds for all elements in the matrix <code class="param">m</code>.  <br /></td></tr>
<tr class="memitem:a044a99d40c78d36c585451760f6a8513" id="r_a044a99d40c78d36c585451760f6a8513"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a044a99d40c78d36c585451760f6a8513 template"><td class="memItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a044a99d40c78d36c585451760f6a8513">any</a> (const Eigen::DenseBase&lt; Derived &gt; &amp;m)</td></tr>
<tr class="memdesc:a044a99d40c78d36c585451760f6a8513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks truth for at least one element in matrix <code class="param">m</code>.  <br /></td></tr>
<tr class="memitem:a2cca690674b317f8f5781d064cacf2ed" id="r_a2cca690674b317f8f5781d064cacf2ed"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a2cca690674b317f8f5781d064cacf2ed template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cca690674b317f8f5781d064cacf2ed">any_of</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const std::function&lt; <a class="el" href="#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;(const typename Derived::Scalar &amp;)&gt; &amp;pred)</td></tr>
<tr class="memdesc:a2cca690674b317f8f5781d064cacf2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate <code class="param">pred</code> holds for at least one element in the matrix <code class="param">m</code>.  <br /></td></tr>
<tr class="memitem:ad43049d1b6ef4ac0baf74355cc5ddfcb" id="r_ad43049d1b6ef4ac0baf74355cc5ddfcb"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:ad43049d1b6ef4ac0baf74355cc5ddfcb template"><td class="memItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad43049d1b6ef4ac0baf74355cc5ddfcb">none</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m)</td></tr>
<tr class="memdesc:ad43049d1b6ef4ac0baf74355cc5ddfcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that no elements of <code class="param">m</code> are true. An empty matrix returns true.  <br /></td></tr>
<tr class="memitem:a4151f6cb087cd5b1cdc40e43cb1f7284" id="r_a4151f6cb087cd5b1cdc40e43cb1f7284"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a4151f6cb087cd5b1cdc40e43cb1f7284 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4151f6cb087cd5b1cdc40e43cb1f7284">none_of</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const std::function&lt; <a class="el" href="#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;(const typename Derived::Scalar &amp;)&gt; &amp;pred)</td></tr>
<tr class="memdesc:a4151f6cb087cd5b1cdc40e43cb1f7284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if unary predicate <code class="param">pred</code> holds for no elements in the matrix <code class="param">m</code>.  <br /></td></tr>
<tr class="memitem:a9e802890ec66861781b5204d68fb6ec9" id="r_a9e802890ec66861781b5204d68fb6ec9"><td class="memTemplParams" colspan="2">template&lt;typename T, int Rows&gt; </td></tr>
<tr class="memitem:a9e802890ec66861781b5204d68fb6ec9 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e802890ec66861781b5204d68fb6ec9">if_then_else</a> (const <a class="el" href="#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt; &amp;f_cond, const Eigen::Matrix&lt; T, Rows, 1 &gt; &amp;m_then, const Eigen::Matrix&lt; T, Rows, 1 &gt; &amp;m_else)</td></tr>
<tr class="memdesc:a9e802890ec66861781b5204d68fb6ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads if_then_else for Eigen vectors of <span class="tt">m_then</span> and <span class="tt">m_else</span> values with with a single <span class="tt">f_cond</span> condition to toggle them all at once.  <br /></td></tr>
<tr class="memitem:a2eb77bb30f5d469dbfda988cf8da6475" id="r_a2eb77bb30f5d469dbfda988cf8da6475"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2eb77bb30f5d469dbfda988cf8da6475">MaybeGetDrakePath</a> ()</td></tr>
<tr class="memdesc:a2eb77bb30f5d469dbfda988cf8da6475"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Returns the fully-qualified path to the first folder containing Drake resources as located by FindResource, or nullopt if none is found.  <br /></td></tr>
<tr class="memitem:a116c0ad7d2958e26a9b16795bcae1672" id="r_a116c0ad7d2958e26a9b16795bcae1672"><td class="memTemplParams" colspan="2">template&lt;typename Container&gt; </td></tr>
<tr class="memitem:a116c0ad7d2958e26a9b16795bcae1672 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a116c0ad7d2958e26a9b16795bcae1672">EigenMapView</a> (Container &amp;&amp;c)</td></tr>
<tr class="memdesc:a116c0ad7d2958e26a9b16795bcae1672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a random access container (like std::vector, std::array, or C array), returns an Eigen::Map view into that container.  <br /></td></tr>
<tr class="memitem:a327205de415417316eb87214fbb1b469" id="r_a327205de415417316eb87214fbb1b469"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a327205de415417316eb87214fbb1b469">ExtractDoubleOrThrow</a> (double scalar)</td></tr>
<tr class="memdesc:a327205de415417316eb87214fbb1b469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code class="param">scalar</code> as a double. Never throws.  <br /></td></tr>
<tr class="memitem:aa4436e37f057bca66547eabb27b3243a" id="r_aa4436e37f057bca66547eabb27b3243a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4436e37f057bca66547eabb27b3243a">ExtractDoubleOrThrow</a> (float scalar)</td></tr>
<tr class="memdesc:aa4436e37f057bca66547eabb27b3243a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code class="param">scalar</code> as a double. Never throws.  <br /></td></tr>
<tr class="memitem:a3a84c0102427116efee16d9170058116" id="r_a3a84c0102427116efee16d9170058116"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a3a84c0102427116efee16d9170058116 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, double &gt;, <a class="el" href="#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; double, Derived &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a84c0102427116efee16d9170058116">ExtractDoubleOrThrow</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix)</td></tr>
<tr class="memdesc:a3a84c0102427116efee16d9170058116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code class="param">matrix</code> as an Eigen::Matrix&lt;double, ...&gt; with the same size allocation as <code class="param">matrix</code>.  <br /></td></tr>
<tr class="memitem:a9c44573b575d41585df41dc137def92c" id="r_a9c44573b575d41585df41dc137def92c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c44573b575d41585df41dc137def92c">to_string</a> (const <a class="el" href="#a08115460f0d38571bcd4445ca9d6ec18">FileSource</a> &amp;source)</td></tr>
<tr class="memdesc:a9c44573b575d41585df41dc137def92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation.  <br /></td></tr>
<tr class="memitem:a26037cbd8a3c6a7dd5a0c7f1259bd18f" id="r_a26037cbd8a3c6a7dd5a0c7f1259bd18f"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26037cbd8a3c6a7dd5a0c7f1259bd18f">LoadedLibraryPath</a> (const std::string &amp;library_name)</td></tr>
<tr class="memdesc:a26037cbd8a3c6a7dd5a0c7f1259bd18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the absolute path of the library with the name <span class="tt">library_name</span> if that library was loaded in the current running process.  <br /></td></tr>
<tr class="memitem:a6d12a9fa5bded2c0de25138421b0e1d7" id="r_a6d12a9fa5bded2c0de25138421b0e1d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1_find_resource_result.html">FindResourceResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d12a9fa5bded2c0de25138421b0e1d7">FindResource</a> (const std::string &amp;resource_path)</td></tr>
<tr class="memdesc:a6d12a9fa5bded2c0de25138421b0e1d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Attempts to locate a Drake resource named by the given <span class="tt">resource_path</span>.  <br /></td></tr>
<tr class="memitem:ab1402fc7fba316744f96586956e7a752" id="r_ab1402fc7fba316744f96586956e7a752"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1402fc7fba316744f96586956e7a752">FindResourceOrThrow</a> (const std::string &amp;resource_path)</td></tr>
<tr class="memdesc:ab1402fc7fba316744f96586956e7a752"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Convenient wrapper for querying FindResource(resource_path) followed by <a class="el" href="classdrake_1_1_find_resource_result.html#a85ae127f2c62d94a37ba9190bb9ed0cf" title="Either returns the get_absolute_path() iff the resource was found, or else throws std::exception.">FindResourceResult::get_absolute_path_or_throw()</a>.  <br /></td></tr>
<tr class="memitem:a7d08c050b131498e375c5e6bb4ac8523" id="r_a7d08c050b131498e375c5e6bb4ac8523"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d08c050b131498e375c5e6bb4ac8523">ReadFile</a> (const std::filesystem::path &amp;path)</td></tr>
<tr class="memdesc:a7d08c050b131498e375c5e6bb4ac8523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the file at the given path, or nullopt if it cannot be read.  <br /></td></tr>
<tr class="memitem:aaf3c49ca62422759206ccb9c7a7b0bf5" id="r_aaf3c49ca62422759206ccb9c7a7b0bf5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf3c49ca62422759206ccb9c7a7b0bf5">ReadFileOrThrow</a> (const std::filesystem::path &amp;path)</td></tr>
<tr class="memdesc:aaf3c49ca62422759206ccb9c7a7b0bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the content of the file at the given path, or throws if it cannot be read.  <br /></td></tr>
<tr class="memitem:a2f411cee985f933195d5f37ef45e0cc6" id="r_a2f411cee985f933195d5f37ef45e0cc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f411cee985f933195d5f37ef45e0cc6">HasRunfiles</a> ()</td></tr>
<tr class="memdesc:a2f411cee985f933195d5f37ef45e0cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced.) Returns true iff this process has Bazel runfiles available.  <br /></td></tr>
<tr class="memitem:ae7b592b35122cdfc472bd8bf9d35df7a" id="r_ae7b592b35122cdfc472bd8bf9d35df7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1_rlocation_or_error.html">RlocationOrError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7b592b35122cdfc472bd8bf9d35df7a">FindRunfile</a> (const std::string &amp;resource_path, const std::string &amp;source_repository={})</td></tr>
<tr class="memdesc:ae7b592b35122cdfc472bd8bf9d35df7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced.) Returns the absolute path to the given <span class="tt">resource_path</span> from Bazel runfiles, or else an error message when not found.  <br /></td></tr>
<tr class="memitem:af432bd3fe5b5d4786e7473b3a26cd877" id="r_af432bd3fe5b5d4786e7473b3a26cd877"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af432bd3fe5b5d4786e7473b3a26cd877">fmt_runtime</a> (std::string_view s)</td></tr>
<tr class="memdesc:af432bd3fe5b5d4786e7473b3a26cd877"><td class="mdescLeft">&#160;</td><td class="mdescRight">When using fmt &gt;= 8, this is an alias for <a href="https://fmt.dev/latest/api.html#compile-time-format-string-checks">fmt::runtime</a>.  <br /></td></tr>
<tr class="memitem:a78ab22f7a42b8921faafd7b6ffb341fd" id="r_a78ab22f7a42b8921faafd7b6ffb341fd"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; <br />
requires (std::is_same_v&lt;T, float&gt; || std::is_same_v&lt;T, double&gt;)</td></tr>
<tr class="memitem:a78ab22f7a42b8921faafd7b6ffb341fd template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78ab22f7a42b8921faafd7b6ffb341fd">fmt_floating_point</a> (T x)</td></tr>
<tr class="memdesc:a78ab22f7a42b8921faafd7b6ffb341fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">fmt::to_string(x)</span> but always with at least one digit after the decimal point.  <br /></td></tr>
<tr class="memitem:afc57f8ba3471c69c959f961a287666ac" id="r_afc57f8ba3471c69c959f961a287666ac"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc57f8ba3471c69c959f961a287666ac">fmt_debug_string</a> (std::string_view x)</td></tr>
<tr class="memdesc:afc57f8ba3471c69c959f961a287666ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt"><a class="el" href="namespacefmt.html">fmt</a>::("{:?}", x)</span>, i.e, using fmt's "debug string format"; see <a href="https://fmt.dev">https://fmt.dev</a> docs for the '?  <br /></td></tr>
<tr class="memitem:a0655e16a159b287851163900c29d2b4f" id="r_a0655e16a159b287851163900c29d2b4f"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a0655e16a159b287851163900c29d2b4f template"><td class="memItemLeft" align="right" valign="top">internal::fmt_eigen_ref&lt; typename Derived::Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0655e16a159b287851163900c29d2b4f">fmt_eigen</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix)</td></tr>
<tr class="memdesc:a0655e16a159b287851163900c29d2b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">When passing an Eigen::Matrix to fmt, use this wrapper function to instruct fmt to use Drake's custom formatter for Eigen types.  <br /></td></tr>
<tr class="memitem:a65ba5721a088bacdc594dab652fc7e1c" id="r_a65ba5721a088bacdc594dab652fc7e1c"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a65ba5721a088bacdc594dab652fc7e1c template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65ba5721a088bacdc594dab652fc7e1c">fmt_streamed</a> (const T &amp;ref)</td></tr>
<tr class="memdesc:a65ba5721a088bacdc594dab652fc7e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">When using fmt &gt;= 9, this is an alias for <a href="https://fmt.dev/latest/api.html#ostream-api">fmt::streamed</a>.  <br /></td></tr>
<tr class="memitem:af07565c94853b4bbb124bf870969e3ff" id="r_af07565c94853b4bbb124bf870969e3ff"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm, class T&gt; </td></tr>
<tr class="memitem:af07565c94853b4bbb124bf870969e3ff template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af07565c94853b4bbb124bf870969e3ff">hash_append</a> (HashAlgorithm &amp;hasher, const T &amp;item) noexcept</td></tr>
<tr class="memdesc:af07565c94853b4bbb124bf870969e3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for integral constants.  <br /></td></tr>
<tr class="memitem:af61c35d443d2f52d05829da878f12532" id="r_af61c35d443d2f52d05829da878f12532"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm, class T&gt; </td></tr>
<tr class="memitem:af61c35d443d2f52d05829da878f12532 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af61c35d443d2f52d05829da878f12532">hash_append</a> (HashAlgorithm &amp;hasher, const T *item) noexcept</td></tr>
<tr class="memdesc:af61c35d443d2f52d05829da878f12532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for bare pointers.  <br /></td></tr>
<tr class="memitem:aff8e43fae4fbd53d5d9be5e4bdab7909" id="r_aff8e43fae4fbd53d5d9be5e4bdab7909"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm, class T&gt; </td></tr>
<tr class="memitem:aff8e43fae4fbd53d5d9be5e4bdab7909 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_enum_v&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff8e43fae4fbd53d5d9be5e4bdab7909">hash_append</a> (HashAlgorithm &amp;hasher, const T &amp;item) noexcept</td></tr>
<tr class="memdesc:aff8e43fae4fbd53d5d9be5e4bdab7909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for enumerations.  <br /></td></tr>
<tr class="memitem:aa59b8cb1f61857c789dff87021bf054e" id="r_aa59b8cb1f61857c789dff87021bf054e"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm, class T&gt; </td></tr>
<tr class="memitem:aa59b8cb1f61857c789dff87021bf054e template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point_v&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa59b8cb1f61857c789dff87021bf054e">hash_append</a> (HashAlgorithm &amp;hasher, const T &amp;item) noexcept</td></tr>
<tr class="memdesc:aa59b8cb1f61857c789dff87021bf054e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for floating point values.  <br /></td></tr>
<tr class="memitem:a4b8152b4424b80d9e9775da4d29b8746" id="r_a4b8152b4424b80d9e9775da4d29b8746"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm, class Traits, class Allocator&gt; </td></tr>
<tr class="memitem:a4b8152b4424b80d9e9775da4d29b8746 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b8152b4424b80d9e9775da4d29b8746">hash_append</a> (HashAlgorithm &amp;hasher, const std::basic_string&lt; char, Traits, Allocator &gt; &amp;item) noexcept</td></tr>
<tr class="memdesc:a4b8152b4424b80d9e9775da4d29b8746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::string.  <br /></td></tr>
<tr class="memitem:a180f010d174a68db7ca96ebb81c1471f" id="r_a180f010d174a68db7ca96ebb81c1471f"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm, class T1, class T2&gt; </td></tr>
<tr class="memitem:a180f010d174a68db7ca96ebb81c1471f template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a180f010d174a68db7ca96ebb81c1471f">hash_append</a> (HashAlgorithm &amp;hasher, const std::pair&lt; T1, T2 &gt; &amp;item) noexcept</td></tr>
<tr class="memdesc:a180f010d174a68db7ca96ebb81c1471f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::pair.  <br /></td></tr>
<tr class="memitem:a98bb4cd952e51e277fc40dc5e7e9b2c8" id="r_a98bb4cd952e51e277fc40dc5e7e9b2c8"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm, class T&gt; </td></tr>
<tr class="memitem:a98bb4cd952e51e277fc40dc5e7e9b2c8 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98bb4cd952e51e277fc40dc5e7e9b2c8">hash_append</a> (HashAlgorithm &amp;hasher, const std::optional&lt; T &gt; &amp;item) noexcept</td></tr>
<tr class="memdesc:a98bb4cd952e51e277fc40dc5e7e9b2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::optional.  <br /></td></tr>
<tr class="memitem:ad2c80c0eacf567c675541a92ff161fd0" id="r_ad2c80c0eacf567c675541a92ff161fd0"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm, class T1, class T2, class Compare, class Allocator&gt; </td></tr>
<tr class="memitem:ad2c80c0eacf567c675541a92ff161fd0 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2c80c0eacf567c675541a92ff161fd0">hash_append</a> (HashAlgorithm &amp;hasher, const std::map&lt; T1, T2, Compare, Allocator &gt; &amp;item) noexcept</td></tr>
<tr class="memdesc:ad2c80c0eacf567c675541a92ff161fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::map.  <br /></td></tr>
<tr class="memitem:a1db7c5cf9556e82dd4fe8f79321ca8e5" id="r_a1db7c5cf9556e82dd4fe8f79321ca8e5"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm, class Key, class Compare, class Allocator&gt; </td></tr>
<tr class="memitem:a1db7c5cf9556e82dd4fe8f79321ca8e5 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1db7c5cf9556e82dd4fe8f79321ca8e5">hash_append</a> (HashAlgorithm &amp;hasher, const std::set&lt; Key, Compare, Allocator &gt; &amp;item) noexcept</td></tr>
<tr class="memdesc:a1db7c5cf9556e82dd4fe8f79321ca8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::set.  <br /></td></tr>
<tr class="memitem:a6aea25059ddf8d6feeca13d2f3ec5783" id="r_a6aea25059ddf8d6feeca13d2f3ec5783"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm, class Iter&gt; </td></tr>
<tr class="memitem:a6aea25059ddf8d6feeca13d2f3ec5783 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6aea25059ddf8d6feeca13d2f3ec5783">hash_append_range</a> (HashAlgorithm &amp;hasher, Iter begin, Iter end) noexcept</td></tr>
<tr class="memdesc:a6aea25059ddf8d6feeca13d2f3ec5783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for a range, as given by two iterators.  <br /></td></tr>
<tr class="memitem:a2cf089de86f2bc6c12794ce67aacad84" id="r_a2cf089de86f2bc6c12794ce67aacad84"><td class="memTemplParams" colspan="2">template&lt;typename Tag&gt; </td></tr>
<tr class="memitem:a2cf089de86f2bc6c12794ce67aacad84 template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cf089de86f2bc6c12794ce67aacad84">to_string</a> (const <a class="el" href="classdrake_1_1_identifier.html">drake::Identifier</a>&lt; Tag &gt; &amp;id)</td></tr>
<tr class="memdesc:a2cf089de86f2bc6c12794ce67aacad84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables use of identifiers with to_string.  <br /></td></tr>
<tr class="memitem:afc8546dc6818041c65c64ee824685e74" id="r_afc8546dc6818041c65c64ee824685e74"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:afc8546dc6818041c65c64ee824685e74 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc8546dc6818041c65c64ee824685e74">is_approx_equal_abstol</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;m1, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;m2, double tolerance)</td></tr>
<tr class="memdesc:afc8546dc6818041c65c64ee824685e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if the two matrices are equal to within a certain absolute elementwise <code class="param">tolerance</code>.  <br /></td></tr>
<tr class="memitem:a15ebb98c217bdb150425d0175b37e827" id="r_a15ebb98c217bdb150425d0175b37e827"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a15ebb98c217bdb150425d0175b37e827 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15ebb98c217bdb150425d0175b37e827">IsApproxEqualAbsTolWithPermutedColumns</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;m1, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;m2, double tolerance)</td></tr>
<tr class="memdesc:a15ebb98c217bdb150425d0175b37e827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if a simple greedy search reveals a permutation of the columns of m2 to make the matrix equal to m1 to within a certain absolute elementwise <code class="param">tolerance</code>.  <br /></td></tr>
<tr class="memitem:a59728afb061f73e8235575806ed811f8" id="r_a59728afb061f73e8235575806ed811f8"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a59728afb061f73e8235575806ed811f8 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1_name_value.html">NameValue</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59728afb061f73e8235575806ed811f8">MakeNameValue</a> (const char *name, T *value)</td></tr>
<tr class="memdesc:a59728afb061f73e8235575806ed811f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Creates a <a class="el" href="classdrake_1_1_name_value.html" title="(Advanced) A basic implementation of the Name-Value Pair concept as used in the Serialize / Archive p...">NameValue</a>.  <br /></td></tr>
<tr class="memitem:a90397b62328225fe13d52a529dc3335d" id="r_a90397b62328225fe13d52a529dc3335d"><td class="memTemplParams" colspan="2">template&lt;class T, class U&gt; </td></tr>
<tr class="memitem:a90397b62328225fe13d52a529dc3335d template"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90397b62328225fe13d52a529dc3335d">static_pointer_cast</a> (std::unique_ptr&lt; U &gt; &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a90397b62328225fe13d52a529dc3335d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the object owned by the std::unique_ptr <span class="tt">other</span> from type <span class="tt">U</span> to <span class="tt">T</span>; no runtime type checking is performed.  <br /></td></tr>
<tr class="memitem:acbd230a9a1c01f99255cff20bbaf543e" id="r_acbd230a9a1c01f99255cff20bbaf543e"><td class="memTemplParams" colspan="2">template&lt;class T, class U&gt; </td></tr>
<tr class="memitem:acbd230a9a1c01f99255cff20bbaf543e template"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbd230a9a1c01f99255cff20bbaf543e">dynamic_pointer_cast</a> (std::unique_ptr&lt; U &gt; &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:acbd230a9a1c01f99255cff20bbaf543e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the object owned by the std::unique_ptr <span class="tt">other</span> from type <span class="tt">U</span> to <span class="tt">T</span>; if the cast fails, returns nullptr.  <br /></td></tr>
<tr class="memitem:a8bb3c50cd860a96af4593008942bc7ef" id="r_a8bb3c50cd860a96af4593008942bc7ef"><td class="memTemplParams" colspan="2">template&lt;class T, class U&gt; </td></tr>
<tr class="memitem:a8bb3c50cd860a96af4593008942bc7ef template"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bb3c50cd860a96af4593008942bc7ef">dynamic_pointer_cast_or_throw</a> (std::unique_ptr&lt; U &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a8bb3c50cd860a96af4593008942bc7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the object owned by the std::unique_ptr <span class="tt">other</span> from type <span class="tt">U</span> to <span class="tt">T</span>; if <span class="tt">other</span> is nullptr or the cast fails, throws a std::exception.  <br /></td></tr>
<tr class="memitem:a3d362cd0d2c845da2124c3f3914329a0" id="r_a3d362cd0d2c845da2124c3f3914329a0"><td class="memTemplParams" colspan="2">template&lt;class T, class U&gt; </td></tr>
<tr class="memitem:a3d362cd0d2c845da2124c3f3914329a0 template"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d362cd0d2c845da2124c3f3914329a0">dynamic_pointer_cast_or_throw</a> (U *other)</td></tr>
<tr class="memdesc:a3d362cd0d2c845da2124c3f3914329a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the pointer <span class="tt">other</span> from type <span class="tt">U</span> to <span class="tt">T</span> using <span class="tt">dynamic_cast</span>.  <br /></td></tr>
<tr class="memitem:a92c1bc8d793f1a04fa4f4c33a011f4eb" id="r_a92c1bc8d793f1a04fa4f4c33a011f4eb"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a92c1bc8d793f1a04fa4f4c33a011f4eb template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92c1bc8d793f1a04fa4f4c33a011f4eb">pow</a> (const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;base, typename <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt;::PowerType exponent)</td></tr>
<tr class="memdesc:a92c1bc8d793f1a04fa4f4c33a011f4eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides power function for <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>.  <br /></td></tr>
<tr class="memitem:a24d3bbc3fbb363dfb7cdc7ff5c71c850" id="r_a24d3bbc3fbb363dfb7cdc7ff5c71c850"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a24d3bbc3fbb363dfb7cdc7ff5c71c850 template"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24d3bbc3fbb363dfb7cdc7ff5c71c850">operator&lt;&lt;</a> (std::ostream &amp;os, const typename <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt;::Monomial &amp;m)</td></tr>
<tr class="memdesc:a24d3bbc3fbb363dfb7cdc7ff5c71c850"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr class="memitem:a6349afb82c0796366e318e99f25c3e5f" id="r_a6349afb82c0796366e318e99f25c3e5f"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a6349afb82c0796366e318e99f25c3e5f template"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6349afb82c0796366e318e99f25c3e5f">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;poly)</td></tr>
<tr class="memdesc:a6349afb82c0796366e318e99f25c3e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr class="memitem:a8db300eaec345b10d2e808b900239b8e" id="r_a8db300eaec345b10d2e808b900239b8e"><td class="memTemplParams" colspan="2">template&lt;typename T, int Rows, int Cols&gt; </td></tr>
<tr class="memitem:a8db300eaec345b10d2e808b900239b8e template"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8db300eaec345b10d2e808b900239b8e">operator&lt;&lt;</a> (std::ostream &amp;os, const Eigen::Matrix&lt; <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt;, Rows, Cols &gt; &amp;poly_mat)</td></tr>
<tr class="memdesc:a8db300eaec345b10d2e808b900239b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr class="memitem:ae05268ef42cdcf5bf9eba8c8a9b28e76" id="r_ae05268ef42cdcf5bf9eba8c8a9b28e76"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ae05268ef42cdcf5bf9eba8c8a9b28e76 template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae05268ef42cdcf5bf9eba8c8a9b28e76">CalcProbabilityDensity</a> (<a class="el" href="#a72383be4710d27584d0821effc6506a5">RandomDistribution</a> distribution, const Eigen::Ref&lt; const <a class="el" href="#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;x)</td></tr>
<tr class="memdesc:ae05268ef42cdcf5bf9eba8c8a9b28e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the density (probability density function) of the multivariate distribution.  <br /></td></tr>
<tr class="memitem:a7bb300fa310dc3a00fc8d7b353892de5" id="r_a7bb300fa310dc3a00fc8d7b353892de5"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a7bb300fa310dc3a00fc8d7b353892de5 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bb300fa310dc3a00fc8d7b353892de5">operator==</a> (const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;x, const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a7bb300fa310dc3a00fc8d7b353892de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two pairs of the same type are equal iff their members are equal after sorting.  <br /></td></tr>
<tr class="memitem:a28c8e50b495c78b108797d0fa25e30c3" id="r_a28c8e50b495c78b108797d0fa25e30c3"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a28c8e50b495c78b108797d0fa25e30c3 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28c8e50b495c78b108797d0fa25e30c3">operator&lt;</a> (const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;x, const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a28c8e50b495c78b108797d0fa25e30c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two pairs using lexicographic ordering.  <br /></td></tr>
<tr class="memitem:a99551f6e5616851814f382c6e2cdad66" id="r_a99551f6e5616851814f382c6e2cdad66"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a99551f6e5616851814f382c6e2cdad66 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99551f6e5616851814f382c6e2cdad66">operator!=</a> (const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;x, const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a99551f6e5616851814f382c6e2cdad66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether two <a class="el" href="structdrake_1_1_sorted_pair.html" title="This class is similar to the std::pair class.">SortedPair</a> objects are not equal using <span class="tt">operator==</span>.  <br /></td></tr>
<tr class="memitem:ad0dcb5fec94a56bb5d9cb4496aab181c" id="r_ad0dcb5fec94a56bb5d9cb4496aab181c"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:ad0dcb5fec94a56bb5d9cb4496aab181c template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0dcb5fec94a56bb5d9cb4496aab181c">operator&gt;</a> (const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;x, const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:ad0dcb5fec94a56bb5d9cb4496aab181c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <span class="tt">x &gt; y</span> using <span class="tt">operator&lt;</span>.  <br /></td></tr>
<tr class="memitem:a2a304872c147b8718725ee5aec091838" id="r_a2a304872c147b8718725ee5aec091838"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a2a304872c147b8718725ee5aec091838 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a304872c147b8718725ee5aec091838">operator&lt;=</a> (const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;x, const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a2a304872c147b8718725ee5aec091838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <span class="tt">x &lt;= y</span> using <span class="tt">operator&lt;</span>.  <br /></td></tr>
<tr class="memitem:a976cb6470ad6aaf19b3c35fcbd4c17f6" id="r_a976cb6470ad6aaf19b3c35fcbd4c17f6"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a976cb6470ad6aaf19b3c35fcbd4c17f6 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a976cb6470ad6aaf19b3c35fcbd4c17f6">operator&gt;=</a> (const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;x, const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a976cb6470ad6aaf19b3c35fcbd4c17f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether <span class="tt">x &gt;= y</span> using <span class="tt">operator&lt;</span>.  <br /></td></tr>
<tr class="memitem:a72635329c414630ebc3e3247b376131b" id="r_a72635329c414630ebc3e3247b376131b"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a72635329c414630ebc3e3247b376131b template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; typename std::decay&lt; T &gt;::type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72635329c414630ebc3e3247b376131b">MakeSortedPair</a> (T &amp;&amp;x, T &amp;&amp;y)</td></tr>
<tr class="memdesc:a72635329c414630ebc3e3247b376131b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper for creating a sorted pair from two objects.  <br /></td></tr>
<tr class="memitem:a898781913e4e5fa4287087afc880fec3" id="r_a898781913e4e5fa4287087afc880fec3"><td class="memTemplParams" colspan="2">template&lt;typename... Rest&gt; </td></tr>
<tr class="memitem:a898781913e4e5fa4287087afc880fec3 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a898781913e4e5fa4287087afc880fec3">cond</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;f_cond, double v_then, Rest... rest)</td></tr>
<tr class="memdesc:a898781913e4e5fa4287087afc880fec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides specialization of <code>cond</code> function defined in <a class="el" href="cond_8h.html">drake/common/cond.h</a> file.  <br /></td></tr>
<tr class="memitem:a77f0b9085e94fbc8908dc1f99327e28b" id="r_a77f0b9085e94fbc8908dc1f99327e28b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77f0b9085e94fbc8908dc1f99327e28b">ExtractDoubleOrThrow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a77f0b9085e94fbc8908dc1f99327e28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the symbolic expression's value() as a double.  <br /></td></tr>
<tr class="memitem:a6ebf51d3e031eb0226316624b990d04c" id="r_a6ebf51d3e031eb0226316624b990d04c"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a6ebf51d3e031eb0226316624b990d04c template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;, <a class="el" href="#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; double, Derived &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ebf51d3e031eb0226316624b990d04c">ExtractDoubleOrThrow</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix)</td></tr>
<tr class="memdesc:a6ebf51d3e031eb0226316624b990d04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code class="param">matrix</code> as an Eigen::Matrix&lt;double, ...&gt; with the same size allocation as <code class="param">matrix</code>.  <br /></td></tr>
<tr class="memitem:a848fb0ead47dfe2676e2ef81b8735e83" id="r_a848fb0ead47dfe2676e2ef81b8735e83"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a848fb0ead47dfe2676e2ef81b8735e83">temp_directory</a> ()</td></tr>
<tr class="memdesc:a848fb0ead47dfe2676e2ef81b8735e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a directory location suitable for temporary files.  <br /></td></tr>
<tr class="memitem:aa157c1d75c2e52df3370e5f458022ee9" id="r_aa157c1d75c2e52df3370e5f458022ee9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1logging.html#a9cae370466ffb304c10aebea42eca26b">logging::logger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa157c1d75c2e52df3370e5f458022ee9">log</a> ()</td></tr>
<tr class="memdesc:aa157c1d75c2e52df3370e5f458022ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an instance of a logger to use for logging; for example:  <br /></td></tr>
<tr class="memitem:a5d8d2d0a2bce6b5cbd9a0bf5c7e424de" id="r_a5d8d2d0a2bce6b5cbd9a0bf5c7e424de"><td class="memTemplParams" colspan="2">template&lt;typename Tag, typename U&gt; </td></tr>
<tr class="memitem:a5d8d2d0a2bce6b5cbd9a0bf5c7e424de template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral_v&lt; U &gt; &amp;&amp;std::is_unsigned_v&lt; U &gt;, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d8d2d0a2bce6b5cbd9a0bf5c7e424de">operator==</a> (const U &amp;value, const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;tag)</td></tr>
<tr class="memitem:adcc62c87e81d1f0042eeb4494e6ce196" id="r_adcc62c87e81d1f0042eeb4494e6ce196"><td class="memTemplParams" colspan="2">template&lt;typename Tag, typename U&gt; </td></tr>
<tr class="memitem:adcc62c87e81d1f0042eeb4494e6ce196 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral_v&lt; U &gt; &amp;&amp;std::is_unsigned_v&lt; U &gt;, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcc62c87e81d1f0042eeb4494e6ce196">operator!=</a> (const U &amp;value, const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;tag)</td></tr>
<tr class="memitem:a384c7fbbef42a1cc6a9de6280859c9c3" id="r_a384c7fbbef42a1cc6a9de6280859c9c3"><td class="memTemplParams" colspan="2">template&lt;typename Tag, typename U&gt; </td></tr>
<tr class="memitem:a384c7fbbef42a1cc6a9de6280859c9c3 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral_v&lt; U &gt; &amp;&amp;std::is_unsigned_v&lt; U &gt;, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a384c7fbbef42a1cc6a9de6280859c9c3">operator&lt;</a> (const U &amp;value, const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;tag)</td></tr>
<tr class="memitem:ab005cf901fa796e6359047cca655109a" id="r_ab005cf901fa796e6359047cca655109a"><td class="memTemplParams" colspan="2">template&lt;typename Tag, typename U&gt; </td></tr>
<tr class="memitem:ab005cf901fa796e6359047cca655109a template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral_v&lt; U &gt; &amp;&amp;std::is_unsigned_v&lt; U &gt;, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab005cf901fa796e6359047cca655109a">operator&lt;=</a> (const U &amp;value, const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;tag)</td></tr>
<tr class="memitem:aaf9b132f26a170831b3a0352bff7b133" id="r_aaf9b132f26a170831b3a0352bff7b133"><td class="memTemplParams" colspan="2">template&lt;typename Tag, typename U&gt; </td></tr>
<tr class="memitem:aaf9b132f26a170831b3a0352bff7b133 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral_v&lt; U &gt; &amp;&amp;std::is_unsigned_v&lt; U &gt;, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf9b132f26a170831b3a0352bff7b133">operator&gt;</a> (const U &amp;value, const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;tag)</td></tr>
<tr class="memitem:a0bafa7a8866f7785a6e357c474bae900" id="r_a0bafa7a8866f7785a6e357c474bae900"><td class="memTemplParams" colspan="2">template&lt;typename Tag, typename U&gt; </td></tr>
<tr class="memitem:a0bafa7a8866f7785a6e357c474bae900 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_integral_v&lt; U &gt; &amp;&amp;std::is_unsigned_v&lt; U &gt;, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bafa7a8866f7785a6e357c474bae900">operator&gt;=</a> (const U &amp;value, const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;tag)</td></tr>
<tr class="memitem:abcaeeaa04ecaa7cad4ea3bac4cb4aafd" id="r_abcaeeaa04ecaa7cad4ea3bac4cb4aafd"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:abcaeeaa04ecaa7cad4ea3bac4cb4aafd template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcaeeaa04ecaa7cad4ea3bac4cb4aafd">unused</a> (const Args &amp;...)</td></tr>
<tr class="memdesc:abcaeeaa04ecaa7cad4ea3bac4cb4aafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Documents the argument(s) as unused, placating GCC's -Wunused-parameter warning.  <br /></td></tr>
<tr class="memitem:a6f77603aea6d719b71744d902e66a84d" id="r_a6f77603aea6d719b71744d902e66a84d"><td class="memTemplParams" colspan="2">template&lt;typename Tag&gt; </td></tr>
<tr class="memitem:a6f77603aea6d719b71744d902e66a84d template"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_identifier.html#a6f77603aea6d719b71744d902e66a84d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classdrake_1_1_identifier.html">Identifier</a>&lt; Tag &gt; &amp;id)</td></tr>
<tr class="memdesc:a6f77603aea6d719b71744d902e66a84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming output operator.  <br /></td></tr>
<tr id="func-members-0" class="groupHeader"><td colspan="2"><div class="groupHeader">cond</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>Constructs conditional expression (similar to Lisp's cond).</p>
<pre class="fragment">  cond(cond_1, expr_1,
       cond_2, expr_2,
          ...,   ...,
       cond_n, expr_n,
       expr_{n+1})
</pre><p>The value returned by the above cond expression is <code>expr_1</code> if <code>cond_1</code> is true; else if <code>cond_2</code> is true then <code>expr_2</code>; ... ; else if <code>cond_n</code> is true then <code>expr_n</code>. If none of the conditions are true, it returns <code>expr_{n+1}</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This functions assumes that <code class="param">ScalarType</code> provides <code>operator&lt;</code> and the type of <code>f_cond</code> is the type of the return type of <span class="tt">operator&lt;(ScalarType,
ScalarType)</span>. For example, <code><a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a></code> can be used as a <code class="param">ScalarType</code> because it provides <span class="tt"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">symbolic::Formula</a>
operator&lt;(symbolic::Expression, symbolic::Expression)</span>. </dd></dl>
</div></td></tr>
<tr class="memitem:a39aaec46622357afe980113c771ea19d" id="r_a39aaec46622357afe980113c771ea19d"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType&gt; </td></tr>
<tr class="memitem:a39aaec46622357afe980113c771ea19d template"><td class="memItemLeft" align="right" valign="top">ScalarType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39aaec46622357afe980113c771ea19d">cond</a> (const ScalarType &amp;e)</td></tr>
<tr class="memitem:a94ec7781b1da45c01105982d4ed6f7d9" id="r_a94ec7781b1da45c01105982d4ed6f7d9"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType, typename... Rest&gt; </td></tr>
<tr class="memitem:a94ec7781b1da45c01105982d4ed6f7d9 template"><td class="memItemLeft" align="right" valign="top">ScalarType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94ec7781b1da45c01105982d4ed6f7d9">cond</a> (const decltype(ScalarType()&lt; ScalarType())&amp;f_cond, const ScalarType &amp;e_then, Rest... rest)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaf140364db7046208e67d85327722d34a" id="r_gaf140364db7046208e67d85327722d34a"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:gaf140364db7046208e67d85327722d34a template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__default__scalars.html#gaf140364db7046208e67d85327722d34a">is_default_scalar</a></td></tr>
<tr class="memitem:acd67fb791be292c340610dbcbd9b5b8f" id="r_acd67fb791be292c340610dbcbd9b5b8f"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd67fb791be292c340610dbcbd9b5b8f">eigen_all</a> = Eigen::placeholders::all</td></tr>
<tr class="memdesc:acd67fb791be292c340610dbcbd9b5b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A portable alias for Eigen::placeholders::all.  <br /></td></tr>
<tr class="memitem:aa39127b52b1d34b56cf3e6801cf31045" id="r_aa39127b52b1d34b56cf3e6801cf31045"><td class="memItemLeft" align="right" valign="top">const char *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa39127b52b1d34b56cf3e6801cf31045">kDrakeResourceRootEnvironmentVariableName</a></td></tr>
<tr class="memdesc:aa39127b52b1d34b56cf3e6801cf31045"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the environment variable that provides the first place where FindResource attempts to look.  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a90d91e75997a81a48adea1e83caddde4" name="a90d91e75997a81a48adea1e83caddde4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d91e75997a81a48adea1e83caddde4">&#9670;&#160;</a></span>AngleAxis</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a90d91e75997a81a48adea1e83caddde4">AngleAxis</a> = Eigen::AngleAxis&lt;Scalar&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An <a class="el" href="#a90d91e75997a81a48adea1e83caddde4" title="An AngleAxis templated on scalar type.">AngleAxis</a> templated on scalar type. </p>

</div>
</div>
<a id="a5f4077c4918078fb55bfb6b73968cb0a" name="a5f4077c4918078fb55bfb6b73968cb0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4077c4918078fb55bfb6b73968cb0a">&#9670;&#160;</a></span>AutoDiffd</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int num_vars&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5f4077c4918078fb55bfb6b73968cb0a">AutoDiffd</a> = Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, num_vars, 1&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An autodiff variable with <span class="tt">num_vars</span> partials. </p>

</div>
</div>
<a id="a790a072a62129732864a20e7a4743298" name="a790a072a62129732864a20e7a4743298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790a072a62129732864a20e7a4743298">&#9670;&#160;</a></span>AutoDiffVecd</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int num_vars, int rows&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a790a072a62129732864a20e7a4743298">AutoDiffVecd</a> = Eigen::Matrix&lt;<a class="el" href="#a5f4077c4918078fb55bfb6b73968cb0a">AutoDiffd</a>&lt;num_vars&gt;, rows, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector of <span class="tt">rows</span> autodiff variables, each with <span class="tt">num_vars</span> partials. </p>

</div>
</div>
<a id="a59eaaaa152841d234e829f38163a9981" name="a59eaaaa152841d234e829f38163a9981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59eaaaa152841d234e829f38163a9981">&#9670;&#160;</a></span>AutoDiffVecXd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a59eaaaa152841d234e829f38163a9981">AutoDiffVecXd</a> = Eigen::Matrix&lt;<a class="el" href="#a3d6302a0051e9403c9df3ed6808f3854">AutoDiffXd</a>, Eigen::Dynamic, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A dynamic-sized vector of autodiff variables. </p>

</div>
</div>
<a id="a3d6302a0051e9403c9df3ed6808f3854" name="a3d6302a0051e9403c9df3ed6808f3854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6302a0051e9403c9df3ed6808f3854">&#9670;&#160;</a></span>AutoDiffXd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a3d6302a0051e9403c9df3ed6808f3854">AutoDiffXd</a> = <a class="el" href="classdrake_1_1ad_1_1_auto_diff.html">drake::ad::AutoDiff</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A scalar type that performs automatic differentiation. </p>
<p>Always use this <span class="tt"><a class="el" href="#a3d6302a0051e9403c9df3ed6808f3854" title="A scalar type that performs automatic differentiation.">AutoDiffXd</a></span> alias when referring to the scalar type. </p>

</div>
</div>
<a id="a1f1c657c4d2cf400649123a7c2573d5b" name="a1f1c657c4d2cf400649123a7c2573d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1c657c4d2cf400649123a7c2573d5b">&#9670;&#160;</a></span>boolean</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a> = typename <a class="el" href="structdrake_1_1scalar__predicate.html">scalar_predicate</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alias for a boolean-like value, conditioned on the scalar type <span class="tt">T</span>. </p>
<p>In many cases this will be a synonym for <span class="tt">bool</span>, e.g., when <span class="tt">T = double</span>. When <span class="tt">T = <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a></span>, this is a synonym for <span class="tt"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">symbolic::Formula</a></span>. This is a convenience abbreviation for <a class="el" href="structdrake_1_1scalar__predicate.html#a945d5b96b85fa30cf7587ef08b38f3d2" title="The return type of predicates over T.">scalar_predicate&lt;T&gt;::type</a>. </p>

</div>
</div>
<a id="a323dc8b0cc629c61d4da8feeaa8cd4f5" name="a323dc8b0cc629c61d4da8feeaa8cd4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323dc8b0cc629c61d4da8feeaa8cd4f5">&#9670;&#160;</a></span>DefaultHash</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a323dc8b0cc629c61d4da8feeaa8cd4f5">DefaultHash</a> = <a class="el" href="structdrake_1_1uhash.html">drake::uhash</a>&lt;<a class="el" href="#a5a11519c4c803fc3f2118df94e858e95">DefaultHasher</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default hashing functor, akin to std::hash. </p>

</div>
</div>
<a id="a5a11519c4c803fc3f2118df94e858e95" name="a5a11519c4c803fc3f2118df94e858e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a11519c4c803fc3f2118df94e858e95">&#9670;&#160;</a></span>DefaultHasher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5a11519c4c803fc3f2118df94e858e95">DefaultHasher</a> = internal::FNV1aHasher</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default HashAlgorithm concept implementation across Drake. </p>
<p>This is guaranteed to have a result_type of <a class="el" href="classsize__t.html">size_t</a> to be compatible with std::hash. </p>

</div>
</div>
<a id="a08115460f0d38571bcd4445ca9d6ec18" name="a08115460f0d38571bcd4445ca9d6ec18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08115460f0d38571bcd4445ca9d6ec18">&#9670;&#160;</a></span>FileSource</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a08115460f0d38571bcd4445ca9d6ec18">FileSource</a> = std::variant&lt;std::filesystem::path, <a class="el" href="classdrake_1_1_memory_file.html">MemoryFile</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a file. </p>
<p>The file can be on-disk or in-memory. </p>

</div>
</div>
<a id="a158f68939b94f6c2c5ea353d652919da" name="a158f68939b94f6c2c5ea353d652919da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158f68939b94f6c2c5ea353d652919da">&#9670;&#160;</a></span>is_cloneable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a158f68939b94f6c2c5ea353d652919da">is_cloneable</a> = is_cloneable_internal::is_cloneable_helper&lt;T, void&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="is_cloneable_doc"></a>Provides method for determining at run time if a class is "cloneable". </p>
<p><b>Usage</b></p>
<p>This gets used like <span class="tt">type_traits</span> functions (e.g., <span class="tt">is_copy_constructible</span>, <span class="tt">is_same</span>, etc.) To determine if a class is cloneable simply invoke:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> value = <a class="code hl_typedef" href="#a158f68939b94f6c2c5ea353d652919da">drake::is_cloneable&lt;Foo&gt;::value</a>;</div>
<div class="ttc" id="anamespacedrake_html_a158f68939b94f6c2c5ea353d652919da"><div class="ttname"><a href="#a158f68939b94f6c2c5ea353d652919da">drake::is_cloneable</a></div><div class="ttdeci">is_cloneable_internal::is_cloneable_helper&lt; T, void &gt; is_cloneable</div><div class="ttdoc">Provides method for determining at run time if a class is &quot;cloneable&quot;.</div><div class="ttdef"><b>Definition</b> is_cloneable.h:81</div></div>
</div><!-- fragment --><p>If <span class="tt">Foo</span> is cloneable, it will evaluate to true. It can also be used in compile-time tests (e.g., SFINAE and <span class="tt">static_assert</span>s):</p>
<div class="fragment"><div class="line"><span class="keyword">static_assert</span>(<a class="code hl_typedef" href="#a158f68939b94f6c2c5ea353d652919da">is_cloneable&lt;Foo&gt;::value</a>, <span class="stringliteral">&quot;This method requires its classes to &quot;</span></div>
<div class="line">                                        <span class="stringliteral">&quot;be cloneable.&quot;</span>);</div>
</div><!-- fragment --><p><b>Definition of "cloneability"</b></p>
<p>To be cloneable, the class <span class="tt">Foo</span> must have a <em>public</em> method of the form: </p><div class="fragment"><div class="line">unique_ptr&lt;Foo&gt; Foo::Clone() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> Note that "friend" access for the is_cloneable-using class is not sufficient. The <span class="tt">Foo::Clone()</span> method must actually be public.</p>
<p>The pointer contained in the returned <span class="tt">unique_ptr</span> must point to a heap-allocated deep copy of the <em>concrete</em> object. This test can confirm the proper signature, but cannot confirm the heap-allocated deep copy. A Clone() method that doesn't return such a copy of the <em>concrete</em> object should be considered a malformed function.</p>
<dl class="section warning"><dt>Warning</dt><dd>It is important to note, that a <span class="tt">Clone()</span> method that returns a <span class="tt">unique_ptr</span> to a <em>super</em> class is <em>not</em> sufficient to be cloneable. In other words the presence of: <div class="fragment"><div class="line">unique_ptr&lt;Base&gt; Derived::Clone() <span class="keyword">const</span>;</div>
</div><!-- fragment --> will not make the <span class="tt">Derived</span> class cloneable.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The class to test for cloneability. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9eb383d64a842ca9002f66b2e10254aa" name="a9eb383d64a842ca9002f66b2e10254aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb383d64a842ca9002f66b2e10254aa">&#9670;&#160;</a></span>Isometry3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a> = Eigen::Transform&lt;Scalar, 3, Eigen::Isometry&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An Isometry templated on scalar type. </p>

</div>
</div>
<a id="a06406a5da633da84f911e2979aa48549" name="a06406a5da633da84f911e2979aa48549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06406a5da633da84f911e2979aa48549">&#9670;&#160;</a></span>Matrix2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a06406a5da633da84f911e2979aa48549">Matrix2</a> = Eigen::Matrix&lt;Scalar, 2, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 2 rows and 2 columns, templated on scalar type. </p>

</div>
</div>
<a id="af13883859324817e6310d04a6d2fe206" name="af13883859324817e6310d04a6d2fe206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13883859324817e6310d04a6d2fe206">&#9670;&#160;</a></span>Matrix2X</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af13883859324817e6310d04a6d2fe206">Matrix2X</a> = Eigen::Matrix&lt;Scalar, 2, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 2 rows, dynamic columns, templated on scalar type. </p>

</div>
</div>
<a id="a3922cc0c6264e8ff225a6aa0dd993667" name="a3922cc0c6264e8ff225a6aa0dd993667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3922cc0c6264e8ff225a6aa0dd993667">&#9670;&#160;</a></span>Matrix3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a> = Eigen::Matrix&lt;Scalar, 3, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 3 rows and 3 columns, templated on scalar type. </p>

</div>
</div>
<a id="acfe2dee57bc492bfbd96fe078b65ab00" name="acfe2dee57bc492bfbd96fe078b65ab00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe2dee57bc492bfbd96fe078b65ab00">&#9670;&#160;</a></span>Matrix3X</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a> = Eigen::Matrix&lt;Scalar, 3, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 3 rows, dynamic columns, templated on scalar type. </p>

</div>
</div>
<a id="ae74155a11dfcdaad0adc0349f0956148" name="ae74155a11dfcdaad0adc0349f0956148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74155a11dfcdaad0adc0349f0956148">&#9670;&#160;</a></span>Matrix4</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae74155a11dfcdaad0adc0349f0956148">Matrix4</a> = Eigen::Matrix&lt;Scalar, 4, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 4 rows and 4 columns, templated on scalar type. </p>

</div>
</div>
<a id="a585f047d94502e00bfb163347abbc771" name="a585f047d94502e00bfb163347abbc771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585f047d94502e00bfb163347abbc771">&#9670;&#160;</a></span>Matrix4X</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a585f047d94502e00bfb163347abbc771">Matrix4X</a> = Eigen::Matrix&lt;Scalar, 4, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 4 rows, dynamic columns, templated on scalar type. </p>

</div>
</div>
<a id="a11f9aa896d31437a219ed19fa944fe20" name="a11f9aa896d31437a219ed19fa944fe20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f9aa896d31437a219ed19fa944fe20">&#9670;&#160;</a></span>Matrix6</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a11f9aa896d31437a219ed19fa944fe20">Matrix6</a> = Eigen::Matrix&lt;Scalar, 6, 6&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 6 rows and 6 columns, templated on scalar type. </p>

</div>
</div>
<a id="a668e1152f8b876967b9093ae4d95298b" name="a668e1152f8b876967b9093ae4d95298b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668e1152f8b876967b9093ae4d95298b">&#9670;&#160;</a></span>Matrix6X</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a668e1152f8b876967b9093ae4d95298b">Matrix6X</a> = Eigen::Matrix&lt;Scalar, 6, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 6 rows, dynamic columns, templated on scalar type. </p>

</div>
</div>
<a id="ae2b0be18a912f9cacfec6d0a0a6d873c" name="ae2b0be18a912f9cacfec6d0a0a6d873c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b0be18a912f9cacfec6d0a0a6d873c">&#9670;&#160;</a></span>Matrix6xUpTo6</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae2b0be18a912f9cacfec6d0a0a6d873c">Matrix6xUpTo6</a> = Eigen::Matrix&lt;Scalar, 6, Eigen::Dynamic, 0, 6, 6&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of 6 rows and dynamic column size up to a maximum of 6, templated on scalar type. </p>

</div>
</div>
<a id="aae413ce2f94f0ecb301727a6781b69ff" name="aae413ce2f94f0ecb301727a6781b69ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae413ce2f94f0ecb301727a6781b69ff">&#9670;&#160;</a></span>MatrixLikewise</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    Eigen::Matrix&lt;Scalar, Derived::RowsAtCompileTime,</div>
<div class="line">                  Derived::ColsAtCompileTime,</div>
<div class="line">                  Derived::IsRowMajor ? Eigen::RowMajor : Eigen::ColMajor,</div>
<div class="line">                  Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime&gt;</div>
</div><!-- fragment -->
<p>A matrix with the same compile-time sizes and storage order as Derived, but with a different scalar type and its default alignment (Eigen::AutoAlign). </p>

</div>
</div>
<a id="abac76c309b7189051aa03fdd116aacd1" name="abac76c309b7189051aa03fdd116aacd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac76c309b7189051aa03fdd116aacd1">&#9670;&#160;</a></span>MatrixUpTo6</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#abac76c309b7189051aa03fdd116aacd1">MatrixUpTo6</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    Eigen::Matrix&lt;Scalar, Eigen::Dynamic, Eigen::Dynamic, 0, 6, 6&gt;</div>
</div><!-- fragment -->
<p>A matrix of dynamic size templated on scalar type, up to a maximum of 6 rows and 6 columns. </p>
<p>Rectangular matrices, with different number of rows and columns, are allowed. </p>

</div>
</div>
<a id="a28c58d881c60e96f48a7a4e32a699b95" name="a28c58d881c60e96f48a7a4e32a699b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c58d881c60e96f48a7a4e32a699b95">&#9670;&#160;</a></span>MatrixX</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a> = Eigen::Matrix&lt;Scalar, Eigen::Dynamic, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A matrix of dynamic size, templated on scalar type. </p>

</div>
</div>
<a id="ab0a2621977171e1d2d5b64c55141b9b2" name="ab0a2621977171e1d2d5b64c55141b9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a2621977171e1d2d5b64c55141b9b2">&#9670;&#160;</a></span>Polynomiald</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt;double&gt; <a class="el" href="#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4156bf453a5b323356d7cc784dfdf084" name="a4156bf453a5b323356d7cc784dfdf084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4156bf453a5b323356d7cc784dfdf084">&#9670;&#160;</a></span>Quaternion</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4156bf453a5b323356d7cc784dfdf084">Quaternion</a> = Eigen::Quaternion&lt;Scalar&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A quaternion templated on scalar type. </p>

</div>
</div>
<a id="a3eb9dffa1f3d48e4c5fe406e5a4617fe" name="a3eb9dffa1f3d48e4c5fe406e5a4617fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb9dffa1f3d48e4c5fe406e5a4617fe">&#9670;&#160;</a></span>RowVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, int Cols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a3eb9dffa1f3d48e4c5fe406e5a4617fe">RowVector</a> = Eigen::Matrix&lt;Scalar, 1, Cols&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A row vector templated on the number of columns. </p>

</div>
</div>
<a id="afc54e1f7aa3341a5f6b305705452d9bd" name="afc54e1f7aa3341a5f6b305705452d9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc54e1f7aa3341a5f6b305705452d9bd">&#9670;&#160;</a></span>RowVector2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#afc54e1f7aa3341a5f6b305705452d9bd">RowVector2</a> = Eigen::Matrix&lt;Scalar, 1, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A row vector of size 2, templated on scalar type. </p>

</div>
</div>
<a id="aee4ae0d841ea1629551bf77fd5d9ec9e" name="aee4ae0d841ea1629551bf77fd5d9ec9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4ae0d841ea1629551bf77fd5d9ec9e">&#9670;&#160;</a></span>RowVector3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aee4ae0d841ea1629551bf77fd5d9ec9e">RowVector3</a> = Eigen::Matrix&lt;Scalar, 1, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A row vector of size 3, templated on scalar type. </p>

</div>
</div>
<a id="aa9b373b2971391d9054b431d8a3e4b33" name="aa9b373b2971391d9054b431d8a3e4b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b373b2971391d9054b431d8a3e4b33">&#9670;&#160;</a></span>RowVector4</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aa9b373b2971391d9054b431d8a3e4b33">RowVector4</a> = Eigen::Matrix&lt;Scalar, 1, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A row vector of size 4, templated on scalar type. </p>

</div>
</div>
<a id="a3ad88c2d704ccb2899d475d3ae05de14" name="a3ad88c2d704ccb2899d475d3ae05de14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad88c2d704ccb2899d475d3ae05de14">&#9670;&#160;</a></span>RowVector6</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a3ad88c2d704ccb2899d475d3ae05de14">RowVector6</a> = Eigen::Matrix&lt;Scalar, 1, 6&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A row vector of size 6. </p>

</div>
</div>
<a id="a218f39990d2d9090c7a25c9c18cbf832" name="a218f39990d2d9090c7a25c9c18cbf832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218f39990d2d9090c7a25c9c18cbf832">&#9670;&#160;</a></span>RowVectorX</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a218f39990d2d9090c7a25c9c18cbf832">RowVectorX</a> = Eigen::Matrix&lt;Scalar, 1, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A row vector of any size, templated on scalar type. </p>

</div>
</div>
<a id="ad5de4c858064cf0a457d6a18381e837b" name="ad5de4c858064cf0a457d6a18381e837b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5de4c858064cf0a457d6a18381e837b">&#9670;&#160;</a></span>StrideX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ad5de4c858064cf0a457d6a18381e837b">StrideX</a> = Eigen::Stride&lt;Eigen::Dynamic, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A fully dynamic Eigen stride. </p>

</div>
</div>
<a id="a9de8c1164370b94e59f07071e3d37231" name="a9de8c1164370b94e59f07071e3d37231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de8c1164370b94e59f07071e3d37231">&#9670;&#160;</a></span>string_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9de8c1164370b94e59f07071e3d37231">string_map</a> = std::map&lt;std::string, T, std::less&lt;void&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <span class="tt">std::map&lt;std::string, T&gt;</span>, but with better defaults than the plain <span class="tt">std::map&lt;std::string, T&gt;</span> spelling. </p>
<p>We need <span class="tt">std::less&lt;void&gt;</span> as the comparison function so that <span class="tt">std::string_view</span> and <span class="tt">const char*</span> can be used as lookup keys without copying them to a <span class="tt">std::string</span>. </p>

</div>
</div>
<a id="a5df4f70ad81fe7daff15f9a9ce9b8edf" name="a5df4f70ad81fe7daff15f9a9ce9b8edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df4f70ad81fe7daff15f9a9ce9b8edf">&#9670;&#160;</a></span>string_multimap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5df4f70ad81fe7daff15f9a9ce9b8edf">string_multimap</a> = std::multimap&lt;std::string, T, std::less&lt;void&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <span class="tt">std::multimap&lt;std::string, T&gt;</span>, but with better defaults than the plain <span class="tt">std::multimap&lt;std::string, T&gt;</span> spelling. </p>
<p>We need <span class="tt">std::less&lt;void&gt;</span> as the comparison function so that <span class="tt">std::string_view</span> and <span class="tt">const char*</span> can be used as lookup keys without copying them to a <span class="tt">std::string</span>. </p>

</div>
</div>
<a id="a66eb3331428a0a762d12c6130ae0fdcb" name="a66eb3331428a0a762d12c6130ae0fdcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66eb3331428a0a762d12c6130ae0fdcb">&#9670;&#160;</a></span>string_multiset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a66eb3331428a0a762d12c6130ae0fdcb">string_multiset</a> = std::multiset&lt;std::string, std::less&lt;void&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <span class="tt">std::multiset&lt;std::string&gt;</span>, but with better defaults than the plain <span class="tt">std::multiset&lt;std::string&gt;</span> spelling. </p>
<p>We need <span class="tt">std::less&lt;void&gt;</span> as the comparison function so that <span class="tt">std::string_view</span> and <span class="tt">const char*</span> can be used as lookup keys without copying them to a <span class="tt">std::string</span>. </p>

</div>
</div>
<a id="abaab955b1414eeecd13a7fe3d79b6422" name="abaab955b1414eeecd13a7fe3d79b6422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaab955b1414eeecd13a7fe3d79b6422">&#9670;&#160;</a></span>string_set</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#abaab955b1414eeecd13a7fe3d79b6422">string_set</a> = std::set&lt;std::string, std::less&lt;void&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <span class="tt">std::set&lt;std::string&gt;</span>, but with better defaults than the plain <span class="tt">std::set&lt;std::string&gt;</span> spelling. </p>
<p>We need <span class="tt">std::less&lt;void&gt;</span> as the comparison function so that <span class="tt">std::string_view</span> and <span class="tt">const char*</span> can be used as lookup keys without copying them to a <span class="tt">std::string</span>. </p>

</div>
</div>
<a id="a42ead4ab3ea15652a58208871dde4238" name="a42ead4ab3ea15652a58208871dde4238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ead4ab3ea15652a58208871dde4238">&#9670;&#160;</a></span>string_unordered_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a42ead4ab3ea15652a58208871dde4238">string_unordered_map</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::unordered_map&lt;std::string, T, internal::StringHash,</div>
<div class="line">                       std::equal_to&lt;void&gt;&gt;</div>
</div><!-- fragment -->
<p>Like <span class="tt">std::unordered_map&lt;std::string, T&gt;</span>, but with better defaults than the plain <span class="tt">std::unordered_map&lt;std::string, T&gt;</span> spelling. </p>
<p>We need the custom hash and comparison functions so that <span class="tt">std::string_view</span> and <span class="tt">const char*</span> can be used as lookup keys without copying them to a <span class="tt">std::string</span>. </p>

</div>
</div>
<a id="adcca06c39e67c5fb9588f30dd77f868c" name="adcca06c39e67c5fb9588f30dd77f868c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcca06c39e67c5fb9588f30dd77f868c">&#9670;&#160;</a></span>string_unordered_multimap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#adcca06c39e67c5fb9588f30dd77f868c">string_unordered_multimap</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::unordered_multimap&lt;std::string, T, internal::StringHash,</div>
<div class="line">                            std::equal_to&lt;void&gt;&gt;</div>
</div><!-- fragment -->
<p>Like <span class="tt">std::unordered_multimap&lt;std::string, T&gt;</span>, but with better defaults than the plain <span class="tt">std::unordered_multimap&lt;std::string, T&gt;</span> spelling. </p>
<p>We need the custom hash and comparison functions so that <span class="tt">std::string_view</span> and <span class="tt">const
char*</span> can be used as lookup keys without copying them to a <span class="tt">std::string</span>. </p>

</div>
</div>
<a id="acf1f478dc725be9a5579b3ce44f9816e" name="acf1f478dc725be9a5579b3ce44f9816e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1f478dc725be9a5579b3ce44f9816e">&#9670;&#160;</a></span>string_unordered_multiset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#acf1f478dc725be9a5579b3ce44f9816e">string_unordered_multiset</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::unordered_multiset&lt;std::string, internal::StringHash,</div>
<div class="line">                            std::equal_to&lt;void&gt;&gt;</div>
</div><!-- fragment -->
<p>Like <span class="tt">std::unordered_multiset&lt;std::string&gt;</span>, but with better defaults than the plain <span class="tt">std::unordered_multiset&lt;std::string&gt;</span> spelling. </p>
<p>We need the custom hash and comparison functions so that <span class="tt">std::string_view</span> and <span class="tt">const char*</span> can be used as lookup keys without copying them to a <span class="tt">std::string</span>. </p>

</div>
</div>
<a id="a786c9cdb32bd0bdebbaeda107f9dbb2b" name="a786c9cdb32bd0bdebbaeda107f9dbb2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786c9cdb32bd0bdebbaeda107f9dbb2b">&#9670;&#160;</a></span>string_unordered_set</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a786c9cdb32bd0bdebbaeda107f9dbb2b">string_unordered_set</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::unordered_set&lt;std::string, internal::StringHash, std::equal_to&lt;void&gt;&gt;</div>
</div><!-- fragment -->
<p>Like <span class="tt">std::unordered_set&lt;std::string&gt;</span>, but with better defaults than the plain <span class="tt">std::unordered_set&lt;std::string&gt;</span> spelling. </p>
<p>We need the custom hash and comparison functions so that <span class="tt">std::string_view</span> and <span class="tt">const char*</span> can be used as lookup keys without copying them to a <span class="tt">std::string</span>. </p>

</div>
</div>
<a id="a01ae662d5635b7c9efe03d15d976f7a8" name="a01ae662d5635b7c9efe03d15d976f7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ae662d5635b7c9efe03d15d976f7a8">&#9670;&#160;</a></span>Vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar, int Rows&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a01ae662d5635b7c9efe03d15d976f7a8">Vector</a> = Eigen::Matrix&lt;Scalar, Rows, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector templated on the number of rows. </p>

</div>
</div>
<a id="acda0b15d77e4c1701d160b17a2cb2ea8" name="acda0b15d77e4c1701d160b17a2cb2ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda0b15d77e4c1701d160b17a2cb2ea8">&#9670;&#160;</a></span>Vector0</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#acda0b15d77e4c1701d160b17a2cb2ea8">Vector0</a> = Eigen::Matrix&lt;Scalar, 0, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The empty column vector (zero rows, one column), templated on scalar type. </p>

</div>
</div>
<a id="af359dfdb84d6c13b606bb3ed7b821e23" name="af359dfdb84d6c13b606bb3ed7b821e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af359dfdb84d6c13b606bb3ed7b821e23">&#9670;&#160;</a></span>Vector1</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af359dfdb84d6c13b606bb3ed7b821e23">Vector1</a> = Eigen::Matrix&lt;Scalar, 1, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of size 1 (that is, a scalar), templated on scalar type. </p>

</div>
</div>
<a id="a6d923e79e6e92c2556edd86520145077" name="a6d923e79e6e92c2556edd86520145077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d923e79e6e92c2556edd86520145077">&#9670;&#160;</a></span>Vector1d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a6d923e79e6e92c2556edd86520145077">Vector1d</a> = Eigen::Matrix&lt;double, 1, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of size 1 of doubles. </p>

</div>
</div>
<a id="ab9f8b7dbd727440c2dd207bf43812f1e" name="ab9f8b7dbd727440c2dd207bf43812f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f8b7dbd727440c2dd207bf43812f1e">&#9670;&#160;</a></span>Vector2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab9f8b7dbd727440c2dd207bf43812f1e">Vector2</a> = Eigen::Matrix&lt;Scalar, 2, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of size 2, templated on scalar type. </p>

</div>
</div>
<a id="a0ad29daab565ce347c4d1c5aae6a76c2" name="a0ad29daab565ce347c4d1c5aae6a76c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad29daab565ce347c4d1c5aae6a76c2">&#9670;&#160;</a></span>Vector3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a> = Eigen::Matrix&lt;Scalar, 3, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of size 3, templated on scalar type. </p>

</div>
</div>
<a id="af7e96394aef85f13f3fc84d3c3c238b3" name="af7e96394aef85f13f3fc84d3c3c238b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e96394aef85f13f3fc84d3c3c238b3">&#9670;&#160;</a></span>Vector4</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a> = Eigen::Matrix&lt;Scalar, 4, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of size 4, templated on scalar type. </p>

</div>
</div>
<a id="a14aa433aedda321a15238f2d4074d4c3" name="a14aa433aedda321a15238f2d4074d4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14aa433aedda321a15238f2d4074d4c3">&#9670;&#160;</a></span>Vector6</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a14aa433aedda321a15238f2d4074d4c3">Vector6</a> = Eigen::Matrix&lt;Scalar, 6, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of size 6. </p>

</div>
</div>
<a id="a44f103cf5fdeb3f539ceeeb9cd3a0a28" name="a44f103cf5fdeb3f539ceeeb9cd3a0a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f103cf5fdeb3f539ceeeb9cd3a0a28">&#9670;&#160;</a></span>Vector6d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a44f103cf5fdeb3f539ceeeb9cd3a0a28">Vector6d</a> = Eigen::Matrix&lt;double, 6, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of size 6 of doubles. </p>

</div>
</div>
<a id="adfbacdba0566fe8958cfafd659b4373f" name="adfbacdba0566fe8958cfafd659b4373f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfbacdba0566fe8958cfafd659b4373f">&#9670;&#160;</a></span>VectorUpTo6</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#adfbacdba0566fe8958cfafd659b4373f">VectorUpTo6</a> = Eigen::Matrix&lt;Scalar, Eigen::Dynamic, 1, 0, 6, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector of dynamic size templated on scalar type, up to a maximum of 6 elements. </p>

</div>
</div>
<a id="a77dd228fb4dd66a2c17dd3f7f38ffd85" name="a77dd228fb4dd66a2c17dd3f7f38ffd85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77dd228fb4dd66a2c17dd3f7f38ffd85">&#9670;&#160;</a></span>VectorX</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a> = Eigen::Matrix&lt;Scalar, Eigen::Dynamic, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of any size, templated on scalar type. </p>

</div>
</div>
<a id="a00cbebcd97766579bb36e35abcf44acf" name="a00cbebcd97766579bb36e35abcf44acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00cbebcd97766579bb36e35abcf44acf">&#9670;&#160;</a></span>VectorXPoly</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;<a class="el" href="#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a>, Eigen::Dynamic, 1&gt; <a class="el" href="#a00cbebcd97766579bb36e35abcf44acf">VectorXPoly</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A column vector of polynomials; used in several optimization classes. </p>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="a72383be4710d27584d0821effc6506a5" name="a72383be4710d27584d0821effc6506a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72383be4710d27584d0821effc6506a5">&#9670;&#160;</a></span>RandomDistribution</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a72383be4710d27584d0821effc6506a5">RandomDistribution</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drake supports explicit reasoning about a few carefully chosen random distributions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a72383be4710d27584d0821effc6506a5a3ea9f7aca87fd7b64469a0d1119f0b50" name="a72383be4710d27584d0821effc6506a5a3ea9f7aca87fd7b64469a0d1119f0b50"></a>kUniform&#160;</td><td class="fielddoc"><p><a class="el" href="#a01ae662d5635b7c9efe03d15d976f7a8" title="A column vector templated on the number of rows.">Vector</a> elements are independent and uniformly distributed ∈ [0.0, 1.0). </p>
</td></tr>
<tr><td class="fieldname"><a id="a72383be4710d27584d0821effc6506a5ab933cd0242085c2dbf804dbf288ce7f0" name="a72383be4710d27584d0821effc6506a5ab933cd0242085c2dbf804dbf288ce7f0"></a>kGaussian&#160;</td><td class="fielddoc"><p><a class="el" href="#a01ae662d5635b7c9efe03d15d976f7a8" title="A column vector templated on the number of rows.">Vector</a> elements are independent and drawn from a mean-zero, unit-variance normal (Gaussian) distribution. </p>
</td></tr>
<tr><td class="fieldname"><a id="a72383be4710d27584d0821effc6506a5a601bf5851ffd28f5e6219c0f1945c8d6" name="a72383be4710d27584d0821effc6506a5a601bf5851ffd28f5e6219c0f1945c8d6"></a>kExponential&#160;</td><td class="fielddoc"><p><a class="el" href="#a01ae662d5635b7c9efe03d15d976f7a8" title="A column vector templated on the number of rows.">Vector</a> elements are independent and drawn from an exponential distribution with λ=1.0. </p>
</td></tr>
</table>

</div>
</div>
<a id="af8777bc10296f9d39d52753861110e26" name="af8777bc10296f9d39d52753861110e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8777bc10296f9d39d52753861110e26">&#9670;&#160;</a></span>ToleranceType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#af8777bc10296f9d39d52753861110e26">ToleranceType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af8777bc10296f9d39d52753861110e26abab0767e88027de9944aa55c24c8387a" name="af8777bc10296f9d39d52753861110e26abab0767e88027de9944aa55c24c8387a"></a>kAbsolute&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af8777bc10296f9d39d52753861110e26af460a96ab20647996c15854794763384" name="af8777bc10296f9d39d52753861110e26af460a96ab20647996c15854794763384"></a>kRelative&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a6f017505f166d0b60735ba1c4a9b4f23" name="a6f017505f166d0b60735ba1c4a9b4f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f017505f166d0b60735ba1c4a9b4f23">&#9670;&#160;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar all </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks truth for all elements in matrix <code class="param">m</code>. </p>
<p>This is identical to <span class="tt">Eigen::DenseBase::all()</span>, except this function allows for lazy evaluation, so works even when <a class="el" href="structdrake_1_1scalar__predicate.html#ab6fdcd06e06c892b3492eb6ea8f15be2" title="Whether type is bool.">scalar_predicate&lt;&gt;::is_bool</a> does not hold. An empty matrix returns true. </p>

</div>
</div>
<a id="a58bef16b035645d48c9d032a977d7680" name="a58bef16b035645d48c9d032a977d7680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58bef16b035645d48c9d032a977d7680">&#9670;&#160;</a></span>all_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt; all_of </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;(const typename Derived::Scalar &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate <code class="param">pred</code> holds for all elements in the matrix <code class="param">m</code>. </p>
<p>An empty matrix returns true. </p>

</div>
</div>
<a id="a044a99d40c78d36c585451760f6a8513" name="a044a99d40c78d36c585451760f6a8513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044a99d40c78d36c585451760f6a8513">&#9670;&#160;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar any </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks truth for at least one element in matrix <code class="param">m</code>. </p>
<p>This is identical to <span class="tt">Eigen::DenseBase::any()</span>, except this function allows for lazy evaluation, so works even when <a class="el" href="structdrake_1_1scalar__predicate.html#ab6fdcd06e06c892b3492eb6ea8f15be2" title="Whether type is bool.">scalar_predicate&lt;&gt;::is_bool</a> does not hold. An empty matrix returns false. </p>

</div>
</div>
<a id="a2cca690674b317f8f5781d064cacf2ed" name="a2cca690674b317f8f5781d064cacf2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cca690674b317f8f5781d064cacf2ed">&#9670;&#160;</a></span>any_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt; any_of </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;(const typename Derived::Scalar &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate <code class="param">pred</code> holds for at least one element in the matrix <code class="param">m</code>. </p>
<p>An empty matrix returns false. </p>

</div>
</div>
<a id="ae05268ef42cdcf5bf9eba8c8a9b28e76" name="ae05268ef42cdcf5bf9eba8c8a9b28e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05268ef42cdcf5bf9eba8c8a9b28e76">&#9670;&#160;</a></span>CalcProbabilityDensity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T CalcProbabilityDensity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a72383be4710d27584d0821effc6506a5">RandomDistribution</a></td>          <td class="paramname"><span class="paramname"><em>distribution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the density (probability density function) of the multivariate distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distribution</td><td>The distribution type. </td></tr>
    <tr><td class="paramname">x</td><td>The value of the sampled vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default nonsymbolic scalars</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When instantiating this function, the user needs to explicitly pass in the scalar type, for example CalcProbabilityDensity&lt;double&gt;(...), the compiler might have problem to deduce the scalar type automatically. </dd></dl>

</div>
</div>
<a id="a7ac422c010c8ccd5708c43d12459b211" name="a7ac422c010c8ccd5708c43d12459b211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac422c010c8ccd5708c43d12459b211">&#9670;&#160;</a></span>cond() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1ad_1_1_auto_diff.html">ad::AutoDiff</a> cond </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>f_cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1ad_1_1_auto_diff.html">ad::AutoDiff</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e_then</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rest...</td>          <td class="paramname"><span class="paramname"><em>rest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides cond base for AutoDiff. </p>
<p>Overloads <a class="el" href="#a032afe843cdaa8b1e28e99344d84ab9d" title="Provides cond&#39;s base case for AutoDiff.">cond()</a> from <span class="tt"><a class="el" href="double__overloads_8h.html" title="Provides necessary operations on double to have it as a ScalarType in drake.">drake/common/double_overloads.h</a></span>. </p>

</div>
</div>
<a id="aa937e4c404b7e9c2c433f4dae17ee783" name="aa937e4c404b7e9c2c433f4dae17ee783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa937e4c404b7e9c2c433f4dae17ee783">&#9670;&#160;</a></span>cond() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerType, typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::AutoDiffScalar&lt; typename Eigen::internal::remove_all&lt; DerType &gt;::type::PlainObject &gt; cond </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>f_cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::AutoDiffScalar&lt; DerType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>e_then</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rest...</td>          <td class="paramname"><span class="paramname"><em>rest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides special case of cond expression for Eigen::AutoDiffScalar type. </p>

</div>
</div>
<a id="a032afe843cdaa8b1e28e99344d84ab9d" name="a032afe843cdaa8b1e28e99344d84ab9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032afe843cdaa8b1e28e99344d84ab9d">&#9670;&#160;</a></span>cond() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1ad_1_1_auto_diff.html">ad::AutoDiff</a> cond </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1ad_1_1_auto_diff.html">ad::AutoDiff</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides cond's base case for AutoDiff. </p>
<p>Overloads <a class="el" href="#a032afe843cdaa8b1e28e99344d84ab9d" title="Provides cond&#39;s base case for AutoDiff.">cond()</a> from <span class="tt"><a class="el" href="double__overloads_8h.html" title="Provides necessary operations on double to have it as a ScalarType in drake.">drake/common/double_overloads.h</a></span>. </p>

</div>
</div>
<a id="a94ec7781b1da45c01105982d4ed6f7d9" name="a94ec7781b1da45c01105982d4ed6f7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ec7781b1da45c01105982d4ed6f7d9">&#9670;&#160;</a></span>cond() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType, typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ScalarType cond </td>
          <td>(</td>
          <td class="paramtype">const decltype(ScalarType()&lt; ScalarType())&amp;</td>          <td class="paramname"><span class="paramname"><em>f_cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;</td>          <td class="paramname"><span class="paramname"><em>e_then</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rest...</td>          <td class="paramname"><span class="paramname"><em>rest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a39aaec46622357afe980113c771ea19d" name="a39aaec46622357afe980113c771ea19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39aaec46622357afe980113c771ea19d">&#9670;&#160;</a></span>cond() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ScalarType cond </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a898781913e4e5fa4287087afc880fec3" name="a898781913e4e5fa4287087afc880fec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898781913e4e5fa4287087afc880fec3">&#9670;&#160;</a></span>cond() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> cond </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">symbolic::Formula</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f_cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>v_then</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rest...</td>          <td class="paramname"><span class="paramname"><em>rest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides specialization of <code>cond</code> function defined in <a class="el" href="cond_8h.html">drake/common/cond.h</a> file. </p>
<p>This specialization is required to handle <code>double</code> to <code><a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a></code> conversion so that we can write one such as <span class="tt"><a class="el" href="#a032afe843cdaa8b1e28e99344d84ab9d" title="Provides cond&#39;s base case for AutoDiff.">cond</a>(x &gt;
0.0, 1.0, -1.0)</span>. </p>

</div>
</div>
<a id="acbd230a9a1c01f99255cff20bbaf543e" name="acbd230a9a1c01f99255cff20bbaf543e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd230a9a1c01f99255cff20bbaf543e">&#9670;&#160;</a></span>dynamic_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; T &gt; dynamic_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; U &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts the object owned by the std::unique_ptr <span class="tt">other</span> from type <span class="tt">U</span> to <span class="tt">T</span>; if the cast fails, returns nullptr. </p>
<p>Casting is performed using <span class="tt">dynamic_cast</span> on the managed value (i.e., the result of <span class="tt">other.get()</span>). On success, <span class="tt">other</span>'s managed value is transferred to the result and <span class="tt">other</span> is empty; on failure, <span class="tt">other</span> will retain its original managed value and the result is empty. As with <span class="tt">dynamic_cast</span>, casting nullptr to anything always succeeds, so a nullptr result could indicate either that the argument was nullptr or that the cast failed.</p>
<p>This method is analogous to the built-in std::dynamic_pointer_cast that operates on a std::shared_ptr.</p>
<p>Note that this function only supports default deleters. </p>

</div>
</div>
<a id="a8bb3c50cd860a96af4593008942bc7ef" name="a8bb3c50cd860a96af4593008942bc7ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb3c50cd860a96af4593008942bc7ef">&#9670;&#160;</a></span>dynamic_pointer_cast_or_throw() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; T &gt; dynamic_pointer_cast_or_throw </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; U &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts the object owned by the std::unique_ptr <span class="tt">other</span> from type <span class="tt">U</span> to <span class="tt">T</span>; if <span class="tt">other</span> is nullptr or the cast fails, throws a std::exception. </p>
<p>Casting is performed using <span class="tt">dynamic_cast</span> on the managed value (i.e., the result of <span class="tt">other.get()</span>). On success, <span class="tt">other</span>'s managed value is transferred to the result and <span class="tt">other</span> is empty; on failure, <span class="tt">other</span> will retain its original managed value.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the cast fails.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that this function only supports default deleters. </p>

</div>
</div>
<a id="a3d362cd0d2c845da2124c3f3914329a0" name="a3d362cd0d2c845da2124c3f3914329a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d362cd0d2c845da2124c3f3914329a0">&#9670;&#160;</a></span>dynamic_pointer_cast_or_throw() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * dynamic_pointer_cast_or_throw </td>
          <td>(</td>
          <td class="paramtype">U *</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts the pointer <span class="tt">other</span> from type <span class="tt">U</span> to <span class="tt">T</span> using <span class="tt">dynamic_cast</span>. </p>
<p>The result is never nullptr.</p>
<p>This differs from the C++ built-in dynamic_cast by providing a nicer exception message, and always throwing on any failure.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">other</span> is nullptr or the cast fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a116c0ad7d2958e26a9b16795bcae1672" name="a116c0ad7d2958e26a9b16795bcae1672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116c0ad7d2958e26a9b16795bcae1672">&#9670;&#160;</a></span>EigenMapView()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto EigenMapView </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a random access container (like std::vector, std::array, or C array), returns an Eigen::Map view into that container. </p>
<p>Because this effectively forms a reference to borrowed memory, you must be be careful using the return value as anything other than a temporary. The Map return value currently uses Eigen::Dynamic size at compile time even when the container is fixed-size (e.g., std::array); if that ever turns into a performance bottleneck in practice, it would be plausible to interrogate the size and return a fixed-size Map, instead. </p>

</div>
</div>
<a id="a76aa07d781c1d9b7db80d218dd28b66a" name="a76aa07d781c1d9b7db80d218dd28b66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76aa07d781c1d9b7db80d218dd28b66a">&#9670;&#160;</a></span>ExtractDoubleOrThrow() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ExtractDoubleOrThrow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1ad_1_1_auto_diff.html">ad::AutoDiff</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the autodiff scalar's value() as a double. </p>
<p>Never throws. Overloads <a class="el" href="#a76aa07d781c1d9b7db80d218dd28b66a" title="Returns the autodiff scalar&#39;s value() as a double.">ExtractDoubleOrThrow()</a> from <span class="tt"><a class="el" href="extract__double_8h.html">drake/common/extract_double.h</a></span>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1math.html#a511506438ea2d8b648ef31f7957f118b" title="Extracts the value() portion from an AutoDiffScalar matrix into a pre-existing matrix (resizing if ne...">math::ExtractValue()</a>, <a class="el" href="namespacedrake_1_1math.html#aa6b853dffb7141874967340f9a18f4eb" title="B = DiscardGradient(A) enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar typ...">math::DiscardGradient()</a> </dd></dl>

</div>
</div>
<a id="ad0da43c947d3694c1051212d4043d07e" name="ad0da43c947d3694c1051212d4043d07e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0da43c947d3694c1051212d4043d07e">&#9670;&#160;</a></span>ExtractDoubleOrThrow() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double ExtractDoubleOrThrow </td>
          <td>(</td>
          <td class="paramtype">const Eigen::AutoDiffScalar&lt; DerType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the autodiff scalar's value() as a double. </p>
<p>Never throws. Overloads ExtractDoubleOrThrow from <a class="el" href="extract__double_8h.html">common/extract_double.h</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1math.html#a511506438ea2d8b648ef31f7957f118b" title="Extracts the value() portion from an AutoDiffScalar matrix into a pre-existing matrix (resizing if ne...">math::ExtractValue()</a>, <a class="el" href="namespacedrake_1_1math.html#aa6b853dffb7141874967340f9a18f4eb" title="B = DiscardGradient(A) enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar typ...">math::DiscardGradient()</a> </dd></dl>

</div>
</div>
<a id="a3a84c0102427116efee16d9170058116" name="a3a84c0102427116efee16d9170058116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a84c0102427116efee16d9170058116">&#9670;&#160;</a></span>ExtractDoubleOrThrow() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, double &gt;, <a class="el" href="#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; double, Derived &gt; &gt; ExtractDoubleOrThrow </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code class="param">matrix</code> as an Eigen::Matrix&lt;double, ...&gt; with the same size allocation as <code class="param">matrix</code>. </p>
<p>Calls ExtractDoubleOrThrow on each element of the matrix, and therefore throws if any one of the extractions fail. </p>

</div>
</div>
<a id="a6ebf51d3e031eb0226316624b990d04c" name="a6ebf51d3e031eb0226316624b990d04c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ebf51d3e031eb0226316624b990d04c">&#9670;&#160;</a></span>ExtractDoubleOrThrow() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;, <a class="el" href="#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; double, Derived &gt; &gt; ExtractDoubleOrThrow </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code class="param">matrix</code> as an Eigen::Matrix&lt;double, ...&gt; with the same size allocation as <code class="param">matrix</code>. </p>
<p>Calls ExtractDoubleOrThrow on each element of the matrix, and therefore throws if any one of the extractions fail. </p>

</div>
</div>
<a id="af77f42953b424b906077b9b7daa0bdf8" name="af77f42953b424b906077b9b7daa0bdf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77f42953b424b906077b9b7daa0bdf8">&#9670;&#160;</a></span>ExtractDoubleOrThrow() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int RowsAtCompileTime, int ColsAtCompileTime, int Options, int MaxRowsAtCompileTime, int MaxColsAtCompileTime&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ExtractDoubleOrThrow </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Eigen::Matrix&lt; <a class="el" href="classdrake_1_1ad_1_1_auto_diff.html">ad::AutoDiff</a>, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="tt">matrix</span> as an Eigen::Matrix&lt;double, ...&gt; with the same size allocation as <span class="tt">matrix</span>. </p>
<p>Calls ExtractDoubleOrThrow on each element of the matrix, and therefore throws if any one of the extractions fail. Overloads <a class="el" href="#a76aa07d781c1d9b7db80d218dd28b66a" title="Returns the autodiff scalar&#39;s value() as a double.">ExtractDoubleOrThrow()</a> from <span class="tt"><a class="el" href="extract__double_8h.html">drake/common/extract_double.h</a></span>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1math.html#a511506438ea2d8b648ef31f7957f118b" title="Extracts the value() portion from an AutoDiffScalar matrix into a pre-existing matrix (resizing if ne...">math::ExtractValue()</a>, <a class="el" href="namespacedrake_1_1math.html#aa6b853dffb7141874967340f9a18f4eb" title="B = DiscardGradient(A) enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar typ...">math::DiscardGradient()</a> </dd></dl>

</div>
</div>
<a id="a4f91267b864bbde5457e4adac3e417fe" name="a4f91267b864bbde5457e4adac3e417fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f91267b864bbde5457e4adac3e417fe">&#9670;&#160;</a></span>ExtractDoubleOrThrow() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerType, int RowsAtCompileTime, int ColsAtCompileTime, int Options, int MaxRowsAtCompileTime, int MaxColsAtCompileTime&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ExtractDoubleOrThrow </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Eigen::Matrix&lt; Eigen::AutoDiffScalar&lt; DerType &gt;, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code class="param">matrix</code> as an Eigen::Matrix&lt;double, ...&gt; with the same size allocation as <code class="param">matrix</code>. </p>
<p>Calls ExtractDoubleOrThrow on each element of the matrix, and therefore throws if any one of the extractions fail. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1math.html#a511506438ea2d8b648ef31f7957f118b" title="Extracts the value() portion from an AutoDiffScalar matrix into a pre-existing matrix (resizing if ne...">math::ExtractValue()</a>, <a class="el" href="namespacedrake_1_1math.html#aa6b853dffb7141874967340f9a18f4eb" title="B = DiscardGradient(A) enables casting from a matrix of AutoDiffScalars to AutoDiffScalar::Scalar typ...">math::DiscardGradient()</a> </dd></dl>

</div>
</div>
<a id="a77f0b9085e94fbc8908dc1f99327e28b" name="a77f0b9085e94fbc8908dc1f99327e28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f0b9085e94fbc8908dc1f99327e28b">&#9670;&#160;</a></span>ExtractDoubleOrThrow() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ExtractDoubleOrThrow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the symbolic expression's value() as a double. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if it is not possible to evaluate the symbolic expression with an empty environment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a327205de415417316eb87214fbb1b469" name="a327205de415417316eb87214fbb1b469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327205de415417316eb87214fbb1b469">&#9670;&#160;</a></span>ExtractDoubleOrThrow() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ExtractDoubleOrThrow </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code class="param">scalar</code> as a double. Never throws. </p>

</div>
</div>
<a id="aa4436e37f057bca66547eabb27b3243a" name="aa4436e37f057bca66547eabb27b3243a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4436e37f057bca66547eabb27b3243a">&#9670;&#160;</a></span>ExtractDoubleOrThrow() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ExtractDoubleOrThrow </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code class="param">scalar</code> as a double. Never throws. </p>

</div>
</div>
<a id="a6d12a9fa5bded2c0de25138421b0e1d7" name="a6d12a9fa5bded2c0de25138421b0e1d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d12a9fa5bded2c0de25138421b0e1d7">&#9670;&#160;</a></span>FindResource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_find_resource_result.html">FindResourceResult</a> FindResource </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>resource_path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Attempts to locate a Drake resource named by the given <span class="tt">resource_path</span>. </p>
<p>The <span class="tt">resource_path</span> refers to the relative path within the Drake source repository, prepended with <span class="tt">drake/</span>. For example, to find the source file <span class="tt">examples/pendulum/Pendulum.urdf</span>, the <span class="tt">resource_path</span> would be <span class="tt">drake/examples/pendulum/Pendulum.urdf</span>. Paths that do not start with <span class="tt">drake/</span> will return an error result. The <span class="tt">resource_path</span> must refer to a file (not a directory).</p>
<p>The search scans for the resource in the following resource roots and in the following order:</p>
<ol type="1">
<li>In the DRAKE_RESOURCE_ROOT environment variable.</li>
<li>In the Bazel runfiles for a bazel-bin/pkg/program.</li>
<li>In the Drake CMake install directory.</li>
</ol>
<p>The first resource root from the list that exists is used to find any and all Drake resources. If the resource root does not contain the resource, the result is an error even (if a resource root lower on the list happens to have the resource). If all three roots are unavailable, then returns an error result. </p>

</div>
</div>
<a id="ab1402fc7fba316744f96586956e7a752" name="ab1402fc7fba316744f96586956e7a752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1402fc7fba316744f96586956e7a752">&#9670;&#160;</a></span>FindResourceOrThrow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string FindResourceOrThrow </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>resource_path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Convenient wrapper for querying FindResource(resource_path) followed by <a class="el" href="classdrake_1_1_find_resource_result.html#a85ae127f2c62d94a37ba9190bb9ed0cf" title="Either returns the get_absolute_path() iff the resource was found, or else throws std::exception.">FindResourceResult::get_absolute_path_or_throw()</a>. </p>
<p>The primary purpose of this function is for Drake's software internals to locate Drake resources (e.g., config files) within Drake's build system. In most cases, end users should not need to use it.</p>
<p>Do NOT use this function to feed into a drake::multibody::parsing::Parser. Instead, use parser.AddModelsFromUrl() in coordination with the parser's PackageMap. </p>

</div>
</div>
<a id="ae7b592b35122cdfc472bd8bf9d35df7a" name="ae7b592b35122cdfc472bd8bf9d35df7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b592b35122cdfc472bd8bf9d35df7a">&#9670;&#160;</a></span>FindRunfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1_rlocation_or_error.html">RlocationOrError</a> FindRunfile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>resource_path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>source_repository</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced.) Returns the absolute path to the given <span class="tt">resource_path</span> from Bazel runfiles, or else an error message when not found. </p>
<p>When <a class="el" href="#a2f411cee985f933195d5f37ef45e0cc6" title="(Advanced.) Returns true iff this process has Bazel runfiles available.">HasRunfiles()</a> is false, returns an error.</p>
<dl class="section note"><dt>Note</dt><dd>For Drake Developers, note that in an installed copy of Drake (e.g., in a binary release) the <a class="el" href="#a2f411cee985f933195d5f37ef45e0cc6" title="(Advanced.) Returns true iff this process has Bazel runfiles available.">HasRunfiles()</a> check will return <span class="tt">false</span>, so this function will return an error. That means it's generally ill-advised to call this function from library code inside Drake, or if you do you'll need to have a fallback plan in case of an error. Typically our library code should be calling <a class="el" href="#a6d12a9fa5bded2c0de25138421b0e1d7" title="(Advanced) Attempts to locate a Drake resource named by the given resource_path.">FindResource()</a> not <a class="el" href="#ae7b592b35122cdfc472bd8bf9d35df7a" title="(Advanced.) Returns the absolute path to the given resource_path from Bazel runfiles,...">FindRunfile()</a>. On the other hand, for our private code like unit tests and benchmarks, it's fine to call this function and in those programs it's also fine to leave the source_repository defaulted (empty).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resource_path</td><td>The path to find, formulated as the repository name followed by package and filename, e.g., "repository/topdir/subdir/file.ext". Drake resource paths look like "drake/common/foo.txt".</td></tr>
    <tr><td class="paramname">source_repository</td><td>When looking up a Drake runfile, this value is ignored (and therefore may be set to anything). Otherwise, it should be set to the value of the preprocessor definition <span class="tt">BAZEL_CURRENT_REPOSITORY</span> or else when running with bzlmod enabled you risk using an incorrect repo_mapping. That preprocessor definition is Bazel magic that takes on <em>different values</em> depending on which translation unit is being compiled (and is undefined unless you add Bazel's runfiles library to your own library's <span class="tt">deps = ...</span> directly), so cannot be used as the default value here. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc57f8ba3471c69c959f961a287666ac" name="afc57f8ba3471c69c959f961a287666ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc57f8ba3471c69c959f961a287666ac">&#9670;&#160;</a></span>fmt_debug_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string fmt_debug_string </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="tt"><a class="el" href="namespacefmt.html">fmt</a>::("{:?}", x)</span>, i.e, using fmt's "debug string format"; see <a href="https://fmt.dev">https://fmt.dev</a> docs for the '? </p>
<p>' presentation type for details. We provide this wrapper because not all of our supported platforms have a new-enough fmt to rely on it. On platforms with older fmt, we use a Drake re-implementation of the feature that does NOT handle unicode correctly. </p>

</div>
</div>
<a id="a0655e16a159b287851163900c29d2b4f" name="a0655e16a159b287851163900c29d2b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0655e16a159b287851163900c29d2b4f">&#9670;&#160;</a></span>fmt_eigen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::fmt_eigen_ref&lt; typename Derived::Scalar &gt; fmt_eigen </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When passing an Eigen::Matrix to fmt, use this wrapper function to instruct fmt to use Drake's custom formatter for Eigen types. </p>
<p>Within Drake, when formatting an Eigen matrix into a string you must wrap the Eigen object as <span class="tt">fmt_eigen(M)</span>. This holds true whether it be for logging, error messages, debugging, or etc.</p>
<p>For example: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (!CheckValid(M)) {</div>
<div class="line">  <span class="keywordflow">throw</span> std::logic_error(fmt::format(<span class="stringliteral">&quot;Invalid M = {}&quot;</span>, <a class="code hl_function" href="#a0655e16a159b287851163900c29d2b4f">fmt_eigen</a>(M)));</div>
<div class="line">}</div>
<div class="ttc" id="anamespacedrake_html_a0655e16a159b287851163900c29d2b4f"><div class="ttname"><a href="#a0655e16a159b287851163900c29d2b4f">drake::fmt_eigen</a></div><div class="ttdeci">internal::fmt_eigen_ref&lt; typename Derived::Scalar &gt; fmt_eigen(const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix)</div><div class="ttdoc">When passing an Eigen::Matrix to fmt, use this wrapper function to instruct fmt to use Drake&#39;s custom...</div><div class="ttdef"><b>Definition</b> fmt_eigen.h:77</div></div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The return value of this function should only ever be used as a temporary object, i.e., in a fmt argument list or a logging statement argument list. Never store it as a local variable, member field, etc.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>To ensure floating-point data is formatted without losing any digits, Drake's code is compiled using -DEIGEN_NO_IO, which enforces that nothing within Drake is allowed to use Eigen's <span class="tt">operator&lt;&lt;</span>. Downstream code that calls into Drake is not required to use that option; it is only enforced by Drake's build system, not by Drake's headers. </dd></dl>

</div>
</div>
<a id="a78ab22f7a42b8921faafd7b6ffb341fd" name="a78ab22f7a42b8921faafd7b6ffb341fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ab22f7a42b8921faafd7b6ffb341fd">&#9670;&#160;</a></span>fmt_floating_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; <br />
requires (std::is_same_v&lt;T, float&gt; || std::is_same_v&lt;T, double&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">std::string fmt_floating_point </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="tt">fmt::to_string(x)</span> but always with at least one digit after the decimal point. </p>
<p>Different versions of fmt disagree on whether to omit the trailing ".0" when formatting integer-valued floating-point numbers. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>must be either <span class="tt">float</span> or <span class="tt">double</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af432bd3fe5b5d4786e7473b3a26cd877" name="af432bd3fe5b5d4786e7473b3a26cd877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af432bd3fe5b5d4786e7473b3a26cd877">&#9670;&#160;</a></span>fmt_runtime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto fmt_runtime </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When using fmt &gt;= 8, this is an alias for <a href="https://fmt.dev/latest/api.html#compile-time-format-string-checks">fmt::runtime</a>. </p>
<p>When using fmt &lt; 8, this is a no-op. </p>

</div>
</div>
<a id="a65ba5721a088bacdc594dab652fc7e1c" name="a65ba5721a088bacdc594dab652fc7e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ba5721a088bacdc594dab652fc7e1c">&#9670;&#160;</a></span>fmt_streamed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto fmt_streamed </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>ref</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When using fmt &gt;= 9, this is an alias for <a href="https://fmt.dev/latest/api.html#ostream-api">fmt::streamed</a>. </p>
<p>When using fmt &lt; 9, this uses a polyfill instead.</p>
<p>Within Drake, the nominal use for <span class="tt">fmt::streamed</span> is when formatting third-party types that provide <span class="tt">operator&lt;&lt;</span> support but not <span class="tt">fmt::formatter&lt;T&gt;</span> support. Once we stop using <span class="tt">FMT_DEPRECATED_OSTREAM=1</span>, compilation errors will help you understand where you are required to use this wrapper. </p>

</div>
</div>
<a id="a4b8152b4424b80d9e9775da4d29b8746" name="a4b8152b4424b80d9e9775da4d29b8746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8152b4424b80d9e9775da4d29b8746">&#9670;&#160;</a></span>hash_append() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashAlgorithm, class Traits, class Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;</td>          <td class="paramname"><span class="paramname"><em>hasher</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; char, Traits, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::string. </p>
<p>(Technically, any string based on <span class="tt">CharT = char</span>.) </p>

</div>
</div>
<a id="ad2c80c0eacf567c675541a92ff161fd0" name="ad2c80c0eacf567c675541a92ff161fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c80c0eacf567c675541a92ff161fd0">&#9670;&#160;</a></span>hash_append() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashAlgorithm, class T1, class T2, class Compare, class Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;</td>          <td class="paramname"><span class="paramname"><em>hasher</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; T1, T2, Compare, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::map. </p>
<p>Note that there is no <span class="tt"><a class="el" href="#af07565c94853b4bbb124bf870969e3ff" title="Provides hash_append generic hashing for integral constants.">hash_append</a></span> overload for <span class="tt">std::unordered_map</span>. See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3980.html#unordered">N3980</a> for details. </p>

</div>
</div>
<a id="a98bb4cd952e51e277fc40dc5e7e9b2c8" name="a98bb4cd952e51e277fc40dc5e7e9b2c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98bb4cd952e51e277fc40dc5e7e9b2c8">&#9670;&#160;</a></span>hash_append() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashAlgorithm, class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;</td>          <td class="paramname"><span class="paramname"><em>hasher</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::optional. </p>
<p>Note that <span class="tt">std::hash&lt;std::optional&lt;T&gt;&gt;</span> provides the peculiar invariant that the hash of an <span class="tt">optional</span> bearing a value <span class="tt">v</span> shall evaluate to the same hash as that of the value <span class="tt">v</span> itself. Hash operations implemented with this <span class="tt"><a class="el" href="#af07565c94853b4bbb124bf870969e3ff" title="Provides hash_append generic hashing for integral constants.">hash_append</a></span> do <em>not</em> provide that invariant. </p>

</div>
</div>
<a id="a180f010d174a68db7ca96ebb81c1471f" name="a180f010d174a68db7ca96ebb81c1471f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180f010d174a68db7ca96ebb81c1471f">&#9670;&#160;</a></span>hash_append() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashAlgorithm, class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;</td>          <td class="paramname"><span class="paramname"><em>hasher</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; T1, T2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::pair. </p>

</div>
</div>
<a id="a1db7c5cf9556e82dd4fe8f79321ca8e5" name="a1db7c5cf9556e82dd4fe8f79321ca8e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db7c5cf9556e82dd4fe8f79321ca8e5">&#9670;&#160;</a></span>hash_append() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashAlgorithm, class Key, class Compare, class Allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;</td>          <td class="paramname"><span class="paramname"><em>hasher</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; Key, Compare, Allocator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for std::set. </p>
<p>Note that there is no <span class="tt"><a class="el" href="#af07565c94853b4bbb124bf870969e3ff" title="Provides hash_append generic hashing for integral constants.">hash_append</a></span> overload for <span class="tt">std::unordered_set</span>. See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3980.html#unordered">N3980</a> for details. </p>

</div>
</div>
<a id="aa59b8cb1f61857c789dff87021bf054e" name="aa59b8cb1f61857c789dff87021bf054e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59b8cb1f61857c789dff87021bf054e">&#9670;&#160;</a></span>hash_append() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashAlgorithm, class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_floating_point_v&lt; T &gt; &gt; hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;</td>          <td class="paramname"><span class="paramname"><em>hasher</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for floating point values. </p>

</div>
</div>
<a id="aff8e43fae4fbd53d5d9be5e4bdab7909" name="aff8e43fae4fbd53d5d9be5e4bdab7909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8e43fae4fbd53d5d9be5e4bdab7909">&#9670;&#160;</a></span>hash_append() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashAlgorithm, class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_enum_v&lt; T &gt; &gt; hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;</td>          <td class="paramname"><span class="paramname"><em>hasher</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for enumerations. </p>

</div>
</div>
<a id="af07565c94853b4bbb124bf870969e3ff" name="af07565c94853b4bbb124bf870969e3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07565c94853b4bbb124bf870969e3ff">&#9670;&#160;</a></span>hash_append() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashAlgorithm, class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &gt; hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;</td>          <td class="paramname"><span class="paramname"><em>hasher</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for integral constants. </p>

</div>
</div>
<a id="af61c35d443d2f52d05829da878f12532" name="af61c35d443d2f52d05829da878f12532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61c35d443d2f52d05829da878f12532">&#9670;&#160;</a></span>hash_append() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashAlgorithm, class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;</td>          <td class="paramname"><span class="paramname"><em>hasher</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>item</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for bare pointers. </p>

</div>
</div>
<a id="a6aea25059ddf8d6feeca13d2f3ec5783" name="a6aea25059ddf8d6feeca13d2f3ec5783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aea25059ddf8d6feeca13d2f3ec5783">&#9670;&#160;</a></span>hash_append_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HashAlgorithm, class Iter&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hash_append_range </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;</td>          <td class="paramname"><span class="paramname"><em>hasher</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides <a class="el" href="group__hash__append.html">hash_append generic hashing</a> for a range, as given by two iterators. </p>

</div>
</div>
<a id="a2f411cee985f933195d5f37ef45e0cc6" name="a2f411cee985f933195d5f37ef45e0cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f411cee985f933195d5f37ef45e0cc6">&#9670;&#160;</a></span>HasRunfiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasRunfiles </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced.) Returns true iff this process has Bazel runfiles available. </p>
<p>For both C++ and Python programs, and no matter what workspace a program resides in (<span class="tt">@<a class="el" href="namespacedrake.html">drake</a></span> or otherwise), this will be true when running <span class="tt">bazel-bin/pkg/program</span> or <span class="tt">bazel test //pkg:program</span> or <span class="tt">bazel run
//pkg:program</span>. </p>

</div>
</div>
<a id="a3e8eeef2d39f7e0d858b79aac4efd952" name="a3e8eeef2d39f7e0d858b79aac4efd952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8eeef2d39f7e0d858b79aac4efd952">&#9670;&#160;</a></span>if_then_else() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1ad_1_1_auto_diff.html">ad::AutoDiff</a> if_then_else </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>f_cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1ad_1_1_auto_diff.html">ad::AutoDiff</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1ad_1_1_auto_diff.html">ad::AutoDiff</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides if-then-else expression for AutoDiff. </p>
<p>Overloads <a class="el" href="#a3e8eeef2d39f7e0d858b79aac4efd952" title="Provides if-then-else expression for AutoDiff.">if_then_else()</a> from <span class="tt"><a class="el" href="double__overloads_8h.html" title="Provides necessary operations on double to have it as a ScalarType in drake.">drake/common/double_overloads.h</a></span>. </p>

</div>
</div>
<a id="aeb46699dc47883f5ac4d81f95d8756f1" name="aeb46699dc47883f5ac4d81f95d8756f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb46699dc47883f5ac4d81f95d8756f1">&#9670;&#160;</a></span>if_then_else() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerType1, typename DerType2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::AutoDiffScalar&lt; typename Eigen::internal::remove_all&lt; DerType1 &gt;::type::PlainObject &gt; if_then_else </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>f_cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::AutoDiffScalar&lt; DerType1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::AutoDiffScalar&lt; DerType2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides if-then-else expression for Eigen::AutoDiffScalar type. </p>
<p>To support Eigen's generic expressions, we use casting to the plain object after applying Eigen::internal::remove_all. It is based on the Eigen's implementation of min/max function for AutoDiffScalar type (<a href="https://bitbucket.org/eigen/eigen/src/10a1de58614569c9250df88bdfc6402024687bc6/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h?at=default&amp;fileviewer=file-view-default#AutoDiffScalar.h-546">https://bitbucket.org/eigen/eigen/src/10a1de58614569c9250df88bdfc6402024687bc6/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h?at=default&amp;fileviewer=file-view-default#AutoDiffScalar.h-546</a>). </p>

</div>
</div>
<a id="a64f6df74b46df7d595a8510ba6f3a72d" name="a64f6df74b46df7d595a8510ba6f3a72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f6df74b46df7d595a8510ba6f3a72d">&#9670;&#160;</a></span>if_then_else() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double if_then_else </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>f_cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>v_then</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>v_else</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides if-then-else expression for double. </p>
<p>The value returned by the if-then-else expression is <code class="param">v_then</code> if <code class="param">f_cond</code> is <code>true</code>. Otherwise, it returns <code class="param">v_else</code>. The semantics is similar but not exactly the same as C++'s conditional expression constructed by its ternary operator, <code></code>?:. In <span class="tt">if_then_else(f_cond, v_then, v_else)</span>, both of <code class="param">v_then</code> and <code class="param">v_else</code> are evaluated regardless of the evaluation of <code class="param">f_cond</code>. In contrast, only one of <code class="param">v_then</code> or <code class="param">v_else</code> is evaluated in C++'s conditional expression <span class="tt">f_cond ? v_then : v_else</span>. </p>

</div>
</div>
<a id="a9e802890ec66861781b5204d68fb6ec9" name="a9e802890ec66861781b5204d68fb6ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e802890ec66861781b5204d68fb6ec9">&#9670;&#160;</a></span>if_then_else() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int Rows&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto if_then_else </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f_cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Rows, 1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m_then</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Rows, 1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m_else</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads if_then_else for Eigen vectors of <span class="tt">m_then</span> and <span class="tt">m_else</span> values with with a single <span class="tt">f_cond</span> condition to toggle them all at once. </p>

</div>
</div>
<a id="afc8546dc6818041c65c64ee824685e74" name="afc8546dc6818041c65c64ee824685e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8546dc6818041c65c64ee824685e74">&#9670;&#160;</a></span>is_approx_equal_abstol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_approx_equal_abstol </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if and only if the two matrices are equal to within a certain absolute elementwise <code class="param">tolerance</code>. </p>
<p>Special values (infinities, NaN, etc.) do not compare as equal elements. </p>

</div>
</div>
<a id="a15ebb98c217bdb150425d0175b37e827" name="a15ebb98c217bdb150425d0175b37e827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ebb98c217bdb150425d0175b37e827">&#9670;&#160;</a></span>IsApproxEqualAbsTolWithPermutedColumns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA, typename DerivedB&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool IsApproxEqualAbsTolWithPermutedColumns </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if and only if a simple greedy search reveals a permutation of the columns of m2 to make the matrix equal to m1 to within a certain absolute elementwise <code class="param">tolerance</code>. </p>
<p>E.g., there exists a P such that </p><pre>
   forall i,j,  |m1 - m2*P|_{i,j} &lt;= tolerance
   where P is a permutation matrix:
      P(i,j)={0,1}, sum_i P(i,j)=1, sum_j P(i,j)=1.
</pre><p> Note: Returns false for matrices of different sizes. Note: The current implementation is O(n^2) in the number of columns. Note: In marginal cases (with similar but not identical columns) this algorithm can fail to find a permutation P even if it exists because it accepts the first column match (m1(i),m2(j)) and removes m2(j) from the pool. It is possible that other columns of m2 would also match m1(i) but that m2(j) is the only match possible for a later column of m1. </p>

</div>
</div>
<a id="a26037cbd8a3c6a7dd5a0c7f1259bd18f" name="a26037cbd8a3c6a7dd5a0c7f1259bd18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26037cbd8a3c6a7dd5a0c7f1259bd18f">&#9670;&#160;</a></span>LoadedLibraryPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::string &gt; LoadedLibraryPath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>library_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the absolute path of the library with the name <span class="tt">library_name</span> if that library was loaded in the current running process. </p>
<p>Otherwise it returns an empty optional. </p>

</div>
</div>
<a id="aa157c1d75c2e52df3370e5f458022ee9" name="aa157c1d75c2e52df3370e5f458022ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa157c1d75c2e52df3370e5f458022ee9">&#9670;&#160;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1logging.html#a9cae370466ffb304c10aebea42eca26b">logging::logger</a> * log </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve an instance of a logger to use for logging; for example: </p>
<pre>
  <a class="el" href="#aa157c1d75c2e52df3370e5f458022ee9" title="Retrieve an instance of a logger to use for logging; for example:">drake::log()</a>-&gt;info("potato!")
</pre><p>See the <a class="el" href="text__logging_8h.html" title="This is the entry point for all text logging within Drake.">text_logging.h</a> documentation for a short tutorial. </p>

</div>
</div>
<a id="a59728afb061f73e8235575806ed811f8" name="a59728afb061f73e8235575806ed811f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59728afb061f73e8235575806ed811f8">&#9670;&#160;</a></span>MakeNameValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_name_value.html">NameValue</a>&lt; T &gt; MakeNameValue </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Creates a <a class="el" href="classdrake_1_1_name_value.html" title="(Advanced) A basic implementation of the Name-Value Pair concept as used in the Serialize / Archive p...">NameValue</a>. </p>
<p>The conventional method for calling this function is the DRAKE_NVP sugar macro below.</p>
<p>Both pointers are aliased for the lifetime of the return value. </p>

</div>
</div>
<a id="a72635329c414630ebc3e3247b376131b" name="a72635329c414630ebc3e3247b376131b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72635329c414630ebc3e3247b376131b">&#9670;&#160;</a></span>MakeSortedPair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; typename std::decay&lt; T &gt;::type &gt; MakeSortedPair </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A convenience wrapper for creating a sorted pair from two objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The first_ object. </td></tr>
    <tr><td class="paramname">y</td><td>The second_ object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly-constructed <a class="el" href="structdrake_1_1_sorted_pair.html" title="This class is similar to the std::pair class.">SortedPair</a> object. </dd></dl>

</div>
</div>
<a id="a2eb77bb30f5d469dbfda988cf8da6475" name="a2eb77bb30f5d469dbfda988cf8da6475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb77bb30f5d469dbfda988cf8da6475">&#9670;&#160;</a></span>MaybeGetDrakePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::string &gt; MaybeGetDrakePath </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Returns the fully-qualified path to the first folder containing Drake resources as located by FindResource, or nullopt if none is found. </p>
<p>For example <span class="tt">${result}/examples/pendulum/Pendulum.urdf</span> would be the path to the Pendulum example's URDF resource.</p>
<p>Most users should prefer <a class="el" href="#a6d12a9fa5bded2c0de25138421b0e1d7" title="(Advanced) Attempts to locate a Drake resource named by the given resource_path.">FindResource()</a> or <a class="el" href="#ab1402fc7fba316744f96586956e7a752" title="(Advanced) Convenient wrapper for querying FindResource(resource_path) followed by FindResourceResult...">FindResourceOrThrow()</a> to locate Drake resources for a specific resource filename. This method only exists for legacy compatibility reasons, and might eventually be removed. </p>

</div>
</div>
<a id="ad43049d1b6ef4ac0baf74355cc5ddfcb" name="ad43049d1b6ef4ac0baf74355cc5ddfcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43049d1b6ef4ac0baf74355cc5ddfcb">&#9670;&#160;</a></span>none()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar none </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that no elements of <code class="param">m</code> are true. An empty matrix returns true. </p>

</div>
</div>
<a id="a4151f6cb087cd5b1cdc40e43cb1f7284" name="a4151f6cb087cd5b1cdc40e43cb1f7284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4151f6cb087cd5b1cdc40e43cb1f7284">&#9670;&#160;</a></span>none_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt; none_of </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; typename Derived::Scalar &gt;(const typename Derived::Scalar &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if unary predicate <code class="param">pred</code> holds for no elements in the matrix <code class="param">m</code>. </p>
<p>An empty matrix returns true. </p>

</div>
</div>
<a id="a99551f6e5616851814f382c6e2cdad66" name="a99551f6e5616851814f382c6e2cdad66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99551f6e5616851814f382c6e2cdad66">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether two <a class="el" href="structdrake_1_1_sorted_pair.html" title="This class is similar to the std::pair class.">SortedPair</a> objects are not equal using <span class="tt">operator==</span>. </p>

</div>
</div>
<a id="adcc62c87e81d1f0042eeb4494e6ce196" name="adcc62c87e81d1f0042eeb4494e6ce196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc62c87e81d1f0042eeb4494e6ce196">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag, typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_integral_v&lt; U &gt; &amp;&amp;std::is_unsigned_v&lt; U &gt;, bool &gt; operator!= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a28c8e50b495c78b108797d0fa25e30c3" name="a28c8e50b495c78b108797d0fa25e30c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c8e50b495c78b108797d0fa25e30c3">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two pairs using lexicographic ordering. </p>

</div>
</div>
<a id="a384c7fbbef42a1cc6a9de6280859c9c3" name="a384c7fbbef42a1cc6a9de6280859c9c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384c7fbbef42a1cc6a9de6280859c9c3">&#9670;&#160;</a></span>operator&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag, typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_integral_v&lt; U &gt; &amp;&amp;std::is_unsigned_v&lt; U &gt;, bool &gt; operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8db300eaec345b10d2e808b900239b8e" name="a8db300eaec345b10d2e808b900239b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db300eaec345b10d2e808b900239b8e">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int Rows, int Cols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt;, Rows, Cols &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>poly_mat</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated</a></b></dt><dd>Wrap Eigen objects M with fmt_eigen() to format Eigen data into fmt  strings e.g., fmt::to_string(fmt_eigen(M)),  fmt::format(\M = {}\, fmt_eigen(M)). You'll need to  #include \drake/common/fmt_eigen.h\ to access that function.  Refer to GitHub issue #17742 for more information. <br  />
 This will be removed from Drake on or after 2026-06-01. </dd></dl>

</div>
</div>
<a id="a6349afb82c0796366e318e99f25c3e5f" name="a6349afb82c0796366e318e99f25c3e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6349afb82c0796366e318e99f25c3e5f">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>poly</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated</a></b></dt><dd>Use fmt functions instead (e.g., fmt::format(), fmt::to_string(),  fmt::print()). Refer to GitHub issue #17742 for more information. <br  />
 This will be removed from Drake on or after 2026-06-01. </dd></dl>

</div>
</div>
<a id="a24d3bbc3fbb363dfb7cdc7ff5c71c850" name="a24d3bbc3fbb363dfb7cdc7ff5c71c850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d3bbc3fbb363dfb7cdc7ff5c71c850">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt;::Monomial &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated</a></b></dt><dd>Use fmt functions instead (e.g., fmt::format(), fmt::to_string(),  fmt::print()). Refer to GitHub issue #17742 for more information. <br  />
 This will be removed from Drake on or after 2026-06-01. </dd></dl>

</div>
</div>
<a id="a2a304872c147b8718725ee5aec091838" name="a2a304872c147b8718725ee5aec091838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a304872c147b8718725ee5aec091838">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether <span class="tt">x &lt;= y</span> using <span class="tt">operator&lt;</span>. </p>

</div>
</div>
<a id="ab005cf901fa796e6359047cca655109a" name="ab005cf901fa796e6359047cca655109a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab005cf901fa796e6359047cca655109a">&#9670;&#160;</a></span>operator&lt;=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag, typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_integral_v&lt; U &gt; &amp;&amp;std::is_unsigned_v&lt; U &gt;, bool &gt; operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7bb300fa310dc3a00fc8d7b353892de5" name="a7bb300fa310dc3a00fc8d7b353892de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb300fa310dc3a00fc8d7b353892de5">&#9670;&#160;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Two pairs of the same type are equal iff their members are equal after sorting. </p>

</div>
</div>
<a id="a5d8d2d0a2bce6b5cbd9a0bf5c7e424de" name="a5d8d2d0a2bce6b5cbd9a0bf5c7e424de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8d2d0a2bce6b5cbd9a0bf5c7e424de">&#9670;&#160;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag, typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_integral_v&lt; U &gt; &amp;&amp;std::is_unsigned_v&lt; U &gt;, bool &gt; operator== </td>
          <td>(</td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0dcb5fec94a56bb5d9cb4496aab181c" name="ad0dcb5fec94a56bb5d9cb4496aab181c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0dcb5fec94a56bb5d9cb4496aab181c">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether <span class="tt">x &gt; y</span> using <span class="tt">operator&lt;</span>. </p>

</div>
</div>
<a id="aaf9b132f26a170831b3a0352bff7b133" name="aaf9b132f26a170831b3a0352bff7b133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9b132f26a170831b3a0352bff7b133">&#9670;&#160;</a></span>operator&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag, typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_integral_v&lt; U &gt; &amp;&amp;std::is_unsigned_v&lt; U &gt;, bool &gt; operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a976cb6470ad6aaf19b3c35fcbd4c17f6" name="a976cb6470ad6aaf19b3c35fcbd4c17f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976cb6470ad6aaf19b3c35fcbd4c17f6">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether <span class="tt">x &gt;= y</span> using <span class="tt">operator&lt;</span>. </p>

</div>
</div>
<a id="a0bafa7a8866f7785a6e357c474bae900" name="a0bafa7a8866f7785a6e357c474bae900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bafa7a8866f7785a6e357c474bae900">&#9670;&#160;</a></span>operator&gt;=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag, typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_integral_v&lt; U &gt; &amp;&amp;std::is_unsigned_v&lt; U &gt;, bool &gt; operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; Tag &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92c1bc8d793f1a04fa4f4c33a011f4eb" name="a92c1bc8d793f1a04fa4f4c33a011f4eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c1bc8d793f1a04fa4f4c33a011f4eb">&#9670;&#160;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>base</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt;::PowerType</td>          <td class="paramname"><span class="paramname"><em>exponent</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides power function for <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>

</div>
</div>
<a id="a7d08c050b131498e375c5e6bb4ac8523" name="a7d08c050b131498e375c5e6bb4ac8523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d08c050b131498e375c5e6bb4ac8523">&#9670;&#160;</a></span>ReadFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::string &gt; ReadFile </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the content of the file at the given path, or nullopt if it cannot be read. </p>
<p>Note that the path is a filesystem path, not a <span class="tt">resource_path</span>. </p>

</div>
</div>
<a id="aaf3c49ca62422759206ccb9c7a7b0bf5" name="aaf3c49ca62422759206ccb9c7a7b0bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3c49ca62422759206ccb9c7a7b0bf5">&#9670;&#160;</a></span>ReadFileOrThrow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ReadFileOrThrow </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the content of the file at the given path, or throws if it cannot be read. </p>
<p>Note that the path is a filesystem path, not a <span class="tt">resource_path</span>. </p>

</div>
</div>
<a id="a90397b62328225fe13d52a529dc3335d" name="a90397b62328225fe13d52a529dc3335d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90397b62328225fe13d52a529dc3335d">&#9670;&#160;</a></span>static_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; T &gt; static_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; U &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts the object owned by the std::unique_ptr <span class="tt">other</span> from type <span class="tt">U</span> to <span class="tt">T</span>; no runtime type checking is performed. </p>
<p>This method is analogous to the built-in std::static_pointer_cast that operates on a std::shared_ptr.</p>
<p>Note that this function only supports default deleters. </p>

</div>
</div>
<a id="a848fb0ead47dfe2676e2ef81b8735e83" name="a848fb0ead47dfe2676e2ef81b8735e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848fb0ead47dfe2676e2ef81b8735e83">&#9670;&#160;</a></span>temp_directory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string temp_directory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a directory location suitable for temporary files. </p>
<p>The directory will be called ${parent}/robotlocomotion_drake_XXXXXX where each X is replaced by a character from the portable filename character set. The path ${parent} is defined as one of the following (in decreasing priority):</p>
<ul>
<li>${TEST_TMPDIR}</li>
<li>${TMPDIR}</li>
<li>/tmp</li>
</ul>
<p>If successful, this will always create a new directory. While the caller is not obliged to delete the directory, it has full power to do so based on specific context and need.</p>
<dl class="section return"><dt>Returns</dt><dd>The path representing a newly created directory There will be no trailing <span class="tt">/</span>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>the directory ${parent}/robotlocomotion_drake_XXXXXX cannot be created, or is not a directory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cf089de86f2bc6c12794ce67aacad84" name="a2cf089de86f2bc6c12794ce67aacad84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf089de86f2bc6c12794ce67aacad84">&#9670;&#160;</a></span>to_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_identifier.html">drake::Identifier</a>&lt; Tag &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables use of identifiers with to_string. </p>
<p>It requires ADL to work. So, it should be invoked as: <span class="tt">to_string(id);</span> and should be preceded by <span class="tt">using std::to_string</span>. </p>

</div>
</div>
<a id="a9c44573b575d41585df41dc137def92c" name="a9c44573b575d41585df41dc137def92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c44573b575d41585df41dc137def92c">&#9670;&#160;</a></span>to_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a08115460f0d38571bcd4445ca9d6ec18">FileSource</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation. </p>

</div>
</div>
<a id="abcaeeaa04ecaa7cad4ea3bac4cb4aafd" name="abcaeeaa04ecaa7cad4ea3bac4cb4aafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcaeeaa04ecaa7cad4ea3bac4cb4aafd">&#9670;&#160;</a></span>unused()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void unused </td>
          <td>(</td>
          <td class="paramtype">const Args &amp;</td>          <td class="paramname"><span class="paramname"><em>...</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Documents the argument(s) as unused, placating GCC's -Wunused-parameter warning. </p>
<p>This can be called within function bodies to mark that certain parameters are unused.</p>
<p>When possible, removing the unused parameter is better than placating the warning. However, in some cases the parameter is part of a virtual API or template concept that is used elsewhere, so we can't remove it. In those cases, this function might be an appropriate work-around.</p>
<p>Here's rough advice on how to fix Wunused-parameter warnings:</p>
<p>(1) If the parameter can be removed entirely, prefer that as the first choice. (This may not be possible if, e.g., a method must match some virtual API or template concept.)</p>
<p>(2) Unless the parameter name has acute value, prefer to omit the name of the parameter, leaving only the type, e.g. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Print(<span class="keyword">const</span> State&amp; state)<span class="keyword"> override </span>{ <span class="comment">/* No state to print. */</span> }</div>
</div><!-- fragment --><p> changes to </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Print(<span class="keyword">const</span> State&amp;)<span class="keyword"> override </span>{ <span class="comment">/* No state to print. */</span>}</div>
</div><!-- fragment --><p> This no longer triggers the warning and further makes it clear that a parameter required by the API is definitively unused in the function.</p>
<p>This is an especially good solution in the context of method definitions (vs declarations); the parameter name used in a definition is entirely irrelevant to Doxygen and most readers.</p>
<p>(3) When leaving the parameter name intact has acute value, it is acceptable to keep the name and mark it <span class="tt"><a class="el" href="#abcaeeaa04ecaa7cad4ea3bac4cb4aafd" title="Documents the argument(s) as unused, placating GCC&#39;s -Wunused-parameter warning.">unused</a></span>. For example, when the name appears as part of a virtual method's base class declaration, the name is used by Doxygen to document the method, e.g., </p><div class="fragment"><div class="line"><span class="comment">   /** Sets the default State of a System.  This default implementation is to</span></div>
<div class="line"><span class="comment">*      set all zeros.  Subclasses may override to use non-zero defaults.  The</span></div>
<div class="line"><span class="comment">*      custom defaults may be based on the given @p context, when relevant.  */</span></div>
<div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">void</span> SetDefault(<span class="keyword">const</span> Context&lt;T&gt;&amp; context, State&lt;T&gt;* state)<span class="keyword"> const </span>{</div>
<div class="line">     <a class="code hl_function" href="#abcaeeaa04ecaa7cad4ea3bac4cb4aafd">unused</a>(context);</div>
<div class="line">     state-&gt;SetZero();</div>
<div class="line">   }</div>
<div class="ttc" id="anamespacedrake_html_abcaeeaa04ecaa7cad4ea3bac4cb4aafd"><div class="ttname"><a href="#abcaeeaa04ecaa7cad4ea3bac4cb4aafd">drake::unused</a></div><div class="ttdeci">void unused(const Args &amp;...)</div><div class="ttdoc">Documents the argument(s) as unused, placating GCC&#39;s -Wunused-parameter warning.</div><div class="ttdef"><b>Definition</b> unused.h:51</div></div>
</div><!-- fragment --> 
</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="acd67fb791be292c340610dbcbd9b5b8f" name="acd67fb791be292c340610dbcbd9b5b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd67fb791be292c340610dbcbd9b5b8f">&#9670;&#160;</a></span>eigen_all</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto eigen_all = Eigen::placeholders::all</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A portable alias for Eigen::placeholders::all. </p>

</div>
</div>
<a id="aa39127b52b1d34b56cf3e6801cf31045" name="aa39127b52b1d34b56cf3e6801cf31045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39127b52b1d34b56cf3e6801cf31045">&#9670;&#160;</a></span>kDrakeResourceRootEnvironmentVariableName</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* const kDrakeResourceRootEnvironmentVariableName</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the environment variable that provides the first place where FindResource attempts to look. </p>
<p>The environment variable is allowed to be unset or empty; in that case, FindResource will attempt to use other locations without complaint.</p>
<p>The value is guaranteed to be "DRAKE_RESOURCE_ROOT". (For some users, it may be easier to hard-code a value than refer to this constant.)</p>
<p>When the environment variable is set, resources are sought in relation to it by appending the <a class="el" href="#a6d12a9fa5bded2c0de25138421b0e1d7" title="(Advanced) Attempts to locate a Drake resource named by the given resource_path.">FindResource()</a> <span class="tt">resource_path</span> to the environment variable (with an intermediate <span class="tt">/</span> as appropriate). For example, if the <span class="tt">resource_path</span> is <span class="tt">drake/examples/pendulum/Pendulum.urdf</span> and the <span class="tt">DRAKE_RESOURCE_ROOT</span> is set to <span class="tt">/home/someuser/foo</span> then the resource will be sought at <span class="tt">/home/someuser/foo/drake/examples/pendulum/Pendulum.urdf</span>.</p>
<p>The intended use of this variable is to seek resources from an installed copy of Drake, in case other methods have failed. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
