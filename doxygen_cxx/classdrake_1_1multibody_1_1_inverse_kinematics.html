<!-- HTML header for doxygen 1.14.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: InverseKinematics Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1multibody_1_1_inverse_kinematics.html','','classdrake_1_1multibody_1_1_inverse_kinematics-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">InverseKinematics Class Reference<div class="ingroups"><a class="el" href="group__algorithms.html">Algorithms</a> &raquo; <a class="el" href="group__planning.html">Planning</a> &raquo; <a class="el" href="group__planning__kinematics.html">Inverse kinematics</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Solves an inverse kinematics (IK) problem on a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>, to find the postures of the robot satisfying certain constraints. </p>
<p>The decision variables include the generalized position of the robot.</p>
<p>To perform IK on a subset of the plant, use the constructor overload that takes a <span class="tt">plant_context</span> and use <span class="tt"><a class="el" href="classdrake_1_1multibody_1_1_joint.html#a50c7f850050d4a94641ed72dd2d1968f" title="Lock the joint.">Joint::Lock</a></span> on the joints in that Context that should be fixed during IK. </p>
</div>
<p><code>#include &lt;drake/multibody/inverse_kinematics/inverse_kinematics.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a17e545f30ae2d1bf7fd15e14f6198fa9" id="r_a17e545f30ae2d1bf7fd15e14f6198fa9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17e545f30ae2d1bf7fd15e14f6198fa9">~InverseKinematics</a> ()</td></tr>
<tr class="memitem:a491bed91ae956de434888dd68594b7a3" id="r_a491bed91ae956de434888dd68594b7a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a491bed91ae956de434888dd68594b7a3">InverseKinematics</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;plant, bool with_joint_limits=true)</td></tr>
<tr class="memdesc:a491bed91ae956de434888dd68594b7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an inverse kinematics problem for a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>.  <br /></td></tr>
<tr class="memitem:a8a352889e2c30877b432e49e8d191efd" id="r_a8a352889e2c30877b432e49e8d191efd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a352889e2c30877b432e49e8d191efd">InverseKinematics</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;plant, <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *plant_context, bool with_joint_limits=true)</td></tr>
<tr class="memdesc:a8a352889e2c30877b432e49e8d191efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an inverse kinematics problem for a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>.  <br /></td></tr>
<tr class="memitem:ad9cd94b6ef67d25a510671af607247f9" id="r_ad9cd94b6ef67d25a510671af607247f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9cd94b6ef67d25a510671af607247f9">AddPositionConstraint</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;frameB, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;p_BQ, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;frameA, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;p_AQ_lower, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;p_AQ_upper)</td></tr>
<tr class="memdesc:ad9cd94b6ef67d25a510671af607247f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the kinematic constraint that a point Q, fixed in frame B, should lie within a bounding box expressed in another frame A as p_AQ_lower &lt;= p_AQ &lt;= p_AQ_upper, where p_AQ is the position of point Q measured and expressed in frame A.  <br /></td></tr>
<tr class="memitem:a77356d666b4ab74b8248890936a7eee4" id="r_a77356d666b4ab74b8248890936a7eee4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77356d666b4ab74b8248890936a7eee4">AddPositionConstraint</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;frameB, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;p_BQ, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;frameAbar, const std::optional&lt; math::RigidTransformd &gt; &amp;X_AbarA, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;p_AQ_lower, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;p_AQ_upper)</td></tr>
<tr class="memdesc:a77356d666b4ab74b8248890936a7eee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the kinematic constraint that a point Q, fixed in frame B, should lie within a bounding box expressed in another frame A as p_AQ_lower &lt;= p_AQ &lt;= p_AQ_upper, where p_AQ is the position of point Q measured and expressed in frame A.  <br /></td></tr>
<tr class="memitem:ae19a88f45b346d2d37e7e1b2c495c464" id="r_ae19a88f45b346d2d37e7e1b2c495c464"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">solvers::Cost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae19a88f45b346d2d37e7e1b2c495c464">AddPositionCost</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;frameA, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;p_AP, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;frameB, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;p_BQ, const Eigen::Ref&lt; const Eigen::Matrix3d &gt; &amp;C)</td></tr>
<tr class="memdesc:ae19a88f45b346d2d37e7e1b2c495c464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost of the form (p_AP - p_AQ)ᵀ C (p_AP - p_AQ), where point P is specified relative to frame A and point Q is specified relative to frame B, and the cost is evaluated in frame A.  <br /></td></tr>
<tr class="memitem:a48900177032f21de7b7232ea0a318037" id="r_a48900177032f21de7b7232ea0a318037"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48900177032f21de7b7232ea0a318037">AddOrientationConstraint</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;frameAbar, const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;R_AbarA, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;frameBbar, const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;R_BbarB, <a class="el" href="classdouble.html">double</a> theta_bound)</td></tr>
<tr class="memdesc:a48900177032f21de7b7232ea0a318037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrains that the angle difference θ between the orientation of frame A and the orientation of frame B to satisfy θ ≤ θ_bound.  <br /></td></tr>
<tr class="memitem:ac000dbc95b163716b1e69c640128a770" id="r_ac000dbc95b163716b1e69c640128a770"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">solvers::Cost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac000dbc95b163716b1e69c640128a770">AddOrientationCost</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;frameAbar, const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;R_AbarA, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;frameBbar, const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;R_BbarB, <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="memdesc:ac000dbc95b163716b1e69c640128a770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a cost of the form <span class="tt">c * (1 - cos(θ))</span>, where θ is the angle between the orientation of frame A and the orientation of frame B, and <code class="param">c</code> is a cost scaling.  <br /></td></tr>
<tr class="memitem:a285b9d94f9b3f6e4dc65fcb8076db5c6" id="r_a285b9d94f9b3f6e4dc65fcb8076db5c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a285b9d94f9b3f6e4dc65fcb8076db5c6">AddGazeTargetConstraint</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;frameA, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;p_AS, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;n_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;frameB, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;p_BT, <a class="el" href="classdouble.html">double</a> cone_half_angle)</td></tr>
<tr class="memdesc:a285b9d94f9b3f6e4dc65fcb8076db5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrains a target point T to be within a cone K.  <br /></td></tr>
<tr class="memitem:ac06bd4343d37875ba75bfee7d014580c" id="r_ac06bd4343d37875ba75bfee7d014580c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac06bd4343d37875ba75bfee7d014580c">AddAngleBetweenVectorsConstraint</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;frameA, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;na_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;frameB, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;nb_B, <a class="el" href="classdouble.html">double</a> angle_lower, <a class="el" href="classdouble.html">double</a> angle_upper)</td></tr>
<tr class="memdesc:ac06bd4343d37875ba75bfee7d014580c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrains that the angle between a vector na and another vector nb is between [θ_lower, θ_upper].  <br /></td></tr>
<tr class="memitem:a7ebc49cfcb63d2749e45c5e6344b64c4" id="r_a7ebc49cfcb63d2749e45c5e6344b64c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">solvers::Cost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ebc49cfcb63d2749e45c5e6344b64c4">AddAngleBetweenVectorsCost</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;frameA, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;na_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;frameB, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;nb_B, <a class="el" href="classdouble.html">double</a> c)</td></tr>
<tr class="memdesc:a7ebc49cfcb63d2749e45c5e6344b64c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a cost c * (1-cosθ) where θ is the angle between the vector <span class="tt">na</span> and <span class="tt">nb</span>.  <br /></td></tr>
<tr class="memitem:a6544ad01ed1f2deef8e702716aa07940" id="r_a6544ad01ed1f2deef8e702716aa07940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6544ad01ed1f2deef8e702716aa07940">AddMinimumDistanceLowerBoundConstraint</a> (<a class="el" href="classdouble.html">double</a> bound, <a class="el" href="classdouble.html">double</a> influence_distance_offset=0.01)</td></tr>
<tr class="memdesc:a6544ad01ed1f2deef8e702716aa07940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the constraint that the pairwise distance between objects should be no smaller than <span class="tt">bound</span>.  <br /></td></tr>
<tr class="memitem:acb88e51c9d18bcf7da15cd6f5da30dde" id="r_acb88e51c9d18bcf7da15cd6f5da30dde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb88e51c9d18bcf7da15cd6f5da30dde">AddMinimumDistanceUpperBoundConstraint</a> (<a class="el" href="classdouble.html">double</a> bound, <a class="el" href="classdouble.html">double</a> influence_distance_offset)</td></tr>
<tr class="memdesc:acb88e51c9d18bcf7da15cd6f5da30dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the constraint that at least one pair of geometries has distance no larger than <span class="tt">bound</span>.  <br /></td></tr>
<tr class="memitem:affa23da5c7ec4fd4e01c39b1e6d00cab" id="r_affa23da5c7ec4fd4e01c39b1e6d00cab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affa23da5c7ec4fd4e01c39b1e6d00cab">AddDistanceConstraint</a> (const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> &gt; &amp;geometry_pair, <a class="el" href="classdouble.html">double</a> distance_lower, <a class="el" href="classdouble.html">double</a> distance_upper)</td></tr>
<tr class="memdesc:affa23da5c7ec4fd4e01c39b1e6d00cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the constraint that the distance between a pair of geometries is within some bounds.  <br /></td></tr>
<tr class="memitem:a4d8aebd78831688e8c1bb899d28ceed1" id="r_a4d8aebd78831688e8c1bb899d28ceed1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d8aebd78831688e8c1bb899d28ceed1">AddPointToPointDistanceConstraint</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;frame1, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;p_B1P1, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;frame2, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;p_B2P2, <a class="el" href="classdouble.html">double</a> distance_lower, <a class="el" href="classdouble.html">double</a> distance_upper)</td></tr>
<tr class="memdesc:a4d8aebd78831688e8c1bb899d28ceed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a constraint that the distance between point P1 attached to frame 1 and point P2 attached to frame 2 is within the range [distance_lower, distance_upper].  <br /></td></tr>
<tr class="memitem:a8640101a78303ea3fb07cf7063661483" id="r_a8640101a78303ea3fb07cf7063661483"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8640101a78303ea3fb07cf7063661483">AddPointToLineDistanceConstraint</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;frame_point, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;p_B1P, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;frame_line, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;p_B2Q, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;n_B2, <a class="el" href="classdouble.html">double</a> distance_lower, <a class="el" href="classdouble.html">double</a> distance_upper)</td></tr>
<tr class="memdesc:a8640101a78303ea3fb07cf7063661483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a constraint that the distance between point P attached to frame_point (denoted as B1) and a line attached to frame_line (denoted as B2) is within the range [distance_lower, distance_upper].  <br /></td></tr>
<tr class="memitem:a9a77ae06ea88d1c5a68025faca73e5dc" id="r_a9a77ae06ea88d1c5a68025faca73e5dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a77ae06ea88d1c5a68025faca73e5dc">AddPolyhedronConstraint</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;frameF, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;frameG, const Eigen::Ref&lt; const Eigen::Matrix3Xd &gt; &amp;p_GP, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b)</td></tr>
<tr class="memdesc:a9a77ae06ea88d1c5a68025faca73e5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the constraint that the position of P1, ..., Pn satisfy A * [p_FP1; p_FP2; ...; p_FPn] &lt;= b.  <br /></td></tr>
<tr class="memitem:a9d9bc4d98911ca9808bec31c2f564560" id="r_a9d9bc4d98911ca9808bec31c2f564560"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d9bc4d98911ca9808bec31c2f564560">q</a> () const</td></tr>
<tr class="memdesc:a9d9bc4d98911ca9808bec31c2f564560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for q.  <br /></td></tr>
<tr class="memitem:ab54111eab638313c328fc0a0f1b50944" id="r_ab54111eab638313c328fc0a0f1b50944"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab54111eab638313c328fc0a0f1b50944">prog</a> () const</td></tr>
<tr class="memdesc:ab54111eab638313c328fc0a0f1b50944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the optimization program constructed by <a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html" title="Solves an inverse kinematics (IK) problem on a MultibodyPlant, to find the postures of the robot sati...">InverseKinematics</a>.  <br /></td></tr>
<tr class="memitem:ac91be3995339c8e796a88272d5612b6c" id="r_ac91be3995339c8e796a88272d5612b6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac91be3995339c8e796a88272d5612b6c">get_mutable_prog</a> ()</td></tr>
<tr class="memdesc:ac91be3995339c8e796a88272d5612b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the optimization program constructed by <a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html" title="Solves an inverse kinematics (IK) problem on a MultibodyPlant, to find the postures of the robot sati...">InverseKinematics</a>.  <br /></td></tr>
<tr class="memitem:a9d74e7e1c5b7e2f8280ad16d7fe27f59" id="r_a9d74e7e1c5b7e2f8280ad16d7fe27f59"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d74e7e1c5b7e2f8280ad16d7fe27f59">context</a> () const</td></tr>
<tr class="memdesc:a9d74e7e1c5b7e2f8280ad16d7fe27f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the plant context.  <br /></td></tr>
<tr class="memitem:a61a63f33b7cf87252395dc149f454908" id="r_a61a63f33b7cf87252395dc149f454908"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61a63f33b7cf87252395dc149f454908">get_mutable_context</a> ()</td></tr>
<tr class="memdesc:a61a63f33b7cf87252395dc149f454908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the mutable plant context.  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:a67f334d691594767c3ac1f81e96a7b0f" id="r_a67f334d691594767c3ac1f81e96a7b0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67f334d691594767c3ac1f81e96a7b0f">InverseKinematics</a> (const <a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> &amp;)=delete</td></tr>
<tr class="memitem:ad11f4ad092fc1e40a44be225138d38e9" id="r_ad11f4ad092fc1e40a44be225138d38e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad11f4ad092fc1e40a44be225138d38e9">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> &amp;)=delete</td></tr>
<tr class="memitem:a7bfec066e251fc2acc3980f272c934aa" id="r_a7bfec066e251fc2acc3980f272c934aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bfec066e251fc2acc3980f272c934aa">InverseKinematics</a> (<a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> &amp;&amp;)=delete</td></tr>
<tr class="memitem:a6c2d067105b9effe872abe1ed9c431c1" id="r_a6c2d067105b9effe872abe1ed9c431c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c2d067105b9effe872abe1ed9c431c1">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> &amp;&amp;)=delete</td></tr>
</table>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a67f334d691594767c3ac1f81e96a7b0f" name="a67f334d691594767c3ac1f81e96a7b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f334d691594767c3ac1f81e96a7b0f">&#9670;&#160;</a></span>InverseKinematics() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7bfec066e251fc2acc3980f272c934aa" name="a7bfec066e251fc2acc3980f272c934aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfec066e251fc2acc3980f272c934aa">&#9670;&#160;</a></span>InverseKinematics() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a17e545f30ae2d1bf7fd15e14f6198fa9" name="a17e545f30ae2d1bf7fd15e14f6198fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e545f30ae2d1bf7fd15e14f6198fa9">&#9670;&#160;</a></span>~InverseKinematics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a491bed91ae956de434888dd68594b7a3" name="a491bed91ae956de434888dd68594b7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491bed91ae956de434888dd68594b7a3">&#9670;&#160;</a></span>InverseKinematics() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>plant</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>with_joint_limits</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an inverse kinematics problem for a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>. </p>
<p>This constructor will create and own a context for <span class="tt">plant</span>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plant</td><td>The robot on which the inverse kinematics problem will be solved. </td></tr>
    <tr><td class="paramname">with_joint_limits</td><td>If set to true, then the constructor imposes the joint limits (obtained from plant.GetPositionLowerLimits() and plant.GetPositionUpperLimits()). If set to false, then the constructor does not impose the joint limit constraints in the constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The inverse kinematics problem constructed in this way doesn't permit collision related constraint (such as calling AddMinimumDistanceConstraint). To enable collision related constraint, call InverseKinematics(const MultibodyPlant&lt;double&gt;&amp; plant,
systems::Context&lt;double&gt;* plant_context); </dd></dl>

</div>
</div>
<a id="a8a352889e2c30877b432e49e8d191efd" name="a8a352889e2c30877b432e49e8d191efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a352889e2c30877b432e49e8d191efd">&#9670;&#160;</a></span>InverseKinematics() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>plant</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>plant_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>with_joint_limits</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an inverse kinematics problem for a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>. </p>
<p>If the user wants to solve the problem with collision related constraint (like calling AddMinimumDistanceConstraint), please use this constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plant</td><td>The robot on which the inverse kinematics problem will be solved. This plant should have been connected to a SceneGraph within a Diagram </td></tr>
    <tr><td class="paramname">plant_context</td><td>The context for the plant. This context should be a part of the Diagram context. Any locked joints in the <span class="tt">plant_context</span> will remain fixed at their locked value. (This provides a convenient way to perform IK on a subset of the plant.) To construct a plant connected to a SceneGraph, with the corresponding plant_context, the steps are: <div class="fragment"><div class="line"><span class="comment">// 1. Add a diagram containing the MultibodyPlant and SceneGraph</span></div>
<div class="line"><a class="code hl_class" href="classdrake_1_1systems_1_1_diagram_builder.html">systems::DiagramBuilder&lt;double&gt;</a> builder;</div>
<div class="line"><span class="keyword">auto</span> items = <a class="code hl_function" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8b71553122d35a449d2131789a3f94c2">AddMultibodyPlantSceneGraph</a>(&amp;builder, 0.0);</div>
<div class="line"><span class="comment">// 2. Add collision geometries to the plant</span></div>
<div class="line"><a class="code hl_class" href="classdrake_1_1multibody_1_1_parser.html">Parser</a>(&amp;builder).<a class="code hl_function" href="classdrake_1_1multibody_1_1_parser.html#a2b687c09f6c9a575f4d08ec7fcdea85a">AddModels</a>(<span class="stringliteral">&quot;model.sdf&quot;</span>);</div>
<div class="line"><span class="comment">// 3. Construct the diagram</span></div>
<div class="line"><span class="keyword">auto</span> diagram = builder.<a class="code hl_function" href="classdrake_1_1systems_1_1_diagram_builder.html#ae363709739ead24977365011f7c9b0ea">Build</a>();</div>
<div class="line"><span class="comment">// 4. Create diagram context.</span></div>
<div class="line"><span class="keyword">auto</span> diagram_context= diagram-&gt;CreateDefaultContext();</div>
<div class="line"><span class="comment">// 5. Get the context for the plant.</span></div>
<div class="line"><span class="keyword">auto</span> plant_context = &amp;(diagram-&gt;GetMutableSubsystemContext(items.plant,</div>
<div class="line">diagram_context.get()));</div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_multibody_plant_html_a8b71553122d35a449d2131789a3f94c2"><div class="ttname"><a href="classdrake_1_1multibody_1_1_multibody_plant.html#a8b71553122d35a449d2131789a3f94c2">drake::multibody::MultibodyPlant::AddMultibodyPlantSceneGraph</a></div><div class="ttdeci">AddMultibodyPlantSceneGraphResult&lt; T &gt; AddMultibodyPlantSceneGraph(systems::DiagramBuilder&lt; T &gt; *builder, double time_step, std::unique_ptr&lt; geometry::SceneGraph&lt; T &gt; &gt; scene_graph=nullptr)</div><div class="ttdoc">Makes a new MultibodyPlant with discrete update period time_step and adds it to a diagram builder tog...</div></div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_parser_html"><div class="ttname"><a href="classdrake_1_1multibody_1_1_parser.html">drake::multibody::Parser</a></div><div class="ttdoc">Parses model description input into a MultibodyPlant and (optionally) a SceneGraph.</div><div class="ttdef"><b>Definition</b> parser.h:132</div></div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_parser_html_a2b687c09f6c9a575f4d08ec7fcdea85a"><div class="ttname"><a href="classdrake_1_1multibody_1_1_parser.html#a2b687c09f6c9a575f4d08ec7fcdea85a">drake::multibody::Parser::AddModels</a></div><div class="ttdeci">std::vector&lt; ModelInstanceIndex &gt; AddModels(const std::filesystem::path &amp;file_name)</div><div class="ttdoc">Parses the input file named in file_name and adds all of its model(s) to plant.</div></div>
<div class="ttc" id="aclassdrake_1_1systems_1_1_diagram_builder_html"><div class="ttname"><a href="classdrake_1_1systems_1_1_diagram_builder.html">drake::systems::DiagramBuilder</a></div><div class="ttdoc">DiagramBuilder is a factory class for Diagram.</div><div class="ttdef"><b>Definition</b> diagram_builder.h:64</div></div>
<div class="ttc" id="aclassdrake_1_1systems_1_1_diagram_builder_html_ae363709739ead24977365011f7c9b0ea"><div class="ttname"><a href="classdrake_1_1systems_1_1_diagram_builder.html#ae363709739ead24977365011f7c9b0ea">drake::systems::DiagramBuilder::Build</a></div><div class="ttdeci">std::unique_ptr&lt; Diagram&lt; T &gt; &gt; Build()</div><div class="ttdoc">Builds the Diagram that has been described by the calls to Connect, ExportInput, and ExportOutput.</div></div>
</div><!-- fragment --> This context will be modified during calling ik.prog.Solve(...). When Solve() returns <span class="tt">result</span>, context will store the optimized posture, namely plant.GetPositions(*context) will be the same as in result.GetSolution(ik.q()). The user could then use this context to perform kinematic computation (like computing the position of the end-effector etc.). </td></tr>
    <tr><td class="paramname">with_joint_limits</td><td>If set to true, then the constructor imposes the joint limits (obtained from plant.GetPositionLowerLimits() and plant.GetPositionUpperLimits(), and from any body/joint locks set in <span class="tt">plant_context</span>). If set to false, then the constructor does not impose the joint limit constraints in the constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ac06bd4343d37875ba75bfee7d014580c" name="ac06bd4343d37875ba75bfee7d014580c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac06bd4343d37875ba75bfee7d014580c">&#9670;&#160;</a></span>AddAngleBetweenVectorsConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; AddAngleBetweenVectorsConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frameA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>na_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frameB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nb_B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>angle_lower</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>angle_upper</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constrains that the angle between a vector na and another vector nb is between [θ_lower, θ_upper]. </p>
<p>na is fixed to a frame A, while nb is fixed to a frame B. Mathematically, if we denote na_unit_A as na expressed in frame A after normalization (na_unit_A has unit length), and nb_unit_B as nb expressed in frame B after normalization, the constraint is cos(θ_upper) ≤ na_unit_Aᵀ * R_AB * nb_unit_B ≤ cos(θ_lower), where R_AB is the rotation matrix, representing the orientation of frame B expressed in frame A. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameA</td><td>The frame to which na is fixed. </td></tr>
    <tr><td class="paramname">na_A</td><td>The vector na fixed to frame A, expressed in frame A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>na_A should be a non-zero vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if na_A is close to zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameB</td><td>The frame to which nb is fixed. </td></tr>
    <tr><td class="paramname">nb_B</td><td>The vector nb fixed to frame B, expressed in frame B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>nb_B should be a non-zero vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if nb_B is close to zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle_lower</td><td>The lower bound on the angle between na and nb. It is denoted as θ_lower in the documentation. <code class="param">angle_lower</code> is in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>angle_lower &gt;= 0. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if angle_lower is negative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle_upper</td><td>The upper bound on the angle between na and nb. it is denoted as θ_upper in the class documentation. <code class="param">angle_upper</code> is in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>angle_lower &lt;= angle_upper &lt;= pi. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if angle_upper is outside the bounds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ebc49cfcb63d2749e45c5e6344b64c4" name="a7ebc49cfcb63d2749e45c5e6344b64c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ebc49cfcb63d2749e45c5e6344b64c4">&#9670;&#160;</a></span>AddAngleBetweenVectorsCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">solvers::Cost</a> &gt; AddAngleBetweenVectorsCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frameA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>na_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frameB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nb_B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a cost c * (1-cosθ) where θ is the angle between the vector <span class="tt">na</span> and <span class="tt">nb</span>. </p>
<p>na is fixed to a frame A, while nb is fixed to a frame B. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameA</td><td>The frame to which na is fixed. </td></tr>
    <tr><td class="paramname">na_A</td><td>The vector na fixed to frame A, expressed in frame A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>na_A should be a non-zero vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if na_A is close to zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameB</td><td>The frame to which nb is fixed. </td></tr>
    <tr><td class="paramname">nb_B</td><td>The vector nb fixed to frame B, expressed in frame B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>nb_B should be a non-zero vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if nb_B is close to zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The cost is c * (1-cosθ). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affa23da5c7ec4fd4e01c39b1e6d00cab" name="affa23da5c7ec4fd4e01c39b1e6d00cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa23da5c7ec4fd4e01c39b1e6d00cab">&#9670;&#160;</a></span>AddDistanceConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; AddDistanceConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>geometry_pair</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>distance_lower</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>distance_upper</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the constraint that the distance between a pair of geometries is within some bounds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">geometry_pair</td><td>The pair of geometries between which the distance is constrained. Notice that we only consider the distance between a static geometry and a dynamic geometry, or a pair of dynamic geometries. We don't allow constraining the distance between two static geometries. </td></tr>
    <tr><td class="paramname">distance_lower</td><td>The lower bound on the distance. </td></tr>
    <tr><td class="paramname">distance_upper</td><td>The upper bound on the distance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a285b9d94f9b3f6e4dc65fcb8076db5c6" name="a285b9d94f9b3f6e4dc65fcb8076db5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285b9d94f9b3f6e4dc65fcb8076db5c6">&#9670;&#160;</a></span>AddGazeTargetConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; AddGazeTargetConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frameA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_AS</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>n_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frameB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_BT</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>cone_half_angle</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constrains a target point T to be within a cone K. </p>
<p>The point T ("T" stands for "target") is fixed in a frame B, with position p_BT. The cone originates from a point S ("S" stands for "source"), fixed in frame A with position p_AS, with the axis of the cone being n, also fixed in frame A. The half angle of the cone is θ. A common usage of this constraint is that a camera should gaze at some target; namely the target falls within a gaze cone, originating from the camera eye. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameA</td><td>The frame where the gaze cone is fixed to. </td></tr>
    <tr><td class="paramname">p_AS</td><td>The position of the cone source point S, measured and expressed in frame A. </td></tr>
    <tr><td class="paramname">n_A</td><td>The directional vector representing the center ray of the cone, expressed in frame A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code class="param">n_A</code> cannot be a zero vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>is n_A is close to a zero vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameB</td><td>The frame where the target point T is fixed to. </td></tr>
    <tr><td class="paramname">p_BT</td><td>The position of the target point T, measured and expressed in frame B. </td></tr>
    <tr><td class="paramname">cone_half_angle</td><td>The half angle of the cone. We denote it as θ in the documentation. <code class="param">cone_half_angle</code> is in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code class="param">0</code> &lt;= cone_half_angle &lt;= pi. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if cone_half_angle is outside of the bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6544ad01ed1f2deef8e702716aa07940" name="a6544ad01ed1f2deef8e702716aa07940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6544ad01ed1f2deef8e702716aa07940">&#9670;&#160;</a></span>AddMinimumDistanceLowerBoundConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; AddMinimumDistanceLowerBoundConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>influence_distance_offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.01</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the constraint that the pairwise distance between objects should be no smaller than <span class="tt">bound</span>. </p>
<p>We consider the distance between pairs of</p><ol type="1">
<li>Anchored (static) object and a dynamic object.</li>
<li>A dynamic object and another dynamic object, if one is not the parent link of the other. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bound</td><td>The minimum allowed value, dₘᵢₙ, of the signed distance between any candidate pair of geometries. </td></tr>
    <tr><td class="paramname">influence_distance_offset</td><td>See <a class="el" href="classdrake_1_1multibody_1_1_minimum_distance_lower_bound_constraint.html" title="Constrain min(d) &gt;= lb, namely the signed distance between all candidate pairs of geometries (accordi...">MinimumDistanceLowerBoundConstraint</a> for explanation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> passed to the constructor of <span class="tt">this</span> has registered its geometry with a SceneGraph. </dd>
<dd>
0 &lt; <span class="tt">influence_distance_offset</span> &lt; ∞ </dd></dl>
</li>
</ol>

</div>
</div>
<a id="acb88e51c9d18bcf7da15cd6f5da30dde" name="acb88e51c9d18bcf7da15cd6f5da30dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb88e51c9d18bcf7da15cd6f5da30dde">&#9670;&#160;</a></span>AddMinimumDistanceUpperBoundConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; AddMinimumDistanceUpperBoundConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>influence_distance_offset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the constraint that at least one pair of geometries has distance no larger than <span class="tt">bound</span>. </p>
<p>We consider the distance between pairs of</p><ol type="1">
<li>Anchored (static) object and a dynamic object.</li>
<li>A dynamic object and another dynamic object, if one is not the parent link of the other. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bound</td><td>The upper bound of the minimum signed distance between any candidate pair of geometries. Notice this is NOT the upper bound of every distance, but the upper bound of the smallest distance. </td></tr>
    <tr><td class="paramname">influence_distance_offset</td><td>See <a class="el" href="classdrake_1_1multibody_1_1_minimum_distance_upper_bound_constraint.html" title="Constrain min(d) &lt;= ub, namely at least one signed distance between a candidate pairs of geometries (...">MinimumDistanceUpperBoundConstraint</a> for more details on influence_distance_offset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> passed to the constructor of <span class="tt">this</span> has registered its geometry with a SceneGraph. </dd>
<dd>
0 &lt; <span class="tt">influence_distance_offset</span> &lt; ∞ </dd></dl>
</li>
</ol>

</div>
</div>
<a id="a48900177032f21de7b7232ea0a318037" name="a48900177032f21de7b7232ea0a318037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48900177032f21de7b7232ea0a318037">&#9670;&#160;</a></span>AddOrientationConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; AddOrientationConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frameAbar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R_AbarA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frameBbar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R_BbarB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>theta_bound</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constrains that the angle difference θ between the orientation of frame A and the orientation of frame B to satisfy θ ≤ θ_bound. </p>
<p><a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame) of its underl...">Frame</a> A is fixed to frame A_bar, with orientation R_AbarA measured in frame A_bar. <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame) of its underl...">Frame</a> B is fixed to frame B_bar, with orientation R_BbarB measured in frame B_bar. The angle difference between frame A's orientation R_WA and B's orientation R_WB is θ, (θ ∈ [0, π]), if there exists a rotation axis a, such that rotating frame A by angle θ about axis a aligns it with frame B. Namely R_AB = I + sinθ â + (1-cosθ)â² (1) where R_AB is the orientation of frame B expressed in frame A. â is the skew symmetric matrix of the rotation axis a. Equation (1) is the Rodrigues formula that computes the rotation matrix from a rotation axis a and an angle θ, <a href="https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula">https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula</a> If the users want frame A and frame B to align perfectly, they can set θ_bound = 0. Mathematically, this constraint is imposed as trace(R_AB) ≥ 2cos(θ_bound) + 1 (1) To derive (1), using Rodrigues formula R_AB = I + sinθ â + (1-cosθ)â² where trace(R_AB) = 2cos(θ) + 1 ≥ 2cos(θ_bound) + 1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameAbar</td><td>frame A_bar, the frame A is fixed to frame A_bar. </td></tr>
    <tr><td class="paramname">R_AbarA</td><td>The orientation of frame A measured in frame A_bar. </td></tr>
    <tr><td class="paramname">frameBbar</td><td>frame B_bar, the frame B is fixed to frame B_bar. </td></tr>
    <tr><td class="paramname">R_BbarB</td><td>The orientation of frame B measured in frame B_bar. </td></tr>
    <tr><td class="paramname">theta_bound</td><td>The bound on the angle difference between frame A's orientation and frame B's orientation. It is denoted as θ_bound in the documentation. <code class="param">theta_bound</code> is in radians. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac000dbc95b163716b1e69c640128a770" name="ac000dbc95b163716b1e69c640128a770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac000dbc95b163716b1e69c640128a770">&#9670;&#160;</a></span>AddOrientationCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">solvers::Cost</a> &gt; AddOrientationCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frameAbar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R_AbarA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frameBbar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R_BbarB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost of the form <span class="tt">c * (1 - cos(θ))</span>, where θ is the angle between the orientation of frame A and the orientation of frame B, and <code class="param">c</code> is a cost scaling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameAbar</td><td>A frame on the <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>. </td></tr>
    <tr><td class="paramname">R_AbarA</td><td>The rotation matrix describing the orientation of frame A relative to Abar. </td></tr>
    <tr><td class="paramname">frameBbar</td><td>A frame on the <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>. </td></tr>
    <tr><td class="paramname">R_BbarB</td><td>The rotation matrix describing the orientation of frame B relative to Bbar. </td></tr>
    <tr><td class="paramname">c</td><td>A scalar cost weight. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8640101a78303ea3fb07cf7063661483" name="a8640101a78303ea3fb07cf7063661483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8640101a78303ea3fb07cf7063661483">&#9670;&#160;</a></span>AddPointToLineDistanceConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; AddPointToLineDistanceConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_B1P</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_B2Q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>n_B2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>distance_lower</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>distance_upper</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a constraint that the distance between point P attached to frame_point (denoted as B1) and a line attached to frame_line (denoted as B2) is within the range [distance_lower, distance_upper]. </p>
<p>The line passes through a point Q with a directional vector n. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame_point</td><td>The frame to which P is attached. </td></tr>
    <tr><td class="paramname">p_B1P</td><td>The position of P measured and expressed in frame_point. </td></tr>
    <tr><td class="paramname">frame_line</td><td>The frame to which the line is attached. </td></tr>
    <tr><td class="paramname">p_B2Q</td><td>The position of Q measured and expressed in frame_line, the line passes through Q. </td></tr>
    <tr><td class="paramname">n_B2</td><td>The direction vector of the line measured and expressed in frame_line. </td></tr>
    <tr><td class="paramname">distance_lower</td><td>The lower bound on the distance. </td></tr>
    <tr><td class="paramname">distance_upper</td><td>The upper bound on the distance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d8aebd78831688e8c1bb899d28ceed1" name="a4d8aebd78831688e8c1bb899d28ceed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8aebd78831688e8c1bb899d28ceed1">&#9670;&#160;</a></span>AddPointToPointDistanceConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; AddPointToPointDistanceConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_B1P1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_B2P2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>distance_lower</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>distance_upper</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a constraint that the distance between point P1 attached to frame 1 and point P2 attached to frame 2 is within the range [distance_lower, distance_upper]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame1</td><td>The frame to which P1 is attached. </td></tr>
    <tr><td class="paramname">p_B1P1</td><td>The position of P1 measured and expressed in frame 1. </td></tr>
    <tr><td class="paramname">frame2</td><td>The frame to which P2 is attached. </td></tr>
    <tr><td class="paramname">p_B2P2</td><td>The position of P2 measured and expressed in frame 2. </td></tr>
    <tr><td class="paramname">distance_lower</td><td>The lower bound on the distance. </td></tr>
    <tr><td class="paramname">distance_upper</td><td>The upper bound on the distance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a77ae06ea88d1c5a68025faca73e5dc" name="a9a77ae06ea88d1c5a68025faca73e5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a77ae06ea88d1c5a68025faca73e5dc">&#9670;&#160;</a></span>AddPolyhedronConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; AddPolyhedronConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frameF</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frameG</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix3Xd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_GP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the constraint that the position of P1, ..., Pn satisfy A * [p_FP1; p_FP2; ...; p_FPn] &lt;= b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameF</td><td>The frame in which the position P is measured and expressed </td></tr>
    <tr><td class="paramname">frameG</td><td>The frame in which the point P is rigidly attached. </td></tr>
    <tr><td class="paramname">p_GP</td><td>p_GP.col(i) is the position of the i'th point Pi measured and expressed in frame G. </td></tr>
    <tr><td class="paramname">A</td><td>We impose the constraint A * [p_FP1; p_FP2; ...; p_FPn] &lt;= b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>A.cols() = 3 * p_GP.cols(). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>We impose the constraint A * [p_FP1; p_FP2; ...; p_FPn] &lt;= b. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9cd94b6ef67d25a510671af607247f9" name="ad9cd94b6ef67d25a510671af607247f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9cd94b6ef67d25a510671af607247f9">&#9670;&#160;</a></span>AddPositionConstraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; AddPositionConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frameB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_BQ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frameA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_AQ_lower</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_AQ_upper</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the kinematic constraint that a point Q, fixed in frame B, should lie within a bounding box expressed in another frame A as p_AQ_lower &lt;= p_AQ &lt;= p_AQ_upper, where p_AQ is the position of point Q measured and expressed in frame A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameB</td><td>The frame in which point Q is fixed. </td></tr>
    <tr><td class="paramname">p_BQ</td><td>The position of the point Q, rigidly attached to frame B, measured and expressed in frame B. </td></tr>
    <tr><td class="paramname">frameA</td><td>The frame in which the bounding box p_AQ_lower &lt;= p_AQ &lt;= p_AQ_upper is expressed. </td></tr>
    <tr><td class="paramname">p_AQ_lower</td><td>The lower bound on the position of point Q, measured and expressed in frame A. </td></tr>
    <tr><td class="paramname">p_AQ_upper</td><td>The upper bound on the position of point Q, measured and expressed in frame A. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77356d666b4ab74b8248890936a7eee4" name="a77356d666b4ab74b8248890936a7eee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77356d666b4ab74b8248890936a7eee4">&#9670;&#160;</a></span>AddPositionConstraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; AddPositionConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frameB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_BQ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frameAbar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; math::RigidTransformd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_AbarA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_AQ_lower</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_AQ_upper</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the kinematic constraint that a point Q, fixed in frame B, should lie within a bounding box expressed in another frame A as p_AQ_lower &lt;= p_AQ &lt;= p_AQ_upper, where p_AQ is the position of point Q measured and expressed in frame A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameB</td><td>The frame in which point Q is fixed. </td></tr>
    <tr><td class="paramname">p_BQ</td><td>The position of the point Q, rigidly attached to frame B, measured and expressed in frame B. </td></tr>
    <tr><td class="paramname">frameAbar</td><td>We will compute frame A from frame Abar. The bounding box p_AQ_lower &lt;= p_AQ &lt;= p_AQ_upper is expressed in frame A. </td></tr>
    <tr><td class="paramname">X_AbarA</td><td>The relative transform between frame Abar and A. If empty, then we use the identity transform. </td></tr>
    <tr><td class="paramname">p_AQ_lower</td><td>The lower bound on the position of point Q, measured and expressed in frame A. </td></tr>
    <tr><td class="paramname">p_AQ_upper</td><td>The upper bound on the position of point Q, measured and expressed in frame A. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae19a88f45b346d2d37e7e1b2c495c464" name="ae19a88f45b346d2d37e7e1b2c495c464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19a88f45b346d2d37e7e1b2c495c464">&#9670;&#160;</a></span>AddPositionCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">solvers::Cost</a> &gt; AddPositionCost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frameA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_AP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frameB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_BQ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Matrix3d &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a cost of the form (p_AP - p_AQ)ᵀ C (p_AP - p_AQ), where point P is specified relative to frame A and point Q is specified relative to frame B, and the cost is evaluated in frame A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameA</td><td>The frame in which point P's position is measured. </td></tr>
    <tr><td class="paramname">p_AP</td><td>The point P. </td></tr>
    <tr><td class="paramname">frameB</td><td>The frame in which point Q's position is measured. </td></tr>
    <tr><td class="paramname">p_BQ</td><td>The point Q. </td></tr>
    <tr><td class="paramname">C</td><td>A 3x3 matrix representing the cost in quadratic form. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d74e7e1c5b7e2f8280ad16d7fe27f59" name="a9d74e7e1c5b7e2f8280ad16d7fe27f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d74e7e1c5b7e2f8280ad16d7fe27f59">&#9670;&#160;</a></span>context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp; context </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the plant context. </p>

</div>
</div>
<a id="a61a63f33b7cf87252395dc149f454908" name="a61a63f33b7cf87252395dc149f454908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a63f33b7cf87252395dc149f454908">&#9670;&#160;</a></span>get_mutable_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; * get_mutable_context </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the mutable plant context. </p>

</div>
</div>
<a id="ac91be3995339c8e796a88272d5612b6c" name="ac91be3995339c8e796a88272d5612b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91be3995339c8e796a88272d5612b6c">&#9670;&#160;</a></span>get_mutable_prog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> * get_mutable_prog </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the optimization program constructed by <a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html" title="Solves an inverse kinematics (IK) problem on a MultibodyPlant, to find the postures of the robot sati...">InverseKinematics</a>. </p>

</div>
</div>
<a id="ad11f4ad092fc1e40a44be225138d38e9" name="ad11f4ad092fc1e40a44be225138d38e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11f4ad092fc1e40a44be225138d38e9">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c2d067105b9effe872abe1ed9c431c1" name="a6c2d067105b9effe872abe1ed9c431c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2d067105b9effe872abe1ed9c431c1">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab54111eab638313c328fc0a0f1b50944" name="ab54111eab638313c328fc0a0f1b50944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54111eab638313c328fc0a0f1b50944">&#9670;&#160;</a></span>prog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> &amp; prog </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the optimization program constructed by <a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html" title="Solves an inverse kinematics (IK) problem on a MultibodyPlant, to find the postures of the robot sati...">InverseKinematics</a>. </p>

</div>
</div>
<a id="a9d9bc4d98911ca9808bec31c2f564560" name="a9d9bc4d98911ca9808bec31c2f564560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d9bc4d98911ca9808bec31c2f564560">&#9670;&#160;</a></span>q()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> &amp; q </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for q. </p>
<p>q is the decision variable for the generalized positions of the robot. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/multibody/inverse_kinematics/<a class="el" href="inverse__kinematics_8h.html">inverse_kinematics.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
