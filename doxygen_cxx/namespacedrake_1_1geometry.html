<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake::geometry Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacedrake_1_1geometry.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">drake::geometry Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedrake_1_1geometry_1_1optimization"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html">optimization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1geometry_1_1proximity"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry_1_1proximity.html">proximity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1geometry_1_1render"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry_1_1render.html">render</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_box.html">Box</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a box.  <a href="classdrake_1_1geometry_1_1_box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_capsule.html">Capsule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a capsule.  <a href="classdrake_1_1geometry_1_1_capsule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_collision_filter_declaration.html">CollisionFilterDeclaration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for articulating changes to the configuration of <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>'s "collision filters"; collision filters limit the scope of various proximity queries.  <a href="classdrake_1_1geometry_1_1_collision_filter_declaration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ContactSurface characterizes the intersection of two geometries M and N as a contact surface with a scalar field and a vector field, whose purpose is to support the hydroelastic pressure field contact model as described in:  <a href="classdrake_1_1geometry_1_1_contact_surface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_convex.html">Convex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for convex shapes.  <a href="classdrake_1_1geometry_1_1_convex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_cylinder.html">Cylinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a cylinder.  <a href="classdrake_1_1geometry_1_1_cylinder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_drake_visualizer.html">DrakeVisualizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A system that publishes LCM messages compatible with the <code>drake_visualizer</code> application representing the current state of a <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> instance (whose QueryObject-valued output port is connected to this system's input port).  <a href="classdrake_1_1geometry_1_1_drake_visualizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1_drake_visualizer_params.html">DrakeVisualizerParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of parameters for configuring <a class="el" href="classdrake_1_1geometry_1_1_drake_visualizer.html" title="A system that publishes LCM messages compatible with the drake_visualizer application representing th...">DrakeVisualizer</a>.  <a href="structdrake_1_1geometry_1_1_drake_visualizer_params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_drake_visualizer_test.html">DrakeVisualizerTest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_ellipsoid.html">Ellipsoid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of an ellipsoid.  <a href="classdrake_1_1geometry_1_1_ellipsoid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_frame_kinematics_vector.html">FrameKinematicsVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A FrameKinematicsVector is used to report kinematics data for registered frames (identified by unique FrameId values) to <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>.  <a href="classdrake_1_1geometry_1_1_frame_kinematics_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_frame.html">GeometryFrame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This simple class carries the definition of a frame used in the <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>.  <a href="classdrake_1_1geometry_1_1_geometry_frame.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to identify geometry instances in <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>.  <a href="classdrake_1_1geometry_1_1_geometry_id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">GeometryInstance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A geometry instance combines a geometry definition (i.e., a shape of some sort), a pose (relative to a parent "frame" P), material information, and an opaque collection of metadata.  <a href="classdrake_1_1geometry_1_1_geometry_instance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for defining a set of geometry properties.  <a href="classdrake_1_1geometry_1_1_geometry_properties.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_set.html">GeometrySet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The GeometrySet, as its name implies, is a convenience class for defining a set of geometries.  <a href="classdrake_1_1geometry_1_1_geometry_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_set_tester.html">GeometrySetTester</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_state.html">GeometryState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The context-dependent state of <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>.  <a href="classdrake_1_1geometry_1_1_geometry_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_version.html">GeometryVersion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version numbering class that reports revisions of <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>'s geometric data.  <a href="classdrake_1_1geometry_1_1_geometry_version.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_half_space.html">HalfSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a half space.  <a href="classdrake_1_1geometry_1_1_half_space.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html">IllustrationProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of properties for geometry used in an "illustration" role.  <a href="classdrake_1_1geometry_1_1_illustration_properties.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh.html">Mesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limited support for meshes.  <a href="classdrake_1_1geometry_1_1_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MeshFieldLinear represents a continuous piecewise-linear scalar field <code>f</code> defined on a (triangular or tetrahedral) mesh; the field value changes linearly within each element E (triangle or tetrahedron), and the gradient ∇f is constant within each element.  <a href="classdrake_1_1geometry_1_1_mesh_field_linear.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html">PenetrationAsPointPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A characterization of the intersection of two penetrating geometries.  <a href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_perception_properties.html">PerceptionProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of properties for geometry used in a "perception" role.  <a href="classdrake_1_1geometry_1_1_perception_properties.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1promoted__numerical.html">promoted_numerical</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the two scalar types U and T, returns the most "promoted" type.  <a href="structdrake_1_1geometry_1_1promoted__numerical.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of properties for geometry used in a <em>proximity</em> role.  <a href="classdrake_1_1geometry_1_1_proximity_properties.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The QueryObject serves as a mechanism to perform geometry queries on the world's geometry.  <a href="classdrake_1_1geometry_1_1_query_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_rgba.html">Rgba</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines RGBA (red, green, blue, alpha) values on the range [0, 1].  <a href="classdrake_1_1geometry_1_1_rgba.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">SceneGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> serves as the nexus for all geometry (and geometry-based operations) in a Diagram.  <a href="classdrake_1_1geometry_1_1_scene_graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html">SceneGraphInspector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SceneGraphInspector serves as a mechanism to query the topological structure of a <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> instance.  <a href="classdrake_1_1geometry_1_1_scene_graph_inspector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_shape.html">Shape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base interface for all shape specifications.  <a href="classdrake_1_1geometry_1_1_shape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_shape_name.html">ShapeName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that reports the name of the type of shape being reified (e.g., <a class="el" href="classdrake_1_1geometry_1_1_sphere.html" title="Definition of sphere.">Sphere</a>, <a class="el" href="classdrake_1_1geometry_1_1_box.html" title="Definition of a box.">Box</a>, etc.)  <a href="classdrake_1_1geometry_1_1_shape_name.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_shape_reifier.html">ShapeReifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The interface for converting shape descriptions to real shapes.  <a href="classdrake_1_1geometry_1_1_shape_reifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1_shape_tag.html">ShapeTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple struct for instantiating the type-specific <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The base interface for all shape specifications.">Shape</a> functionality.  <a href="structdrake_1_1geometry_1_1_shape_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1_signed_distance_pair.html">SignedDistancePair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data for reporting the signed distance between two geometries, A and B.  <a href="structdrake_1_1geometry_1_1_signed_distance_pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1_signed_distance_to_point.html">SignedDistanceToPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data for reporting the signed distance from a query point to a geometry.  <a href="structdrake_1_1geometry_1_1_signed_distance_to_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_sphere.html">Sphere</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of sphere.  <a href="classdrake_1_1geometry_1_1_sphere.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_face.html">SurfaceFace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SurfaceFace represents a triangular face in a <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html" title="SurfaceMesh represents a triangulated surface.">SurfaceMesh</a>.  <a href="classdrake_1_1geometry_1_1_surface_face.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SurfaceMesh represents a triangulated surface.  <a href="classdrake_1_1geometry_1_1_surface_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh_tester.html">SurfaceMeshTester</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_vertex.html">SurfaceVertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SurfaceVertex represents a vertex in <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html" title="SurfaceMesh represents a triangulated surface.">SurfaceMesh</a>.  <a href="classdrake_1_1geometry_1_1_surface_vertex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_volume_element.html">VolumeElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">VolumeElement represents a tetrahedral element in a <a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html" title="VolumeMesh represents a tetrahedral volume mesh.">VolumeMesh</a>.  <a href="classdrake_1_1geometry_1_1_volume_element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html">VolumeMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">VolumeMesh represents a tetrahedral volume mesh.  <a href="classdrake_1_1geometry_1_1_volume_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_volume_mesh_tester.html">VolumeMeshTester</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_volume_vertex.html">VolumeVertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">VolumeVertex represents a vertex in <a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html" title="VolumeMesh represents a tetrahedral volume mesh.">VolumeMesh</a>.  <a href="classdrake_1_1geometry_1_1_volume_vertex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acbab8995daa433cebfc335ffe8ae8fd0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#acbab8995daa433cebfc335ffe8ae8fd0">DrakeVisualizerd</a> = <a class="el" href="classdrake_1_1geometry_1_1_drake_visualizer.html">DrakeVisualizer</a>&lt; double &gt;</td></tr>
<tr class="memdesc:acbab8995daa433cebfc335ffe8ae8fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient alias for the <a class="el" href="classdrake_1_1geometry_1_1_drake_visualizer.html" title="A system that publishes LCM messages compatible with the drake_visualizer application representing th...">DrakeVisualizer</a> class when using the <code>double</code> scalar type.  <a href="#acbab8995daa433cebfc335ffe8ae8fd0">More...</a><br /></td></tr>
<tr class="separator:acbab8995daa433cebfc335ffe8ae8fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ace159b1ce98627d4af8aeb8c681087"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4ace159b1ce98627d4af8aeb8c681087"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#a4ace159b1ce98627d4af8aeb8c681087">FramePoseVector</a> = <a class="el" href="classdrake_1_1geometry_1_1_frame_kinematics_vector.html">FrameKinematicsVector</a>&lt; <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a4ace159b1ce98627d4af8aeb8c681087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for communicating <em>pose</em> information to <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> for registered frames.  <a href="#a4ace159b1ce98627d4af8aeb8c681087">More...</a><br /></td></tr>
<tr class="separator:a4ace159b1ce98627d4af8aeb8c681087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53cb597123131fb23a7af26e8d350bf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#ac53cb597123131fb23a7af26e8d350bf">SourceId</a> = <a class="el" href="classdrake_1_1_identifier.html">drake::Identifier</a>&lt; class SourceTag &gt;</td></tr>
<tr class="memdesc:ac53cb597123131fb23a7af26e8d350bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to identify geometry sources in <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>.  <a href="#ac53cb597123131fb23a7af26e8d350bf">More...</a><br /></td></tr>
<tr class="separator:ac53cb597123131fb23a7af26e8d350bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b41363b37fadf8cce0977d500e13cb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> = <a class="el" href="classdrake_1_1_identifier.html">drake::Identifier</a>&lt; class FrameTag &gt;</td></tr>
<tr class="memdesc:a43b41363b37fadf8cce0977d500e13cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to identify geometry frames in <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>.  <a href="#a43b41363b37fadf8cce0977d500e13cb">More...</a><br /></td></tr>
<tr class="separator:a43b41363b37fadf8cce0977d500e13cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d902a71edc021497a25d2001b2af76"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#aa5d902a71edc021497a25d2001b2af76">FrameIndex</a> = <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; class GeometryTag &gt;</td></tr>
<tr class="memdesc:aa5d902a71edc021497a25d2001b2af76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index into the ordered vector of all registered frames &ndash; by convention, the world frame's index is always zero.  <a href="#aa5d902a71edc021497a25d2001b2af76">More...</a><br /></td></tr>
<tr class="separator:aa5d902a71edc021497a25d2001b2af76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b8d905842571b365085fdd17378772"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a74b8d905842571b365085fdd17378772"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#a74b8d905842571b365085fdd17378772">promoted_numerical_t</a> = typename <a class="el" href="structdrake_1_1geometry_1_1promoted__numerical.html">promoted_numerical</a>&lt; T, U &gt;::type</td></tr>
<tr class="separator:a74b8d905842571b365085fdd17378772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6bae4ff910e57daa4b0ac8e4f481b8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#a4b6bae4ff910e57daa4b0ac8e4f481b8">SurfaceVertexIndex</a> = <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; class SurfaceVertexTag &gt;</td></tr>
<tr class="memdesc:a4b6bae4ff910e57daa4b0ac8e4f481b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index used to identify a vertex in a surface mesh.  <a href="#a4b6bae4ff910e57daa4b0ac8e4f481b8">More...</a><br /></td></tr>
<tr class="separator:a4b6bae4ff910e57daa4b0ac8e4f481b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831785d5225564e2a531b4fd2445e1d6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#a831785d5225564e2a531b4fd2445e1d6">SurfaceFaceIndex</a> = <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; class SurfaceFaceTag &gt;</td></tr>
<tr class="memdesc:a831785d5225564e2a531b4fd2445e1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index for identifying a triangular face in a surface mesh.  <a href="#a831785d5225564e2a531b4fd2445e1d6">More...</a><br /></td></tr>
<tr class="separator:a831785d5225564e2a531b4fd2445e1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8521ca427b948bf56882cae0363bd4"><td class="memTemplParams" colspan="2">template&lt;typename FieldValue , typename T &gt; </td></tr>
<tr class="memitem:aeb8521ca427b948bf56882cae0363bd4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#aeb8521ca427b948bf56882cae0363bd4">SurfaceMeshFieldLinear</a> = <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a>&lt; FieldValue, <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:aeb8521ca427b948bf56882cae0363bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for instantiating a <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a> on a <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html" title="SurfaceMesh represents a triangulated surface.">SurfaceMesh</a>.  <a href="#aeb8521ca427b948bf56882cae0363bd4">More...</a><br /></td></tr>
<tr class="separator:aeb8521ca427b948bf56882cae0363bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aba540a75351aad1e183ae9accf234c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#a2aba540a75351aad1e183ae9accf234c">VolumeVertexIndex</a> = <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; class VolumeVertexTag &gt;</td></tr>
<tr class="memdesc:a2aba540a75351aad1e183ae9accf234c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index used to identify a vertex in a volume mesh.  <a href="#a2aba540a75351aad1e183ae9accf234c">More...</a><br /></td></tr>
<tr class="separator:a2aba540a75351aad1e183ae9accf234c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521e6b89e03b3021766886e2270056b6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#a521e6b89e03b3021766886e2270056b6">VolumeElementIndex</a> = <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; class VolumeElementTag &gt;</td></tr>
<tr class="memdesc:a521e6b89e03b3021766886e2270056b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index for identifying a tetrahedral element in a volume mesh.  <a href="#a521e6b89e03b3021766886e2270056b6">More...</a><br /></td></tr>
<tr class="separator:a521e6b89e03b3021766886e2270056b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0a99208aa3dea5d4a3094f4fdf9274"><td class="memTemplParams" colspan="2">template&lt;typename FieldValue , typename T &gt; </td></tr>
<tr class="memitem:a6f0a99208aa3dea5d4a3094f4fdf9274"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#a6f0a99208aa3dea5d4a3094f4fdf9274">VolumeMeshFieldLinear</a> = <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a>&lt; FieldValue, <a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html">VolumeMesh</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a6f0a99208aa3dea5d4a3094f4fdf9274"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for instantiating a <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a> on a <a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html" title="VolumeMesh represents a tetrahedral volume mesh.">VolumeMesh</a>.  <a href="#a6f0a99208aa3dea5d4a3094f4fdf9274">More...</a><br /></td></tr>
<tr class="separator:a6f0a99208aa3dea5d4a3094f4fdf9274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Structures for maintaining the entity relationships</div></td></tr>
<tr class="memitem:a3a71d18e80aa6fba962ddd8a33aecb05"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#a3a71d18e80aa6fba962ddd8a33aecb05">FrameIdSet</a> = std::unordered_set&lt; <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> &gt;</td></tr>
<tr class="memdesc:a3a71d18e80aa6fba962ddd8a33aecb05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of unique frame ids.  <a href="#a3a71d18e80aa6fba962ddd8a33aecb05">More...</a><br /></td></tr>
<tr class="separator:a3a71d18e80aa6fba962ddd8a33aecb05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:acdd79a1a4f81dd6ee5cddcb21149b951"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#acdd79a1a4f81dd6ee5cddcb21149b951">Role</a> { <a class="el" href="namespacedrake_1_1geometry.html#acdd79a1a4f81dd6ee5cddcb21149b951a41ba12ed492ce20c3ff503a553ae85ea">kUnassigned</a> = 0x0, 
<a class="el" href="namespacedrake_1_1geometry.html#acdd79a1a4f81dd6ee5cddcb21149b951ad909c44a5dea6ebbdb3a95e4cb701521">kProximity</a> = 0x1, 
<a class="el" href="namespacedrake_1_1geometry.html#acdd79a1a4f81dd6ee5cddcb21149b951aac28e5ab68fbe5dc23f550aa18255c07">kIllustration</a> = 0x2, 
<a class="el" href="namespacedrake_1_1geometry.html#acdd79a1a4f81dd6ee5cddcb21149b951ac1f9a0ba01987bd1d23d1c4ea605df2b">kPerception</a> = 0x4
 }</td></tr>
<tr class="memdesc:acdd79a1a4f81dd6ee5cddcb21149b951"><td class="mdescLeft">&#160;</td><td class="mdescRight">General enumeration for indicating geometry role.  <a href="namespacedrake_1_1geometry.html#acdd79a1a4f81dd6ee5cddcb21149b951">More...</a><br /></td></tr>
<tr class="separator:acdd79a1a4f81dd6ee5cddcb21149b951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f8cb466b0827379bc8815f0d58aac3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#a52f8cb466b0827379bc8815f0d58aac3">RoleAssign</a> { <a class="el" href="namespacedrake_1_1geometry.html#a52f8cb466b0827379bc8815f0d58aac3aaf1adf7ec3673b4f5765cfbc5d43b7dc">kNew</a>, 
<a class="el" href="namespacedrake_1_1geometry.html#a52f8cb466b0827379bc8815f0d58aac3a8ba1782ca7c04c255b3d69d6d2411d90">kReplace</a>
 }</td></tr>
<tr class="memdesc:a52f8cb466b0827379bc8815f0d58aac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operations that can be performed on the given properties when assigning roles to geometry.  <a href="namespacedrake_1_1geometry.html#a52f8cb466b0827379bc8815f0d58aac3">More...</a><br /></td></tr>
<tr class="separator:a52f8cb466b0827379bc8815f0d58aac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a40ca141e2cff1416ab27b5234409dcf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#a40ca141e2cff1416ab27b5234409dcf5">ReadObjToSurfaceMesh</a> (const std::string &amp;filename, double scale=1.0, std::function&lt; void(std::string_view)&gt; on_warning={})</td></tr>
<tr class="memdesc:a40ca141e2cff1416ab27b5234409dcf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a surface mesh from a Wavefront .obj file and optionally scales coordinates by the given scale factor.  <a href="#a40ca141e2cff1416ab27b5234409dcf5">More...</a><br /></td></tr>
<tr class="separator:a40ca141e2cff1416ab27b5234409dcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78decc4125a80819440fcc2f16f6f8d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#a78decc4125a80819440fcc2f16f6f8d9">ReadObjToSurfaceMesh</a> (std::istream *input_stream, double scale=1.0, std::function&lt; void(std::string_view)&gt; on_warning={})</td></tr>
<tr class="memdesc:a78decc4125a80819440fcc2f16f6f8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of ReadObjToSurfaceMesh(const std::string&amp;, double) with the Wavefront .obj file given in std::istream.  <a href="#a78decc4125a80819440fcc2f16f6f8d9">More...</a><br /></td></tr>
<tr class="separator:a78decc4125a80819440fcc2f16f6f8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2134db5f8753db883df9439aa2c38814"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#a2134db5f8753db883df9439aa2c38814">operator==</a> (const <a class="el" href="classdrake_1_1geometry_1_1_volume_element.html">VolumeElement</a> &amp;e1, const <a class="el" href="classdrake_1_1geometry_1_1_volume_element.html">VolumeElement</a> &amp;e2)</td></tr>
<tr class="separator:a2134db5f8753db883df9439aa2c38814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15599d92370af7b991c4a593f6103376"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#a15599d92370af7b991c4a593f6103376">operator!=</a> (const <a class="el" href="classdrake_1_1geometry_1_1_volume_element.html">VolumeElement</a> &amp;e1, const <a class="el" href="classdrake_1_1geometry_1_1_volume_element.html">VolumeElement</a> &amp;e2)</td></tr>
<tr class="separator:a15599d92370af7b991c4a593f6103376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76ed94bef3f81765a1b3ce069562e00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#af76ed94bef3f81765a1b3ce069562e00">AddRigidHydroelasticProperties</a> (double resolution_hint, <a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *properties)</td></tr>
<tr class="memdesc:af76ed94bef3f81765a1b3ce069562e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds properties to the given set of proximity properties sufficient to cause the associated geometry to generate a rigid hydroelastic representation.  <a href="#af76ed94bef3f81765a1b3ce069562e00">More...</a><br /></td></tr>
<tr class="separator:af76ed94bef3f81765a1b3ce069562e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d24de26748b70a3c802fd171b150fc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#a7d24de26748b70a3c802fd171b150fc2">AddRigidHydroelasticProperties</a> (<a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *properties)</td></tr>
<tr class="memdesc:a7d24de26748b70a3c802fd171b150fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload, intended for shapes that don't get tessellated in their hydroelastic representation (e.g., <a class="el" href="classdrake_1_1geometry_1_1_half_space.html" title="Definition of a half space.">HalfSpace</a> and <a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Limited support for meshes.">Mesh</a>).  <a href="#a7d24de26748b70a3c802fd171b150fc2">More...</a><br /></td></tr>
<tr class="separator:a7d24de26748b70a3c802fd171b150fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c01c8e61753cdc77272c430c452968"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#ab8c01c8e61753cdc77272c430c452968">AddSoftHydroelasticProperties</a> (double resolution_hint, <a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *properties)</td></tr>
<tr class="memdesc:ab8c01c8e61753cdc77272c430c452968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds properties to the given set of proximity properties sufficient to cause the associated geometry to generate a soft hydroelastic representation.  <a href="#ab8c01c8e61753cdc77272c430c452968">More...</a><br /></td></tr>
<tr class="separator:ab8c01c8e61753cdc77272c430c452968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d4f8a99b181dd9968667b7d4daefdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#a43d4f8a99b181dd9968667b7d4daefdf">AddSoftHydroelasticProperties</a> (<a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *properties)</td></tr>
<tr class="memdesc:a43d4f8a99b181dd9968667b7d4daefdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload, intended for shapes that don't get tessellated in their hydroelastic representation (e.g., <a class="el" href="classdrake_1_1geometry_1_1_half_space.html" title="Definition of a half space.">HalfSpace</a>).  <a href="#a43d4f8a99b181dd9968667b7d4daefdf">More...</a><br /></td></tr>
<tr class="separator:a43d4f8a99b181dd9968667b7d4daefdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22f40ec627443c415b558cee11e111e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#ad22f40ec627443c415b558cee11e111e">AddSoftHydroelasticPropertiesForHalfSpace</a> (double slab_thickness, <a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *properties)</td></tr>
<tr class="memdesc:ad22f40ec627443c415b558cee11e111e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Soft half spaces are handled as a special case; they do not get tessellated.  <a href="#ad22f40ec627443c415b558cee11e111e">More...</a><br /></td></tr>
<tr class="separator:ad22f40ec627443c415b558cee11e111e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Geometry role to string conversions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are simply convenience functions for converting the Role enumeration into a human-readable string.</p>
</div></td></tr>
<tr class="memitem:a660dff0520608baf7e7f09861d6fa8f5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#a660dff0520608baf7e7f09861d6fa8f5">to_string</a> (const <a class="el" href="namespacedrake_1_1geometry.html#acdd79a1a4f81dd6ee5cddcb21149b951">Role</a> &amp;role)</td></tr>
<tr class="separator:a660dff0520608baf7e7f09861d6fa8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152c7124632aaba612f6b59e0510957e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#a152c7124632aaba612f6b59e0510957e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="namespacedrake_1_1geometry.html#acdd79a1a4f81dd6ee5cddcb21149b951">Role</a> &amp;role)</td></tr>
<tr class="separator:a152c7124632aaba612f6b59e0510957e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Convenience functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>A collection of functions to help facilitate working with properties.</p>
</div></td></tr>
<tr class="memitem:aa70628317c9ed8d19606fee0d13643a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html">IllustrationProperties</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#aa70628317c9ed8d19606fee0d13643a5">MakePhongIllustrationProperties</a> (const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; double &gt; &amp;diffuse)</td></tr>
<tr class="memdesc:aa70628317c9ed8d19606fee0d13643a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html" title="The set of properties for geometry used in an &quot;illustration&quot; role.">IllustrationProperties</a> instance compatible with a simple "phong" material using only the given <code>diffuse</code> color.  <a href="#aa70628317c9ed8d19606fee0d13643a5">More...</a><br /></td></tr>
<tr class="separator:aa70628317c9ed8d19606fee0d13643a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Contact Material Utility Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="contact_material_utility_functions"></a> <a class="el" href="namespacedrake_1_1geometry.html#a75b8bc3ef835424639b5aa5e0874121b">AddContactMaterial()</a> adds contact material properties to the given set of proximity <code>properties</code>. Only the parameters that carry values will be added to the given set of <code>properties</code>; no default values will be provided. Downstream consumers of the contact materials can optionally provide defaults for missing properties.</p>
<p>For legacy and backwards compatibility purposes, two overloads for <a class="el" href="namespacedrake_1_1geometry.html#a75b8bc3ef835424639b5aa5e0874121b">AddContactMaterial()</a> are provided. One supports all contact material properties <b>except</b> <code>point_stiffness</code>, and the other includes it. Users are encouraged to use the overload that contains the argument for <code>point_stiffness</code>.</p>
<p>These functions will throw an error if:</p><ul>
<li><code>elastic_modulus</code> is not positive</li>
<li><code>dissipation</code> is negative</li>
<li><code>point_stiffness</code> is not positive</li>
<li>Any of the contact material properties have already been defined in <code>properties</code>. </li>
</ul>
</div></td></tr>
<tr class="memitem:a75b8bc3ef835424639b5aa5e0874121b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#a75b8bc3ef835424639b5aa5e0874121b">AddContactMaterial</a> (const std::optional&lt; double &gt; &amp;elastic_modulus, const std::optional&lt; double &gt; &amp;dissipation, const std::optional&lt; double &gt; &amp;point_stiffness, const std::optional&lt; <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">multibody::CoulombFriction</a>&lt; double &gt;&gt; &amp;friction, <a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *properties)</td></tr>
<tr class="separator:a75b8bc3ef835424639b5aa5e0874121b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994429610a1aadf4521959e996c5cfac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry.html#a994429610a1aadf4521959e996c5cfac">AddContactMaterial</a> (const std::optional&lt; double &gt; &amp;elastic_modulus, const std::optional&lt; double &gt; &amp;dissipation, const std::optional&lt; <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">multibody::CoulombFriction</a>&lt; double &gt;&gt; &amp;friction, <a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *properties)</td></tr>
<tr class="separator:a994429610a1aadf4521959e996c5cfac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="acbab8995daa433cebfc335ffe8ae8fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbab8995daa433cebfc335ffe8ae8fd0">&#9670;&nbsp;</a></span>DrakeVisualizerd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1geometry.html#acbab8995daa433cebfc335ffe8ae8fd0">DrakeVisualizerd</a> =  <a class="el" href="classdrake_1_1geometry_1_1_drake_visualizer.html">DrakeVisualizer</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenient alias for the <a class="el" href="classdrake_1_1geometry_1_1_drake_visualizer.html" title="A system that publishes LCM messages compatible with the drake_visualizer application representing th...">DrakeVisualizer</a> class when using the <code>double</code> scalar type. </p>

</div>
</div>
<a id="a43b41363b37fadf8cce0977d500e13cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b41363b37fadf8cce0977d500e13cb">&#9670;&nbsp;</a></span>FrameId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> =  <a class="el" href="classdrake_1_1_identifier.html">drake::Identifier</a>&lt;class FrameTag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used to identify geometry frames in <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>. </p>

</div>
</div>
<a id="a3a71d18e80aa6fba962ddd8a33aecb05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a71d18e80aa6fba962ddd8a33aecb05">&#9670;&nbsp;</a></span>FrameIdSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1geometry.html#a3a71d18e80aa6fba962ddd8a33aecb05">FrameIdSet</a> =  std::unordered_set&lt;<a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collection of unique frame ids. </p>

</div>
</div>
<a id="aa5d902a71edc021497a25d2001b2af76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d902a71edc021497a25d2001b2af76">&#9670;&nbsp;</a></span>FrameIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1geometry.html#aa5d902a71edc021497a25d2001b2af76">FrameIndex</a> =  <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt;class GeometryTag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index into the ordered vector of all registered frames &ndash; by convention, the world frame's index is always zero. </p>

</div>
</div>
<a id="a4ace159b1ce98627d4af8aeb8c681087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ace159b1ce98627d4af8aeb8c681087">&#9670;&nbsp;</a></span>FramePoseVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1geometry.html#a4ace159b1ce98627d4af8aeb8c681087">FramePoseVector</a> =  <a class="el" href="classdrake_1_1geometry_1_1_frame_kinematics_vector.html">FrameKinematicsVector</a>&lt;<a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class for communicating <em>pose</em> information to <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> for registered frames. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74b8d905842571b365085fdd17378772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b8d905842571b365085fdd17378772">&#9670;&nbsp;</a></span>promoted_numerical_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1geometry.html#a74b8d905842571b365085fdd17378772">promoted_numerical_t</a> =  typename <a class="el" href="structdrake_1_1geometry_1_1promoted__numerical.html">promoted_numerical</a>&lt;T, U&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac53cb597123131fb23a7af26e8d350bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53cb597123131fb23a7af26e8d350bf">&#9670;&nbsp;</a></span>SourceId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1geometry.html#ac53cb597123131fb23a7af26e8d350bf">SourceId</a> =  <a class="el" href="classdrake_1_1_identifier.html">drake::Identifier</a>&lt;class SourceTag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used to identify geometry sources in <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>. </p>

</div>
</div>
<a id="a831785d5225564e2a531b4fd2445e1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831785d5225564e2a531b4fd2445e1d6">&#9670;&nbsp;</a></span>SurfaceFaceIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1geometry.html#a831785d5225564e2a531b4fd2445e1d6">SurfaceFaceIndex</a> =  <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt;class SurfaceFaceTag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index for identifying a triangular face in a surface mesh. </p>

</div>
</div>
<a id="aeb8521ca427b948bf56882cae0363bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8521ca427b948bf56882cae0363bd4">&#9670;&nbsp;</a></span>SurfaceMeshFieldLinear</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1geometry.html#aeb8521ca427b948bf56882cae0363bd4">SurfaceMeshFieldLinear</a> =  <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a>&lt;FieldValue, <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience alias for instantiating a <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a> on a <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html" title="SurfaceMesh represents a triangulated surface.">SurfaceMesh</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FieldValue</td><td>A valid Eigen scalar or vector of valid Eigen scalars for the field value. </td></tr>
    <tr><td class="paramname">T</td><td>A valid Eigen scalar for mesh coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b6bae4ff910e57daa4b0ac8e4f481b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6bae4ff910e57daa4b0ac8e4f481b8">&#9670;&nbsp;</a></span>SurfaceVertexIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1geometry.html#a4b6bae4ff910e57daa4b0ac8e4f481b8">SurfaceVertexIndex</a> =  <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt;class SurfaceVertexTag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index used to identify a vertex in a surface mesh. </p>

</div>
</div>
<a id="a521e6b89e03b3021766886e2270056b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521e6b89e03b3021766886e2270056b6">&#9670;&nbsp;</a></span>VolumeElementIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1geometry.html#a521e6b89e03b3021766886e2270056b6">VolumeElementIndex</a> =  <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt;class VolumeElementTag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index for identifying a tetrahedral element in a volume mesh. </p>

</div>
</div>
<a id="a6f0a99208aa3dea5d4a3094f4fdf9274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0a99208aa3dea5d4a3094f4fdf9274">&#9670;&nbsp;</a></span>VolumeMeshFieldLinear</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1geometry.html#a6f0a99208aa3dea5d4a3094f4fdf9274">VolumeMeshFieldLinear</a> =  <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a>&lt;FieldValue, <a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html">VolumeMesh</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience alias for instantiating a <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a> on a <a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html" title="VolumeMesh represents a tetrahedral volume mesh.">VolumeMesh</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FieldValue</td><td>A valid Eigen scalar or vector of valid Eigen scalars for the field value. </td></tr>
    <tr><td class="paramname">T</td><td>A valid Eigen scalar for mesh coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2aba540a75351aad1e183ae9accf234c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aba540a75351aad1e183ae9accf234c">&#9670;&nbsp;</a></span>VolumeVertexIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1geometry.html#a2aba540a75351aad1e183ae9accf234c">VolumeVertexIndex</a> =  <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt;class VolumeVertexTag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index used to identify a vertex in a volume mesh. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="acdd79a1a4f81dd6ee5cddcb21149b951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd79a1a4f81dd6ee5cddcb21149b951">&#9670;&nbsp;</a></span>Role</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1geometry.html#acdd79a1a4f81dd6ee5cddcb21149b951">Role</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>General enumeration for indicating geometry role. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acdd79a1a4f81dd6ee5cddcb21149b951a41ba12ed492ce20c3ff503a553ae85ea"></a>kUnassigned&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acdd79a1a4f81dd6ee5cddcb21149b951ad909c44a5dea6ebbdb3a95e4cb701521"></a>kProximity&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acdd79a1a4f81dd6ee5cddcb21149b951aac28e5ab68fbe5dc23f550aa18255c07"></a>kIllustration&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acdd79a1a4f81dd6ee5cddcb21149b951ac1f9a0ba01987bd1d23d1c4ea605df2b"></a>kPerception&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a52f8cb466b0827379bc8815f0d58aac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f8cb466b0827379bc8815f0d58aac3">&#9670;&nbsp;</a></span>RoleAssign</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1geometry.html#a52f8cb466b0827379bc8815f0d58aac3">RoleAssign</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The operations that can be performed on the given properties when assigning roles to geometry. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a52f8cb466b0827379bc8815f0d58aac3aaf1adf7ec3673b4f5765cfbc5d43b7dc"></a>kNew&#160;</td><td class="fielddoc"><p>Assign the properties to a geometry that doesn't already have the role. </p>
</td></tr>
<tr><td class="fieldname"><a id="a52f8cb466b0827379bc8815f0d58aac3a8ba1782ca7c04c255b3d69d6d2411d90"></a>kReplace&#160;</td><td class="fielddoc"><p>Replace the existing role properties completely. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a75b8bc3ef835424639b5aa5e0874121b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b8bc3ef835424639b5aa5e0874121b">&#9670;&nbsp;</a></span>AddContactMaterial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::geometry::AddContactMaterial </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>elastic_modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dissipation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_stiffness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">multibody::CoulombFriction</a>&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>friction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if any parameter doesn't satisfy the requirements listed in <a class="el" href="namespacedrake_1_1geometry.html#contact_material_utility_functions">Contact Material Utility Functions</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a994429610a1aadf4521959e996c5cfac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994429610a1aadf4521959e996c5cfac">&#9670;&nbsp;</a></span>AddContactMaterial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::geometry::AddContactMaterial </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>elastic_modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dissipation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">multibody::CoulombFriction</a>&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>friction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>Please use the overload of <a class="el" href="namespacedrake_1_1geometry.html#a75b8bc3ef835424639b5aa5e0874121b">AddContactMaterial()</a> that includes the argument for <code>point_stiffness</code> rather than this one. </dd></dl>

</div>
</div>
<a id="af76ed94bef3f81765a1b3ce069562e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af76ed94bef3f81765a1b3ce069562e00">&#9670;&nbsp;</a></span>AddRigidHydroelasticProperties() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::geometry::AddRigidHydroelasticProperties </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution_hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds properties to the given set of proximity properties sufficient to cause the associated geometry to generate a rigid hydroelastic representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">resolution_hint</td><td>If the geometry is to be tessellated, it is the parameter that guides the level of mesh refinement. See MODULE_NOT_WRITTEN_YET. This will be ignored for geometry types that don't require tessellation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">properties</td><td>The properties will be added to this property set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>If <code>properties</code> already has properties with the names that this function would need to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt; <code>resolution_hint</code> &lt; ∞ and <code>properties</code> is not nullptr. </dd></dl>

</div>
</div>
<a id="a7d24de26748b70a3c802fd171b150fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d24de26748b70a3c802fd171b150fc2">&#9670;&nbsp;</a></span>AddRigidHydroelasticProperties() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::geometry::AddRigidHydroelasticProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *&#160;</td>
          <td class="paramname"><em>properties</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload, intended for shapes that don't get tessellated in their hydroelastic representation (e.g., <a class="el" href="classdrake_1_1geometry_1_1_half_space.html" title="Definition of a half space.">HalfSpace</a> and <a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Limited support for meshes.">Mesh</a>). </p>
<p>See MODULE_NOT_WRITTEN_YET. </p>

</div>
</div>
<a id="ab8c01c8e61753cdc77272c430c452968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c01c8e61753cdc77272c430c452968">&#9670;&nbsp;</a></span>AddSoftHydroelasticProperties() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::geometry::AddSoftHydroelasticProperties </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution_hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds properties to the given set of proximity properties sufficient to cause the associated geometry to generate a soft hydroelastic representation. </p>
<p>The geometry's pressure field will be the function p(e) = Ee, where E is the elastic modulus stored in the given <code>properties</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">resolution_hint</td><td>If the geometry is to be tessellated, it is the parameter that guides the level of mesh refinement. This will be ignored for geometry types that don't require tessellation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">properties</td><td>The properties will be added to this property set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>If <code>properties</code> already has properties with the names that this function would need to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt; <code>resolution_hint</code> &lt; ∞, <code>properties</code> is not nullptr, and <code>properties</code> contains a valid elastic modulus value. </dd></dl>

</div>
</div>
<a id="a43d4f8a99b181dd9968667b7d4daefdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d4f8a99b181dd9968667b7d4daefdf">&#9670;&nbsp;</a></span>AddSoftHydroelasticProperties() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::geometry::AddSoftHydroelasticProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *&#160;</td>
          <td class="paramname"><em>properties</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload, intended for shapes that don't get tessellated in their hydroelastic representation (e.g., <a class="el" href="classdrake_1_1geometry_1_1_half_space.html" title="Definition of a half space.">HalfSpace</a>). </p>
<p>See MODULE_NOT_WRITTEN_YET. </p>

</div>
</div>
<a id="ad22f40ec627443c415b558cee11e111e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22f40ec627443c415b558cee11e111e">&#9670;&nbsp;</a></span>AddSoftHydroelasticPropertiesForHalfSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::geometry::AddSoftHydroelasticPropertiesForHalfSpace </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>slab_thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Soft half spaces are handled as a special case; they do not get tessellated. </p>
<p>Instead, they are treated as infinite slabs with a finite thickness. This variant is required for hydroelastic half spaces.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">slab_thickness</td><td>The distance from the half space boundary to its rigid core (this helps define the extent field of the half space). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">properties</td><td>The properties will be added to this property set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>If <code>properties</code> already has properties with the names that this function would need to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt; <code>slab_thickness</code> &lt; ∞ . </dd></dl>

</div>
</div>
<a id="aa70628317c9ed8d19606fee0d13643a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70628317c9ed8d19606fee0d13643a5">&#9670;&nbsp;</a></span>MakePhongIllustrationProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html">IllustrationProperties</a> drake::geometry::MakePhongIllustrationProperties </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>diffuse</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an <a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html" title="The set of properties for geometry used in an &quot;illustration&quot; role.">IllustrationProperties</a> instance compatible with a simple "phong" material using only the given <code>diffuse</code> color. </p>

</div>
</div>
<a id="a15599d92370af7b991c4a593f6103376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15599d92370af7b991c4a593f6103376">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::geometry::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_volume_element.html">VolumeElement</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_volume_element.html">VolumeElement</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a152c7124632aaba612f6b59e0510957e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152c7124632aaba612f6b59e0510957e">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::geometry::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1geometry.html#acdd79a1a4f81dd6ee5cddcb21149b951">Role</a> &amp;&#160;</td>
          <td class="paramname"><em>role</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2134db5f8753db883df9439aa2c38814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2134db5f8753db883df9439aa2c38814">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::geometry::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_volume_element.html">VolumeElement</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_volume_element.html">VolumeElement</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a40ca141e2cff1416ab27b5234409dcf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ca141e2cff1416ab27b5234409dcf5">&#9670;&nbsp;</a></span>ReadObjToSurfaceMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&lt;double&gt; drake::geometry::ReadObjToSurfaceMesh </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(std::string_view)&gt;&#160;</td>
          <td class="paramname"><em>on_warning</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a surface mesh from a Wavefront .obj file and optionally scales coordinates by the given scale factor. </p>
<p>Polygons will be triangulated if they are not triangles already. All objects in the .obj file will be merged into the surface mesh. See <a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file">https://en.wikipedia.org/wiki/Wavefront_.obj_file</a> for the file format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>A valid file name with absolute path or relative path. </td></tr>
    <tr><td class="paramname">scale</td><td>An optional scale to coordinates. </td></tr>
    <tr><td class="paramname">on_warning</td><td>An optional callback that will receive warning message(s) encountered while reading the mesh. When not provided, <a class="el" href="namespacedrake.html#ae32fd151ebc2dab30d9546f1dbef0c79" title="Retrieve an instance of a logger to use for logging; for example:">drake::log()</a> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>filename</code> doesn't have a valid file path, or the file has no faces. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>surface mesh </dd></dl>

</div>
</div>
<a id="a78decc4125a80819440fcc2f16f6f8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78decc4125a80819440fcc2f16f6f8d9">&#9670;&nbsp;</a></span>ReadObjToSurfaceMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&lt;double&gt; drake::geometry::ReadObjToSurfaceMesh </td>
          <td>(</td>
          <td class="paramtype">std::istream *&#160;</td>
          <td class="paramname"><em>input_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(std::string_view)&gt;&#160;</td>
          <td class="paramname"><em>on_warning</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of ReadObjToSurfaceMesh(const std::string&amp;, double) with the Wavefront .obj file given in std::istream. </p>

</div>
</div>
<a id="a660dff0520608baf7e7f09861d6fa8f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660dff0520608baf7e7f09861d6fa8f5">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string drake::geometry::to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1geometry.html#acdd79a1a4f81dd6ee5cddcb21149b951">Role</a> &amp;&#160;</td>
          <td class="paramname"><em>role</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1geometry.html">geometry</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
