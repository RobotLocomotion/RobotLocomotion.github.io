<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake::geometry Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespacedrake_1_1geometry.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">drake::geometry Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:optimization" id="r_optimization"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html">optimization</a></td></tr>
<tr class="memitem:proximity" id="r_proximity"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry_1_1proximity.html">proximity</a></td></tr>
<tr class="memitem:render" id="r_render"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry_1_1render.html">render</a></td></tr>
<tr class="memitem:render_5Fgltf_5Fclient" id="r_render_5Fgltf_5Fclient"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry_1_1render__gltf__client.html">render_gltf_client</a></td></tr>
<tr class="memitem:render_5Fvtk" id="r_render_5Fvtk"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry_1_1render__vtk.html">render_vtk</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:Aabb" id="r_Aabb"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_aabb.html">Aabb</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Axis-aligned bounding box.  <a href="classdrake_1_1geometry_1_1_aabb.html#details">More...</a><br /></td></tr>
<tr class="memitem:AabbMaker" id="r_AabbMaker"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_aabb_maker.html">AabbMaker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AabbMaker implements the logic to fit an <a class="el" href="classdrake_1_1geometry_1_1_aabb.html" title="Axis-aligned bounding box.">Aabb</a> to a collection of points.  <a href="classdrake_1_1geometry_1_1_aabb_maker.html#details">More...</a><br /></td></tr>
<tr class="memitem:Box" id="r_Box"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_box.html">Box</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a box.  <a href="classdrake_1_1geometry_1_1_box.html#details">More...</a><br /></td></tr>
<tr class="memitem:Capsule" id="r_Capsule"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_capsule.html">Capsule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a capsule.  <a href="classdrake_1_1geometry_1_1_capsule.html#details">More...</a><br /></td></tr>
<tr class="memitem:CollisionFilterDeclaration" id="r_CollisionFilterDeclaration"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_collision_filter_declaration.html">CollisionFilterDeclaration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for articulating changes to the configuration of <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>'s "collision filters"; collision filters limit the scope of various proximity queries.  <a href="classdrake_1_1geometry_1_1_collision_filter_declaration.html#details">More...</a><br /></td></tr>
<tr class="memitem:CollisionFilterManager" id="r_CollisionFilterManager"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_collision_filter_manager.html">CollisionFilterManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for configuring "collision filters"; collision filters limit the scope of various proximity queries.  <a href="classdrake_1_1geometry_1_1_collision_filter_manager.html#details">More...</a><br /></td></tr>
<tr class="memitem:ContactSurface" id="r_ContactSurface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ContactSurface characterizes the intersection of two geometries M and N as a contact surface with a scalar field and a vector field, whose purpose is to support the hydroelastic pressure field contact model as described in:  <a href="classdrake_1_1geometry_1_1_contact_surface.html#details">More...</a><br /></td></tr>
<tr class="memitem:Convex" id="r_Convex"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_convex.html">Convex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a <em>convex</em> surface mesh.  <a href="classdrake_1_1geometry_1_1_convex.html#details">More...</a><br /></td></tr>
<tr class="memitem:Cylinder" id="r_Cylinder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_cylinder.html">Cylinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a cylinder.  <a href="classdrake_1_1geometry_1_1_cylinder.html#details">More...</a><br /></td></tr>
<tr class="memitem:DefaultProximityProperties" id="r_DefaultProximityProperties"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1_default_proximity_properties.html">DefaultProximityProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">These properties will be used as defaults when the geometry as added via API calls or parsed from model files doesn't say anything more specific.  <a href="structdrake_1_1geometry_1_1_default_proximity_properties.html#details">More...</a><br /></td></tr>
<tr class="memitem:DrakeVisualizer" id="r_DrakeVisualizer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_drake_visualizer.html">DrakeVisualizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A system that publishes LCM messages representing the current state of a <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> instance (whose QueryObject-valued output port is connected to this system's input port).  <a href="classdrake_1_1geometry_1_1_drake_visualizer.html#details">More...</a><br /></td></tr>
<tr class="memitem:DrakeVisualizerParams" id="r_DrakeVisualizerParams"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1_drake_visualizer_params.html">DrakeVisualizerParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of parameters for configuring <a class="el" href="classdrake_1_1geometry_1_1_drake_visualizer.html" title="A system that publishes LCM messages representing the current state of a SceneGraph instance (whose Q...">DrakeVisualizer</a>.  <a href="structdrake_1_1geometry_1_1_drake_visualizer_params.html#details">More...</a><br /></td></tr>
<tr class="memitem:DrakeVisualizerTest" id="r_DrakeVisualizerTest"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_drake_visualizer_test.html">DrakeVisualizerTest</a></td></tr>
<tr class="memitem:Ellipsoid" id="r_Ellipsoid"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_ellipsoid.html">Ellipsoid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of an ellipsoid.  <a href="classdrake_1_1geometry_1_1_ellipsoid.html#details">More...</a><br /></td></tr>
<tr class="memitem:EnvironmentMap" id="r_EnvironmentMap"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1_environment_map.html">EnvironmentMap</a></td></tr>
<tr class="memitem:EquirectangularMap" id="r_EquirectangularMap"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1_equirectangular_map.html">EquirectangularMap</a></td></tr>
<tr class="memitem:GeometryFrame" id="r_GeometryFrame"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_frame.html">GeometryFrame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This simple class carries the definition of a frame used in the <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>.  <a href="classdrake_1_1geometry_1_1_geometry_frame.html#details">More...</a><br /></td></tr>
<tr class="memitem:GeometryId" id="r_GeometryId"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to identify geometry instances in <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>.  <a href="classdrake_1_1geometry_1_1_geometry_id.html#details">More...</a><br /></td></tr>
<tr class="memitem:GeometryInstance" id="r_GeometryInstance"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">GeometryInstance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A geometry instance combines a geometry definition (i.e., a shape of some sort), a pose (relative to a parent "frame" P), material information, and an opaque collection of metadata.  <a href="classdrake_1_1geometry_1_1_geometry_instance.html#details">More...</a><br /></td></tr>
<tr class="memitem:GeometryProperties" id="r_GeometryProperties"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for defining a set of geometry properties.  <a href="classdrake_1_1geometry_1_1_geometry_properties.html#details">More...</a><br /></td></tr>
<tr class="memitem:GeometrySet" id="r_GeometrySet"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_set.html">GeometrySet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The GeometrySet, as its name implies, is a convenience class for defining a set of geometries.  <a href="classdrake_1_1geometry_1_1_geometry_set.html#details">More...</a><br /></td></tr>
<tr class="memitem:GeometryState" id="r_GeometryState"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_state.html">GeometryState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The context-dependent state of <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>.  <a href="classdrake_1_1geometry_1_1_geometry_state.html#details">More...</a><br /></td></tr>
<tr class="memitem:GeometryVersion" id="r_GeometryVersion"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_version.html">GeometryVersion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version numbering class that reports revisions of <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>'s geometric data.  <a href="classdrake_1_1geometry_1_1_geometry_version.html#details">More...</a><br /></td></tr>
<tr class="memitem:GltfExtension" id="r_GltfExtension"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1_gltf_extension.html">GltfExtension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies how to deal with glTF "extensions" (non-standard capabilities).  <a href="structdrake_1_1geometry_1_1_gltf_extension.html#details">More...</a><br /></td></tr>
<tr class="memitem:HalfSpace" id="r_HalfSpace"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_half_space.html">HalfSpace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a half space.  <a href="classdrake_1_1geometry_1_1_half_space.html#details">More...</a><br /></td></tr>
<tr class="memitem:IllustrationProperties" id="r_IllustrationProperties"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html">IllustrationProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of properties for geometry used in an "illustration" role.  <a href="classdrake_1_1geometry_1_1_illustration_properties.html#details">More...</a><br /></td></tr>
<tr class="memitem:InMemoryMesh" id="r_InMemoryMesh"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1_in_memory_mesh.html">InMemoryMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a mesh file stored in memory.  <a href="structdrake_1_1geometry_1_1_in_memory_mesh.html#details">More...</a><br /></td></tr>
<tr class="memitem:KinematicsVector" id="r_KinematicsVector"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_kinematics_vector.html">KinematicsVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A KinematicsVector is a container class used to report kinematics data for registered frames and geometries (keyed by unique FrameId/GeometryId values) to <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> where the set of keys (FrameId/GeometryId) is usually constant and the values (kinematics data) are varying.  <a href="classdrake_1_1geometry_1_1_kinematics_vector.html#details">More...</a><br /></td></tr>
<tr class="memitem:Mesh" id="r_Mesh"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh.html">Mesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a general (possibly non-convex) mesh.  <a href="classdrake_1_1geometry_1_1_mesh.html#details">More...</a><br /></td></tr>
<tr class="memitem:Meshcat" id="r_Meshcat"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_meshcat.html">Meshcat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an interface to Meshcat (<a href="https://github.com/meshcat-dev/meshcat">https://github.com/meshcat-dev/meshcat</a>).  <a href="classdrake_1_1geometry_1_1_meshcat.html#details">More...</a><br /></td></tr>
<tr class="memitem:MeshcatAnimation" id="r_MeshcatAnimation"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_meshcat_animation.html">MeshcatAnimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface for recording/playback animations in <a class="el" href="classdrake_1_1geometry_1_1_meshcat.html" title="Provides an interface to Meshcat (https://github.com/meshcat-dev/meshcat).">Meshcat</a>.  <a href="classdrake_1_1geometry_1_1_meshcat_animation.html#details">More...</a><br /></td></tr>
<tr class="memitem:MeshcatCone" id="r_MeshcatCone"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_meshcat_cone.html">MeshcatCone</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a cone.  <a href="classdrake_1_1geometry_1_1_meshcat_cone.html#details">More...</a><br /></td></tr>
<tr class="memitem:MeshcatParams" id="r_MeshcatParams"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1_meshcat_params.html">MeshcatParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of parameters for configuring <a class="el" href="classdrake_1_1geometry_1_1_meshcat.html" title="Provides an interface to Meshcat (https://github.com/meshcat-dev/meshcat).">Meshcat</a>.  <a href="structdrake_1_1geometry_1_1_meshcat_params.html#details">More...</a><br /></td></tr>
<tr class="memitem:MeshcatPointCloudVisualizer" id="r_MeshcatPointCloudVisualizer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_meshcat_point_cloud_visualizer.html">MeshcatPointCloudVisualizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdrake_1_1geometry_1_1_meshcat_point_cloud_visualizer.html" title="MeshcatPointCloudVisualizer is a systems::LeafSystem that publishes a perception::PointCloud from its...">MeshcatPointCloudVisualizer</a> is a <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">systems::LeafSystem</a> that publishes a <a class="el" href="classdrake_1_1perception_1_1_point_cloud.html" title="Implements a point cloud (with contiguous storage), whose main goal is to offer a convenient,...">perception::PointCloud</a> from its input port to <a class="el" href="classdrake_1_1geometry_1_1_meshcat.html" title="Provides an interface to Meshcat (https://github.com/meshcat-dev/meshcat).">Meshcat</a>.  <a href="classdrake_1_1geometry_1_1_meshcat_point_cloud_visualizer.html#details">More...</a><br /></td></tr>
<tr class="memitem:MeshcatVisualizer" id="r_MeshcatVisualizer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_meshcat_visualizer.html">MeshcatVisualizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A system wrapper for <a class="el" href="classdrake_1_1geometry_1_1_meshcat.html" title="Provides an interface to Meshcat (https://github.com/meshcat-dev/meshcat).">Meshcat</a> that publishes the current state of a <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> instance (whose QueryObject-valued output port is connected to this system's input port).  <a href="classdrake_1_1geometry_1_1_meshcat_visualizer.html#details">More...</a><br /></td></tr>
<tr class="memitem:MeshcatVisualizerParams" id="r_MeshcatVisualizerParams"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1_meshcat_visualizer_params.html">MeshcatVisualizerParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of parameters for configuring <a class="el" href="classdrake_1_1geometry_1_1_meshcat_visualizer.html" title="A system wrapper for Meshcat that publishes the current state of a SceneGraph instance (whose QueryOb...">MeshcatVisualizer</a>.  <a href="structdrake_1_1geometry_1_1_meshcat_visualizer_params.html#details">More...</a><br /></td></tr>
<tr class="memitem:MeshFieldLinear" id="r_MeshFieldLinear"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MeshFieldLinear represents a continuous piecewise-linear scalar field <span class="tt">f</span> defined on a (triangular or tetrahedral) mesh; the field value changes linearly within each element E (triangle or tetrahedron), and the gradient ∇f is constant within each element.  <a href="classdrake_1_1geometry_1_1_mesh_field_linear.html#details">More...</a><br /></td></tr>
<tr class="memitem:MeshSource" id="r_MeshSource"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_source.html">MeshSource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a general abstraction to the definition of a mesh.  <a href="classdrake_1_1geometry_1_1_mesh_source.html#details">More...</a><br /></td></tr>
<tr class="memitem:NullTexture" id="r_NullTexture"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1_null_texture.html">NullTexture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) A place holder indicating that no texture has been provided for environment map (and, therefore, no environment map).  <a href="structdrake_1_1geometry_1_1_null_texture.html#details">More...</a><br /></td></tr>
<tr class="memitem:Obb" id="r_Obb"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_obb.html">Obb</a></td></tr>
<tr class="memitem:ObbMaker" id="r_ObbMaker"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_obb_maker.html">ObbMaker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ObbMaker performs an algorithm to create an oriented bounding box that fits a specified set of vertices in a mesh.  <a href="classdrake_1_1geometry_1_1_obb_maker.html#details">More...</a><br /></td></tr>
<tr class="memitem:ObbMakerTester" id="r_ObbMakerTester"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_obb_maker_tester.html">ObbMakerTester</a></td></tr>
<tr class="memitem:PenetrationAsPointPair" id="r_PenetrationAsPointPair"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html">PenetrationAsPointPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A characterization of the intersection of two penetrating geometries.  <a href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html#details">More...</a><br /></td></tr>
<tr class="memitem:PerceptionProperties" id="r_PerceptionProperties"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_perception_properties.html">PerceptionProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of properties for geometry used in a "perception" role.  <a href="classdrake_1_1geometry_1_1_perception_properties.html#details">More...</a><br /></td></tr>
<tr class="memitem:Plane" id="r_Plane"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_plane.html">Plane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a plane in ℜ³, posed in an arbitrary frame.  <a href="classdrake_1_1geometry_1_1_plane.html#details">More...</a><br /></td></tr>
<tr class="memitem:PolygonSurfaceMesh" id="r_PolygonSurfaceMesh"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PolygonSurfaceMesh represents a surface comprised of <em>polygonal</em> elements (three or more sides).  <a href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html#details">More...</a><br /></td></tr>
<tr class="memitem:PolygonSurfaceMeshTest" id="r_PolygonSurfaceMeshTest"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh_test.html">PolygonSurfaceMeshTest</a></td></tr>
<tr class="memitem:promoted_5Fnumerical" id="r_promoted_5Fnumerical"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1promoted__numerical.html">promoted_numerical</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the two scalar types U and T, returns the most "promoted" type.  <a href="structdrake_1_1geometry_1_1promoted__numerical.html#details">More...</a><br /></td></tr>
<tr class="memitem:ProximityProperties" id="r_ProximityProperties"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of properties for geometry used in a <em>proximity</em> role.  <a href="classdrake_1_1geometry_1_1_proximity_properties.html#details">More...</a><br /></td></tr>
<tr class="memitem:QueryObject" id="r_QueryObject"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The QueryObject serves as a mechanism to perform geometry queries on the world's geometry.  <a href="classdrake_1_1geometry_1_1_query_object.html#details">More...</a><br /></td></tr>
<tr class="memitem:RenderEngineGlParams" id="r_RenderEngineGlParams"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1_render_engine_gl_params.html">RenderEngineGlParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction parameters for RenderEngineGl.  <a href="structdrake_1_1geometry_1_1_render_engine_gl_params.html#details">More...</a><br /></td></tr>
<tr class="memitem:RenderEngineGltfClientParams" id="r_RenderEngineGltfClientParams"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1_render_engine_gltf_client_params.html">RenderEngineGltfClientParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction parameters for the <a class="el" href="#a004a8b7a49c0b7a4bc2f8860af26591b" title="Constructs a RenderEngine implementation which generates glTF  files to upload to a render server,...">MakeRenderEngineGltfClient()</a> to create a client as part of the <a class="el" href="group__render__engine__gltf__client__server__api.html">glTF Render Client-Server API</a>.  <a href="structdrake_1_1geometry_1_1_render_engine_gltf_client_params.html#details">More...</a><br /></td></tr>
<tr class="memitem:RenderEngineVtkParams" id="r_RenderEngineVtkParams"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1_render_engine_vtk_params.html">RenderEngineVtkParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction parameters for the RenderEngineVtk.  <a href="structdrake_1_1geometry_1_1_render_engine_vtk_params.html#details">More...</a><br /></td></tr>
<tr class="memitem:Rgba" id="r_Rgba"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_rgba.html">Rgba</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines RGBA (red, green, blue, alpha) values on the range [0, 1].  <a href="classdrake_1_1geometry_1_1_rgba.html#details">More...</a><br /></td></tr>
<tr class="memitem:SceneGraph" id="r_SceneGraph"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">SceneGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> serves as the nexus for all geometry (and geometry-based operations) in a Diagram.  <a href="classdrake_1_1geometry_1_1_scene_graph.html#details">More...</a><br /></td></tr>
<tr class="memitem:SceneGraphConfig" id="r_SceneGraphConfig"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1_scene_graph_config.html">SceneGraphConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of configurable properties on a <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>.  <a href="structdrake_1_1geometry_1_1_scene_graph_config.html#details">More...</a><br /></td></tr>
<tr class="memitem:SceneGraphInspector" id="r_SceneGraphInspector"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html">SceneGraphInspector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SceneGraphInspector serves as a mechanism to query the topological structure of a <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> instance.  <a href="classdrake_1_1geometry_1_1_scene_graph_inspector.html#details">More...</a><br /></td></tr>
<tr class="memitem:Shape" id="r_Shape"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_shape.html">Shape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base class for all shape specifications.  <a href="classdrake_1_1geometry_1_1_shape.html#details">More...</a><br /></td></tr>
<tr class="memitem:ShapeReifier" id="r_ShapeReifier"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_shape_reifier.html">ShapeReifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The interface for converting shape descriptions to real shapes.  <a href="classdrake_1_1geometry_1_1_shape_reifier.html#details">More...</a><br /></td></tr>
<tr class="memitem:SignedDistancePair" id="r_SignedDistancePair"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1_signed_distance_pair.html">SignedDistancePair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data for reporting the signed distance between two geometries, A and B.  <a href="structdrake_1_1geometry_1_1_signed_distance_pair.html#details">More...</a><br /></td></tr>
<tr class="memitem:SignedDistanceToPoint" id="r_SignedDistanceToPoint"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1_signed_distance_to_point.html">SignedDistanceToPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data for reporting the signed distance from a query point to a geometry.  <a href="structdrake_1_1geometry_1_1_signed_distance_to_point.html#details">More...</a><br /></td></tr>
<tr class="memitem:Sphere" id="r_Sphere"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_sphere.html">Sphere</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of sphere.  <a href="classdrake_1_1geometry_1_1_sphere.html#details">More...</a><br /></td></tr>
<tr class="memitem:SsaoParameter" id="r_SsaoParameter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1_ssao_parameter.html">SsaoParameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Screen-space ambient occlusion (SSAO) parameters.  <a href="structdrake_1_1geometry_1_1_ssao_parameter.html#details">More...</a><br /></td></tr>
<tr class="memitem:SurfacePolygon" id="r_SurfacePolygon"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_polygon.html">SurfacePolygon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a polygonal face in a <a class="el" href="classdrake_1_1geometry_1_1_surface_polygon.html" title="Representation of a polygonal face in a SurfacePolygon.">SurfacePolygon</a>.  <a href="classdrake_1_1geometry_1_1_surface_polygon.html#details">More...</a><br /></td></tr>
<tr class="memitem:SurfaceTriangle" id="r_SurfaceTriangle"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_surface_triangle.html">SurfaceTriangle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SurfaceTriangle represents a triangular face in a <a class="el" href="classdrake_1_1geometry_1_1_triangle_surface_mesh.html" title="TriangleSurfaceMesh represents a union of triangles.">TriangleSurfaceMesh</a>.  <a href="classdrake_1_1geometry_1_1_surface_triangle.html#details">More...</a><br /></td></tr>
<tr class="memitem:TriangleSurfaceMesh" id="r_TriangleSurfaceMesh"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_triangle_surface_mesh.html">TriangleSurfaceMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TriangleSurfaceMesh represents a union of triangles.  <a href="classdrake_1_1geometry_1_1_triangle_surface_mesh.html#details">More...</a><br /></td></tr>
<tr class="memitem:TriangleSurfaceMeshTester" id="r_TriangleSurfaceMeshTester"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_triangle_surface_mesh_tester.html">TriangleSurfaceMeshTester</a></td></tr>
<tr class="memitem:VolumeElement" id="r_VolumeElement"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_volume_element.html">VolumeElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">VolumeElement represents a tetrahedral element in a <a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html" title="VolumeMesh represents a tetrahedral volume mesh.">VolumeMesh</a>.  <a href="classdrake_1_1geometry_1_1_volume_element.html#details">More...</a><br /></td></tr>
<tr class="memitem:VolumeMesh" id="r_VolumeMesh"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html">VolumeMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">VolumeMesh represents a tetrahedral volume mesh.  <a href="classdrake_1_1geometry_1_1_volume_mesh.html#details">More...</a><br /></td></tr>
<tr class="memitem:VolumeMeshTester" id="r_VolumeMeshTester"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_volume_mesh_tester.html">VolumeMeshTester</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acbab8995daa433cebfc335ffe8ae8fd0" id="r_acbab8995daa433cebfc335ffe8ae8fd0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbab8995daa433cebfc335ffe8ae8fd0">DrakeVisualizerd</a> = <a class="el" href="classdrake_1_1geometry_1_1_drake_visualizer.html">DrakeVisualizer</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;</td></tr>
<tr class="memdesc:acbab8995daa433cebfc335ffe8ae8fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient alias for the <a class="el" href="classdrake_1_1geometry_1_1_drake_visualizer.html" title="A system that publishes LCM messages representing the current state of a SceneGraph instance (whose Q...">DrakeVisualizer</a> class when using the <span class="tt"><a class="el" href="classdouble.html">double</a></span> scalar type.  <br /></td></tr>
<tr class="memitem:a92efe958866f76d7391035159c554a56" id="r_a92efe958866f76d7391035159c554a56"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92efe958866f76d7391035159c554a56">FilterId</a> = <a class="el" href="classdrake_1_1_identifier.html">drake::Identifier</a>&lt;class FilterTag&gt;</td></tr>
<tr class="memdesc:a92efe958866f76d7391035159c554a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to identify transient collision filter declarations in <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>.  <br /></td></tr>
<tr class="memitem:ac53cb597123131fb23a7af26e8d350bf" id="r_ac53cb597123131fb23a7af26e8d350bf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac53cb597123131fb23a7af26e8d350bf">SourceId</a> = <a class="el" href="classdrake_1_1_identifier.html">drake::Identifier</a>&lt;class SourceTag&gt;</td></tr>
<tr class="memdesc:ac53cb597123131fb23a7af26e8d350bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to identify geometry sources in <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>.  <br /></td></tr>
<tr class="memitem:a43b41363b37fadf8cce0977d500e13cb" id="r_a43b41363b37fadf8cce0977d500e13cb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> = <a class="el" href="classdrake_1_1_identifier.html">drake::Identifier</a>&lt;class FrameTag&gt;</td></tr>
<tr class="memdesc:a43b41363b37fadf8cce0977d500e13cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to identify geometry frames in <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>.  <br /></td></tr>
<tr class="memitem:a0f8e11a5858131e3e05d6d07fd4cceeb" id="r_a0f8e11a5858131e3e05d6d07fd4cceeb"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a0f8e11a5858131e3e05d6d07fd4cceeb template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f8e11a5858131e3e05d6d07fd4cceeb">FramePoseVector</a> = <a class="el" href="classdrake_1_1geometry_1_1_kinematics_vector.html">KinematicsVector</a>&lt;<a class="el" href="#a43b41363b37fadf8cce0977d500e13cb">FrameId</a>, <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt;T&gt;&gt;</td></tr>
<tr class="memdesc:a0f8e11a5858131e3e05d6d07fd4cceeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for communicating <em>pose</em> information to <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> for registered frames.  <br /></td></tr>
<tr class="memitem:ab9c4c9d66418bb333c14d48e05aac617" id="r_ab9c4c9d66418bb333c14d48e05aac617"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ab9c4c9d66418bb333c14d48e05aac617 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9c4c9d66418bb333c14d48e05aac617">GeometryConfigurationVector</a> = <a class="el" href="classdrake_1_1geometry_1_1_kinematics_vector.html">KinematicsVector</a>&lt;<a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a>, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt;&gt;</td></tr>
<tr class="memdesc:ab9c4c9d66418bb333c14d48e05aac617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for communicating <em>configuration</em> information to <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> for registered deformable geometries.  <br /></td></tr>
<tr class="memitem:a13b4d36d0491327603af75e4f6d0c52a" id="r_a13b4d36d0491327603af75e4f6d0c52a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13b4d36d0491327603af75e4f6d0c52a">MeshcatPointCloudVisualizerd</a> = <a class="el" href="classdrake_1_1geometry_1_1_meshcat_point_cloud_visualizer.html">MeshcatPointCloudVisualizer</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;</td></tr>
<tr class="memdesc:a13b4d36d0491327603af75e4f6d0c52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient alias for the <a class="el" href="classdrake_1_1geometry_1_1_meshcat_point_cloud_visualizer.html" title="MeshcatPointCloudVisualizer is a systems::LeafSystem that publishes a perception::PointCloud from its...">MeshcatPointCloudVisualizer</a> class when using the <span class="tt"><a class="el" href="classdouble.html">double</a></span> scalar type.  <br /></td></tr>
<tr class="memitem:acfc5928f9ddabb01ca8a0f2cdabbffa3" id="r_acfc5928f9ddabb01ca8a0f2cdabbffa3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfc5928f9ddabb01ca8a0f2cdabbffa3">MeshcatVisualizerd</a> = <a class="el" href="classdrake_1_1geometry_1_1_meshcat_visualizer.html">MeshcatVisualizer</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;</td></tr>
<tr class="memdesc:acfc5928f9ddabb01ca8a0f2cdabbffa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient alias for the <a class="el" href="classdrake_1_1geometry_1_1_meshcat_visualizer.html" title="A system wrapper for Meshcat that publishes the current state of a SceneGraph instance (whose QueryOb...">MeshcatVisualizer</a> class when using the <span class="tt"><a class="el" href="classdouble.html">double</a></span> scalar type.  <br /></td></tr>
<tr class="memitem:a74b8d905842571b365085fdd17378772" id="r_a74b8d905842571b365085fdd17378772"><td class="memTemplParams" colspan="2">template&lt;typename T, typename U&gt; </td></tr>
<tr class="memitem:a74b8d905842571b365085fdd17378772 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74b8d905842571b365085fdd17378772">promoted_numerical_t</a> = typename <a class="el" href="structdrake_1_1geometry_1_1promoted__numerical.html">promoted_numerical</a>&lt;T, U&gt;::type</td></tr>
<tr class="memitem:a70187c16ea14553f92a3bec4402ae490" id="r_a70187c16ea14553f92a3bec4402ae490"><td class="memTemplParams" colspan="2">template&lt;typename FieldValue, typename T&gt; </td></tr>
<tr class="memitem:a70187c16ea14553f92a3bec4402ae490 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70187c16ea14553f92a3bec4402ae490">PolygonSurfaceMeshFieldLinear</a></td></tr>
<tr class="memdesc:a70187c16ea14553f92a3bec4402ae490"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for instantiating a <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a> on a <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html" title="PolygonSurfaceMesh represents a surface comprised of polygonal elements (three or more sides).">PolygonSurfaceMesh</a>.  <br /></td></tr>
<tr class="memitem:afb1cea0cef695099b2d920680d24050f" id="r_afb1cea0cef695099b2d920680d24050f"><td class="memTemplParams" colspan="2">template&lt;typename FieldValue, typename T&gt; </td></tr>
<tr class="memitem:afb1cea0cef695099b2d920680d24050f template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb1cea0cef695099b2d920680d24050f">TriangleSurfaceMeshFieldLinear</a></td></tr>
<tr class="memdesc:afb1cea0cef695099b2d920680d24050f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for instantiating a <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a> on a <a class="el" href="classdrake_1_1geometry_1_1_triangle_surface_mesh.html" title="TriangleSurfaceMesh represents a union of triangles.">TriangleSurfaceMesh</a>.  <br /></td></tr>
<tr class="memitem:aee6c99359ac348f38b4d470329ec1851" id="r_aee6c99359ac348f38b4d470329ec1851"><td class="memTemplParams" colspan="2">template&lt;typename FieldValue, typename T&gt; </td></tr>
<tr class="memitem:aee6c99359ac348f38b4d470329ec1851 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee6c99359ac348f38b4d470329ec1851">VolumeMeshFieldLinear</a> = <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a>&lt;FieldValue, <a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html">VolumeMesh</a>&lt;T&gt;&gt;</td></tr>
<tr class="memdesc:aee6c99359ac348f38b4d470329ec1851"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience alias for instantiating a <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a> on a <a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html" title="VolumeMesh represents a tetrahedral volume mesh.">VolumeMesh</a>.  <br /></td></tr>
<tr id="typedef-members-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Structures for maintaining the entity relationships</div></td></tr>
<tr class="memitem:a3a71d18e80aa6fba962ddd8a33aecb05" id="r_a3a71d18e80aa6fba962ddd8a33aecb05"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a71d18e80aa6fba962ddd8a33aecb05">FrameIdSet</a> = std::unordered_set&lt;<a class="el" href="#a43b41363b37fadf8cce0977d500e13cb">FrameId</a>&gt;</td></tr>
<tr class="memdesc:a3a71d18e80aa6fba962ddd8a33aecb05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of unique frame ids.  <br /></td></tr>
<tr class="memitem:ae17f078345eeccd086fdb02c198d5b7d" id="r_ae17f078345eeccd086fdb02c198d5b7d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae17f078345eeccd086fdb02c198d5b7d">GeometryIdSet</a> = std::unordered_set&lt;<a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a>&gt;</td></tr>
<tr class="memdesc:ae17f078345eeccd086fdb02c198d5b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of unique geometry ids.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad580d9f8e007396af59694d605245253" id="r_ad580d9f8e007396af59694d605245253"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad580d9f8e007396af59694d605245253">CollisionFilterScope</a> { <a class="el" href="#ad580d9f8e007396af59694d605245253a34bdbffdb1c0e1b603f58fc0d49548b6">kAll</a>
, <a class="el" href="#ad580d9f8e007396af59694d605245253add0cbaa458a6d1a39dfc809377ad2be8">kOmitDeformable</a>
 }</td></tr>
<tr class="memdesc:ad580d9f8e007396af59694d605245253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum that defines the scope of the geometries that are affected by the collision filtering mechanism.  <a href="#ad580d9f8e007396af59694d605245253">More...</a><br /></td></tr>
<tr class="memitem:acdd79a1a4f81dd6ee5cddcb21149b951" id="r_acdd79a1a4f81dd6ee5cddcb21149b951"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdd79a1a4f81dd6ee5cddcb21149b951">Role</a> { <a class="el" href="#acdd79a1a4f81dd6ee5cddcb21149b951a41ba12ed492ce20c3ff503a553ae85ea">kUnassigned</a> = 0x0
, <a class="el" href="#acdd79a1a4f81dd6ee5cddcb21149b951ad909c44a5dea6ebbdb3a95e4cb701521">kProximity</a> = 0x1
, <a class="el" href="#acdd79a1a4f81dd6ee5cddcb21149b951aac28e5ab68fbe5dc23f550aa18255c07">kIllustration</a> = 0x2
, <a class="el" href="#acdd79a1a4f81dd6ee5cddcb21149b951ac1f9a0ba01987bd1d23d1c4ea605df2b">kPerception</a> = 0x4
 }</td></tr>
<tr class="memdesc:acdd79a1a4f81dd6ee5cddcb21149b951"><td class="mdescLeft">&#160;</td><td class="mdescRight">General enumeration for indicating geometry role.  <a href="#acdd79a1a4f81dd6ee5cddcb21149b951">More...</a><br /></td></tr>
<tr class="memitem:a52f8cb466b0827379bc8815f0d58aac3" id="r_a52f8cb466b0827379bc8815f0d58aac3"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52f8cb466b0827379bc8815f0d58aac3">RoleAssign</a> { <a class="el" href="#a52f8cb466b0827379bc8815f0d58aac3aaf1adf7ec3673b4f5765cfbc5d43b7dc">kNew</a>
, <a class="el" href="#a52f8cb466b0827379bc8815f0d58aac3a8ba1782ca7c04c255b3d69d6d2411d90">kReplace</a>
 }</td></tr>
<tr class="memdesc:a52f8cb466b0827379bc8815f0d58aac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operations that can be performed on the given properties when assigning roles to geometry.  <a href="#a52f8cb466b0827379bc8815f0d58aac3">More...</a><br /></td></tr>
<tr class="memitem:aa480f7d5d485f556225ed73538dd4eca" id="r_aa480f7d5d485f556225ed73538dd4eca"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa480f7d5d485f556225ed73538dd4eca">MeshGradientMode</a> { <a class="el" href="#aa480f7d5d485f556225ed73538dd4ecaa35c3ace1970663a16e5c65baa5941b13">kNone</a>
, <a class="el" href="#aa480f7d5d485f556225ed73538dd4ecaa5543e81cb3b8f1409b593cc1ebce1752">kOkOrMarkDegenerate</a>
, <a class="el" href="#aa480f7d5d485f556225ed73538dd4ecaa26940490086ffcdf0616b678df54e7f8">kOkOrThrow</a>
 }</td></tr>
<tr class="memdesc:aa480f7d5d485f556225ed73538dd4eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify whether to generate gradients, and how to handle numerical failures.  <a href="#aa480f7d5d485f556225ed73538dd4eca">More...</a><br /></td></tr>
<tr class="memitem:a227f80cb57c9c87f6ecc4e839e364979" id="r_a227f80cb57c9c87f6ecc4e839e364979"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a227f80cb57c9c87f6ecc4e839e364979">HydroelasticContactRepresentation</a> { <a class="el" href="#a227f80cb57c9c87f6ecc4e839e364979a3a53496ffe96227ef579995d332425c1">kTriangle</a>
, <a class="el" href="#a227f80cb57c9c87f6ecc4e839e364979a64edd70c85c6854f380a0cbbc3db3cbb">kPolygon</a>
 }</td></tr>
<tr class="memdesc:a227f80cb57c9c87f6ecc4e839e364979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports on how a hydroelastic contact surface is represented.  <a href="#a227f80cb57c9c87f6ecc4e839e364979">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa078bc1cc37439da0b38aec2b6e2ee1d" id="r_aa078bc1cc37439da0b38aec2b6e2ee1d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa078bc1cc37439da0b38aec2b6e2ee1d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a> &amp;props)</td></tr>
<tr class="memdesc:aa078bc1cc37439da0b38aec2b6e2ee1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr class="memitem:a1b02fd98506fd3eaa665e6aea5964675" id="r_a1b02fd98506fd3eaa665e6aea5964675"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classdrake_1_1geometry_1_1_obb.html">Obb</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b02fd98506fd3eaa665e6aea5964675">CalcObb</a> (const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">Shape</a> &amp;shape)</td></tr>
<tr class="memdesc:a1b02fd98506fd3eaa665e6aea5964675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the oriented bounding box (OBB) for the <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The abstract base class for all shape specifications.">Shape</a> in its canonical frame.  <br /></td></tr>
<tr class="memitem:aca214fb7e658fbafe777562b609ba572" id="r_aca214fb7e658fbafe777562b609ba572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_triangle_surface_mesh.html">TriangleSurfaceMesh</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca214fb7e658fbafe777562b609ba572">ReadObjToTriangleSurfaceMesh</a> (const std::filesystem::path &amp;filename, const Eigen::Vector3d &amp;scale3, std::function&lt; void(std::string_view)&gt; on_warning={})</td></tr>
<tr class="memdesc:aca214fb7e658fbafe777562b609ba572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a surface mesh from a Wavefront .obj file and optionally scales coordinates by the given scale factor.  <br /></td></tr>
<tr class="memitem:a6247d94deb29805e3995bfd786ecd03a" id="r_a6247d94deb29805e3995bfd786ecd03a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_triangle_surface_mesh.html">TriangleSurfaceMesh</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6247d94deb29805e3995bfd786ecd03a">ReadObjToTriangleSurfaceMesh</a> (const std::filesystem::path &amp;filename, <a class="el" href="classdouble.html">double</a> scale=1.0, std::function&lt; void(std::string_view)&gt; on_warning={})</td></tr>
<tr class="memdesc:a6247d94deb29805e3995bfd786ecd03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant that allows defining uniform scaling from a single scalar value.  <br /></td></tr>
<tr class="memitem:a81c676132d054d87c5c47ff786a7d42c" id="r_a81c676132d054d87c5c47ff786a7d42c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_triangle_surface_mesh.html">TriangleSurfaceMesh</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81c676132d054d87c5c47ff786a7d42c">ReadObjToTriangleSurfaceMesh</a> (const <a class="el" href="classdrake_1_1geometry_1_1_mesh_source.html">MeshSource</a> &amp;mesh_source, const Eigen::Vector3d &amp;scale3, std::function&lt; void(std::string_view)&gt; on_warning={})</td></tr>
<tr class="memdesc:a81c676132d054d87c5c47ff786a7d42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of ReadObjToTriangleSurfaceMesh(const std::filesystem::path&amp;,
double) with the Wavefront .obj in a <a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Definition of a general (possibly non-convex) mesh.">Mesh</a> shape specification.  <br /></td></tr>
<tr class="memitem:ab353abd55dd1c9955e09e40c1a491475" id="r_ab353abd55dd1c9955e09e40c1a491475"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_triangle_surface_mesh.html">TriangleSurfaceMesh</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab353abd55dd1c9955e09e40c1a491475">ReadObjToTriangleSurfaceMesh</a> (const <a class="el" href="classdrake_1_1geometry_1_1_mesh_source.html">MeshSource</a> &amp;mesh_source, <a class="el" href="classdouble.html">double</a> scale=1.0, std::function&lt; void(std::string_view)&gt; on_warning={})</td></tr>
<tr class="memdesc:ab353abd55dd1c9955e09e40c1a491475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant that allows defining uniform scaling from a single scalar value.  <br /></td></tr>
<tr class="memitem:a5e63dda63c412c981364dec694ed3d16" id="r_a5e63dda63c412c981364dec694ed3d16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e63dda63c412c981364dec694ed3d16">operator==</a> (const <a class="el" href="classdrake_1_1geometry_1_1_volume_element.html">VolumeElement</a> &amp;e1, const <a class="el" href="classdrake_1_1geometry_1_1_volume_element.html">VolumeElement</a> &amp;e2)</td></tr>
<tr class="memitem:a7fa229f9c0cc6e132f7f4d2a149bb864" id="r_a7fa229f9c0cc6e132f7f4d2a149bb864"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fa229f9c0cc6e132f7f4d2a149bb864">operator!=</a> (const <a class="el" href="classdrake_1_1geometry_1_1_volume_element.html">VolumeElement</a> &amp;e1, const <a class="el" href="classdrake_1_1geometry_1_1_volume_element.html">VolumeElement</a> &amp;e2)</td></tr>
<tr class="memitem:af9d172ba9808493bb6d98dc9da32e875" id="r_af9d172ba9808493bb6d98dc9da32e875"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html">VolumeMesh</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9d172ba9808493bb6d98dc9da32e875">RefineVolumeMesh</a> (const <a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html">VolumeMesh</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;mesh)</td></tr>
<tr class="memdesc:af9d172ba9808493bb6d98dc9da32e875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines a tetrahedral mesh to eliminate problematic simplices.  <br /></td></tr>
<tr class="memitem:acd7c2cc9566b924539ebcd75590f48c1" id="r_acd7c2cc9566b924539ebcd75590f48c1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd7c2cc9566b924539ebcd75590f48c1">RefineVolumeMeshIntoVtkFileContents</a> (const <a class="el" href="classdrake_1_1geometry_1_1_mesh_source.html">MeshSource</a> &amp;mesh_source)</td></tr>
<tr class="memdesc:acd7c2cc9566b924539ebcd75590f48c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines a tetrahedral mesh to eliminate problematic simplices.  <br /></td></tr>
<tr class="memitem:a75a53812378833c4ceabcde98a841e89" id="r_a75a53812378833c4ceabcde98a841e89"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a75a53812378833c4ceabcde98a841e89 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_triangle_surface_mesh.html">TriangleSurfaceMesh</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75a53812378833c4ceabcde98a841e89">ConvertVolumeToSurfaceMesh</a> (const <a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html">VolumeMesh</a>&lt; T &gt; &amp;volume)</td></tr>
<tr class="memdesc:a75a53812378833c4ceabcde98a841e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a tetrahedral volume mesh to a triangulated surface mesh of the boundary surface of the volume.  <br /></td></tr>
<tr class="memitem:a172a6c0e9c7f29a07c1e5437f17c6d9d" id="r_a172a6c0e9c7f29a07c1e5437f17c6d9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a172a6c0e9c7f29a07c1e5437f17c6d9d">AddContactMaterial</a> (std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt; dissipation, std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt; point_stiffness, const std::optional&lt; <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">multibody::CoulombFriction</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;friction, <a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *properties)</td></tr>
<tr class="memdesc:a172a6c0e9c7f29a07c1e5437f17c6d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#a172a6c0e9c7f29a07c1e5437f17c6d9d" title="AddContactMaterial() adds general contact material properties to the given set of proximity propertie...">AddContactMaterial()</a> adds general contact material properties to the given set of proximity <span class="tt">properties</span>.  <br /></td></tr>
<tr class="memitem:a6c74afc9942060de51e7c6a65f0ade08" id="r_a6c74afc9942060de51e7c6a65f0ade08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c74afc9942060de51e7c6a65f0ade08">AddRigidHydroelasticProperties</a> (<a class="el" href="classdouble.html">double</a> resolution_hint, <a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *properties)</td></tr>
<tr class="memdesc:a6c74afc9942060de51e7c6a65f0ade08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds properties to the given set of proximity properties sufficient to cause the associated geometry to generate a rigid hydroelastic representation.  <br /></td></tr>
<tr class="memitem:a9f348bc35f08089e23f075a72a72c683" id="r_a9f348bc35f08089e23f075a72a72c683"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f348bc35f08089e23f075a72a72c683">AddRigidHydroelasticProperties</a> (<a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *properties)</td></tr>
<tr class="memdesc:a9f348bc35f08089e23f075a72a72c683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload, intended for shapes that don't get tessellated in their hydroelastic representation (e.g., <a class="el" href="classdrake_1_1geometry_1_1_half_space.html" title="Definition of a half space.">HalfSpace</a> and <a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Definition of a general (possibly non-convex) mesh.">Mesh</a>).  <br /></td></tr>
<tr class="memitem:a7cccbced57eb9c31f3e5e9ad26099257" id="r_a7cccbced57eb9c31f3e5e9ad26099257"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cccbced57eb9c31f3e5e9ad26099257">AddCompliantHydroelasticProperties</a> (<a class="el" href="classdouble.html">double</a> resolution_hint, <a class="el" href="classdouble.html">double</a> hydroelastic_modulus, <a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *properties)</td></tr>
<tr class="memdesc:a7cccbced57eb9c31f3e5e9ad26099257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds properties to the given set of proximity properties sufficient to cause the associated geometry to generate a compliant hydroelastic representation.  <br /></td></tr>
<tr class="memitem:ac8718ed182e7a34c228c3f00d1ad1a23" id="r_ac8718ed182e7a34c228c3f00d1ad1a23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8718ed182e7a34c228c3f00d1ad1a23">AddCompliantHydroelasticPropertiesForHalfSpace</a> (<a class="el" href="classdouble.html">double</a> slab_thickness, <a class="el" href="classdouble.html">double</a> hydroelastic_modulus, <a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *properties)</td></tr>
<tr class="memdesc:ac8718ed182e7a34c228c3f00d1ad1a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compliant half spaces are handled as a special case; they do not get tessellated.  <br /></td></tr>
<tr class="memitem:ab2ba2dbf3b19bdec9eabe6ae62099169" id="r_ab2ba2dbf3b19bdec9eabe6ae62099169"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1geometry_1_1_in_memory_mesh.html">InMemoryMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2ba2dbf3b19bdec9eabe6ae62099169">ReadGltfToMemory</a> (const std::filesystem::path &amp;gltf_path)</td></tr>
<tr class="memdesc:ab2ba2dbf3b19bdec9eabe6ae62099169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a file path to a .gltf file, loads the .gltf file contents into memory.  <br /></td></tr>
<tr class="memitem:abb99e00d0f295497d9b250d9bf03a0a2" id="r_abb99e00d0f295497d9b250d9bf03a0a2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1render_1_1_render_engine.html">render::RenderEngine</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb99e00d0f295497d9b250d9bf03a0a2">MakeRenderEngineGl</a> (<a class="el" href="structdrake_1_1geometry_1_1_render_engine_gl_params.html">RenderEngineGlParams</a> params={})</td></tr>
<tr class="memdesc:abb99e00d0f295497d9b250d9bf03a0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RenderEngine implementation which uses a purely OpenGL renderer.  <br /></td></tr>
<tr class="memitem:a004a8b7a49c0b7a4bc2f8860af26591b" id="r_a004a8b7a49c0b7a4bc2f8860af26591b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1render_1_1_render_engine.html">render::RenderEngine</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a004a8b7a49c0b7a4bc2f8860af26591b">MakeRenderEngineGltfClient</a> (const <a class="el" href="structdrake_1_1geometry_1_1_render_engine_gltf_client_params.html">RenderEngineGltfClientParams</a> &amp;params)</td></tr>
<tr class="memdesc:a004a8b7a49c0b7a4bc2f8860af26591b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RenderEngine implementation which generates <a href="https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html">glTF </a> files to upload to a render server, and retrieves renderings from said server by copying image data back into drake <a class="el" href="classdrake_1_1systems_1_1sensors_1_1_image.html" title="Simple data format for Image.">systems::sensors::Image</a> buffers.  <br /></td></tr>
<tr class="memitem:a8d8e28336b380bccf83c9e5611689e2b" id="r_a8d8e28336b380bccf83c9e5611689e2b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1render_1_1_render_engine.html">render::RenderEngine</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d8e28336b380bccf83c9e5611689e2b">MakeRenderEngineVtk</a> (const <a class="el" href="structdrake_1_1geometry_1_1_render_engine_vtk_params.html">RenderEngineVtkParams</a> &amp;params)</td></tr>
<tr class="memdesc:a8d8e28336b380bccf83c9e5611689e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RenderEngine implementation which uses a VTK-based OpenGL renderer.  <br /></td></tr>
<tr class="memitem:a91365f3b8232ef18656f48264f6a3596" id="r_a91365f3b8232ef18656f48264f6a3596"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91365f3b8232ef18656f48264f6a3596">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classdrake_1_1geometry_1_1_rgba.html">Rgba</a> &amp;rgba)</td></tr>
<tr class="memdesc:a91365f3b8232ef18656f48264f6a3596"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr class="memitem:ac677ae9aff90aba0a891854f4287a643" id="r_ac677ae9aff90aba0a891854f4287a643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac677ae9aff90aba0a891854f4287a643">CalcVolume</a> (const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">Shape</a> &amp;shape)</td></tr>
<tr class="memdesc:ac677ae9aff90aba0a891854f4287a643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the volume (in meters^3) for the <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The abstract base class for all shape specifications.">Shape</a>.  <br /></td></tr>
<tr id="func-members-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Geometry role to string conversions</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>These are simply convenience functions for converting the <a class="el" href="#acdd79a1a4f81dd6ee5cddcb21149b951" title="General enumeration for indicating geometry role.">Role</a> enumeration into a human-readable string. </p>
</div></td></tr>
<tr class="memitem:a97f9f12fdd336553a58b605abd5a9563" id="r_a97f9f12fdd336553a58b605abd5a9563"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97f9f12fdd336553a58b605abd5a9563">to_string</a> (const <a class="el" href="#acdd79a1a4f81dd6ee5cddcb21149b951">Role</a> &amp;role)</td></tr>
<tr class="memitem:a968488524d6041456c69fae448e35270" id="r_a968488524d6041456c69fae448e35270"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a968488524d6041456c69fae448e35270">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="#acdd79a1a4f81dd6ee5cddcb21149b951">Role</a> &amp;role)</td></tr>
<tr class="memdesc:a968488524d6041456c69fae448e35270"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr id="func-members-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Convenience functions</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>A collection of functions to help facilitate working with properties. </p>
</div></td></tr>
<tr class="memitem:ac6e7ff65cee87fead2192eae91ca0b28" id="r_ac6e7ff65cee87fead2192eae91ca0b28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html">IllustrationProperties</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6e7ff65cee87fead2192eae91ca0b28">MakePhongIllustrationProperties</a> (const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;diffuse)</td></tr>
<tr class="memdesc:ac6e7ff65cee87fead2192eae91ca0b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html" title="The set of properties for geometry used in an &quot;illustration&quot; role.">IllustrationProperties</a> instance compatible with a simple "phong" material using only the given <span class="tt">diffuse</span> color.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6a949953d76af52d6dd1b13417cb556a" id="r_a6a949953d76af52d6dd1b13417cb556a"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a949953d76af52d6dd1b13417cb556a">kHasRenderEngineGl</a></td></tr>
<tr class="memdesc:a6a949953d76af52d6dd1b13417cb556a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the availability of the RenderEngineGl implementation.  <br /></td></tr>
<tr class="memitem:a7cd7e8fb90454c8f7fa6e5dad3afbb59" id="r_a7cd7e8fb90454c8f7fa6e5dad3afbb59"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cd7e8fb90454c8f7fa6e5dad3afbb59">kHasRenderEngineGltfClient</a></td></tr>
<tr class="memdesc:a7cd7e8fb90454c8f7fa6e5dad3afbb59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the availability of the RenderEngineGltfClient implementation.  <br /></td></tr>
<tr class="memitem:a8a8c891d80ef7ca189d701d976d65d1f" id="r_a8a8c891d80ef7ca189d701d976d65d1f"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a8c891d80ef7ca189d701d976d65d1f">kHasRenderEngineVtk</a></td></tr>
<tr class="memdesc:a8a8c891d80ef7ca189d701d976d65d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the availability of the RenderEngineVtk implementation.  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="acbab8995daa433cebfc335ffe8ae8fd0" name="acbab8995daa433cebfc335ffe8ae8fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbab8995daa433cebfc335ffe8ae8fd0">&#9670;&#160;</a></span>DrakeVisualizerd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#acbab8995daa433cebfc335ffe8ae8fd0">DrakeVisualizerd</a> = <a class="el" href="classdrake_1_1geometry_1_1_drake_visualizer.html">DrakeVisualizer</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenient alias for the <a class="el" href="classdrake_1_1geometry_1_1_drake_visualizer.html" title="A system that publishes LCM messages representing the current state of a SceneGraph instance (whose Q...">DrakeVisualizer</a> class when using the <span class="tt"><a class="el" href="classdouble.html">double</a></span> scalar type. </p>

</div>
</div>
<a id="a92efe958866f76d7391035159c554a56" name="a92efe958866f76d7391035159c554a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92efe958866f76d7391035159c554a56">&#9670;&#160;</a></span>FilterId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a92efe958866f76d7391035159c554a56">FilterId</a> = <a class="el" href="classdrake_1_1_identifier.html">drake::Identifier</a>&lt;class FilterTag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used to identify transient collision filter declarations in <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>. </p>

</div>
</div>
<a id="a43b41363b37fadf8cce0977d500e13cb" name="a43b41363b37fadf8cce0977d500e13cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b41363b37fadf8cce0977d500e13cb">&#9670;&#160;</a></span>FrameId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> = <a class="el" href="classdrake_1_1_identifier.html">drake::Identifier</a>&lt;class FrameTag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used to identify geometry frames in <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>. </p>

</div>
</div>
<a id="a3a71d18e80aa6fba962ddd8a33aecb05" name="a3a71d18e80aa6fba962ddd8a33aecb05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a71d18e80aa6fba962ddd8a33aecb05">&#9670;&#160;</a></span>FrameIdSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a3a71d18e80aa6fba962ddd8a33aecb05">FrameIdSet</a> = std::unordered_set&lt;<a class="el" href="#a43b41363b37fadf8cce0977d500e13cb">FrameId</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collection of unique frame ids. </p>

</div>
</div>
<a id="a0f8e11a5858131e3e05d6d07fd4cceeb" name="a0f8e11a5858131e3e05d6d07fd4cceeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8e11a5858131e3e05d6d07fd4cceeb">&#9670;&#160;</a></span>FramePoseVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0f8e11a5858131e3e05d6d07fd4cceeb">FramePoseVector</a> = <a class="el" href="classdrake_1_1geometry_1_1_kinematics_vector.html">KinematicsVector</a>&lt;<a class="el" href="#a43b41363b37fadf8cce0977d500e13cb">FrameId</a>, <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt;T&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class for communicating <em>pose</em> information to <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> for registered frames. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9c4c9d66418bb333c14d48e05aac617" name="ab9c4c9d66418bb333c14d48e05aac617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c4c9d66418bb333c14d48e05aac617">&#9670;&#160;</a></span>GeometryConfigurationVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab9c4c9d66418bb333c14d48e05aac617">GeometryConfigurationVector</a> = <a class="el" href="classdrake_1_1geometry_1_1_kinematics_vector.html">KinematicsVector</a>&lt;<a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a>, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class for communicating <em>configuration</em> information to <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> for registered deformable geometries. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae17f078345eeccd086fdb02c198d5b7d" name="ae17f078345eeccd086fdb02c198d5b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17f078345eeccd086fdb02c198d5b7d">&#9670;&#160;</a></span>GeometryIdSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae17f078345eeccd086fdb02c198d5b7d">GeometryIdSet</a> = std::unordered_set&lt;<a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collection of unique geometry ids. </p>

</div>
</div>
<a id="a13b4d36d0491327603af75e4f6d0c52a" name="a13b4d36d0491327603af75e4f6d0c52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b4d36d0491327603af75e4f6d0c52a">&#9670;&#160;</a></span>MeshcatPointCloudVisualizerd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a13b4d36d0491327603af75e4f6d0c52a">MeshcatPointCloudVisualizerd</a> = <a class="el" href="classdrake_1_1geometry_1_1_meshcat_point_cloud_visualizer.html">MeshcatPointCloudVisualizer</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenient alias for the <a class="el" href="classdrake_1_1geometry_1_1_meshcat_point_cloud_visualizer.html" title="MeshcatPointCloudVisualizer is a systems::LeafSystem that publishes a perception::PointCloud from its...">MeshcatPointCloudVisualizer</a> class when using the <span class="tt"><a class="el" href="classdouble.html">double</a></span> scalar type. </p>

</div>
</div>
<a id="acfc5928f9ddabb01ca8a0f2cdabbffa3" name="acfc5928f9ddabb01ca8a0f2cdabbffa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc5928f9ddabb01ca8a0f2cdabbffa3">&#9670;&#160;</a></span>MeshcatVisualizerd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#acfc5928f9ddabb01ca8a0f2cdabbffa3">MeshcatVisualizerd</a> = <a class="el" href="classdrake_1_1geometry_1_1_meshcat_visualizer.html">MeshcatVisualizer</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenient alias for the <a class="el" href="classdrake_1_1geometry_1_1_meshcat_visualizer.html" title="A system wrapper for Meshcat that publishes the current state of a SceneGraph instance (whose QueryOb...">MeshcatVisualizer</a> class when using the <span class="tt"><a class="el" href="classdouble.html">double</a></span> scalar type. </p>

</div>
</div>
<a id="a70187c16ea14553f92a3bec4402ae490" name="a70187c16ea14553f92a3bec4402ae490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70187c16ea14553f92a3bec4402ae490">&#9670;&#160;</a></span>PolygonSurfaceMeshFieldLinear</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldValue, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a70187c16ea14553f92a3bec4402ae490">PolygonSurfaceMeshFieldLinear</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear&lt;FieldValue, PolygonSurfaceMesh&lt;T&gt;</a>&gt;</div>
<div class="ttc" id="aclassdrake_1_1geometry_1_1_mesh_field_linear_html"><div class="ttname"><a href="classdrake_1_1geometry_1_1_mesh_field_linear.html">drake::geometry::MeshFieldLinear</a></div><div class="ttdoc">MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...</div><div class="ttdef"><b>Definition</b> mesh_field_linear.h:126</div></div>
</div><!-- fragment -->
<p>A convenience alias for instantiating a <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a> on a <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html" title="PolygonSurfaceMesh represents a surface comprised of polygonal elements (three or more sides).">PolygonSurfaceMesh</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FieldValue</td><td>A valid Eigen scalar or vector of valid Eigen scalars for the field value. </td></tr>
    <tr><td class="paramname">T</td><td>A valid Eigen scalar for mesh coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74b8d905842571b365085fdd17378772" name="a74b8d905842571b365085fdd17378772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b8d905842571b365085fdd17378772">&#9670;&#160;</a></span>promoted_numerical_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a74b8d905842571b365085fdd17378772">promoted_numerical_t</a> = typename <a class="el" href="structdrake_1_1geometry_1_1promoted__numerical.html">promoted_numerical</a>&lt;T, U&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac53cb597123131fb23a7af26e8d350bf" name="ac53cb597123131fb23a7af26e8d350bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53cb597123131fb23a7af26e8d350bf">&#9670;&#160;</a></span>SourceId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac53cb597123131fb23a7af26e8d350bf">SourceId</a> = <a class="el" href="classdrake_1_1_identifier.html">drake::Identifier</a>&lt;class SourceTag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used to identify geometry sources in <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>. </p>

</div>
</div>
<a id="afb1cea0cef695099b2d920680d24050f" name="afb1cea0cef695099b2d920680d24050f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1cea0cef695099b2d920680d24050f">&#9670;&#160;</a></span>TriangleSurfaceMeshFieldLinear</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldValue, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#afb1cea0cef695099b2d920680d24050f">TriangleSurfaceMeshFieldLinear</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear&lt;FieldValue, TriangleSurfaceMesh&lt;T&gt;</a>&gt;</div>
</div><!-- fragment -->
<p>A convenience alias for instantiating a <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a> on a <a class="el" href="classdrake_1_1geometry_1_1_triangle_surface_mesh.html" title="TriangleSurfaceMesh represents a union of triangles.">TriangleSurfaceMesh</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FieldValue</td><td>A valid Eigen scalar or vector of valid Eigen scalars for the field value. </td></tr>
    <tr><td class="paramname">T</td><td>A valid Eigen scalar for mesh coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee6c99359ac348f38b4d470329ec1851" name="aee6c99359ac348f38b4d470329ec1851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6c99359ac348f38b4d470329ec1851">&#9670;&#160;</a></span>VolumeMeshFieldLinear</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FieldValue, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aee6c99359ac348f38b4d470329ec1851">VolumeMeshFieldLinear</a> = <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a>&lt;FieldValue, <a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html">VolumeMesh</a>&lt;T&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience alias for instantiating a <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a> on a <a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html" title="VolumeMesh represents a tetrahedral volume mesh.">VolumeMesh</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FieldValue</td><td>A valid Eigen scalar or vector of valid Eigen scalars for the field value. </td></tr>
    <tr><td class="paramname">T</td><td>A valid Eigen scalar for mesh coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="ad580d9f8e007396af59694d605245253" name="ad580d9f8e007396af59694d605245253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad580d9f8e007396af59694d605245253">&#9670;&#160;</a></span>CollisionFilterScope</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ad580d9f8e007396af59694d605245253">CollisionFilterScope</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum that defines the scope of the geometries that are affected by the collision filtering mechanism. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad580d9f8e007396af59694d605245253a34bdbffdb1c0e1b603f58fc0d49548b6" name="ad580d9f8e007396af59694d605245253a34bdbffdb1c0e1b603f58fc0d49548b6"></a>kAll&#160;</td><td class="fielddoc"><p>All geometries are considered when collision filters are applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad580d9f8e007396af59694d605245253add0cbaa458a6d1a39dfc809377ad2be8" name="ad580d9f8e007396af59694d605245253add0cbaa458a6d1a39dfc809377ad2be8"></a>kOmitDeformable&#160;</td><td class="fielddoc"><p>Deformable geometries are omitted when applying collision filters. </p>
<p>That means that all deformable geometries are not affected by the collision filter declaration even if they are included in the <a class="el" href="classdrake_1_1geometry_1_1_geometry_set.html" title="The GeometrySet, as its name implies, is a convenience class for defining a set of geometries.">GeometrySet</a> when the filter is declared. </p>
</td></tr>
</table>

</div>
</div>
<a id="a227f80cb57c9c87f6ecc4e839e364979" name="a227f80cb57c9c87f6ecc4e839e364979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227f80cb57c9c87f6ecc4e839e364979">&#9670;&#160;</a></span>HydroelasticContactRepresentation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a227f80cb57c9c87f6ecc4e839e364979">HydroelasticContactRepresentation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports on how a hydroelastic contact surface is represented. </p>
<p>See <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#contact_surface_discrete_representation">the documentation in ContactSurface</a> for more details. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a227f80cb57c9c87f6ecc4e839e364979a3a53496ffe96227ef579995d332425c1" name="a227f80cb57c9c87f6ecc4e839e364979a3a53496ffe96227ef579995d332425c1"></a>kTriangle&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a227f80cb57c9c87f6ecc4e839e364979a64edd70c85c6854f380a0cbbc3db3cbb" name="a227f80cb57c9c87f6ecc4e839e364979a64edd70c85c6854f380a0cbbc3db3cbb"></a>kPolygon&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="aa480f7d5d485f556225ed73538dd4eca" name="aa480f7d5d485f556225ed73538dd4eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa480f7d5d485f556225ed73538dd4eca">&#9670;&#160;</a></span>MeshGradientMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#aa480f7d5d485f556225ed73538dd4eca">MeshGradientMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specify whether to generate gradients, and how to handle numerical failures. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa480f7d5d485f556225ed73538dd4ecaa35c3ace1970663a16e5c65baa5941b13" name="aa480f7d5d485f556225ed73538dd4ecaa35c3ace1970663a16e5c65baa5941b13"></a>kNone&#160;</td><td class="fielddoc"><p>Don't compute gradients at all. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa480f7d5d485f556225ed73538dd4ecaa5543e81cb3b8f1409b593cc1ebce1752" name="aa480f7d5d485f556225ed73538dd4ecaa5543e81cb3b8f1409b593cc1ebce1752"></a>kOkOrMarkDegenerate&#160;</td><td class="fielddoc"><p>If gradient computation fails, mark it degenerate. </p>
<p>See <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html#a3f68cddb7189743795032263fdfa4509">MeshFieldLinear::is_gradient_field_degenerate()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa480f7d5d485f556225ed73538dd4ecaa26940490086ffcdf0616b678df54e7f8" name="aa480f7d5d485f556225ed73538dd4ecaa26940490086ffcdf0616b678df54e7f8"></a>kOkOrThrow&#160;</td><td class="fielddoc"><p>If gradient computation fails, throw an exception. </p>
</td></tr>
</table>

</div>
</div>
<a id="acdd79a1a4f81dd6ee5cddcb21149b951" name="acdd79a1a4f81dd6ee5cddcb21149b951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd79a1a4f81dd6ee5cddcb21149b951">&#9670;&#160;</a></span>Role</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#acdd79a1a4f81dd6ee5cddcb21149b951">Role</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>General enumeration for indicating geometry role. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acdd79a1a4f81dd6ee5cddcb21149b951a41ba12ed492ce20c3ff503a553ae85ea" name="acdd79a1a4f81dd6ee5cddcb21149b951a41ba12ed492ce20c3ff503a553ae85ea"></a>kUnassigned&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acdd79a1a4f81dd6ee5cddcb21149b951ad909c44a5dea6ebbdb3a95e4cb701521" name="acdd79a1a4f81dd6ee5cddcb21149b951ad909c44a5dea6ebbdb3a95e4cb701521"></a>kProximity&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acdd79a1a4f81dd6ee5cddcb21149b951aac28e5ab68fbe5dc23f550aa18255c07" name="acdd79a1a4f81dd6ee5cddcb21149b951aac28e5ab68fbe5dc23f550aa18255c07"></a>kIllustration&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acdd79a1a4f81dd6ee5cddcb21149b951ac1f9a0ba01987bd1d23d1c4ea605df2b" name="acdd79a1a4f81dd6ee5cddcb21149b951ac1f9a0ba01987bd1d23d1c4ea605df2b"></a>kPerception&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a52f8cb466b0827379bc8815f0d58aac3" name="a52f8cb466b0827379bc8815f0d58aac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f8cb466b0827379bc8815f0d58aac3">&#9670;&#160;</a></span>RoleAssign</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a52f8cb466b0827379bc8815f0d58aac3">RoleAssign</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The operations that can be performed on the given properties when assigning roles to geometry. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a52f8cb466b0827379bc8815f0d58aac3aaf1adf7ec3673b4f5765cfbc5d43b7dc" name="a52f8cb466b0827379bc8815f0d58aac3aaf1adf7ec3673b4f5765cfbc5d43b7dc"></a>kNew&#160;</td><td class="fielddoc"><p>Assign the properties to a geometry that doesn't already have the role. </p>
</td></tr>
<tr><td class="fieldname"><a id="a52f8cb466b0827379bc8815f0d58aac3a8ba1782ca7c04c255b3d69d6d2411d90" name="a52f8cb466b0827379bc8815f0d58aac3a8ba1782ca7c04c255b3d69d6d2411d90"></a>kReplace&#160;</td><td class="fielddoc"><p>Replace the existing role properties completely. </p>
</td></tr>
</table>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a7cccbced57eb9c31f3e5e9ad26099257" name="a7cccbced57eb9c31f3e5e9ad26099257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cccbced57eb9c31f3e5e9ad26099257">&#9670;&#160;</a></span>AddCompliantHydroelasticProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddCompliantHydroelasticProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>resolution_hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>hydroelastic_modulus</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *</td>          <td class="paramname"><span class="paramname"><em>properties</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds properties to the given set of proximity properties sufficient to cause the associated geometry to generate a compliant hydroelastic representation. </p>
<p>The geometry's pressure field will be the function p(e) = Ee, where E is the hydroelastic modulus stored in the given <span class="tt">properties</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">resolution_hint</td><td>If the geometry is to be tessellated, it is the parameter that guides the level of mesh refinement. It has length units (in meters) and roughly corresponds to a typical edge length in the resulting mesh. See <a class="el" href="group__hydroelastic__user__guide.html#hug_properties">Properties for hydroelastic contact</a>. This will be ignored for geometry types that don't require tessellation. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">hydroelastic_modulus</td><td>A multiplier that maps penetration to pressure. See <a class="el" href="group__hydroelastic__user__guide.html#hug_properties">Properties for hydroelastic contact</a>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">properties</td><td>The properties will be added to this property set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>If <span class="tt">properties</span> already has properties with the names that this function would need to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt; <span class="tt">resolution_hint</span> &lt; ∞, 0 &lt; <span class="tt">hydroelastic_modulus</span>, and <span class="tt">properties</span> is not nullptr. </dd></dl>

</div>
</div>
<a id="ac8718ed182e7a34c228c3f00d1ad1a23" name="ac8718ed182e7a34c228c3f00d1ad1a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8718ed182e7a34c228c3f00d1ad1a23">&#9670;&#160;</a></span>AddCompliantHydroelasticPropertiesForHalfSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddCompliantHydroelasticPropertiesForHalfSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>slab_thickness</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>hydroelastic_modulus</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *</td>          <td class="paramname"><span class="paramname"><em>properties</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compliant half spaces are handled as a special case; they do not get tessellated. </p>
<p>Instead, they are treated as infinite slabs with a finite thickness. This variant is required for hydroelastic half spaces.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">slab_thickness</td><td>The distance from the half space boundary to its rigid core (this helps define the extent field of the half space). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">hydroelastic_modulus</td><td>A multiplier that maps penetration to pressure. See <a class="el" href="group__hydroelastic__user__guide.html#hug_properties">Properties for hydroelastic contact</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">properties</td><td>The properties will be added to this property set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>If <span class="tt">properties</span> already has properties with the names that this function would need to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt; <span class="tt">slab_thickness</span> &lt; ∞, 0 &lt; <span class="tt">hydroelastic_modulus</span>, and <span class="tt">properties</span> is not nullptr. </dd></dl>

</div>
</div>
<a id="a172a6c0e9c7f29a07c1e5437f17c6d9d" name="a172a6c0e9c7f29a07c1e5437f17c6d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172a6c0e9c7f29a07c1e5437f17c6d9d">&#9670;&#160;</a></span>AddContactMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddContactMaterial </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>dissipation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>point_stiffness</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">multibody::CoulombFriction</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>friction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *</td>          <td class="paramname"><span class="paramname"><em>properties</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#a172a6c0e9c7f29a07c1e5437f17c6d9d" title="AddContactMaterial() adds general contact material properties to the given set of proximity propertie...">AddContactMaterial()</a> adds general contact material properties to the given set of proximity <span class="tt">properties</span>. </p>
<p>These are the properties required by the default point contact model. However, other contact models can opt to use these properties as well. Only the parameters that carry values will be added to the given set of <span class="tt">properties</span>; no default values will be provided. Downstream consumers of the contact materials can optionally provide defaults for missing properties.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">dissipation</span> is negative, <span class="tt">point_stiffness</span> is not positive, of any of the contact material properties have already been defined in <span class="tt">properties</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">properties</span> is not nullptr. </dd></dl>

</div>
</div>
<a id="a6c74afc9942060de51e7c6a65f0ade08" name="a6c74afc9942060de51e7c6a65f0ade08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c74afc9942060de51e7c6a65f0ade08">&#9670;&#160;</a></span>AddRigidHydroelasticProperties() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddRigidHydroelasticProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>resolution_hint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *</td>          <td class="paramname"><span class="paramname"><em>properties</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds properties to the given set of proximity properties sufficient to cause the associated geometry to generate a rigid hydroelastic representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">resolution_hint</td><td>If the geometry is to be tessellated, it is the parameter that guides the level of mesh refinement. It has length units (in meters) and roughly corresponds to a typical edge length in the resulting mesh. See <a class="el" href="group__hydroelastic__user__guide.html#hug_properties">Properties for hydroelastic contact</a>. This will be ignored for geometry types that don't require tessellation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">properties</td><td>The properties will be added to this property set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>If <span class="tt">properties</span> already has properties with the names that this function would need to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt; <span class="tt">resolution_hint</span> &lt; ∞ and <span class="tt">properties</span> is not nullptr. </dd></dl>

</div>
</div>
<a id="a9f348bc35f08089e23f075a72a72c683" name="a9f348bc35f08089e23f075a72a72c683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f348bc35f08089e23f075a72a72c683">&#9670;&#160;</a></span>AddRigidHydroelasticProperties() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddRigidHydroelasticProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> *</td>          <td class="paramname"><span class="paramname"><em>properties</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload, intended for shapes that don't get tessellated in their hydroelastic representation (e.g., <a class="el" href="classdrake_1_1geometry_1_1_half_space.html" title="Definition of a half space.">HalfSpace</a> and <a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Definition of a general (possibly non-convex) mesh.">Mesh</a>). </p>
<p>See <a class="el" href="group__hydroelastic__user__guide.html#hug_properties">Properties for hydroelastic contact</a>. </p>

</div>
</div>
<a id="a1b02fd98506fd3eaa665e6aea5964675" name="a1b02fd98506fd3eaa665e6aea5964675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b02fd98506fd3eaa665e6aea5964675">&#9670;&#160;</a></span>CalcObb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classdrake_1_1geometry_1_1_obb.html">Obb</a> &gt; CalcObb </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the oriented bounding box (OBB) for the <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The abstract base class for all shape specifications.">Shape</a> in its canonical frame. </p>
<p>Returns <span class="tt">std::nullopt</span> if the <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The abstract base class for all shape specifications.">Shape</a> is <a class="el" href="classdrake_1_1geometry_1_1_half_space.html" title="Definition of a half space.">HalfSpace</a> which doesn't have a bounding box.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if a referenced file cannot be opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac677ae9aff90aba0a891854f4287a643" name="ac677ae9aff90aba0a891854f4287a643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac677ae9aff90aba0a891854f4287a643">&#9670;&#160;</a></span>CalcVolume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> CalcVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the volume (in meters^3) for the <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The abstract base class for all shape specifications.">Shape</a>. </p>
<p>For convex and mesh geometries, the algorithm only supports ".obj" files and only produces meaningful results for "closed" shapes.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the derived type hasn't overloaded this implementation (yet), if a filetype is unsupported, or if a referenced file cannot be opened. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75a53812378833c4ceabcde98a841e89" name="a75a53812378833c4ceabcde98a841e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a53812378833c4ceabcde98a841e89">&#9670;&#160;</a></span>ConvertVolumeToSurfaceMesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_triangle_surface_mesh.html">TriangleSurfaceMesh</a>&lt; T &gt; ConvertVolumeToSurfaceMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html">VolumeMesh</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>volume</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a tetrahedral volume mesh to a triangulated surface mesh of the boundary surface of the volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The tetrahedral volume mesh, whose vertex positions are measured and expressed in some frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The triangulated surface mesh, whose vertex positions are measured and expressed in the same frame E of the volume mesh. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The vertices of the volume mesh are unique. Adjacent tetrahedra share the same vertices, instead of repeating the vertices with the same coordinates. Otherwise, the returned surface mesh will have extra triangles in addition to the boundary triangles of the volume. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default nonsymbolic scalars</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6e7ff65cee87fead2192eae91ca0b28" name="ac6e7ff65cee87fead2192eae91ca0b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e7ff65cee87fead2192eae91ca0b28">&#9670;&#160;</a></span>MakePhongIllustrationProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html">IllustrationProperties</a> MakePhongIllustrationProperties </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>diffuse</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an <a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html" title="The set of properties for geometry used in an &quot;illustration&quot; role.">IllustrationProperties</a> instance compatible with a simple "phong" material using only the given <span class="tt">diffuse</span> color. </p>

</div>
</div>
<a id="abb99e00d0f295497d9b250d9bf03a0a2" name="abb99e00d0f295497d9b250d9bf03a0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb99e00d0f295497d9b250d9bf03a0a2">&#9670;&#160;</a></span>MakeRenderEngineGl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1render_1_1_render_engine.html">render::RenderEngine</a> &gt; MakeRenderEngineGl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdrake_1_1geometry_1_1_render_engine_gl_params.html">RenderEngineGlParams</a></td>          <td class="paramname"><span class="paramname"><em>params</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a RenderEngine implementation which uses a purely OpenGL renderer. </p>
<p>The engine only works under Ubuntu. If called on a Mac, it will throw.</p>
<dl class="section note"><dt>Note</dt><dd>RenderEngineGl behaves a bit differently from other RenderEngine implementations (e.g., RenderEngineVtk) with respect to displayed images. First, RenderEngineGl can only display a <em>single</em> image type at a time. So, if a shown window has been requested for both label and color images, the images will alternate in the same window. Second, the window display draws all images <em>flipped vertically</em>. The image produced will be compatible with the Drake ecosystem, only the visualization will be upside down. This has been documented in <a href="https://github.com/RobotLocomotion/drake/issues/14254">https://github.com/RobotLocomotion/drake/issues/14254</a>.</dd></dl>
<p><b> Using RenderEngineGl in multiple threads </b></p>
<p>Most importantly, a single RenderEngineGl should <em>not</em> be exercised in multiple threads. One thread, one RenderEngineGl instance.</p>
<p>A RenderEngineGl instance and its <em>clones</em> can be used in different threads simultaneously, but <em>only</em> the rendering APIs are threadsafe. Do not mutate the contents of the engine (e.g., adding/removing geometries, etc.) in parallel.</p>
<p>Two independently constructed RenderEngineGl instances can be freely used in different threads &ndash; all APIs are available.</p>
<p>The expected workflow is to add a RenderEngineGl instance a <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> instance (see <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html#a7acc35fe63b16403d1c8e177cfed0b7b" title="Adds a new render engine to this SceneGraph.">SceneGraph::AddRenderer()</a>) and then to populate <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> with the desired geometry. Each <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">systems::Context</a> allocated for that <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> will receive a clone of the original RenderEngineGl. One <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">systems::Context</a> can be used per thread to create rendered images in parallel.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if kHasRenderEngineGl is false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a004a8b7a49c0b7a4bc2f8860af26591b" name="a004a8b7a49c0b7a4bc2f8860af26591b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a004a8b7a49c0b7a4bc2f8860af26591b">&#9670;&#160;</a></span>MakeRenderEngineGltfClient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1render_1_1_render_engine.html">render::RenderEngine</a> &gt; MakeRenderEngineGltfClient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1geometry_1_1_render_engine_gltf_client_params.html">RenderEngineGltfClientParams</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a RenderEngine implementation which generates <a href="https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html">glTF </a> files to upload to a render server, and retrieves renderings from said server by copying image data back into drake <a class="el" href="classdrake_1_1systems_1_1sensors_1_1_image.html" title="Simple data format for Image.">systems::sensors::Image</a> buffers. </p>
<p>The server url and endpoint are provided through the specified <a class="el" href="structdrake_1_1geometry_1_1_render_engine_gltf_client_params.html" title="Construction parameters for the MakeRenderEngineGltfClient() to create a client as part of the glTF R...">RenderEngineGltfClientParams</a>. The returned RenderEngine implements the client side of the <a class="el" href="group__render__engine__gltf__client__server__api.html">glTF Render Client-Server API</a>. The rules for supported geometries and textures are the same as for the VTK-based engine and are described in <a class="el" href="#a8d8e28336b380bccf83c9e5611689e2b" title="Constructs a RenderEngine implementation which uses a VTK-based OpenGL renderer.">MakeRenderEngineVtk()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The underlying RenderEngine utilizes <a href="https://curl.se/libcurl/">libcurl</a> to communicate with a server. Static curl initialization must be performed once per process, and the operation is <a href="https://curl.se/libcurl/c/threadsafe.html"><b>not</b> thread-safe</a>! Instantiating this RenderEngine automatically initializes curl with the default <a href="https://curl.se/libcurl/c/curl_global_init.html"><span class="tt">curl_global_init(CURL_GLOBAL_ALL | CURL_GLOBAL_ACK_EINTR)</span></a>, the implication for consuming applications being: </dd>
<dd>
<ol type="1">
<li>See <a class="el" href="group__allow__network.html">DRAKE_ALLOW_NETWORK</a> for an environment variable option to deny remote rendering entirely.</li>
<li>If you intend to have your rendering take place in a threaded context, you <b>must</b> instantiate this RenderEngine via MakeRenderEngineGltfClient from the main thread <b>before</b> spawning your threaded workers. As soon as one of these RenderEngine instances has been constructed, libcurl will have been initialized. <div class="fragment"><div class="line"><span class="comment">// Setup your server information and create the RenderEngine.  This must</span></div>
<div class="line"><span class="comment">// be done in a non-threaded context (e.g., at the program start).</span></div>
<div class="line"><a class="code hl_struct" href="structdrake_1_1geometry_1_1_render_engine_gltf_client_params.html">RenderEngineGltfClientParams</a> params;</div>
<div class="line">params.<a class="code hl_variable" href="structdrake_1_1geometry_1_1_render_engine_gltf_client_params.html#a6120129a500ee5f5fb32836c1ad5bbc0">base_url</a> = <span class="stringliteral">&quot;http://some-server.url&quot;</span>;</div>
<div class="line"><span class="keyword">auto</span> render_engine = <a class="code hl_function" href="#a004a8b7a49c0b7a4bc2f8860af26591b">MakeRenderEngineGltfClient</a>(params);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// After MakeRenderEngineGltfClient() function call, libcurl has been</span></div>
<div class="line"><span class="comment">// initialized and you may now create threads if desired.</span></div>
<div class="ttc" id="anamespacedrake_1_1geometry_html_a004a8b7a49c0b7a4bc2f8860af26591b"><div class="ttname"><a href="#a004a8b7a49c0b7a4bc2f8860af26591b">drake::geometry::MakeRenderEngineGltfClient</a></div><div class="ttdeci">std::unique_ptr&lt; render::RenderEngine &gt; MakeRenderEngineGltfClient(const RenderEngineGltfClientParams &amp;params)</div><div class="ttdoc">Constructs a RenderEngine implementation which generates glTF  files to upload to a render server,...</div></div>
<div class="ttc" id="astructdrake_1_1geometry_1_1_render_engine_gltf_client_params_html"><div class="ttname"><a href="structdrake_1_1geometry_1_1_render_engine_gltf_client_params.html">drake::geometry::RenderEngineGltfClientParams</a></div><div class="ttdoc">Construction parameters for the MakeRenderEngineGltfClient() to create a client as part of the glTF R...</div><div class="ttdef"><b>Definition</b> render_engine_gltf_client_params.h:14</div></div>
<div class="ttc" id="astructdrake_1_1geometry_1_1_render_engine_gltf_client_params_html_a6120129a500ee5f5fb32836c1ad5bbc0"><div class="ttname"><a href="structdrake_1_1geometry_1_1_render_engine_gltf_client_params.html#a6120129a500ee5f5fb32836c1ad5bbc0">drake::geometry::RenderEngineGltfClientParams::base_url</a></div><div class="ttdeci">std::string base_url</div><div class="ttdoc">The base url of the server communicate with.</div><div class="ttdef"><b>Definition</b> render_engine_gltf_client_params.h:27</div></div>
</div><!-- fragment --></li>
<li>If you need to use a different initialization strategy for libcurl in your application, you should first create the RenderEngine using MakeRenderEngineGltfClient, then manually call <a href="https://curl.se/libcurl/c/curl_global_cleanup.html"><span class="tt">curl_global_cleanup()</span></a>, followed by manually calling <a href="https://curl.se/libcurl/c/curl_global_init.html"><span class="tt">curl_global_init(...)</span></a> with your desired flags. In general, this scenario is <b>atypical</b> and you should not need to worry about this. Applications with specialized libcurl needs, though, must understand the construction and initialization order to be able to modify the behavior to suit their needs. <div class="fragment"><div class="line"><span class="comment">// Follow the steps above to construct the RenderEngine given the</span></div>
<div class="line"><span class="comment">// specified RenderEngineGltfClientParams.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Libcurl has been initialized at this point, so your application needs</span></div>
<div class="line"><span class="comment">// to reset and re-initialize curl again.</span></div>
<div class="line">curl_global_cleanup();</div>
<div class="line">curl_global_init(...);  <span class="comment">// &lt;&lt;&lt; your custom flags here</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now that libcurl has been re-initialized to suit your application&#39;s</span></div>
<div class="line"><span class="comment">// needs, you may now create threads if desired.</span></div>
</div><!-- fragment --></li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if kHasRenderEngineGltfClient is false, or if disabled via the environment variable DRAKE_ALLOW_NETWORK. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d8e28336b380bccf83c9e5611689e2b" name="a8d8e28336b380bccf83c9e5611689e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8e28336b380bccf83c9e5611689e2b">&#9670;&#160;</a></span>MakeRenderEngineVtk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1render_1_1_render_engine.html">render::RenderEngine</a> &gt; MakeRenderEngineVtk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1geometry_1_1_render_engine_vtk_params.html">RenderEngineVtkParams</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a RenderEngine implementation which uses a VTK-based OpenGL renderer. </p>
<dl class="section warning"><dt>Warning</dt><dd>On macOS, we've observed that RenderEngineVtk sometimes does not obey <a class="el" href="classdrake_1_1geometry_1_1render_1_1_color_render_camera.html#ace4c47773d7612ddd9396fb4e958058a" title="If true, requests that the RenderEngine display the rendered image.">render::ColorRenderCamera::show_window</a> when it's set to <span class="tt">true</span>. Refer to issue <a href="https://github.com/RobotLocomotion/drake/issues/20144">#20144</a> for further discussion.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>On Ubuntu, <a class="el" href="classdrake_1_1geometry_1_1render_1_1_color_render_camera.html#ace4c47773d7612ddd9396fb4e958058a" title="If true, requests that the RenderEngine display the rendered image.">render::ColorRenderCamera::show_window</a> only shows a window when <a class="el" href="structdrake_1_1geometry_1_1_render_engine_vtk_params.html#a8ea4310382b496e8e4efc05c73409cbc" title="Controls which graphics library will be used to perform the rendering.">RenderEngineVtkParams::backend</a> is set to "GLX"; the default backend value of "EGL" cannot show a window.</dd></dl>
<p><a class="anchor" id="render_engine_vtk_properties"></a> </p><h2>Geometry perception properties</h2>
<p>This RenderEngine implementation looks for the following properties when registering visual geometry, categorized by rendered image type.</p>
<h3>RGB images</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Group name  </th><th class="markdownTableHeadCenter">Property Name  </th><th class="markdownTableHeadCenter">Required  </th><th class="markdownTableHeadCenter">Property Type  </th><th class="markdownTableHeadLeft">Property Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">phong  </td><td class="markdownTableBodyCenter">diffuse  </td><td class="markdownTableBodyCenter">no¹  </td><td class="markdownTableBodyCenter">Eigen::Vector4d  </td><td class="markdownTableBodyLeft">The rgba value of the object surface.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">phong  </td><td class="markdownTableBodyCenter">diffuse_map  </td><td class="markdownTableBodyCenter">no²  </td><td class="markdownTableBodyCenter">std::string  </td><td class="markdownTableBodyLeft">The path to a texture to apply to the geometry.³⁴  </td></tr>
</table>
<p>¹ If no diffuse value is given, a default rgba value will be applied. The default color is a bright orange. This default value can be changed to a different value at construction. <br  />
 ² If no path is specified, or the file cannot be read, the diffuse rgba value is used (or its default). <br  />
 ³ RenderEngineVtk implements a legacy feature for associating textures with <em>meshes</em>. If <em>no</em> <span class="tt">(phong, diffuse_map)</span> property is provided (or it refers to a file that doesn't exist), for a mesh named <span class="tt">/path/to/mesh.obj</span>, RenderEngineVtk will search for a file <span class="tt">/path/to/mesh.png</span> (replacing "obj" with "png"). If that image exists, it will be used as a texture on the mesh object. ⁴ The render engine consumes pngs with uchar channels. Pngs with a different bit depth, e.g., uint16 channels, will be converted to that.</p>
<dl class="section note"><dt>Note</dt><dd>RenderEngineVtk does not support the OBJ format <span class="tt">usemtl</span> directive. Instead, it has two ways to associate a color texture with an obj file:<ul>
<li>File name matching; see footnote 3 above.</li>
<li>Explicit assignment of arbitrary texture files from within model files. In SDFormat, use the tag <a class="el" href="group__multibody__parsing.html#tag_drake_diffuse_map">drake:diffuse_map</a>. In URDF, use <span class="tt">//visual/material/texture</span>.</li>
</ul>
</dd></dl>
<h3>Depth images</h3>
<p>No specific properties required.</p>
<h3>Label images</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Group name  </th><th class="markdownTableHeadCenter">Property Name  </th><th class="markdownTableHeadCenter">Required  </th><th class="markdownTableHeadCenter">Property Type  </th><th class="markdownTableHeadLeft">Property Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">label  </td><td class="markdownTableBodyCenter">id  </td><td class="markdownTableBodyCenter">no⁵  </td><td class="markdownTableBodyCenter">RenderLabel  </td><td class="markdownTableBodyLeft">The label to render into the image.  </td></tr>
</table>
<p>⁵ When the label property is not set, RenderEngineVtk uses a default render label of RenderLabel::kDontCare.</p>
<h3>Geometries accepted by RenderEngineVtk</h3>
<p>As documented in RenderEngine::RegisterVisual(), a RenderEngine implementation can use the properties found in the <a class="el" href="classdrake_1_1geometry_1_1_perception_properties.html" title="The set of properties for geometry used in a &quot;perception&quot; role.">PerceptionProperties</a> to determine whether it <em>accepts</em> a shape provided for registration. RenderEngineVtk makes use of defaults to accept <em>all</em> geometries (assuming the properties pass validation, e.g., render label validation). </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if kHasRenderEngineVtk is false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fa229f9c0cc6e132f7f4d2a149bb864" name="a7fa229f9c0cc6e132f7f4d2a149bb864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa229f9c0cc6e132f7f4d2a149bb864">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_volume_element.html">VolumeElement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_volume_element.html">VolumeElement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa078bc1cc37439da0b38aec2b6e2ee1d" name="aa078bc1cc37439da0b38aec2b6e2ee1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa078bc1cc37439da0b38aec2b6e2ee1d">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>props</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated</a></b></dt><dd>Use fmt::to_string(), instead <br  />
 This will be removed from Drake on or after 2026-03-01. </dd></dl>

</div>
</div>
<a id="a91365f3b8232ef18656f48264f6a3596" name="a91365f3b8232ef18656f48264f6a3596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91365f3b8232ef18656f48264f6a3596">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_rgba.html">Rgba</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rgba</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated</a></b></dt><dd>Use fmt::to_string(), instead <br  />
 This will be removed from Drake on or after 2026-03-01. </dd></dl>

</div>
</div>
<a id="a968488524d6041456c69fae448e35270" name="a968488524d6041456c69fae448e35270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968488524d6041456c69fae448e35270">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#acdd79a1a4f81dd6ee5cddcb21149b951">Role</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>role</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated</a></b></dt><dd>Use fmt::to_string(), instead <br  />
 This will be removed from Drake on or after 2026-03-01. </dd></dl>

</div>
</div>
<a id="a5e63dda63c412c981364dec694ed3d16" name="a5e63dda63c412c981364dec694ed3d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e63dda63c412c981364dec694ed3d16">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_volume_element.html">VolumeElement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_volume_element.html">VolumeElement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2ba2dbf3b19bdec9eabe6ae62099169" name="ab2ba2dbf3b19bdec9eabe6ae62099169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ba2dbf3b19bdec9eabe6ae62099169">&#9670;&#160;</a></span>ReadGltfToMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1geometry_1_1_in_memory_mesh.html">InMemoryMesh</a> ReadGltfToMemory </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>gltf_path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a file path to a .gltf file, loads the .gltf file contents into memory. </p>
<p>All named .bin and image files are loaded into its supporting files as path-valued <a class="el" href="namespacedrake.html#a08115460f0d38571bcd4445ca9d6ec18" title="Represents a file.">FileSource</a> instances (i.e., absolute paths for the external files are included).</p>
<p>Note: the path-valued supporting files are not validated with respect to their accessibility or even their existence. </p>

</div>
</div>
<a id="a81c676132d054d87c5c47ff786a7d42c" name="a81c676132d054d87c5c47ff786a7d42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c676132d054d87c5c47ff786a7d42c">&#9670;&#160;</a></span>ReadObjToTriangleSurfaceMesh() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_triangle_surface_mesh.html">TriangleSurfaceMesh</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; ReadObjToTriangleSurfaceMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_mesh_source.html">MeshSource</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh_source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;</td>          <td class="paramname"><span class="paramname"><em>scale3</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(std::string_view)&gt;</td>          <td class="paramname"><span class="paramname"><em>on_warning</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of ReadObjToTriangleSurfaceMesh(const std::filesystem::path&amp;,
double) with the Wavefront .obj in a <a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Definition of a general (possibly non-convex) mesh.">Mesh</a> shape specification. </p>

</div>
</div>
<a id="ab353abd55dd1c9955e09e40c1a491475" name="ab353abd55dd1c9955e09e40c1a491475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab353abd55dd1c9955e09e40c1a491475">&#9670;&#160;</a></span>ReadObjToTriangleSurfaceMesh() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_triangle_surface_mesh.html">TriangleSurfaceMesh</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; ReadObjToTriangleSurfaceMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_mesh_source.html">MeshSource</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh_source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>scale</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(std::string_view)&gt;</td>          <td class="paramname"><span class="paramname"><em>on_warning</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant that allows defining uniform scaling from a single scalar value. </p>

</div>
</div>
<a id="aca214fb7e658fbafe777562b609ba572" name="aca214fb7e658fbafe777562b609ba572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca214fb7e658fbafe777562b609ba572">&#9670;&#160;</a></span>ReadObjToTriangleSurfaceMesh() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_triangle_surface_mesh.html">TriangleSurfaceMesh</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; ReadObjToTriangleSurfaceMesh </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;</td>          <td class="paramname"><span class="paramname"><em>scale3</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(std::string_view)&gt;</td>          <td class="paramname"><span class="paramname"><em>on_warning</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a surface mesh from a Wavefront .obj file and optionally scales coordinates by the given scale factor. </p>
<p>Polygons will be triangulated if they are not triangles already. All objects in the .obj file will be merged into the surface mesh. See <a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file">https://en.wikipedia.org/wiki/Wavefront_.obj_file</a> for the file format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>A valid file name with absolute path or relative path. </td></tr>
    <tr><td class="paramname">scale3</td><td>A scale to coordinates. </td></tr>
    <tr><td class="paramname">on_warning</td><td>An optional callback that will receive warning message(s) encountered while reading the mesh. When not provided, <a class="el" href="namespacedrake.html#aa157c1d75c2e52df3370e5f458022ee9" title="Retrieve an instance of a logger to use for logging; for example:">drake::log()</a> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there is an error reading the mesh data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>surface mesh </dd></dl>

</div>
</div>
<a id="a6247d94deb29805e3995bfd786ecd03a" name="a6247d94deb29805e3995bfd786ecd03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6247d94deb29805e3995bfd786ecd03a">&#9670;&#160;</a></span>ReadObjToTriangleSurfaceMesh() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_triangle_surface_mesh.html">TriangleSurfaceMesh</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; ReadObjToTriangleSurfaceMesh </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>scale</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(std::string_view)&gt;</td>          <td class="paramname"><span class="paramname"><em>on_warning</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant that allows defining uniform scaling from a single scalar value. </p>

</div>
</div>
<a id="af9d172ba9808493bb6d98dc9da32e875" name="af9d172ba9808493bb6d98dc9da32e875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d172ba9808493bb6d98dc9da32e875">&#9670;&#160;</a></span>RefineVolumeMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html">VolumeMesh</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; RefineVolumeMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html">VolumeMesh</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refines a tetrahedral mesh to eliminate problematic simplices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh to refine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The refined mesh, or a copy of the input mesh if no refinement was needed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">mesh</span> is not a valid tetrahedral mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd7c2cc9566b924539ebcd75590f48c1" name="acd7c2cc9566b924539ebcd75590f48c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7c2cc9566b924539ebcd75590f48c1">&#9670;&#160;</a></span>RefineVolumeMeshIntoVtkFileContents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string RefineVolumeMeshIntoVtkFileContents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_mesh_source.html">MeshSource</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh_source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refines a tetrahedral mesh to eliminate problematic simplices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh_source</td><td>The mesh to refine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid, ASCII VTK file defining the refined tetrahedral mesh. Represents the input mesh if no refinement was needed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">mesh_source</span> does not reference a valid VTK-formatted tetrahedral mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97f9f12fdd336553a58b605abd5a9563" name="a97f9f12fdd336553a58b605abd5a9563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f9f12fdd336553a58b605abd5a9563">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#acdd79a1a4f81dd6ee5cddcb21149b951">Role</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>role</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="a6a949953d76af52d6dd1b13417cb556a" name="a6a949953d76af52d6dd1b13417cb556a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a949953d76af52d6dd1b13417cb556a">&#9670;&#160;</a></span>kHasRenderEngineGl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool kHasRenderEngineGl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the availability of the RenderEngineGl implementation. </p>

</div>
</div>
<a id="a7cd7e8fb90454c8f7fa6e5dad3afbb59" name="a7cd7e8fb90454c8f7fa6e5dad3afbb59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd7e8fb90454c8f7fa6e5dad3afbb59">&#9670;&#160;</a></span>kHasRenderEngineGltfClient</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool kHasRenderEngineGltfClient</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the availability of the RenderEngineGltfClient implementation. </p>

</div>
</div>
<a id="a8a8c891d80ef7ca189d701d976d65d1f" name="a8a8c891d80ef7ca189d701d976d65d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8c891d80ef7ca189d701d976d65d1f">&#9670;&#160;</a></span>kHasRenderEngineVtk</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool kHasRenderEngineVtk</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the availability of the RenderEngineVtk implementation. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1geometry.html">geometry</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
