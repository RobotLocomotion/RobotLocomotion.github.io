<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: RotationalInertia&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API onlyâ€¦">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drakeâ€¦">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1multibody_1_1_rotational_inertia.html','','classdrake_1_1multibody_1_1_rotational_inertia-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">RotationalInertia&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class drake::multibody::RotationalInertia&lt; T &gt;</div><p>This class describes the mass distribution (inertia properties) of a body or composite body about a particular point. </p>
<p>Herein, "composite body" means one body or a collection of bodies that are welded together. In this documentation, "body" and "composite body" are used interchangeably.</p>
<p>A <b>rigid</b> body's mass distribution is described by three quantities: the body's mass; the body's center of mass; and the body's rotational inertia about a particular point. The term <b>rotational inertia</b> is used here and by [Jain 2010] to distinguish from a body's <b>spatial inertia</b>. In this class, a 3x3 <b>inertia matrix</b> I represents a body's rotational inertia about a point and expressed in a frame. More specifically, <span class="tt">I_BP_E</span> is the inertia matrix of a body B about-point P and expressed-in frame E (herein frame E's orthogonal unit vectors Ex, Ey, Ez are denoted ğ±Ì‚, ğ²Ì‚, ğ³Ì‚). </p><pre>
    | Ixx Ixy Ixz |
I = | Ixy Iyy Iyz |
    | Ixz Iyz Izz |
</pre><p> The moments of inertia Ixx, Iyy, Izz and products of inertia Ixy, Ixz, Iyz are defined in terms of the mass dm of a differential volume of the body. The position of dm from about-point P is xxÌ‚ + yyÌ‚ + zzÌ‚ = [x, y, z]_E. </p><pre>
Ixx = âˆ« (yÂ² + zÂ²) dm
Iyy = âˆ« (xÂ² + zÂ²) dm
Izz = âˆ« (xÂ² + yÂ²) dm
Ixy = - âˆ« x y dm
Ixz = - âˆ« x z dm
Iyz = - âˆ« y z dm
</pre><p> We use the negated convention for products of inertia, so that I serves to relate angular velocity Ï‰ and angular momentum h via <span class="tt">h = I â‹… Ï‰</span>. Ensure your products of inertia follow this negative sign convention.</p>
<p>The 3x3 inertia matrix is symmetric and its diagonal elements (moments of inertia) and off-diagonal elements (products of inertia) are associated with a body (or composite body) S, an about-point P, and an expressed-in frame E (ğ±Ì‚, ğ²Ì‚, ğ³Ì‚Ì‚). A rotational inertia is ill-defined unless there is a body S, about-point P, and expressed-in frame E. The user of this class is responsible for tracking the body S, about-point P and expressed-in frame E (none of these are stored in this class).</p>
<dl class="section note"><dt>Note</dt><dd>This class does not store the about-point nor the expressed-in frame, nor does this class help enforce consistency of the about-point or expressed-in frame. To help users of this class track the about-point and expressed-in frame, we strongly recommend the following notation.</dd>
<dd>
In typeset material, use the symbol \( [I^{S/P}]_E \) to represent the rotational inertia (inertia matrix) of a body (or composite body) S about-point P, expressed in frame E. In code and comments, use the monogram notation <span class="tt">I_SP_E</span> (e.g., as described in <a class="el" href="group__multibody__spatial__inertia.html">Spatial Mass Matrix (Spatial Inertia)</a>). If the about-point P is fixed to a body B, the point is named \( B_P \) and this appears in code/comments as <span class="tt">Bp</span>. Examples: <span class="tt">I_BBp_E</span> is rigid body B's rotational inertia about-point Bp expressed-in frame E; I_BBo_E is B's rotational inertia about-point <span class="tt">Bo</span> (body B's origin) expressed-in frame E; and I_BBcm_E is B's inertia matrix about-point <span class="tt">Bcm</span> (B's center of mass) expressed-in frame E.</dd>
<dd>
The rotational inertia (inertia matrix) can be re-expressed in terms of a special frame whose orthogonal unit vectors are parallel to <b>principal axes of inertia</b> so that the inertia matrix is diagonalized with elements called <b>principal moments of inertia</b>.</dd>
<dd>
The formal definition of the inertia matrix \( I^{S/P} \) of a system S about a point P follows the definition of the inertia dyadic ğˆ of S about P, which begins by modeling S with n particles Sâ‚ ... Sâ‚™ (e.g., 12 grams of carbon can be modeled with n = 6.02 * 10Â²Â³ molecules/particles). The inertia dyadic ğˆâ‚ of one particle Sâ‚ about point P is defined [Kane, 1985] in terms of mâ‚ (mass of Sâ‚), á´¾ğ©Ë¢Â¹ (position vector from P to Sâ‚), and the unit dyadic ğ” which is defined by the property ğ” â‹… ğ¯ = ğ¯ where ğ¯ is is any vector (this definition of ğ” is analogous to defining the identity matrix by the property ğ‘°ğ’…ğ’†ğ’ğ’•ğ’Šğ’•ğ’šğ‘´ğ’‚ğ’•ğ’“ğ’Šğ’™ * ğ’‚ğ’ğ’šğ‘´ğ’‚ğ’•ğ’“ğ’Šğ’™ = ğ’‚ğ’ğ’šğ‘´ğ’‚ğ’•ğ’“ğ’Šğ’™). <pre>
    ğˆâ‚ = mâ‚ * [ğ” * (á´¾ğ©Ë¢Â¹ â‹… á´¾ğ©Ë¢Â¹)  -  á´¾ğ©Ë¢Â¹ * á´¾ğ©Ë¢Â¹]
</pre> Note: The vector dot-product (â‹…) above produces a scalar whereas the vector multiply (*) produces a dyadic which is a 2nd-order tensor (á´¾ğ©Ë¢Â¹ * á´¾ğ©Ë¢Â¹ is similar to the matrix outer-product of a 3x1 matrix multiplied by a 1x3 matrix). An example inertia dyadic for a single particle is shown further below. The inertia dyadic ğˆ of the entire system S is defined by summing the inertia dyadic of each particle Sáµ¢ about P (i = 1, ... n), i.e., <pre>
    ğˆ = ğˆâ‚ + ğˆâ‚‚ + ... ğˆâ‚™
</pre> The elements of the inertia matrix \( [I^{S/P}]_E \) expressed in frame E (in terms of orthogonal unit vectors ğ±Ì‚, ğ²Ì‚, ğ³Ì‚Ì‚) are found by pre-dot multiplying and post-dot multiplying ğˆ with appropriate unit vectors. <pre>
   Ixx = ğ±Ì‚ â‹… ğˆ â‹… ğ±Ì‚     Ixy = ğ±Ì‚ â‹… ğˆ â‹… ğ²Ì‚      Ixz = ğ±Ì‚ â‹… ğˆ â‹… ğ³Ì‚Ì‚
   Iyx = ğ²Ì‚ â‹… ğˆ â‹… ğ±Ì‚     Iyy = ğ²Ì‚ â‹… ğˆ â‹… ğ²Ì‚      Iyz = ğ²Ì‚ â‹… ğˆ â‹… ğ³Ì‚Ì‚
   Izx = ğ³Ì‚Ì‚ â‹… ğˆ â‹… ğ±Ì‚     Izy = ğ³Ì‚Ì‚ â‹… ğˆ â‹… ğ²Ì‚      Izz = ğ³Ì‚Ì‚ â‹… ğˆ â‹… ğ³Ì‚Ì‚
</pre> The inertia dyadic ğˆá´® of a rigid body B about Bcm (B's center of mass) is related to various dynamic quantities. For example, B's angular momentum ğ‡ about Bcm in a frame N and B's kinetic energy KE in N relate to ğˆá´® by <pre>
   ğ‡ = ğˆá´® â‹… ğ›š
   KE = 1/2 ğ›š â‹… ğˆá´® â‹… ğ›š  +  1/2 má´® ğ¯ â‹… ğ¯
</pre> where ğ›š is B's angular velocity in N, ğ¯ is Bcm's translational velocity in N, and má´® is B's mass. When frame N happens to be a Newtonian frame (also called an inertial frame or non-rotating/non-accelerating frame), the moment ğ“ of all forces on B about Bcm relates to ğˆá´® and ğ›‚ (B's angular acceleration in N) by Euler's rigid body equation as <pre>
   ğ“ = ğˆá´® â‹… ğ›‚  +  ğ›š Ã— ğˆá´® â‹… ğ›š
</pre> Example: For a particle Q of mass m whose position vector from a point O is written in terms of right-handed orthogonal unit vectors ğ±Ì‚, ğ²Ì‚, ğ³Ì‚ (below), the inertia dyadic ğˆ of particle Q about point O is defined and calculated <pre>
    ğ© = x ğ±Ì‚  +  y ğ²Ì‚                               (given)
    ğˆ = m * [ğ” * (ğ© â‹… ğ©)  -  ğ© * ğ©]              (definition)
      = m * [ğ” * (xÂ² + yÂ²)  -  (xğ±Ì‚ + yğ²Ì‚Ì‚) * (xğ±Ì‚ + yğ²Ì‚)
      = m * [(ğ±Ì‚ğ±Ì‚ + ğ²Ì‚ğ²Ì‚ + ğ³Ì‚ğ³Ì‚) * (xÂ² + yÂ²) - (xÂ²ğ±Ì‚ğ±Ì‚ + xyğ±Ì‚ğ²Ì‚Ì‚ + xyğ²Ì‚Ì‚ğ±Ì‚ + yÂ²ğ²Ì‚Ì‚ğ²Ì‚Ì‚)]
      = m * [yÂ²ğ±Ì‚ğ±Ì‚ + xÂ²ğ²Ì‚ğ²Ì‚ + (xÂ² + yÂ²)ğ³Ì‚ğ³Ì‚ - xyğ±Ì‚ğ²Ì‚Ì‚ - xyğ²Ì‚Ì‚ğ±Ì‚]
</pre> which means the inertia matrix for particle Q about point O for ğ±Ì‚, ğ²Ì‚, ğ³Ì‚ is <pre>
    |  m yÂ²     -m x y         0     |
I = | -m x y     m xÂ²          0     |
    |    0         0     m (xÂ² + yÂ²) |
</pre> [Kane, 1985] pg. 68. "Dynamics: Theory and Applications," McGraw-Hill Co., New York, 1985 (with D. A. Levinson). Available for free .pdf download: <a href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></dd>
<dd>
Several methods in this class throw a std::exception for invalid rotational inertia operations in debug releases only. This provides speed in a release build while facilitating debugging in debug builds. In addition, these validity tests are only performed for scalar types for which <a class="el" href="structdrake_1_1scalar__predicate.html#ab6fdcd06e06c892b3492eb6ea8f15be2" title="Whether type is bool.">drake::scalar_predicate&lt;T&gt;::is_bool</a> is <span class="tt">true</span>. For instance, validity checks are not performed when T is <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>.</dd>
<dd>
The methods of this class satisfy the "basic exception guarantee": if an exception is thrown, the program will still be in a valid state. Specifically, no resources are leaked, and all objects' invariants are intact. Be aware that <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class describes the mass distribution (inertia properties) of a body or composite body about a p...">RotationalInertia</a> objects may contain invalid inertia data in cases where input checking is skipped. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/language/exceptions">https://en.cppreference.com/w/cpp/language/exceptions</a></dd></dl>
<p>Various methods in this class require numerical (not symbolic) data types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/multibody/tree/rotational_inertia.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab3ffc4a4e197a2a2155641d75c2a7c49" id="r_ab3ffc4a4e197a2a2155641d75c2a7c49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3ffc4a4e197a2a2155641d75c2a7c49">RotationalInertia</a> ()</td></tr>
<tr class="memdesc:ab3ffc4a4e197a2a2155641d75c2a7c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a rotational inertia that has all its moments/products of inertia equal to NaN (helps quickly detect uninitialized values).  <br /></td></tr>
<tr class="memitem:af36dbdaa401764e4df48b07d3b6ad7d4" id="r_af36dbdaa401764e4df48b07d3b6ad7d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af36dbdaa401764e4df48b07d3b6ad7d4">RotationalInertia</a> (const T &amp;Ixx, const T &amp;Iyy, const T &amp;Izz)</td></tr>
<tr class="memdesc:af36dbdaa401764e4df48b07d3b6ad7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rotational inertia with moments of inertia <span class="tt">Ixx</span>, <span class="tt">Iyy</span>, <span class="tt">Izz</span>, and with each product of inertia set to zero.  <br /></td></tr>
<tr class="memitem:a319d6a0feeb306267605332cdd1906d6" id="r_a319d6a0feeb306267605332cdd1906d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a319d6a0feeb306267605332cdd1906d6">RotationalInertia</a> (const T &amp;Ixx, const T &amp;Iyy, const T &amp;Izz, const T &amp;Ixy, const T &amp;Ixz, const T &amp;Iyz)</td></tr>
<tr class="memdesc:a319d6a0feeb306267605332cdd1906d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rotational inertia with moments of inertia <span class="tt">Ixx</span>, <span class="tt">Iyy</span>, <span class="tt">Izz</span>, and with products of inertia <span class="tt">Ixy</span>, <span class="tt">Ixz</span>, <span class="tt">Iyz</span>.  <br /></td></tr>
<tr class="memitem:a73ee8d395f9f46a1086071be0faa8e37" id="r_a73ee8d395f9f46a1086071be0faa8e37"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73ee8d395f9f46a1086071be0faa8e37">RotationalInertia</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_PQ_E)</td></tr>
<tr class="memdesc:a73ee8d395f9f46a1086071be0faa8e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a rotational inertia for a particle Q of mass <span class="tt">mass</span>, whose position vector from about-point P is p_PQ_E (E is expressed-in frame).  <br /></td></tr>
<tr class="memitem:ad107abcacb84cbabb41b87ba81360f91" id="r_ad107abcacb84cbabb41b87ba81360f91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad107abcacb84cbabb41b87ba81360f91">rows</a> () const</td></tr>
<tr class="memdesc:ad107abcacb84cbabb41b87ba81360f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">For consistency with Eigen's API, the <a class="el" href="#ad107abcacb84cbabb41b87ba81360f91" title="For consistency with Eigen&#39;s API, the rows() method returns 3.">rows()</a> method returns 3.  <br /></td></tr>
<tr class="memitem:a8509d6f7951179378f848f5f4cc37720" id="r_a8509d6f7951179378f848f5f4cc37720"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8509d6f7951179378f848f5f4cc37720">cols</a> () const</td></tr>
<tr class="memdesc:a8509d6f7951179378f848f5f4cc37720"><td class="mdescLeft">&#160;</td><td class="mdescRight">For consistency with Eigen's API, the <a class="el" href="#a8509d6f7951179378f848f5f4cc37720" title="For consistency with Eigen&#39;s API, the cols() method returns 3.">cols()</a> method returns 3.  <br /></td></tr>
<tr class="memitem:a47eb03d10723e3f8e2bcf1c9cc5500e0" id="r_a47eb03d10723e3f8e2bcf1c9cc5500e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47eb03d10723e3f8e2bcf1c9cc5500e0">get_moments</a> () const</td></tr>
<tr class="memdesc:a47eb03d10723e3f8e2bcf1c9cc5500e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 3-element vector with moments of inertia [Ixx, Iyy, Izz].  <br /></td></tr>
<tr class="memitem:ac0b1ab3dbfcef595919f9217a544de26" id="r_ac0b1ab3dbfcef595919f9217a544de26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0b1ab3dbfcef595919f9217a544de26">get_products</a> () const</td></tr>
<tr class="memdesc:ac0b1ab3dbfcef595919f9217a544de26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 3-element vector with products of inertia [Ixy, Ixz, Iyz].  <br /></td></tr>
<tr class="memitem:a23798f37ae600d4d79b8a2e71586c4c7" id="r_a23798f37ae600d4d79b8a2e71586c4c7"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23798f37ae600d4d79b8a2e71586c4c7">Trace</a> () const</td></tr>
<tr class="memdesc:a23798f37ae600d4d79b8a2e71586c4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a rotational inertia's trace (i.e., Ixx + Iyy + Izz, the sum of the diagonal elements of the inertia matrix).  <br /></td></tr>
<tr class="memitem:a3751c9eaa974909523b6d8d3fd0833a8" id="r_a3751c9eaa974909523b6d8d3fd0833a8"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3751c9eaa974909523b6d8d3fd0833a8">CalcMaximumPossibleMomentOfInertia</a> () const</td></tr>
<tr class="memdesc:a3751c9eaa974909523b6d8d3fd0833a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum possible moment of inertia for <span class="tt">this</span> rotational inertia about-point P for any expressed-in frame E.  <br /></td></tr>
<tr class="memitem:a837c9ac223ddbd3ba4790e1ea4fbd93c" id="r_a837c9ac223ddbd3ba4790e1ea4fbd93c"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a837c9ac223ddbd3ba4790e1ea4fbd93c">operator()</a> (int i, int j) const</td></tr>
<tr class="memdesc:a837c9ac223ddbd3ba4790e1ea4fbd93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const access to the <span class="tt">(i, j)</span> element of this rotational inertia.  <br /></td></tr>
<tr class="memitem:a9d866667de353b810492a78b82f71c26" id="r_a9d866667de353b810492a78b82f71c26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d866667de353b810492a78b82f71c26">CopyToFullMatrix3</a> () const</td></tr>
<tr class="memdesc:a9d866667de353b810492a78b82f71c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a full 3x3 matrix copy of this rotational inertia.  <br /></td></tr>
<tr class="memitem:a165f795d78058b9eb89b0cb19819bb5e" id="r_a165f795d78058b9eb89b0cb19819bb5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a165f795d78058b9eb89b0cb19819bb5e">IsNearlyEqualTo</a> (const <a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a> &amp;other, double precision) const</td></tr>
<tr class="memdesc:a165f795d78058b9eb89b0cb19819bb5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <span class="tt">this</span> rotational inertia to <span class="tt">other</span> rotational inertia within the specified <span class="tt">precision</span> (which is a dimensionless number specifying the relative precision to which the comparison is performed).  <br /></td></tr>
<tr class="memitem:ac06b3cc96b498f9967fe4a66b19b9630" id="r_ac06b3cc96b498f9967fe4a66b19b9630"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac06b3cc96b498f9967fe4a66b19b9630">operator+=</a> (const <a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;I_BP_E)</td></tr>
<tr class="memdesc:ac06b3cc96b498f9967fe4a66b19b9630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a rotational inertia <span class="tt">I_BP_E</span> to <span class="tt">this</span> rotational inertia.  <br /></td></tr>
<tr class="memitem:afdfa5bfc70bb9a615044575eddfd6e8f" id="r_afdfa5bfc70bb9a615044575eddfd6e8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdfa5bfc70bb9a615044575eddfd6e8f">operator+</a> (const <a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;I_BP_E) const</td></tr>
<tr class="memdesc:afdfa5bfc70bb9a615044575eddfd6e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a rotational inertia <span class="tt">I_BP_E</span> to <span class="tt">this</span> rotational inertia.  <br /></td></tr>
<tr class="memitem:a3d318c572c1fd80006117f7009669459" id="r_a3d318c572c1fd80006117f7009669459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d318c572c1fd80006117f7009669459">operator-=</a> (const <a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;I_BP_E)</td></tr>
<tr class="memdesc:a3d318c572c1fd80006117f7009669459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a rotational inertia <span class="tt">I_BP_E</span> from <span class="tt">this</span> rotational inertia.  <br /></td></tr>
<tr class="memitem:a93a21673141f71de960703b9e25c4625" id="r_a93a21673141f71de960703b9e25c4625"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93a21673141f71de960703b9e25c4625">operator-</a> (const <a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;I_BP_E) const</td></tr>
<tr class="memdesc:a93a21673141f71de960703b9e25c4625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a rotational inertia <span class="tt">I_BP_E</span> from <span class="tt">this</span> rotational inertia.  <br /></td></tr>
<tr class="memitem:a7469d31bb79c3c18e0b08941d0469db5" id="r_a7469d31bb79c3c18e0b08941d0469db5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7469d31bb79c3c18e0b08941d0469db5">operator*=</a> (const T &amp;nonnegative_scalar)</td></tr>
<tr class="memdesc:a7469d31bb79c3c18e0b08941d0469db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <span class="tt">this</span> rotational inertia by a nonnegative scalar (&gt;= 0).  <br /></td></tr>
<tr class="memitem:a1275e13820b74540e4b013515e3a5e9a" id="r_a1275e13820b74540e4b013515e3a5e9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1275e13820b74540e4b013515e3a5e9a">operator*</a> (const T &amp;nonnegative_scalar) const</td></tr>
<tr class="memdesc:a1275e13820b74540e4b013515e3a5e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <span class="tt">this</span> rotational inertia by a nonnegative scalar (&gt;= 0).  <br /></td></tr>
<tr class="memitem:a803b4a22e6bb49af2293bae89606c9c6" id="r_a803b4a22e6bb49af2293bae89606c9c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a803b4a22e6bb49af2293bae89606c9c6">operator*</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;w_E) const</td></tr>
<tr class="memdesc:a803b4a22e6bb49af2293bae89606c9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <span class="tt">this</span> rotational inertia about-point P, expressed-in frame E by the vector w_E (which <em>must</em> also have the same expressed-in frame E).  <br /></td></tr>
<tr class="memitem:ae58060f6748438555963260559ec166f" id="r_ae58060f6748438555963260559ec166f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae58060f6748438555963260559ec166f">operator/=</a> (const T &amp;positive_scalar)</td></tr>
<tr class="memdesc:ae58060f6748438555963260559ec166f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides <span class="tt">this</span> rotational inertia by a positive scalar (&gt; 0).  <br /></td></tr>
<tr class="memitem:a8667afd6b8da13b652b1a60e1ef723a8" id="r_a8667afd6b8da13b652b1a60e1ef723a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8667afd6b8da13b652b1a60e1ef723a8">operator/</a> (const T &amp;positive_scalar) const</td></tr>
<tr class="memdesc:a8667afd6b8da13b652b1a60e1ef723a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides <span class="tt">this</span> rotational inertia by a positive scalar(&gt; 0).  <br /></td></tr>
<tr class="memitem:af50fb42c03039a2532fe3c6780983680" id="r_af50fb42c03039a2532fe3c6780983680"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af50fb42c03039a2532fe3c6780983680">MultiplyByScalarSkipValidityCheck</a> (const T &amp;s) const</td></tr>
<tr class="memdesc:af50fb42c03039a2532fe3c6780983680"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Multiplies a rotational inertia by a scalar.  <br /></td></tr>
<tr class="memitem:ae461fd75b1b4eba6c95a57621adb4e9d" id="r_ae461fd75b1b4eba6c95a57621adb4e9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae461fd75b1b4eba6c95a57621adb4e9d">SetToNaN</a> ()</td></tr>
<tr class="memdesc:ae461fd75b1b4eba6c95a57621adb4e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <span class="tt">this</span> rotational inertia so all its elements are equal to NaN.  <br /></td></tr>
<tr class="memitem:ae57e5aca5db002545e4b9335c8d9dbfa" id="r_ae57e5aca5db002545e4b9335c8d9dbfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae57e5aca5db002545e4b9335c8d9dbfa">SetZero</a> ()</td></tr>
<tr class="memdesc:ae57e5aca5db002545e4b9335c8d9dbfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <span class="tt">this</span> rotational inertia so all its moments/products of inertia are zero, e.g., for convenient initialization before a computation or for inertia calculations involving a particle (point-mass).  <br /></td></tr>
<tr class="memitem:acbac9e46d70cd5de4d831476fa75ff82" id="r_acbac9e46d70cd5de4d831476fa75ff82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbac9e46d70cd5de4d831476fa75ff82">IsFinite</a> () const</td></tr>
<tr class="memdesc:acbac9e46d70cd5de4d831476fa75ff82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all moments and products in <span class="tt">this</span> rotational inertia are finite (e.g., no NaNs or infinities), otherwise returns false.  <br /></td></tr>
<tr class="memitem:a6b40e1a3480c9c023c2a23ae76710e50" id="r_a6b40e1a3480c9c023c2a23ae76710e50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b40e1a3480c9c023c2a23ae76710e50">IsNaN</a> () const</td></tr>
<tr class="memdesc:a6b40e1a3480c9c023c2a23ae76710e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if any moment/product in <span class="tt">this</span> rotational inertia is NaN.  <br /></td></tr>
<tr class="memitem:ae83b964ad82fb77ed23768d94f3774e4" id="r_ae83b964ad82fb77ed23768d94f3774e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae83b964ad82fb77ed23768d94f3774e4">IsZero</a> () const</td></tr>
<tr class="memdesc:ae83b964ad82fb77ed23768d94f3774e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if all moments and products of inertia are exactly zero.  <br /></td></tr>
<tr class="memitem:a12c2f927bd3c5ffcc0bac4637904ddc9" id="r_a12c2f927bd3c5ffcc0bac4637904ddc9"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:a12c2f927bd3c5ffcc0bac4637904ddc9 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12c2f927bd3c5ffcc0bac4637904ddc9">cast</a> () const</td></tr>
<tr class="memdesc:a12c2f927bd3c5ffcc0bac4637904ddc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new RotationalInertia object templated on <span class="tt">Scalar</span> initialized from the values of <span class="tt">this</span> rotational inertia's entries.  <br /></td></tr>
<tr class="memitem:a10ddf088130a2bc850d0ea329692a097" id="r_a10ddf088130a2bc850d0ea329692a097"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10ddf088130a2bc850d0ea329692a097">CalcPrincipalMomentsOfInertia</a> () const</td></tr>
<tr class="memdesc:a10ddf088130a2bc850d0ea329692a097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the 3 principal moments of inertia for <span class="tt">this</span> rotational inertia.  <br /></td></tr>
<tr class="memitem:a6ccafd1dd3273464ee91e480a2c6abec" id="r_a6ccafd1dd3273464ee91e480a2c6abec"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; double &gt;, <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ccafd1dd3273464ee91e480a2c6abec">CalcPrincipalMomentsAndAxesOfInertia</a> () const</td></tr>
<tr class="memdesc:a6ccafd1dd3273464ee91e480a2c6abec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the 3 principal moments of inertia and their 3 associated principal directions for <span class="tt">this</span> rotational inertia.  <br /></td></tr>
<tr class="memitem:a3d0f677b6d05d13d285967b57e203f4b" id="r_a3d0f677b6d05d13d285967b57e203f4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d0f677b6d05d13d285967b57e203f4b">CouldBePhysicallyValid</a> () const</td></tr>
<tr class="memdesc:a3d0f677b6d05d13d285967b57e203f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs several checks to verify whether <span class="tt">this</span> rotational inertia <em>could</em> be physically valid, including:  <br /></td></tr>
<tr class="memitem:af397b4c3403d23ab61a128dbeaa1c3aa" id="r_af397b4c3403d23ab61a128dbeaa1c3aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af397b4c3403d23ab61a128dbeaa1c3aa">ReExpressInPlace</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;R_AE)</td></tr>
<tr class="memdesc:af397b4c3403d23ab61a128dbeaa1c3aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-expresses <span class="tt">this</span> rotational inertia <span class="tt">I_BP_E</span> in place to <span class="tt">I_BP_A</span>.  <br /></td></tr>
<tr class="memitem:a527deca4cbc51761000630fb372b7eb1" id="r_a527deca4cbc51761000630fb372b7eb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a527deca4cbc51761000630fb372b7eb1">ReExpress</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;R_AE) const</td></tr>
<tr class="memdesc:a527deca4cbc51761000630fb372b7eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-expresses <span class="tt">this</span> rotational inertia <span class="tt">I_BP_E</span> to <span class="tt">I_BP_A</span> i.e., re-expresses body B's rotational inertia from frame E to frame A.  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:a719e23ae8c26b0c8cf0c7f30dd112559" id="r_a719e23ae8c26b0c8cf0c7f30dd112559"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a719e23ae8c26b0c8cf0c7f30dd112559">RotationalInertia</a> (const RotationalInertia &amp;)=default</td></tr>
<tr class="memitem:a68e38e58f3ba84dd869e2371d65f6690" id="r_a68e38e58f3ba84dd869e2371d65f6690"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68e38e58f3ba84dd869e2371d65f6690">operator=</a> (const <a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a> &amp;)=default</td></tr>
<tr class="memitem:a87e215bccd4ce720b787f8b5195a7551" id="r_a87e215bccd4ce720b787f8b5195a7551"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87e215bccd4ce720b787f8b5195a7551">RotationalInertia</a> (RotationalInertia &amp;&amp;)=default</td></tr>
<tr class="memitem:a991044d177f307aee54d34d04bf6dc82" id="r_a991044d177f307aee54d34d04bf6dc82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a991044d177f307aee54d34d04bf6dc82">operator=</a> (<a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a> &amp;&amp;)=default</td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Shift methods</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>Each shift method shifts a body's rotational inertia from one about-point to another about-point.</p>
<p>The expressed-in frame is unchanged.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">In-place methods (<span class="tt">this</span> changes)  </th><th class="markdownTableHeadNone">Const methods  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ShiftFromCenterOfMassInPlace  </td><td class="markdownTableBodyNone">ShiftFromCenterOfMass  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ShiftToCenterOfMassInPlace  </td><td class="markdownTableBodyNone">ShiftToCenterOfMass  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ShiftToThenAwayFromCenterOfMassInPlace  </td><td class="markdownTableBodyNone">ShiftToThenAwayFromCenterOfMass  </td></tr>
</table>
</div></td></tr>
<tr class="memitem:aaad06162821520625a28e0526d698e87" id="r_aaad06162821520625a28e0526d698e87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaad06162821520625a28e0526d698e87">ShiftFromCenterOfMassInPlace</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_BcmQ_E)</td></tr>
<tr class="memdesc:aaad06162821520625a28e0526d698e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts <span class="tt">this</span> rotational inertia for a body (or composite body) B from about-point Bcm (B's center of mass) to about-point Q.  <br /></td></tr>
<tr class="memitem:a56317cf8991d1f8ab21f8a8b81a33340" id="r_a56317cf8991d1f8ab21f8a8b81a33340"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56317cf8991d1f8ab21f8a8b81a33340">ShiftFromCenterOfMass</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_BcmQ_E) const</td></tr>
<tr class="memdesc:a56317cf8991d1f8ab21f8a8b81a33340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rotational inertia that results from shifting <span class="tt">this</span> rotational inertia for a body (or composite body) B from about-point Bcm (B's center of mass) to about-point Q.  <br /></td></tr>
<tr class="memitem:af8ca1f1551b6a301c66903cee8db94d5" id="r_af8ca1f1551b6a301c66903cee8db94d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8ca1f1551b6a301c66903cee8db94d5">ShiftToCenterOfMassInPlace</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_QBcm_E)</td></tr>
<tr class="memdesc:af8ca1f1551b6a301c66903cee8db94d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts <span class="tt">this</span> rotational inertia for a body (or composite body) B from about-point Q to about-point <span class="tt">Bcm</span> (B's center of mass).  <br /></td></tr>
<tr class="memitem:a9a02657678fd4d5324b53a4923ad8c8f" id="r_a9a02657678fd4d5324b53a4923ad8c8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a02657678fd4d5324b53a4923ad8c8f">ShiftToCenterOfMass</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_QBcm_E) const</td></tr>
<tr class="memdesc:a9a02657678fd4d5324b53a4923ad8c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rotational inertia that results from shifting <span class="tt">this</span> rotational inertia for a body (or composite body) B from about-point Q to about-point <span class="tt">Bcm</span> (B's center of mass).  <br /></td></tr>
<tr class="memitem:ae531c9b24ec6c5cc94481a0231c331b7" id="r_ae531c9b24ec6c5cc94481a0231c331b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae531c9b24ec6c5cc94481a0231c331b7">ShiftToThenAwayFromCenterOfMassInPlace</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_PBcm_E, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_QBcm_E)</td></tr>
<tr class="memdesc:ae531c9b24ec6c5cc94481a0231c331b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts <span class="tt">this</span> rotational inertia for a body (or composite body) B from about-point P to about-point Q via Bcm (B's center of mass).  <br /></td></tr>
<tr class="memitem:a55b84836d8b7e4e0ec1c3455ab0ade9c" id="r_a55b84836d8b7e4e0ec1c3455ab0ade9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55b84836d8b7e4e0ec1c3455ab0ade9c">ShiftToThenAwayFromCenterOfMass</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_PBcm_E, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_QBcm_E) const</td></tr>
<tr class="memdesc:a55b84836d8b7e4e0ec1c3455ab0ade9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rotational inertia that results from shifting <span class="tt">this</span> rotational inertia for a body (or composite body) B from about-point P to about-point Q via Bcm (B's center of mass).  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afbaf4c2e50e429fd52f2d91eb32c20b1" id="r_afbaf4c2e50e429fd52f2d91eb32c20b1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbaf4c2e50e429fd52f2d91eb32c20b1">TriaxiallySymmetric</a> (const T &amp;I_triaxial)</td></tr>
<tr class="memdesc:afbaf4c2e50e429fd52f2d91eb32c20b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a rotational inertia with equal moments of inertia along its diagonal and with each product of inertia set to zero.  <br /></td></tr>
<tr class="memitem:a95b3ed85676656a8ce5f46ebf59bd2cc" id="r_a95b3ed85676656a8ce5f46ebf59bd2cc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95b3ed85676656a8ce5f46ebf59bd2cc">MakeFromMomentsAndProductsOfInertia</a> (const T &amp;Ixx, const T &amp;Iyy, const T &amp;Izz, const T &amp;Ixy, const T &amp;Ixz, const T &amp;Iyz, bool skip_validity_check=false)</td></tr>
<tr class="memdesc:a95b3ed85676656a8ce5f46ebf59bd2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Creates a rotational inertia with moments of inertia Ixx, Iyy, Izz, and with products of inertia Ixy, Ixz, Iyz.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-methods" class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aeb144bbd1889973bd7e968bb9d3eba4f" id="r_aeb144bbd1889973bd7e968bb9d3eba4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb144bbd1889973bd7e968bb9d3eba4f">MinusEqualsUnchecked</a> (const <a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;I_BP_E)</td></tr>
<tr class="memdesc:aeb144bbd1889973bd7e968bb9d3eba4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a rotational inertia <span class="tt">I_BP_E</span> from <span class="tt">this</span> rotational inertia.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-friends" class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a82936d10a31afe3ae91f3025a39d3224" id="r_a82936d10a31afe3ae91f3025a39d3224"><td class="memTemplParams" colspan="2">template&lt;typename&gt; </td></tr>
<tr class="memitem:a82936d10a31afe3ae91f3025a39d3224 template"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a></td></tr>
<tr class="memitem:ab17d9c09a9350b0a4e0ce60a6d62eeeb" id="r_ab17d9c09a9350b0a4e0ce60a6d62eeeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab17d9c09a9350b0a4e0ce60a6d62eeeb">operator*</a> (const T &amp;nonnegative_scalar, const <a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;I_BP_E)</td></tr>
<tr class="memdesc:ab17d9c09a9350b0a4e0ce60a6d62eeeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a nonnegative scalar (&gt;= 0) by the rotational inertia <span class="tt">I_BP_E</span>.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-related" class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:ac917bf1dfed2a1cfe26be9d258285a2d" id="r_ac917bf1dfed2a1cfe26be9d258285a2d"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ac917bf1dfed2a1cfe26be9d258285a2d template"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac917bf1dfed2a1cfe26be9d258285a2d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;I)</td></tr>
<tr class="memdesc:ac917bf1dfed2a1cfe26be9d258285a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an instance of <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class describes the mass distribution (inertia properties) of a body or composite body about a p...">RotationalInertia</a> into a std::ostream.  <br /></td></tr>
<tr class="memitem:ae863ba45d3a764d9fcfc77df2e070335" id="r_ae863ba45d3a764d9fcfc77df2e070335"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ae863ba45d3a764d9fcfc77df2e070335 template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae863ba45d3a764d9fcfc77df2e070335">to_string</a> (const <a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;I)</td></tr>
<tr class="memdesc:ae863ba45d3a764d9fcfc77df2e070335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string representation of a <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class describes the mass distribution (inertia properties) of a body or composite body about a p...">RotationalInertia</a> object.  <br /></td></tr>
</table>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a719e23ae8c26b0c8cf0c7f30dd112559" name="a719e23ae8c26b0c8cf0c7f30dd112559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719e23ae8c26b0c8cf0c7f30dd112559">&#9670;&#160;</a></span>RotationalInertia() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RotationalInertia </td>
          <td>(</td>
          <td class="paramtype">const RotationalInertia&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a87e215bccd4ce720b787f8b5195a7551" name="a87e215bccd4ce720b787f8b5195a7551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e215bccd4ce720b787f8b5195a7551">&#9670;&#160;</a></span>RotationalInertia() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RotationalInertia </td>
          <td>(</td>
          <td class="paramtype">RotationalInertia&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3ffc4a4e197a2a2155641d75c2a7c49" name="ab3ffc4a4e197a2a2155641d75c2a7c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ffc4a4e197a2a2155641d75c2a7c49">&#9670;&#160;</a></span>RotationalInertia() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RotationalInertia </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a rotational inertia that has all its moments/products of inertia equal to NaN (helps quickly detect uninitialized values). </p>

</div>
</div>
<a id="af36dbdaa401764e4df48b07d3b6ad7d4" name="af36dbdaa401764e4df48b07d3b6ad7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36dbdaa401764e4df48b07d3b6ad7d4">&#9670;&#160;</a></span>RotationalInertia() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RotationalInertia </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>Ixx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>Iyy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>Izz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a rotational inertia with moments of inertia <span class="tt">Ixx</span>, <span class="tt">Iyy</span>, <span class="tt">Izz</span>, and with each product of inertia set to zero. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if not <a class="el" href="#a3d0f677b6d05d13d285967b57e203f4b" title="Performs several checks to verify whether this rotational inertia could be physically valid,...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a319d6a0feeb306267605332cdd1906d6" name="a319d6a0feeb306267605332cdd1906d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319d6a0feeb306267605332cdd1906d6">&#9670;&#160;</a></span>RotationalInertia() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RotationalInertia </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>Ixx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>Iyy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>Izz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>Ixy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>Ixz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>Iyz</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a rotational inertia with moments of inertia <span class="tt">Ixx</span>, <span class="tt">Iyy</span>, <span class="tt">Izz</span>, and with products of inertia <span class="tt">Ixy</span>, <span class="tt">Ixz</span>, <span class="tt">Iyz</span>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if not <a class="el" href="#a3d0f677b6d05d13d285967b57e203f4b" title="Performs several checks to verify whether this rotational inertia could be physically valid,...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73ee8d395f9f46a1086071be0faa8e37" name="a73ee8d395f9f46a1086071be0faa8e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ee8d395f9f46a1086071be0faa8e37">&#9670;&#160;</a></span>RotationalInertia() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RotationalInertia </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>mass</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_PQ_E</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a rotational inertia for a particle Q of mass <span class="tt">mass</span>, whose position vector from about-point P is p_PQ_E (E is expressed-in frame). </p>
<p>This std::logic_error exception only occurs if <span class="tt">mass</span> &lt; 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mass</td><td>The mass of particle Q. </td></tr>
    <tr><td class="paramname">p_PQ_E</td><td>Position from about-point P to Q, expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">I_QP_E,Q's</td><td>rotational inertia about-point P expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Negating the position vector p_PQ_E has no affect on the result. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if not <a class="el" href="#a3d0f677b6d05d13d285967b57e203f4b" title="Performs several checks to verify whether this rotational inertia could be physically valid,...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a3751c9eaa974909523b6d8d3fd0833a8" name="a3751c9eaa974909523b6d8d3fd0833a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3751c9eaa974909523b6d8d3fd0833a8">&#9670;&#160;</a></span>CalcMaximumPossibleMomentOfInertia()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T CalcMaximumPossibleMomentOfInertia </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum possible moment of inertia for <span class="tt">this</span> rotational inertia about-point P for any expressed-in frame E. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The maximum moment Imax has range: trace / 3 &lt;= Imax &lt;= trace / 2. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a23798f37ae600d4d79b8a2e71586c4c7" title="Returns a rotational inertia&#39;s trace (i.e., Ixx + Iyy + Izz, the sum of the diagonal elements of the ...">Trace()</a> </dd></dl>

</div>
</div>
<a id="a6ccafd1dd3273464ee91e480a2c6abec" name="a6ccafd1dd3273464ee91e480a2c6abec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ccafd1dd3273464ee91e480a2c6abec">&#9670;&#160;</a></span>CalcPrincipalMomentsAndAxesOfInertia()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; double &gt;, <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; double &gt; &gt; CalcPrincipalMomentsAndAxesOfInertia </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forms the 3 principal moments of inertia and their 3 associated principal directions for <span class="tt">this</span> rotational inertia. </p>
<dl class="section return"><dt>Returns</dt><dd>3 principal moments of inertia [Ixx Iyy Izz], sorted in ascending order (Ixx â‰¤ Iyy â‰¤ Izz) and a rotation matrix R_EA whose columns are the 3 associated principal directions that relate the expressed-in frame E to a frame A, where frame E is the expressed-in frame for <span class="tt">this</span> rotational inertia I_BP_E (body B's rotational inertia about-point P) and frame A contains right-handed orthonormal vectors Ax, Ay, Az. The 1Ë¢áµ— column of R_EA is Ax_E (Ax expressed in frame E) which is parallel to the principal axis associated with Ixx (the smallest principal moment of inertia). Similarly, the 2â¿áµˆ and 3Ê³áµˆ columns of R_EA are Ay_E and Az_E, which are parallel to principal axes associated with Iyy and Izz (the intermediate and largest principal moments of inertia). If all principal moments of inertia are equal (i.e., Ixx = Iyy = Izz), R_EA is the identity matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the elements of <span class="tt">this</span> rotational inertia cannot be converted to a real finite double. For example, an exception is thrown if <span class="tt">this</span> contains an erroneous NaN or if scalar type T is symbolic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a10ddf088130a2bc850d0ea329692a097" title="Forms the 3 principal moments of inertia for this rotational inertia.">CalcPrincipalMomentsOfInertia()</a> to calculate the principal moments of inertia [Ixx Iyy Izz], without calculating the principal directions. </dd></dl>

</div>
</div>
<a id="a10ddf088130a2bc850d0ea329692a097" name="a10ddf088130a2bc850d0ea329692a097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ddf088130a2bc850d0ea329692a097">&#9670;&#160;</a></span>CalcPrincipalMomentsOfInertia()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; double &gt; CalcPrincipalMomentsOfInertia </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forms the 3 principal moments of inertia for <span class="tt">this</span> rotational inertia. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>3 principal moments of inertia [Imin Imed Imax], sorted in ascending order (Imin â‰¤ Imed â‰¤ Imax). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the elements of <span class="tt">this</span> rotational inertia cannot be converted to a real finite double. For example, an exception is thrown if <span class="tt">this</span> contains an erroneous NaN or if scalar type T is symbolic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a6ccafd1dd3273464ee91e480a2c6abec" title="Forms the 3 principal moments of inertia and their 3 associated principal directions for this rotatio...">CalcPrincipalMomentsAndAxesOfInertia()</a> to also calculate principal moment of inertia directions associated with <span class="tt">this</span> rotational inertia. </dd></dl>

</div>
</div>
<a id="a12c2f927bd3c5ffcc0bac4637904ddc9" name="a12c2f927bd3c5ffcc0bac4637904ddc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c2f927bd3c5ffcc0bac4637904ddc9">&#9670;&#160;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; Scalar &gt; cast </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new RotationalInertia object templated on <span class="tt">Scalar</span> initialized from the values of <span class="tt">this</span> rotational inertia's entries. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type on which the new rotational inertia will be templated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><span class="tt"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class describes the mass distribution (inertia properties) of a body or composite body about a p...">RotationalInertia</a>&lt;From&gt;::<a class="el" href="#a12c2f927bd3c5ffcc0bac4637904ddc9" title="Returns a new RotationalInertia object templated on Scalar initialized from the values of this rotati...">cast</a>&lt;To&gt;()</span> creates a new <span class="tt"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class describes the mass distribution (inertia properties) of a body or composite body about a p...">RotationalInertia</a>&lt;To&gt;</span> from a <span class="tt"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class describes the mass distribution (inertia properties) of a body or composite body about a p...">RotationalInertia</a>&lt;From&gt;</span> but only if type <span class="tt">To</span> is constructible from type <span class="tt">From</span>. This cast method works in accordance with Eigen's cast method for Eigen's Matrix3 that underlies this RotationalInertia. For example, Eigen currently allows cast from type double to <a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854" title="A scalar type that performs automatic differentiation.">AutoDiffXd</a>, but not vice-versa. </dd></dl>

</div>
</div>
<a id="a8509d6f7951179378f848f5f4cc37720" name="a8509d6f7951179378f848f5f4cc37720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8509d6f7951179378f848f5f4cc37720">&#9670;&#160;</a></span>cols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int cols </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For consistency with Eigen's API, the <a class="el" href="#a8509d6f7951179378f848f5f4cc37720" title="For consistency with Eigen&#39;s API, the cols() method returns 3.">cols()</a> method returns 3. </p>

</div>
</div>
<a id="a9d866667de353b810492a78b82f71c26" name="a9d866667de353b810492a78b82f71c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d866667de353b810492a78b82f71c26">&#9670;&#160;</a></span>CopyToFullMatrix3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt; CopyToFullMatrix3 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a full 3x3 matrix copy of this rotational inertia. </p>
<p>The returned copy is symmetric and includes both lower and upper parts of the matrix. </p>

</div>
</div>
<a id="a3d0f677b6d05d13d285967b57e203f4b" name="a3d0f677b6d05d13d285967b57e203f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0f677b6d05d13d285967b57e203f4b">&#9670;&#160;</a></span>CouldBePhysicallyValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt; CouldBePhysicallyValid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs several checks to verify whether <span class="tt">this</span> rotational inertia <em>could</em> be physically valid, including: </p>
<ul>
<li>No NaN moments or products of inertia.</li>
<li>Ixx, Iyy, Izz and principal moments are all non-negative.</li>
<li>Ixx, Iyy Izz and principal moments satisfy the triangle inequality:<ul>
<li><span class="tt">Ixx + Iyy â‰¥ Izz</span></li>
<li><span class="tt">Ixx + Izz â‰¥ Iyy</span></li>
<li><span class="tt">Iyy + Izz â‰¥ Ixx</span></li>
</ul>
</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>These checks are necessary (but NOT sufficient) conditions for a rotational inertia to be physically valid. The sufficient condition requires a rotational inertia to satisfy the above checks <em>after</em> <span class="tt">this</span> is shifted to the center of mass, i.e., the sufficient condition requires calling <a class="el" href="#a3d0f677b6d05d13d285967b57e203f4b" title="Performs several checks to verify whether this rotational inertia could be physically valid,...">CouldBePhysicallyValid()</a> when the about-point is Bcm (the body's center of mass). Note: this class does not know its about-point or its center of mass location.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> for a plausible rotational inertia passing the above necessary but insufficient checks and <span class="tt">false</span> otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if principal moments of inertia cannot be calculated (eigenvalue solver) or if scalar type T cannot be converted to a double. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47eb03d10723e3f8e2bcf1c9cc5500e0" name="a47eb03d10723e3f8e2bcf1c9cc5500e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47eb03d10723e3f8e2bcf1c9cc5500e0">&#9670;&#160;</a></span>get_moments()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; get_moments </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns 3-element vector with moments of inertia [Ixx, Iyy, Izz]. </p>

</div>
</div>
<a id="ac0b1ab3dbfcef595919f9217a544de26" name="ac0b1ab3dbfcef595919f9217a544de26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b1ab3dbfcef595919f9217a544de26">&#9670;&#160;</a></span>get_products()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; get_products </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns 3-element vector with products of inertia [Ixy, Ixz, Iyz]. </p>

</div>
</div>
<a id="acbac9e46d70cd5de4d831476fa75ff82" name="acbac9e46d70cd5de4d831476fa75ff82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbac9e46d70cd5de4d831476fa75ff82">&#9670;&#160;</a></span>IsFinite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt; IsFinite </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if all moments and products in <span class="tt">this</span> rotational inertia are finite (e.g., no NaNs or infinities), otherwise returns false. </p>

</div>
</div>
<a id="a6b40e1a3480c9c023c2a23ae76710e50" name="a6b40e1a3480c9c023c2a23ae76710e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b40e1a3480c9c023c2a23ae76710e50">&#9670;&#160;</a></span>IsNaN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt; IsNaN </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if any moment/product in <span class="tt">this</span> rotational inertia is NaN. </p>
<p>Otherwise returns <span class="tt">false</span>. </p>

</div>
</div>
<a id="a165f795d78058b9eb89b0cb19819bb5e" name="a165f795d78058b9eb89b0cb19819bb5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a165f795d78058b9eb89b0cb19819bb5e">&#9670;&#160;</a></span>IsNearlyEqualTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt; IsNearlyEqualTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>precision</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares <span class="tt">this</span> rotational inertia to <span class="tt">other</span> rotational inertia within the specified <span class="tt">precision</span> (which is a dimensionless number specifying the relative precision to which the comparison is performed). </p>
<p>Denoting <span class="tt">I_maxA</span> as the largest element value that can appear in a valid <span class="tt">this</span> rotational inertia (independent of the expressed-in frame E) and denoting <span class="tt">I_maxB</span> as the largest element value that can appear in a valid <span class="tt">other</span> rotational inertia (independent of the expressed-in frame E), <span class="tt">this</span> and <span class="tt">other</span> are considered nearly equal to each other, if: â€–this - otherâ€–âˆ &lt; precision * min(I_maxA, I_maxB)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Rotational inertia to compare with <span class="tt">this</span> rotational inertia. </td></tr>
    <tr><td class="paramname">precision</td><td>is a dimensionless real positive number that is usually based on two factors, namely expected accuracy of moments/products of inertia (e.g., from end-user or CAD) and/or machine-precision. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the absolute value of each moment/product of inertia in <span class="tt">this</span> is within <span class="tt">epsilon</span> of the corresponding moment/ product absolute value in <span class="tt">other</span>. Otherwise returns <span class="tt">false</span>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>: This method only works if all moments of inertia with scalar type T in <span class="tt">this</span> and <span class="tt">other</span> can be converted to a double (discarding supplemental scalar data such as derivatives of an <a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854" title="A scalar type that performs automatic differentiation.">AutoDiffXd</a>). It fails at runtime if type T cannot be converted to <span class="tt">double</span>. </dd></dl>

</div>
</div>
<a id="ae83b964ad82fb77ed23768d94f3774e4" name="ae83b964ad82fb77ed23768d94f3774e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae83b964ad82fb77ed23768d94f3774e4">&#9670;&#160;</a></span>IsZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt; IsZero </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if all moments and products of inertia are exactly zero. </p>

</div>
</div>
<a id="a95b3ed85676656a8ce5f46ebf59bd2cc" name="a95b3ed85676656a8ce5f46ebf59bd2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b3ed85676656a8ce5f46ebf59bd2cc">&#9670;&#160;</a></span>MakeFromMomentsAndProductsOfInertia()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; MakeFromMomentsAndProductsOfInertia </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>Ixx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>Iyy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>Izz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>Ixy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>Ixz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>Iyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>skip_validity_check</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Internal use only) Creates a rotational inertia with moments of inertia Ixx, Iyy, Izz, and with products of inertia Ixy, Ixz, Iyz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Ixx,Iyy,Izz</td><td>Moments of inertia. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ixy,Ixz,Iyz</td><td>Products of inertia. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">skip_validity_check</td><td>If set to false, the rotational inertia is checked via <a class="el" href="#a3d0f677b6d05d13d285967b57e203f4b" title="Performs several checks to verify whether this rotational inertia could be physically valid,...">CouldBePhysicallyValid()</a> to ensure it is physically valid. If set to true (not generally recommended), the check is skipped (which reduces some computational cost). The default value is false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if skip_validity_check is false and <a class="el" href="#a3d0f677b6d05d13d285967b57e203f4b" title="Performs several checks to verify whether this rotational inertia could be physically valid,...">CouldBePhysicallyValid()</a> fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb144bbd1889973bd7e968bb9d3eba4f" name="aeb144bbd1889973bd7e968bb9d3eba4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb144bbd1889973bd7e968bb9d3eba4f">&#9670;&#160;</a></span>MinusEqualsUnchecked()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp; MinusEqualsUnchecked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>I_BP_E</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts a rotational inertia <span class="tt">I_BP_E</span> from <span class="tt">this</span> rotational inertia. </p>
<p>No check is done to determine if the result is physically valid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I_BP_E</td><td>Rotational inertia of a body (or composite body) B to be subtracted from <span class="tt">this</span> rotational inertia. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <span class="tt">this</span> rotational inertia. <span class="tt">this</span> changes since rotational inertia <span class="tt">I_BP_E</span> has been subtracted from it. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a93a21673141f71de960703b9e25c4625" title="Subtracts a rotational inertia I_BP_E from this rotational inertia.">operator-()</a>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This operator may produce an invalid rotational inertia. Use <a class="el" href="#a3d318c572c1fd80006117f7009669459" title="Subtracts a rotational inertia I_BP_E from this rotational inertia.">operator-=()</a> to perform necessary (but insufficient) checks on the physical validity of the resulting rotational inertia. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>: Although this method is mathematically useful, it may result in a rotational inertia that is physically invalid. This method helps perform intermediate calculations which do not necessarily represent a real rotational inertia. For example, an efficient way to shift a rotational inertia from an arbitrary point P to an arbitrary point Q is mathematical equivalent to a + (b - c). Although <span class="tt">a</span> must be physically valid and the result <span class="tt">a + (b - c)</span> must be physically valid, the intermediate quantity (b - c) is not necessarily physically valid. This method allows (b - c) to be calculated without requiring (b - c) to be physically valid. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3d318c572c1fd80006117f7009669459" title="Subtracts a rotational inertia I_BP_E from this rotational inertia.">operator-=()</a>. </dd></dl>

</div>
</div>
<a id="af50fb42c03039a2532fe3c6780983680" name="af50fb42c03039a2532fe3c6780983680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af50fb42c03039a2532fe3c6780983680">&#9670;&#160;</a></span>MultiplyByScalarSkipValidityCheck()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; MultiplyByScalarSkipValidityCheck </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Multiplies a rotational inertia by a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Scalar which multiplies <span class="tt">this</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">this</span> rotational inertia multiplied by <span class="tt">s</span>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ab17d9c09a9350b0a4e0ce60a6d62eeeb" title="Multiplies a nonnegative scalar (&gt;= 0) by the rotational inertia I_BP_E.">operator*(const T&amp;, const RotationalInertia&lt;T&gt;&amp;)</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method works even if <span class="tt">s</span> is negative or <span class="tt">this</span> is invalid. This method is useful for error messages associated with an invalid inertia. </dd></dl>

</div>
</div>
<a id="a837c9ac223ddbd3ba4790e1ea4fbd93c" name="a837c9ac223ddbd3ba4790e1ea4fbd93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837c9ac223ddbd3ba4790e1ea4fbd93c">&#9670;&#160;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; operator() </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const access to the <span class="tt">(i, j)</span> element of this rotational inertia. </p>
<dl class="section remark"><dt>Remarks</dt><dd>A mutable version of operator() is intentionally absent so as to prevent an end-user from directly setting elements. This prevents the creation of a non-physical (or non-symmetric) rotational inertia. </dd></dl>

</div>
</div>
<a id="a1275e13820b74540e4b013515e3a5e9a" name="a1275e13820b74540e4b013515e3a5e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1275e13820b74540e4b013515e3a5e9a">&#9670;&#160;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>nonnegative_scalar</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies <span class="tt">this</span> rotational inertia by a nonnegative scalar (&gt;= 0). </p>
<p>In debug builds, throws std::exception if <span class="tt">nonnegative_scalar</span> &lt; 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nonnegative_scalar</td><td>Nonnegative scalar which multiplies <span class="tt">this</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">this</span> rotational inertia multiplied by <span class="tt">nonnegative_scalar</span>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7469d31bb79c3c18e0b08941d0469db5" title="Multiplies this rotational inertia by a nonnegative scalar (&gt;= 0).">operator*=()</a>, <a class="el" href="#ab17d9c09a9350b0a4e0ce60a6d62eeeb" title="Multiplies a nonnegative scalar (&gt;= 0) by the rotational inertia I_BP_E.">operator*(const T&amp;, const RotationalInertia&lt;T&gt;&amp;)</a> </dd></dl>

</div>
</div>
<a id="a803b4a22e6bb49af2293bae89606c9c6" name="a803b4a22e6bb49af2293bae89606c9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803b4a22e6bb49af2293bae89606c9c6">&#9670;&#160;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>w_E</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies <span class="tt">this</span> rotational inertia about-point P, expressed-in frame E by the vector w_E (which <em>must</em> also have the same expressed-in frame E). </p>
<dl class="section note"><dt>Note</dt><dd>This calculation is equivalent to regarding <span class="tt">this</span> rotational inertia as an inertia dyadic and dot-multiplying it by w_E. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w_E</td><td><a class="el" href="namespacedrake.html#a01ae662d5635b7c9efe03d15d976f7a8" title="A column vector templated on the number of rows.">Vector</a> to post-multiply with <span class="tt">this</span> rotational inertia. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="namespacedrake.html#a01ae662d5635b7c9efe03d15d976f7a8" title="A column vector templated on the number of rows.">Vector</a> that results from multiplying <span class="tt">this</span> by <span class="tt">w_E</span>. </dd></dl>

</div>
</div>
<a id="a7469d31bb79c3c18e0b08941d0469db5" name="a7469d31bb79c3c18e0b08941d0469db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7469d31bb79c3c18e0b08941d0469db5">&#9670;&#160;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>nonnegative_scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies <span class="tt">this</span> rotational inertia by a nonnegative scalar (&gt;= 0). </p>
<p>In debug builds, throws std::exception if <span class="tt">nonnegative_scalar</span> &lt; 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nonnegative_scalar</td><td>Nonnegative scalar which multiplies <span class="tt">this</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <span class="tt">this</span> rotational inertia. <span class="tt">this</span> changes since <span class="tt">this</span> has been multiplied by <span class="tt">nonnegative_scalar</span>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1275e13820b74540e4b013515e3a5e9a" title="Multiplies this rotational inertia by a nonnegative scalar (&gt;= 0).">operator*()</a>, <a class="el" href="#ab17d9c09a9350b0a4e0ce60a6d62eeeb" title="Multiplies a nonnegative scalar (&gt;= 0) by the rotational inertia I_BP_E.">operator*(const T&amp;, const RotationalInertia&lt;T&gt;&amp;)</a>. </dd></dl>

</div>
</div>
<a id="afdfa5bfc70bb9a615044575eddfd6e8f" name="afdfa5bfc70bb9a615044575eddfd6e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdfa5bfc70bb9a615044575eddfd6e8f">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>I_BP_E</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a rotational inertia <span class="tt">I_BP_E</span> to <span class="tt">this</span> rotational inertia. </p>
<p>This method requires both rotational inertias (<span class="tt">I_BP_E</span> and <span class="tt">this</span>) to have the same about-point P and the same expressed-in frame E. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I_BP_E</td><td>Rotational inertia of a body (or composite body) B to be added to <span class="tt">this</span> rotational inertia. <span class="tt">I_BP_E</span> and <span class="tt">this</span> must have the same about-point P and expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of <span class="tt">this</span> rotational inertia and <span class="tt">I_BP_E</span>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac06b3cc96b498f9967fe4a66b19b9630" title="Adds a rotational inertia I_BP_E to this rotational inertia.">operator+=()</a>. </dd></dl>

</div>
</div>
<a id="ac06b3cc96b498f9967fe4a66b19b9630" name="ac06b3cc96b498f9967fe4a66b19b9630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac06b3cc96b498f9967fe4a66b19b9630">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>I_BP_E</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a rotational inertia <span class="tt">I_BP_E</span> to <span class="tt">this</span> rotational inertia. </p>
<p>This method requires both rotational inertias (<span class="tt">I_BP_E</span> and <span class="tt">this</span>) to have the same about-point P and the same expressed-in frame E. The += operator updates <span class="tt">this</span> so <span class="tt">I_BP_E</span> is added to <span class="tt">this</span>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I_BP_E</td><td>Rotational inertia of a body (or composite body) B to be added to <span class="tt">this</span> rotational inertia. <span class="tt">I_BP_E</span> and <span class="tt">this</span> must have the same about-point P and expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <span class="tt">this</span> rotational inertia. <span class="tt">this</span> changes since rotational inertia <span class="tt">I_BP_E</span> has been added to it. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#afdfa5bfc70bb9a615044575eddfd6e8f" title="Adds a rotational inertia I_BP_E to this rotational inertia.">operator+()</a>. </dd></dl>

</div>
</div>
<a id="a93a21673141f71de960703b9e25c4625" name="a93a21673141f71de960703b9e25c4625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a21673141f71de960703b9e25c4625">&#9670;&#160;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>I_BP_E</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts a rotational inertia <span class="tt">I_BP_E</span> from <span class="tt">this</span> rotational inertia. </p>
<p>This method requires both rotational inertias (<span class="tt">I_BP_E</span> and <span class="tt">this</span>) to have the same about-point P and the same expressed-in frame E. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I_BP_E</td><td>Rotational inertia of a body (or composite body) B to be subtracted from <span class="tt">this</span> rotational inertia. <span class="tt">I_BP_E</span> and <span class="tt">this</span> must have the same about-point P and expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The subtraction of <span class="tt">I_BP_E</span> from <span class="tt">this</span> rotational inertia. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if not <a class="el" href="#a3d0f677b6d05d13d285967b57e203f4b" title="Performs several checks to verify whether this rotational inertia could be physically valid,...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3d318c572c1fd80006117f7009669459" title="Subtracts a rotational inertia I_BP_E from this rotational inertia.">operator-=()</a>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>See warning and documentation for <a class="el" href="#a3d318c572c1fd80006117f7009669459" title="Subtracts a rotational inertia I_BP_E from this rotational inertia.">operator-=()</a>. </dd></dl>

</div>
</div>
<a id="a3d318c572c1fd80006117f7009669459" name="a3d318c572c1fd80006117f7009669459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d318c572c1fd80006117f7009669459">&#9670;&#160;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>I_BP_E</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts a rotational inertia <span class="tt">I_BP_E</span> from <span class="tt">this</span> rotational inertia. </p>
<p>This method requires both rotational inertias (<span class="tt">I_BP_E</span> and <span class="tt">this</span>) to have the same about-point P and the same expressed-in frame E. The -= operator updates <span class="tt">this</span> so <span class="tt">I_BP_E</span> is subtracted from <span class="tt">this</span>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I_BP_E</td><td>Rotational inertia of a body (or composite body) B to be subtracted from <span class="tt">this</span> rotational inertia. <span class="tt">I_BP_E</span> and <span class="tt">this</span> must have the same about-point P and expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <span class="tt">this</span> rotational inertia. <span class="tt">this</span> changes since rotational inertia <span class="tt">I_BP_E</span> has been subtracted from it. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if not <a class="el" href="#a3d0f677b6d05d13d285967b57e203f4b" title="Performs several checks to verify whether this rotational inertia could be physically valid,...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a93a21673141f71de960703b9e25c4625" title="Subtracts a rotational inertia I_BP_E from this rotational inertia.">operator-()</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This subtract operator is useful for computing rotational inertia of a body with a hole. First the rotational inertia of a fully solid body S (without the hole) is calculated, then the rotational inertia of the hole (treated as a massive solid body B) is calculated. The rotational inertia of a composite body C (comprised of S and -B) is computed by subtracting B's rotational inertia from S's rotational inertia. </dd></dl>

</div>
</div>
<a id="a8667afd6b8da13b652b1a60e1ef723a8" name="a8667afd6b8da13b652b1a60e1ef723a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8667afd6b8da13b652b1a60e1ef723a8">&#9670;&#160;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>positive_scalar</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides <span class="tt">this</span> rotational inertia by a positive scalar(&gt; 0). </p>
<p>In debug builds, throws std::exception if <span class="tt">positive_scalar</span> &lt;= 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positive_scalar</td><td>Positive scalar (&gt; 0) which divides <span class="tt">this</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">this</span> rotational inertia divided by <span class="tt">positive_scalar</span>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae58060f6748438555963260559ec166f" title="Divides this rotational inertia by a positive scalar (&gt; 0).">operator/=()</a>. </dd></dl>

</div>
</div>
<a id="ae58060f6748438555963260559ec166f" name="ae58060f6748438555963260559ec166f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58060f6748438555963260559ec166f">&#9670;&#160;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>positive_scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides <span class="tt">this</span> rotational inertia by a positive scalar (&gt; 0). </p>
<p>In debug builds, throws std::exception if <span class="tt">positive_scalar</span> &lt;= 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positive_scalar</td><td>Positive scalar (&gt; 0) which divides <span class="tt">this</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <span class="tt">this</span> rotational inertia. <span class="tt">this</span> changes since <span class="tt">this</span> has been divided by <span class="tt">positive_scalar</span>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8667afd6b8da13b652b1a60e1ef723a8" title="Divides this rotational inertia by a positive scalar(&gt; 0).">operator/()</a>. </dd></dl>

</div>
</div>
<a id="a68e38e58f3ba84dd869e2371d65f6690" name="a68e38e58f3ba84dd869e2371d65f6690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e38e58f3ba84dd869e2371d65f6690">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a991044d177f307aee54d34d04bf6dc82" name="a991044d177f307aee54d34d04bf6dc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991044d177f307aee54d34d04bf6dc82">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a527deca4cbc51761000630fb372b7eb1" name="a527deca4cbc51761000630fb372b7eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527deca4cbc51761000630fb372b7eb1">&#9670;&#160;</a></span>ReExpress()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; ReExpress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R_AE</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-expresses <span class="tt">this</span> rotational inertia <span class="tt">I_BP_E</span> to <span class="tt">I_BP_A</span> i.e., re-expresses body B's rotational inertia from frame E to frame A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R_AE</td><td>RotationMatrix relating frames A and E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">I_BP_A</td><td>Rotational inertia of B about-point P expressed-in frame A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if the rotational inertia that is re-expressed-in frame A violates <a class="el" href="#a3d0f677b6d05d13d285967b57e203f4b" title="Performs several checks to verify whether this rotational inertia could be physically valid,...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af397b4c3403d23ab61a128dbeaa1c3aa" title="Re-expresses this rotational inertia I_BP_E in place to I_BP_A.">ReExpressInPlace()</a> </dd></dl>

</div>
</div>
<a id="af397b4c3403d23ab61a128dbeaa1c3aa" name="af397b4c3403d23ab61a128dbeaa1c3aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af397b4c3403d23ab61a128dbeaa1c3aa">&#9670;&#160;</a></span>ReExpressInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ReExpressInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R_AE</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-expresses <span class="tt">this</span> rotational inertia <span class="tt">I_BP_E</span> in place to <span class="tt">I_BP_A</span>. </p>
<p>In other words, starts with <span class="tt">this</span> rotational inertia of a body (or composite body) B about-point P expressed-in frame E and re-expresses to B's rotational inertia about-point P expressed-in frame A. More concisely, we compute <span class="tt">I_BP_A = R_AE * I_BP_E * (R_AE)áµ€</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R_AE</td><td>RotationMatrix relating frames A and E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if the rotational inertia that is re-expressed-in frame A violates <a class="el" href="#a3d0f677b6d05d13d285967b57e203f4b" title="Performs several checks to verify whether this rotational inertia could be physically valid,...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a527deca4cbc51761000630fb372b7eb1" title="Re-expresses this rotational inertia I_BP_E to I_BP_A i.e., re-expresses body B&#39;s rotational inertia ...">ReExpress()</a>. </dd></dl>

</div>
</div>
<a id="ad107abcacb84cbabb41b87ba81360f91" name="ad107abcacb84cbabb41b87ba81360f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad107abcacb84cbabb41b87ba81360f91">&#9670;&#160;</a></span>rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int rows </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For consistency with Eigen's API, the <a class="el" href="#ad107abcacb84cbabb41b87ba81360f91" title="For consistency with Eigen&#39;s API, the rows() method returns 3.">rows()</a> method returns 3. </p>

</div>
</div>
<a id="ae461fd75b1b4eba6c95a57621adb4e9d" name="ae461fd75b1b4eba6c95a57621adb4e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae461fd75b1b4eba6c95a57621adb4e9d">&#9670;&#160;</a></span>SetToNaN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetToNaN </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <span class="tt">this</span> rotational inertia so all its elements are equal to NaN. </p>
<p>This helps quickly detect uninitialized moments/products of inertia. </p>

</div>
</div>
<a id="ae57e5aca5db002545e4b9335c8d9dbfa" name="ae57e5aca5db002545e4b9335c8d9dbfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57e5aca5db002545e4b9335c8d9dbfa">&#9670;&#160;</a></span>SetZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetZero </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <span class="tt">this</span> rotational inertia so all its moments/products of inertia are zero, e.g., for convenient initialization before a computation or for inertia calculations involving a particle (point-mass). </p>
<p>Note: Real 3D massive physical objects have non-zero moments of inertia. </p>

</div>
</div>
<a id="a56317cf8991d1f8ab21f8a8b81a33340" name="a56317cf8991d1f8ab21f8a8b81a33340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56317cf8991d1f8ab21f8a8b81a33340">&#9670;&#160;</a></span>ShiftFromCenterOfMass()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; ShiftFromCenterOfMass </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>mass</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_BcmQ_E</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the rotational inertia that results from shifting <span class="tt">this</span> rotational inertia for a body (or composite body) B from about-point Bcm (B's center of mass) to about-point Q. </p>
<p>I.e., shifts <span class="tt">I_BBcm_E</span> to <span class="tt">I_BQ_E</span> (both are expressed-in frame E). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mass</td><td>The mass of body (or composite body) B. </td></tr>
    <tr><td class="paramname">p_BcmQ_E</td><td>Position vector from Bcm to Q, expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">I_BQ_E</td><td>B's rotational inertia about-point Q expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if the rotational inertia that is shifted to about-point Q violates <a class="el" href="#a3d0f677b6d05d13d285967b57e203f4b" title="Performs several checks to verify whether this rotational inertia could be physically valid,...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Negating the position vector p_BcmQ_E has no affect on the result. </dd></dl>

</div>
</div>
<a id="aaad06162821520625a28e0526d698e87" name="aaad06162821520625a28e0526d698e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad06162821520625a28e0526d698e87">&#9670;&#160;</a></span>ShiftFromCenterOfMassInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ShiftFromCenterOfMassInPlace </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>mass</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_BcmQ_E</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts <span class="tt">this</span> rotational inertia for a body (or composite body) B from about-point Bcm (B's center of mass) to about-point Q. </p>
<p>I.e., shifts <span class="tt">I_BBcm_E</span> to <span class="tt">I_BQ_E</span> (both are expressed-in frame E). On return, <span class="tt">this</span> is modified to be shifted from about-point Bcm to about-point Q. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mass</td><td>The mass of body (or composite body) B. </td></tr>
    <tr><td class="paramname">p_BcmQ_E</td><td>Position vector from Bcm to Q, expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if the rotational inertia that is shifted to about-point Q violates <a class="el" href="#a3d0f677b6d05d13d285967b57e203f4b" title="Performs several checks to verify whether this rotational inertia could be physically valid,...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Negating the position vector p_BcmQ_E has no affect on the result. </dd></dl>

</div>
</div>
<a id="a9a02657678fd4d5324b53a4923ad8c8f" name="a9a02657678fd4d5324b53a4923ad8c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a02657678fd4d5324b53a4923ad8c8f">&#9670;&#160;</a></span>ShiftToCenterOfMass()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; ShiftToCenterOfMass </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>mass</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_QBcm_E</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the rotational inertia that results from shifting <span class="tt">this</span> rotational inertia for a body (or composite body) B from about-point Q to about-point <span class="tt">Bcm</span> (B's center of mass). </p>
<p>I.e., shifts <span class="tt">I_BQ_E</span> to <span class="tt">I_BBcm_E</span> (both are expressed-in frame E). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mass</td><td>The mass of body (or composite body) B. </td></tr>
    <tr><td class="paramname">p_QBcm_E</td><td>Position vector from Q to <span class="tt">Bcm</span>, expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">I_BBcm_E</td><td>B's rotational inertia about-point <span class="tt">Bcm</span> expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if the rotational inertia that is shifted to about-point <span class="tt">Bcm</span> violates <a class="el" href="#a3d0f677b6d05d13d285967b57e203f4b" title="Performs several checks to verify whether this rotational inertia could be physically valid,...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Negating the position vector <span class="tt">p_QBcm_E</span> has no affect on the result. </dd></dl>

</div>
</div>
<a id="af8ca1f1551b6a301c66903cee8db94d5" name="af8ca1f1551b6a301c66903cee8db94d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ca1f1551b6a301c66903cee8db94d5">&#9670;&#160;</a></span>ShiftToCenterOfMassInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ShiftToCenterOfMassInPlace </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>mass</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_QBcm_E</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts <span class="tt">this</span> rotational inertia for a body (or composite body) B from about-point Q to about-point <span class="tt">Bcm</span> (B's center of mass). </p>
<p>I.e., shifts <span class="tt">I_BQ_E</span> to <span class="tt">I_BBcm_E</span> (both are expressed-in frame E). On return, <span class="tt">this</span> is shifted from about-point Q to about-point <span class="tt">Bcm</span>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mass</td><td>The mass of body (or composite body) B. </td></tr>
    <tr><td class="paramname">p_QBcm_E</td><td>Position vector from Q to <span class="tt">Bcm</span>, expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if the rotational inertia that is shifted to about-point <span class="tt">Bcm</span> violates <a class="el" href="#a3d0f677b6d05d13d285967b57e203f4b" title="Performs several checks to verify whether this rotational inertia could be physically valid,...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Negating the position vector <span class="tt">p_QBcm_E</span> has no affect on the result. </dd></dl>

</div>
</div>
<a id="a55b84836d8b7e4e0ec1c3455ab0ade9c" name="a55b84836d8b7e4e0ec1c3455ab0ade9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b84836d8b7e4e0ec1c3455ab0ade9c">&#9670;&#160;</a></span>ShiftToThenAwayFromCenterOfMass()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; ShiftToThenAwayFromCenterOfMass </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>mass</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_PBcm_E</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_QBcm_E</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the rotational inertia that results from shifting <span class="tt">this</span> rotational inertia for a body (or composite body) B from about-point P to about-point Q via Bcm (B's center of mass). </p>
<p>I.e., shifts <span class="tt">I_BP_E</span> to <span class="tt">I_BQ_E</span> (both are expressed-in frame E). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mass</td><td>The mass of body (or composite body) B. </td></tr>
    <tr><td class="paramname">p_PBcm_E</td><td>Position vector from P to Bcm, expressed-in frame E. </td></tr>
    <tr><td class="paramname">p_QBcm_E</td><td>Position vector from Q to Bcm, expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">I_BQ_E,B's</td><td>rotational inertia about-point Q expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if the rotational inertia that is shifted to about-point Q violates <a class="el" href="#a3d0f677b6d05d13d285967b57e203f4b" title="Performs several checks to verify whether this rotational inertia could be physically valid,...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Negating either (or both) position vectors p_PBcm_E and p_QBcm_E has no affect on the result. </dd></dl>

</div>
</div>
<a id="ae531c9b24ec6c5cc94481a0231c331b7" name="ae531c9b24ec6c5cc94481a0231c331b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae531c9b24ec6c5cc94481a0231c331b7">&#9670;&#160;</a></span>ShiftToThenAwayFromCenterOfMassInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ShiftToThenAwayFromCenterOfMassInPlace </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>mass</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_PBcm_E</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_QBcm_E</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts <span class="tt">this</span> rotational inertia for a body (or composite body) B from about-point P to about-point Q via Bcm (B's center of mass). </p>
<p>I.e., shifts <span class="tt">I_BP_E</span> to <span class="tt">I_BQ_E</span> (both are expressed-in frame E). On return, <span class="tt">this</span> is modified to be shifted from about-point P to about-point Q. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mass</td><td>The mass of body (or composite body) B. </td></tr>
    <tr><td class="paramname">p_PBcm_E</td><td>Position vector from P to Bcm, expressed-in frame E. </td></tr>
    <tr><td class="paramname">p_QBcm_E</td><td>Position vector from Q to Bcm, expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if the rotational inertia that is shifted to about-point Q violates <a class="el" href="#a3d0f677b6d05d13d285967b57e203f4b" title="Performs several checks to verify whether this rotational inertia could be physically valid,...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Negating either (or both) position vectors p_PBcm_E and p_QBcm_E has no affect on the result. </dd>
<dd>
This method is more efficient (by 6 multiplications) than first shifting to the center of mass, then shifting away, e.g., as (<a class="el" href="#af8ca1f1551b6a301c66903cee8db94d5" title="Shifts this rotational inertia for a body (or composite body) B from about-point Q to about-point Bcm...">ShiftToCenterOfMassInPlace()</a>).<a class="el" href="#aaad06162821520625a28e0526d698e87" title="Shifts this rotational inertia for a body (or composite body) B from about-point Bcm (B&#39;s center of m...">ShiftFromCenterOfMassInPlace()</a>; </dd></dl>

</div>
</div>
<a id="a23798f37ae600d4d79b8a2e71586c4c7" name="a23798f37ae600d4d79b8a2e71586c4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23798f37ae600d4d79b8a2e71586c4c7">&#9670;&#160;</a></span>Trace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Trace </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a rotational inertia's trace (i.e., Ixx + Iyy + Izz, the sum of the diagonal elements of the inertia matrix). </p>
<p>The trace happens to be invariant to its expressed-in frame (i.e., the trace does not depend on the frame in which it is expressed). The trace is useful because the largest moment of inertia Imax has range: trace / 3 &lt;= Imax &lt;= trace / 2, and the largest possible product of inertia must be &lt;= Imax / 2. Hence, trace / 3 and trace / 2 give a lower and upper bound on the largest possible element that can be in a valid rotational inertia. </p>

</div>
</div>
<a id="afbaf4c2e50e429fd52f2d91eb32c20b1" name="afbaf4c2e50e429fd52f2d91eb32c20b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbaf4c2e50e429fd52f2d91eb32c20b1">&#9670;&#160;</a></span>TriaxiallySymmetric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; TriaxiallySymmetric </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>I_triaxial</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a rotational inertia with equal moments of inertia along its diagonal and with each product of inertia set to zero. </p>
<p>This factory is useful for the rotational inertia of a uniform-density sphere or cube. In debug builds, throws std::exception if I_triaxial is negative/NaN. </p>

</div>
</div>
<a name="doc-related-members" id="doc-related-members"></a><h2 id="header-doc-related-members" class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="ab17d9c09a9350b0a4e0ce60a6d62eeeb" name="ab17d9c09a9350b0a4e0ce60a6d62eeeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17d9c09a9350b0a4e0ce60a6d62eeeb">&#9670;&#160;</a></span>operator*</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>nonnegative_scalar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>I_BP_E</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies a nonnegative scalar (&gt;= 0) by the rotational inertia <span class="tt">I_BP_E</span>. </p>
<p>In debug builds, throws std::exception if <span class="tt">nonnegative_scalar</span> &lt; 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nonnegative_scalar</td><td>Nonnegative scalar which multiplies <span class="tt">I_BP_E</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">nonnegative_scalar</span> multiplied by rotational inertia <span class="tt">I_BP_E</span>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7469d31bb79c3c18e0b08941d0469db5" title="Multiplies this rotational inertia by a nonnegative scalar (&gt;= 0).">operator*=()</a>, <a class="el" href="#a1275e13820b74540e4b013515e3a5e9a" title="Multiplies this rotational inertia by a nonnegative scalar (&gt;= 0).">operator*()</a> </dd></dl>
<p>Multiplication of a scalar with a rotational matrix is commutative.</p>

</div>
</div>
<a id="ac917bf1dfed2a1cfe26be9d258285a2d" name="ac917bf1dfed2a1cfe26be9d258285a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac917bf1dfed2a1cfe26be9d258285a2d">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>I</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel related">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes an instance of <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class describes the mass distribution (inertia properties) of a body or composite body about a p...">RotationalInertia</a> into a std::ostream. </p>
<p>(Deprecated.) </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000034">Deprecated</a></b></dt><dd>Use fmt functions instead (e.g., fmt::format(), fmt::to_string(),  fmt::print()). Refer to GitHub issue #17742 for more information. <br  />
 This will be removed from Drake on or after 2026-06-01. </dd></dl>

</div>
</div>
<a id="a82936d10a31afe3ae91f3025a39d3224" name="a82936d10a31afe3ae91f3025a39d3224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82936d10a31afe3ae91f3025a39d3224">&#9670;&#160;</a></span>RotationalInertia</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class RotationalInertia</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae863ba45d3a764d9fcfc77df2e070335" name="ae863ba45d3a764d9fcfc77df2e070335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae863ba45d3a764d9fcfc77df2e070335">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>I</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel related">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the string representation of a <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class describes the mass distribution (inertia properties) of a body or composite body about a p...">RotationalInertia</a> object. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/multibody/tree/<a class="el" href="rotational__inertia_8h.html">rotational_inertia.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to nameâ€¦';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
