<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: RotationalInertia&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 </div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1multibody_1_1_rotational_inertia.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classdrake_1_1multibody_1_1_rotational_inertia-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RotationalInertia&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::multibody::RotationalInertia&lt; T &gt;</h3>

<p>This class describes the mass distribution (inertia properties) of a body or composite body about a particular point. </p>
<p>Herein, "composite body" means one body or a collection of bodies that are welded together. In this documentation, "body" and "composite body" are used interchangeably.</p>
<p>A <b>rigid</b> body's mass distribution is described by three quantities: the body's mass; the body's center of mass; and the body's rotational inertia about a particular point. The term <b>rotational inertia</b> is used here and by [Jain 2010] to distinguish from a body's <b>spatial inertia</b>. In this class, a 3x3 <b>inertia matrix</b> I represents a body's rotational inertia about a point and expressed in a frame. More specifically, <code>I_BP_E</code> is the inertia matrix of a body B about-point P and expressed-in frame E (herein frame E's orthogonal unit vectors Ex, Ey, Ez are denoted 𝐱̂, 𝐲̂, 𝐳̂). </p><pre>
    | Ixx Ixy Ixz |
I = | Ixy Iyy Iyz |
    | Ixz Iyz Izz |
</pre><p> The moments of inertia Ixx, Iyy, Izz and products of inertia Ixy, Ixz, Iyz are defined in terms of the mass dm of a differential volume of the body. The position of dm from about-point P is xx̂ + yŷ + zẑ = [x, y, z]_E. </p><pre>
Ixx = ∫ (y² + z²) dm
Iyy = ∫ (x² + z²) dm
Izz = ∫ (x² + y²) dm
Ixy = - ∫ x y dm
Ixz = - ∫ x z dm
Iyz = - ∫ y z dm
</pre><p> We use the negated convention for products of inertia, so that I serves to relate angular velocity ω and angular momentum h via <code>h = I ⋅ ω</code>. Ensure your products of inertia follow this negative sign convention.</p>
<p>The 3x3 inertia matrix is symmetric and its diagonal elements (moments of inertia) and off-diagonal elements (products of inertia) are associated with a body (or composite body) S, an about-point P, and an expressed-in frame E (𝐱̂, 𝐲̂, 𝐳̂̂). A rotational inertia is ill-defined unless there is a body S, about-point P, and expressed-in frame E. The user of this class is responsible for tracking the body S, about-point P and expressed-in frame E (none of these are stored in this class).</p>
<dl class="section note"><dt>Note</dt><dd>This class does not store the about-point nor the expressed-in frame, nor does this class help enforce consistency of the about-point or expressed-in frame. To help users of this class track the about-point and expressed-in frame, we strongly recommend the following notation.</dd>
<dd>
In typeset material, use the symbol \( [I^{S/P}]_E \) to represent the rotational inertia (inertia matrix) of a body (or composite body) S about-point P, expressed in frame E. In code and comments, use the monogram notation <code>I_SP_E</code> (e.g., as described in <a class="el" href="group__multibody__spatial__inertia.html">Spatial Mass Matrix (Spatial Inertia)</a>). If the about-point P is fixed to a body B, the point is named \( B_P \) and this appears in code/comments as <code>Bp</code>. Examples: <code>I_BBp_E</code> is rigid body B's rotational inertia about-point Bp expressed-in frame E; I_BBo_E is B's rotational inertia about-point <code>Bo</code> (body B's origin) expressed-in frame E; and I_BBcm_E is B's inertia matrix about-point <code>Bcm</code> (B's center of mass) expressed-in frame E.</dd>
<dd>
The rotational inertia (inertia matrix) can be re-expressed in terms of a special frame whose orthogonal unit vectors are parallel to <b>principal axes of inertia</b> so that the inertia matrix is diagonalized with elements called <b>principal moments of inertia</b>.</dd>
<dd>
The formal definition of the inertia matrix \( I^{S/P} \) of a system S about a point P follows the definition of the inertia dyadic 𝐈 of S about P, which begins by modeling S with n particles S₁ ... Sₙ (e.g., 12 grams of carbon can be modeled with n = 6.02 * 10²³ molecules/particles). The inertia dyadic 𝐈₁ of one particle S₁ about point P is defined [Kane, 1985] in terms of m₁ (mass of S₁), ᴾ𝐩ˢ¹ (position vector from P to S₁), and the unit dyadic 𝐔 which is defined by the property 𝐔 ⋅ 𝐯 = 𝐯 where 𝐯 is is any vector (this definition of 𝐔 is analogous to defining the identity matrix by the property 𝑰𝒅𝒆𝒏𝒕𝒊𝒕𝒚𝑴𝒂𝒕𝒓𝒊𝒙 * 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙 = 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙). <pre>
    𝐈₁ = m₁ * [𝐔 * (ᴾ𝐩ˢ¹ ⋅ ᴾ𝐩ˢ¹)  -  ᴾ𝐩ˢ¹ * ᴾ𝐩ˢ¹]
</pre> Note: The vector dot-product (⋅) above produces a scalar whereas the vector multiply (*) produces a dyadic which is a 2nd-order tensor (ᴾ𝐩ˢ¹ * ᴾ𝐩ˢ¹ is similar to the matrix outer-product of a 3x1 matrix multiplied by a 1x3 matrix). An example inertia dyadic for a single particle is shown further below. The inertia dyadic 𝐈 of the entire system S is defined by summing the inertia dyadic of each particle Sᵢ about P (i = 1, ... n), i.e., <pre>
    𝐈 = 𝐈₁ + 𝐈₂ + ... 𝐈ₙ
</pre> The elements of the inertia matrix \( [I^{S/P}]_E \) expressed in frame E (in terms of orthogonal unit vectors 𝐱̂, 𝐲̂, 𝐳̂̂) are found by pre-dot multiplying and post-dot multiplying 𝐈 with appropriate unit vectors. <pre>
   Ixx = 𝐱̂ ⋅ 𝐈 ⋅ 𝐱̂     Ixy = 𝐱̂ ⋅ 𝐈 ⋅ 𝐲̂      Ixz = 𝐱̂ ⋅ 𝐈 ⋅ 𝐳̂̂
   Iyx = 𝐲̂ ⋅ 𝐈 ⋅ 𝐱̂     Iyy = 𝐲̂ ⋅ 𝐈 ⋅ 𝐲̂      Iyz = 𝐲̂ ⋅ 𝐈 ⋅ 𝐳̂̂
   Izx = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐱̂     Izy = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐲̂      Izz = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐳̂̂
</pre> The inertia dyadic 𝐈ᴮ of a rigid body B about Bcm (B's center of mass) is related to various dynamic quantities. For example, B's angular momentum 𝐇 about Bcm in a frame N and B's kinetic energy KE in N relate to 𝐈ᴮ by <pre>
   𝐇 = 𝐈ᴮ ⋅ 𝛚
   KE = 1/2 𝛚 ⋅ 𝐈ᴮ ⋅ 𝛚  +  1/2 mᴮ 𝐯 ⋅ 𝐯
</pre> where 𝛚 is B's angular velocity in N, 𝐯 is Bcm's translational velocity in N, and mᴮ is B's mass. When frame N happens to be a Newtonian frame (also called an inertial frame or non-rotating/non-accelerating frame), the moment 𝐓 of all forces on B about Bcm relates to 𝐈ᴮ and 𝛂 (B's angular acceleration in N) by Euler's rigid body equation as <pre>
   𝐓 = 𝐈ᴮ ⋅ 𝛂  +  𝛚 × 𝐈ᴮ ⋅ 𝛚
</pre> Example: For a particle Q of mass m whose position vector from a point O is written in terms of right-handed orthogonal unit vectors 𝐱̂, 𝐲̂, 𝐳̂ (below), the inertia dyadic 𝐈 of particle Q about point O is defined and calculated <pre>
    𝐩 = x 𝐱̂  +  y 𝐲̂                               (given)
    𝐈 = m * [𝐔 * (𝐩 ⋅ 𝐩)  -  𝐩 * 𝐩]              (definition)
      = m * [𝐔 * (x² + y²)  -  (x𝐱̂ + y𝐲̂̂) * (x𝐱̂ + y𝐲̂)
      = m * [(𝐱̂𝐱̂ + 𝐲̂𝐲̂ + 𝐳̂𝐳̂) * (x² + y²) - (x²𝐱̂𝐱̂ + xy𝐱̂𝐲̂̂ + xy𝐲̂̂𝐱̂ + y²𝐲̂̂𝐲̂̂)]
      = m * [y²𝐱̂𝐱̂ + x²𝐲̂𝐲̂ + (x² + y²)𝐳̂𝐳̂ - xy𝐱̂𝐲̂̂ - xy𝐲̂̂𝐱̂]
</pre> which means the inertia matrix for particle Q about point O for 𝐱̂, 𝐲̂, 𝐳̂ is <pre>
    |  m y²     -m x y         0     |
I = | -m x y     m x²          0     |
    |    0         0     m (x² + y²) |
</pre> [Kane, 1985] pg. 68. "Dynamics: Theory and Applications," McGraw-Hill Co., New York, 1985 (with D. A. Levinson). Available for free .pdf download: <a href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></dd>
<dd>
Several methods in this class throw a std::exception for invalid rotational inertia operations in debug releases only. This provides speed in a release build while facilitating debugging in debug builds. In addition, these validity tests are only performed for scalar types for which <a class="el" href="structdrake_1_1scalar__predicate.html#ab6fdcd06e06c892b3492eb6ea8f15be2" title="Whether type is bool.">drake::scalar_predicate&lt;T&gt;::is_bool</a> is <code>true</code>. For instance, validity checks are not performed when T is <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>.</dd>
<dd>
The methods of this class satisfy the "basic exception guarantee": if an exception is thrown, the program will still be in a valid state. Specifically, no resources are leaked, and all objects' invariants are intact. Be aware that <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class describes the mass distribution (inertia properties) of a body or composite body about a p...">RotationalInertia</a> objects may contain invalid inertia data in cases where input checking is skipped. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/language/exceptions">https://en.cppreference.com/w/cpp/language/exceptions</a></dd></dl>
<p>Various methods in this class require numerical (not symbolic) data types.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/multibody/tree/rotational_inertia.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab3ffc4a4e197a2a2155641d75c2a7c49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab3ffc4a4e197a2a2155641d75c2a7c49">RotationalInertia</a> ()</td></tr>
<tr class="memdesc:ab3ffc4a4e197a2a2155641d75c2a7c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a rotational inertia that has all its moments/products of inertia equal to NaN (helps quickly detect uninitialized values).  <a href="#ab3ffc4a4e197a2a2155641d75c2a7c49">More...</a><br /></td></tr>
<tr class="separator:ab3ffc4a4e197a2a2155641d75c2a7c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36dbdaa401764e4df48b07d3b6ad7d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#af36dbdaa401764e4df48b07d3b6ad7d4">RotationalInertia</a> (const T &amp;Ixx, const T &amp;Iyy, const T &amp;Izz)</td></tr>
<tr class="memdesc:af36dbdaa401764e4df48b07d3b6ad7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rotational inertia with moments of inertia <code>Ixx</code>, <code>Iyy</code>, <code>Izz</code>, and with each product of inertia set to zero.  <a href="#af36dbdaa401764e4df48b07d3b6ad7d4">More...</a><br /></td></tr>
<tr class="separator:af36dbdaa401764e4df48b07d3b6ad7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319d6a0feeb306267605332cdd1906d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a319d6a0feeb306267605332cdd1906d6">RotationalInertia</a> (const T &amp;Ixx, const T &amp;Iyy, const T &amp;Izz, const T &amp;Ixy, const T &amp;Ixz, const T &amp;Iyz)</td></tr>
<tr class="memdesc:a319d6a0feeb306267605332cdd1906d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rotational inertia with moments of inertia <code>Ixx</code>, <code>Iyy</code>, <code>Izz</code>, and with products of inertia <code>Ixy</code>, <code>Ixz</code>, <code>Iyz</code>.  <a href="#a319d6a0feeb306267605332cdd1906d6">More...</a><br /></td></tr>
<tr class="separator:a319d6a0feeb306267605332cdd1906d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ee8d395f9f46a1086071be0faa8e37"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a73ee8d395f9f46a1086071be0faa8e37">RotationalInertia</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_PQ_E)</td></tr>
<tr class="memdesc:a73ee8d395f9f46a1086071be0faa8e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a rotational inertia for a particle Q of mass <code>mass</code>, whose position vector from about-point P is p_PQ_E (E is expressed-in frame).  <a href="#a73ee8d395f9f46a1086071be0faa8e37">More...</a><br /></td></tr>
<tr class="separator:a73ee8d395f9f46a1086071be0faa8e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad107abcacb84cbabb41b87ba81360f91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ad107abcacb84cbabb41b87ba81360f91">rows</a> () const</td></tr>
<tr class="memdesc:ad107abcacb84cbabb41b87ba81360f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">For consistency with Eigen's API, the <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ad107abcacb84cbabb41b87ba81360f91" title="For consistency with Eigen&#39;s API, the rows() method returns 3.">rows()</a> method returns 3.  <a href="#ad107abcacb84cbabb41b87ba81360f91">More...</a><br /></td></tr>
<tr class="separator:ad107abcacb84cbabb41b87ba81360f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8509d6f7951179378f848f5f4cc37720"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a8509d6f7951179378f848f5f4cc37720">cols</a> () const</td></tr>
<tr class="memdesc:a8509d6f7951179378f848f5f4cc37720"><td class="mdescLeft">&#160;</td><td class="mdescRight">For consistency with Eigen's API, the <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a8509d6f7951179378f848f5f4cc37720" title="For consistency with Eigen&#39;s API, the cols() method returns 3.">cols()</a> method returns 3.  <a href="#a8509d6f7951179378f848f5f4cc37720">More...</a><br /></td></tr>
<tr class="separator:a8509d6f7951179378f848f5f4cc37720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63faf9877a005bf08269b508f2d17b42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a63faf9877a005bf08269b508f2d17b42">get_moments</a> () const</td></tr>
<tr class="memdesc:a63faf9877a005bf08269b508f2d17b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 3-element vector with moments of inertia [Ixx, Iyy, Izz].  <a href="#a63faf9877a005bf08269b508f2d17b42">More...</a><br /></td></tr>
<tr class="separator:a63faf9877a005bf08269b508f2d17b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73703796210df51bb25acbb19168913a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a73703796210df51bb25acbb19168913a">get_products</a> () const</td></tr>
<tr class="memdesc:a73703796210df51bb25acbb19168913a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 3-element vector with products of inertia [Ixy, Ixz, Iyz].  <a href="#a73703796210df51bb25acbb19168913a">More...</a><br /></td></tr>
<tr class="separator:a73703796210df51bb25acbb19168913a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23798f37ae600d4d79b8a2e71586c4c7"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a23798f37ae600d4d79b8a2e71586c4c7">Trace</a> () const</td></tr>
<tr class="memdesc:a23798f37ae600d4d79b8a2e71586c4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a rotational inertia's trace (i.e., Ixx + Iyy + Izz, the sum of the diagonal elements of the inertia matrix).  <a href="#a23798f37ae600d4d79b8a2e71586c4c7">More...</a><br /></td></tr>
<tr class="separator:a23798f37ae600d4d79b8a2e71586c4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3751c9eaa974909523b6d8d3fd0833a8"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a3751c9eaa974909523b6d8d3fd0833a8">CalcMaximumPossibleMomentOfInertia</a> () const</td></tr>
<tr class="memdesc:a3751c9eaa974909523b6d8d3fd0833a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum possible moment of inertia for <code>this</code> rotational inertia about-point P for any expressed-in frame E.  <a href="#a3751c9eaa974909523b6d8d3fd0833a8">More...</a><br /></td></tr>
<tr class="separator:a3751c9eaa974909523b6d8d3fd0833a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae48d85764cacfd54fc3001250b4eac"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#afae48d85764cacfd54fc3001250b4eac">operator()</a> (<a class="el" href="classint.html">int</a> i, <a class="el" href="classint.html">int</a> j) const</td></tr>
<tr class="memdesc:afae48d85764cacfd54fc3001250b4eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const access to the <code>(i, j)</code> element of this rotational inertia.  <a href="#afae48d85764cacfd54fc3001250b4eac">More...</a><br /></td></tr>
<tr class="separator:afae48d85764cacfd54fc3001250b4eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38985b256018ac664935ee8423bbe8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#af38985b256018ac664935ee8423bbe8b">CopyToFullMatrix3</a> () const</td></tr>
<tr class="memdesc:af38985b256018ac664935ee8423bbe8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a full 3x3 matrix copy of this rotational inertia.  <a href="#af38985b256018ac664935ee8423bbe8b">More...</a><br /></td></tr>
<tr class="separator:af38985b256018ac664935ee8423bbe8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0546b3ac658fccec61a5156a926765dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a0546b3ac658fccec61a5156a926765dd">IsNearlyEqualTo</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> &amp;other, <a class="el" href="classdouble.html">double</a> precision) const</td></tr>
<tr class="memdesc:a0546b3ac658fccec61a5156a926765dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <code>this</code> rotational inertia to <code>other</code> rotational inertia within the specified <code>precision</code> (which is a dimensionless number specifying the relative precision to which the comparison is performed).  <a href="#a0546b3ac658fccec61a5156a926765dd">More...</a><br /></td></tr>
<tr class="separator:a0546b3ac658fccec61a5156a926765dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d65a4cd4dd6105398ee79ad825035f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a22d65a4cd4dd6105398ee79ad825035f">operator+=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I_BP_E)</td></tr>
<tr class="memdesc:a22d65a4cd4dd6105398ee79ad825035f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a rotational inertia <code>I_BP_E</code> to <code>this</code> rotational inertia.  <a href="#a22d65a4cd4dd6105398ee79ad825035f">More...</a><br /></td></tr>
<tr class="separator:a22d65a4cd4dd6105398ee79ad825035f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b4714f1ad30911025024f1eda4d72e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab3b4714f1ad30911025024f1eda4d72e">operator+</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I_BP_E) const</td></tr>
<tr class="memdesc:ab3b4714f1ad30911025024f1eda4d72e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a rotational inertia <code>I_BP_E</code> to <code>this</code> rotational inertia.  <a href="#ab3b4714f1ad30911025024f1eda4d72e">More...</a><br /></td></tr>
<tr class="separator:ab3b4714f1ad30911025024f1eda4d72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9616b9b963139066953c80ac978c362a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a9616b9b963139066953c80ac978c362a">operator-=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I_BP_E)</td></tr>
<tr class="memdesc:a9616b9b963139066953c80ac978c362a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a rotational inertia <code>I_BP_E</code> from <code>this</code> rotational inertia.  <a href="#a9616b9b963139066953c80ac978c362a">More...</a><br /></td></tr>
<tr class="separator:a9616b9b963139066953c80ac978c362a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff3c0d26ee10bb5d824ee6d3498eb4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#aaff3c0d26ee10bb5d824ee6d3498eb4d">operator-</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I_BP_E) const</td></tr>
<tr class="memdesc:aaff3c0d26ee10bb5d824ee6d3498eb4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a rotational inertia <code>I_BP_E</code> from <code>this</code> rotational inertia.  <a href="#aaff3c0d26ee10bb5d824ee6d3498eb4d">More...</a><br /></td></tr>
<tr class="separator:aaff3c0d26ee10bb5d824ee6d3498eb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772d06048b8ada1e80045b45a32e51f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a772d06048b8ada1e80045b45a32e51f0">operator *=</a> (const T &amp;nonnegative_scalar)</td></tr>
<tr class="memdesc:a772d06048b8ada1e80045b45a32e51f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <code>this</code> rotational inertia by a nonnegative scalar (&gt;= 0).  <a href="#a772d06048b8ada1e80045b45a32e51f0">More...</a><br /></td></tr>
<tr class="separator:a772d06048b8ada1e80045b45a32e51f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad677024790190d7f913839cbdf0902"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a6ad677024790190d7f913839cbdf0902">operator *</a> (const T &amp;nonnegative_scalar) const</td></tr>
<tr class="memdesc:a6ad677024790190d7f913839cbdf0902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <code>this</code> rotational inertia by a nonnegative scalar (&gt;= 0).  <a href="#a6ad677024790190d7f913839cbdf0902">More...</a><br /></td></tr>
<tr class="separator:a6ad677024790190d7f913839cbdf0902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275b3628b6e487b99b5a26b40e7c9454"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a275b3628b6e487b99b5a26b40e7c9454">operator *</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;w_E) const</td></tr>
<tr class="memdesc:a275b3628b6e487b99b5a26b40e7c9454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <code>this</code> rotational inertia about-point P, expressed-in frame E by the vector w_E (which <em>must</em> also have the same expressed-in frame E).  <a href="#a275b3628b6e487b99b5a26b40e7c9454">More...</a><br /></td></tr>
<tr class="separator:a275b3628b6e487b99b5a26b40e7c9454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb6014636db3579a84defd7824ee4c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a3cb6014636db3579a84defd7824ee4c1">operator/=</a> (const T &amp;positive_scalar)</td></tr>
<tr class="memdesc:a3cb6014636db3579a84defd7824ee4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides <code>this</code> rotational inertia by a positive scalar (&gt; 0).  <a href="#a3cb6014636db3579a84defd7824ee4c1">More...</a><br /></td></tr>
<tr class="separator:a3cb6014636db3579a84defd7824ee4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0d8c42739dc16a87225c2b0057517b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a7a0d8c42739dc16a87225c2b0057517b">operator/</a> (const T &amp;positive_scalar) const</td></tr>
<tr class="memdesc:a7a0d8c42739dc16a87225c2b0057517b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides <code>this</code> rotational inertia by a positive scalar(&gt; 0).  <a href="#a7a0d8c42739dc16a87225c2b0057517b">More...</a><br /></td></tr>
<tr class="separator:a7a0d8c42739dc16a87225c2b0057517b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0393e660bf996a3937e40ef2dc3e6757"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a0393e660bf996a3937e40ef2dc3e6757">MultiplyByScalarSkipValidityCheck</a> (const T &amp;s) const</td></tr>
<tr class="memdesc:a0393e660bf996a3937e40ef2dc3e6757"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Multiplies a rotational inertia by a scalar.  <a href="#a0393e660bf996a3937e40ef2dc3e6757">More...</a><br /></td></tr>
<tr class="separator:a0393e660bf996a3937e40ef2dc3e6757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae461fd75b1b4eba6c95a57621adb4e9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ae461fd75b1b4eba6c95a57621adb4e9d">SetToNaN</a> ()</td></tr>
<tr class="memdesc:ae461fd75b1b4eba6c95a57621adb4e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>this</code> rotational inertia so all its elements are equal to NaN.  <a href="#ae461fd75b1b4eba6c95a57621adb4e9d">More...</a><br /></td></tr>
<tr class="separator:ae461fd75b1b4eba6c95a57621adb4e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57e5aca5db002545e4b9335c8d9dbfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ae57e5aca5db002545e4b9335c8d9dbfa">SetZero</a> ()</td></tr>
<tr class="memdesc:ae57e5aca5db002545e4b9335c8d9dbfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>this</code> rotational inertia so all its moments/products of inertia are zero, e.g., for convenient initialization before a computation or for inertia calculations involving a particle (point-mass).  <a href="#ae57e5aca5db002545e4b9335c8d9dbfa">More...</a><br /></td></tr>
<tr class="separator:ae57e5aca5db002545e4b9335c8d9dbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a73339c4b21bba9c3fa975f7a6c4220"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a1a73339c4b21bba9c3fa975f7a6c4220">IsNaN</a> () const</td></tr>
<tr class="memdesc:a1a73339c4b21bba9c3fa975f7a6c4220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if any moment/product in <code>this</code> rotational inertia is NaN.  <a href="#a1a73339c4b21bba9c3fa975f7a6c4220">More...</a><br /></td></tr>
<tr class="separator:a1a73339c4b21bba9c3fa975f7a6c4220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55630ea16dd7fcd906f2c9d9db36bb66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a55630ea16dd7fcd906f2c9d9db36bb66">IsZero</a> () const</td></tr>
<tr class="memdesc:a55630ea16dd7fcd906f2c9d9db36bb66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if all moments and products of inertia are exactly zero.  <a href="#a55630ea16dd7fcd906f2c9d9db36bb66">More...</a><br /></td></tr>
<tr class="separator:a55630ea16dd7fcd906f2c9d9db36bb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1e01c37486db2e78263fb70eaff550"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:afa1e01c37486db2e78263fb70eaff550"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#afa1e01c37486db2e78263fb70eaff550">cast</a> () const</td></tr>
<tr class="memdesc:afa1e01c37486db2e78263fb70eaff550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new RotationalInertia object templated on <code>Scalar</code> initialized from the values of <code>this</code> rotational inertia's entries.  <a href="#afa1e01c37486db2e78263fb70eaff550">More...</a><br /></td></tr>
<tr class="separator:afa1e01c37486db2e78263fb70eaff550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b63ae12f2b1cc131b2584efe07a2b6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a6b63ae12f2b1cc131b2584efe07a2b6b">CalcPrincipalMomentsOfInertia</a> () const</td></tr>
<tr class="memdesc:a6b63ae12f2b1cc131b2584efe07a2b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the 3 principal moments of inertia for <code>this</code> rotational inertia.  <a href="#a6b63ae12f2b1cc131b2584efe07a2b6b">More...</a><br /></td></tr>
<tr class="separator:a6b63ae12f2b1cc131b2584efe07a2b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e13800a4b7f21903141dbe4c0102720"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;, <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a0e13800a4b7f21903141dbe4c0102720">CalcPrincipalMomentsAndAxesOfInertia</a> () const</td></tr>
<tr class="memdesc:a0e13800a4b7f21903141dbe4c0102720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the 3 principal moments of inertia and their 3 associated principal directions for <code>this</code> rotational inertia.  <a href="#a0e13800a4b7f21903141dbe4c0102720">More...</a><br /></td></tr>
<tr class="separator:a0e13800a4b7f21903141dbe4c0102720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e71eb4bd2a7648a411e1cbaf94812b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b">CouldBePhysicallyValid</a> () const</td></tr>
<tr class="memdesc:a03e71eb4bd2a7648a411e1cbaf94812b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs several necessary checks to verify whether <code>this</code> rotational inertia <em>could</em> be physically valid, including:  <a href="#a03e71eb4bd2a7648a411e1cbaf94812b">More...</a><br /></td></tr>
<tr class="separator:a03e71eb4bd2a7648a411e1cbaf94812b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800af438924a7ab6a1eeaf5a58865f28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a800af438924a7ab6a1eeaf5a58865f28">ReExpressInPlace</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;R_AE)</td></tr>
<tr class="memdesc:a800af438924a7ab6a1eeaf5a58865f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-expresses <code>this</code> rotational inertia <code>I_BP_E</code> in place to <code>I_BP_A</code>.  <a href="#a800af438924a7ab6a1eeaf5a58865f28">More...</a><br /></td></tr>
<tr class="separator:a800af438924a7ab6a1eeaf5a58865f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08eb5284c5ec57a645aee167798a1f2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a08eb5284c5ec57a645aee167798a1f2c">ReExpress</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;R_AE) const __attribute__((warn_unused_result))</td></tr>
<tr class="memdesc:a08eb5284c5ec57a645aee167798a1f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-expresses <code>this</code> rotational inertia <code>I_BP_E</code> to <code>I_BP_A</code> i.e., re-expresses body B's rotational inertia from frame E to frame A.  <a href="#a08eb5284c5ec57a645aee167798a1f2c">More...</a><br /></td></tr>
<tr class="separator:a08eb5284c5ec57a645aee167798a1f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:a719e23ae8c26b0c8cf0c7f30dd112559"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a719e23ae8c26b0c8cf0c7f30dd112559">RotationalInertia</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> &amp;)=default</td></tr>
<tr class="separator:a719e23ae8c26b0c8cf0c7f30dd112559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78d207e550d7d227b7e7f37557fb66a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab78d207e550d7d227b7e7f37557fb66a">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> &amp;)=default</td></tr>
<tr class="separator:ab78d207e550d7d227b7e7f37557fb66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e215bccd4ce720b787f8b5195a7551"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a87e215bccd4ce720b787f8b5195a7551">RotationalInertia</a> (<a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a87e215bccd4ce720b787f8b5195a7551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25060922d76f06276ac5f169e748ebd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ac25060922d76f06276ac5f169e748ebd">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ac25060922d76f06276ac5f169e748ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Shift methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Each shift method shifts a body's rotational inertia from one about-point to another about-point.</p>
<p>The expressed-in frame is unchanged.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">In-place methods (<code>this</code> changes)  </th><th class="markdownTableHeadNone">Const methods   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ShiftFromCenterOfMassInPlace  </td><td class="markdownTableBodyNone">ShiftFromCenterOfMass   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ShiftToCenterOfMassInPlace  </td><td class="markdownTableBodyNone">ShiftToCenterOfMass   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ShiftToThenAwayFromCenterOfMassInPlace  </td><td class="markdownTableBodyNone">ShiftToThenAwayFromCenterOfMass   </td></tr>
</table>
</div></td></tr>
<tr class="memitem:a233d049441510e6de4347afa89eff0e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a233d049441510e6de4347afa89eff0e0">ShiftFromCenterOfMassInPlace</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_BcmQ_E)</td></tr>
<tr class="memdesc:a233d049441510e6de4347afa89eff0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts <code>this</code> rotational inertia for a body (or composite body) B from about-point Bcm (B's center of mass) to about-point Q.  <a href="#a233d049441510e6de4347afa89eff0e0">More...</a><br /></td></tr>
<tr class="separator:a233d049441510e6de4347afa89eff0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6d68bf65261dba0c10a00174fed83c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a5a6d68bf65261dba0c10a00174fed83c">ShiftFromCenterOfMass</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_BcmQ_E) const __attribute__((warn_unused_result))</td></tr>
<tr class="memdesc:a5a6d68bf65261dba0c10a00174fed83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rotational inertia that results from shifting <code>this</code> rotational inertia for a body (or composite body) B from about-point Bcm (B's center of mass) to about-point Q.  <a href="#a5a6d68bf65261dba0c10a00174fed83c">More...</a><br /></td></tr>
<tr class="separator:a5a6d68bf65261dba0c10a00174fed83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a43d32c412efc0f5e1b6ccc1b1cc17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a82a43d32c412efc0f5e1b6ccc1b1cc17">ShiftToCenterOfMassInPlace</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_QBcm_E)</td></tr>
<tr class="memdesc:a82a43d32c412efc0f5e1b6ccc1b1cc17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts <code>this</code> rotational inertia for a body (or composite body) B from about-point Q to about-point <code>Bcm</code> (B's center of mass).  <a href="#a82a43d32c412efc0f5e1b6ccc1b1cc17">More...</a><br /></td></tr>
<tr class="separator:a82a43d32c412efc0f5e1b6ccc1b1cc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef27cf48918c4ca310e1e5d67de50f7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#aef27cf48918c4ca310e1e5d67de50f7a">ShiftToCenterOfMass</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_QBcm_E) const __attribute__((warn_unused_result))</td></tr>
<tr class="memdesc:aef27cf48918c4ca310e1e5d67de50f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rotational inertia that results from shifting <code>this</code> rotational inertia for a body (or composite body) B from about-point Q to about-point <code>Bcm</code> (B's center of mass).  <a href="#aef27cf48918c4ca310e1e5d67de50f7a">More...</a><br /></td></tr>
<tr class="separator:aef27cf48918c4ca310e1e5d67de50f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631d7db4d8c28e6108d78b8309dabc2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a631d7db4d8c28e6108d78b8309dabc2b">ShiftToThenAwayFromCenterOfMassInPlace</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_PBcm_E, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_QBcm_E)</td></tr>
<tr class="memdesc:a631d7db4d8c28e6108d78b8309dabc2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts <code>this</code> rotational inertia for a body (or composite body) B from about-point P to about-point Q via Bcm (B's center of mass).  <a href="#a631d7db4d8c28e6108d78b8309dabc2b">More...</a><br /></td></tr>
<tr class="separator:a631d7db4d8c28e6108d78b8309dabc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa36a24a9c8fa583631e45d1ad366ce3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#afa36a24a9c8fa583631e45d1ad366ce3">ShiftToThenAwayFromCenterOfMass</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_PBcm_E, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_QBcm_E) const __attribute__((warn_unused_result))</td></tr>
<tr class="memdesc:afa36a24a9c8fa583631e45d1ad366ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rotational inertia that results from shifting <code>this</code> rotational inertia for a body (or composite body) B from about-point P to about-point Q via Bcm (B's center of mass).  <a href="#afa36a24a9c8fa583631e45d1ad366ce3">More...</a><br /></td></tr>
<tr class="separator:afa36a24a9c8fa583631e45d1ad366ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a96949d335bfe501c62587705d47ce6ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a96949d335bfe501c62587705d47ce6ad">TriaxiallySymmetric</a> (const T &amp;I_triaxial)</td></tr>
<tr class="memdesc:a96949d335bfe501c62587705d47ce6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a rotational inertia with equal moments of inertia along its diagonal and with each product of inertia set to zero.  <a href="#a96949d335bfe501c62587705d47ce6ad">More...</a><br /></td></tr>
<tr class="separator:a96949d335bfe501c62587705d47ce6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a9857b35a25e766eda6fb149fb9134"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a66a9857b35a25e766eda6fb149fb9134">MakeFromMomentsAndProductsOfInertia</a> (const T &amp;Ixx, const T &amp;Iyy, const T &amp;Izz, const T &amp;Ixy, const T &amp;Ixz, const T &amp;Iyz, bool skip_validity_check=false)</td></tr>
<tr class="memdesc:a66a9857b35a25e766eda6fb149fb9134"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Creates a rotational inertia with moments of inertia Ixx, Iyy, Izz, and with products of inertia Ixy, Ixz, Iyz.  <a href="#a66a9857b35a25e766eda6fb149fb9134">More...</a><br /></td></tr>
<tr class="separator:a66a9857b35a25e766eda6fb149fb9134"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af016e2a9451f4692a56bec5209ddbaf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#af016e2a9451f4692a56bec5209ddbaf5">MinusEqualsUnchecked</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I_BP_E)</td></tr>
<tr class="memdesc:af016e2a9451f4692a56bec5209ddbaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a rotational inertia <code>I_BP_E</code> from <code>this</code> rotational inertia.  <a href="#af016e2a9451f4692a56bec5209ddbaf5">More...</a><br /></td></tr>
<tr class="separator:af016e2a9451f4692a56bec5209ddbaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a82936d10a31afe3ae91f3025a39d3224"><td class="memTemplParams" colspan="2">template&lt;typename &gt; </td></tr>
<tr class="memitem:a82936d10a31afe3ae91f3025a39d3224"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a82936d10a31afe3ae91f3025a39d3224">RotationalInertia</a></td></tr>
<tr class="separator:a82936d10a31afe3ae91f3025a39d3224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0f659ca0d1286108f3238040cea74a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a5c0f659ca0d1286108f3238040cea74a">operator *</a> (const T &amp;nonnegative_scalar, const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I_BP_E)</td></tr>
<tr class="memdesc:a5c0f659ca0d1286108f3238040cea74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a nonnegative scalar (&gt;= 0) by the rotational inertia <code>I_BP_E</code>.  <a href="#a5c0f659ca0d1286108f3238040cea74a">More...</a><br /></td></tr>
<tr class="separator:a5c0f659ca0d1286108f3238040cea74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ac917bf1dfed2a1cfe26be9d258285a2d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac917bf1dfed2a1cfe26be9d258285a2d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ac917bf1dfed2a1cfe26be9d258285a2d">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I)</td></tr>
<tr class="memdesc:ac917bf1dfed2a1cfe26be9d258285a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an instance of <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class describes the mass distribution (inertia properties) of a body or composite body about a p...">RotationalInertia</a> into a std::ostream.  <a href="#ac917bf1dfed2a1cfe26be9d258285a2d">More...</a><br /></td></tr>
<tr class="separator:ac917bf1dfed2a1cfe26be9d258285a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a719e23ae8c26b0c8cf0c7f30dd112559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719e23ae8c26b0c8cf0c7f30dd112559">&#9670;&nbsp;</a></span>RotationalInertia() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a87e215bccd4ce720b787f8b5195a7551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e215bccd4ce720b787f8b5195a7551">&#9670;&nbsp;</a></span>RotationalInertia() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3ffc4a4e197a2a2155641d75c2a7c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ffc4a4e197a2a2155641d75c2a7c49">&#9670;&nbsp;</a></span>RotationalInertia() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a rotational inertia that has all its moments/products of inertia equal to NaN (helps quickly detect uninitialized values). </p>

</div>
</div>
<a id="af36dbdaa401764e4df48b07d3b6ad7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36dbdaa401764e4df48b07d3b6ad7d4">&#9670;&nbsp;</a></span>RotationalInertia() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Ixx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Iyy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Izz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a rotational inertia with moments of inertia <code>Ixx</code>, <code>Iyy</code>, <code>Izz</code>, and with each product of inertia set to zero. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if not <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a319d6a0feeb306267605332cdd1906d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319d6a0feeb306267605332cdd1906d6">&#9670;&nbsp;</a></span>RotationalInertia() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Ixx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Iyy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Izz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Ixy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Ixz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Iyz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a rotational inertia with moments of inertia <code>Ixx</code>, <code>Iyy</code>, <code>Izz</code>, and with products of inertia <code>Ixy</code>, <code>Ixz</code>, <code>Iyz</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if not <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73ee8d395f9f46a1086071be0faa8e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ee8d395f9f46a1086071be0faa8e37">&#9670;&nbsp;</a></span>RotationalInertia() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_PQ_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a rotational inertia for a particle Q of mass <code>mass</code>, whose position vector from about-point P is p_PQ_E (E is expressed-in frame). </p>
<p>This std::logic_error exception only occurs if <code>mass</code> &lt; 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mass</td><td>The mass of particle Q. </td></tr>
    <tr><td class="paramname">p_PQ_E</td><td>Position from about-point P to Q, expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">I_QP_E,Q's</td><td>rotational inertia about-point P expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Negating the position vector p_PQ_E has no affect on the result. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if not <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3751c9eaa974909523b6d8d3fd0833a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3751c9eaa974909523b6d8d3fd0833a8">&#9670;&nbsp;</a></span>CalcMaximumPossibleMomentOfInertia()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T CalcMaximumPossibleMomentOfInertia </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum possible moment of inertia for <code>this</code> rotational inertia about-point P for any expressed-in frame E. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The maximum moment Imax has range: trace / 3 &lt;= Imax &lt;= trace / 2. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a23798f37ae600d4d79b8a2e71586c4c7" title="Returns a rotational inertia&#39;s trace (i.e., Ixx + Iyy + Izz, the sum of the diagonal elements of the ...">Trace()</a> </dd></dl>

</div>
</div>
<a id="a0e13800a4b7f21903141dbe4c0102720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e13800a4b7f21903141dbe4c0102720">&#9670;&nbsp;</a></span>CalcPrincipalMomentsAndAxesOfInertia()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;, <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; CalcPrincipalMomentsAndAxesOfInertia </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forms the 3 principal moments of inertia and their 3 associated principal directions for <code>this</code> rotational inertia. </p>
<dl class="section return"><dt>Returns</dt><dd>3 principal moments of inertia [Ixx Iyy Izz], sorted in ascending order (Ixx ≤ Iyy ≤ Izz) and a rotation matrix R_EP whose columns are the 3 associated principal directions that relate the expressed-in frame E to a frame P, where frame E is the expressed-in frame for <code>this</code> rotational inertia I_BPo_E (body B's rotational inertia about-point Po) and frame P contains right-handed orthonormal vectors Px, Py, Pz. The 1ˢᵗ column of R_EP is Px_E (Px expressed in frame E) which is parallel to the principal axis associated with Ixx (the smallest principal moment of inertia). Similarly, the 2ⁿᵈ and 3ʳᵈ columns of R_EP are Py_E and Pz_E, which are parallel to principal axes associated with Iyy and Izz (the intermediate and largest principal moments of inertia). If all principal moments of inertia are equal (i.e., Ixx = Iyy = Izz), R_EP is the identity matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the elements of <code>this</code> rotational inertia cannot be converted to a real finite double. For example, an exception is thrown if <code>this</code> contains an erroneous NaN or if scalar type T is symbolic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a6b63ae12f2b1cc131b2584efe07a2b6b" title="Forms the 3 principal moments of inertia for this rotational inertia.">CalcPrincipalMomentsOfInertia()</a> to calculate the principal moments of inertia [Ixx Iyy Izz], without calculating the principal directions. </dd></dl>

</div>
</div>
<a id="a6b63ae12f2b1cc131b2584efe07a2b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b63ae12f2b1cc131b2584efe07a2b6b">&#9670;&nbsp;</a></span>CalcPrincipalMomentsOfInertia()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; CalcPrincipalMomentsOfInertia </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forms the 3 principal moments of inertia for <code>this</code> rotational inertia. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>3 principal moments of inertia [Imin Imed Imax], sorted in ascending order (Imin ≤ Imed ≤ Imax). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the elements of <code>this</code> rotational inertia cannot be converted to a real finite double. For example, an exception is thrown if <code>this</code> contains an erroneous NaN or if scalar type T is symbolic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a0e13800a4b7f21903141dbe4c0102720" title="Forms the 3 principal moments of inertia and their 3 associated principal directions for this rotatio...">CalcPrincipalMomentsAndAxesOfInertia()</a> to also calculate principal moment of inertia directions associated with <code>this</code> rotational inertia. </dd></dl>

</div>
</div>
<a id="afa1e01c37486db2e78263fb70eaff550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1e01c37486db2e78263fb70eaff550">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;Scalar&gt; cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new RotationalInertia object templated on <code>Scalar</code> initialized from the values of <code>this</code> rotational inertia's entries. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type on which the new rotational inertia will be templated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class describes the mass distribution (inertia properties) of a body or composite body about a p...">RotationalInertia</a>&lt;From&gt;::cast&lt;To&gt;()</code> creates a new <code><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class describes the mass distribution (inertia properties) of a body or composite body about a p...">RotationalInertia</a>&lt;To&gt;</code> from a <code><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class describes the mass distribution (inertia properties) of a body or composite body about a p...">RotationalInertia</a>&lt;From&gt;</code> but only if type <code>To</code> is constructible from type <code>From</code>. This cast method works in accordance with Eigen's cast method for Eigen's Matrix3 that underlies this RotationalInertia. For example, Eigen currently allows cast from type double to AutoDiffXd, but not vice-versa. </dd></dl>

</div>
</div>
<a id="a8509d6f7951179378f848f5f4cc37720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8509d6f7951179378f848f5f4cc37720">&#9670;&nbsp;</a></span>cols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For consistency with Eigen's API, the <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a8509d6f7951179378f848f5f4cc37720" title="For consistency with Eigen&#39;s API, the cols() method returns 3.">cols()</a> method returns 3. </p>

</div>
</div>
<a id="af38985b256018ac664935ee8423bbe8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38985b256018ac664935ee8423bbe8b">&#9670;&nbsp;</a></span>CopyToFullMatrix3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a3922cc0c6264e8ff225a6aa0dd993667">Matrix3</a>&lt;T&gt; CopyToFullMatrix3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a full 3x3 matrix copy of this rotational inertia. </p>
<p>The returned copy is symmetric and includes both lower and upper parts of the matrix. </p>

</div>
</div>
<a id="a03e71eb4bd2a7648a411e1cbaf94812b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e71eb4bd2a7648a411e1cbaf94812b">&#9670;&nbsp;</a></span>CouldBePhysicallyValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; CouldBePhysicallyValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs several necessary checks to verify whether <code>this</code> rotational inertia <em>could</em> be physically valid, including: </p>
<ul>
<li>No NaN moments or products of inertia.</li>
<li>Ixx, Iyy, Izz and principal moments are all non-negative.</li>
<li>Ixx, Iyy Izz and principal moments satisfy the triangle inequality:<ul>
<li><code>Ixx + Iyy &gt;= Izz</code></li>
<li><code>Ixx + Izz &gt;= Iyy</code></li>
<li><code>Iyy + Izz &gt;= Ixx</code></li>
</ul>
</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>These checks are necessary (but NOT sufficient) conditions for a rotational inertia to be physically valid. The sufficient condition requires a rotational inertia to satisfy the above checks <em>after</em> <code>this</code> is shifted to the center of mass, i.e., the sufficient condition requires calling <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a> when the about-point is Bcm (the body's center of mass). Note: this class does not know its about-point or its center of mass location.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> for a plausible rotational inertia passing the above necessary but insufficient checks and <code>false</code> otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if principal moments of inertia cannot be calculated (eigenvalue solver) or if scalar type T cannot be converted to a double. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63faf9877a005bf08269b508f2d17b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63faf9877a005bf08269b508f2d17b42">&#9670;&nbsp;</a></span>get_moments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt; get_moments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns 3-element vector with moments of inertia [Ixx, Iyy, Izz]. </p>

</div>
</div>
<a id="a73703796210df51bb25acbb19168913a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73703796210df51bb25acbb19168913a">&#9670;&nbsp;</a></span>get_products()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt; get_products </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns 3-element vector with products of inertia [Ixy, Ixz, Iyz]. </p>

</div>
</div>
<a id="a1a73339c4b21bba9c3fa975f7a6c4220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a73339c4b21bba9c3fa975f7a6c4220">&#9670;&nbsp;</a></span>IsNaN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if any moment/product in <code>this</code> rotational inertia is NaN. </p>
<p>Otherwise returns <code>false</code>. </p>

</div>
</div>
<a id="a0546b3ac658fccec61a5156a926765dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0546b3ac658fccec61a5156a926765dd">&#9670;&nbsp;</a></span>IsNearlyEqualTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsNearlyEqualTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>precision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares <code>this</code> rotational inertia to <code>other</code> rotational inertia within the specified <code>precision</code> (which is a dimensionless number specifying the relative precision to which the comparison is performed). </p>
<p>Denoting <code>I_maxA</code> as the largest element value that can appear in a valid <code>this</code> rotational inertia (independent of the expressed-in frame E) and denoting <code>I_maxB</code> as the largest element value that can appear in a valid <code>other</code> rotational inertia (independent of the expressed-in frame E), <code>this</code> and <code>other</code> are considered nearly equal to each other, if: ‖this - other‖∞ &lt; precision * min(I_maxA, I_maxB)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Rotational inertia to compare with <code>this</code> rotational inertia. </td></tr>
    <tr><td class="paramname">precision</td><td>is a dimensionless real positive number that is usually based on two factors, namely expected accuracy of moments/products of inertia (e.g., from end-user or CAD) and/or machine-precision. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the absolute value of each moment/product of inertia in <code>this</code> is within <code>epsilon</code> of the corresponding moment/ product absolute value in <code>other</code>. Otherwise returns <code>false</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>: This method only works if all moments of inertia with scalar type T in <code>this</code> and <code>other</code> can be converted to a double (discarding supplemental scalar data such as derivatives of an AutoDiffXd). It fails at runtime if type T cannot be converted to <code>double</code>. </dd></dl>

</div>
</div>
<a id="a55630ea16dd7fcd906f2c9d9db36bb66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55630ea16dd7fcd906f2c9d9db36bb66">&#9670;&nbsp;</a></span>IsZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if all moments and products of inertia are exactly zero. </p>

</div>
</div>
<a id="a66a9857b35a25e766eda6fb149fb9134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a9857b35a25e766eda6fb149fb9134">&#9670;&nbsp;</a></span>MakeFromMomentsAndProductsOfInertia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; MakeFromMomentsAndProductsOfInertia </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Ixx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Iyy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Izz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Ixy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Ixz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Iyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_validity_check</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Internal use only) Creates a rotational inertia with moments of inertia Ixx, Iyy, Izz, and with products of inertia Ixy, Ixz, Iyz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Ixx,Iyy,Izz</td><td>Moments of inertia. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ixy,Ixz,Iyz</td><td>Products of inertia. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">skip_validity_check</td><td>If set to false, the rotational inertia is checked via <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a> to ensure it is physically valid. If set to true (not generally recommended), the check is skipped (which reduces some computational cost). The default value is false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if skip_validity_check is false and <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a> fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af016e2a9451f4692a56bec5209ddbaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af016e2a9451f4692a56bec5209ddbaf5">&#9670;&nbsp;</a></span>MinusEqualsUnchecked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt;&amp; MinusEqualsUnchecked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>I_BP_E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts a rotational inertia <code>I_BP_E</code> from <code>this</code> rotational inertia. </p>
<p>No check is done to determine if the result is physically valid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I_BP_E</td><td>Rotational inertia of a body (or composite body) B to be subtracted from <code>this</code> rotational inertia. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> rotational inertia. <code>this</code> changes since rotational inertia <code>I_BP_E</code> has been subtracted from it. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#aaff3c0d26ee10bb5d824ee6d3498eb4d" title="Subtracts a rotational inertia I_BP_E from this rotational inertia.">operator-()</a>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This operator may produce an invalid rotational inertia. Use <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a9616b9b963139066953c80ac978c362a" title="Subtracts a rotational inertia I_BP_E from this rotational inertia.">operator-=()</a> to perform necessary (but insufficient) checks on the physical validity of the resulting rotational inertia. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>: Although this method is mathematically useful, it may result in a rotational inertia that is physically invalid. This method helps perform intermediate calculations which do not necessarily represent a real rotational inertia. For example, an efficient way to shift a rotational inertia from an arbitrary point P to an arbitrary point Q is mathematical equivalent to a + (b - c). Although <code>a</code> must be physically valid and the result <code>a + (b - c)</code> must be physically valid, the intermediate quantity (b - c) is not necessarily physically valid. This method allows (b - c) to be calculated without requiring (b - c) to be physically valid. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a9616b9b963139066953c80ac978c362a" title="Subtracts a rotational inertia I_BP_E from this rotational inertia.">operator-=()</a>. </dd></dl>

</div>
</div>
<a id="a0393e660bf996a3937e40ef2dc3e6757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0393e660bf996a3937e40ef2dc3e6757">&#9670;&nbsp;</a></span>MultiplyByScalarSkipValidityCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; MultiplyByScalarSkipValidityCheck </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Multiplies a rotational inertia by a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Scalar which multiplies <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>this</code> rotational inertia multiplied by <code>s</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a5c0f659ca0d1286108f3238040cea74a" title="Multiplies a nonnegative scalar (&gt;= 0) by the rotational inertia I_BP_E.">operator*(const T&amp;, const RotationalInertia&lt;T&gt;&amp;)</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method works even if <code>s</code> is negative or <code>this</code> is invalid. This method is useful for error messages associated with an invalid inertia. </dd></dl>

</div>
</div>
<a id="a6ad677024790190d7f913839cbdf0902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad677024790190d7f913839cbdf0902">&#9670;&nbsp;</a></span>operator *() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; operator * </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>nonnegative_scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies <code>this</code> rotational inertia by a nonnegative scalar (&gt;= 0). </p>
<p>In debug builds, throws std::exception if <code>nonnegative_scalar</code> &lt; 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nonnegative_scalar</td><td>Nonnegative scalar which multiplies <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>this</code> rotational inertia multiplied by <code>nonnegative_scalar</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a772d06048b8ada1e80045b45a32e51f0" title="Multiplies this rotational inertia by a nonnegative scalar (&gt;= 0).">operator*=()</a>, <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a5c0f659ca0d1286108f3238040cea74a" title="Multiplies a nonnegative scalar (&gt;= 0) by the rotational inertia I_BP_E.">operator*(const T&amp;, const RotationalInertia&lt;T&gt;&amp;)</a> </dd></dl>

</div>
</div>
<a id="a275b3628b6e487b99b5a26b40e7c9454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a275b3628b6e487b99b5a26b40e7c9454">&#9670;&nbsp;</a></span>operator *() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt; operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>w_E</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies <code>this</code> rotational inertia about-point P, expressed-in frame E by the vector w_E (which <em>must</em> also have the same expressed-in frame E). </p>
<dl class="section note"><dt>Note</dt><dd>This calculation is equivalent to regarding <code>this</code> rotational inertia as an inertia dyadic and dot-multiplying it by w_E. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w_E</td><td>Vector to post-multiply with <code>this</code> rotational inertia. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Vector that results from multiplying <code>this</code> by <code>w_E</code>. </dd></dl>

</div>
</div>
<a id="a772d06048b8ada1e80045b45a32e51f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772d06048b8ada1e80045b45a32e51f0">&#9670;&nbsp;</a></span>operator *=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt;&amp; operator *= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>nonnegative_scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies <code>this</code> rotational inertia by a nonnegative scalar (&gt;= 0). </p>
<p>In debug builds, throws std::exception if <code>nonnegative_scalar</code> &lt; 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nonnegative_scalar</td><td>Nonnegative scalar which multiplies <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> rotational inertia. <code>this</code> changes since <code>this</code> has been multiplied by <code>nonnegative_scalar</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a6ad677024790190d7f913839cbdf0902" title="Multiplies this rotational inertia by a nonnegative scalar (&gt;= 0).">operator*()</a>, <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a5c0f659ca0d1286108f3238040cea74a" title="Multiplies a nonnegative scalar (&gt;= 0) by the rotational inertia I_BP_E.">operator*(const T&amp;, const RotationalInertia&lt;T&gt;&amp;)</a>. </dd></dl>

</div>
</div>
<a id="afae48d85764cacfd54fc3001250b4eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae48d85764cacfd54fc3001250b4eac">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const access to the <code>(i, j)</code> element of this rotational inertia. </p>
<dl class="section remark"><dt>Remarks</dt><dd>A mutable version of operator() is intentionally absent so as to prevent an end-user from directly setting elements. This prevents the creation of a non-physical (or non-symmetric) rotational inertia. </dd></dl>

</div>
</div>
<a id="ab3b4714f1ad30911025024f1eda4d72e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b4714f1ad30911025024f1eda4d72e">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>I_BP_E</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a rotational inertia <code>I_BP_E</code> to <code>this</code> rotational inertia. </p>
<p>This method requires both rotational inertias (<code>I_BP_E</code> and <code>this</code>) to have the same about-point P and the same expressed-in frame E. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I_BP_E</td><td>Rotational inertia of a body (or composite body) B to be added to <code>this</code> rotational inertia. <code>I_BP_E</code> and <code>this</code> must have the same about-point P and expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of <code>this</code> rotational inertia and <code>I_BP_E</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a22d65a4cd4dd6105398ee79ad825035f" title="Adds a rotational inertia I_BP_E to this rotational inertia.">operator+=()</a>. </dd></dl>

</div>
</div>
<a id="a22d65a4cd4dd6105398ee79ad825035f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d65a4cd4dd6105398ee79ad825035f">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>I_BP_E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a rotational inertia <code>I_BP_E</code> to <code>this</code> rotational inertia. </p>
<p>This method requires both rotational inertias (<code>I_BP_E</code> and <code>this</code>) to have the same about-point P and the same expressed-in frame E. The += operator updates <code>this</code> so <code>I_BP_E</code> is added to <code>this</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I_BP_E</td><td>Rotational inertia of a body (or composite body) B to be added to <code>this</code> rotational inertia. <code>I_BP_E</code> and <code>this</code> must have the same about-point P and expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> rotational inertia. <code>this</code> changes since rotational inertia <code>I_BP_E</code> has been added to it. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ab3b4714f1ad30911025024f1eda4d72e" title="Adds a rotational inertia I_BP_E to this rotational inertia.">operator+()</a>. </dd></dl>

</div>
</div>
<a id="aaff3c0d26ee10bb5d824ee6d3498eb4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff3c0d26ee10bb5d824ee6d3498eb4d">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>I_BP_E</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts a rotational inertia <code>I_BP_E</code> from <code>this</code> rotational inertia. </p>
<p>This method requires both rotational inertias (<code>I_BP_E</code> and <code>this</code>) to have the same about-point P and the same expressed-in frame E. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I_BP_E</td><td>Rotational inertia of a body (or composite body) B to be subtracted from <code>this</code> rotational inertia. <code>I_BP_E</code> and <code>this</code> must have the same about-point P and expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The subtraction of <code>I_BP_E</code> from <code>this</code> rotational inertia. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if not <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a9616b9b963139066953c80ac978c362a" title="Subtracts a rotational inertia I_BP_E from this rotational inertia.">operator-=()</a>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>See warning and documentation for <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a9616b9b963139066953c80ac978c362a" title="Subtracts a rotational inertia I_BP_E from this rotational inertia.">operator-=()</a>. </dd></dl>

</div>
</div>
<a id="a9616b9b963139066953c80ac978c362a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9616b9b963139066953c80ac978c362a">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>I_BP_E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts a rotational inertia <code>I_BP_E</code> from <code>this</code> rotational inertia. </p>
<p>This method requires both rotational inertias (<code>I_BP_E</code> and <code>this</code>) to have the same about-point P and the same expressed-in frame E. The -= operator updates <code>this</code> so <code>I_BP_E</code> is subtracted from <code>this</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I_BP_E</td><td>Rotational inertia of a body (or composite body) B to be subtracted from <code>this</code> rotational inertia. <code>I_BP_E</code> and <code>this</code> must have the same about-point P and expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> rotational inertia. <code>this</code> changes since rotational inertia <code>I_BP_E</code> has been subtracted from it. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if not <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#aaff3c0d26ee10bb5d824ee6d3498eb4d" title="Subtracts a rotational inertia I_BP_E from this rotational inertia.">operator-()</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This subtract operator is useful for computing rotational inertia of a body with a hole. First the rotational inertia of a fully solid body S (without the hole) is calculated, then the rotational inertia of the hole (treated as a massive solid body B) is calculated. The rotational inertia of a composite body C (comprised of S and -B) is computed by subtracting B's rotational inertia from S's rotational inertia. </dd></dl>

</div>
</div>
<a id="a7a0d8c42739dc16a87225c2b0057517b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0d8c42739dc16a87225c2b0057517b">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>positive_scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides <code>this</code> rotational inertia by a positive scalar(&gt; 0). </p>
<p>In debug builds, throws std::exception if <code>positive_scalar</code> &lt;= 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positive_scalar</td><td>Positive scalar (&gt; 0) which divides <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>this</code> rotational inertia divided by <code>positive_scalar</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a3cb6014636db3579a84defd7824ee4c1" title="Divides this rotational inertia by a positive scalar (&gt; 0).">operator/=()</a>. </dd></dl>

</div>
</div>
<a id="a3cb6014636db3579a84defd7824ee4c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb6014636db3579a84defd7824ee4c1">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt;&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>positive_scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides <code>this</code> rotational inertia by a positive scalar (&gt; 0). </p>
<p>In debug builds, throws std::exception if <code>positive_scalar</code> &lt;= 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positive_scalar</td><td>Positive scalar (&gt; 0) which divides <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> rotational inertia. <code>this</code> changes since <code>this</code> has been divided by <code>positive_scalar</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a7a0d8c42739dc16a87225c2b0057517b" title="Divides this rotational inertia by a positive scalar(&gt; 0).">operator/()</a>. </dd></dl>

</div>
</div>
<a id="ac25060922d76f06276ac5f169e748ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25060922d76f06276ac5f169e748ebd">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab78d207e550d7d227b7e7f37557fb66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78d207e550d7d227b7e7f37557fb66a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08eb5284c5ec57a645aee167798a1f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08eb5284c5ec57a645aee167798a1f2c">&#9670;&nbsp;</a></span>ReExpress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; ReExpress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_AE</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-expresses <code>this</code> rotational inertia <code>I_BP_E</code> to <code>I_BP_A</code> i.e., re-expresses body B's rotational inertia from frame E to frame A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R_AE</td><td>RotationMatrix relating frames A and E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">I_BP_A</td><td>Rotational inertia of B about-point P expressed-in frame A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if the rotational inertia that is re-expressed-in frame A violates <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a800af438924a7ab6a1eeaf5a58865f28" title="Re-expresses this rotational inertia I_BP_E in place to I_BP_A.">ReExpressInPlace()</a> </dd></dl>

</div>
</div>
<a id="a800af438924a7ab6a1eeaf5a58865f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800af438924a7ab6a1eeaf5a58865f28">&#9670;&nbsp;</a></span>ReExpressInPlace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp; ReExpressInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_AE</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-expresses <code>this</code> rotational inertia <code>I_BP_E</code> in place to <code>I_BP_A</code>. </p>
<p>In other words, starts with <code>this</code> rotational inertia of a body (or composite body) B about-point P expressed-in frame E and re-expresses to B's rotational inertia about-point P expressed-in frame A. More concisely, we compute <code>I_BP_A = R_AE * I_BP_E * (R_AE)ᵀ</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R_AE</td><td>RotationMatrix relating frames A and E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> rotational inertia about-point P, but with <code>this</code> now expressed in frame A (instead of frame E). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if the rotational inertia that is re-expressed-in frame A violates <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a08eb5284c5ec57a645aee167798a1f2c" title="Re-expresses this rotational inertia I_BP_E to I_BP_A i.e., re-expresses body B&#39;s rotational inertia ...">ReExpress()</a>. </dd></dl>

</div>
</div>
<a id="ad107abcacb84cbabb41b87ba81360f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad107abcacb84cbabb41b87ba81360f91">&#9670;&nbsp;</a></span>rows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For consistency with Eigen's API, the <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#ad107abcacb84cbabb41b87ba81360f91" title="For consistency with Eigen&#39;s API, the rows() method returns 3.">rows()</a> method returns 3. </p>

</div>
</div>
<a id="ae461fd75b1b4eba6c95a57621adb4e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae461fd75b1b4eba6c95a57621adb4e9d">&#9670;&nbsp;</a></span>SetToNaN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetToNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <code>this</code> rotational inertia so all its elements are equal to NaN. </p>
<p>This helps quickly detect uninitialized moments/products of inertia. </p>

</div>
</div>
<a id="ae57e5aca5db002545e4b9335c8d9dbfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57e5aca5db002545e4b9335c8d9dbfa">&#9670;&nbsp;</a></span>SetZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <code>this</code> rotational inertia so all its moments/products of inertia are zero, e.g., for convenient initialization before a computation or for inertia calculations involving a particle (point-mass). </p>
<p>Note: Real 3D massive physical objects have non-zero moments of inertia. </p>

</div>
</div>
<a id="a5a6d68bf65261dba0c10a00174fed83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6d68bf65261dba0c10a00174fed83c">&#9670;&nbsp;</a></span>ShiftFromCenterOfMass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; ShiftFromCenterOfMass </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BcmQ_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the rotational inertia that results from shifting <code>this</code> rotational inertia for a body (or composite body) B from about-point Bcm (B's center of mass) to about-point Q. </p>
<p>I.e., shifts <code>I_BBcm_E</code> to <code>I_BQ_E</code> (both are expressed-in frame E). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mass</td><td>The mass of body (or composite body) B. </td></tr>
    <tr><td class="paramname">p_BcmQ_E</td><td>Position vector from Bcm to Q, expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">I_BQ_E</td><td>B's rotational inertia about-point Q expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if the rotational inertia that is shifted to about-point Q violates <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Negating the position vector p_BcmQ_E has no affect on the result. </dd></dl>

</div>
</div>
<a id="a233d049441510e6de4347afa89eff0e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233d049441510e6de4347afa89eff0e0">&#9670;&nbsp;</a></span>ShiftFromCenterOfMassInPlace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt;&amp; ShiftFromCenterOfMassInPlace </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BcmQ_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts <code>this</code> rotational inertia for a body (or composite body) B from about-point Bcm (B's center of mass) to about-point Q. </p>
<p>I.e., shifts <code>I_BBcm_E</code> to <code>I_BQ_E</code> (both are expressed-in frame E). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mass</td><td>The mass of body (or composite body) B. </td></tr>
    <tr><td class="paramname">p_BcmQ_E</td><td>Position vector from Bcm to Q, expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> rotational inertia expressed-in frame E, but with <code>this</code> shifted from about-point Bcm to about-point Q. i.e., returns I_BQ_E, B's rotational inertia about-point Bcm expressed-in frame E. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if the rotational inertia that is shifted to about-point Q violates <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Negating the position vector p_BcmQ_E has no affect on the result. </dd></dl>

</div>
</div>
<a id="aef27cf48918c4ca310e1e5d67de50f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef27cf48918c4ca310e1e5d67de50f7a">&#9670;&nbsp;</a></span>ShiftToCenterOfMass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; ShiftToCenterOfMass </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_QBcm_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the rotational inertia that results from shifting <code>this</code> rotational inertia for a body (or composite body) B from about-point Q to about-point <code>Bcm</code> (B's center of mass). </p>
<p>I.e., shifts <code>I_BQ_E</code> to <code>I_BBcm_E</code> (both are expressed-in frame E). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mass</td><td>The mass of body (or composite body) B. </td></tr>
    <tr><td class="paramname">p_QBcm_E</td><td>Position vector from Q to <code>Bcm</code>, expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">I_BBcm_E</td><td>B's rotational inertia about-point <code>Bcm</code> expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if the rotational inertia that is shifted to about-point <code>Bcm</code> violates <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Negating the position vector <code>p_QBcm_E</code> has no affect on the result. </dd></dl>

</div>
</div>
<a id="a82a43d32c412efc0f5e1b6ccc1b1cc17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a43d32c412efc0f5e1b6ccc1b1cc17">&#9670;&nbsp;</a></span>ShiftToCenterOfMassInPlace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt;&amp; ShiftToCenterOfMassInPlace </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_QBcm_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts <code>this</code> rotational inertia for a body (or composite body) B from about-point Q to about-point <code>Bcm</code> (B's center of mass). </p>
<p>I.e., shifts <code>I_BQ_E</code> to <code>I_BBcm_E</code> (both are expressed-in frame E). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mass</td><td>The mass of body (or composite body) B. </td></tr>
    <tr><td class="paramname">p_QBcm_E</td><td>Position vector from Q to <code>Bcm</code>, expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> rotational inertia expressed-in frame E, but with <code>this</code> shifted from about-point Q to about-point <code>Bcm</code>, i.e., returns <code>I_BBcm_E</code>, B's rotational inertia about-point <code>Bcm</code> expressed-in frame E. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if the rotational inertia that is shifted to about-point <code>Bcm</code> violates <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Negating the position vector <code>p_QBcm_E</code> has no affect on the result. </dd></dl>

</div>
</div>
<a id="afa36a24a9c8fa583631e45d1ad366ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa36a24a9c8fa583631e45d1ad366ce3">&#9670;&nbsp;</a></span>ShiftToThenAwayFromCenterOfMass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; ShiftToThenAwayFromCenterOfMass </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_PBcm_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_QBcm_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the rotational inertia that results from shifting <code>this</code> rotational inertia for a body (or composite body) B from about-point P to about-point Q via Bcm (B's center of mass). </p>
<p>I.e., shifts <code>I_BP_E</code> to <code>I_BQ_E</code> (both are expressed-in frame E). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mass</td><td>The mass of body (or composite body) B. </td></tr>
    <tr><td class="paramname">p_PBcm_E</td><td>Position vector from P to Bcm, expressed-in frame E. </td></tr>
    <tr><td class="paramname">p_QBcm_E</td><td>Position vector from Q to Bcm, expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">I_BQ_E,B's</td><td>rotational inertia about-point Q expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if the rotational inertia that is shifted to about-point Q violates <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Negating either (or both) position vectors p_PBcm_E and p_QBcm_E has no affect on the result. </dd></dl>

</div>
</div>
<a id="a631d7db4d8c28e6108d78b8309dabc2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631d7db4d8c28e6108d78b8309dabc2b">&#9670;&nbsp;</a></span>ShiftToThenAwayFromCenterOfMassInPlace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt;&amp; ShiftToThenAwayFromCenterOfMassInPlace </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_PBcm_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_QBcm_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shifts <code>this</code> rotational inertia for a body (or composite body) B from about-point P to about-point Q via Bcm (B's center of mass). </p>
<p>I.e., shifts <code>I_BP_E</code> to <code>I_BQ_E</code> (both are expressed-in frame E). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mass</td><td>The mass of body (or composite body) B. </td></tr>
    <tr><td class="paramname">p_PBcm_E</td><td>Position vector from P to Bcm, expressed-in frame E. </td></tr>
    <tr><td class="paramname">p_QBcm_E</td><td>Position vector from Q to Bcm, expressed-in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> rotational inertia expressed-in frame E, but with <code>this</code> shifted from about-point P to about-point Q, i.e., returns I_BQ_E, B's rotational inertia about-point Q expressed-in frame E. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for Debug builds if the rotational inertia that is shifted to about-point Q violates <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">CouldBePhysicallyValid()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Negating either (or both) position vectors p_PBcm_E and p_QBcm_E has no affect on the result. </dd>
<dd>
This method is more efficient (by 6 multiplications) than first shifting to the center of mass, then shifting away, e.g., as (<a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a82a43d32c412efc0f5e1b6ccc1b1cc17" title="Shifts this rotational inertia for a body (or composite body) B from about-point Q to about-point Bcm...">ShiftToCenterOfMassInPlace()</a>).<a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a233d049441510e6de4347afa89eff0e0" title="Shifts this rotational inertia for a body (or composite body) B from about-point Bcm (B&#39;s center of m...">ShiftFromCenterOfMassInPlace()</a>; </dd></dl>

</div>
</div>
<a id="a23798f37ae600d4d79b8a2e71586c4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23798f37ae600d4d79b8a2e71586c4c7">&#9670;&nbsp;</a></span>Trace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T Trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a rotational inertia's trace (i.e., Ixx + Iyy + Izz, the sum of the diagonal elements of the inertia matrix). </p>
<p>The trace happens to be invariant to its expressed-in frame (i.e., the trace does not depend on the frame in which it is expressed). The trace is useful because the largest moment of inertia Imax has range: trace / 3 &lt;= Imax &lt;= trace / 2, and the largest possible product of inertia must be &lt;= Imax / 2. Hence, trace / 3 and trace / 2 give a lower and upper bound on the largest possible element that can be in a valid rotational inertia. </p>

</div>
</div>
<a id="a96949d335bfe501c62587705d47ce6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96949d335bfe501c62587705d47ce6ad">&#9670;&nbsp;</a></span>TriaxiallySymmetric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; TriaxiallySymmetric </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>I_triaxial</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a rotational inertia with equal moments of inertia along its diagonal and with each product of inertia set to zero. </p>
<p>This factory is useful for the rotational inertia of a uniform-density sphere or cube. In debug builds, throws std::exception if I_triaxial is negative/NaN. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a5c0f659ca0d1286108f3238040cea74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0f659ca0d1286108f3238040cea74a">&#9670;&nbsp;</a></span>operator *</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; operator * </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>nonnegative_scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>I_BP_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies a nonnegative scalar (&gt;= 0) by the rotational inertia <code>I_BP_E</code>. </p>
<p>In debug builds, throws std::exception if <code>nonnegative_scalar</code> &lt; 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nonnegative_scalar</td><td>Nonnegative scalar which multiplies <code>I_BP_E</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>nonnegative_scalar</code> multiplied by rotational inertia <code>I_BP_E</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a772d06048b8ada1e80045b45a32e51f0" title="Multiplies this rotational inertia by a nonnegative scalar (&gt;= 0).">operator*=()</a>, <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a6ad677024790190d7f913839cbdf0902" title="Multiplies this rotational inertia by a nonnegative scalar (&gt;= 0).">operator*()</a> </dd></dl>
<p>Multiplication of a scalar with a rotational matrix is commutative. </p>

</div>
</div>
<a id="ac917bf1dfed2a1cfe26be9d258285a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac917bf1dfed2a1cfe26be9d258285a2d">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes an instance of <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class describes the mass distribution (inertia properties) of a body or composite body about a p...">RotationalInertia</a> into a std::ostream. </p>

</div>
</div>
<a id="a82936d10a31afe3ae91f3025a39d3224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82936d10a31afe3ae91f3025a39d3224">&#9670;&nbsp;</a></span>RotationalInertia</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/multibody/tree/<a class="el" href="rotational__inertia_8h.html">rotational_inertia.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- footer -->
<div id="nav-path" class="navpath">
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a></li>
  </ul>
</div>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().value = searchBox.searchLabel;
</script>
</body>
</html>
