<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: MathematicalProgramResult Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1solvers_1_1_mathematical_program_result.html','','classdrake_1_1solvers_1_1_mathematical_program_result-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">MathematicalProgramResult Class Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The result returned by MathematicalProgram::Solve(). </p>
<p>It stores the <a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">solvers::SolutionResult</a> (whether the program is solved to optimality, detected infeasibility, etc), the optimal value for the decision variables, the optimal cost, and solver specific details. </p>
</div>
<p><code>#include &lt;drake/solvers/mathematical_program_result.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4fd3b5095ed206da42f1451c5dd426c5" id="r_a4fd3b5095ed206da42f1451c5dd426c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fd3b5095ed206da42f1451c5dd426c5">MathematicalProgramResult</a> ()</td></tr>
<tr class="memdesc:a4fd3b5095ed206da42f1451c5dd426c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the result.  <br /></td></tr>
<tr class="memitem:ab69f22a0b39aa76226e1a7a1c357cced" id="r_ab69f22a0b39aa76226e1a7a1c357cced"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab69f22a0b39aa76226e1a7a1c357cced">is_success</a> () const</td></tr>
<tr class="memdesc:ab69f22a0b39aa76226e1a7a1c357cced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the optimization problem is solved successfully; false otherwise.  <br /></td></tr>
<tr class="memitem:a8454ba31b3b8d0dcf68140e63b8333fe" id="r_a8454ba31b3b8d0dcf68140e63b8333fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8454ba31b3b8d0dcf68140e63b8333fe">set_decision_variable_index</a> (std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, int &gt; decision_variable_index)</td></tr>
<tr class="memdesc:a8454ba31b3b8d0dcf68140e63b8333fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets decision_variable_index mapping, that maps each decision variable to its index in the aggregated vector containing all decision variables in <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <br /></td></tr>
<tr class="memitem:aa41491a390f5a69b27ebf76646d0fe40" id="r_aa41491a390f5a69b27ebf76646d0fe40"><td class="memItemLeft" align="right" valign="top">const std::optional&lt; std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, int &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa41491a390f5a69b27ebf76646d0fe40">get_decision_variable_index</a> () const</td></tr>
<tr class="memdesc:aa41491a390f5a69b27ebf76646d0fe40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets decision_variable_index.  <br /></td></tr>
<tr class="memitem:ad1f3ddfd8fc09cc65cc8612e7d8f58f9" id="r_ad1f3ddfd8fc09cc65cc8612e7d8f58f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1f3ddfd8fc09cc65cc8612e7d8f58f9">set_solution_result</a> (<a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a> solution_result)</td></tr>
<tr class="memdesc:ad1f3ddfd8fc09cc65cc8612e7d8f58f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a>.  <br /></td></tr>
<tr class="memitem:a81aa1c64c1219a1663bf5b2e50897e08" id="r_a81aa1c64c1219a1663bf5b2e50897e08"><td class="memItemLeft" align="right" valign="top">const Eigen::VectorXd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81aa1c64c1219a1663bf5b2e50897e08">get_x_val</a> () const</td></tr>
<tr class="memdesc:a81aa1c64c1219a1663bf5b2e50897e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the decision variable values.  <br /></td></tr>
<tr class="memitem:a4b0532bc94d42bfb6a357b3187c5bc63" id="r_a4b0532bc94d42bfb6a357b3187c5bc63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b0532bc94d42bfb6a357b3187c5bc63">get_solution_result</a> () const</td></tr>
<tr class="memdesc:a4b0532bc94d42bfb6a357b3187c5bc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets <a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a>.  <br /></td></tr>
<tr class="memitem:a8efad865c03b165eece1fd889cd6631c" id="r_a8efad865c03b165eece1fd889cd6631c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8efad865c03b165eece1fd889cd6631c">set_x_val</a> (const Eigen::VectorXd &amp;x_val)</td></tr>
<tr class="memdesc:a8efad865c03b165eece1fd889cd6631c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the decision variable values.  <br /></td></tr>
<tr class="memitem:acb24e4b6d61d3d8b70d7d8d8c3b05490" id="r_acb24e4b6d61d3d8b70d7d8d8c3b05490"><td class="memTemplParams" colspan="2">template&lt;typename C&gt; </td></tr>
<tr class="memitem:acb24e4b6d61d3d8b70d7d8d8c3b05490 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb24e4b6d61d3d8b70d7d8d8c3b05490">set_dual_solution</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;constraint, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;dual_solution)</td></tr>
<tr class="memdesc:acb24e4b6d61d3d8b70d7d8d8c3b05490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the dual solution associated with a given constraint.  <br /></td></tr>
<tr class="memitem:a9d5ddbee930ff1a078b859f00b8a698a" id="r_a9d5ddbee930ff1a078b859f00b8a698a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d5ddbee930ff1a078b859f00b8a698a">get_optimal_cost</a> () const</td></tr>
<tr class="memdesc:a9d5ddbee930ff1a078b859f00b8a698a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the optimal cost.  <br /></td></tr>
<tr class="memitem:a7ab1855f8b76b618b25d64262cfc2320" id="r_a7ab1855f8b76b618b25d64262cfc2320"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ab1855f8b76b618b25d64262cfc2320">set_optimal_cost</a> (<a class="el" href="classdouble.html">double</a> optimal_cost)</td></tr>
<tr class="memdesc:a7ab1855f8b76b618b25d64262cfc2320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the optimal cost.  <br /></td></tr>
<tr class="memitem:a48c1f2ac04c5116615dc7ff9485c5a75" id="r_a48c1f2ac04c5116615dc7ff9485c5a75"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48c1f2ac04c5116615dc7ff9485c5a75">get_solver_id</a> () const</td></tr>
<tr class="memdesc:a48c1f2ac04c5116615dc7ff9485c5a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the solver ID.  <br /></td></tr>
<tr class="memitem:aafc118526b8c4e23fe369ce8b28ea597" id="r_aafc118526b8c4e23fe369ce8b28ea597"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafc118526b8c4e23fe369ce8b28ea597">set_solver_id</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;solver_id)</td></tr>
<tr class="memdesc:aafc118526b8c4e23fe369ce8b28ea597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the solver ID.  <br /></td></tr>
<tr class="memitem:accb663202a090d9ef76d04bda3433c03" id="r_accb663202a090d9ef76d04bda3433c03"><td class="memTemplParams" colspan="2">template&lt;typename Solver&gt; </td></tr>
<tr class="memitem:accb663202a090d9ef76d04bda3433c03 template"><td class="memItemLeft" align="right" valign="top">const Solver::Details &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accb663202a090d9ef76d04bda3433c03">get_solver_details</a> () const</td></tr>
<tr class="memdesc:accb663202a090d9ef76d04bda3433c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the solver details for the <span class="tt">Solver</span> that solved the program.  <br /></td></tr>
<tr class="memitem:a5121163587d2a27fc52931410370c40e" id="r_a5121163587d2a27fc52931410370c40e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5121163587d2a27fc52931410370c40e">get_abstract_solver_details</a> () const</td></tr>
<tr class="memdesc:a5121163587d2a27fc52931410370c40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced.) Gets the type-erased solver details.  <br /></td></tr>
<tr class="memitem:a425165e30082a0b745e2a792f1f4cfa7" id="r_a425165e30082a0b745e2a792f1f4cfa7"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a425165e30082a0b745e2a792f1f4cfa7 template"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a425165e30082a0b745e2a792f1f4cfa7">SetSolverDetailsType</a> ()</td></tr>
<tr class="memdesc:a425165e30082a0b745e2a792f1f4cfa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced.) Forces the solver_details to be stored using the given type <span class="tt">T</span>.  <br /></td></tr>
<tr class="memitem:a879d07f1043c47fbf928c0ab8141bdbe" id="r_a879d07f1043c47fbf928c0ab8141bdbe"><td class="memItemLeft" align="right" valign="top">const Eigen::VectorXd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a879d07f1043c47fbf928c0ab8141bdbe">GetSolution</a> () const</td></tr>
<tr class="memdesc:a879d07f1043c47fbf928c0ab8141bdbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the solution of all decision variables.  <br /></td></tr>
<tr class="memitem:ac2ac429fd3bf2017099984de63285acf" id="r_ac2ac429fd3bf2017099984de63285acf"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:ac2ac429fd3bf2017099984de63285acf template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, <a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; <a class="el" href="classdouble.html">double</a>, Derived &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2ac429fd3bf2017099984de63285acf">GetSolution</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;var) const</td></tr>
<tr class="memdesc:ac2ac429fd3bf2017099984de63285acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the solution of an Eigen matrix of decision variables.  <br /></td></tr>
<tr class="memitem:ae75eb95dd928015b0410479833c607f7" id="r_ae75eb95dd928015b0410479833c607f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae75eb95dd928015b0410479833c607f7">GetSolution</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;var) const</td></tr>
<tr class="memdesc:ae75eb95dd928015b0410479833c607f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the solution of a single decision variable.  <br /></td></tr>
<tr class="memitem:a5d0d1bedd09e7efb632e277a09b3fba2" id="r_a5d0d1bedd09e7efb632e277a09b3fba2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d0d1bedd09e7efb632e277a09b3fba2">SetSolution</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;var, <a class="el" href="classdouble.html">double</a> value)</td></tr>
<tr class="memdesc:a5d0d1bedd09e7efb632e277a09b3fba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the solution of a single decision variable that is already registered with this result.  <br /></td></tr>
<tr class="memitem:a95fe776847b769ae0341b0844dd2d0c7" id="r_a95fe776847b769ae0341b0844dd2d0c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95fe776847b769ae0341b0844dd2d0c7">GetSolution</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e) const</td></tr>
<tr class="memdesc:a95fe776847b769ae0341b0844dd2d0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes the value of all decision variables into the Expression.  <br /></td></tr>
<tr class="memitem:af66c730c31d65150eba65d0c66670cc3" id="r_af66c730c31d65150eba65d0c66670cc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af66c730c31d65150eba65d0c66670cc3">GetSolution</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;p) const</td></tr>
<tr class="memdesc:af66c730c31d65150eba65d0c66670cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes the value of all decision variables into the coefficients of the symbolic polynomial.  <br /></td></tr>
<tr class="memitem:a87c4b0cc06dfff812148d1a290bdb9da" id="r_a87c4b0cc06dfff812148d1a290bdb9da"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a87c4b0cc06dfff812148d1a290bdb9da template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;, <a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>, Derived &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87c4b0cc06dfff812148d1a290bdb9da">GetSolution</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m) const</td></tr>
<tr class="memdesc:a87c4b0cc06dfff812148d1a290bdb9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes the value of all decision variables into the Matrix&lt;Expression&gt;.  <br /></td></tr>
<tr class="memitem:a83ded6cdb6fee1487b660f066dcbd1e9" id="r_a83ded6cdb6fee1487b660f066dcbd1e9"><td class="memTemplParams" colspan="2">template&lt;typename C&gt; </td></tr>
<tr class="memitem:a83ded6cdb6fee1487b660f066dcbd1e9 template"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83ded6cdb6fee1487b660f066dcbd1e9">GetDualSolution</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;constraint) const</td></tr>
<tr class="memdesc:a83ded6cdb6fee1487b660f066dcbd1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the dual solution associated with a constraint.  <br /></td></tr>
<tr class="memitem:a5477c6d7b8af6a3be55e58d0d5e2d768" id="r_a5477c6d7b8af6a3be55e58d0d5e2d768"><td class="memTemplParams" colspan="2">template&lt;typename Evaluator&gt; </td></tr>
<tr class="memitem:a5477c6d7b8af6a3be55e58d0d5e2d768 template"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5477c6d7b8af6a3be55e58d0d5e2d768">EvalBinding</a> (const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; Evaluator &gt; &amp;binding) const</td></tr>
<tr class="memdesc:a5477c6d7b8af6a3be55e58d0d5e2d768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a <a class="el" href="classdrake_1_1solvers_1_1_binding.html" title="A binding on constraint type C is a mapping of the decision variables onto the inputs of C.">Binding</a> at the solution.  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:ac44e9b76f5a49fd42d33fa180ae2b6dc" id="r_ac44e9b76f5a49fd42d33fa180ae2b6dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac44e9b76f5a49fd42d33fa180ae2b6dc">MathematicalProgramResult</a> (const MathematicalProgramResult &amp;)=default</td></tr>
<tr class="memitem:a39612db869ad20baf8d65cb626ae7a72" id="r_a39612db869ad20baf8d65cb626ae7a72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac44e9b76f5a49fd42d33fa180ae2b6dc">MathematicalProgramResult</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39612db869ad20baf8d65cb626ae7a72">operator=</a> (const <a class="el" href="#ac44e9b76f5a49fd42d33fa180ae2b6dc">MathematicalProgramResult</a> &amp;)=default</td></tr>
<tr class="memitem:af80eb434687cea4c6bc747d19a8476f3" id="r_af80eb434687cea4c6bc747d19a8476f3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af80eb434687cea4c6bc747d19a8476f3">MathematicalProgramResult</a> (MathematicalProgramResult &amp;&amp;)=default</td></tr>
<tr class="memitem:a0fa25c86682c1aaf36a2fd902a454071" id="r_a0fa25c86682c1aaf36a2fd902a454071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac44e9b76f5a49fd42d33fa180ae2b6dc">MathematicalProgramResult</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fa25c86682c1aaf36a2fd902a454071">operator=</a> (<a class="el" href="#ac44e9b76f5a49fd42d33fa180ae2b6dc">MathematicalProgramResult</a> &amp;&amp;)=default</td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Solution Pools</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="solution_pools"></a> Some solvers (like Gurobi, Cplex, etc) can store a pool of (suboptimal) solutions for mixed integer programming model. </p>
</div></td></tr>
<tr class="memitem:a09af389875a3775b5899cd92e800b8d4" id="r_a09af389875a3775b5899cd92e800b8d4"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a09af389875a3775b5899cd92e800b8d4 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, <a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; <a class="el" href="classdouble.html">double</a>, Derived &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09af389875a3775b5899cd92e800b8d4">GetSuboptimalSolution</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;var, int solution_number) const</td></tr>
<tr class="memdesc:a09af389875a3775b5899cd92e800b8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the suboptimal solution corresponding to a matrix of decision variables.  <br /></td></tr>
<tr class="memitem:a0f1b5841ee288eef56aab11d80344e64" id="r_a0f1b5841ee288eef56aab11d80344e64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f1b5841ee288eef56aab11d80344e64">GetSuboptimalSolution</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;var, int solution_number) const</td></tr>
<tr class="memdesc:a0f1b5841ee288eef56aab11d80344e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the suboptimal solution of a decision variable.  <br /></td></tr>
<tr class="memitem:abc1b132c76d03e6a14ff22e0c7974a02" id="r_abc1b132c76d03e6a14ff22e0c7974a02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc1b132c76d03e6a14ff22e0c7974a02">num_suboptimal_solution</a> () const</td></tr>
<tr class="memdesc:abc1b132c76d03e6a14ff22e0c7974a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of suboptimal solutions stored inside <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html" title="The result returned by MathematicalProgram::Solve().">MathematicalProgramResult</a>.  <br /></td></tr>
<tr class="memitem:aadf0105c699cd77cd49b9a1fa031182f" id="r_aadf0105c699cd77cd49b9a1fa031182f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadf0105c699cd77cd49b9a1fa031182f">get_suboptimal_objective</a> (int solution_number) const</td></tr>
<tr class="memdesc:aadf0105c699cd77cd49b9a1fa031182f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the suboptimal objective value.  <br /></td></tr>
<tr class="memitem:a36e18a00ea3f96de94071921fd7bcfd3" id="r_a36e18a00ea3f96de94071921fd7bcfd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36e18a00ea3f96de94071921fd7bcfd3">AddSuboptimalSolution</a> (<a class="el" href="classdouble.html">double</a> suboptimal_objective, const Eigen::VectorXd &amp;suboptimal_x)</td></tr>
<tr class="memdesc:a36e18a00ea3f96de94071921fd7bcfd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the suboptimal solution to the result.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Get infeasible constraints</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="get_infeasible_constraints"></a> Some solvers (e.g.</p>
<p>SNOPT) provide a "best-effort solution" even when they determine that a problem is infeasible. This method will return the descriptions corresponding to the constraints for which <span class="tt">CheckSatisfied</span> evaluates to false given the reported solution. This can be very useful for debugging. Note that this feature is available only when the optimization problem is solved through certain solvers (like SNOPT, IPOPT) which provide a "best-effort solution". Some solvers (like Gurobi) don't return the "best-effort solution" when the problem is infeasible, and this feature is hence unavailable. </p>
</td></tr>
<tr class="memitem:a7095270fe56730c84e35c845c4860090" id="r_a7095270fe56730c84e35c845c4860090"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7095270fe56730c84e35c845c4860090">GetInfeasibleConstraintNames</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog, std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt; tolerance=std::nullopt) const</td></tr>
<tr class="memdesc:a7095270fe56730c84e35c845c4860090"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="#get_infeasible_constraints">get_infeasible_constraints</a> for more information.  <br /></td></tr>
<tr class="memitem:a1d17b1ed4ccc3b4271c7f918b6b69fb9" id="r_a1d17b1ed4ccc3b4271c7f918b6b69fb9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d17b1ed4ccc3b4271c7f918b6b69fb9">GetInfeasibleConstraints</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog, std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt; tolerance=std::nullopt) const</td></tr>
<tr class="memdesc:a1d17b1ed4ccc3b4271c7f918b6b69fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="#get_infeasible_constraints">get_infeasible_constraints</a> for more information.  <br /></td></tr>
</table>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac44e9b76f5a49fd42d33fa180ae2b6dc" name="ac44e9b76f5a49fd42d33fa180ae2b6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44e9b76f5a49fd42d33fa180ae2b6dc">&#9670;&#160;</a></span>MathematicalProgramResult() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MathematicalProgramResult </td>
          <td>(</td>
          <td class="paramtype">const MathematicalProgramResult &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af80eb434687cea4c6bc747d19a8476f3" name="af80eb434687cea4c6bc747d19a8476f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80eb434687cea4c6bc747d19a8476f3">&#9670;&#160;</a></span>MathematicalProgramResult() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MathematicalProgramResult </td>
          <td>(</td>
          <td class="paramtype">MathematicalProgramResult &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fd3b5095ed206da42f1451c5dd426c5" name="a4fd3b5095ed206da42f1451c5dd426c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fd3b5095ed206da42f1451c5dd426c5">&#9670;&#160;</a></span>MathematicalProgramResult() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MathematicalProgramResult </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the result. </p>
<dl class="section note"><dt>Note</dt><dd>The solver_details is set to nullptr. </dd></dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a36e18a00ea3f96de94071921fd7bcfd3" name="a36e18a00ea3f96de94071921fd7bcfd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e18a00ea3f96de94071921fd7bcfd3">&#9670;&#160;</a></span>AddSuboptimalSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddSuboptimalSolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>suboptimal_objective</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>suboptimal_x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the suboptimal solution to the result. </p>
<p>See <a class="el" href="#solution_pools">solution pools</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suboptimal_objective</td><td>The objective value computed from this suboptimal solution. </td></tr>
    <tr><td class="paramname">suboptimal_x</td><td>The values of the decision variables in this suboptimal solution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5477c6d7b8af6a3be55e58d0d5e2d768" name="a5477c6d7b8af6a3be55e58d0d5e2d768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5477c6d7b8af6a3be55e58d0d5e2d768">&#9670;&#160;</a></span>EvalBinding()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Evaluator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd EvalBinding </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; Evaluator &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a <a class="el" href="classdrake_1_1solvers_1_1_binding.html" title="A binding on constraint type C is a mapping of the decision variables onto the inputs of C.">Binding</a> at the solution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binding</td><td>A binding between a constraint/cost and the variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The binding.variables() must be the within the decision variables in the <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> that generated this MathematicalProgramResult. </dd>
<dd>
The user must have called <a class="el" href="#a8454ba31b3b8d0dcf68140e63b8333fe" title="Sets decision_variable_index mapping, that maps each decision variable to its index in the aggregated...">set_decision_variable_index()</a> function. </dd></dl>

</div>
</div>
<a id="a5121163587d2a27fc52931410370c40e" name="a5121163587d2a27fc52931410370c40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5121163587d2a27fc52931410370c40e">&#9670;&#160;</a></span>get_abstract_solver_details()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a> &amp; get_abstract_solver_details </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced.) Gets the type-erased solver details. </p>
<p>Most users should use <a class="el" href="#accb663202a090d9ef76d04bda3433c03" title="Gets the solver details for the Solver that solved the program.">get_solver_details()</a> instead. Throws an error if the solver_details has not been set. </p>

</div>
</div>
<a id="aa41491a390f5a69b27ebf76646d0fe40" name="aa41491a390f5a69b27ebf76646d0fe40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41491a390f5a69b27ebf76646d0fe40">&#9670;&#160;</a></span>get_decision_variable_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::optional&lt; std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, int &gt; &gt; &amp; get_decision_variable_index </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets decision_variable_index. </p>

</div>
</div>
<a id="a9d5ddbee930ff1a078b859f00b8a698a" name="a9d5ddbee930ff1a078b859f00b8a698a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5ddbee930ff1a078b859f00b8a698a">&#9670;&#160;</a></span>get_optimal_cost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> get_optimal_cost </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the optimal cost. </p>

</div>
</div>
<a id="a4b0532bc94d42bfb6a357b3187c5bc63" name="a4b0532bc94d42bfb6a357b3187c5bc63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0532bc94d42bfb6a357b3187c5bc63">&#9670;&#160;</a></span>get_solution_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a> get_solution_result </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets <a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a>. </p>

</div>
</div>
<a id="accb663202a090d9ef76d04bda3433c03" name="accb663202a090d9ef76d04bda3433c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb663202a090d9ef76d04bda3433c03">&#9670;&#160;</a></span>get_solver_details()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Solver&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Solver::Details &amp; get_solver_details </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the solver details for the <span class="tt">Solver</span> that solved the program. </p>
<p>Throws an error if the solver_details has not been set. </p>

</div>
</div>
<a id="a48c1f2ac04c5116615dc7ff9485c5a75" name="a48c1f2ac04c5116615dc7ff9485c5a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c1f2ac04c5116615dc7ff9485c5a75">&#9670;&#160;</a></span>get_solver_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp; get_solver_id </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the solver ID. </p>

</div>
</div>
<a id="aadf0105c699cd77cd49b9a1fa031182f" name="aadf0105c699cd77cd49b9a1fa031182f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf0105c699cd77cd49b9a1fa031182f">&#9670;&#160;</a></span>get_suboptimal_objective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> get_suboptimal_objective </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>solution_number</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the suboptimal objective value. </p>
<p>See <a class="el" href="#solution_pools">solutionpools</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solution_number</td><td>The index of the sub-optimal solution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code class="param">solution_number</code> should be in the range [0, <a class="el" href="#abc1b132c76d03e6a14ff22e0c7974a02" title="Number of suboptimal solutions stored inside MathematicalProgramResult.">num_suboptimal_solution()</a>). </dd></dl>

</div>
</div>
<a id="a81aa1c64c1219a1663bf5b2e50897e08" name="a81aa1c64c1219a1663bf5b2e50897e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81aa1c64c1219a1663bf5b2e50897e08">&#9670;&#160;</a></span>get_x_val()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::VectorXd &amp; get_x_val </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the decision variable values. </p>

</div>
</div>
<a id="a83ded6cdb6fee1487b660f066dcbd1e9" name="a83ded6cdb6fee1487b660f066dcbd1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ded6cdb6fee1487b660f066dcbd1e9">&#9670;&#160;</a></span>GetDualSolution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd GetDualSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>constraint</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the dual solution associated with a constraint. </p>
<p>For constraints in the form lower &lt;= f(x) &lt;= upper (including linear inequality, linear equality, bounding box constraints, and general nonlinear constraints), we interpret the dual variable value as the "shadow
price" of the original problem. Namely if we change the constraint bound by one unit (each unit is infinitesimally small), the change of the optimal cost is the value of the dual solution times the unit. Mathematically dual_solution = ∂optimal_cost / ∂bound.</p>
<p>For a linear equality constraint Ax = b where b ∈ ℝⁿ, the vector of dual variables has n rows, and dual_solution(i) is the value of the dual variable for the constraint A(i,:)*x = b(i).</p>
<p>For a linear inequality constraint lower &lt;= A*x &lt;= upper where lower and upper ∈ ℝⁿ, dual_solution also has n rows. dual_solution(i) is the value of the dual variable for constraint lower(i) &lt;= A(i,:)*x &lt;= upper(i). If neither side of the constraint is active, then dual_solution(i) is 0. If the left hand-side lower(i) &lt;= A(i, :)*x is active (meaning lower(i) = A(i,
:)*x at the solution), then dual_solution(i) is non-negative (because the objective is to minimize a cost, increasing the lower bound means the constraint set is tighter, hence the optimal solution cannot decrease. Thus the shadow price is non-negative). If the right hand-side A(i,
:)*x&lt;=upper(i) is active (meaning A(i,:)*x=upper(i) at the solution), then dual_solution(i) is non-positive.</p>
<p>For a bounding box constraint lower &lt;= x &lt;= upper, the interpretation of the dual solution is the same as the linear inequality constraint.</p>
<p>For a Lorentz cone or rotated Lorentz cone constraint that Ax + b is in the cone, depending on the solver, the dual solution has different meanings:</p><ol type="1">
<li>If the solver is Gurobi, then the user can only obtain the dual solution by explicitly setting the options for computing dual solution. <div class="fragment"><div class="line"><span class="keyword">auto</span> constraint = prog.AddLorentzConeConstraint(...);</div>
<div class="line"><a class="code hl_class" href="classdrake_1_1solvers_1_1_gurobi_solver.html">GurobiSolver</a> solver;</div>
<div class="line"><span class="comment">// Explicitly tell the solver to compute the dual solution for Lorentz</span></div>
<div class="line"><span class="comment">// cone or rotated Lorentz cone constraint, check</span></div>
<div class="line"><span class="comment">// https://docs.gurobi.com/projects/optimizer/en/12.0/reference/parameters.html#qcpdual</span></div>
<div class="line"><span class="comment">// for more information.</span></div>
<div class="line"><a class="code hl_struct" href="structdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> options;</div>
<div class="line">options.<a class="code hl_function" href="structdrake_1_1solvers_1_1_solver_options.html#af4c4c08922e737f18d2f1960f4f93e02">SetOption</a>(<a class="code hl_function" href="classdrake_1_1solvers_1_1_gurobi_solver.html#a4dc451b7db72a168d9f0da1746011b45">GurobiSolver::id</a>(), <span class="stringliteral">&quot;QCPDual&quot;</span>, 1);</div>
<div class="line"><a class="code hl_function" href="#ac44e9b76f5a49fd42d33fa180ae2b6dc">MathematicalProgramResult</a> result = solver.<a class="code hl_function" href="classdrake_1_1solvers_1_1_gurobi_solver.html#a00b55f8b4c1c4f19b45621a84deed66c">Solve</a>(prog, {}, options);</div>
<div class="line">Eigen::VectorXd dual_solution = result.<a class="code hl_function" href="#a83ded6cdb6fee1487b660f066dcbd1e9">GetDualSolution</a>(constraint);</div>
<div class="ttc" id="aclassdrake_1_1solvers_1_1_gurobi_solver_html"><div class="ttname"><a href="classdrake_1_1solvers_1_1_gurobi_solver.html">drake::solvers::GurobiSolver</a></div><div class="ttdoc">An implementation of SolverInterface for the commercially-licensed Gurobi solver (https://www....</div><div class="ttdef"><b>Definition</b> gurobi_solver.h:78</div></div>
<div class="ttc" id="aclassdrake_1_1solvers_1_1_gurobi_solver_html_a00b55f8b4c1c4f19b45621a84deed66c"><div class="ttname"><a href="classdrake_1_1solvers_1_1_gurobi_solver.html#a00b55f8b4c1c4f19b45621a84deed66c">drake::solvers::GurobiSolver::Solve</a></div><div class="ttdeci">MathematicalProgramResult Solve(const MathematicalProgram &amp;prog, const std::optional&lt; Eigen::VectorXd &gt; &amp;initial_guess=std::nullopt, const std::optional&lt; SolverOptions &gt; &amp;solver_options=std::nullopt) const</div><div class="ttdoc">Like SolverInterface::Solve(), but the result is a return value instead of an output argument.</div></div>
<div class="ttc" id="aclassdrake_1_1solvers_1_1_gurobi_solver_html_a4dc451b7db72a168d9f0da1746011b45"><div class="ttname"><a href="classdrake_1_1solvers_1_1_gurobi_solver.html#a4dc451b7db72a168d9f0da1746011b45">drake::solvers::GurobiSolver::id</a></div><div class="ttdeci">static SolverId id()</div></div>
<div class="ttc" id="aclassdrake_1_1solvers_1_1_mathematical_program_result_html_a83ded6cdb6fee1487b660f066dcbd1e9"><div class="ttname"><a href="#a83ded6cdb6fee1487b660f066dcbd1e9">drake::solvers::MathematicalProgramResult::GetDualSolution</a></div><div class="ttdeci">Eigen::VectorXd GetDualSolution(const Binding&lt; C &gt; &amp;constraint) const</div><div class="ttdoc">Gets the dual solution associated with a constraint.</div><div class="ttdef"><b>Definition</b> mathematical_program_result.h:347</div></div>
<div class="ttc" id="aclassdrake_1_1solvers_1_1_mathematical_program_result_html_ac44e9b76f5a49fd42d33fa180ae2b6dc"><div class="ttname"><a href="#ac44e9b76f5a49fd42d33fa180ae2b6dc">drake::solvers::MathematicalProgramResult::MathematicalProgramResult</a></div><div class="ttdeci">MathematicalProgramResult(const MathematicalProgramResult &amp;)=default</div></div>
<div class="ttc" id="astructdrake_1_1solvers_1_1_solver_options_html"><div class="ttname"><a href="structdrake_1_1solvers_1_1_solver_options.html">drake::solvers::SolverOptions</a></div><div class="ttdoc">Stores options for multiple solvers.</div><div class="ttdef"><b>Definition</b> solver_options.h:60</div></div>
<div class="ttc" id="astructdrake_1_1solvers_1_1_solver_options_html_af4c4c08922e737f18d2f1960f4f93e02"><div class="ttname"><a href="structdrake_1_1solvers_1_1_solver_options.html#af4c4c08922e737f18d2f1960f4f93e02">drake::solvers::SolverOptions::SetOption</a></div><div class="ttdeci">void SetOption(const SolverId &amp;solver_id, std::string key, OptionValue value)</div><div class="ttdoc">Sets a solver option for a specific solver.</div></div>
</div><!-- fragment --> The dual solution has size 1, dual_solution(0) is the shadow price for the constraint z₁² + ... +zₙ² ≤ z₀² for Lorentz cone constraint, and the shadow price for the constraint z₂² + ... +zₙ² ≤ z₀z₁ for rotated Lorentz cone constraint, where z is the slack variable representing z = A*x+b and z in the Lorentz cone/rotated Lorentz cone.</li>
<li>For nonlinear solvers like IPOPT, the dual solution for Lorentz cone constraint (with EvalType::kConvex) is the shadow price for z₀ - sqrt(z₁² + ... +zₙ²) ≥ 0, where z = Ax+b.</li>
<li>For other convex conic solver such as SCS, MOSEK<a href="/tm.html">™</a>, CSDP, etc, the dual solution to the (rotated) Lorentz cone constraint doesn't have the "shadow price" interpretation, but should lie in the dual cone, and satisfy the KKT condition. For more information, refer to <a href="https://docs.mosek.com/11.0/capi/prob-def-conic.html#duality-for-conic-optimization">https://docs.mosek.com/11.0/capi/prob-def-conic.html#duality-for-conic-optimization</a> as an explanation.</li>
</ol>
<p>The interpretation for the dual variable to conic constraint x ∈ K can be different. Here K is a convex cone, including exponential cone, power cone, psd cone, etc. When the problem is solved by a convex solver (like SCS, MOSEK<a href="/tm.html">™</a>, CSDP, etc), often it has a dual variable z ∈ K*, where K* is the dual cone. Here the dual variable DOESN'T have the interpretation of "shadow price", but should satisfy the KKT condition, while the dual variable stays inside the dual cone.</p>
<p>When K is a psd cone, the returned dual solution is the lower triangle of the dual symmetric psd matrix. Namely for the primal problem</p>
<p>min trace(C*X) s.t A(X) = b X is psd</p>
<p>the dual is</p>
<p>max b'*y s.t A'(y) - C = Z Z is psd.</p>
<p>We return the lower triangular part of Z. You can call <a class="el" href="namespacedrake_1_1math.html#ae4935d457d59fdb0a60b7f1d5cb465bb" title="Given a column vector containing the stacked columns of the lower triangular part of a square matrix,...">drake::math::ToSymmetricMatrixFromLowerTriangularColumns</a> to get the matrix Z. </p>

</div>
</div>
<a id="a7095270fe56730c84e35c845c4860090" name="a7095270fe56730c84e35c845c4860090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7095270fe56730c84e35c845c4860090">&#9670;&#160;</a></span>GetInfeasibleConstraintNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; GetInfeasibleConstraintNames </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="#get_infeasible_constraints">get_infeasible_constraints</a> for more information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>The <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> that was solved to obtain <span class="tt">this</span> <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html" title="The result returned by MathematicalProgram::Solve().">MathematicalProgramResult</a>. </td></tr>
    <tr><td class="paramname">tolerance</td><td>A positive tolerance to check the constraint violation. If no tolerance is provided, this method will attempt to obtain the constraint tolerance from the solver, or insert a conservative default tolerance.</td></tr>
  </table>
  </dd>
</dl>
<p>Note: Currently most constraints have the empty string as the description, so the <a class="el" href="classdrake_1_1_nice_type_name.html" title="Obtains canonicalized, platform-independent, human-readable names for arbitrarily-complicated C++ typ...">NiceTypeName</a> of the <a class="el" href="classdrake_1_1solvers_1_1_constraint.html" title="A constraint is a function + lower and upper bounds.">Constraint</a> is used instead. Use e.g. <span class="tt">prog.AddConstraint(x == 1).evaluator().set_description(str)</span> to make this method more specific/useful. </p>

</div>
</div>
<a id="a1d17b1ed4ccc3b4271c7f918b6b69fb9" name="a1d17b1ed4ccc3b4271c7f918b6b69fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d17b1ed4ccc3b4271c7f918b6b69fb9">&#9670;&#160;</a></span>GetInfeasibleConstraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a> &gt; &gt; GetInfeasibleConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="#get_infeasible_constraints">get_infeasible_constraints</a> for more information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>The <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> that was solved to obtain <span class="tt">this</span> <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html" title="The result returned by MathematicalProgram::Solve().">MathematicalProgramResult</a>. </td></tr>
    <tr><td class="paramname">tolerance</td><td>A positive tolerance to check the constraint violation. If no tolerance is provided, this method will attempt to obtain the constraint tolerance from the solver, or insert a conservative default tolerance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>infeasible_bindings A vector of all infeasible bindings (constraints together with the associated variables) at the best-effort solution. </dd></dl>

</div>
</div>
<a id="a879d07f1043c47fbf928c0ab8141bdbe" name="a879d07f1043c47fbf928c0ab8141bdbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879d07f1043c47fbf928c0ab8141bdbe">&#9670;&#160;</a></span>GetSolution() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::VectorXd &amp; GetSolution </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the solution of all decision variables. </p>

</div>
</div>
<a id="a87c4b0cc06dfff812148d1a290bdb9da" name="a87c4b0cc06dfff812148d1a290bdb9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c4b0cc06dfff812148d1a290bdb9da">&#9670;&#160;</a></span>GetSolution() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;, <a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>, Derived &gt; &gt; GetSolution </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitutes the value of all decision variables into the Matrix&lt;Expression&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>An Eigen matrix containing Expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Matrix&lt;Expression&gt; that is the result of the substitution. </dd></dl>

</div>
</div>
<a id="ac2ac429fd3bf2017099984de63285acf" name="ac2ac429fd3bf2017099984de63285acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ac429fd3bf2017099984de63285acf">&#9670;&#160;</a></span>GetSolution() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, <a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; <a class="el" href="classdouble.html">double</a>, Derived &gt; &gt; GetSolution </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the solution of an Eigen matrix of decision variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>An Eigen matrix containing Variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The decision variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the decision variable after solving the problem. </dd></dl>

</div>
</div>
<a id="a95fe776847b769ae0341b0844dd2d0c7" name="a95fe776847b769ae0341b0844dd2d0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95fe776847b769ae0341b0844dd2d0c7">&#9670;&#160;</a></span>GetSolution() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> GetSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitutes the value of all decision variables into the Expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The decision variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Expression that is the result of the substitution. </dd></dl>

</div>
</div>
<a id="af66c730c31d65150eba65d0c66670cc3" name="af66c730c31d65150eba65d0c66670cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66c730c31d65150eba65d0c66670cc3">&#9670;&#160;</a></span>GetSolution() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> GetSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">symbolic::Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitutes the value of all decision variables into the coefficients of the symbolic polynomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A symbolic polynomial. Its indeterminates can't intersect with the set of decision variables of the <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> from which this result is obtained. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html" title="Represents symbolic polynomials.">symbolic::Polynomial</a> as the result of the substitution. </dd></dl>

</div>
</div>
<a id="ae75eb95dd928015b0410479833c607f7" name="ae75eb95dd928015b0410479833c607f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75eb95dd928015b0410479833c607f7">&#9670;&#160;</a></span>GetSolution() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GetSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the solution of a single decision variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The decision variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the decision variable after solving the problem. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">var</span> is not captured in the mapping <code class="param">decision_variable_index</code>, as the input argument of <a class="el" href="#a8454ba31b3b8d0dcf68140e63b8333fe" title="Sets decision_variable_index mapping, that maps each decision variable to its index in the aggregated...">set_decision_variable_index()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09af389875a3775b5899cd92e800b8d4" name="a09af389875a3775b5899cd92e800b8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09af389875a3775b5899cd92e800b8d4">&#9670;&#160;</a></span>GetSuboptimalSolution() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, <a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; <a class="el" href="classdouble.html">double</a>, Derived &gt; &gt; GetSuboptimalSolution </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>solution_number</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the suboptimal solution corresponding to a matrix of decision variables. </p>
<p>See <a class="el" href="#solution_pools">solution pools</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The decision variables. </td></tr>
    <tr><td class="paramname">solution_number</td><td>The index of the sub-optimal solution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code class="param">solution_number</code> should be in the range [0, <a class="el" href="#abc1b132c76d03e6a14ff22e0c7974a02" title="Number of suboptimal solutions stored inside MathematicalProgramResult.">num_suboptimal_solution()</a>). </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The suboptimal values of the decision variables after solving the problem. </dd></dl>

</div>
</div>
<a id="a0f1b5841ee288eef56aab11d80344e64" name="a0f1b5841ee288eef56aab11d80344e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1b5841ee288eef56aab11d80344e64">&#9670;&#160;</a></span>GetSuboptimalSolution() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GetSuboptimalSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>solution_number</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the suboptimal solution of a decision variable. </p>
<p>See <a class="el" href="#solution_pools">solution pools</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The decision variable. </td></tr>
    <tr><td class="paramname">solution_number</td><td>The index of the sub-optimal solution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code class="param">solution_number</code> should be in the range [0, <a class="el" href="#abc1b132c76d03e6a14ff22e0c7974a02" title="Number of suboptimal solutions stored inside MathematicalProgramResult.">num_suboptimal_solution()</a>). </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The suboptimal value of the decision variable after solving the problem. </dd></dl>

</div>
</div>
<a id="ab69f22a0b39aa76226e1a7a1c357cced" name="ab69f22a0b39aa76226e1a7a1c357cced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69f22a0b39aa76226e1a7a1c357cced">&#9670;&#160;</a></span>is_success()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_success </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the optimization problem is solved successfully; false otherwise. </p>
<p>For more information on the solution status, the user could call <a class="el" href="#accb663202a090d9ef76d04bda3433c03" title="Gets the solver details for the Solver that solved the program.">get_solver_details()</a> to obtain the solver-specific solution status. </p>

</div>
</div>
<a id="abc1b132c76d03e6a14ff22e0c7974a02" name="abc1b132c76d03e6a14ff22e0c7974a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1b132c76d03e6a14ff22e0c7974a02">&#9670;&#160;</a></span>num_suboptimal_solution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int num_suboptimal_solution </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of suboptimal solutions stored inside <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html" title="The result returned by MathematicalProgram::Solve().">MathematicalProgramResult</a>. </p>
<p>See <a class="el" href="#solution_pools">solution pools</a>. </p>

</div>
</div>
<a id="a39612db869ad20baf8d65cb626ae7a72" name="a39612db869ad20baf8d65cb626ae7a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39612db869ad20baf8d65cb626ae7a72">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac44e9b76f5a49fd42d33fa180ae2b6dc">MathematicalProgramResult</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ac44e9b76f5a49fd42d33fa180ae2b6dc">MathematicalProgramResult</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fa25c86682c1aaf36a2fd902a454071" name="a0fa25c86682c1aaf36a2fd902a454071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa25c86682c1aaf36a2fd902a454071">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac44e9b76f5a49fd42d33fa180ae2b6dc">MathematicalProgramResult</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac44e9b76f5a49fd42d33fa180ae2b6dc">MathematicalProgramResult</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8454ba31b3b8d0dcf68140e63b8333fe" name="a8454ba31b3b8d0dcf68140e63b8333fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8454ba31b3b8d0dcf68140e63b8333fe">&#9670;&#160;</a></span>set_decision_variable_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_decision_variable_index </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, int &gt;</td>          <td class="paramname"><span class="paramname"><em>decision_variable_index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets decision_variable_index mapping, that maps each decision variable to its index in the aggregated vector containing all decision variables in <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>. </p>
<p>Initialize x_val to NAN. </p>

</div>
</div>
<a id="acb24e4b6d61d3d8b70d7d8d8c3b05490" name="acb24e4b6d61d3d8b70d7d8d8c3b05490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb24e4b6d61d3d8b70d7d8d8c3b05490">&#9670;&#160;</a></span>set_dual_solution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_dual_solution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>constraint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dual_solution</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the dual solution associated with a given constraint. </p>

</div>
</div>
<a id="a7ab1855f8b76b618b25d64262cfc2320" name="a7ab1855f8b76b618b25d64262cfc2320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab1855f8b76b618b25d64262cfc2320">&#9670;&#160;</a></span>set_optimal_cost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_optimal_cost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>optimal_cost</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the optimal cost. </p>

</div>
</div>
<a id="ad1f3ddfd8fc09cc65cc8612e7d8f58f9" name="ad1f3ddfd8fc09cc65cc8612e7d8f58f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f3ddfd8fc09cc65cc8612e7d8f58f9">&#9670;&#160;</a></span>set_solution_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_solution_result </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a></td>          <td class="paramname"><span class="paramname"><em>solution_result</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a>. </p>

</div>
</div>
<a id="aafc118526b8c4e23fe369ce8b28ea597" name="aafc118526b8c4e23fe369ce8b28ea597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc118526b8c4e23fe369ce8b28ea597">&#9670;&#160;</a></span>set_solver_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_solver_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>solver_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the solver ID. </p>

</div>
</div>
<a id="a8efad865c03b165eece1fd889cd6631c" name="a8efad865c03b165eece1fd889cd6631c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8efad865c03b165eece1fd889cd6631c">&#9670;&#160;</a></span>set_x_val()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_x_val </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>x_val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the decision variable values. </p>

</div>
</div>
<a id="a5d0d1bedd09e7efb632e277a09b3fba2" name="a5d0d1bedd09e7efb632e277a09b3fba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0d1bedd09e7efb632e277a09b3fba2">&#9670;&#160;</a></span>SetSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the solution of a single decision variable that is already registered with this result. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">var</span> is not captured in the mapping <code class="param">decision_variable_index</code>, as the input argument of <a class="el" href="#a8454ba31b3b8d0dcf68140e63b8333fe" title="Sets decision_variable_index mapping, that maps each decision variable to its index in the aggregated...">set_decision_variable_index()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a425165e30082a0b745e2a792f1f4cfa7" name="a425165e30082a0b745e2a792f1f4cfa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425165e30082a0b745e2a792f1f4cfa7">&#9670;&#160;</a></span>SetSolverDetailsType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; SetSolverDetailsType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced.) Forces the solver_details to be stored using the given type <span class="tt">T</span>. </p>
<p>Typically, only an implementation of <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html" title="Interface used by implementations of individual solvers.">SolverInterface</a> will call this method. If the storage was already typed as T, this is a no-op. If there were not any solver_details previously, or if it was of a different type, initializes the storage to a default-constructed T. Returns a reference to the mutable solver_details object. The reference remains valid until the next call to this method, or until this <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html" title="The result returned by MathematicalProgram::Solve().">MathematicalProgramResult</a> is destroyed. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/solvers/<a class="el" href="mathematical__program__result_8h.html">mathematical_program_result.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1solvers.html">solvers</a></li><li class="navelem"><a href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
