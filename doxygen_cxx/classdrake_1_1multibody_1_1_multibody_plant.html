<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: MultibodyPlant&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1multibody_1_1_multibody_plant.html','','classdrake_1_1multibody_1_1_multibody_plant-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">MultibodyPlant&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__systems.html">Modeling Dynamical Systems</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class drake::multibody::MultibodyPlant&lt; T &gt;</div><p>MultibodyPlant is a Drake system framework representation (see <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">systems::System</a>) for the model of a physical system consisting of a collection of interconnected bodies. </p>
<p>See <a class="el" href="group__multibody.html">Multibody Kinematics and Dynamics</a> for an overview of concepts/notation.</p>
<table align="center" cellpadding="0" cellspacing="0">
<tr align="center">
<td style="vertical-align:middle"><table cellspacing="0" cellpadding="0">
<tr>
<td align="right" style="padding:5px 0px 5px 0px">actuation&rarr;</td></tr>
<tr>
<td align="right" style="padding:5px 0px 5px 0px">applied_generalized_force&rarr;</td></tr>
<tr>
<td align="right" style="padding:5px 0px 5px 0px">applied_spatial_force&rarr;</td></tr>
<tr>
<td align="right" style="padding:5px 0px 5px 0px"><em style="color:gray">model_instance_name[i]</em>_actuation&rarr;</td></tr>
<tr>
<td align="right" style="padding:5px 0px 5px 0px"><em style="color:gray">model_instance_name[i]</em>_desired_state&rarr;</td></tr>
<tr>
<td align="right" style="padding:5px 0px 5px 0px"><span style="color:green">geometry_query</span>&rarr;</td></tr>
</table>
</td><td align="center" style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor="#F0F0F0"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a></td><td style="vertical-align:middle"><table cellspacing="0" cellpadding="0">
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; state</td></tr>
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; body_poses</td></tr>
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; body_spatial_velocities</td></tr>
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; body_spatial_accelerations</td></tr>
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; generalized_acceleration</td></tr>
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; net_actuation</td></tr>
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; reaction_forces</td></tr>
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; contact_results</td></tr>
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray">model_instance_name[i]</em>_state</td></tr>
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray">model_instance_name[i]</em>_generalized_acceleration</td></tr>
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray">model_instance_name[i]</em>_generalized_contact_forces</td></tr>
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray">model_instance_name[i]</em>_net_actuation</td></tr>
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; <span style="color:green">geometry_pose</span></td></tr>
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; <span style="color:green">deformable_body_configuration</span></td></tr>
</table>
</td></tr>
</table>
<p>The ports whose names begin with <em style="color:gray"> model_instance_name[i]</em> represent groups of ports, one for each of the <a class="el" href="#model_instances">model instances</a>, with i ∈ {0, ..., N-1} for the N model instances. If a model instance does not contain any data of the indicated type the port will still be present but its value will be a zero-length vector. (Model instances <span class="tt"><a class="el" href="namespacedrake_1_1multibody.html#a98c52e065024cd788db2679149ace0c7" title="Returns the model instance containing the world body.">world_model_instance()</a></span> and <span class="tt"><a class="el" href="namespacedrake_1_1multibody.html#a143e07f1c9e4723d9aeb6e3f424c3423" title="Returns the model instance which contains all tree elements with no explicit model instance specified...">default_model_instance()</a></span> always exist.)</p>
<p>The ports shown in <span style="color:green">green</span> are for communication with Drake's <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">SceneGraph</a> system for dealing with geometry.</p>
<p>MultibodyPlant provides a user-facing API for:</p>
<ul>
<li><a class="el" href="#mbp_input_and_output_ports">Ports</a>: Access input and output ports.</li>
<li><a class="el" href="#mbp_construction">Construction</a>: Add bodies, joints, frames, force elements, and actuators.</li>
<li><a class="el" href="#mbp_geometry">Geometry</a>: Register geometries to a provided SceneGraph instance.</li>
<li><a class="el" href="#mbp_contact_modeling">Contact modeling</a>: Select and parameterize contact models.</li>
<li><a class="el" href="#mbp_state_accessors_and_mutators">State access and modification</a>: Obtain and manipulate position and velocity state variables.</li>
<li><a class="el" href="#mbp_parameters">Parameters</a> Working with system parameters for various multibody elements.</li>
<li><a class="el" href="#mbp_working_with_free_bodies">Free and floating base bodies</a>: Work conveniently with free (floating) bodies.</li>
<li><a class="el" href="#mbp_kinematic_and_dynamic_computations">Kinematics and dynamics</a>: Perform <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>-dependent kinematic and dynamic queries.</li>
<li><a class="el" href="#mbp_system_matrix_computations">System matrices</a>: Explicitly form matrices that appear in the equations of motion.</li>
<li><a class="el" href="#mbp_introspection">Introspection</a>: Perform introspection to find out what's in the MultibodyPlant.</li>
</ul>
<p><a class="anchor" id="model_instances"></a></p><h3>Model Instances</h3>
<p>A MultiBodyPlant may contain multiple model instances. Each model instance corresponds to a set of bodies and their connections (joints). Model instances provide methods to get or set the state of the set of bodies (e.g., through <a class="el" href="#a61c4037d7f25d2e511f86e9102772290" title="Returns a const vector reference [q; v] to the generalized positions q and generalized velocities v i...">GetPositionsAndVelocities()</a> and <a class="el" href="#acdf6af4e5e5e71b55ea7ea3034ac5e90" title="Sets generalized positions q and generalized velocities v in a given Context from a given vector [q; ...">SetPositionsAndVelocities()</a>), connecting controllers (through <a class="el" href="#a3c6b13fba0889c4bb9a88610254a387b" title="Returns a constant reference to the output port for the multibody state x = [q, v] of the model.">get_state_output_port()</a> and <a class="el" href="#a69ef9262ffab02b34bdf20449aab7551" title="Returns a constant reference to the input port for external actuation for all actuated dofs.">get_actuation_input_port()</a>), and organizing duplicate models (read through a parser). In fact, many MultibodyPlant methods are overloaded to allow operating on the entire plant or just the subset corresponding to the model instance; for example, one <a class="el" href="#a15aab0eeb92b8e9f0a9bfcab8abaca69" title="Returns a const vector reference to the vector of generalized positions q in a given Context.">GetPositions()</a> method obtains the generalized positions for the entire plant while another <a class="el" href="#a15aab0eeb92b8e9f0a9bfcab8abaca69" title="Returns a const vector reference to the vector of generalized positions q in a given Context.">GetPositions()</a> method obtains the generalized positions for model instance.</p>
<p>Model instances are frequently defined through SDFormat files (using the <span class="tt">model</span> tag) and are automatically created when SDFormat files are parsed (by <a class="el" href="classdrake_1_1multibody_1_1_parser.html" title="Parses model description input into a MultibodyPlant and (optionally) a SceneGraph.">Parser</a>). There are two special <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0" title="Type used to identify model instances by index within a multibody plant.">multibody::ModelInstanceIndex</a> values. The world body is always <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0" title="Type used to identify model instances by index within a multibody plant.">multibody::ModelInstanceIndex</a> 0. <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0" title="Type used to identify model instances by index within a multibody plant.">multibody::ModelInstanceIndex</a> 1 is reserved for all elements with no explicit model instance and is generally only relevant for elements created programmatically (and only when a model instance is not explicitly specified). Note that <a class="el" href="classdrake_1_1multibody_1_1_parser.html" title="Parses model description input into a MultibodyPlant and (optionally) a SceneGraph.">Parser</a> creates model instances (resulting in a <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0" title="Type used to identify model instances by index within a multibody plant.">multibody::ModelInstanceIndex</a> ≥ 2) as needed.</p>
<p>See <a class="el" href="#ac89140adb93cb9e507f71c30eb783198" title="Returns the number of model instances in the model.">num_model_instances()</a>, <a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">num_positions()</a>, <a class="el" href="#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a>, <a class="el" href="#ae3fc8de8de8eaf2d37a24c79d6be8e97" title="Returns the total number of actuated degrees of freedom.">num_actuated_dofs()</a>, <a class="el" href="#a4edf1daa65069a26255c903b02bce4c6" title="Creates a new model instance.">AddModelInstance()</a> <a class="el" href="#a61c4037d7f25d2e511f86e9102772290" title="Returns a const vector reference [q; v] to the generalized positions q and generalized velocities v i...">GetPositionsAndVelocities()</a>, <a class="el" href="#a15aab0eeb92b8e9f0a9bfcab8abaca69" title="Returns a const vector reference to the vector of generalized positions q in a given Context.">GetPositions()</a>, <a class="el" href="#a83faa6d43006794cd8f7ee6f851e1d09" title="Returns a const vector reference to the generalized velocities v in a given Context.">GetVelocities()</a>, <a class="el" href="#acdf6af4e5e5e71b55ea7ea3034ac5e90" title="Sets generalized positions q and generalized velocities v in a given Context from a given vector [q; ...">SetPositionsAndVelocities()</a>, <a class="el" href="#a40ecddd72c91e66ee38fe023bc58b3a0" title="Sets the generalized positions q in a given Context from a given vector.">SetPositions()</a>, <a class="el" href="#aa6864e2bce8855ab702b8ea1bb748f00" title="Sets the generalized velocities v in a given Context from a given vector.">SetVelocities()</a>, <a class="el" href="#a5d2ae02e64d4433eb7c5bbebd2a9dd0d" title="Returns a vector of generalized positions for model_instance from a vector q_array of generalized pos...">GetPositionsFromArray()</a>, <a class="el" href="#a52b25b565255d213a7f483b12f18ab68" title="Returns a vector of generalized velocities for model_instance from a vector v of generalized velociti...">GetVelocitiesFromArray()</a>, <a class="el" href="#ab264035a2e8c56b57bd80afb0b6ffb48" title="Sets the vector of generalized positions for model_instance in q using q_instance,...">SetPositionsInArray()</a>, <a class="el" href="#a89105b866dae232e6a9236d50f1fb08c" title="Sets the vector of generalized velocities for model_instance in v using v_instance,...">SetVelocitiesInArray()</a>, <a class="el" href="#a695e24adcadab868d6dd5a57f51953fd" title="Given actuation values u_instance for the actuators in model_instance, this function updates the actu...">SetActuationInArray()</a>, <a class="el" href="#ae12f32b40b7a41c3aa933ed74b2417fb">HasModelInstanceNamed()</a>, <a class="el" href="#a6967a3b13b5d006821d7590945a0c168" title="Returns the name of a model_instance.">GetModelInstanceName()</a>, <a class="el" href="#a3c6b13fba0889c4bb9a88610254a387b" title="Returns a constant reference to the output port for the multibody state x = [q, v] of the model.">get_state_output_port()</a>, <a class="el" href="#a69ef9262ffab02b34bdf20449aab7551" title="Returns a constant reference to the input port for external actuation for all actuated dofs.">get_actuation_input_port()</a>.</p>
<p><a class="anchor" id="mbp_equations_of_motion"></a></p><h3>System dynamics</h3>
<p>The state of a multibody system <span class="tt">x = [q; v]</span> is given by its generalized positions vector q, of size <span class="tt">nq</span> (see <a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">num_positions()</a>), and by its generalized velocities vector v, of size <span class="tt">nv</span> (see <a class="el" href="#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a>).</p>
<p>A MultibodyPlant can be constructed to be either continuous or discrete. The choice is indicated by the time_step passed to the constructor &ndash; a non-zero time_step indicates a discrete plant, while a zero time_step indicates continuous. A <a class="el" href="classdrake_1_1systems_1_1_simulator.html">Simulator</a> will step a discrete plant using the indicated time_step, but will allow a numerical integrator to choose how to advance time for a continuous MultibodyPlant.</p>
<p>We'll discuss continuous plant dynamics in this section. Discrete dynamics is more complicated and gets its own section below.</p>
<p>As a Drake <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>, MultibodyPlant implements the governing equations for a multibody dynamical system in the form <span class="tt">ẋ = f(t, x, u)</span> with t being time and u external inputs such as actuation forces. The governing equations for the dynamics of a multibody system modeled with MultibodyPlant are [Featherstone 2008, Jain 2010]: </p><pre>
         q̇ = N(q)v
  (1)    M(q)v̇ + C(q, v)v = τ
</pre><p> where <span class="tt">M(q)</span> is the mass matrix of the multibody system (including rigid body mass properties and <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#reflected_inertia">reflected inertias</a>), <span class="tt">C(q, v)v</span> contains Coriolis, centripetal, and gyroscopic terms and <span class="tt">N(q)</span> is the kinematic coupling matrix describing the relationship between q̇ (the time derivatives of the generalized positions) and the generalized velocities v, [Seth 2010]. <span class="tt">N(q)</span> is an <span class="tt">nq x nv</span> matrix. The vector <span class="tt">τ ∈ ℝⁿᵛ</span> on the right hand side of Eq. (1) is the system's generalized forces. These incorporate gravity, springs, externally applied body forces, constraint forces, and contact forces.</p>
<p><a class="anchor" id="mbp_discrete_dynamics"></a></p><h3>Discrete system dynamics</h3>
<p>We'll start with the basic difference equation interpretation of a discrete plant and then explain some Drake-specific subtleties.</p>
<dl class="section note"><dt>Note</dt><dd>We use "kinematics" here to refer to quantities that involve only position or velocity, and "dynamics" to refer to quantities that also involve forces.</dd></dl>
<p>By default, a discrete MultibodyPlant has these update dynamics: </p><pre class="fragment">   x[0] = initial kinematics      state variables x (={q, v}), s
   s[0] = empty (no sample yet)

 s[n+1] = g(t[n], x[n], u[n])     record sample
 x[n+1] = f(t[n], x[n], u[n])     update kinematics
yd[n+1] = gd(s)                   dynamic outputs use sampled values
yk[n+1] = gk(x)                   kinematic outputs use current x
</pre><p>Optionally, output port sampling can be disabled. In that case we have: </p><pre class="fragment"> x[n+1] = f(t[n], x[n], u[n])       update kinematics
yd[n+1] = gd(g(t, x, u))            dynamic outputs use current values
yk[n+1] = gk(x)                     kinematic outputs use current x
</pre><p>We're using <span class="tt">yd</span> and <span class="tt">yk</span> above to represent the calculated values of dynamic and kinematic output ports, resp. Kinematic output ports are those that depend only on position and velocity: <span class="tt">state</span>, <span class="tt">body_poses</span>, <span class="tt">body_spatial_velocities</span>. Everything else depends on forces so is a dynamic output port: <span class="tt">body_spatial_accelerations</span>, <span class="tt">generalized_acceleration</span>, <span class="tt">net_actuation</span>, <span class="tt">reaction_forces</span>, and <span class="tt">contact_results</span>.</p>
<p>Use the function <a class="el" href="#adb2f51f2f513478a97b0175bff3a65ae" title="(Advanced) For a discrete-time plant, configures whether the output ports are sampled (the default) o...">SetUseSampledOutputPorts()</a> to choose which dynamics you prefer. The default behavior (output port sampling) is more efficient for simulation, but use slightly-different kinematics for the dynamic output port computations versus the kinematic output ports. Disabling output port sampling provides "live" output port results that are recalculated from the current state and inputs whenever changes occur. It also eliminates the sampling state variable (s above). Note that kinematic output ports (that is, those depending only on position and velocity) are always "live" &ndash; they are calculated as needed from the current (updated) state.</p>
<p>The reason that the default mode is more efficient for simulation is that the sample variable s records expensive-to-compute results (such as hydroelastic contact forces) that are needed to advance the state x. Those results are thus available for free at the start of step n. If instead we wait until after the state is updated to n+1, we would have to recalculate those expensive results at the new state in order to report them. Thus sampling means the output ports show the results that were calculated using kinematics values x[n], although the Context has been updated to kinematics values x[n+1]. If that isn't tolerable you should disable output port sampling. You can also force an update to occur using <a class="el" href="classdrake_1_1systems_1_1_system.html#a90b36c14bbcdf47bf14f2906e18573ca" title="This method triggers all of the forced events registered with this System (which might be a Diagram).">ExecuteForcedEvents()</a>.</p>
<p>See <a class="el" href="#output_port_sampling">Output port sampling</a> below for more practical considerations.</p>
<p>Minor details most users won't care about:</p>
<ul>
<li>The sample variable s is a Drake Abstract state variable. When it is present, the plant update is performed using an Unrestricted update; when it is absent we are able to use a Discrete update. Some Drake features (e.g. linearization of discrete systems) may be restricted to systems that use only Discrete (numeric) state variables and Discrete update.</li>
<li>The sample variable s is used only by output ports. It does not affect the behavior of any <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> "Calc" or "Eval" functions &ndash; those are always calculated using the current values of time, kinematic state, and input port values.</li>
</ul>
<p><a class="anchor" id="output_port_sampling"></a></p><h3>Output port sampling</h3>
<p>As described in <a class="el" href="#mbp_discrete_dynamics">Discrete system dynamics</a> above, the semantics of certain MultibodyPlant output ports depends on whether the plant is configured to advance using continuous time integration or discrete time steps (see is_discrete()). This section explains the details, focusing on the practical aspects moreso than the equations.</p>
<p>Output ports that only depend on the [q, v] kinematic state (such as <a class="el" href="#a120e794678007aaf5494894806ce3e6f" title="Returns the output port of all body poses in the world frame.">get_body_poses_output_port()</a> or <a class="el" href="#a5f76813ea964f4c30e21bb841c182a0c" title="Returns the output port of all body spatial velocities in the world frame.">get_body_spatial_velocities_output_port()</a>) do <em>not</em> change semantics for continuous vs discrete time. In all cases, the output value is a function of the kinematic state in the context.</p>
<p>Output ports that incorporate dynamics (i.e., forces) <em>do</em> change semantics based on the plant mode. Imagine that the <a class="el" href="#a241c6a79cee07ffff3eaac93f47947c8" title="Returns a constant reference to the input port for applying spatial forces to bodies in the plant.">get_applied_spatial_force_input_port()</a> provides a continuously time-varying input force. The <a class="el" href="#a482d55aca3da9ee3786b507c9c964b40" title="Returns the output port of all body spatial accelerations in the world frame.">get_body_spatial_accelerations_output_port()</a> output is dependent on that force. We could return a snapshot of the acceleration that was used in the last time step, or we could recalculate the acceleration to immediately reflect the changing forces. We call the former a "sampled" port and the latter a "live" port.</p>
<p>For a continuous-time plant, there is no distinction &ndash; the output port is always live &ndash; it immediately reflects the instantaneous input value. It is a "direct feedthrough" output port (see SystemBase::GetDirectFeedthroughs()).</p>
<p>For a discrete-time plant, the user can choose whether the output should be sampled or live: Use the function <a class="el" href="#adb2f51f2f513478a97b0175bff3a65ae" title="(Advanced) For a discrete-time plant, configures whether the output ports are sampled (the default) o...">SetUseSampledOutputPorts()</a> to change whether output ports are sampled or not, and <a class="el" href="#ad6b97bb53425156402e7f46d72859e1e" title="(Advanced) If this plant is continuous (i.e., is_discrete() is false), returns false.">has_sampled_output_ports()</a> to check the current setting. When sampling is disabled, the only state in the context is the kinematic [q, v], so dynamics output ports will always reflect the instantaneous answer (i.e., direct feedthrough). When sampling is enabled (the default), the plant state incorporates a snapshot of the most recent step's kinematics and dynamics, and the output ports will reflect that sampled state (i.e., not direct feedthrough). For a detailed discussion, see <a class="el" href="#mbp_discrete_dynamics">Discrete system dynamics</a>.</p>
<p>For a discrete-time plant, the sampled outputs are generally <em>much</em> faster to calculate than the feedthrough outputs when any inputs ports are changing values faster than the discrete time step, e.g., during a simulation. When input ports are fixed, or change at the time step rate (e.g., during motion planning), sampled vs feedthrough will have similar computational performance.</p>
<p>Direct plant API function calls (e.g., <a class="el" href="#ae663a7a52206ea41f2520ec926bd2cb2" title="Evaluates A_WB, body B&#39;s spatial acceleration in the world frame W.">EvalBodySpatialAccelerationInWorld()</a>) that depend on forces always use the instantaneous (not sampled) accelerations.</p>
<p>Here are some practical tips that might help inform your particular situation:</p>
<p>(1) If you need a minimal-state representation for motion planning, mathematical optimization, or similar, then you can either use a continuous-time plant or set the config option <span class="tt">use_sampled_output_ports=false</span> on a discrete-time plant.</p>
<p>(2) By default, setting the positions of a discrete-time plant in the Context will not have any effect on the dynamics-related output ports, e.g., the contact results will not change. If you need to see changes to outputs without running the plant in a Simulator, then you can either use a continuous-time plant, set the config option <span class="tt">use_sampled_output_ports=false</span>, or use <a class="el" href="classdrake_1_1systems_1_1_system.html#a90b36c14bbcdf47bf14f2906e18573ca" title="This method triggers all of the forced events registered with this System (which might be a Diagram).">ExecuteForcedEvents()</a> to force a dynamics step and then the outputs (and positions) will change.</p>
<p><a class="anchor" id="mbp_actuation"></a></p><h3>Actuation</h3>
<p>In a MultibodyPlant model an actuator can be added as a <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a>, see <a class="el" href="#ae6e70af2d399ab5b665a3f36a5ada172" title="Creates and adds a JointActuator model for an actuator acting on a given joint.">AddJointActuator()</a>. The plant declares actuation input ports to provide feedforward actuation, both for the MultibodyPlant as a whole (see <a class="el" href="#a69ef9262ffab02b34bdf20449aab7551" title="Returns a constant reference to the input port for external actuation for all actuated dofs.">get_actuation_input_port()</a>) and for each individual <a class="el" href="#model_instances">model instance</a> in the MultibodyPlant (see <a class="el" href="#a776f6189a7a33efee4aed2a9135f5150">get_actuation_input_port(ModelInstanceIndex)</a>).</p><ul>
<li>Actuation inputs and actuation effort limits are taken to be in joint coordinates (they are not affected by the actuator gear ratio).</li>
<li>Any actuation input ports not connected are assumed to be zero.</li>
<li>Actuation values from the full MultibodyPlant model port (<a class="el" href="#a69ef9262ffab02b34bdf20449aab7551" title="Returns a constant reference to the input port for external actuation for all actuated dofs.">get_actuation_input_port()</a>) and from the per model-instance ports ( <a class="el" href="#a776f6189a7a33efee4aed2a9135f5150">get_actuation_input_port(ModelInstanceIndex)</a>) are summed up.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>A <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a>'s index into the vector data supplied to MultibodyPlant's actuation input port for all actuators (<a class="el" href="#a69ef9262ffab02b34bdf20449aab7551" title="Returns a constant reference to the input port for external actuation for all actuated dofs.">get_actuation_input_port()</a>) is given by <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#a42d883dde11e65819319f8060b0843b4" title="Returns the index to the first element for this joint actuator / within the vector of actuation input...">JointActuator::input_start()</a>, NOT by its <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c" title="Type used to identify actuators by index within a multibody plant.">JointActuatorIndex</a>. That is, the vector element data for a <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a> at index <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c" title="Type used to identify actuators by index within a multibody plant.">JointActuatorIndex(i)</a> in the full input port vector is found at index: MultibodyPlant::get_joint_actuator(JointActuatorIndex(i)).input_start(). For the <a class="el" href="#a776f6189a7a33efee4aed2a9135f5150">get_actuation_input_port(ModelInstanceIndex)</a> specific to a model index, the vector data is ordered by monotonically increasing <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> for the actuators within that model instance: the 0ᵗʰ vector element corresponds to the lowest-numbered JointActuatorIndex of that instance, the 1ˢᵗ vector element corresponds to the second-lowest-numbered JointActuatorIndex of that instance, etc.</dd>
<dd>
The following snippet shows how per model instance actuation can be set: <div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance_index = ...;</div>
<div class="line"><a class="code hl_typedef" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX&lt;T&gt;</a> u_instance(plant.num_actuated_dofs(model_instance_index));</div>
<div class="line"><span class="keywordtype">int</span> offset = 0;</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code hl_typedef" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> joint_actuator_index :</div>
<div class="line">         plant.GetJointActuatorIndices(model_instance_index)) {</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator&lt;T&gt;</a>&amp; actuator = plant.get_joint_actuator(</div>
<div class="line">      joint_actuator_index);</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1multibody_1_1_joint.html">Joint&lt;T&gt;</a>&amp; joint = actuator.<a class="code hl_function" href="classdrake_1_1multibody_1_1_joint_actuator.html#a3b5b554176d07aad193f03b5d90c8b2d">joint</a>();</div>
<div class="line">  <a class="code hl_typedef" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX&lt;T&gt;</a> u_joint = ... my_actuation_logic_for(joint) ...;</div>
<div class="line">  ASSERT(u_joint.size() == joint_actuator.num_inputs());</div>
<div class="line">  u_instance.segment(offset, u_joint.size()) = u_joint;</div>
<div class="line">  offset += u_joint.size();</div>
<div class="line">}</div>
<div class="line">plant.get_actuation_input_port(model_instance_index).FixValue(</div>
<div class="line">    plant_context, u_instance);</div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_joint_actuator_html"><div class="ttname"><a href="classdrake_1_1multibody_1_1_joint_actuator.html">drake::multibody::JointActuator</a></div><div class="ttdoc">The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...</div><div class="ttdef"><b>Definition</b> joint_actuator.h:39</div></div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_joint_actuator_html_a3b5b554176d07aad193f03b5d90c8b2d"><div class="ttname"><a href="classdrake_1_1multibody_1_1_joint_actuator.html#a3b5b554176d07aad193f03b5d90c8b2d">drake::multibody::JointActuator::joint</a></div><div class="ttdeci">const Joint&lt; T &gt; &amp; joint() const</div><div class="ttdoc">Returns a reference to the joint actuated by this JointActuator.</div></div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_joint_html"><div class="ttname"><a href="classdrake_1_1multibody_1_1_joint.html">drake::multibody::Joint</a></div><div class="ttdoc">A Joint models the kinematical relationship which characterizes the possible relative motion between ...</div><div class="ttdef"><b>Definition</b> joint.h:84</div></div>
<div class="ttc" id="anamespacedrake_1_1multibody_html_acc810ff385ed4dede2e011b0b6fd3f2c"><div class="ttname"><a href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">drake::multibody::JointActuatorIndex</a></div><div class="ttdeci">TypeSafeIndex&lt; class JointActuatorElementTag &gt; JointActuatorIndex</div><div class="ttdoc">Type used to identify actuators by index within a multibody plant.</div><div class="ttdef"><b>Definition</b> multibody_tree_indexes.h:48</div></div>
<div class="ttc" id="anamespacedrake_1_1multibody_html_af65439a17091283a89eb12f1955c6db0"><div class="ttname"><a href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">drake::multibody::ModelInstanceIndex</a></div><div class="ttdeci">TypeSafeIndex&lt; class ModelInstanceTag &gt; ModelInstanceIndex</div><div class="ttdoc">Type used to identify model instances by index within a multibody plant.</div><div class="ttdef"><b>Definition</b> multibody_tree_indexes.h:54</div></div>
<div class="ttc" id="anamespacedrake_html_a77dd228fb4dd66a2c17dd3f7f38ffd85"><div class="ttname"><a href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">drake::VectorX</a></div><div class="ttdeci">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, 1 &gt; VectorX</div><div class="ttdoc">A column vector of any size, templated on scalar type.</div><div class="ttdef"><b>Definition</b> eigen_types.h:67</div></div>
</div><!-- fragment --></dd>
<dd>
To inter-operate between the whole plant actuation vector and sets of per-model instance actuation vectors, see <a class="el" href="#a695e24adcadab868d6dd5a57f51953fd" title="Given actuation values u_instance for the actuators in model_instance, this function updates the actu...">SetActuationInArray()</a> to gather the model instance vectors into a whole plant vector and <a class="el" href="#a7a29c9845043cc59458a5a3f3d8fd5f6" title="Returns a vector of actuation values for model_instance from a vector u of actuation values for the e...">GetActuationFromArray()</a> to scatter the whole plant vector into per-model instance vectors.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Effort limits (<a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#a5e00d5f4ea204b3bab3d733b8a64b9eb" title="Returns the actuator effort limit.">JointActuator::effort_limit()</a>) are not enforced, unless PD controllers are defined. See <a class="el" href="#pd_controllers">Using PD controlled actuators</a>.</dd></dl>
<p><a class="anchor" id="pd_controllers"></a></p><h4>Using PD controlled actuators</h4>
<p>While PD controllers can be modeled externally and be connected to the MultibodyPlant model via the <a class="el" href="#a69ef9262ffab02b34bdf20449aab7551" title="Returns a constant reference to the input port for external actuation for all actuated dofs.">get_actuation_input_port()</a>, simulation stability at discrete-time steps can be compromised for high controller gains. For such cases, simulation stability and robustness can be improved significantly by moving your PD controller into the plant where the discrete solver can strongly couple controller and model dynamics.</p>
<dl class="section warning"><dt>Warning</dt><dd>Currently, this feature is only supported for discrete models (is_discrete() is true) using the SAP solver (<a class="el" href="#ad7698366750a09e383106a17bf9009a2" title="Returns the contact solver type used for discrete MultibodyPlant models.">get_discrete_contact_solver()</a> returns <a class="el" href="namespacedrake_1_1multibody.html#a902306c5e0120a67c07f80e9219a3e8dad48dc7e3221aee2d9e1af665ebfbeeec" title="SAP solver, see [Castro et al., 2022].">DiscreteContactSolver::kSap</a>.)</dd></dl>
<p>PD controlled joint actuators can be defined by setting PD gains for each joint actuator, see <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#a0d23c206d13900df47e009ce56fddfeb" title="Set controller gains for this joint actuator.">JointActuator::set_controller_gains()</a>. Unless these gains are specified, joint actuators will not be PD controlled and <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#a2ae9bfe9ff9fa92e86c62acc0179d459" title="Returns true if any non-zero controller gains have been specified with a call to set_controller_gains...">JointActuator::has_controller()</a> will return <span class="tt">false</span>.</p>
<p>For models with PD controllers, the actuation torque per actuator is computed according to: </p><pre>
  ũ = -Kp⋅(q − qd) - Kd⋅(v − vd) + u_ff
  u = max(−e, min(e, ũ))
</pre><p> where qd and vd are desired configuration and velocity (see <a class="el" href="#acb103492157aa5e69843c22c394d1de5" title="For models with PD controlled joint actuators, returns the port to provide the desired state for the ...">get_desired_state_input_port()</a>) for the actuated joint (see <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#a3b5b554176d07aad193f03b5d90c8b2d" title="Returns a reference to the joint actuated by this JointActuator.">JointActuator::joint()</a>), Kp and Kd are the proportional and derivative gains of the actuator (see <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#a19405121e493076b6368acc4ca3e865d" title="Returns a reference to the controller gains for this actuator.">JointActuator::get_controller_gains()</a>), <span class="tt">u_ff</span> is the feed-forward actuation specified with <a class="el" href="#a69ef9262ffab02b34bdf20449aab7551" title="Returns a constant reference to the input port for external actuation for all actuated dofs.">get_actuation_input_port()</a>, and <span class="tt">e</span> corresponds to effort limit (see <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#a5e00d5f4ea204b3bab3d733b8a64b9eb" title="Returns the actuator effort limit.">JointActuator::effort_limit()</a>).</p>
<p>Notice that actuation through <a class="el" href="#a69ef9262ffab02b34bdf20449aab7551" title="Returns a constant reference to the input port for external actuation for all actuated dofs.">get_actuation_input_port()</a> and PD control are not mutually exclusive, and they can be used together. This is better explained through examples:</p><ol type="1">
<li><b>PD controlled gripper</b>. In this case, only PD control is used to drive the opening and closing of the fingers. The feed-forward term is assumed to be zero and the actuation input port is not required to be connected.</li>
<li><b>Robot arm</b>. A typical configuration consists on applying gravity compensation in the feed-forward term plus PD control to drive the robot to a given desired state.</li>
</ol>
<p><a class="anchor" id="pd_controllers_and_ports"></a></p><h4>Actuation input ports requirements</h4>
<p>Actuation input ports and desired state input ports need not be connected:</p><ul>
<li>Unconnected actuation inputs default to zero, simplifying diagram wiring for models relying solely on PD controllers.</li>
<li>PD controllers are disarmed when their model instance's desired state input port is disconnected. In this state, they have no effect on dynamics, behaving as if no PD controller exists. This allows a MultibodyPlant model to be used outside simulation (e.g., for visualization).</li>
</ul>
<p>Note that both ports are always created but will be zero-sized for model instances without actuation.</p>
<h4>Net actuation</h4>
<p>The total joint actuation applied via the actuation input port (<a class="el" href="#a69ef9262ffab02b34bdf20449aab7551" title="Returns a constant reference to the input port for external actuation for all actuated dofs.">get_actuation_input_port()</a>) and applied by the PD controllers is reported by the net actuation port (<a class="el" href="#a1bd2d6bf64c3bc65af05bdf0b634120e" title="Returns a constant reference to the output port that reports actuation values applied through joint a...">get_net_actuation_output_port()</a>). That is, the net actuation port reports the total actuation applied by a given actuator.</p>
<dl class="section note"><dt>Note</dt><dd>PD controllers are ignored when a joint is locked (see <a class="el" href="classdrake_1_1multibody_1_1_joint.html#a50c7f850050d4a94641ed72dd2d1968f" title="Lock the joint.">Joint::Lock()</a>), and thus they have no effect on the actuation output.</dd></dl>
<p><a class="anchor" id="sdf_loading"></a></p><h3>Loading models from SDFormat files</h3>
<p>Drake has the capability to load multibody models from SDFormat and URDF files. Consider the example below which loads an acrobot model: </p><div class="fragment"><div class="line"><a class="code hl_friend" href="#a47a63154823dffd5838329527aafbd58">MultibodyPlant&lt;T&gt;</a> acrobot;</div>
<div class="line">SceneGraph&lt;T&gt; scene_graph;</div>
<div class="line"><a class="code hl_class" href="classdrake_1_1multibody_1_1_parser.html">Parser</a> parser(&amp;acrobot, &amp;scene_graph);</div>
<div class="line"><span class="keyword">const</span> std::string url =</div>
<div class="line">    <span class="stringliteral">&quot;package://drake/multibody/benchmarks/acrobot/acrobot.sdf&quot;</span>;</div>
<div class="line">parser.AddModelsFromUrl(url);</div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_multibody_plant_html_a47a63154823dffd5838329527aafbd58"><div class="ttname"><a href="#a47a63154823dffd5838329527aafbd58">drake::multibody::MultibodyPlant::MultibodyPlant</a></div><div class="ttdeci">friend class MultibodyPlant</div><div class="ttdef"><b>Definition</b> multibody_plant.h:5848</div></div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_parser_html"><div class="ttname"><a href="classdrake_1_1multibody_1_1_parser.html">drake::multibody::Parser</a></div><div class="ttdoc">Parses model description input into a MultibodyPlant and (optionally) a SceneGraph.</div><div class="ttdef"><b>Definition</b> parser.h:132</div></div>
</div><!-- fragment --><p> As in the example above, for models including visual geometry, collision geometry or both, the user must specify a SceneGraph for geometry handling. You can find a full example of the LQR controlled acrobot in examples/multibody/acrobot/run_lqr.cc.</p>
<p>AddModelFromFile() can be invoked multiple times on the same plant in order to load multiple model instances. Other methods are available on <a class="el" href="classdrake_1_1multibody_1_1_parser.html" title="Parses model description input into a MultibodyPlant and (optionally) a SceneGraph.">Parser</a> such as AddModels() which allows creating model instances per each <span class="tt">&lt;model&gt;</span> tag found in the file. Please refer to each of these methods' documentation for further details.</p>
<p><a class="anchor" id="working_with_scenegraph"></a></p><h3>Working with SceneGraph</h3>
<p><a class="anchor" id="add_multibody_plant_scene_graph"></a></p><h4>Adding a MultibodyPlant connected to a SceneGraph to your Diagram</h4>
<p>Probably the simplest way to add and wire up a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> with a SceneGraph in your Diagram is using <a class="el" href="#a8b71553122d35a449d2131789a3f94c2" title="Makes a new MultibodyPlant with discrete update period time_step and adds it to a diagram builder tog...">AddMultibodyPlantSceneGraph()</a>.</p>
<p>Recommended usages:</p>
<p>Assign to a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> reference (ignoring the SceneGraph): </p><div class="fragment"><div class="line"><a class="code hl_friend" href="#a47a63154823dffd5838329527aafbd58">MultibodyPlant&lt;double&gt;</a>&amp; plant =</div>
<div class="line">    <a class="code hl_function" href="#a8b71553122d35a449d2131789a3f94c2">AddMultibodyPlantSceneGraph</a>(&amp;builder, 0.0 /+ <a class="code hl_function" href="#a8daceb7a3c384d6ad9f305e42b5fc1c6">time_step</a> +/);</div>
<div class="line">plant.DoFoo(...);</div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_multibody_plant_html_a8b71553122d35a449d2131789a3f94c2"><div class="ttname"><a href="#a8b71553122d35a449d2131789a3f94c2">drake::multibody::MultibodyPlant::AddMultibodyPlantSceneGraph</a></div><div class="ttdeci">AddMultibodyPlantSceneGraphResult&lt; T &gt; AddMultibodyPlantSceneGraph(systems::DiagramBuilder&lt; T &gt; *builder, double time_step, std::unique_ptr&lt; geometry::SceneGraph&lt; T &gt; &gt; scene_graph=nullptr)</div><div class="ttdoc">Makes a new MultibodyPlant with discrete update period time_step and adds it to a diagram builder tog...</div></div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_multibody_plant_html_a8daceb7a3c384d6ad9f305e42b5fc1c6"><div class="ttname"><a href="#a8daceb7a3c384d6ad9f305e42b5fc1c6">drake::multibody::MultibodyPlant::time_step</a></div><div class="ttdeci">double time_step() const</div><div class="ttdoc">The time step (or period) used to model this plant as a discrete system with periodic updates.</div><div class="ttdef"><b>Definition</b> multibody_plant.h:5135</div></div>
</div><!-- fragment --><p> This flavor is the simplest, when the SceneGraph is not explicitly needed. (It can always be retrieved later via GetSubsystemByName("scene_graph").)</p>
<p>Assign to auto, and use the named public fields: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> items = <a class="code hl_function" href="#a8b71553122d35a449d2131789a3f94c2">AddMultibodyPlantSceneGraph</a>(&amp;builder, 0.0 /+ <a class="code hl_function" href="#a8daceb7a3c384d6ad9f305e42b5fc1c6">time_step</a> +/);</div>
<div class="line">items.plant.DoFoo(...);</div>
<div class="line">items.scene_graph.DoBar(...);</div>
</div><!-- fragment --><p> or taking advantage of C++'s structured binding: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> [plant, scene_graph] = <a class="code hl_function" href="#a8b71553122d35a449d2131789a3f94c2">AddMultibodyPlantSceneGraph</a>(&amp;builder, 0.0);</div>
<div class="line">...</div>
<div class="line">plant.DoFoo(...);</div>
<div class="line">scene_graph.DoBar(...);</div>
</div><!-- fragment --><p> This is the easiest way to use both the plant and scene_graph.</p>
<p>Assign to already-declared pointer variables: </p><div class="fragment"><div class="line"><a class="code hl_friend" href="#a47a63154823dffd5838329527aafbd58">MultibodyPlant&lt;double&gt;</a>* plant{};</div>
<div class="line">SceneGraph&lt;double&gt;* scene_graph{};</div>
<div class="line">std::tie(plant, scene_graph) =</div>
<div class="line">    <a class="code hl_function" href="#a8b71553122d35a449d2131789a3f94c2">AddMultibodyPlantSceneGraph</a>(&amp;builder, 0.0 /+ <a class="code hl_function" href="#a8daceb7a3c384d6ad9f305e42b5fc1c6">time_step</a> +/);</div>
<div class="line">plant-&gt;DoFoo(...);</div>
<div class="line">scene_graph-&gt;DoBar(...);</div>
</div><!-- fragment --><p> This flavor is most useful when the pointers are class member fields (and so perhaps cannot be references).</p>
<p><a class="anchor" id="mbp_geometry_registration"></a></p><h4>Registering geometry with a SceneGraph</h4>
<p>MultibodyPlant users can register geometry with a SceneGraph for essentially two purposes; a) visualization and, b) contact modeling.</p>
<p>Before any geometry registration takes place, a user <b>must</b> first make a call to <a class="el" href="#a4a6d28ce9c8119bee923e827eb6f02ed" title="Registers this plant to serve as a source for an instance of SceneGraph.">RegisterAsSourceForSceneGraph()</a> in order to register the MultibodyPlant as a client of a SceneGraph instance, point at which the plant will have assigned a valid <a class="el" href="namespacedrake_1_1geometry.html#ac53cb597123131fb23a7af26e8d350bf" title="Type used to identify geometry sources in SceneGraph.">geometry::SourceId</a>. At <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>, MultibodyPlant will declare input/output ports as appropriate to communicate with the SceneGraph instance on which registrations took place. All geometry registration <b>must</b> be performed pre-finalize.</p>
<p>Multibodyplant declares an input port for geometric queries, see <a class="el" href="#a38d417c47f17405fb748b5bb02140bcd" title="Returns a constant reference to the input port used to perform geometric queries on a SceneGraph.">get_geometry_query_input_port()</a>. If MultibodyPlant registers geometry with a SceneGraph via calls to <a class="el" href="#a90d32a93de07ef91744b95ed152c578d" title="Registers geometry in a SceneGraph with a given geometry::Shape to be used for the contact modeling o...">RegisterCollisionGeometry()</a>, users may use this port for geometric queries. The port must be connected to the same SceneGraph used for registration. The preferred mechanism is to use <a class="el" href="#a8b71553122d35a449d2131789a3f94c2" title="Makes a new MultibodyPlant with discrete update period time_step and adds it to a diagram builder tog...">AddMultibodyPlantSceneGraph()</a> as documented above.</p>
<p>In extraordinary circumstances, this can be done by hand and the setup process will include:</p>
<ol type="1">
<li>Call to <a class="el" href="#a4a6d28ce9c8119bee923e827eb6f02ed" title="Registers this plant to serve as a source for an instance of SceneGraph.">RegisterAsSourceForSceneGraph()</a>.</li>
<li>Calls to <a class="el" href="#a90d32a93de07ef91744b95ed152c578d" title="Registers geometry in a SceneGraph with a given geometry::Shape to be used for the contact modeling o...">RegisterCollisionGeometry()</a>, as many as needed.</li>
<li>Call to <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>, user is done specifying the model.</li>
<li>Connect <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html#a84b04e5623e12e97d6021445a3687283" title="Returns the output port which produces the QueryObject for performing geometric queries.">geometry::SceneGraph::get_query_output_port()</a> to <a class="el" href="#a38d417c47f17405fb748b5bb02140bcd" title="Returns a constant reference to the input port used to perform geometric queries on a SceneGraph.">get_geometry_query_input_port()</a>.</li>
<li>Connect <a class="el" href="#a986b7f0917bb20533970dc7658770237" title="Returns the output port of frames&#39; poses to communicate with a SceneGraph.">get_geometry_pose_output_port()</a> to <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html#adcd7d53c0e18e7bc5cb39d5856f7cca7" title="Given a valid source id, returns a pose input port associated with that id.">geometry::SceneGraph::get_source_pose_port()</a></li>
</ol>
<p>Refer to the documentation provided in each of the methods above for further details.</p>
<p><a class="anchor" id="accessing_contact_properties"></a></p><h4>Accessing point contact parameters</h4>
<p>MultibodyPlant's point contact model looks for model parameters stored as <a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html" title="The set of properties for geometry used in a proximity role.">geometry::ProximityProperties</a> by <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">geometry::SceneGraph</a>. These properties can be obtained before or after context creation through <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html" title="The SceneGraphInspector serves as a mechanism to query the topological structure of a SceneGraph inst...">geometry::SceneGraphInspector</a> APIs as outlined below. MultibodyPlant expects the following properties for point contact modeling:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Group name  </th><th class="markdownTableHeadCenter">Property Name  </th><th class="markdownTableHeadCenter">Required  </th><th class="markdownTableHeadCenter">Property Type  </th><th class="markdownTableHeadLeft">Property Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">material  </td><td class="markdownTableBodyCenter">coulomb_friction  </td><td class="markdownTableBodyCenter">yes¹  </td><td class="markdownTableBodyCenter"><a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html" title="Parameters for Coulomb&#39;s Law of Friction, namely:">CoulombFriction&lt;T&gt;</a>  </td><td class="markdownTableBodyLeft">Static and Dynamic friction.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">material  </td><td class="markdownTableBodyCenter">point_contact_stiffness  </td><td class="markdownTableBodyCenter">no²  </td><td class="markdownTableBodyCenter">T  </td><td class="markdownTableBodyLeft">Compliant point contact stiffness.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">material  </td><td class="markdownTableBodyCenter">hunt_crossley_dissipation  </td><td class="markdownTableBodyCenter">no²⁴  </td><td class="markdownTableBodyCenter">T  </td><td class="markdownTableBodyLeft">Compliant contact dissipation.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">material  </td><td class="markdownTableBodyCenter">relaxation_time  </td><td class="markdownTableBodyCenter">yes³⁴  </td><td class="markdownTableBodyCenter">T  </td><td class="markdownTableBodyLeft">Linear Kelvin–Voigt model parameter.  </td></tr>
</table>
<p>¹ Collision geometry is required to be registered with a <a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html" title="The set of properties for geometry used in a proximity role.">geometry::ProximityProperties</a> object that contains the ("material", "coulomb_friction") property. If the property is missing, MultibodyPlant will throw an exception.</p>
<p>² If the property is missing, MultibodyPlant will use a heuristic value as the default. Refer to the section <a class="el" href="group__compliant__contact.html#point_contact_defaults">Point Contact Default Parameters</a> for further details.</p>
<p>³ When using a linear Kelvin–Voigt model of dissipation (for instance when selecting the SAP solver), collision geometry is required to be registered with a <a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html" title="The set of properties for geometry used in a proximity role.">geometry::ProximityProperties</a> object that contains the ("material", "relaxation_time") property. If the property is missing, an exception will be thrown.</p>
<p>⁴ We allow to specify both hunt_crossley_dissipation and relaxation_time for a given geometry. However only one of these will get used, depending on the configuration of the MultibodyPlant. As an example, if the SAP contact approximation is specified (see <a class="el" href="#a9b3f429ca991bd1028f4f60d6d5f2e61" title="Sets the discrete contact model approximation.">set_discrete_contact_approximation()</a>) only the relaxation_time is used while hunt_crossley_dissipation is ignored. Conversely, if the TAMSI, Similar or Lagged approximation is used (see <a class="el" href="#a9b3f429ca991bd1028f4f60d6d5f2e61" title="Sets the discrete contact model approximation.">set_discrete_contact_approximation()</a>) only hunt_crossley_dissipation is used while relaxation_time is ignored. Currently, a continuous MultibodyPlant model will always use the Hunt &amp; Crossley model and relaxation_time will be ignored.</p>
<p>Accessing and modifying contact properties requires interfacing with <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">geometry::SceneGraph</a>'s model inspector. Interfacing with a model inspector obtained from <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">geometry::SceneGraph</a> will provide the default registered values for a given parameter. These are the values that will initially appear in a <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">systems::Context</a> created by <a class="el" href="classdrake_1_1systems_1_1_system.html#aa036f873464a74c03fab943bbace8942" title="This convenience method allocates a context using AllocateContext() and sets its default values using...">CreateDefaultContext()</a>. Subsequently, true system parameters can be accessed and changed through a <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">systems::Context</a> once available. For both of the above cases, proximity properties are accessed through <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html" title="The SceneGraphInspector serves as a mechanism to query the topological structure of a SceneGraph inst...">geometry::SceneGraphInspector</a> APIs.</p>
<p>Before context creation an inspector can be retrieved directly from SceneGraph as: </p><div class="fragment"><div class="line"><span class="comment">// For a SceneGraph&lt;T&gt; instance called scene_graph.</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html">geometry::SceneGraphInspector&lt;T&gt;</a>&amp; inspector =</div>
<div class="line">    scene_graph.model_inspector();</div>
<div class="ttc" id="aclassdrake_1_1geometry_1_1_scene_graph_inspector_html"><div class="ttname"><a href="classdrake_1_1geometry_1_1_scene_graph_inspector.html">drake::geometry::SceneGraphInspector</a></div><div class="ttdoc">The SceneGraphInspector serves as a mechanism to query the topological structure of a SceneGraph inst...</div><div class="ttdef"><b>Definition</b> scene_graph_inspector.h:70</div></div>
</div><!-- fragment --><p> After context creation, an inspector can be retrieved from the state stored in the context: </p><div class="fragment"><div class="line"><span class="comment">// For a MultibodyPlant&lt;T&gt; instance called mbp and a Context&lt;T&gt; called</span></div>
<div class="line"><span class="comment">// context.</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html">geometry::SceneGraphInspector&lt;T&gt;</a>&amp; inspector =</div>
<div class="line">    mbp.EvalSceneGraphInspector(context);</div>
</div><!-- fragment --><p> Once an inspector is available, proximity properties can be retrieved as: </p><div class="fragment"><div class="line"><span class="comment">// For a body with GeometryId called geometry_id</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1geometry_1_1_proximity_properties.html">geometry::ProximityProperties</a>* props =</div>
<div class="line">    inspector.<a class="code hl_function" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html#a83bbb55df1a9753ee5f7ae76821dcdae">GetProximityProperties</a>(geometry_id);</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction&lt;T&gt;</a>&amp; geometry_friction =</div>
<div class="line">    props-&gt;<a class="code hl_function" href="classdrake_1_1geometry_1_1_geometry_properties.html#aaaa9388bc0cffeef445272cc5234b087">GetProperty</a>&lt;<a class="code hl_class" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction&lt;T&gt;</a>&gt;(<span class="stringliteral">&quot;material&quot;</span>,</div>
<div class="line">                                           <span class="stringliteral">&quot;coulomb_friction&quot;</span>);</div>
<div class="ttc" id="aclassdrake_1_1geometry_1_1_geometry_properties_html_aaaa9388bc0cffeef445272cc5234b087"><div class="ttname"><a href="classdrake_1_1geometry_1_1_geometry_properties.html#aaaa9388bc0cffeef445272cc5234b087">drake::geometry::GeometryProperties::GetProperty</a></div><div class="ttdeci">decltype(auto) GetProperty(const std::string &amp;group_name, const std::string &amp;name) const</div><div class="ttdoc">Retrieves the typed value for the property (group_name, name) from this set of properties.</div><div class="ttdef"><b>Definition</b> geometry_properties.h:337</div></div>
<div class="ttc" id="aclassdrake_1_1geometry_1_1_proximity_properties_html"><div class="ttname"><a href="classdrake_1_1geometry_1_1_proximity_properties.html">drake::geometry::ProximityProperties</a></div><div class="ttdoc">The set of properties for geometry used in a proximity role.</div><div class="ttdef"><b>Definition</b> geometry_roles.h:171</div></div>
<div class="ttc" id="aclassdrake_1_1geometry_1_1_scene_graph_inspector_html_a83bbb55df1a9753ee5f7ae76821dcdae"><div class="ttname"><a href="classdrake_1_1geometry_1_1_scene_graph_inspector.html#a83bbb55df1a9753ee5f7ae76821dcdae">drake::geometry::SceneGraphInspector::GetProximityProperties</a></div><div class="ttdeci">const ProximityProperties * GetProximityProperties(GeometryId geometry_id) const</div><div class="ttdoc">Returns a pointer to the const proximity properties of the geometry with the given geometry_id.</div></div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_coulomb_friction_html"><div class="ttname"><a href="classdrake_1_1multibody_1_1_coulomb_friction.html">drake::multibody::CoulombFriction</a></div><div class="ttdoc">Parameters for Coulomb&#39;s Law of Friction, namely:</div><div class="ttdef"><b>Definition</b> coulomb_friction.h:62</div></div>
</div><!-- fragment --><p><a class="anchor" id="mbp_parameters"></a></p><h3>Working with MultibodyElement parameters</h3>
<p>Several MultibodyElements expose parameters, allowing the user flexible modification of some aspects of the plant's model, post <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">systems::Context</a> creation. For details, refer to the documentation for the <a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html" title="A class representing an element (subcomponent) of a MultibodyPlant or (internally) a MultibodyTree.">MultibodyElement</a> whose parameters you are trying to modify/access (e.g. <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a>, <a class="el" href="classdrake_1_1multibody_1_1_fixed_offset_frame.html" title="FixedOffsetFrame represents a material frame F whose pose is fixed with respect to a parent material ...">FixedOffsetFrame</a>, etc.)</p>
<p>As an example, here is how to access and modify rigid body mass parameters: </p><div class="fragment"><div class="line"><a class="code hl_friend" href="#a47a63154823dffd5838329527aafbd58">MultibodyPlant&lt;double&gt;</a> plant;</div>
<div class="line"><span class="comment">// ... Code to add bodies, finalize plant, and to obtain a context.</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody&lt;double&gt;</a>&amp; body =</div>
<div class="line">    plant.<a class="code hl_function" href="#ad46fb49fc69d22b8a08d4dedc574ee1e">GetRigidBodyByName</a>(<span class="stringliteral">&quot;BodyName&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia&lt;double&gt;</a> M_BBo_B =</div>
<div class="line">    body.GetSpatialInertiaInBodyFrame(context);</div>
<div class="line"><span class="comment">// .. logic to determine a new SpatialInertia parameter for body.</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia&lt;double&gt;</a>&amp; M_BBo_B_new = ....</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Modify the body parameter for spatial inertia.</span></div>
<div class="line">body.<a class="code hl_function" href="classdrake_1_1multibody_1_1_rigid_body.html#a2e83508afc2db2bda9a1f25ed5201918">SetSpatialInertiaInBodyFrame</a>(&amp;context, M_BBo_B_new);</div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_multibody_plant_html_ad46fb49fc69d22b8a08d4dedc574ee1e"><div class="ttname"><a href="#ad46fb49fc69d22b8a08d4dedc574ee1e">drake::multibody::MultibodyPlant::GetRigidBodyByName</a></div><div class="ttdeci">const RigidBody&lt; T &gt; &amp; GetRigidBodyByName(std::string_view name) const</div><div class="ttdoc">Returns a constant reference to a rigid body that is identified by the string name in this model.</div><div class="ttdef"><b>Definition</b> multibody_plant.h:5244</div></div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_rigid_body_html"><div class="ttname"><a href="classdrake_1_1multibody_1_1_rigid_body.html">drake::multibody::RigidBody</a></div><div class="ttdoc">The term rigid body implies that the deformations of the body under consideration are so small that t...</div><div class="ttdef"><b>Definition</b> rigid_body.h:198</div></div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_rigid_body_html_a2e83508afc2db2bda9a1f25ed5201918"><div class="ttname"><a href="classdrake_1_1multibody_1_1_rigid_body.html#a2e83508afc2db2bda9a1f25ed5201918">drake::multibody::RigidBody::SetSpatialInertiaInBodyFrame</a></div><div class="ttdeci">void SetSpatialInertiaInBodyFrame(systems::Context&lt; T &gt; *context, const SpatialInertia&lt; T &gt; &amp;M_Bo_B) const</div><div class="ttdoc">For this RigidBody B, sets its SpatialInertia that is stored in context to M_Bo_B.</div><div class="ttdef"><b>Definition</b> rigid_body.h:628</div></div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_spatial_inertia_html"><div class="ttname"><a href="classdrake_1_1multibody_1_1_spatial_inertia.html">drake::multibody::SpatialInertia</a></div><div class="ttdoc">This class represents the physical concept of a Spatial Inertia.</div><div class="ttdef"><b>Definition</b> spatial_inertia.h:113</div></div>
</div><!-- fragment --><p>Another example, working with automatic differentiation in order to take derivatives with respect to one of the bodies' masses: </p><div class="fragment"><div class="line"><a class="code hl_friend" href="#a47a63154823dffd5838329527aafbd58">MultibodyPlant&lt;double&gt;</a> plant;</div>
<div class="line"><span class="comment">// ... Code to add bodies, finalize plant, and to obtain a</span></div>
<div class="line"><span class="comment">// context and a body&#39;s spatial inertia M_BBo_B.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Scalar convert the plant.</span></div>
<div class="line">unique_ptr&lt;MultibodyPlant&lt;AutoDiffXd&gt;&gt; plant_autodiff =</div>
<div class="line">    <a class="code hl_function" href="classdrake_1_1systems_1_1_system.html#af4283f9cfe4969e5760164a5528b6960">systems::System&lt;double&gt;::ToAutoDiffXd</a>(plant);</div>
<div class="line">unique_ptr&lt;Context&lt;AutoDiffXd&gt;&gt; context_autodiff =</div>
<div class="line">    plant_autodiff-&gt;CreateDefaultContext();</div>
<div class="line">context_autodiff-&gt;SetTimeStateAndParametersFrom(context);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody&lt;AutoDiffXd&gt;</a>&amp; body =</div>
<div class="line">    plant_autodiff-&gt;GetRigidBodyByName(<span class="stringliteral">&quot;BodyName&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Modify the body parameter for mass.</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_typedef" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854">AutoDiffXd</a> mass_autodiff(mass, <a class="code hl_typedef" href="namespacedrake.html#a6d923e79e6e92c2556edd86520145077">Vector1d</a>(1));</div>
<div class="line">body.<a class="code hl_function" href="classdrake_1_1multibody_1_1_rigid_body.html#ad850c57d3a08a7992a9f22cc30e69ef9">SetMass</a>(context_autodiff.get(), mass_autodiff);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// M_autodiff(i, j).derivatives()(0), contains the derivatives of</span></div>
<div class="line"><span class="comment">// M(i, j) with respect to the body&#39;s mass.</span></div>
<div class="line"><a class="code hl_typedef" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX&lt;AutoDiffXd&gt;</a> M_autodiff(plant_autodiff-&gt;num_velocities(),</div>
<div class="line">    plant_autodiff-&gt;num_velocities());</div>
<div class="line">plant_autodiff-&gt;CalcMassMatrix(*context_autodiff, &amp;M_autodiff);</div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_rigid_body_html_ad850c57d3a08a7992a9f22cc30e69ef9"><div class="ttname"><a href="classdrake_1_1multibody_1_1_rigid_body.html#ad850c57d3a08a7992a9f22cc30e69ef9">drake::multibody::RigidBody::SetMass</a></div><div class="ttdeci">void SetMass(systems::Context&lt; T &gt; *context, const T &amp;mass) const</div><div class="ttdoc">For this RigidBody B, sets its mass stored in context to mass.</div><div class="ttdef"><b>Definition</b> rigid_body.h:573</div></div>
<div class="ttc" id="aclassdrake_1_1systems_1_1_system_html_af4283f9cfe4969e5760164a5528b6960"><div class="ttname"><a href="classdrake_1_1systems_1_1_system.html#af4283f9cfe4969e5760164a5528b6960">drake::systems::System::ToAutoDiffXd</a></div><div class="ttdeci">std::unique_ptr&lt; System&lt; AutoDiffXd &gt; &gt; ToAutoDiffXd() const</div><div class="ttdoc">Creates a deep copy of this System, transmogrified to use the autodiff scalar type,...</div></div>
<div class="ttc" id="anamespacedrake_html_a28c58d881c60e96f48a7a4e32a699b95"><div class="ttname"><a href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">drake::MatrixX</a></div><div class="ttdeci">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; MatrixX</div><div class="ttdoc">A matrix of dynamic size, templated on scalar type.</div><div class="ttdef"><b>Definition</b> eigen_types.h:132</div></div>
<div class="ttc" id="anamespacedrake_html_a3d6302a0051e9403c9df3ed6808f3854"><div class="ttname"><a href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854">drake::AutoDiffXd</a></div><div class="ttdeci">drake::ad::AutoDiff AutoDiffXd</div><div class="ttdoc">A scalar type that performs automatic differentiation.</div><div class="ttdef"><b>Definition</b> autodiff.h:20</div></div>
<div class="ttc" id="anamespacedrake_html_a6d923e79e6e92c2556edd86520145077"><div class="ttname"><a href="namespacedrake.html#a6d923e79e6e92c2556edd86520145077">drake::Vector1d</a></div><div class="ttdeci">Eigen::Matrix&lt; double, 1, 1 &gt; Vector1d</div><div class="ttdoc">A column vector of size 1 of doubles.</div><div class="ttdef"><b>Definition</b> eigen_types.h:40</div></div>
</div><!-- fragment --><p><a class="anchor" id="mbp_adding_elements"></a></p><h3>Adding modeling elements</h3>
<p>Add multibody elements to a MultibodyPlant with methods like:</p>
<ul>
<li>Bodies: <a class="el" href="#a2f347b072b9cdb7b584f7098ba7c451c" title="Creates a rigid body with the provided name and spatial inertia.">AddRigidBody()</a></li>
<li>Joints: <a class="el" href="#a80c10ac818d74ed590875fd07f477671" title="This method adds a Joint of type JointType between two bodies.">AddJoint()</a></li>
<li>see <a class="el" href="#mbp_construction">Construction</a> for more.</li>
</ul>
<p>All modeling elements <b>must</b> be added before <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> is called. See <a class="el" href="#mbp_finalize_stage">Finalize stage</a> for a discussion.</p>
<p><a class="anchor" id="mbp_modeling_contact"></a></p><h3>Modeling contact</h3>
<p>Please refer to <a class="el" href="group__drake__contacts.html">Contact Modeling in Drake</a> for details on the available approximations, setup, and considerations for a multibody simulation with frictional contact.</p>
<p><a class="anchor" id="mbp_energy_and_power"></a></p><h3>Energy and Power</h3>
<p>MultibodyPlant implements the System energy and power methods, with some limitations.</p><ul>
<li>Kinetic energy: fully implemented.</li>
<li>Potential energy and conservative power: currently include only gravity and contributions from <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> objects; potential energy from compliant contact and joint limits are not included.</li>
<li>Nonconservative power: currently includes only contributions from <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> objects; actuation and input port forces, joint damping, and dissipation from joint limits, friction, and contact dissipation are not included.</li>
</ul>
<p>See Drake issue #12942 for more discussion.</p>
<p><a class="anchor" id="mbp_finalize_stage"></a></p><h3>Finalize() stage</h3>
<p>Once the user is done adding modeling elements and registering geometry, a call to <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> must be performed. This call will:</p><ul>
<li>Build the underlying tree structure of the multibody model,</li>
<li>declare the plant's state,</li>
<li>declare the plant's input and output ports,</li>
<li>declare collision filters to ignore collisions among rigid bodies:<ul>
<li>between rigid bodies connected by a joint,</li>
<li>within subgraphs of welded rigid bodies.</li>
</ul>
</li>
</ul>
<p>Note that <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> will <em>not</em> introduce any automatic collision filters on deformable bodies. Collision filters for deformable bodies can be explicitly applied via <a class="el" href="#a41edc1b3c920a1e48f27ad5661584fad" title="Excludes the collision geometries between two given collision filter groups.">ExcludeCollisionGeometriesWithCollisionFilterGroupPair()</a> or during parsing.</p>
<p><a class="anchor" id="mbp_table_of_contents"></a> <a class="anchor" id="mbp_references"></a></p><h3>References</h3>
<ul>
<li>[Featherstone 2008] Featherstone, R., 2008. Rigid body dynamics algorithms. Springer.</li>
<li>[Jain 2010] Jain, A., 2010. Robot and multibody dynamics: analysis and algorithms. Springer Science &amp; Business Media.</li>
<li>[Seth 2010] Seth, A., Sherman, M., Eastman, P. and Delp, S., 2010. Minimal formulation of joint motion for biomechanisms. Nonlinear dynamics, 62(1), pp.291-303.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/multibody/plant/multibody_plant.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:a3aeb03d90d213da4702f2dc5e484fc86" id="r_a3aeb03d90d213da4702f2dc5e484fc86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3aeb03d90d213da4702f2dc5e484fc86">MultibodyPlant</a> (const MultibodyPlant &amp;)=delete</td></tr>
<tr class="memitem:a4fef5f5f8133f2d54825ef109c80f1c2" id="r_a4fef5f5f8133f2d54825ef109c80f1c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a47a63154823dffd5838329527aafbd58">MultibodyPlant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fef5f5f8133f2d54825ef109c80f1c2">operator=</a> (const <a class="el" href="#a47a63154823dffd5838329527aafbd58">MultibodyPlant</a> &amp;)=delete</td></tr>
<tr class="memitem:a359ae04bf7eabd0461c5f12ab35fee1d" id="r_a359ae04bf7eabd0461c5f12ab35fee1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a359ae04bf7eabd0461c5f12ab35fee1d">MultibodyPlant</a> (MultibodyPlant &amp;&amp;)=delete</td></tr>
<tr class="memitem:a5f52507b11d3c1c5f7d9364d363457e6" id="r_a5f52507b11d3c1c5f7d9364d363457e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a47a63154823dffd5838329527aafbd58">MultibodyPlant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f52507b11d3c1c5f7d9364d363457e6">operator=</a> (<a class="el" href="#a47a63154823dffd5838329527aafbd58">MultibodyPlant</a> &amp;&amp;)=delete</td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Input and output ports</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="mbp_input_and_output_ports"></a> These methods provide access to the Drake <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a> input and output ports as depicted in the <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> class documentation.</p>
<p>Actuation values can be provided through a single input port which describes the entire plant, or through multiple input ports which each provide the actuation values for a specific model instance. See <a class="el" href="#ae6e70af2d399ab5b665a3f36a5ada172" title="Creates and adds a JointActuator model for an actuator acting on a given joint.">AddJointActuator()</a> and <a class="el" href="#ae3fc8de8de8eaf2d37a24c79d6be8e97" title="Returns the total number of actuated degrees of freedom.">num_actuated_dofs()</a>.</p>
<p>Output ports provide information about the entire MultibodyPlant or its individual model instances. </p>
</div></td></tr>
<tr class="memitem:a120e794678007aaf5494894806ce3e6f" id="r_a120e794678007aaf5494894806ce3e6f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a120e794678007aaf5494894806ce3e6f">get_body_poses_output_port</a> () const</td></tr>
<tr class="memdesc:a120e794678007aaf5494894806ce3e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the output port of all body poses in the world frame.  <br /></td></tr>
<tr class="memitem:a5f76813ea964f4c30e21bb841c182a0c" id="r_a5f76813ea964f4c30e21bb841c182a0c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f76813ea964f4c30e21bb841c182a0c">get_body_spatial_velocities_output_port</a> () const</td></tr>
<tr class="memdesc:a5f76813ea964f4c30e21bb841c182a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the output port of all body spatial velocities in the world frame.  <br /></td></tr>
<tr class="memitem:a482d55aca3da9ee3786b507c9c964b40" id="r_a482d55aca3da9ee3786b507c9c964b40"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a482d55aca3da9ee3786b507c9c964b40">get_body_spatial_accelerations_output_port</a> () const</td></tr>
<tr class="memdesc:a482d55aca3da9ee3786b507c9c964b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the output port of all body spatial accelerations in the world frame.  <br /></td></tr>
<tr class="memitem:a69ef9262ffab02b34bdf20449aab7551" id="r_a69ef9262ffab02b34bdf20449aab7551"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69ef9262ffab02b34bdf20449aab7551">get_actuation_input_port</a> () const</td></tr>
<tr class="memdesc:a69ef9262ffab02b34bdf20449aab7551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the input port for external actuation for all actuated dofs.  <br /></td></tr>
<tr class="memitem:a776f6189a7a33efee4aed2a9135f5150" id="r_a776f6189a7a33efee4aed2a9135f5150"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a776f6189a7a33efee4aed2a9135f5150">get_actuation_input_port</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a776f6189a7a33efee4aed2a9135f5150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the input port for external actuation for a specific model instance.  <br /></td></tr>
<tr class="memitem:a1bd2d6bf64c3bc65af05bdf0b634120e" id="r_a1bd2d6bf64c3bc65af05bdf0b634120e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bd2d6bf64c3bc65af05bdf0b634120e">get_net_actuation_output_port</a> () const</td></tr>
<tr class="memdesc:a1bd2d6bf64c3bc65af05bdf0b634120e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the output port that reports actuation values applied through joint actuators.  <br /></td></tr>
<tr class="memitem:afcc5bd59fc38539a6388d3a923f01cad" id="r_afcc5bd59fc38539a6388d3a923f01cad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcc5bd59fc38539a6388d3a923f01cad">get_net_actuation_output_port</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:afcc5bd59fc38539a6388d3a923f01cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the output port that reports actuation values applied through joint actuators, for a specific model instance.  <br /></td></tr>
<tr class="memitem:acb103492157aa5e69843c22c394d1de5" id="r_acb103492157aa5e69843c22c394d1de5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb103492157aa5e69843c22c394d1de5">get_desired_state_input_port</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:acb103492157aa5e69843c22c394d1de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">For models with PD controlled joint actuators, returns the port to provide the desired state for the given <span class="tt">model_instance</span>.  <br /></td></tr>
<tr class="memitem:a1a18f3e06640387dc4fe29c1e0c2d80b" id="r_a1a18f3e06640387dc4fe29c1e0c2d80b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a18f3e06640387dc4fe29c1e0c2d80b">get_applied_generalized_force_input_port</a> () const</td></tr>
<tr class="memdesc:a1a18f3e06640387dc4fe29c1e0c2d80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the vector-valued input port for applied generalized forces, and the vector will be added directly into <span class="tt">tau</span> (see <a class="el" href="#mbp_equations_of_motion">System dynamics</a>).  <br /></td></tr>
<tr class="memitem:a241c6a79cee07ffff3eaac93f47947c8" id="r_a241c6a79cee07ffff3eaac93f47947c8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a241c6a79cee07ffff3eaac93f47947c8">get_applied_spatial_force_input_port</a> () const</td></tr>
<tr class="memdesc:a241c6a79cee07ffff3eaac93f47947c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the input port for applying spatial forces to bodies in the plant.  <br /></td></tr>
<tr class="memitem:a38d417c47f17405fb748b5bb02140bcd" id="r_a38d417c47f17405fb748b5bb02140bcd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38d417c47f17405fb748b5bb02140bcd">get_geometry_query_input_port</a> () const</td></tr>
<tr class="memdesc:a38d417c47f17405fb748b5bb02140bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the input port used to perform geometric queries on a SceneGraph.  <br /></td></tr>
<tr class="memitem:a3c6b13fba0889c4bb9a88610254a387b" id="r_a3c6b13fba0889c4bb9a88610254a387b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c6b13fba0889c4bb9a88610254a387b">get_state_output_port</a> () const</td></tr>
<tr class="memdesc:a3c6b13fba0889c4bb9a88610254a387b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the output port for the multibody state x = [q, v] of the model.  <br /></td></tr>
<tr class="memitem:a913ca524f43c5b9ab8273d271b807c22" id="r_a913ca524f43c5b9ab8273d271b807c22"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a913ca524f43c5b9ab8273d271b807c22">get_state_output_port</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a913ca524f43c5b9ab8273d271b807c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the output port for the state xᵢ = [qᵢ vᵢ] of model instance i.  <br /></td></tr>
<tr class="memitem:a1aa2696beaffa5645a301f4578776cd8" id="r_a1aa2696beaffa5645a301f4578776cd8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1aa2696beaffa5645a301f4578776cd8">get_generalized_acceleration_output_port</a> () const</td></tr>
<tr class="memdesc:a1aa2696beaffa5645a301f4578776cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the output port for generalized accelerations v̇ of the model.  <br /></td></tr>
<tr class="memitem:a459ec616a1690ef27fe1b466fa0a46fa" id="r_a459ec616a1690ef27fe1b466fa0a46fa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a459ec616a1690ef27fe1b466fa0a46fa">get_generalized_acceleration_output_port</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a459ec616a1690ef27fe1b466fa0a46fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the output port for the generalized accelerations v̇ᵢ ⊆ v̇ for model instance i.  <br /></td></tr>
<tr class="memitem:a64b671623de5eecd130ce235995ac320" id="r_a64b671623de5eecd130ce235995ac320"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64b671623de5eecd130ce235995ac320">get_generalized_contact_forces_output_port</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a64b671623de5eecd130ce235995ac320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the output port of generalized contact forces for a specific model instance.  <br /></td></tr>
<tr class="memitem:afaa2e09232a83be4836114260b374dfb" id="r_afaa2e09232a83be4836114260b374dfb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afaa2e09232a83be4836114260b374dfb">get_reaction_forces_output_port</a> () const</td></tr>
<tr class="memdesc:afaa2e09232a83be4836114260b374dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the port for joint reaction forces.  <br /></td></tr>
<tr class="memitem:a38514bf9e20aa4b85ad82a0a2009a65f" id="r_a38514bf9e20aa4b85ad82a0a2009a65f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38514bf9e20aa4b85ad82a0a2009a65f">get_contact_results_output_port</a> () const</td></tr>
<tr class="memdesc:a38514bf9e20aa4b85ad82a0a2009a65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the port that outputs <a class="el" href="classdrake_1_1multibody_1_1_contact_results.html" title="A container class storing the contact results information for each contact pair for a given state of ...">ContactResults</a>.  <br /></td></tr>
<tr class="memitem:a986b7f0917bb20533970dc7658770237" id="r_a986b7f0917bb20533970dc7658770237"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a986b7f0917bb20533970dc7658770237">get_geometry_pose_output_port</a> () const</td></tr>
<tr class="memdesc:a986b7f0917bb20533970dc7658770237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the output port of frames' poses to communicate with a SceneGraph.  <br /></td></tr>
<tr class="memitem:a7c99a1da019a96da8acdad8b06727280" id="r_a7c99a1da019a96da8acdad8b06727280"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c99a1da019a96da8acdad8b06727280">get_deformable_body_configuration_output_port</a> () const</td></tr>
<tr class="memdesc:a7c99a1da019a96da8acdad8b06727280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the output port for vertex positions (configurations), measured and expressed in the World frame, of the deformable bodies in <span class="tt">this</span> plant as a GeometryConfigurationVector.  <br /></td></tr>
<tr id="pub-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="mbp_construction"></a> To add modeling elements like bodies, joints, force elements, constraints, etc.</p>
<p>to a MultibodyPlant, use one of the following construction methods. Once <em>all</em> modeling elements have been added, the <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> method <b>must</b> be called. A call to any construction method <b>after</b> a call to <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> causes an exception to be thrown. After calling <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>, you may invoke MultibodyPlant methods that perform computations. See <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> for details. </p>
</div></td></tr>
<tr class="memitem:a3296be9fa9bc35e6639460f54029c4c9" id="r_a3296be9fa9bc35e6639460f54029c4c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3296be9fa9bc35e6639460f54029c4c9">MultibodyPlant</a> (<a class="el" href="classdouble.html">double</a> <a class="el" href="#a8daceb7a3c384d6ad9f305e42b5fc1c6">time_step</a>)</td></tr>
<tr class="memdesc:a3296be9fa9bc35e6639460f54029c4c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor creates a plant with a single "world" body.  <br /></td></tr>
<tr class="memitem:a912adb84c4940893eb4634155e6e7e8b" id="r_a912adb84c4940893eb4634155e6e7e8b"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:a912adb84c4940893eb4634155e6e7e8b template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a912adb84c4940893eb4634155e6e7e8b">MultibodyPlant</a> (const MultibodyPlant&lt; U &gt; &amp;other)</td></tr>
<tr class="memdesc:a912adb84c4940893eb4634155e6e7e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar-converting copy constructor. See <a class="el" href="group__system__scalar__conversion.html">System Scalar Conversion</a>.  <br /></td></tr>
<tr class="memitem:ad119698acd3da506dbdd68f19372dbfb" id="r_ad119698acd3da506dbdd68f19372dbfb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad119698acd3da506dbdd68f19372dbfb">~MultibodyPlant</a> () override</td></tr>
<tr class="memitem:adb2f51f2f513478a97b0175bff3a65ae" id="r_adb2f51f2f513478a97b0175bff3a65ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb2f51f2f513478a97b0175bff3a65ae">SetUseSampledOutputPorts</a> (bool use_sampled_output_ports)</td></tr>
<tr class="memdesc:adb2f51f2f513478a97b0175bff3a65ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) For a discrete-time plant, configures whether the output ports are sampled (the default) or live (opt-in).  <br /></td></tr>
<tr class="memitem:a2f347b072b9cdb7b584f7098ba7c451c" id="r_a2f347b072b9cdb7b584f7098ba7c451c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f347b072b9cdb7b584f7098ba7c451c">AddRigidBody</a> (const std::string &amp;name, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;M_BBo_B=<a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::Zero())</td></tr>
<tr class="memdesc:a2f347b072b9cdb7b584f7098ba7c451c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rigid body with the provided name and spatial inertia.  <br /></td></tr>
<tr class="memitem:a929da02905c626c447f2fcc25505391c" id="r_a929da02905c626c447f2fcc25505391c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a929da02905c626c447f2fcc25505391c">AddRigidBody</a> (const std::string &amp;name, const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;M_BBo_B=<a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::Zero())</td></tr>
<tr class="memdesc:a929da02905c626c447f2fcc25505391c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rigid body with the provided name and spatial inertia.  <br /></td></tr>
<tr class="memitem:a8026d4144953acf4c1d89b128f678ba0" id="r_a8026d4144953acf4c1d89b128f678ba0"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class FrameType&gt; </td></tr>
<tr class="memitem:a8026d4144953acf4c1d89b128f678ba0 template"><td class="memItemLeft" align="right" valign="top">const FrameType&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8026d4144953acf4c1d89b128f678ba0">AddFrame</a> (std::unique_ptr&lt; FrameType&lt; T &gt; &gt; frame)</td></tr>
<tr class="memdesc:a8026d4144953acf4c1d89b128f678ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method adds a <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame) of its underl...">Frame</a> of type <span class="tt">FrameType&lt;T&gt;</span>.  <br /></td></tr>
<tr class="memitem:a80c10ac818d74ed590875fd07f477671" id="r_a80c10ac818d74ed590875fd07f477671"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename <a class="el" href="classdrake_1_1systems_1_1_system.html#a78eaec0a6a2d1c99d2a7eb5eeb1f8bdc">Scalar</a> &gt; class JointType&gt; </td></tr>
<tr class="memitem:a80c10ac818d74ed590875fd07f477671 template"><td class="memItemLeft" align="right" valign="top">const JointType&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80c10ac818d74ed590875fd07f477671">AddJoint</a> (std::unique_ptr&lt; JointType&lt; T &gt; &gt; joint)</td></tr>
<tr class="memdesc:a80c10ac818d74ed590875fd07f477671"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method adds a <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> of type <span class="tt">JointType</span> between two bodies.  <br /></td></tr>
<tr class="memitem:aa2637e697203a7c7e84143afb684e3a1" id="r_aa2637e697203a7c7e84143afb684e3a1"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class JointType, typename... Args&gt; </td></tr>
<tr class="memitem:aa2637e697203a7c7e84143afb684e3a1 template"><td class="memItemLeft" align="right" valign="top">const JointType&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2637e697203a7c7e84143afb684e3a1">AddJoint</a> (const std::string &amp;name, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;parent, const std::optional&lt; <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;X_PF, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;child, const std::optional&lt; <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;X_BM, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa2637e697203a7c7e84143afb684e3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method adds a <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> of type <span class="tt">JointType</span> between two bodies.  <br /></td></tr>
<tr class="memitem:af9ac269076a123de9d88132d946d0827" id="r_af9ac269076a123de9d88132d946d0827"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9ac269076a123de9d88132d946d0827">RemoveJoint</a> (const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp;joint)</td></tr>
<tr class="memdesc:af9ac269076a123de9d88132d946d0827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and deletes <span class="tt">joint</span> from this MultibodyPlant.  <br /></td></tr>
<tr class="memitem:ae39937d8af6ec034bf8d41770a4ff658" id="r_ae39937d8af6ec034bf8d41770a4ff658"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_weld_joint.html">WeldJoint</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae39937d8af6ec034bf8d41770a4ff658">WeldFrames</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_on_parent_F, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_on_child_M, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X_FM=<a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::Identity())</td></tr>
<tr class="memdesc:ae39937d8af6ec034bf8d41770a4ff658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Welds <span class="tt">frame_on_parent_F</span> and <span class="tt">frame_on_child_M</span> with relative pose <span class="tt">X_FM</span>.  <br /></td></tr>
<tr class="memitem:a82719521a8b2d69b6d3ce0bbb462d6e8" id="r_a82719521a8b2d69b6d3ce0bbb462d6e8"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename <a class="el" href="classdrake_1_1systems_1_1_system.html#a78eaec0a6a2d1c99d2a7eb5eeb1f8bdc">Scalar</a> &gt; class ForceElementType, typename... Args&gt; </td></tr>
<tr class="memitem:a82719521a8b2d69b6d3ce0bbb462d6e8 template"><td class="memItemLeft" align="right" valign="top">const ForceElementType&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82719521a8b2d69b6d3ce0bbb462d6e8">AddForceElement</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a82719521a8b2d69b6d3ce0bbb462d6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new force element model of type <span class="tt">ForceElementType</span> to <span class="tt">this</span> MultibodyPlant.  <br /></td></tr>
<tr class="memitem:ae6e70af2d399ab5b665a3f36a5ada172" id="r_ae6e70af2d399ab5b665a3f36a5ada172"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6e70af2d399ab5b665a3f36a5ada172">AddJointActuator</a> (const std::string &amp;name, const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp;joint, <a class="el" href="classdouble.html">double</a> effort_limit=std::numeric_limits&lt; <a class="el" href="classdouble.html">double</a> &gt;::infinity())</td></tr>
<tr class="memdesc:ae6e70af2d399ab5b665a3f36a5ada172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and adds a <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a> model for an actuator acting on a given <span class="tt">joint</span>.  <br /></td></tr>
<tr class="memitem:ae9eafac01a6cf0c90fa9005418ee2ec8" id="r_ae9eafac01a6cf0c90fa9005418ee2ec8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9eafac01a6cf0c90fa9005418ee2ec8">RemoveJointActuator</a> (const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp;actuator)</td></tr>
<tr class="memdesc:ae9eafac01a6cf0c90fa9005418ee2ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and deletes <span class="tt">actuator</span> from this MultibodyPlant.  <br /></td></tr>
<tr class="memitem:a4edf1daa65069a26255c903b02bce4c6" id="r_a4edf1daa65069a26255c903b02bce4c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4edf1daa65069a26255c903b02bce4c6">AddModelInstance</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a4edf1daa65069a26255c903b02bce4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new model instance.  <br /></td></tr>
<tr class="memitem:a43433a05aa2c28c03644da7319adab9f" id="r_a43433a05aa2c28c03644da7319adab9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43433a05aa2c28c03644da7319adab9f">RenameModelInstance</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const std::string &amp;name)</td></tr>
<tr class="memdesc:a43433a05aa2c28c03644da7319adab9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames an existing model instance.  <br /></td></tr>
<tr class="memitem:a7c9672b405425259b192131304f14f9c" id="r_a7c9672b405425259b192131304f14f9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c9672b405425259b192131304f14f9c">SetBaseBodyJointType</a> (<a class="el" href="namespacedrake_1_1multibody.html#ab69d6cd821353ffa5ba779a02269852d">BaseBodyJointType</a> joint_type, std::optional&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; model_instance={})</td></tr>
<tr class="memdesc:a7c9672b405425259b192131304f14f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the type of joint to be used by <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> to connect any otherwise unconnected bodies to World.  <br /></td></tr>
<tr class="memitem:a4b9dbdb48dceb9427775abedf465150c" id="r_a4b9dbdb48dceb9427775abedf465150c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#ab69d6cd821353ffa5ba779a02269852d">BaseBodyJointType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b9dbdb48dceb9427775abedf465150c">GetBaseBodyJointType</a> (std::optional&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; model_instance={}) const</td></tr>
<tr class="memdesc:a4b9dbdb48dceb9427775abedf465150c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently-set choice for base body joint type, either for the global setting or for a specific model instance if provided.  <br /></td></tr>
<tr class="memitem:a8fee61d7a783cade1a3d07fe86284d27" id="r_a8fee61d7a783cade1a3d07fe86284d27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27">Finalize</a> ()</td></tr>
<tr class="memdesc:a8fee61d7a783cade1a3d07fe86284d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method must be called after all elements in the model (joints, bodies, force elements, constraints, etc.) are added and before any computations are performed.  <br /></td></tr>
<tr id="pub-methods-3" class="groupHeader"><td colspan="2"><div class="groupHeader">Constraints</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="mbp_constraints"></a> Set of APIs to define constraints. To mention a few important examples, constraints can be used to couple the motion of joints, to create kinematic loops, or to weld bodies together.</p>
<p>Currently constraints are only supported for discrete MultibodyPlant models and not for all discrete solvers, see <a class="el" href="#ad7698366750a09e383106a17bf9009a2" title="Returns the contact solver type used for discrete MultibodyPlant models.">get_discrete_contact_solver()</a>. If the model contains constraints not supported by the discrete solver, the plant will throw an exception at <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> time. At this point the user has the option to select a contact model approximation that uses a solver that supports constraints, or to re-define the model so that such a constraint is not needed. A contact model approximation can be set with <a class="el" href="#a9b3f429ca991bd1028f4f60d6d5f2e61" title="Sets the discrete contact model approximation.">set_discrete_contact_approximation()</a> or in the <a class="el" href="structdrake_1_1multibody_1_1_multibody_plant_config.html" title="The set of configurable properties on a MultibodyPlant.">MultibodyPlantConfig</a>.</p>
<p>Each constraint is identified with a <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a" title="Type used to identify constraint by id within a multibody plant.">MultibodyConstraintId</a> returned by the function used to add it (e.g. <a class="el" href="#ad867f47ed9c5fa6a48d4eba8b9d871e9" title="Defines a holonomic constraint between two single-dof joints joint0 and joint1 with positions q₀ and ...">AddCouplerConstraint()</a>). It is possible to recover constraint specification parameters for each constraint with various introspection functions (e.g. <a class="el" href="#ac6c3a91f336442760368c29976f8e65e" title="(Internal use only) Returns the coupler constraint specification corresponding to id">get_coupler_constraint_specs()</a>). Each constraint has an "active" status that is set to true by default. Query a constraint's active status with <a class="el" href="#a8f75638f952ae11ee62d8c8458a47415" title="Returns the active status of the constraint given by id in context.">GetConstraintActiveStatus()</a> and set its active status with <a class="el" href="#a0308169d8d70b7f20285b0d5df3f046f" title="Sets the active status of the constraint given by id in context.">SetConstraintActiveStatus()</a>.</p>
</div></td></tr>
<tr class="memitem:a23f1475b0c301d9d78814fce265fd6ea" id="r_a23f1475b0c301d9d78814fce265fd6ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23f1475b0c301d9d78814fce265fd6ea">num_constraints</a> () const</td></tr>
<tr class="memdesc:a23f1475b0c301d9d78814fce265fd6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of constraints specified by the user.  <br /></td></tr>
<tr class="memitem:aa84267261a17f03b155394a33523aec8" id="r_aa84267261a17f03b155394a33523aec8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa84267261a17f03b155394a33523aec8">GetConstraintIds</a> () const</td></tr>
<tr class="memdesc:aa84267261a17f03b155394a33523aec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all constraint identifiers.  <br /></td></tr>
<tr class="memitem:aabbb62902b23cee44ddb8a5ad0b04e07" id="r_aabbb62902b23cee44ddb8a5ad0b04e07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabbb62902b23cee44ddb8a5ad0b04e07">num_coupler_constraints</a> () const</td></tr>
<tr class="memdesc:aabbb62902b23cee44ddb8a5ad0b04e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of coupler constraints specified by the user.  <br /></td></tr>
<tr class="memitem:adcd3b83abdfc7ffd22359f73c540f166" id="r_adcd3b83abdfc7ffd22359f73c540f166"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcd3b83abdfc7ffd22359f73c540f166">num_distance_constraints</a> () const</td></tr>
<tr class="memdesc:adcd3b83abdfc7ffd22359f73c540f166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of distance constraints specified by the user.  <br /></td></tr>
<tr class="memitem:aff063ba2ef6ea43b0abf574e27846c29" id="r_aff063ba2ef6ea43b0abf574e27846c29"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff063ba2ef6ea43b0abf574e27846c29">num_ball_constraints</a> () const</td></tr>
<tr class="memdesc:aff063ba2ef6ea43b0abf574e27846c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of ball constraints specified by the user.  <br /></td></tr>
<tr class="memitem:a96b8512dd5edf0fcb41d2ebd2e650bf7" id="r_a96b8512dd5edf0fcb41d2ebd2e650bf7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96b8512dd5edf0fcb41d2ebd2e650bf7">num_weld_constraints</a> () const</td></tr>
<tr class="memdesc:a96b8512dd5edf0fcb41d2ebd2e650bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of weld constraints specified by the user.  <br /></td></tr>
<tr class="memitem:abea05e15475afa8545b1ce34795261a6" id="r_abea05e15475afa8545b1ce34795261a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abea05e15475afa8545b1ce34795261a6">num_tendon_constraints</a> () const</td></tr>
<tr class="memdesc:abea05e15475afa8545b1ce34795261a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of tendon constraints specified by the user.  <br /></td></tr>
<tr class="memitem:ac6c3a91f336442760368c29976f8e65e" id="r_ac6c3a91f336442760368c29976f8e65e"><td class="memItemLeft" align="right" valign="top">const internal::CouplerConstraintSpec &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6c3a91f336442760368c29976f8e65e">get_coupler_constraint_specs</a> (<a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a> id) const</td></tr>
<tr class="memdesc:ac6c3a91f336442760368c29976f8e65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns the coupler constraint specification corresponding to <span class="tt">id</span>  <br /></td></tr>
<tr class="memitem:abd9a0ed88db25f4ee242584c42b401eb" id="r_abd9a0ed88db25f4ee242584c42b401eb"><td class="memItemLeft" align="right" valign="top">const internal::BallConstraintSpec &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd9a0ed88db25f4ee242584c42b401eb">get_ball_constraint_specs</a> (<a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a> id) const</td></tr>
<tr class="memdesc:abd9a0ed88db25f4ee242584c42b401eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns the ball constraint specification corresponding to <span class="tt">id</span>  <br /></td></tr>
<tr class="memitem:af92a76ea886e8c4281ac658d0bf1073e" id="r_af92a76ea886e8c4281ac658d0bf1073e"><td class="memItemLeft" align="right" valign="top">const internal::WeldConstraintSpec &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af92a76ea886e8c4281ac658d0bf1073e">get_weld_constraint_specs</a> (<a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a> id) const</td></tr>
<tr class="memdesc:af92a76ea886e8c4281ac658d0bf1073e"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns the weld constraint specification corresponding to <span class="tt">id</span>  <br /></td></tr>
<tr class="memitem:a57d85a2af04011b2f5ec52a68b6a6bee" id="r_a57d85a2af04011b2f5ec52a68b6a6bee"><td class="memItemLeft" align="right" valign="top">const internal::TendonConstraintSpec &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57d85a2af04011b2f5ec52a68b6a6bee">get_tendon_constraint_specs</a> (<a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a> id) const</td></tr>
<tr class="memdesc:a57d85a2af04011b2f5ec52a68b6a6bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns the tendon constraint specification corresponding to <span class="tt">id</span>  <br /></td></tr>
<tr class="memitem:a88a57e0ca8c75b5fe55e0d87d7118fc5" id="r_a88a57e0ca8c75b5fe55e0d87d7118fc5"><td class="memItemLeft" align="right" valign="top">const std::map&lt; <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a>, internal::CouplerConstraintSpec &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88a57e0ca8c75b5fe55e0d87d7118fc5">get_coupler_constraint_specs</a> () const</td></tr>
<tr class="memdesc:a88a57e0ca8c75b5fe55e0d87d7118fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns a reference to the all of the coupler constraints in this plant as a map from <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a" title="Type used to identify constraint by id within a multibody plant.">MultibodyConstraintId</a> to CouplerConstraintSpec.  <br /></td></tr>
<tr class="memitem:a8989c7aebeff42590d79635c9ba28132" id="r_a8989c7aebeff42590d79635c9ba28132"><td class="memItemLeft" align="right" valign="top">const std::map&lt; <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a>, internal::BallConstraintSpec &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8989c7aebeff42590d79635c9ba28132">get_ball_constraint_specs</a> () const</td></tr>
<tr class="memdesc:a8989c7aebeff42590d79635c9ba28132"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns a reference to all of the ball constraints in this plant as a map from <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a" title="Type used to identify constraint by id within a multibody plant.">MultibodyConstraintId</a> to BallConstraintSpec.  <br /></td></tr>
<tr class="memitem:ac582c6c556a8d449478bd4a32b7144c9" id="r_ac582c6c556a8d449478bd4a32b7144c9"><td class="memItemLeft" align="right" valign="top">const std::map&lt; <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a>, internal::WeldConstraintSpec &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac582c6c556a8d449478bd4a32b7144c9">get_weld_constraint_specs</a> () const</td></tr>
<tr class="memdesc:ac582c6c556a8d449478bd4a32b7144c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns a reference to the all of the weld constraints in this plant as a map from <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a" title="Type used to identify constraint by id within a multibody plant.">MultibodyConstraintId</a> to WeldConstraintSpec.  <br /></td></tr>
<tr class="memitem:ad729a55177cb828cdc0f1fd990e4b05e" id="r_ad729a55177cb828cdc0f1fd990e4b05e"><td class="memItemLeft" align="right" valign="top">const std::map&lt; <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a>, internal::TendonConstraintSpec &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad729a55177cb828cdc0f1fd990e4b05e">get_tendon_constraint_specs</a> () const</td></tr>
<tr class="memdesc:ad729a55177cb828cdc0f1fd990e4b05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns a reference to the all of the tendon constraints in this plant as a map from <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a" title="Type used to identify constraint by id within a multibody plant.">MultibodyConstraintId</a> to TendonConstraintSpec.  <br /></td></tr>
<tr class="memitem:a8f75638f952ae11ee62d8c8458a47415" id="r_a8f75638f952ae11ee62d8c8458a47415"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f75638f952ae11ee62d8c8458a47415">GetConstraintActiveStatus</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a> id) const</td></tr>
<tr class="memdesc:a8f75638f952ae11ee62d8c8458a47415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the active status of the constraint given by <span class="tt">id</span> in <span class="tt">context</span>.  <br /></td></tr>
<tr class="memitem:a0308169d8d70b7f20285b0d5df3f046f" id="r_a0308169d8d70b7f20285b0d5df3f046f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0308169d8d70b7f20285b0d5df3f046f">SetConstraintActiveStatus</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a> id, bool status) const</td></tr>
<tr class="memdesc:a0308169d8d70b7f20285b0d5df3f046f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the active status of the constraint given by <span class="tt">id</span> in <span class="tt">context</span>.  <br /></td></tr>
<tr class="memitem:ad867f47ed9c5fa6a48d4eba8b9d871e9" id="r_ad867f47ed9c5fa6a48d4eba8b9d871e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad867f47ed9c5fa6a48d4eba8b9d871e9">AddCouplerConstraint</a> (const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp;joint0, const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp;joint1, <a class="el" href="classdouble.html">double</a> gear_ratio, <a class="el" href="classdouble.html">double</a> offset=0.0)</td></tr>
<tr class="memdesc:ad867f47ed9c5fa6a48d4eba8b9d871e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a holonomic constraint between two single-dof joints <span class="tt">joint0</span> and <span class="tt">joint1</span> with positions q₀ and q₁, respectively, such that q₀ = ρ⋅q₁ + Δq, where ρ is the gear ratio and Δq is a fixed offset.  <br /></td></tr>
<tr class="memitem:aa141315d9a08af4dc7f82c8d3f9f1367" id="r_aa141315d9a08af4dc7f82c8d3f9f1367"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa141315d9a08af4dc7f82c8d3f9f1367">AddDistanceConstraint</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body_A, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;p_AP, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body_B, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;p_BQ, <a class="el" href="classdouble.html">double</a> distance, <a class="el" href="classdouble.html">double</a> stiffness=std::numeric_limits&lt; <a class="el" href="classdouble.html">double</a> &gt;::infinity(), <a class="el" href="classdouble.html">double</a> damping=0.0)</td></tr>
<tr class="memdesc:aa141315d9a08af4dc7f82c8d3f9f1367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a distance constraint between a point P on a body A and a point Q on a body B.  <br /></td></tr>
<tr class="memitem:a6fceec5d0aeba35c15cb3e5e9fdc3250" id="r_a6fceec5d0aeba35c15cb3e5e9fdc3250"><td class="memItemLeft" align="right" valign="top">const std::map&lt; <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a>, <a class="el" href="classdrake_1_1multibody_1_1_distance_constraint_params.html">DistanceConstraintParams</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fceec5d0aeba35c15cb3e5e9fdc3250">GetDefaultDistanceConstraintParams</a> () const</td></tr>
<tr class="memdesc:a6fceec5d0aeba35c15cb3e5e9fdc3250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all default distance constraint parameters, as registered via <a class="el" href="#aa141315d9a08af4dc7f82c8d3f9f1367" title="Defines a distance constraint between a point P on a body A and a point Q on a body B.">AddDistanceConstraint()</a>.  <br /></td></tr>
<tr class="memitem:a65c964835794b9477b7bc1d0752b3ac7" id="r_a65c964835794b9477b7bc1d0752b3ac7"><td class="memItemLeft" align="right" valign="top">const std::map&lt; <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a>, <a class="el" href="classdrake_1_1multibody_1_1_distance_constraint_params.html">DistanceConstraintParams</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65c964835794b9477b7bc1d0752b3ac7">GetDistanceConstraintParams</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a65c964835794b9477b7bc1d0752b3ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all distance constraint parameters currently stored in <span class="tt">context</span>.  <br /></td></tr>
<tr class="memitem:af25ef52efba5ea5e62c292a43faaf7d8" id="r_af25ef52efba5ea5e62c292a43faaf7d8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_distance_constraint_params.html">DistanceConstraintParams</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af25ef52efba5ea5e62c292a43faaf7d8">GetDistanceConstraintParams</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a> id) const</td></tr>
<tr class="memdesc:af25ef52efba5ea5e62c292a43faaf7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the parameters for the distance constraint that corresponds to identifier <span class="tt">id</span>.  <br /></td></tr>
<tr class="memitem:a6672fc5264442466b21708b7008421fe" id="r_a6672fc5264442466b21708b7008421fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6672fc5264442466b21708b7008421fe">SetDistanceConstraintParams</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a> id, <a class="el" href="classdrake_1_1multibody_1_1_distance_constraint_params.html">DistanceConstraintParams</a> params) const</td></tr>
<tr class="memdesc:a6672fc5264442466b21708b7008421fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores in <span class="tt">context</span> the parameters <span class="tt">params</span> for the distance constraint with identifier <span class="tt">id</span>.  <br /></td></tr>
<tr class="memitem:a04c1fdf7afe469442ca4ceb1392653c7" id="r_a04c1fdf7afe469442ca4ceb1392653c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04c1fdf7afe469442ca4ceb1392653c7">AddBallConstraint</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body_A, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;p_AP, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body_B, const std::optional&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;p_BQ={})</td></tr>
<tr class="memdesc:a04c1fdf7afe469442ca4ceb1392653c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a constraint such that point P affixed to body A is coincident at all times with point Q affixed to body B, effectively modeling a ball-and-socket joint.  <br /></td></tr>
<tr class="memitem:aec4f15db42bddd6789b0732762046ce6" id="r_aec4f15db42bddd6789b0732762046ce6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec4f15db42bddd6789b0732762046ce6">AddWeldConstraint</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body_A, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X_AP, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body_B, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X_BQ)</td></tr>
<tr class="memdesc:aec4f15db42bddd6789b0732762046ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a constraint such that frame P affixed to body A is coincident at all times with frame Q affixed to body B, effectively modeling a weld joint.  <br /></td></tr>
<tr class="memitem:a7639ec04cd9ca90b649e7b712e5b839c" id="r_a7639ec04cd9ca90b649e7b712e5b839c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7639ec04cd9ca90b649e7b712e5b839c">AddTendonConstraint</a> (std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt; joints, std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; a, std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt; offset, std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt; lower_limit, std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt; upper_limit, std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt; stiffness, std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt; damping)</td></tr>
<tr class="memdesc:a7639ec04cd9ca90b649e7b712e5b839c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a set of unilateral constraints on the length of an abstract tendon defined as:  <br /></td></tr>
<tr class="memitem:ab868821d19fbf79f94b50147c4d90b9b" id="r_ab868821d19fbf79f94b50147c4d90b9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab868821d19fbf79f94b50147c4d90b9b">RemoveConstraint</a> (<a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a> id)</td></tr>
<tr class="memdesc:ab868821d19fbf79f94b50147c4d90b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the constraint <span class="tt">id</span> from the plant.  <br /></td></tr>
<tr id="pub-methods-4" class="groupHeader"><td colspan="2"><div class="groupHeader">Geometry</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="mbp_geometry"></a></p>
<p>The following geometry methods provide a convenient means for associating geometries with bodies. Ultimately, the geometries are owned by <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">SceneGraph</a>. These methods do the work of registering the requested geometries with SceneGraph and maintaining a mapping between the body and the registered data. Particularly, SceneGraph knows nothing about the concepts inherent in the MultibodyPlant. These methods account for those differences as documented below.</p>
<h4>Geometry registration with roles</h4>
<p>Geometries can be associated with bodies via the <span class="tt">RegisterFooGeometry</span> family of methods. In SceneGraph, geometries have <a class="el" href="group__geometry__roles.html">roles</a>. The <span class="tt"><a class="el" href="#a90d32a93de07ef91744b95ed152c578d" title="Registers geometry in a SceneGraph with a given geometry::Shape to be used for the contact modeling o...">RegisterCollisionGeometry()</a></span> methods register geometry with SceneGraph and assign it the proximity role. The <span class="tt"><a class="el" href="#af475e2acc5c4720650cf004a37f1ce95" title="Registers geometry in a SceneGraph with a given geometry::Shape to be used for visualization of a giv...">RegisterVisualGeometry()</a></span> methods do the same, but assign the illustration and/or perception role, depending on how the API is exercised (see below).</p>
<p>All geometry registration methods return a <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> GeometryId. This is how SceneGraph refers to the geometries. The properties of an individual geometry can be accessed with its id and <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html" title="The SceneGraphInspector serves as a mechanism to query the topological structure of a SceneGraph inst...">geometry::SceneGraphInspector</a> and <a class="el" href="classdrake_1_1geometry_1_1_query_object.html" title="The QueryObject serves as a mechanism to perform geometry queries on the world&#39;s geometry.">geometry::QueryObject</a> (for its state-dependent pose in world).</p>
<h4>Body frames and SceneGraph frames</h4>
<p>The first time a geometry registration method is called on a particular body, that body's frame B is registered with SceneGraph. As SceneGraph knows nothing about bodies, in the SceneGraph domain, the frame is simply notated as F; this is merely an alias for the body frame. Thus, the pose of the geometry G in the SceneGraph frame F is the same as the pose of the geometry in the body frame B; <span class="tt">X_FG = X_BG</span>.</p>
<p>The model instance index of the body is passed to the SceneGraph frame as its "frame group". This can be retrieved from the geometry::SceneGraphInspector::GetFrameGroup(FrameId) method.</p>
<p>Given a GeometryId, SceneGraph cannot report what <em>body</em> it is affixed to. It can only report the SceneGraph alias frame F. But the following idiom can report the body:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_friend" href="#a47a63154823dffd5838329527aafbd58">MultibodyPlant&lt;T&gt;</a>&amp; plant = ...;</div>
<div class="line"><span class="keyword">const</span> SceneGraphInspector&lt;T&gt;&amp; inspector =  ...;</div>
<div class="line"><span class="keyword">const</span> GeometryId g_id = id_from_some_query;</div>
<div class="line"><span class="keyword">const</span> FrameId f_id = inspector.GetFrameId(g_id);</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody&lt;T&gt;</a>* body = plant.<a class="code hl_function" href="#a861e318468cd1ce72c9cf94566aac812">GetBodyFromFrameId</a>(f_id);</div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_multibody_plant_html_a861e318468cd1ce72c9cf94566aac812"><div class="ttname"><a href="#a861e318468cd1ce72c9cf94566aac812">drake::multibody::MultibodyPlant::GetBodyFromFrameId</a></div><div class="ttdeci">const RigidBody&lt; T &gt; * GetBodyFromFrameId(geometry::FrameId frame_id) const</div><div class="ttdoc">Given a geometry frame identifier, returns a pointer to the body associated with that id (nullptr if ...</div><div class="ttdef"><b>Definition</b> multibody_plant.h:2429</div></div>
</div><!-- fragment --><p> See documentation of <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html" title="The SceneGraphInspector serves as a mechanism to query the topological structure of a SceneGraph inst...">geometry::SceneGraphInspector</a> on where to get an inspector.</p>
<h4>MultibodyPlant names vs. SceneGraph names</h4>
<p>In MultibodyPlant, frame names only have to be unique in a single model instance. However, SceneGraph knows nothing of model instances. So, to generate unique names for the corresponding frames in SceneGraph, when MultibodyPlant registers the corresponding SceneGraph frame, it is named with a "scoped name". This is a concatenation of <span class="tt">[model instance name]::[body name]</span>. Searching for a frame with just the name <span class="tt">body name</span> will fail. (See <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html#a24dcbf29c0d6cd766009a182a6484e3b" title="Gets the name associated with this rigid body.">RigidBody::name()</a> and <a class="el" href="#a6967a3b13b5d006821d7590945a0c168" title="Returns the name of a model_instance.">GetModelInstanceName()</a> for those values.)</p>
<p>Geometry names get scoped in the same way. The name passed to a RegisterXXGeometry becomes the scoped name <span class="tt">[model instance name]::[name]</span> in SceneGraph.</p>
<h4>Registering visual roles</h4>
<p>Drake has two visual roles: illustration and perception. Unless otherwise indicated, the <a class="el" href="#af475e2acc5c4720650cf004a37f1ce95" title="Registers geometry in a SceneGraph with a given geometry::Shape to be used for visualization of a giv...">RegisterVisualGeometry()</a> APIs register the given geometry with both roles. One API allows specific control over which roles are assigned. </p><dl class="section note"><dt>Note</dt><dd>This "assign-all-roles" behavior may change in the future and code that directly relies on it will break.</dd></dl>
<p>Furthermore, unless the ("label", "id") property has already been defined, the PerceptionProperties will be assigned that property with a geometry::RenderLabel whose value is equal to the body's index. </p>
</div></td></tr>
<tr class="memitem:a4a6d28ce9c8119bee923e827eb6f02ed" id="r_a4a6d28ce9c8119bee923e827eb6f02ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1geometry.html#ac53cb597123131fb23a7af26e8d350bf">geometry::SourceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a6d28ce9c8119bee923e827eb6f02ed">RegisterAsSourceForSceneGraph</a> (<a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt; *scene_graph)</td></tr>
<tr class="memdesc:a4a6d28ce9c8119bee923e827eb6f02ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers <span class="tt">this</span> plant to serve as a source for an instance of SceneGraph.  <br /></td></tr>
<tr class="memitem:af475e2acc5c4720650cf004a37f1ce95" id="r_af475e2acc5c4720650cf004a37f1ce95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af475e2acc5c4720650cf004a37f1ce95">RegisterVisualGeometry</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X_BG, const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;shape, const std::string &amp;name, const <a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html">geometry::IllustrationProperties</a> &amp;properties)</td></tr>
<tr class="memdesc:af475e2acc5c4720650cf004a37f1ce95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers geometry in a SceneGraph with a given <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The abstract base class for all shape specifications.">geometry::Shape</a> to be used for visualization of a given <span class="tt">body</span>.  <br /></td></tr>
<tr class="memitem:a49e35f6a4879f7aaf6a75221962efb23" id="r_a49e35f6a4879f7aaf6a75221962efb23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49e35f6a4879f7aaf6a75221962efb23">RegisterVisualGeometry</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">geometry::GeometryInstance</a> &gt; geometry_instance)</td></tr>
<tr class="memdesc:a49e35f6a4879f7aaf6a75221962efb23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the given <span class="tt">geometry_instance</span> in a SceneGraph to be used for visualization of a given <span class="tt">body</span>.  <br /></td></tr>
<tr class="memitem:a5939a509468cd3c7cc7b30b1ecafa625" id="r_a5939a509468cd3c7cc7b30b1ecafa625"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5939a509468cd3c7cc7b30b1ecafa625">RegisterVisualGeometry</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X_BG, const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;shape, const std::string &amp;name, const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;diffuse_color)</td></tr>
<tr class="memdesc:a5939a509468cd3c7cc7b30b1ecafa625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for visual geometry registration.  <br /></td></tr>
<tr class="memitem:a5490007419496acf56fe363344abfe1e" id="r_a5490007419496acf56fe363344abfe1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5490007419496acf56fe363344abfe1e">RegisterVisualGeometry</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X_BG, const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;shape, const std::string &amp;name)</td></tr>
<tr class="memdesc:a5490007419496acf56fe363344abfe1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for visual geometry registration.  <br /></td></tr>
<tr class="memitem:af76b81d10dd0c9689ef62b4c44e63ead" id="r_af76b81d10dd0c9689ef62b4c44e63ead"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af76b81d10dd0c9689ef62b4c44e63ead">GetVisualGeometriesForBody</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body) const</td></tr>
<tr class="memdesc:af76b81d10dd0c9689ef62b4c44e63ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of GeometryId's identifying the different visual geometries for <span class="tt">body</span> previously registered with a SceneGraph.  <br /></td></tr>
<tr class="memitem:a90d32a93de07ef91744b95ed152c578d" id="r_a90d32a93de07ef91744b95ed152c578d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90d32a93de07ef91744b95ed152c578d">RegisterCollisionGeometry</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X_BG, const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;shape, const std::string &amp;name, <a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">geometry::ProximityProperties</a> properties)</td></tr>
<tr class="memdesc:a90d32a93de07ef91744b95ed152c578d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers geometry in a SceneGraph with a given <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The abstract base class for all shape specifications.">geometry::Shape</a> to be used for the contact modeling of a given <span class="tt">body</span>.  <br /></td></tr>
<tr class="memitem:a69fb5b620b296ff32415dd5d70366814" id="r_a69fb5b620b296ff32415dd5d70366814"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69fb5b620b296ff32415dd5d70366814">RegisterCollisionGeometry</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X_BG, const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;shape, const std::string &amp;name, const <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;coulomb_friction)</td></tr>
<tr class="memdesc:a69fb5b620b296ff32415dd5d70366814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload which specifies a single property: coulomb_friction.  <br /></td></tr>
<tr class="memitem:a6e0adfbc5ece81c87ea5d428011ff96c" id="r_a6e0adfbc5ece81c87ea5d428011ff96c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e0adfbc5ece81c87ea5d428011ff96c">GetCollisionGeometriesForBody</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body) const</td></tr>
<tr class="memdesc:a6e0adfbc5ece81c87ea5d428011ff96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of GeometryId's identifying the different contact geometries for <span class="tt">body</span> previously registered with a SceneGraph.  <br /></td></tr>
<tr class="memitem:a41edc1b3c920a1e48f27ad5661584fad" id="r_a41edc1b3c920a1e48f27ad5661584fad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41edc1b3c920a1e48f27ad5661584fad">ExcludeCollisionGeometriesWithCollisionFilterGroupPair</a> (const std::pair&lt; std::string, <a class="el" href="classdrake_1_1geometry_1_1_geometry_set.html">geometry::GeometrySet</a> &gt; &amp;collision_filter_group_a, const std::pair&lt; std::string, <a class="el" href="classdrake_1_1geometry_1_1_geometry_set.html">geometry::GeometrySet</a> &gt; &amp;collision_filter_group_b)</td></tr>
<tr class="memdesc:a41edc1b3c920a1e48f27ad5661584fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Excludes the collision geometries between two given collision filter groups.  <br /></td></tr>
<tr class="memitem:a2822cd320f693cd2191fbcdd6dba2494" id="r_a2822cd320f693cd2191fbcdd6dba2494"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_set.html">geometry::GeometrySet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2822cd320f693cd2191fbcdd6dba2494">CollectRegisteredGeometries</a> (const std::vector&lt; const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; * &gt; &amp;bodies) const</td></tr>
<tr class="memdesc:a2822cd320f693cd2191fbcdd6dba2494"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each of the provided <span class="tt">bodies</span>, collects up all geometries that have been registered to that body.  <br /></td></tr>
<tr class="memitem:a861e318468cd1ce72c9cf94566aac812" id="r_a861e318468cd1ce72c9cf94566aac812"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a861e318468cd1ce72c9cf94566aac812">GetBodyFromFrameId</a> (<a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">geometry::FrameId</a> frame_id) const</td></tr>
<tr class="memdesc:a861e318468cd1ce72c9cf94566aac812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a geometry frame identifier, returns a pointer to the body associated with that id (nullptr if there is no such body).  <br /></td></tr>
<tr class="memitem:a808a317dc7b18b637901509dfb5a788e" id="r_a808a317dc7b18b637901509dfb5a788e"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">geometry::FrameId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a808a317dc7b18b637901509dfb5a788e">GetBodyFrameIdIfExists</a> (<a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">BodyIndex</a> body_index) const</td></tr>
<tr class="memdesc:a808a317dc7b18b637901509dfb5a788e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the body with <span class="tt">body_index</span> belongs to the called plant, it returns the <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb" title="Type used to identify geometry frames in SceneGraph.">geometry::FrameId</a> associated with it.  <br /></td></tr>
<tr class="memitem:afdcdcb4e7798a5aef9bc3111402dfa5e" id="r_afdcdcb4e7798a5aef9bc3111402dfa5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">geometry::FrameId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdcdcb4e7798a5aef9bc3111402dfa5e">GetBodyFrameIdOrThrow</a> (<a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">BodyIndex</a> body_index) const</td></tr>
<tr class="memdesc:afdcdcb4e7798a5aef9bc3111402dfa5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the body with <span class="tt">body_index</span> belongs to the called plant, it returns the <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb" title="Type used to identify geometry frames in SceneGraph.">geometry::FrameId</a> associated with it.  <br /></td></tr>
<tr class="memitem:a591a2dced3f64a85456b9b0eed50807c" id="r_a591a2dced3f64a85456b9b0eed50807c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html">geometry::SceneGraphInspector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a591a2dced3f64a85456b9b0eed50807c">EvalSceneGraphInspector</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a591a2dced3f64a85456b9b0eed50807c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inspector from the <span class="tt">context</span> for the SceneGraph associated with this plant, via this plant's "geometry_query" input port.  <br /></td></tr>
<tr id="pub-methods-5" class="groupHeader"><td colspan="2"><div class="groupHeader">State accessors and mutators</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="mbp_state_accessors_and_mutators"></a> The following state methods allow getting and setting the kinematic state variables <span class="tt">[q; v]</span>, where <span class="tt">q</span> is the vector of generalized positions and <span class="tt">v</span> is the vector of generalized velocities.</p>
<p>The state resides in a <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a> that is supplied as the first argument to every method.</p>
<dl class="section note"><dt>Note</dt><dd>State vectors for the full system are returned as live references into the Context, not independent copies. In contrast, state vectors for individual model instances are returned as copies because the state associated with a model instance is generally not contiguous in a Context.</dd></dl>
<p>There are also utilities for accessing and mutating portions of state or actuation arrays corresponding to just a single model instance. </p>
</div></td></tr>
<tr class="memitem:a61c4037d7f25d2e511f86e9102772290" id="r_a61c4037d7f25d2e511f86e9102772290"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61c4037d7f25d2e511f86e9102772290">GetPositionsAndVelocities</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a61c4037d7f25d2e511f86e9102772290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const vector reference <span class="tt">[q; v]</span> to the generalized positions q and generalized velocities v in a given Context.  <br /></td></tr>
<tr class="memitem:a7ed3389732867302278b87d4605509a2" id="r_a7ed3389732867302278b87d4605509a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ed3389732867302278b87d4605509a2">GetPositionsAndVelocities</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a7ed3389732867302278b87d4605509a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector <span class="tt">[q; v]</span> containing the generalized positions q and generalized velocities v of a specified model instance in a given Context.  <br /></td></tr>
<tr class="memitem:a98228721376112290679f89f8333b78c" id="r_a98228721376112290679f89f8333b78c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98228721376112290679f89f8333b78c">GetPositionsAndVelocities</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; qv_out) const</td></tr>
<tr class="memdesc:a98228721376112290679f89f8333b78c"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Populates output vector qv_out representing the generalized positions q and generalized velocities v of a specified model instance in a given Context.  <br /></td></tr>
<tr class="memitem:acdf6af4e5e5e71b55ea7ea3034ac5e90" id="r_acdf6af4e5e5e71b55ea7ea3034ac5e90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdf6af4e5e5e71b55ea7ea3034ac5e90">SetPositionsAndVelocities</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;q_v) const</td></tr>
<tr class="memdesc:acdf6af4e5e5e71b55ea7ea3034ac5e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets generalized positions q and generalized velocities v in a given Context from a given vector [q; v].  <br /></td></tr>
<tr class="memitem:aa7fa1955c5b663dd2ed08671c95f1fbe" id="r_aa7fa1955c5b663dd2ed08671c95f1fbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7fa1955c5b663dd2ed08671c95f1fbe">SetPositionsAndVelocities</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;q_v) const</td></tr>
<tr class="memdesc:aa7fa1955c5b663dd2ed08671c95f1fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets generalized positions q and generalized velocities v from a given vector [q; v] for a specified model instance in a given Context.  <br /></td></tr>
<tr class="memitem:a15aab0eeb92b8e9f0a9bfcab8abaca69" id="r_a15aab0eeb92b8e9f0a9bfcab8abaca69"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15aab0eeb92b8e9f0a9bfcab8abaca69">GetPositions</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a15aab0eeb92b8e9f0a9bfcab8abaca69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const vector reference to the vector of generalized positions q in a given Context.  <br /></td></tr>
<tr class="memitem:aca5f136c4c48997ffc6284a25f85a16d" id="r_aca5f136c4c48997ffc6284a25f85a16d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca5f136c4c48997ffc6284a25f85a16d">GetPositions</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:aca5f136c4c48997ffc6284a25f85a16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the generalized positions q of a specified model instance in a given Context.  <br /></td></tr>
<tr class="memitem:a33d9285487483014120ce10524b0f762" id="r_a33d9285487483014120ce10524b0f762"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33d9285487483014120ce10524b0f762">GetPositions</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; q_out) const</td></tr>
<tr class="memdesc:a33d9285487483014120ce10524b0f762"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Populates output vector q_out with the generalized positions q of a specified model instance in a given Context.  <br /></td></tr>
<tr class="memitem:a40ecddd72c91e66ee38fe023bc58b3a0" id="r_a40ecddd72c91e66ee38fe023bc58b3a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40ecddd72c91e66ee38fe023bc58b3a0">SetPositions</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;q) const</td></tr>
<tr class="memdesc:a40ecddd72c91e66ee38fe023bc58b3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the generalized positions q in a given Context from a given vector.  <br /></td></tr>
<tr class="memitem:abd0b27947d35ab2005eda04b6f67c6a8" id="r_abd0b27947d35ab2005eda04b6f67c6a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd0b27947d35ab2005eda04b6f67c6a8">SetPositions</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;q_instance) const</td></tr>
<tr class="memdesc:abd0b27947d35ab2005eda04b6f67c6a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the generalized positions q for a particular model instance in a given Context from a given vector.  <br /></td></tr>
<tr class="memitem:a36c37052d28bb9bcb7b70e7b6a6a6321" id="r_a36c37052d28bb9bcb7b70e7b6a6a6321"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36c37052d28bb9bcb7b70e7b6a6a6321">SetPositions</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *state, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;q_instance) const</td></tr>
<tr class="memdesc:a36c37052d28bb9bcb7b70e7b6a6a6321"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Sets the generalized positions q for a particular model instance in a given State from a given vector.  <br /></td></tr>
<tr class="memitem:ac9bcc022da125a839e3673beb0f9dc9b" id="r_ac9bcc022da125a839e3673beb0f9dc9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9bcc022da125a839e3673beb0f9dc9b">GetDefaultPositions</a> () const</td></tr>
<tr class="memdesc:ac9bcc022da125a839e3673beb0f9dc9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default positions for the plant, which can be changed via <a class="el" href="#aa293696b845c071deb902d3ee6d3bcc3" title="Sets the default positions for the plant.">SetDefaultPositions()</a>.  <br /></td></tr>
<tr class="memitem:aa68446168fd4dd3f5778716192d6fdc3" id="r_aa68446168fd4dd3f5778716192d6fdc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa68446168fd4dd3f5778716192d6fdc3">GetDefaultPositions</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:aa68446168fd4dd3f5778716192d6fdc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default positions for the plant for a given model instance, which can be changed via <a class="el" href="#aa293696b845c071deb902d3ee6d3bcc3" title="Sets the default positions for the plant.">SetDefaultPositions()</a>.  <br /></td></tr>
<tr class="memitem:aa293696b845c071deb902d3ee6d3bcc3" id="r_aa293696b845c071deb902d3ee6d3bcc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa293696b845c071deb902d3ee6d3bcc3">SetDefaultPositions</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;q)</td></tr>
<tr class="memdesc:aa293696b845c071deb902d3ee6d3bcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default positions for the plant.  <br /></td></tr>
<tr class="memitem:a71998d3f5e8bc65b742c03235c805fd9" id="r_a71998d3f5e8bc65b742c03235c805fd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71998d3f5e8bc65b742c03235c805fd9">SetDefaultPositions</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;q_instance)</td></tr>
<tr class="memdesc:a71998d3f5e8bc65b742c03235c805fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default positions for the model instance.  <br /></td></tr>
<tr class="memitem:a83faa6d43006794cd8f7ee6f851e1d09" id="r_a83faa6d43006794cd8f7ee6f851e1d09"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83faa6d43006794cd8f7ee6f851e1d09">GetVelocities</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a83faa6d43006794cd8f7ee6f851e1d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const vector reference to the generalized velocities v in a given Context.  <br /></td></tr>
<tr class="memitem:a6ac68a304522ced0b67b93deeb9152cc" id="r_a6ac68a304522ced0b67b93deeb9152cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ac68a304522ced0b67b93deeb9152cc">GetVelocities</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a6ac68a304522ced0b67b93deeb9152cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the generalized velocities v of a specified model instance in a given Context.  <br /></td></tr>
<tr class="memitem:abad057c31de6451c9925dffb8fe4612e" id="r_abad057c31de6451c9925dffb8fe4612e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abad057c31de6451c9925dffb8fe4612e">GetVelocities</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; v_out) const</td></tr>
<tr class="memdesc:abad057c31de6451c9925dffb8fe4612e"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Populates output vector v_out with the generalized velocities v of a specified model instance in a given Context.  <br /></td></tr>
<tr class="memitem:aa6864e2bce8855ab702b8ea1bb748f00" id="r_aa6864e2bce8855ab702b8ea1bb748f00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6864e2bce8855ab702b8ea1bb748f00">SetVelocities</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;v) const</td></tr>
<tr class="memdesc:aa6864e2bce8855ab702b8ea1bb748f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the generalized velocities v in a given Context from a given vector.  <br /></td></tr>
<tr class="memitem:a3040154a84f6d45b28d0408a7826e2a9" id="r_a3040154a84f6d45b28d0408a7826e2a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3040154a84f6d45b28d0408a7826e2a9">SetVelocities</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;v_instance) const</td></tr>
<tr class="memdesc:a3040154a84f6d45b28d0408a7826e2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the generalized velocities v for a particular model instance in a given Context from a given vector.  <br /></td></tr>
<tr class="memitem:ae9f727a51103f28b4e0ee0ce66adc0cd" id="r_ae9f727a51103f28b4e0ee0ce66adc0cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9f727a51103f28b4e0ee0ce66adc0cd">SetVelocities</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *state, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;v_instance) const</td></tr>
<tr class="memdesc:ae9f727a51103f28b4e0ee0ce66adc0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Sets the generalized velocities v for a particular model instance in a given State from a given vector.  <br /></td></tr>
<tr class="memitem:ae73edc00d493b3f15ba7679cc14830a0" id="r_ae73edc00d493b3f15ba7679cc14830a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae73edc00d493b3f15ba7679cc14830a0">SetDefaultState</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *state) const override</td></tr>
<tr class="memdesc:ae73edc00d493b3f15ba7679cc14830a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <span class="tt">state</span> according to defaults set by the user for joints (e.g.  <br /></td></tr>
<tr class="memitem:a470c99c41ab31927ae50c9996786bd10" id="r_a470c99c41ab31927ae50c9996786bd10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a470c99c41ab31927ae50c9996786bd10">SetRandomState</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *state, <a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *generator) const override</td></tr>
<tr class="memdesc:a470c99c41ab31927ae50c9996786bd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns random values to all elements of the state, by drawing samples independently for each joint/free body (coming soon: and then solving a mathematical program to "project" these samples onto the registered system constraints).  <br /></td></tr>
<tr class="memitem:ae77ccdb449347f6eacb212c46eb2d9c7" id="r_ae77ccdb449347f6eacb212c46eb2d9c7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae77ccdb449347f6eacb212c46eb2d9c7">GetPositionNames</a> (bool add_model_instance_prefix=true, bool always_add_suffix=true) const</td></tr>
<tr class="memdesc:ae77ccdb449347f6eacb212c46eb2d9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of string names corresponding to each element of the position vector.  <br /></td></tr>
<tr class="memitem:a5dfe71a78246c3a81abc33954aed21df" id="r_a5dfe71a78246c3a81abc33954aed21df"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5dfe71a78246c3a81abc33954aed21df">GetPositionNames</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, bool add_model_instance_prefix=false, bool always_add_suffix=true) const</td></tr>
<tr class="memdesc:a5dfe71a78246c3a81abc33954aed21df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of string names corresponding to each element of the position vector.  <br /></td></tr>
<tr class="memitem:aa39318cfd5bf8d55192c15985af19e26" id="r_aa39318cfd5bf8d55192c15985af19e26"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa39318cfd5bf8d55192c15985af19e26">GetVelocityNames</a> (bool add_model_instance_prefix=true, bool always_add_suffix=true) const</td></tr>
<tr class="memdesc:aa39318cfd5bf8d55192c15985af19e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of string names corresponding to each element of the velocity vector.  <br /></td></tr>
<tr class="memitem:af7ff5492ccf95a01e734827ae8953584" id="r_af7ff5492ccf95a01e734827ae8953584"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7ff5492ccf95a01e734827ae8953584">GetVelocityNames</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, bool add_model_instance_prefix=false, bool always_add_suffix=true) const</td></tr>
<tr class="memdesc:af7ff5492ccf95a01e734827ae8953584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of string names corresponding to each element of the velocity vector.  <br /></td></tr>
<tr class="memitem:a407f8d30b37d10d4070126c980fed288" id="r_a407f8d30b37d10d4070126c980fed288"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a407f8d30b37d10d4070126c980fed288">GetStateNames</a> (bool add_model_instance_prefix=true) const</td></tr>
<tr class="memdesc:a407f8d30b37d10d4070126c980fed288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of string names corresponding to each element of the multibody state vector.  <br /></td></tr>
<tr class="memitem:ad0eee063ebd3e815ccdb6116e67f8d31" id="r_ad0eee063ebd3e815ccdb6116e67f8d31"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0eee063ebd3e815ccdb6116e67f8d31">GetStateNames</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, bool add_model_instance_prefix=false) const</td></tr>
<tr class="memdesc:ad0eee063ebd3e815ccdb6116e67f8d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of string names corresponding to each element of the multibody state vector.  <br /></td></tr>
<tr class="memitem:afc48985677d2b6db6916e452ab8e4eef" id="r_afc48985677d2b6db6916e452ab8e4eef"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc48985677d2b6db6916e452ab8e4eef">GetActuatorNames</a> (bool add_model_instance_prefix=true) const</td></tr>
<tr class="memdesc:afc48985677d2b6db6916e452ab8e4eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of string names corresponding to each element of the actuation vector.  <br /></td></tr>
<tr class="memitem:a87bda03db9b65dfc45756ca6b6f73b11" id="r_a87bda03db9b65dfc45756ca6b6f73b11"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87bda03db9b65dfc45756ca6b6f73b11">GetActuatorNames</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, bool add_model_instance_prefix=false) const</td></tr>
<tr class="memdesc:a87bda03db9b65dfc45756ca6b6f73b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of string names corresponding to each element of the actuation vector.  <br /></td></tr>
<tr class="memitem:a7a29c9845043cc59458a5a3f3d8fd5f6" id="r_a7a29c9845043cc59458a5a3f3d8fd5f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a29c9845043cc59458a5a3f3d8fd5f6">GetActuationFromArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;u) const</td></tr>
<tr class="memdesc:a7a29c9845043cc59458a5a3f3d8fd5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of actuation values for <span class="tt">model_instance</span> from a vector <span class="tt">u</span> of actuation values for the entire plant model.  <br /></td></tr>
<tr class="memitem:a695e24adcadab868d6dd5a57f51953fd" id="r_a695e24adcadab868d6dd5a57f51953fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a695e24adcadab868d6dd5a57f51953fd">SetActuationInArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;u_instance, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; u) const</td></tr>
<tr class="memdesc:a695e24adcadab868d6dd5a57f51953fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given actuation values <span class="tt">u_instance</span> for the actuators in <span class="tt">model_instance</span>, this function updates the actuation vector u for the entire plant model to which this actuator belongs to.  <br /></td></tr>
<tr class="memitem:a5d2ae02e64d4433eb7c5bbebd2a9dd0d" id="r_a5d2ae02e64d4433eb7c5bbebd2a9dd0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d2ae02e64d4433eb7c5bbebd2a9dd0d">GetPositionsFromArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;q) const</td></tr>
<tr class="memdesc:a5d2ae02e64d4433eb7c5bbebd2a9dd0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of generalized positions for <span class="tt">model_instance</span> from a vector <span class="tt">q_array</span> of generalized positions for the entire model model.  <br /></td></tr>
<tr class="memitem:ac99acfa004ed8d14c7b950ae3cefc233" id="r_ac99acfa004ed8d14c7b950ae3cefc233"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac99acfa004ed8d14c7b950ae3cefc233">GetPositionsFromArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;q, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; q_out) const</td></tr>
<tr class="memdesc:ac99acfa004ed8d14c7b950ae3cefc233"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Populates output vector q_out and with the generalized positions for <span class="tt">model_instance</span> from a vector <span class="tt">q</span> of generalized positions for the entire model.  <br /></td></tr>
<tr class="memitem:ab264035a2e8c56b57bd80afb0b6ffb48" id="r_ab264035a2e8c56b57bd80afb0b6ffb48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab264035a2e8c56b57bd80afb0b6ffb48">SetPositionsInArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;q_instance, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; q) const</td></tr>
<tr class="memdesc:ab264035a2e8c56b57bd80afb0b6ffb48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vector of generalized positions for <span class="tt">model_instance</span> in <span class="tt">q</span> using <span class="tt">q_instance</span>, leaving all other elements in the array untouched.  <br /></td></tr>
<tr class="memitem:a52b25b565255d213a7f483b12f18ab68" id="r_a52b25b565255d213a7f483b12f18ab68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52b25b565255d213a7f483b12f18ab68">GetVelocitiesFromArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;v) const</td></tr>
<tr class="memdesc:a52b25b565255d213a7f483b12f18ab68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of generalized velocities for <span class="tt">model_instance</span> from a vector <span class="tt">v</span> of generalized velocities for the entire <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> model.  <br /></td></tr>
<tr class="memitem:afd9d34274a3e772f96ab8060e604cda1" id="r_afd9d34274a3e772f96ab8060e604cda1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd9d34274a3e772f96ab8060e604cda1">GetVelocitiesFromArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;v, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; v_out) const</td></tr>
<tr class="memdesc:afd9d34274a3e772f96ab8060e604cda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Populates output vector v_out with the generalized velocities for <span class="tt">model_instance</span> from a vector <span class="tt">v</span> of generalized velocities for the entire model.  <br /></td></tr>
<tr class="memitem:a89105b866dae232e6a9236d50f1fb08c" id="r_a89105b866dae232e6a9236d50f1fb08c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89105b866dae232e6a9236d50f1fb08c">SetVelocitiesInArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;v_instance, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; v) const</td></tr>
<tr class="memdesc:a89105b866dae232e6a9236d50f1fb08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vector of generalized velocities for <span class="tt">model_instance</span> in <span class="tt">v</span> using <span class="tt">v_instance</span>, leaving all other elements in the array untouched.  <br /></td></tr>
<tr id="pub-methods-6" class="groupHeader"><td colspan="2"><div class="groupHeader">Working with free and floating base bodies</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="mbp_working_with_free_bodies"></a> In robotics it is natural to think of some bodies as "floating", in the sense that they may be posed independently of any other body. Manipulands (objects to be manipulated by a robot) are the most obvious example since they aren't connected to anything else. A mobile base or humanoid torso can also be posed freely, though other bodies will move along with them. MultibodyPlant recognizes floating bodies at <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> by the fact that they have no user-provided joint connecting them to any parent body. They are given six degrees of freedom relative to the World frame and referred to as <em>floating base bodies</em>.</p>
<p>We use the term <em>free body</em> for <em>any</em> body that has six degrees of freedom relative to its parent. Floating base bodies are a special case of free bodies, with World as the assumed parent. The distinction is where the degrees of freedom come from: floating base bodies get theirs from <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>; all other free bodies get theirs from user-defined joints. The APIs below depend on that distinction. Those with "FreeBody" in their names work on all free bodies. Those with "FloatingBaseBody" only work on floating base bodies.</p>
<p>To implement a floating base body at Finalize(), MultibodyPlant automatically adds a floating joint between that body's frame and the World frame. Prior to that there is no joint so we provide a pre-Finalize() API here to set the default pose of a floating base body in World. (See <a class="el" href="#aadfba35383b020c7184081574cbfcbbd" title="Provisionally records a default World pose for body, to be used in case body turns out to be a floati...">SetDefaultFloatingBaseBodyPose()</a> below.) The default pose is used to initialize the floating joint's coordinates once that joint has been added. After Finalize(), you can use the <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> API by accessing the automatically-added floating joint (see below), or continue to use the APIs in this group.</p>
<p>Post-Finalize() there are a few additional APIs that apply only to floating base bodies. For example, you can query whether a <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a> is a floating base body with <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html#a9045be5f1c764bcd68284096eb4086bc" title="(Advanced) Returns true if this body is a floating base body, meaning it had no explicit joint to a p...">RigidBody::is_floating_base_body()</a>, and can request a list of all floating base bodies with <a class="el" href="#ab593b96202e54f20747521c815b8989f" title="Returns the set of body indices corresponding to the floating base bodies in the model,...">GetFloatingBaseBodies()</a>. The relevant joint coordinate entries q and v in the multibody state vector can be obtained with <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html#a8e98e34e5da5ecfc7e03086b70cf5489" title="(Advanced) For floating base bodies (see is_floating_base_body()), returns the index of this RigidBod...">RigidBody::floating_positions_start()</a> and <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html#a02779a5522ffef8547daf6c386ffb47b" title="(Advanced) For floating base bodies (see is_floating_base_body()), returns the index of this RigidBod...">RigidBody::floating_velocities_start_in_v()</a>.</p>
<p>If there is a user-provided joint mobilizing a free body, use the <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> API as you would for any other joint. You can also use the <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> API to work with floating base bodies after Finalize(), by accessing the automatically-added floating joint. Use <a class="el" href="#a65a8bf98a3d37404d4a9de8d59e1ca70" title="Returns a constant reference to a joint that is identified by the string name in this MultibodyPlant.">GetJointByName()</a> with the name of the floating base body (see <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html#a24dcbf29c0d6cd766009a182a6484e3b" title="Gets the name associated with this rigid body.">RigidBody::name()</a>). (In the rare case that there is already some unrelated joint with that name, we prepend underscores to the joint's name until it is unique.) </p>
</div></td></tr>
<tr class="memitem:ab593b96202e54f20747521c815b8989f" id="r_ab593b96202e54f20747521c815b8989f"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; <a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">BodyIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab593b96202e54f20747521c815b8989f">GetFloatingBaseBodies</a> () const</td></tr>
<tr class="memdesc:ab593b96202e54f20747521c815b8989f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of body indices corresponding to the floating base bodies in the model, in no particular order.  <br /></td></tr>
<tr class="memitem:aadfba35383b020c7184081574cbfcbbd" id="r_aadfba35383b020c7184081574cbfcbbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadfba35383b020c7184081574cbfcbbd">SetDefaultFloatingBaseBodyPose</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X_WB)</td></tr>
<tr class="memdesc:aadfba35383b020c7184081574cbfcbbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provisionally records a default World pose for <span class="tt">body</span>, to be used in case <span class="tt">body</span> turns out to be a floating base body after <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>.  <br /></td></tr>
<tr class="memitem:ab368246484a46e333b6edce659f42cfb" id="r_ab368246484a46e333b6edce659f42cfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab368246484a46e333b6edce659f42cfb">GetDefaultFloatingBaseBodyPose</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body) const</td></tr>
<tr class="memdesc:ab368246484a46e333b6edce659f42cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the provisional default pose of <span class="tt">body</span> as set by <a class="el" href="#aadfba35383b020c7184081574cbfcbbd" title="Provisionally records a default World pose for body, to be used in case body turns out to be a floati...">SetDefaultFloatingBaseBodyPose()</a>.  <br /></td></tr>
<tr class="memitem:a5ade7e309b20dc5f8d7010730d224381" id="r_a5ade7e309b20dc5f8d7010730d224381"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ade7e309b20dc5f8d7010730d224381">SetFloatingBaseBodyPoseInWorldFrame</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;X_WB) const</td></tr>
<tr class="memdesc:a5ade7e309b20dc5f8d7010730d224381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <span class="tt">context</span> to store the pose <span class="tt">X_WB</span> of a given floating base body B's body frame in the World frame W.  <br /></td></tr>
<tr class="memitem:a27c312732aae22e08b580998d6e09334" id="r_a27c312732aae22e08b580998d6e09334"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27c312732aae22e08b580998d6e09334">SetFloatingBaseBodyPoseInAnchoredFrame</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_F, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;X_FB) const</td></tr>
<tr class="memdesc:a27c312732aae22e08b580998d6e09334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <span class="tt">context</span> to store the World-frame pose of floating base body B, given its pose <span class="tt">X_FB</span> in an arbitrary anchored frame F.  <br /></td></tr>
<tr class="memitem:a24ec51f3cfb9ff7bb1a19034abe25d3a" id="r_a24ec51f3cfb9ff7bb1a19034abe25d3a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24ec51f3cfb9ff7bb1a19034abe25d3a">GetUniqueFloatingBaseBodyOrThrow</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a24ec51f3cfb9ff7bb1a19034abe25d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If there is a single base body in the model given by <span class="tt">model_instance</span>, and that body is a floating base body, returns that floating base body.  <br /></td></tr>
<tr class="memitem:a7f07529f78963c62ca6a651a96619fbe" id="r_a7f07529f78963c62ca6a651a96619fbe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f07529f78963c62ca6a651a96619fbe">HasUniqueFloatingBaseBody</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a7f07529f78963c62ca6a651a96619fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there is a single base body in the model given by <span class="tt">model_instance</span>, and that body is a floating base body.  <br /></td></tr>
<tr class="memitem:a4ac585d6a0c8abd7893374d2e6e907fd" id="r_a4ac585d6a0c8abd7893374d2e6e907fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ac585d6a0c8abd7893374d2e6e907fd">GetFreeBodyPose</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body) const</td></tr>
<tr class="memdesc:a4ac585d6a0c8abd7893374d2e6e907fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">For any free body's 6-dof joint, gets the pose X_JpJc of the child frame Jc in its parent frame Jp.  <br /></td></tr>
<tr class="memitem:ae76c5ef45f57813ea469894cf79d5ef8" id="r_ae76c5ef45f57813ea469894cf79d5ef8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae76c5ef45f57813ea469894cf79d5ef8">SetFreeBodyPose</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;X_JpJc) const</td></tr>
<tr class="memdesc:ae76c5ef45f57813ea469894cf79d5ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">For any free body's 6-dof joint, sets <span class="tt">context</span> to store the pose X_JpJc of child frame Jc in its parent frame Jp.  <br /></td></tr>
<tr class="memitem:ad4672adb9536501522b21851abcd9912" id="r_ad4672adb9536501522b21851abcd9912"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4672adb9536501522b21851abcd9912">SetFreeBodyPose</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *state, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;X_JpJc) const</td></tr>
<tr class="memdesc:ad4672adb9536501522b21851abcd9912"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Variant of <a class="el" href="#ae76c5ef45f57813ea469894cf79d5ef8" title="For any free body&#39;s 6-dof joint, sets context to store the pose X_JpJc of child frame Jc in its paren...">SetFreeBodyPose()</a> that writes to a given <span class="tt">state</span> rather than directly to the Context.  <br /></td></tr>
<tr class="memitem:ac0d39c3dc950bc14797e787e873110d8" id="r_ac0d39c3dc950bc14797e787e873110d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0d39c3dc950bc14797e787e873110d8">SetFreeBodySpatialVelocity</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;V_JpJc) const</td></tr>
<tr class="memdesc:ac0d39c3dc950bc14797e787e873110d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">For any free body's 6-dof joint, sets <span class="tt">context</span> to store the spatial velocity V_JpJc of child frame Jc in its parent frame Jp.  <br /></td></tr>
<tr class="memitem:aa1f546d3cb8d03ec2e105839d817b687" id="r_aa1f546d3cb8d03ec2e105839d817b687"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1f546d3cb8d03ec2e105839d817b687">SetFreeBodySpatialVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *state, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;V_JpJc) const</td></tr>
<tr class="memdesc:aa1f546d3cb8d03ec2e105839d817b687"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Variant of <a class="el" href="#ac0d39c3dc950bc14797e787e873110d8" title="For any free body&#39;s 6-dof joint, sets context to store the spatial velocity V_JpJc of child frame Jc ...">SetFreeBodySpatialVelocity()</a> that writes to a given <span class="tt">state</span> rather than directly to the Context.  <br /></td></tr>
<tr class="memitem:ad44332b9a38a3534af794581915407ec" id="r_ad44332b9a38a3534af794581915407ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad44332b9a38a3534af794581915407ec">SetFreeBodyRandomTranslationDistribution</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &amp;translation)</td></tr>
<tr class="memdesc:ad44332b9a38a3534af794581915407ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">For any free body's 6-dof joint, sets the distribution used by <a class="el" href="#a470c99c41ab31927ae50c9996786bd10" title="Assigns random values to all elements of the state, by drawing samples independently for each joint/f...">SetRandomState()</a> to populate the x-y-z <span class="tt">translation</span> of its child frame Jc with respect to its parent frame Jp.  <br /></td></tr>
<tr class="memitem:a0e948d3233ccb5bf0001d5bd7425062a" id="r_a0e948d3233ccb5bf0001d5bd7425062a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e948d3233ccb5bf0001d5bd7425062a">SetFreeBodyRandomRotationDistribution</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const Eigen::Quaternion&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &amp;rotation)</td></tr>
<tr class="memdesc:a0e948d3233ccb5bf0001d5bd7425062a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For any free body's 6-dof joint, sets the distribution used by <a class="el" href="#a470c99c41ab31927ae50c9996786bd10" title="Assigns random values to all elements of the state, by drawing samples independently for each joint/f...">SetRandomState()</a> to populate the orientation of its child frame Jc with respect to its parent frame Jp, expressed as a quaternion.  <br /></td></tr>
<tr class="memitem:a057dc09db3cf93f1cc47fb1db6995ca0" id="r_a057dc09db3cf93f1cc47fb1db6995ca0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a057dc09db3cf93f1cc47fb1db6995ca0">SetFreeBodyRandomRotationDistributionToUniform</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body)</td></tr>
<tr class="memdesc:a057dc09db3cf93f1cc47fb1db6995ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">For any free body's 6-dof joint, sets the distribution used by <a class="el" href="#a470c99c41ab31927ae50c9996786bd10" title="Assigns random values to all elements of the state, by drawing samples independently for each joint/f...">SetRandomState()</a> to populate the orientation of its child frame Jc with respect to its parent frame Jp using uniformly random rotations (expressed as a quaternion).  <br /></td></tr>
<tr class="memitem:a9e833c04c184ed89a4af6632b827500b" id="r_a9e833c04c184ed89a4af6632b827500b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e833c04c184ed89a4af6632b827500b">SetFreeBodyRandomAnglesDistribution</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html">math::RollPitchYaw</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &amp;angles)</td></tr>
<tr class="memdesc:a9e833c04c184ed89a4af6632b827500b"><td class="mdescLeft">&#160;</td><td class="mdescRight">For any free body's 6-dof joint, sets the distribution used by <a class="el" href="#a470c99c41ab31927ae50c9996786bd10" title="Assigns random values to all elements of the state, by drawing samples independently for each joint/f...">SetRandomState()</a> to populate the orientation of its child frame Jc with respect to its parent frame Jp, expressed with roll-pitch-yaw angles.  <br /></td></tr>
<tr class="memitem:a97c0546b4129dad123a33b9b84831157" id="r_a97c0546b4129dad123a33b9b84831157"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97c0546b4129dad123a33b9b84831157">SetFreeBodyPoseInWorldFrame</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;X_WB) const</td></tr>
<tr class="memdesc:a97c0546b4129dad123a33b9b84831157"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr class="memitem:aa046883a4c5530d09082bf39638c119a" id="r_aa046883a4c5530d09082bf39638c119a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa046883a4c5530d09082bf39638c119a">SetFreeBodyPoseInAnchoredFrame</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_F, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;X_FB) const</td></tr>
<tr class="memdesc:aa046883a4c5530d09082bf39638c119a"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr class="memitem:ae89c0d301b92604e7e15bfb5c62697b8" id="r_ae89c0d301b92604e7e15bfb5c62697b8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae89c0d301b92604e7e15bfb5c62697b8">GetUniqueFreeBaseBodyOrThrow</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:ae89c0d301b92604e7e15bfb5c62697b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr class="memitem:afd1c4b1852853c9cf02613bfef053d8e" id="r_afd1c4b1852853c9cf02613bfef053d8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd1c4b1852853c9cf02613bfef053d8e">SetDefaultFreeBodyPose</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X_PB)</td></tr>
<tr class="memdesc:afd1c4b1852853c9cf02613bfef053d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr class="memitem:ae2c0bf5b2fcbf8715b416864fc507a56" id="r_ae2c0bf5b2fcbf8715b416864fc507a56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2c0bf5b2fcbf8715b416864fc507a56">GetDefaultFreeBodyPose</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body) const</td></tr>
<tr class="memdesc:ae2c0bf5b2fcbf8715b416864fc507a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr class="memitem:afc9ce98e9025085b7511227e5d12ebf1" id="r_afc9ce98e9025085b7511227e5d12ebf1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc9ce98e9025085b7511227e5d12ebf1">HasUniqueFreeBaseBody</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:afc9ce98e9025085b7511227e5d12ebf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr id="pub-methods-7" class="groupHeader"><td colspan="2"><div class="groupHeader">Kinematic and dynamic computations</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="mbp_kinematic_and_dynamic_computations"></a> These methods return kinematic results for the state supplied in the given <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>.</p>
<p>Methods whose names being with <span class="tt">Eval</span> return a reference into the Context's cache, performing computation first only if the relevant state has changed. Methods beginning with <span class="tt">Calc</span> perform computation unconditionally and return a result without updating the cache. </p>
</div></td></tr>
<tr class="memitem:a08a04a92064da4bf2b791b09e7da5ab7" id="r_a08a04a92064da4bf2b791b09e7da5ab7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08a04a92064da4bf2b791b09e7da5ab7">EvalBodyPoseInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body_B) const</td></tr>
<tr class="memdesc:a08a04a92064da4bf2b791b09e7da5ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the pose <span class="tt">X_WB</span> of a body B in the world frame W.  <br /></td></tr>
<tr class="memitem:ac926d8ffaa1eab38a3ba38875d11b584" id="r_ac926d8ffaa1eab38a3ba38875d11b584"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac926d8ffaa1eab38a3ba38875d11b584">EvalBodySpatialVelocityInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body_B) const</td></tr>
<tr class="memdesc:ac926d8ffaa1eab38a3ba38875d11b584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates V_WB, body B's spatial velocity in the world frame W.  <br /></td></tr>
<tr class="memitem:ae663a7a52206ea41f2520ec926bd2cb2" id="r_ae663a7a52206ea41f2520ec926bd2cb2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae663a7a52206ea41f2520ec926bd2cb2">EvalBodySpatialAccelerationInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body_B) const</td></tr>
<tr class="memdesc:ae663a7a52206ea41f2520ec926bd2cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates A_WB, body B's spatial acceleration in the world frame W.  <br /></td></tr>
<tr class="memitem:a69e023f53fef5fc02b278a1c8a7b78e5" id="r_a69e023f53fef5fc02b278a1c8a7b78e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69e023f53fef5fc02b278a1c8a7b78e5">CalcRelativeTransform</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B) const</td></tr>
<tr class="memdesc:a69e023f53fef5fc02b278a1c8a7b78e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rigid transform (pose) <span class="tt">X_AB</span> relating frame A and frame B.  <br /></td></tr>
<tr class="memitem:a370093b8df7b283bd4257493246c9082" id="r_a370093b8df7b283bd4257493246c9082"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a370093b8df7b283bd4257493246c9082">CalcRelativeRotationMatrix</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B) const</td></tr>
<tr class="memdesc:a370093b8df7b283bd4257493246c9082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rotation matrix <span class="tt">R_AB</span> relating frame A and frame B.  <br /></td></tr>
<tr class="memitem:a201bed53cf6c1b61a65df508469423fc" id="r_a201bed53cf6c1b61a65df508469423fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a201bed53cf6c1b61a65df508469423fc">CalcPointsPositions</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;p_BQi, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; p_AQi) const</td></tr>
<tr class="memdesc:a201bed53cf6c1b61a65df508469423fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the positions <span class="tt">p_BQi</span> for a set of points <span class="tt">Qi</span> measured and expressed in a frame B, this method computes the positions <span class="tt">p_AQi(q)</span> of each point <span class="tt">Qi</span> in the set as measured and expressed in another frame A, as a function of the generalized positions q of the model.  <br /></td></tr>
<tr class="memitem:a253d10a3004a2ac72cee5404b6192644" id="r_a253d10a3004a2ac72cee5404b6192644"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a253d10a3004a2ac72cee5404b6192644">CalcPointsVelocities</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;p_BQi, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; v_AQi_E) const</td></tr>
<tr class="memdesc:a253d10a3004a2ac72cee5404b6192644"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a set of n points Qi (i = 0, ... n-1) that are regarded as fixed on a frame B, calculates the velocities v_AQi_E of Qi measured in a frame A and expressed in a frame E.  <br /></td></tr>
<tr class="memitem:ac35cf69a93ae82995b04772a811f9870" id="r_ac35cf69a93ae82995b04772a811f9870"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac35cf69a93ae82995b04772a811f9870">CalcTotalMass</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:ac35cf69a93ae82995b04772a811f9870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the total mass of all bodies in this <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>.  <br /></td></tr>
<tr class="memitem:acffd2e6a48e88f9c1b2f561f7dec2135" id="r_acffd2e6a48e88f9c1b2f561f7dec2135"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acffd2e6a48e88f9c1b2f561f7dec2135">CalcTotalMass</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; &amp;model_instances) const</td></tr>
<tr class="memdesc:acffd2e6a48e88f9c1b2f561f7dec2135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the total mass of all bodies contained in model_instances.  <br /></td></tr>
<tr class="memitem:a36c71f9947c9cfa3874a550d82a0139d" id="r_a36c71f9947c9cfa3874a550d82a0139d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36c71f9947c9cfa3874a550d82a0139d">CalcCenterOfMassPositionInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a36c71f9947c9cfa3874a550d82a0139d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the position vector from the world origin Wo to the center of mass of all bodies in this <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>, expressed in the world frame W.  <br /></td></tr>
<tr class="memitem:ac5edd56266d5c7a41e4660ec145179c1" id="r_ac5edd56266d5c7a41e4660ec145179c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5edd56266d5c7a41e4660ec145179c1">CalcCenterOfMassPositionInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; &amp;model_instances) const</td></tr>
<tr class="memdesc:ac5edd56266d5c7a41e4660ec145179c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the position vector from the world origin Wo to the center of mass of all non-world bodies contained in model_instances, expressed in the world frame W.  <br /></td></tr>
<tr class="memitem:a68e79c41979c9448133534e90465b2ec" id="r_a68e79c41979c9448133534e90465b2ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68e79c41979c9448133534e90465b2ec">CalcSpatialInertia</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_F, const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">BodyIndex</a> &gt; &amp;body_indexes) const</td></tr>
<tr class="memdesc:a68e79c41979c9448133534e90465b2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns M_SFo_F, the spatial inertia of a set S of bodies about point Fo (the origin of a frame F), expressed in frame F.  <br /></td></tr>
<tr class="memitem:af145801a5fdaddbd08ffd3f6158ec4e9" id="r_af145801a5fdaddbd08ffd3f6158ec4e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af145801a5fdaddbd08ffd3f6158ec4e9">CalcCenterOfMassTranslationalVelocityInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:af145801a5fdaddbd08ffd3f6158ec4e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates system center of mass translational velocity in world frame W.  <br /></td></tr>
<tr class="memitem:a8287928c6b0c43158cce34773370cbd3" id="r_a8287928c6b0c43158cce34773370cbd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8287928c6b0c43158cce34773370cbd3">CalcCenterOfMassTranslationalAccelerationInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a8287928c6b0c43158cce34773370cbd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the system S contained in this MultibodyPlant, calculates Scm's translational acceleration in the world frame W expressed in W, where Scm is the center of mass of S.  <br /></td></tr>
<tr class="memitem:ae19c48bd3033e534a9a04502af791d72" id="r_ae19c48bd3033e534a9a04502af791d72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae19c48bd3033e534a9a04502af791d72">CalcCenterOfMassTranslationalAccelerationInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; &amp;model_instances) const</td></tr>
<tr class="memdesc:ae19c48bd3033e534a9a04502af791d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the system S containing the selected model instances, calculates Scm's translational acceleration in the world frame W expressed in W, where Scm is the center of mass of S.  <br /></td></tr>
<tr class="memitem:a08450360f6b90cd5de1ce7a6d01ade63" id="r_a08450360f6b90cd5de1ce7a6d01ade63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08450360f6b90cd5de1ce7a6d01ade63">CalcCenterOfMassTranslationalVelocityInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; &amp;model_instances) const</td></tr>
<tr class="memdesc:a08450360f6b90cd5de1ce7a6d01ade63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates system center of mass translational velocity in world frame W.  <br /></td></tr>
<tr class="memitem:a2999dec61302bb9a2db8f79e1a6d7413" id="r_a2999dec61302bb9a2db8f79e1a6d7413"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_momentum.html">SpatialMomentum</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2999dec61302bb9a2db8f79e1a6d7413">CalcSpatialMomentumInWorldAboutPoint</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_WoP_W) const</td></tr>
<tr class="memdesc:a2999dec61302bb9a2db8f79e1a6d7413"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns the spatial momentum of <span class="tt">this</span> <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> in the world frame W, about a designated point P, expressed in the world frame W.  <br /></td></tr>
<tr class="memitem:abf96d385be1144f2100b29c3e5ef7311" id="r_abf96d385be1144f2100b29c3e5ef7311"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_momentum.html">SpatialMomentum</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf96d385be1144f2100b29c3e5ef7311">CalcSpatialMomentumInWorldAboutPoint</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; &amp;model_instances, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_WoP_W) const</td></tr>
<tr class="memdesc:abf96d385be1144f2100b29c3e5ef7311"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns the spatial momentum of a set of model instances in the world frame W, about a designated point P, expressed in frame W.  <br /></td></tr>
<tr class="memitem:a963cde13572c10429e85ba8de00d39e8" id="r_a963cde13572c10429e85ba8de00d39e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a963cde13572c10429e85ba8de00d39e8">CalcSpatialAccelerationsFromVdot</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;known_vdot, std::vector&lt; <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt; &gt; *A_WB_array) const</td></tr>
<tr class="memdesc:a963cde13572c10429e85ba8de00d39e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the state of this model in <span class="tt">context</span> and a known vector of generalized accelerations <span class="tt">known_vdot</span>, this method computes the spatial acceleration <span class="tt">A_WB</span> for each body as measured and expressed in the world frame W.  <br /></td></tr>
<tr class="memitem:af3d9f1dfe387a173b84c49a5bbe5a4c2" id="r_af3d9f1dfe387a173b84c49a5bbe5a4c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3d9f1dfe387a173b84c49a5bbe5a4c2">CalcInverseDynamics</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;known_vdot, const <a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html">MultibodyForces</a>&lt; T &gt; &amp;external_forces) const</td></tr>
<tr class="memdesc:af3d9f1dfe387a173b84c49a5bbe5a4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the state of this model in <span class="tt">context</span> and a known vector of generalized accelerations <span class="tt">vdot</span>, this method computes the set of generalized forces <span class="tt">tau</span> that would need to be applied in order to attain the specified generalized accelerations.  <br /></td></tr>
<tr class="memitem:aecbf5eca950cc15b86c9133950c14f70" id="r_aecbf5eca950cc15b86c9133950c14f70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecbf5eca950cc15b86c9133950c14f70">CalcImplicitTimeDerivativesResidual</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">systems::ContinuousState</a>&lt; T &gt; &amp;proposed_derivatives, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; residual) const</td></tr>
<tr class="memdesc:aecbf5eca950cc15b86c9133950c14f70"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> implements the <a class="el" href="classdrake_1_1systems_1_1_system.html#a8debe7d25e61fd759c918d889286525f" title="Evaluates the implicit form of the System equations and returns the residual.">systems::System::CalcImplicitTimeDerivativesResidual</a> method when the plant is modeled as a continuous-time system, returning one residual for each multibody state.  <br /></td></tr>
<tr class="memitem:ae1b54c8562f107e4d6e11b4b0f8d53c5" id="r_ae1b54c8562f107e4d6e11b4b0f8d53c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1b54c8562f107e4d6e11b4b0f8d53c5">CalcForceElementsContribution</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html">MultibodyForces</a>&lt; T &gt; *forces) const</td></tr>
<tr class="memdesc:ae1b54c8562f107e4d6e11b4b0f8d53c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the combined force contribution of <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> objects in the model.  <br /></td></tr>
<tr class="memitem:a0b1293f0e09ec2d3df0a9eaeab6baa9a" id="r_a0b1293f0e09ec2d3df0a9eaeab6baa9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b1293f0e09ec2d3df0a9eaeab6baa9a">CalcGravityGeneralizedForces</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a0b1293f0e09ec2d3df0a9eaeab6baa9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the generalized forces <span class="tt">tau_g(q)</span> due to gravity as a function of the generalized positions <span class="tt">q</span> stored in the input <span class="tt">context</span>.  <br /></td></tr>
<tr class="memitem:a05d83f939cc098d1c25eabecf41ff588" id="r_a05d83f939cc098d1c25eabecf41ff588"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05d83f939cc098d1c25eabecf41ff588">CalcGeneralizedForces</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html">MultibodyForces</a>&lt; T &gt; &amp;forces, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *generalized_forces) const</td></tr>
<tr class="memdesc:a05d83f939cc098d1c25eabecf41ff588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the generalized forces result of a set of <a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html" title="A class to hold a set of forces applied to a MultibodyTree system.">MultibodyForces</a> applied to this model.  <br /></td></tr>
<tr class="memitem:aa20199c5afe02d72dab2e59f1523fcae" id="r_aa20199c5afe02d72dab2e59f1523fcae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa20199c5afe02d72dab2e59f1523fcae">IsVelocityEqualToQDot</a> () const</td></tr>
<tr class="memdesc:aa20199c5afe02d72dab2e59f1523fcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the generalized velocity v is exactly the time derivative q̇ of the generalized coordinates q.  <br /></td></tr>
<tr class="memitem:aad7c5cf6df811b52e1622f085a63d8c5" id="r_aad7c5cf6df811b52e1622f085a63d8c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad7c5cf6df811b52e1622f085a63d8c5">MapVelocityToQDot</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;v, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; qdot) const</td></tr>
<tr class="memdesc:aad7c5cf6df811b52e1622f085a63d8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms generalized velocities v to time derivatives <span class="tt">qdot</span> of the generalized positions vector <span class="tt">q</span> (stored in <span class="tt">context</span>).  <br /></td></tr>
<tr class="memitem:ae1a772571ef9869938fd98b5a4c635f5" id="r_ae1a772571ef9869938fd98b5a4c635f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1a772571ef9869938fd98b5a4c635f5">MapQDotToVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;qdot, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; v) const</td></tr>
<tr class="memdesc:ae1a772571ef9869938fd98b5a4c635f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the time derivative <span class="tt">qdot</span> of the generalized positions vector <span class="tt">q</span> (stored in <span class="tt">context</span>) to generalized velocities <span class="tt">v</span>.  <br /></td></tr>
<tr class="memitem:aad91322eedc3ad026f5c1cb3b8d6c6b7" id="r_aad91322eedc3ad026f5c1cb3b8d6c6b7"><td class="memItemLeft" align="right" valign="top">Eigen::SparseMatrix&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad91322eedc3ad026f5c1cb3b8d6c6b7">MakeVelocityToQDotMap</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aad91322eedc3ad026f5c1cb3b8d6c6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the matrix <span class="tt">N(q)</span>, which maps <span class="tt">q̇ = N(q)⋅v</span>, as described in <a class="el" href="#aad7c5cf6df811b52e1622f085a63d8c5" title="Transforms generalized velocities v to time derivatives qdot of the generalized positions vector q (s...">MapVelocityToQDot()</a>.  <br /></td></tr>
<tr class="memitem:a8c93a7afbc73ba1624288d42c1f97600" id="r_a8c93a7afbc73ba1624288d42c1f97600"><td class="memItemLeft" align="right" valign="top">Eigen::SparseMatrix&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c93a7afbc73ba1624288d42c1f97600">MakeQDotToVelocityMap</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a8c93a7afbc73ba1624288d42c1f97600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the matrix <span class="tt">N⁺(q)</span>, which maps <span class="tt">v = N⁺(q)⋅q̇</span>, as described in <a class="el" href="#ae1a772571ef9869938fd98b5a4c635f5" title="Transforms the time derivative qdot of the generalized positions vector q (stored in context) to gene...">MapQDotToVelocity()</a>.  <br /></td></tr>
<tr id="pub-methods-8" class="groupHeader"><td colspan="2"><div class="groupHeader">System matrix computations</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="mbp_system_matrix_computations"></a> Methods in this section compute and return various matrices that appear in the system equations of motion.</p>
<p>For better performance, prefer to use direct computations where available rather than work with explicit matrices. See <a class="el" href="#mbp_kinematic_and_dynamic_computations">Kinematic and dynamics computations</a> for available computations. For example, you can obtain the mass matrix, Coriolis, centripetal, and gyroscopic "bias" terms, and a variety of Jacobian and actuation matrices. </p>
</div></td></tr>
<tr class="memitem:a42ee709a2ac50e2ae6c6a4cb153ea2e8" id="r_a42ee709a2ac50e2ae6c6a4cb153ea2e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42ee709a2ac50e2ae6c6a4cb153ea2e8">CalcMassMatrixViaInverseDynamics</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; M) const</td></tr>
<tr class="memdesc:a42ee709a2ac50e2ae6c6a4cb153ea2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mass matrix <span class="tt">M(q)</span> of the model using a slow method (inverse dynamics).  <br /></td></tr>
<tr class="memitem:a1ba9332d8937729be136b54c8adc8b19" id="r_a1ba9332d8937729be136b54c8adc8b19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ba9332d8937729be136b54c8adc8b19">CalcMassMatrix</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; M) const</td></tr>
<tr class="memdesc:a1ba9332d8937729be136b54c8adc8b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficiently computes the mass matrix <span class="tt">M(q)</span> of the model.  <br /></td></tr>
<tr class="memitem:ae1c9973e5bec9022fa46dfcedb34df84" id="r_ae1c9973e5bec9022fa46dfcedb34df84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1c9973e5bec9022fa46dfcedb34df84">MakeStateSelectorMatrix</a> (const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt; &amp;user_to_joint_index_map) const</td></tr>
<tr class="memdesc:ae1c9973e5bec9022fa46dfcedb34df84"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows users to map the state of <span class="tt">this</span> model, x, into a vector of selected state xₛ with a given preferred ordering.  <br /></td></tr>
<tr class="memitem:a91d9ba2b26eb3887a1e277875a5af127" id="r_a91d9ba2b26eb3887a1e277875a5af127"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91d9ba2b26eb3887a1e277875a5af127">MakeActuatorSelectorMatrix</a> (const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> &gt; &amp;user_to_actuator_index_map) const</td></tr>
<tr class="memdesc:a91d9ba2b26eb3887a1e277875a5af127"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows user to map a vector <span class="tt">uₛ</span> containing the actuation for a set of selected actuators into the vector u containing the actuation values for <span class="tt">this</span> full model.  <br /></td></tr>
<tr class="memitem:aa4dc238d06e942e23f0d948f96bc3cfb" id="r_aa4dc238d06e942e23f0d948f96bc3cfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4dc238d06e942e23f0d948f96bc3cfb">MakeActuationMatrix</a> () const</td></tr>
<tr class="memdesc:aa4dc238d06e942e23f0d948f96bc3cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method creates an actuation matrix B mapping a vector of actuation values u into generalized forces <span class="tt">tau_u = B * u</span>, where B is a matrix of size <span class="tt">nv x nu</span> with <span class="tt">nu</span> equal to <a class="el" href="#ae3fc8de8de8eaf2d37a24c79d6be8e97" title="Returns the total number of actuated degrees of freedom.">num_actuated_dofs()</a> and <span class="tt">nv</span> equal to <a class="el" href="#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a>.  <br /></td></tr>
<tr class="memitem:a5746187726bdac7a915a2435e0cba13e" id="r_a5746187726bdac7a915a2435e0cba13e"><td class="memItemLeft" align="right" valign="top">Eigen::SparseMatrix&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5746187726bdac7a915a2435e0cba13e">MakeActuationMatrixPseudoinverse</a> () const</td></tr>
<tr class="memdesc:a5746187726bdac7a915a2435e0cba13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the pseudoinverse of the actuation matrix B directly (without requiring an explicit inverse calculation).  <br /></td></tr>
<tr class="memitem:af90a2eb58b242d1a85176e32435004c9" id="r_af90a2eb58b242d1a85176e32435004c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af90a2eb58b242d1a85176e32435004c9">MakeActuatorSelectorMatrix</a> (const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt; &amp;user_to_joint_index_map) const</td></tr>
<tr class="memdesc:af90a2eb58b242d1a85176e32435004c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative signature to build an actuation selector matrix <span class="tt">Su</span> such that <span class="tt">u = Su⋅uₛ</span>, where u is the vector of actuation values for the full model (see <a class="el" href="#a69ef9262ffab02b34bdf20449aab7551" title="Returns a constant reference to the input port for external actuation for all actuated dofs.">get_actuation_input_port()</a>) and uₛ is a vector of actuation values for the actuators acting on the joints listed by <span class="tt">user_to_joint_index_map</span>.  <br /></td></tr>
<tr id="pub-methods-9" class="groupHeader"><td colspan="2"><div class="groupHeader">Jacobian functions</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="Jacobian_functions"></a> Herein, a Jacobian is a matrix that contains the partial derivatives of a vector with respect to a list of scalars.</p>
<p>The vector may be a position vector, translational velocity, angular velocity, or spatial velocity and the scalars may be the system's generalized positions q or "speeds" 𝑠 where 𝑠 is either q̇ (time-derivative of generalized positions) or v (generalized velocities).</p>
<p>JAq_p_PQ denotes the Jacobian in a frame A of the position vector from point P to point Q with respect to the generalized positions q. It is calculated with <a class="el" href="#ad4f6754b441668775193177ad5dc7e09" title="For each point Bi affixed/welded to a frame B, calculates Jq_p_AoBi, Bi&#39;s position vector Jacobian in...">CalcJacobianPositionVector()</a>.</p>
<p>J𝑠_w_AB denotes the angular velocity Jacobian in a frame A of a frame B with respect to "speeds" 𝑠. It is calculated with <a class="el" href="#a70878af42e7d09d7861e36cb4616fc0d" title="Calculates J𝑠_w_AB, a frame B&#39;s angular velocity Jacobian in a frame A with respect to &quot;speeds&quot; 𝑠.">CalcJacobianAngularVelocity()</a>.</p>
<p>J𝑠_V_ABp denotes the spatial velocity Jacobian in a frame A of a point Bp of frame B with respect to "speeds" 𝑠. It is calculated with <a class="el" href="#a206be3cb8c5909f50bcc671b7bedaa13" title="For one point Bp fixed/welded to a frame B, calculates J𝑠_V_ABp, Bp&#39;s spatial velocity Jacobian in fr...">CalcJacobianSpatialVelocity()</a>.</p>
<p>J𝑠_v_ABp denotes the translational velocity Jacobian in a frame A of a point Bp of frame B with respect to "speeds" 𝑠. It is calculated with <a class="el" href="#a0afc6adf5bda2b9456d67ab2405af076" title="For each point Bi affixed/welded to a frame B, calculates J𝑠_v_ABi, Bi&#39;s translational velocity Jacob...">CalcJacobianTranslationalVelocity()</a>.</p>
<p>J𝑠_v_AScm_E denotes the translational velocity Jacobian in a frame A of a point Scm with respect to "speeds" 𝑠, where point Scm is the center of mass of a system S. It is calculated with <a class="el" href="#af77549470a45208454339f59e989784a" title="Calculates J𝑠_v_AScm_E, point Scm&#39;s translational velocity Jacobian in frame A with respect to &quot;speed...">CalcJacobianCenterOfMassTranslationalVelocity()</a> </p>
</div></td></tr>
<tr class="memitem:aebb50c01460083966268609d9309dbb2" id="r_aebb50c01460083966268609d9309dbb2"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; Eigen::MatrixX&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebb50c01460083966268609d9309dbb2">EvalBlockSystemJacobian</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aebb50c01460083966268609d9309dbb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns the System Jacobian Jv_V_WB(q) in block form.  <br /></td></tr>
<tr class="memitem:a4f6239b2ed3aeda23fb3d75194c84715" id="r_a4f6239b2ed3aeda23fb3d75194c84715"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixX&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f6239b2ed3aeda23fb3d75194c84715">CalcFullSystemJacobian</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a4f6239b2ed3aeda23fb3d75194c84715"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Evaluates the block system Jacobian, then uses it to fill in an equivalent full matrix of size 6n x m where n is the number of mobilized bodies and m the number of generalized velocities (mobilities).  <br /></td></tr>
<tr class="memitem:a206be3cb8c5909f50bcc671b7bedaa13" id="r_a206be3cb8c5909f50bcc671b7bedaa13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a206be3cb8c5909f50bcc671b7bedaa13">CalcJacobianSpatialVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a> with_respect_to, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &gt; &amp;p_BoBp_B, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; Js_V_ABp_E) const</td></tr>
<tr class="memdesc:a206be3cb8c5909f50bcc671b7bedaa13"><td class="mdescLeft">&#160;</td><td class="mdescRight">For one point Bp fixed/welded to a frame B, calculates J𝑠_V_ABp, Bp's spatial velocity Jacobian in frame A with respect to "speeds" 𝑠.  <br /></td></tr>
<tr class="memitem:a70878af42e7d09d7861e36cb4616fc0d" id="r_a70878af42e7d09d7861e36cb4616fc0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70878af42e7d09d7861e36cb4616fc0d">CalcJacobianAngularVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a> with_respect_to, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt; T &gt; &gt; Js_w_AB_E) const</td></tr>
<tr class="memdesc:a70878af42e7d09d7861e36cb4616fc0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates J𝑠_w_AB, a frame B's angular velocity Jacobian in a frame A with respect to "speeds" 𝑠.  <br /></td></tr>
<tr class="memitem:a0afc6adf5bda2b9456d67ab2405af076" id="r_a0afc6adf5bda2b9456d67ab2405af076"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0afc6adf5bda2b9456d67ab2405af076">CalcJacobianTranslationalVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a> with_respect_to, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt; T &gt; &gt; &amp;p_BoBi_B, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; Js_v_ABi_E) const</td></tr>
<tr class="memdesc:a0afc6adf5bda2b9456d67ab2405af076"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each point Bi affixed/welded to a frame B, calculates J𝑠_v_ABi, Bi's translational velocity Jacobian in frame A with respect to "speeds" 𝑠.  <br /></td></tr>
<tr class="memitem:ad4f6754b441668775193177ad5dc7e09" id="r_ad4f6754b441668775193177ad5dc7e09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4f6754b441668775193177ad5dc7e09">CalcJacobianPositionVector</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt; T &gt; &gt; &amp;p_BoBi_B, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; Jq_p_AoBi_E) const</td></tr>
<tr class="memdesc:ad4f6754b441668775193177ad5dc7e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each point Bi affixed/welded to a frame B, calculates Jq_p_AoBi, Bi's position vector Jacobian in frame A with respect to the generalized positions q ≜ [q₁ ... qₙ]ᵀ as.  <br /></td></tr>
<tr class="memitem:af77549470a45208454339f59e989784a" id="r_af77549470a45208454339f59e989784a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af77549470a45208454339f59e989784a">CalcJacobianCenterOfMassTranslationalVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a> with_respect_to, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt; T &gt; &gt; Js_v_AScm_E) const</td></tr>
<tr class="memdesc:af77549470a45208454339f59e989784a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates J𝑠_v_AScm_E, point Scm's translational velocity Jacobian in frame A with respect to "speeds" 𝑠, expressed in frame E, where point Scm is the center of mass of the system S of all non-world bodies contained in <span class="tt">this</span> <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>.  <br /></td></tr>
<tr class="memitem:a7a8a5ba9eb6389a84e24da1c243304ca" id="r_a7a8a5ba9eb6389a84e24da1c243304ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a8a5ba9eb6389a84e24da1c243304ca">CalcJacobianCenterOfMassTranslationalVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; &amp;model_instances, <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a> with_respect_to, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt; T &gt; &gt; Js_v_AScm_E) const</td></tr>
<tr class="memdesc:a7a8a5ba9eb6389a84e24da1c243304ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates J𝑠_v_AScm_E, point Scm's translational velocity Jacobian in frame A with respect to "speeds" 𝑠, expressed in frame E, where point Scm is the center of mass of the system S of all non-world bodies contained in model_instances.  <br /></td></tr>
<tr id="pub-methods-10" class="groupHeader"><td colspan="2"><div class="groupHeader">Bias acceleration functions</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="bias_acceleration_functions"></a> The name a𝑠Bias_AP denotes a point P's bias translational acceleration with respect to "speeds" 𝑠 measured in a frame A, where 𝑠 is either q̇ (time-derivatives of generalized positions) or v (generalized velocities).</p>
<p>a𝑠Bias_AP includes the terms in a_AP (P's translational acceleration in A) that depend on q, q̇, v, but not terms that depend on 𝑠̇, i.e., a𝑠Bias_AP = a_AP when 𝑠̇ = 0. The proof below starts with v_AP (point P's translational velocity in frame A) written in terms of J𝑠_v_AP (point P's translational velocity Jacobian in frame A for s). </p><pre>
  v_AP = J𝑠_v_AP ⋅ 𝑠         which upon vector differentiation in A gives
  a_AP = Ĵ𝑠_v_AP ⋅ 𝑠  +  J𝑠_v_AP ⋅ 𝑠̇                 setting 𝑠̇ = 0, gives
  a𝑠Bias_AP = Ĵ𝑠_v_AP ⋅ 𝑠                               is quadratic in s.
</pre><p> Note: Since Ĵ𝑠_v_AP (the time-derivative of J𝑠_v_AP in frame A) is linear in s, a𝑠Bias_AP = Ĵ𝑠_v_AP ⋅ 𝑠 is quadratic in 𝑠.</p>
<p>Similarly, A𝑠Bias_AB denotes a frame B's bias spatial acceleration with respect to speeds 𝑠 measured in frame A. It can be written in terms of the time-derivative of J𝑠_V_AB (B's spatial velocity Jacobian in frame A for speeds 𝑠) as </p><pre>
  A𝑠Bias_AB = Ĵ𝑠_V_AB ⋅ 𝑠                       is quadratic in s. </pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="#a206be3cb8c5909f50bcc671b7bedaa13" title="For one point Bp fixed/welded to a frame B, calculates J𝑠_V_ABp, Bp&#39;s spatial velocity Jacobian in fr...">CalcJacobianSpatialVelocity()</a> for details on J𝑠_V_AB. </dd></dl>
</div></td></tr>
<tr class="memitem:a0796a9a23609cf73cd050e3f9fa6bae2" id="r_a0796a9a23609cf73cd050e3f9fa6bae2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0796a9a23609cf73cd050e3f9fa6bae2">CalcBiasTerm</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; Cv) const</td></tr>
<tr class="memdesc:a0796a9a23609cf73cd050e3f9fa6bae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bias term <span class="tt">C(q, v) v</span> containing Coriolis, centripetal, and gyroscopic effects in the multibody equations of motion:  <br /></td></tr>
<tr class="memitem:af30522c1a4bfd5a9091d6ab97f19e313" id="r_af30522c1a4bfd5a9091d6ab97f19e313"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af30522c1a4bfd5a9091d6ab97f19e313">CalcBiasTranslationalAcceleration</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a> with_respect_to, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt; T &gt; &gt; &amp;p_BoBi_B, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E) const</td></tr>
<tr class="memdesc:af30522c1a4bfd5a9091d6ab97f19e313"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each point Bi affixed/welded to a frame B, calculates a𝑠Bias_ABi, Bi's translational acceleration bias in frame A with respect to "speeds" 𝑠, expressed in frame E, where speeds 𝑠 is either q̇ or v.  <br /></td></tr>
<tr class="memitem:aaebf41e8c10ab8ea498ce8057ffbdbe2" id="r_aaebf41e8c10ab8ea498ce8057ffbdbe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaebf41e8c10ab8ea498ce8057ffbdbe2">CalcBiasSpatialAcceleration</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a> with_respect_to, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &gt; &amp;p_BoBp_B, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E) const</td></tr>
<tr class="memdesc:aaebf41e8c10ab8ea498ce8057ffbdbe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">For one point Bp affixed/welded to a frame B, calculates A𝑠Bias_ABp, Bp's spatial acceleration bias in frame A with respect to "speeds" 𝑠, expressed in frame E, where speeds 𝑠 is either q̇ or v.  <br /></td></tr>
<tr class="memitem:aca44cee51105bbec8d96bf6ecba05956" id="r_aca44cee51105bbec8d96bf6ecba05956"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca44cee51105bbec8d96bf6ecba05956">CalcBiasCenterOfMassTranslationalAcceleration</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a> with_respect_to, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E) const</td></tr>
<tr class="memdesc:aca44cee51105bbec8d96bf6ecba05956"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the system S of all bodies other than the world body, calculates a𝑠Bias_AScm_E, Scm's translational acceleration bias in frame A with respect to "speeds" 𝑠, expressed in frame E, where Scm is the center of mass of S and speeds 𝑠 is either q̇ or v.  <br /></td></tr>
<tr class="memitem:ad8f95be2e7dd654644d866bc1bd47026" id="r_ad8f95be2e7dd654644d866bc1bd47026"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8f95be2e7dd654644d866bc1bd47026">CalcBiasCenterOfMassTranslationalAcceleration</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; &amp;model_instances, <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a> with_respect_to, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E) const</td></tr>
<tr class="memdesc:ad8f95be2e7dd654644d866bc1bd47026"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the system S containing the selected model instances, calculates a𝑠Bias_AScm_E, Scm's translational acceleration bias in frame A with respect to "speeds" 𝑠, expressed in frame E, where Scm is the center of mass of S and speeds 𝑠 is either q̇ or v.  <br /></td></tr>
<tr id="pub-methods-11" class="groupHeader"><td colspan="2"><div class="groupHeader">Introspection</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="mbp_introspection"></a> These methods allow a user to query whether a given multibody element is part of this plant's model.</p>
<p>These queries can be performed at any time during the lifetime of a MultibodyPlant model, i.e. there is no restriction on whether they must be called before or after <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. These queries can be performed while new multibody elements are being added to the model. These methods allow a user to retrieve a reference to a multibody element by its name. An exception is thrown if there is no element with the requested name.</p>
<p>If the named element is present in more than one model instance and a model instance is not explicitly specified, std::logic_error is thrown. </p>
</div></td></tr>
<tr class="memitem:a8daceb7a3c384d6ad9f305e42b5fc1c6" id="r_a8daceb7a3c384d6ad9f305e42b5fc1c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8daceb7a3c384d6ad9f305e42b5fc1c6">time_step</a> () const</td></tr>
<tr class="memdesc:a8daceb7a3c384d6ad9f305e42b5fc1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time step (or period) used to model <span class="tt">this</span> plant as a discrete system with periodic updates.  <br /></td></tr>
<tr class="memitem:acf7bb2a3531c09a97fb3623ac582d840" id="r_acf7bb2a3531c09a97fb3623ac582d840"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf7bb2a3531c09a97fb3623ac582d840">is_finalized</a> () const</td></tr>
<tr class="memdesc:acf7bb2a3531c09a97fb3623ac582d840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if this MultibodyPlant was finalized with a call to <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>.  <br /></td></tr>
<tr class="memitem:ad6b97bb53425156402e7f46d72859e1e" id="r_ad6b97bb53425156402e7f46d72859e1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6b97bb53425156402e7f46d72859e1e">has_sampled_output_ports</a> () const</td></tr>
<tr class="memdesc:ad6b97bb53425156402e7f46d72859e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) If <span class="tt">this</span> plant is continuous (i.e., is_discrete() is <span class="tt">false</span>), returns false.  <br /></td></tr>
<tr class="memitem:a787a58094e9902e11d3359b54d20eed4" id="r_a787a58094e9902e11d3359b54d20eed4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a787a58094e9902e11d3359b54d20eed4">world_body</a> () const</td></tr>
<tr class="memdesc:a787a58094e9902e11d3359b54d20eed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the <em>world</em> body.  <br /></td></tr>
<tr class="memitem:ad65885e8d50cbd5462360af46bbc10fc" id="r_ad65885e8d50cbd5462360af46bbc10fc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html">RigidBodyFrame</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad65885e8d50cbd5462360af46bbc10fc">world_frame</a> () const</td></tr>
<tr class="memdesc:ad65885e8d50cbd5462360af46bbc10fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the <em>world</em> frame.  <br /></td></tr>
<tr class="memitem:af92b53211e54243aff4490a700168eb4" id="r_af92b53211e54243aff4490a700168eb4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af92b53211e54243aff4490a700168eb4">num_bodies</a> () const</td></tr>
<tr class="memdesc:af92b53211e54243aff4490a700168eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a> elements in the model, including the "world" <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a>, which is always part of the model.  <br /></td></tr>
<tr class="memitem:a8414166617acf540e58c360f9cc9714f" id="r_a8414166617acf540e58c360f9cc9714f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8414166617acf540e58c360f9cc9714f">has_body</a> (<a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">BodyIndex</a> body_index) const</td></tr>
<tr class="memdesc:a8414166617acf540e58c360f9cc9714f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if plant has a rigid body with unique index <span class="tt">body_index</span>.  <br /></td></tr>
<tr class="memitem:a2392f1b869287db1ea1a39183a4d23bf" id="r_a2392f1b869287db1ea1a39183a4d23bf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2392f1b869287db1ea1a39183a4d23bf">get_body</a> (<a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">BodyIndex</a> body_index) const</td></tr>
<tr class="memdesc:a2392f1b869287db1ea1a39183a4d23bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the body with unique index <span class="tt">body_index</span>.  <br /></td></tr>
<tr class="memitem:a9a609a2709f986c17f80438eac93e829" id="r_a9a609a2709f986c17f80438eac93e829"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a609a2709f986c17f80438eac93e829">IsAnchored</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body) const</td></tr>
<tr class="memdesc:a9a609a2709f986c17f80438eac93e829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if <code class="param">body</code> is anchored (i.e.  <br /></td></tr>
<tr class="memitem:a5aa037adf3002834caa1aedd305fa36d" id="r_a5aa037adf3002834caa1aedd305fa36d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5aa037adf3002834caa1aedd305fa36d">HasBodyNamed</a> (std::string_view name) const</td></tr>
<tr class="memitem:abaf942dfd740bf10fda323de2710b211" id="r_abaf942dfd740bf10fda323de2710b211"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abaf942dfd740bf10fda323de2710b211">NumBodiesWithName</a> (std::string_view name) const</td></tr>
<tr class="memitem:ae6d3aab3bdad70348d9201bb855bcde7" id="r_ae6d3aab3bdad70348d9201bb855bcde7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6d3aab3bdad70348d9201bb855bcde7">HasBodyNamed</a> (std::string_view name, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memitem:abb6e264c4c8e38a30a9e3965209d3dea" id="r_abb6e264c4c8e38a30a9e3965209d3dea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb6e264c4c8e38a30a9e3965209d3dea">GetBodyByName</a> (std::string_view name) const</td></tr>
<tr class="memdesc:abb6e264c4c8e38a30a9e3965209d3dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to a body that is identified by the string <span class="tt">name</span> in <span class="tt">this</span> MultibodyPlant.  <br /></td></tr>
<tr class="memitem:a3493d2245659015fc2ce6b713ef9d21c" id="r_a3493d2245659015fc2ce6b713ef9d21c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3493d2245659015fc2ce6b713ef9d21c">GetBodyByName</a> (std::string_view name, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a3493d2245659015fc2ce6b713ef9d21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the body that is uniquely identified by the string <span class="tt">name</span> and <code class="param">model_instance</code> in <span class="tt">this</span> MultibodyPlant.  <br /></td></tr>
<tr class="memitem:a03a6543ccf56f3fd4c8b0aa2420648e6" id="r_a03a6543ccf56f3fd4c8b0aa2420648e6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">BodyIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03a6543ccf56f3fd4c8b0aa2420648e6">GetBodyIndices</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a03a6543ccf56f3fd4c8b0aa2420648e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of body indices associated with <span class="tt">model_instance</span>.  <br /></td></tr>
<tr class="memitem:ad46fb49fc69d22b8a08d4dedc574ee1e" id="r_ad46fb49fc69d22b8a08d4dedc574ee1e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad46fb49fc69d22b8a08d4dedc574ee1e">GetRigidBodyByName</a> (std::string_view name) const</td></tr>
<tr class="memdesc:ad46fb49fc69d22b8a08d4dedc574ee1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to a rigid body that is identified by the string <span class="tt">name</span> in <span class="tt">this</span> model.  <br /></td></tr>
<tr class="memitem:a64e0914d716083743514bf46460ca5c1" id="r_a64e0914d716083743514bf46460ca5c1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64e0914d716083743514bf46460ca5c1">GetRigidBodyByName</a> (std::string_view name, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a64e0914d716083743514bf46460ca5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the rigid body that is uniquely identified by the string <span class="tt">name</span> in <code class="param">model_instance</code>.  <br /></td></tr>
<tr class="memitem:a28590d2acb4d289a18569894ef3b764f" id="r_a28590d2acb4d289a18569894ef3b764f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28590d2acb4d289a18569894ef3b764f">GetBodiesWeldedTo</a> (const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;body) const</td></tr>
<tr class="memdesc:a28590d2acb4d289a18569894ef3b764f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all bodies that are transitively welded, or rigidly affixed, to <span class="tt">body</span>, per these two definitions:  <br /></td></tr>
<tr class="memitem:a137b408b19244d236d315e5b95dbcac9" id="r_a137b408b19244d236d315e5b95dbcac9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">BodyIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a137b408b19244d236d315e5b95dbcac9">GetBodiesKinematicallyAffectedBy</a> (const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt; &amp;joint_indexes) const</td></tr>
<tr class="memdesc:a137b408b19244d236d315e5b95dbcac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all bodies whose kinematics are transitively affected by the given vector of Joints.  <br /></td></tr>
<tr class="memitem:a636804b6c40e538d83d5c2dfefb7929e" id="r_a636804b6c40e538d83d5c2dfefb7929e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a636804b6c40e538d83d5c2dfefb7929e">num_joints</a> () const</td></tr>
<tr class="memdesc:a636804b6c40e538d83d5c2dfefb7929e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of joints in the model.  <br /></td></tr>
<tr class="memitem:aee8d8c1e520c405dc36cbffccbfe2ad8" id="r_aee8d8c1e520c405dc36cbffccbfe2ad8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee8d8c1e520c405dc36cbffccbfe2ad8">has_joint</a> (<a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> joint_index) const</td></tr>
<tr class="memdesc:aee8d8c1e520c405dc36cbffccbfe2ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if plant has a joint with unique index <span class="tt">joint_index</span>.  <br /></td></tr>
<tr class="memitem:aa5c1504637f1b0c7e455cf5b8b1496d5" id="r_aa5c1504637f1b0c7e455cf5b8b1496d5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5c1504637f1b0c7e455cf5b8b1496d5">get_joint</a> (<a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> joint_index) const</td></tr>
<tr class="memdesc:aa5c1504637f1b0c7e455cf5b8b1496d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the joint with unique index <span class="tt">joint_index</span>.  <br /></td></tr>
<tr class="memitem:af5cc2bf03e1b34a63539f8e104425729" id="r_af5cc2bf03e1b34a63539f8e104425729"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5cc2bf03e1b34a63539f8e104425729">HasJointNamed</a> (std::string_view name) const</td></tr>
<tr class="memitem:add62ae8b7ca0c50c87fc93abbf8fd843" id="r_add62ae8b7ca0c50c87fc93abbf8fd843"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add62ae8b7ca0c50c87fc93abbf8fd843">HasJointNamed</a> (std::string_view name, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memitem:a250ff3cf2db7d0c5ef48c94d1a18c332" id="r_a250ff3cf2db7d0c5ef48c94d1a18c332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a250ff3cf2db7d0c5ef48c94d1a18c332">get_mutable_joint</a> (<a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> joint_index)</td></tr>
<tr class="memdesc:a250ff3cf2db7d0c5ef48c94d1a18c332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable reference to the joint with unique index <span class="tt">joint_index</span>.  <br /></td></tr>
<tr class="memitem:acf9168de86a03b26abf216dd93de6a80" id="r_acf9168de86a03b26abf216dd93de6a80"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf9168de86a03b26abf216dd93de6a80">GetJointIndices</a> () const</td></tr>
<tr class="memdesc:acf9168de86a03b26abf216dd93de6a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all joint indices.  <br /></td></tr>
<tr class="memitem:a3321b82d96b679209efb4aec0974d9bc" id="r_a3321b82d96b679209efb4aec0974d9bc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3321b82d96b679209efb4aec0974d9bc">GetJointIndices</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a3321b82d96b679209efb4aec0974d9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of joint indices associated with <span class="tt">model_instance</span>.  <br /></td></tr>
<tr class="memitem:a14c63996575e6bf19290129d32d079cc" id="r_a14c63996575e6bf19290129d32d079cc"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14c63996575e6bf19290129d32d079cc">GetJointActuatorIndices</a> () const</td></tr>
<tr class="memdesc:a14c63996575e6bf19290129d32d079cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all joint actuator indices.  <br /></td></tr>
<tr class="memitem:a03f7c6810cf38ce83a6046e3243f3e28" id="r_a03f7c6810cf38ce83a6046e3243f3e28"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03f7c6810cf38ce83a6046e3243f3e28">GetJointActuatorIndices</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a03f7c6810cf38ce83a6046e3243f3e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of joint actuator indices associated with <span class="tt">model_instance</span>.  <br /></td></tr>
<tr class="memitem:a9f04d3a518de759ddd20257be50073cc" id="r_a9f04d3a518de759ddd20257be50073cc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f04d3a518de759ddd20257be50073cc">GetActuatedJointIndices</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a9f04d3a518de759ddd20257be50073cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of actuated joint indices associated with <span class="tt">model_instance</span>.  <br /></td></tr>
<tr class="memitem:a65a8bf98a3d37404d4a9de8d59e1ca70" id="r_a65a8bf98a3d37404d4a9de8d59e1ca70"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class JointType = Joint&gt; </td></tr>
<tr class="memitem:a65a8bf98a3d37404d4a9de8d59e1ca70 template"><td class="memItemLeft" align="right" valign="top">const JointType&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65a8bf98a3d37404d4a9de8d59e1ca70">GetJointByName</a> (std::string_view name, std::optional&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; model_instance=std::nullopt) const</td></tr>
<tr class="memdesc:a65a8bf98a3d37404d4a9de8d59e1ca70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to a joint that is identified by the string <span class="tt">name</span> in <span class="tt">this</span> MultibodyPlant.  <br /></td></tr>
<tr class="memitem:a7dcf66ff2d8900efa1d376d753238e7c" id="r_a7dcf66ff2d8900efa1d376d753238e7c"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class JointType = Joint&gt; </td></tr>
<tr class="memitem:a7dcf66ff2d8900efa1d376d753238e7c template"><td class="memItemLeft" align="right" valign="top">JointType&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7dcf66ff2d8900efa1d376d753238e7c">GetMutableJointByName</a> (std::string_view name, std::optional&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; model_instance=std::nullopt)</td></tr>
<tr class="memdesc:a7dcf66ff2d8900efa1d376d753238e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version of GetJointByName that returns a mutable reference.  <br /></td></tr>
<tr class="memitem:ada7f02e861a8f89fc0b575b2f30333d3" id="r_ada7f02e861a8f89fc0b575b2f30333d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada7f02e861a8f89fc0b575b2f30333d3">num_frames</a> () const</td></tr>
<tr class="memdesc:ada7f02e861a8f89fc0b575b2f30333d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame) of its underl...">Frame</a> objects in this model.  <br /></td></tr>
<tr class="memitem:a780fb008e04ccdc170e84938156d0018" id="r_a780fb008e04ccdc170e84938156d0018"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a780fb008e04ccdc170e84938156d0018">get_frame</a> (<a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a> frame_index) const</td></tr>
<tr class="memdesc:a780fb008e04ccdc170e84938156d0018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the frame with unique index <span class="tt">frame_index</span>.  <br /></td></tr>
<tr class="memitem:a8f099f6f98dbec124151d83b25fe2edc" id="r_a8f099f6f98dbec124151d83b25fe2edc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f099f6f98dbec124151d83b25fe2edc">HasFrameNamed</a> (std::string_view name) const</td></tr>
<tr class="memitem:a26990e5cf2851439bbfb5c89e18362e3" id="r_a26990e5cf2851439bbfb5c89e18362e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26990e5cf2851439bbfb5c89e18362e3">HasFrameNamed</a> (std::string_view name, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memitem:a214b22ac2258ec73e6eeb2a07011a7f1" id="r_a214b22ac2258ec73e6eeb2a07011a7f1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a214b22ac2258ec73e6eeb2a07011a7f1">GetFrameByName</a> (std::string_view name) const</td></tr>
<tr class="memdesc:a214b22ac2258ec73e6eeb2a07011a7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to a frame that is identified by the string <span class="tt">name</span> in <span class="tt">this</span> model.  <br /></td></tr>
<tr class="memitem:af2b58a281bbc2d62b94b569bba2388c6" id="r_af2b58a281bbc2d62b94b569bba2388c6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2b58a281bbc2d62b94b569bba2388c6">GetFrameByName</a> (std::string_view name, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:af2b58a281bbc2d62b94b569bba2388c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the frame that is uniquely identified by the string <span class="tt">name</span> in <code class="param">model_instance</code>.  <br /></td></tr>
<tr class="memitem:a9dc72553d42ef7bbadddb2822a883746" id="r_a9dc72553d42ef7bbadddb2822a883746"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9dc72553d42ef7bbadddb2822a883746">GetFrameIndices</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a9dc72553d42ef7bbadddb2822a883746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of frame indices associated with <span class="tt">model_instance</span>.  <br /></td></tr>
<tr class="memitem:a8601c026e9807127b4dd41e7585d2cfc" id="r_a8601c026e9807127b4dd41e7585d2cfc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8601c026e9807127b4dd41e7585d2cfc">num_actuators</a> () const</td></tr>
<tr class="memdesc:a8601c026e9807127b4dd41e7585d2cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of joint actuators in the model.  <br /></td></tr>
<tr class="memitem:a2ced71a0d382b846bf68813aa3ab93d6" id="r_a2ced71a0d382b846bf68813aa3ab93d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ced71a0d382b846bf68813aa3ab93d6">num_actuators</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a2ced71a0d382b846bf68813aa3ab93d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of actuators for a specific model instance.  <br /></td></tr>
<tr class="memitem:ae3fc8de8de8eaf2d37a24c79d6be8e97" id="r_ae3fc8de8de8eaf2d37a24c79d6be8e97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3fc8de8de8eaf2d37a24c79d6be8e97">num_actuated_dofs</a> () const</td></tr>
<tr class="memdesc:ae3fc8de8de8eaf2d37a24c79d6be8e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of actuated degrees of freedom.  <br /></td></tr>
<tr class="memitem:a279e31367e76849d4a45fd7db0f116f1" id="r_a279e31367e76849d4a45fd7db0f116f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a279e31367e76849d4a45fd7db0f116f1">num_actuated_dofs</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a279e31367e76849d4a45fd7db0f116f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of actuated degrees of freedom for a specific model instance.  <br /></td></tr>
<tr class="memitem:a3fc00564be4a547c6ba3d476ab128d2c" id="r_a3fc00564be4a547c6ba3d476ab128d2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fc00564be4a547c6ba3d476ab128d2c">has_joint_actuator</a> (<a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> actuator_index) const</td></tr>
<tr class="memdesc:a3fc00564be4a547c6ba3d476ab128d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if plant has a joint actuator with unique index <span class="tt">actuator_index</span>.  <br /></td></tr>
<tr class="memitem:a4740af508f2c9ccdb5940698822613ba" id="r_a4740af508f2c9ccdb5940698822613ba"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4740af508f2c9ccdb5940698822613ba">get_joint_actuator</a> (<a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> actuator_index) const</td></tr>
<tr class="memdesc:a4740af508f2c9ccdb5940698822613ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the joint actuator with unique index <span class="tt">actuator_index</span>.  <br /></td></tr>
<tr class="memitem:a000f3c038ab3e66c16f2078dde9f9cee" id="r_a000f3c038ab3e66c16f2078dde9f9cee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a000f3c038ab3e66c16f2078dde9f9cee">get_mutable_joint_actuator</a> (<a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> actuator_index)</td></tr>
<tr class="memdesc:a000f3c038ab3e66c16f2078dde9f9cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable reference to the joint actuator with unique index <span class="tt">actuator_index</span>.  <br /></td></tr>
<tr class="memitem:a7bfcc73831e073c659a3c6503e0e1e6a" id="r_a7bfcc73831e073c659a3c6503e0e1e6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bfcc73831e073c659a3c6503e0e1e6a">HasJointActuatorNamed</a> (std::string_view name) const</td></tr>
<tr class="memitem:af1f7756f142c8453aca4b70542b90d00" id="r_af1f7756f142c8453aca4b70542b90d00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1f7756f142c8453aca4b70542b90d00">HasJointActuatorNamed</a> (std::string_view name, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memitem:a2a652be40ec0f98f6489931fb9162098" id="r_a2a652be40ec0f98f6489931fb9162098"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a652be40ec0f98f6489931fb9162098">GetJointActuatorByName</a> (std::string_view name) const</td></tr>
<tr class="memdesc:a2a652be40ec0f98f6489931fb9162098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to an actuator that is identified by the string <span class="tt">name</span> in <span class="tt">this</span> MultibodyPlant.  <br /></td></tr>
<tr class="memitem:ad24b3a18e439aaf29ccfec8fc2917c96" id="r_ad24b3a18e439aaf29ccfec8fc2917c96"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad24b3a18e439aaf29ccfec8fc2917c96">GetJointActuatorByName</a> (std::string_view name, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:ad24b3a18e439aaf29ccfec8fc2917c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the actuator that is uniquely identified by the string <span class="tt">name</span> and <code class="param">model_instance</code> in <span class="tt">this</span> MultibodyPlant.  <br /></td></tr>
<tr class="memitem:a6b7f0267d163693025fa04f78bb18333" id="r_a6b7f0267d163693025fa04f78bb18333"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b7f0267d163693025fa04f78bb18333">num_force_elements</a> () const</td></tr>
<tr class="memdesc:a6b7f0267d163693025fa04f78bb18333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> objects.  <br /></td></tr>
<tr class="memitem:a1d93303f2e3893f893c3d77cf5df5e49" id="r_a1d93303f2e3893f893c3d77cf5df5e49"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_force_element.html">ForceElement</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d93303f2e3893f893c3d77cf5df5e49">get_force_element</a> (<a class="el" href="namespacedrake_1_1multibody.html#add80e949328b179d78312d1455319868">ForceElementIndex</a> force_element_index) const</td></tr>
<tr class="memdesc:a1d93303f2e3893f893c3d77cf5df5e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the force element with unique index <span class="tt">force_element_index</span>.  <br /></td></tr>
<tr class="memitem:a172026ba093a622e831746fc2a18b713" id="r_a172026ba093a622e831746fc2a18b713"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class ForceElementType = ForceElement&gt; </td></tr>
<tr class="memitem:a172026ba093a622e831746fc2a18b713 template"><td class="memItemLeft" align="right" valign="top">const ForceElementType&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a172026ba093a622e831746fc2a18b713">GetForceElement</a> (<a class="el" href="namespacedrake_1_1multibody.html#add80e949328b179d78312d1455319868">ForceElementIndex</a> force_element_index) const</td></tr>
<tr class="memdesc:a172026ba093a622e831746fc2a18b713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to a force element identified by its unique index in <span class="tt">this</span> MultibodyPlant.  <br /></td></tr>
<tr class="memitem:a5e8ecddaf1d1c2b4389e028d7b1b66e8" id="r_a5e8ecddaf1d1c2b4389e028d7b1b66e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e8ecddaf1d1c2b4389e028d7b1b66e8">is_gravity_enabled</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memitem:aef9f4c4f6df3cdd1f69b014a6fb0b333" id="r_aef9f4c4f6df3cdd1f69b014a6fb0b333"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef9f4c4f6df3cdd1f69b014a6fb0b333">set_gravity_enabled</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, bool is_enabled)</td></tr>
<tr class="memdesc:aef9f4c4f6df3cdd1f69b014a6fb0b333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="#a5e8ecddaf1d1c2b4389e028d7b1b66e8">is_gravity_enabled()</a> for <span class="tt">model_instance</span> to <span class="tt">is_enabled</span>.  <br /></td></tr>
<tr class="memitem:a0fbda7f9bfa1e15586be2c35abafd03a" id="r_a0fbda7f9bfa1e15586be2c35abafd03a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_uniform_gravity_field_element.html">UniformGravityFieldElement</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fbda7f9bfa1e15586be2c35abafd03a">gravity_field</a> () const</td></tr>
<tr class="memdesc:a0fbda7f9bfa1e15586be2c35abafd03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An accessor to the current gravity field.  <br /></td></tr>
<tr class="memitem:a3218db3534d3bfccc59eb387d04fc884" id="r_a3218db3534d3bfccc59eb387d04fc884"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_uniform_gravity_field_element.html">UniformGravityFieldElement</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3218db3534d3bfccc59eb387d04fc884">mutable_gravity_field</a> ()</td></tr>
<tr class="memdesc:a3218db3534d3bfccc59eb387d04fc884"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable accessor to the current gravity field.  <br /></td></tr>
<tr class="memitem:ac89140adb93cb9e507f71c30eb783198" id="r_ac89140adb93cb9e507f71c30eb783198"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac89140adb93cb9e507f71c30eb783198">num_model_instances</a> () const</td></tr>
<tr class="memdesc:ac89140adb93cb9e507f71c30eb783198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of model instances in the model.  <br /></td></tr>
<tr class="memitem:a6967a3b13b5d006821d7590945a0c168" id="r_a6967a3b13b5d006821d7590945a0c168"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6967a3b13b5d006821d7590945a0c168">GetModelInstanceName</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a6967a3b13b5d006821d7590945a0c168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of a <span class="tt">model_instance</span>.  <br /></td></tr>
<tr class="memitem:ae12f32b40b7a41c3aa933ed74b2417fb" id="r_ae12f32b40b7a41c3aa933ed74b2417fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae12f32b40b7a41c3aa933ed74b2417fb">HasModelInstanceNamed</a> (std::string_view name) const</td></tr>
<tr class="memitem:ae6d03c873e08ade99e59d68af8375355" id="r_ae6d03c873e08ade99e59d68af8375355"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6d03c873e08ade99e59d68af8375355">GetModelInstanceByName</a> (std::string_view name) const</td></tr>
<tr class="memdesc:ae6d03c873e08ade99e59d68af8375355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index to the model instance that is uniquely identified by the string <span class="tt">name</span> in <span class="tt">this</span> MultibodyPlant.  <br /></td></tr>
<tr class="memitem:a113f30d2b1b3a8151b638300231975fa" id="r_a113f30d2b1b3a8151b638300231975fa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a113f30d2b1b3a8151b638300231975fa">GetTopologyGraphvizString</a> () const</td></tr>
<tr class="memdesc:a113f30d2b1b3a8151b638300231975fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Graphviz string describing the topology of this plant.  <br /></td></tr>
<tr class="memitem:aba2887f0ca1fbbdfb49cf6b0ee21e553" id="r_aba2887f0ca1fbbdfb49cf6b0ee21e553"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553">num_positions</a> () const</td></tr>
<tr class="memdesc:aba2887f0ca1fbbdfb49cf6b0ee21e553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the generalized position vector q for this model.  <br /></td></tr>
<tr class="memitem:ab669e070e6178c4aeeb067a1f4b6122e" id="r_ab669e070e6178c4aeeb067a1f4b6122e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab669e070e6178c4aeeb067a1f4b6122e">num_positions</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:ab669e070e6178c4aeeb067a1f4b6122e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the generalized position vector qᵢ for model instance i.  <br /></td></tr>
<tr class="memitem:ae0163ac0976659d811e3337647ff0313" id="r_ae0163ac0976659d811e3337647ff0313"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0163ac0976659d811e3337647ff0313">num_velocities</a> () const</td></tr>
<tr class="memdesc:ae0163ac0976659d811e3337647ff0313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the generalized velocity vector v for this model.  <br /></td></tr>
<tr class="memitem:a0a686a8389beffdc5fb8a7690967e741" id="r_a0a686a8389beffdc5fb8a7690967e741"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a686a8389beffdc5fb8a7690967e741">num_velocities</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a0a686a8389beffdc5fb8a7690967e741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the generalized velocity vector vᵢ for model instance i.  <br /></td></tr>
<tr class="memitem:ac80c61762d32b97a34f02a0374fc6fe3" id="r_ac80c61762d32b97a34f02a0374fc6fe3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac80c61762d32b97a34f02a0374fc6fe3">num_multibody_states</a> () const</td></tr>
<tr class="memdesc:ac80c61762d32b97a34f02a0374fc6fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the multibody system state vector x = [q v].  <br /></td></tr>
<tr class="memitem:a07d0d29cbbe6e1de7cbaf90fefc5e652" id="r_a07d0d29cbbe6e1de7cbaf90fefc5e652"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07d0d29cbbe6e1de7cbaf90fefc5e652">num_multibody_states</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a07d0d29cbbe6e1de7cbaf90fefc5e652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the multibody system state vector xᵢ = [qᵢ vᵢ] for model instance i.  <br /></td></tr>
<tr class="memitem:a00df1769efd86a386234debfca2acc2e" id="r_a00df1769efd86a386234debfca2acc2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00df1769efd86a386234debfca2acc2e">GetPositionLowerLimits</a> () const</td></tr>
<tr class="memdesc:a00df1769efd86a386234debfca2acc2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of size <span class="tt"><a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">num_positions()</a></span> containing the lower position limits for every generalized position coordinate.  <br /></td></tr>
<tr class="memitem:a496aaac0e459e3762b0694fb41e7bab6" id="r_a496aaac0e459e3762b0694fb41e7bab6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a496aaac0e459e3762b0694fb41e7bab6">GetPositionUpperLimits</a> () const</td></tr>
<tr class="memdesc:a496aaac0e459e3762b0694fb41e7bab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upper limit analog of <a class="el" href="#a00df1769efd86a386234debfca2acc2e" title="Returns a vector of size num_positions() containing the lower position limits for every generalized p...">GetPositionLowerLimits()</a>, where any unbounded or unspecified limits will be +infinity.  <br /></td></tr>
<tr class="memitem:a83365196f5b81dbb51d3e09827e4d71b" id="r_a83365196f5b81dbb51d3e09827e4d71b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83365196f5b81dbb51d3e09827e4d71b">GetVelocityLowerLimits</a> () const</td></tr>
<tr class="memdesc:a83365196f5b81dbb51d3e09827e4d71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of size <span class="tt"><a class="el" href="#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a></span> containing the lower velocity limits for every generalized velocity coordinate.  <br /></td></tr>
<tr class="memitem:a5ba581177b15efe8e7a26c4709a77752" id="r_a5ba581177b15efe8e7a26c4709a77752"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ba581177b15efe8e7a26c4709a77752">GetVelocityUpperLimits</a> () const</td></tr>
<tr class="memdesc:a5ba581177b15efe8e7a26c4709a77752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upper limit analog of GetVelocitysLowerLimits(), where any unbounded or unspecified limits will be +infinity.  <br /></td></tr>
<tr class="memitem:a8161e656bfc1653349b90539553a1ba4" id="r_a8161e656bfc1653349b90539553a1ba4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8161e656bfc1653349b90539553a1ba4">GetAccelerationLowerLimits</a> () const</td></tr>
<tr class="memdesc:a8161e656bfc1653349b90539553a1ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of size <span class="tt"><a class="el" href="#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a></span> containing the lower acceleration limits for every generalized velocity coordinate.  <br /></td></tr>
<tr class="memitem:a45b1fa10c461a184984c241fd91cc28e" id="r_a45b1fa10c461a184984c241fd91cc28e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45b1fa10c461a184984c241fd91cc28e">GetAccelerationUpperLimits</a> () const</td></tr>
<tr class="memdesc:a45b1fa10c461a184984c241fd91cc28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upper limit analog of GetAccelerationsLowerLimits(), where any unbounded or unspecified limits will be +infinity.  <br /></td></tr>
<tr class="memitem:acabcf82b7950bc33f824a9209ec76841" id="r_acabcf82b7950bc33f824a9209ec76841"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acabcf82b7950bc33f824a9209ec76841">GetEffortLowerLimits</a> () const</td></tr>
<tr class="memdesc:acabcf82b7950bc33f824a9209ec76841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of size <span class="tt"><a class="el" href="#ae3fc8de8de8eaf2d37a24c79d6be8e97" title="Returns the total number of actuated degrees of freedom.">num_actuated_dofs()</a></span> containing the lower effort limits for every actuator.  <br /></td></tr>
<tr class="memitem:a8344811188893c52deeb10e478b4f8f1" id="r_a8344811188893c52deeb10e478b4f8f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8344811188893c52deeb10e478b4f8f1">GetEffortUpperLimits</a> () const</td></tr>
<tr class="memdesc:a8344811188893c52deeb10e478b4f8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of size <span class="tt"><a class="el" href="#ae3fc8de8de8eaf2d37a24c79d6be8e97" title="Returns the total number of actuated degrees of freedom.">num_actuated_dofs()</a></span> containing the upper effort limits for every actuator.  <br /></td></tr>
<tr class="memitem:a94d1093944c929bd5ca5322836b91bd4" id="r_a94d1093944c929bd5ca5322836b91bd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4e">ContactModel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94d1093944c929bd5ca5322836b91bd4">get_contact_model</a> () const</td></tr>
<tr class="memdesc:a94d1093944c929bd5ca5322836b91bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the model used for contact. See documentation for <a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4e" title="Enumeration for contact model options.">ContactModel</a>.  <br /></td></tr>
<tr class="memitem:aa7c0b698e0102d42f085ca39f337b019" id="r_aa7c0b698e0102d42f085ca39f337b019"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7c0b698e0102d42f085ca39f337b019">num_visual_geometries</a> () const</td></tr>
<tr class="memdesc:aa7c0b698e0102d42f085ca39f337b019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of geometries registered for visualization.  <br /></td></tr>
<tr class="memitem:ac1b107ecf3446e56cb203461440200c1" id="r_ac1b107ecf3446e56cb203461440200c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1b107ecf3446e56cb203461440200c1">num_collision_geometries</a> () const</td></tr>
<tr class="memdesc:ac1b107ecf3446e56cb203461440200c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of geometries registered for contact modeling.  <br /></td></tr>
<tr class="memitem:a6e219dfe1b9145c9c244a4195bc382a6" id="r_a6e219dfe1b9145c9c244a4195bc382a6"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="namespacedrake_1_1geometry.html#ac53cb597123131fb23a7af26e8d350bf">geometry::SourceId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e219dfe1b9145c9c244a4195bc382a6">get_source_id</a> () const</td></tr>
<tr class="memdesc:a6e219dfe1b9145c9c244a4195bc382a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unique id identifying <span class="tt">this</span> plant as a source for a SceneGraph.  <br /></td></tr>
<tr class="memitem:afad783d7e7e513feb7a73384c8080041" id="r_afad783d7e7e513feb7a73384c8080041"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afad783d7e7e513feb7a73384c8080041">geometry_source_is_registered</a> () const</td></tr>
<tr class="memdesc:afad783d7e7e513feb7a73384c8080041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if <span class="tt">this</span> MultibodyPlant was registered with a SceneGraph.  <br /></td></tr>
<tr class="memitem:a4b131944f330a62a756b00d401a14a72" id="r_a4b131944f330a62a756b00d401a14a72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b131944f330a62a756b00d401a14a72">GetMutableSceneGraphPreFinalize</a> ()</td></tr>
<tr class="memdesc:a4b131944f330a62a756b00d401a14a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns a mutable pointer to the SceneGraph that this plant is registered as a source for.  <br /></td></tr>
<tr class="memitem:a262bfea040b50f4e5db5cb8778161655" id="r_a262bfea040b50f4e5db5cb8778161655"><td class="memItemLeft" align="right" valign="top">const internal::LinkJointGraph &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a262bfea040b50f4e5db5cb8778161655">graph</a> () const</td></tr>
<tr class="memdesc:a262bfea040b50f4e5db5cb8778161655"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Provides access to the internal::LinkJointGraph.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-friends" class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a47a63154823dffd5838329527aafbd58" id="r_a47a63154823dffd5838329527aafbd58"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:a47a63154823dffd5838329527aafbd58 template"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47a63154823dffd5838329527aafbd58">MultibodyPlant</a></td></tr>
<tr class="memitem:a42efef893a4d8eed1d593caff328f599" id="r_a42efef893a4d8eed1d593caff328f599"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42efef893a4d8eed1d593caff328f599">MultibodyPlantTester</a></td></tr>
<tr class="memitem:a9bf56e6eda41a6cc82296377a2267479" id="r_a9bf56e6eda41a6cc82296377a2267479"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bf56e6eda41a6cc82296377a2267479">internal::MultibodyPlantDiscreteUpdateManagerAttorney&lt; T &gt;</a></td></tr>
<tr class="memitem:ae31c5abf29d1134fe77df48a1152980a" id="r_ae31c5abf29d1134fe77df48a1152980a"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae31c5abf29d1134fe77df48a1152980a">internal::MultibodyPlantIcfAttorney&lt; T &gt;</a></td></tr>
<tr class="memitem:a7266290642dbb492700e7ebae2e00a20" id="r_a7266290642dbb492700e7ebae2e00a20"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7266290642dbb492700e7ebae2e00a20">internal::MultibodyPlantModelAttorney&lt; T &gt;</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-related" class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:a8b71553122d35a449d2131789a3f94c2" id="r_a8b71553122d35a449d2131789a3f94c2"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a8b71553122d35a449d2131789a3f94c2 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1multibody_1_1_add_multibody_plant_scene_graph_result.html">AddMultibodyPlantSceneGraphResult</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b71553122d35a449d2131789a3f94c2">AddMultibodyPlantSceneGraph</a> (<a class="el" href="classdrake_1_1systems_1_1_diagram_builder.html">systems::DiagramBuilder</a>&lt; T &gt; *builder, <a class="el" href="classdouble.html">double</a> <a class="el" href="#a8daceb7a3c384d6ad9f305e42b5fc1c6">time_step</a>, std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt; &gt; scene_graph=nullptr)</td></tr>
<tr class="memdesc:a8b71553122d35a449d2131789a3f94c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a new <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> with discrete update period <span class="tt"><a class="el" href="#a8daceb7a3c384d6ad9f305e42b5fc1c6" title="The time step (or period) used to model this plant as a discrete system with periodic updates.">time_step</a></span> and adds it to a diagram builder together with the provided SceneGraph instance, connecting the geometry ports.  <br /></td></tr>
<tr class="memitem:abee1730bcdfcda3c985ab6e0c2b4e4b0" id="r_abee1730bcdfcda3c985ab6e0c2b4e4b0"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:abee1730bcdfcda3c985ab6e0c2b4e4b0 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1multibody_1_1_add_multibody_plant_scene_graph_result.html">AddMultibodyPlantSceneGraphResult</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abee1730bcdfcda3c985ab6e0c2b4e4b0">AddMultibodyPlantSceneGraph</a> (<a class="el" href="classdrake_1_1systems_1_1_diagram_builder.html">systems::DiagramBuilder</a>&lt; T &gt; *builder, std::unique_ptr&lt; <a class="el" href="#a47a63154823dffd5838329527aafbd58">MultibodyPlant</a>&lt; T &gt; &gt; plant, std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt; &gt; scene_graph=nullptr)</td></tr>
<tr class="memdesc:abee1730bcdfcda3c985ab6e0c2b4e4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> and a SceneGraph instance to a diagram builder, connecting the geometry ports.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Contact modeling</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="mbp_contact_modeling"></a> Use methods in this section to choose the contact model and to provide parameters for that model.</p>
<p>Currently Drake supports an advanced compliant model of continuous surface patches we call <em>Hydroelastic contact</em> and a compliant point contact model as a reliable fallback. Please refer to <a class="el" href="group__compliant__contact.html">Modeling Compliant Contact</a> for details. </p>
</td></tr>
<tr class="memitem:ad253ab790ff8e142080cedd210e982da" id="r_ad253ab790ff8e142080cedd210e982da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad253ab790ff8e142080cedd210e982da">set_contact_model</a> (<a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4e">ContactModel</a> model)</td></tr>
<tr class="memdesc:ad253ab790ff8e142080cedd210e982da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the contact model to be used by <span class="tt">this</span> MultibodyPlant, see <a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4e" title="Enumeration for contact model options.">ContactModel</a> for available options.  <br /></td></tr>
<tr class="memitem:ad7698366750a09e383106a17bf9009a2" id="r_ad7698366750a09e383106a17bf9009a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#a902306c5e0120a67c07f80e9219a3e8d">DiscreteContactSolver</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7698366750a09e383106a17bf9009a2">get_discrete_contact_solver</a> () const</td></tr>
<tr class="memdesc:ad7698366750a09e383106a17bf9009a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contact solver type used for discrete MultibodyPlant models.  <br /></td></tr>
<tr class="memitem:a9b3f429ca991bd1028f4f60d6d5f2e61" id="r_a9b3f429ca991bd1028f4f60d6d5f2e61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b3f429ca991bd1028f4f60d6d5f2e61">set_discrete_contact_approximation</a> (<a class="el" href="namespacedrake_1_1multibody.html#aa1d02176591187cb83e77e9ff779d679">DiscreteContactApproximation</a> approximation)</td></tr>
<tr class="memdesc:a9b3f429ca991bd1028f4f60d6d5f2e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the discrete contact model approximation.  <br /></td></tr>
<tr class="memitem:ad9ebfcbe324adb1d8cab32b40e4d53c4" id="r_ad9ebfcbe324adb1d8cab32b40e4d53c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#aa1d02176591187cb83e77e9ff779d679">DiscreteContactApproximation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9ebfcbe324adb1d8cab32b40e4d53c4">get_discrete_contact_approximation</a> () const</td></tr>
<tr class="memitem:a857ba74bdbf10e03cbaf8acbfa4b044b" id="r_a857ba74bdbf10e03cbaf8acbfa4b044b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a857ba74bdbf10e03cbaf8acbfa4b044b">set_sap_near_rigid_threshold</a> (<a class="el" href="classdouble.html">double</a> near_rigid_threshold=<a class="el" href="structdrake_1_1multibody_1_1_multibody_plant_config.html">MultibodyPlantConfig</a>{}.sap_near_rigid_threshold)</td></tr>
<tr class="memdesc:a857ba74bdbf10e03cbaf8acbfa4b044b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-negative dimensionless number typically in the range [0.0, 1.0], though larger values are allowed even if uncommon.  <br /></td></tr>
<tr class="memitem:aa17b98a3d4e8ab45709c6d462f458933" id="r_aa17b98a3d4e8ab45709c6d462f458933"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa17b98a3d4e8ab45709c6d462f458933">get_sap_near_rigid_threshold</a> () const</td></tr>
<tr class="memitem:ad6df8a26aa42b59344e931ac9d6f5357" id="r_ad6df8a26aa42b59344e931ac9d6f5357"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6df8a26aa42b59344e931ac9d6f5357">set_contact_surface_representation</a> (<a class="el" href="namespacedrake_1_1geometry.html#a227f80cb57c9c87f6ecc4e839e364979">geometry::HydroelasticContactRepresentation</a> representation)</td></tr>
<tr class="memdesc:ad6df8a26aa42b59344e931ac9d6f5357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the representation of contact surfaces to be used by <span class="tt">this</span> MultibodyPlant.  <br /></td></tr>
<tr class="memitem:a2b82332abfb08a94d367659c3f566e21" id="r_a2b82332abfb08a94d367659c3f566e21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1geometry.html#a227f80cb57c9c87f6ecc4e839e364979">geometry::HydroelasticContactRepresentation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b82332abfb08a94d367659c3f566e21">get_contact_surface_representation</a> () const</td></tr>
<tr class="memdesc:a2b82332abfb08a94d367659c3f566e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current representation of contact surfaces used by <span class="tt">this</span> MultibodyPlant.  <br /></td></tr>
<tr class="memitem:ada6a17fc10f55293cc507b583220f8d7" id="r_ada6a17fc10f55293cc507b583220f8d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada6a17fc10f55293cc507b583220f8d7">set_adjacent_bodies_collision_filters</a> (bool value)</td></tr>
<tr class="memdesc:ada6a17fc10f55293cc507b583220f8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether to apply collision filters to topologically adjacent bodies at <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> time.  <br /></td></tr>
<tr class="memitem:a14ad3e6c2aa8d6de728ee3552260f428" id="r_a14ad3e6c2aa8d6de728ee3552260f428"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14ad3e6c2aa8d6de728ee3552260f428">get_adjacent_bodies_collision_filters</a> () const</td></tr>
<tr class="memdesc:a14ad3e6c2aa8d6de728ee3552260f428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether to apply collision filters to topologically adjacent bodies at <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> time.  <br /></td></tr>
<tr class="memitem:a70ab37a42372902087db6fabe55118c7" id="r_a70ab37a42372902087db6fabe55118c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70ab37a42372902087db6fabe55118c7">SetDiscreteUpdateManager</a> (std::unique_ptr&lt; internal::DiscreteUpdateManager&lt; T &gt; &gt; manager)</td></tr>
<tr class="memdesc:a70ab37a42372902087db6fabe55118c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use only by advanced developers wanting to try out their custom time stepping strategies, including contact resolution.  <br /></td></tr>
<tr class="memitem:a2e04d949f2b755579ea4af5adc195546" id="r_a2e04d949f2b755579ea4af5adc195546"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_deformable_model.html">DeformableModel</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e04d949f2b755579ea4af5adc195546">deformable_model</a> () const</td></tr>
<tr class="memdesc:a2e04d949f2b755579ea4af5adc195546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classdrake_1_1multibody_1_1_deformable_model.html" title="DeformableModel implements the interface in PhysicalModel and provides the functionalities to specify...">DeformableModel</a> owned by this plant.  <br /></td></tr>
<tr class="memitem:ae61da45e6c6c646b11b8ea4a53bcbd32" id="r_ae61da45e6c6c646b11b8ea4a53bcbd32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_deformable_model.html">DeformableModel</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae61da45e6c6c646b11b8ea4a53bcbd32">mutable_deformable_model</a> ()</td></tr>
<tr class="memdesc:ae61da45e6c6c646b11b8ea4a53bcbd32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable reference to the <a class="el" href="classdrake_1_1multibody_1_1_deformable_model.html" title="DeformableModel implements the interface in PhysicalModel and provides the functionalities to specify...">DeformableModel</a> owned by this plant.  <br /></td></tr>
<tr class="memitem:a1e5e058b968b927f6342a8127aea663a" id="r_a1e5e058b968b927f6342a8127aea663a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e5e058b968b927f6342a8127aea663a">set_penetration_allowance</a> (<a class="el" href="classdouble.html">double</a> penetration_allowance=<a class="el" href="structdrake_1_1multibody_1_1_multibody_plant_config.html">MultibodyPlantConfig</a>{}.penetration_allowance)</td></tr>
<tr class="memdesc:a1e5e058b968b927f6342a8127aea663a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a penetration allowance used to estimate the point contact stiffness and Hunt &amp; Crossley dissipation parameters.  <br /></td></tr>
<tr class="memitem:a3338392f611d5d9f93d0ea90e172c68c" id="r_a3338392f611d5d9f93d0ea90e172c68c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3338392f611d5d9f93d0ea90e172c68c">get_contact_penalty_method_time_scale</a> () const</td></tr>
<tr class="memdesc:a3338392f611d5d9f93d0ea90e172c68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a time-scale estimate <span class="tt">tc</span> based on the requested penetration allowance δ set with <a class="el" href="#a1e5e058b968b927f6342a8127aea663a" title="Sets a penetration allowance used to estimate the point contact stiffness and Hunt &amp; Crossley dissipa...">set_penetration_allowance()</a>.  <br /></td></tr>
<tr class="memitem:afa94cf2eeba3e27ad35132211ae6d074" id="r_afa94cf2eeba3e27ad35132211ae6d074"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa94cf2eeba3e27ad35132211ae6d074">set_stiction_tolerance</a> (<a class="el" href="classdouble.html">double</a> v_stiction=<a class="el" href="structdrake_1_1multibody_1_1_multibody_plant_config.html">MultibodyPlantConfig</a>{}.<a class="el" href="#a0cef6f48aa258bbb487ab62cec437cb8">stiction_tolerance</a>)</td></tr>
<tr class="memdesc:afa94cf2eeba3e27ad35132211ae6d074"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="mbp_stribeck_model"></a> <br /></td></tr>
<tr class="memitem:a0cef6f48aa258bbb487ab62cec437cb8" id="r_a0cef6f48aa258bbb487ab62cec437cb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cef6f48aa258bbb487ab62cec437cb8">stiction_tolerance</a> () const</td></tr>
<tr class="memitem:a93cf63581a2d40a28d9cf65a3017839b" id="r_a93cf63581a2d40a28d9cf65a3017839b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1geometry.html#a227f80cb57c9c87f6ecc4e839e364979">geometry::HydroelasticContactRepresentation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93cf63581a2d40a28d9cf65a3017839b">GetDefaultContactSurfaceRepresentation</a> (<a class="el" href="classdouble.html">double</a> <a class="el" href="#a8daceb7a3c384d6ad9f305e42b5fc1c6">time_step</a>)</td></tr>
<tr class="memdesc:a93cf63581a2d40a28d9cf65a3017839b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the default value for contact representation, given the desired time step.  <br /></td></tr>
</table>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3aeb03d90d213da4702f2dc5e484fc86" name="a3aeb03d90d213da4702f2dc5e484fc86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aeb03d90d213da4702f2dc5e484fc86">&#9670;&#160;</a></span>MultibodyPlant() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MultibodyPlant </td>
          <td>(</td>
          <td class="paramtype">const MultibodyPlant&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a359ae04bf7eabd0461c5f12ab35fee1d" name="a359ae04bf7eabd0461c5f12ab35fee1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359ae04bf7eabd0461c5f12ab35fee1d">&#9670;&#160;</a></span>MultibodyPlant() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MultibodyPlant </td>
          <td>(</td>
          <td class="paramtype">MultibodyPlant&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3296be9fa9bc35e6639460f54029c4c9" name="a3296be9fa9bc35e6639460f54029c4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3296be9fa9bc35e6639460f54029c4c9">&#9670;&#160;</a></span>MultibodyPlant() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MultibodyPlant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>time_step</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This constructor creates a plant with a single "world" body. </p>
<p>Therefore, right after creation, <a class="el" href="#af92b53211e54243aff4490a700168eb4" title="Returns the number of RigidBody elements in the model, including the &quot;world&quot; RigidBody,...">num_bodies()</a> returns one.</p>
<p>MultibodyPlant offers two different modalities to model mechanical systems in time. These are:</p><ol type="1">
<li>As a discrete system with periodic updates, <span class="tt"><a class="el" href="#a8daceb7a3c384d6ad9f305e42b5fc1c6" title="The time step (or period) used to model this plant as a discrete system with periodic updates.">time_step</a></span> is strictly greater than zero.</li>
<li>As a continuous system, <span class="tt"><a class="el" href="#a8daceb7a3c384d6ad9f305e42b5fc1c6" title="The time step (or period) used to model this plant as a discrete system with periodic updates.">time_step</a></span> equals exactly zero.</li>
</ol>
<p>Currently the discrete model is preferred for simulation given its robustness and speed in problems with frictional contact. However this might change as we work towards developing better strategies to model contact. See <a class="el" href="group__multibody__solvers.html#multibody_simulation">Simulation of Multibody Systems with Frictional Contact</a> for further details.</p>
<dl class="section warning"><dt>Warning</dt><dd>Users should be aware of current limitations in either modeling modality. While the discrete model is often the preferred option for problems with frictional contact given its robustness and speed, it might become unstable when using large feedback gains, high damping or large external forcing. MultibodyPlant will throw an exception whenever the discrete solver is detected to fail. Conversely, the continuous modality has the potential to leverage the robustness and accuracy control provide by Drake's integrators. However thus far this has proved difficult in practice and especially due to poor performance.</dd></dl>
<pre class="fragment">  @param[in] time_step
    Indicates whether `this` plant is modeled as a continuous system
    (`time_step = 0`) or as a discrete system with periodic updates of
    period `time_step &gt; 0`. See @ref multibody_simulation for further
    details.

  @warning Currently the continuous modality with `time_step = 0` does not
  support joint limits for simulation, these are ignored. %MultibodyPlant
  prints a warning to console if joint limits are provided. If your
  simulation requires joint limits currently you must use a discrete
  %MultibodyPlant model.

  @throws std::exception if `time_step` is negative. 
</pre> 
</div>
</div>
<a id="a912adb84c4940893eb4634155e6e7e8b" name="a912adb84c4940893eb4634155e6e7e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912adb84c4940893eb4634155e6e7e8b">&#9670;&#160;</a></span>MultibodyPlant() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MultibodyPlant </td>
          <td>(</td>
          <td class="paramtype">const MultibodyPlant&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar-converting copy constructor. See <a class="el" href="group__system__scalar__conversion.html">System Scalar Conversion</a>. </p>

</div>
</div>
<a id="ad119698acd3da506dbdd68f19372dbfb" name="ad119698acd3da506dbdd68f19372dbfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad119698acd3da506dbdd68f19372dbfb">&#9670;&#160;</a></span>~MultibodyPlant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="#a47a63154823dffd5838329527aafbd58">MultibodyPlant</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a04c1fdf7afe469442ca4ceb1392653c7" name="a04c1fdf7afe469442ca4ceb1392653c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c1fdf7afe469442ca4ceb1392653c7">&#9670;&#160;</a></span>AddBallConstraint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a> AddBallConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_AP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body_B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_BQ</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a constraint such that point P affixed to body A is coincident at all times with point Q affixed to body B, effectively modeling a ball-and-socket joint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">body_A</td><td><a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a> to which point P is rigidly attached. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_AP</td><td>Position of point P in body A's frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">body_B</td><td><a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a> to which point Q is rigidly attached. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BQ</td><td>(optional) Position of point Q in body B's frame. If p_BQ is std::nullopt, then p_BQ will be computed so that the constraint is satisfied for the default configuration at <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> time; subsequent changes to the default configuration will not change the computed p_BQ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the id of the newly added constraint.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if bodies A and B are the same body. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the MultibodyPlant has already been finalized. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">this</span> MultibodyPlant is not a discrete model (is_discrete() == false) </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">this</span> MultibodyPlant's underlying contact solver is not SAP. (i.e. <a class="el" href="#ad7698366750a09e383106a17bf9009a2" title="Returns the contact solver type used for discrete MultibodyPlant models.">get_discrete_contact_solver()</a> != <a class="el" href="namespacedrake_1_1multibody.html#a902306c5e0120a67c07f80e9219a3e8dad48dc7e3221aee2d9e1af665ebfbeeec" title="SAP solver, see [Castro et al., 2022].">DiscreteContactSolver::kSap</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad867f47ed9c5fa6a48d4eba8b9d871e9" name="ad867f47ed9c5fa6a48d4eba8b9d871e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad867f47ed9c5fa6a48d4eba8b9d871e9">&#9670;&#160;</a></span>AddCouplerConstraint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a> AddCouplerConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>joint0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>joint1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>gear_ratio</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a holonomic constraint between two single-dof joints <span class="tt">joint0</span> and <span class="tt">joint1</span> with positions q₀ and q₁, respectively, such that q₀ = ρ⋅q₁ + Δq, where ρ is the gear ratio and Δq is a fixed offset. </p>
<p>The gear ratio can have units if the units of q₀ and q₁ are different. For instance, between a prismatic and a revolute joint the gear ratio will specify the "pitch" of the resulting mechanism. As defined, <span class="tt">offset</span> has units of <span class="tt">q₀</span>.</p>
<dl class="section note"><dt>Note</dt><dd>joint0 and/or joint1 can still be actuated, regardless of whether we have coupler constraint among them. That is, one or both of these joints can have external actuation applied to them.</dd>
<dd>
Generally, to couple (q0, q1, q2), the user would define a coupler between (q0, q1) and a second coupler between (q1, q2), or any combination therein.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>joint0 and joint1 are not both single-dof joints. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the MultibodyPlant has already been finalized. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">this</span> MultibodyPlant is not a discrete model (is_discrete() == false) </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">this</span> MultibodyPlant's underlying contact solver is not SAP. (i.e. <a class="el" href="#ad7698366750a09e383106a17bf9009a2" title="Returns the contact solver type used for discrete MultibodyPlant models.">get_discrete_contact_solver()</a> != <a class="el" href="namespacedrake_1_1multibody.html#a902306c5e0120a67c07f80e9219a3e8dad48dc7e3221aee2d9e1af665ebfbeeec" title="SAP solver, see [Castro et al., 2022].">DiscreteContactSolver::kSap</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa141315d9a08af4dc7f82c8d3f9f1367" name="aa141315d9a08af4dc7f82c8d3f9f1367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa141315d9a08af4dc7f82c8d3f9f1367">&#9670;&#160;</a></span>AddDistanceConstraint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a> AddDistanceConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_AP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body_B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_BQ</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>distance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>stiffness</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;&#160;<a class="el" href="classdouble.html">double</a>&#160;&gt;::infinity()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>damping</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a distance constraint between a point P on a body A and a point Q on a body B. </p>
<p>This constraint can be compliant, modeling a spring with free length <span class="tt">distance</span> and given <span class="tt">stiffness</span> and <span class="tt">damping</span> parameters between points P and Q. For d = ‖p_PQ‖, then a compliant distance constraint models a spring with force along p_PQ given by:</p>
<p>f = −stiffness ⋅ d − damping ⋅ ḋ</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">body_A</td><td><a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a> to which point P is rigidly attached. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_AP</td><td>Position of point P in body A's frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">body_B</td><td><a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a> to which point Q is rigidly attached. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BQ</td><td>Position of point Q in body B's frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>Fixed length of the distance constraint, in meters. It must be strictly positive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stiffness</td><td>For modeling a spring with free length equal to <span class="tt">distance</span>, the stiffness parameter in N/m. Optional, with its default value being infinite to model a rigid massless rod of length <span class="tt">distance</span> connecting points A and B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">damping</td><td>For modeling a spring with free length equal to <span class="tt">distance</span>, damping parameter in N⋅s/m. Optional, with its default value being zero for a non-dissipative constraint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the id of the newly added constraint.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Currently, it is the user's responsibility to initialize the model's context in a configuration compatible with the newly added constraint.</dd>
<dd>
A distance constraint is the wrong modeling choice if the distance needs to go through zero. To constrain two points to be coincident we need a 3-dof ball constraint, the 1-dof distance constraint is singular in this case. Therefore we require the distance parameter to be strictly positive.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>When a new context is created, a <a class="el" href="classdrake_1_1multibody_1_1_distance_constraint_params.html" title="Parameters for a distance constraint.">DistanceConstraintParams</a> is initialized to store the parameters passed to this function. Parameters in the context can be modified with calls to <a class="el" href="#a6672fc5264442466b21708b7008421fe" title="Stores in context the parameters params for the distance constraint with identifier id.">SetDistanceConstraintParams()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if bodies A and B are the same body. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">distance</span> is not strictly positive. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">stiffness</span> is not positive or zero. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">damping</span> is not positive or zero. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the MultibodyPlant has already been finalized. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">this</span> MultibodyPlant is not a discrete model (is_discrete() == false) </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">this</span> MultibodyPlant's underlying contact solver is not SAP. (i.e. <a class="el" href="#ad7698366750a09e383106a17bf9009a2" title="Returns the contact solver type used for discrete MultibodyPlant models.">get_discrete_contact_solver()</a> != <a class="el" href="namespacedrake_1_1multibody.html#a902306c5e0120a67c07f80e9219a3e8dad48dc7e3221aee2d9e1af665ebfbeeec" title="SAP solver, see [Castro et al., 2022].">DiscreteContactSolver::kSap</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82719521a8b2d69b6d3ce0bbb462d6e8" name="a82719521a8b2d69b6d3ce0bbb462d6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82719521a8b2d69b6d3ce0bbb462d6e8">&#9670;&#160;</a></span>AddForceElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename <a class="el" href="classdrake_1_1systems_1_1_system.html#a78eaec0a6a2d1c99d2a7eb5eeb1f8bdc">Scalar</a> &gt; class ForceElementType, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const ForceElementType&lt; T &gt; &amp; AddForceElement </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new force element model of type <span class="tt">ForceElementType</span> to <span class="tt">this</span> MultibodyPlant. </p>
<p>The arguments to this method <span class="tt">args</span> are forwarded to <span class="tt">ForceElementType</span>'s constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Zero or more parameters provided to the constructor of the new force element. It must be the case that <span class="tt">ForceElementType&lt;T&gt;(args)</span> is a valid constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForceElementType</td><td>The type of the <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> to add. As there is always a <a class="el" href="classdrake_1_1multibody_1_1_uniform_gravity_field_element.html" title="This ForceElement allows modeling the effect of a uniform gravity field as felt by bodies on the surf...">UniformGravityFieldElement</a> present (accessible through <a class="el" href="#a0fbda7f9bfa1e15586be2c35abafd03a" title="An accessor to the current gravity field.">gravity_field()</a>), an exception will be thrown if this function is called to add another <a class="el" href="classdrake_1_1multibody_1_1_uniform_gravity_field_element.html" title="This ForceElement allows modeling the effect of a uniform gravity field as felt by bodies on the surf...">UniformGravityFieldElement</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the new <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> just added, of type <span class="tt">ForceElementType&lt;T&gt;</span> specialized on the scalar type T of <span class="tt">this</span> MultibodyPlant. It will remain valid for the lifetime of <span class="tt">this</span> MultibodyPlant. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>The <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> class's documentation for further details on how a force element is defined. </dd></dl>

</div>
</div>
<a id="a8026d4144953acf4c1d89b128f678ba0" name="a8026d4144953acf4c1d89b128f678ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8026d4144953acf4c1d89b128f678ba0">&#9670;&#160;</a></span>AddFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename &gt; class FrameType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const FrameType&lt; T &gt; &amp; AddFrame </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; FrameType&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>frame</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method adds a <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame) of its underl...">Frame</a> of type <span class="tt">FrameType&lt;T&gt;</span>. </p>
<p>For more information, please see the corresponding constructor of <span class="tt">FrameType</span>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FrameType</td><td>Template which will be instantiated on <span class="tt">T</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>Unique pointer frame instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the new <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame) of its underl...">Frame</a> just added, which will remain valid for the lifetime of <span class="tt">this</span> MultibodyPlant. </dd></dl>

</div>
</div>
<a id="aa2637e697203a7c7e84143afb684e3a1" name="aa2637e697203a7c7e84143afb684e3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2637e697203a7c7e84143afb684e3a1">&#9670;&#160;</a></span>AddJoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename &gt; class JointType, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const JointType&lt; T &gt; &amp; AddJoint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_PF</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>child</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_BM</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method adds a <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> of type <span class="tt">JointType</span> between two bodies. </p>
<p>The two bodies connected by this <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> object are referred to as <em>parent</em> and <em>child</em> bodies. The parent/child ordering defines the sign conventions for the generalized coordinates and the coordinate ordering for multi-DOF joints.</p>
<div class="image">
<img src="BodyParentChildJointCM.png" alt=""/>
</div>
<p> width=50%</p>
<p>Note: The previous figure also shows Pcm which is body P's center of mass and point Bcm which is body B's center of mass.</p>
<p>As explained in the <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> class's documentation, in Drake we define a frame F attached to the parent body P with pose <span class="tt">X_PF</span> and a frame M attached to the child body B with pose <span class="tt">X_BM</span>. This method helps creating a joint between two bodies with fixed poses <span class="tt">X_PF</span> and <span class="tt">X_BM</span>. Refer to the <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> class's documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>A string that uniquely identifies the new joint to be added to <span class="tt">this</span> model. A std::runtime_error is thrown if a joint named <span class="tt">name</span> already is part of the model. See <a class="el" href="#af5cc2bf03e1b34a63539f8e104425729">HasJointNamed()</a>, <a class="el" href="classdrake_1_1multibody_1_1_joint.html#a24dcbf29c0d6cd766009a182a6484e3b" title="Returns the name of this joint.">Joint::name()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>The parent body connected by the new joint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_PF</td><td>The fixed pose of frame F attached to the parent body, measured in the frame P of that body. <span class="tt">X_PF</span> is an optional parameter; empty curly braces <span class="tt">{}</span> imply that frame F <b>is</b> the same body frame P. If instead your intention is to make a frame F with pose <span class="tt">X_PF</span> equal to the identity pose, provide <span class="tt">RigidTransform&lt;<a class="el" href="classdouble.html">double</a>&gt;::Identity()</span> as your input. When non-nullopt, adds a <a class="el" href="classdrake_1_1multibody_1_1_fixed_offset_frame.html" title="FixedOffsetFrame represents a material frame F whose pose is fixed with respect to a parent material ...">FixedOffsetFrame</a> named <span class="tt">{name}_parent</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">child</td><td>The child body connected by the new joint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_BM</td><td>The fixed pose of frame M attached to the child body, measured in the frame B of that body. <span class="tt">X_BM</span> is an optional parameter; empty curly braces <span class="tt">{}</span> imply that frame M <b>is</b> the same body frame B. If instead your intention is to make a frame M with pose <span class="tt">X_BM</span> equal to the identity pose, provide <span class="tt">RigidTransform&lt;<a class="el" href="classdouble.html">double</a>&gt;::Identity()</span> as your input. When non-nullopt, adds a <a class="el" href="classdrake_1_1multibody_1_1_fixed_offset_frame.html" title="FixedOffsetFrame represents a material frame F whose pose is fixed with respect to a parent material ...">FixedOffsetFrame</a> named <span class="tt">{name}_child</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Zero or more parameters provided to the constructor of the new joint. It must be the case that <span class="tt">JointType&lt;T&gt;(
  const std::string&amp;, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame) of its underl...">Frame</a>&lt;T&gt;&amp;, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame) of its underl...">Frame</a>&lt;T&gt;&amp;, args)</span> is a valid constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">JointType</td><td>The type of the <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the new joint just added, of type <span class="tt">JointType&lt;T&gt;</span> specialized on the scalar type T of <span class="tt">this</span> MultibodyPlant. It will remain valid for the lifetime of <span class="tt">this</span> MultibodyPlant.</dd></dl>
<p>Example of usage: </p><div class="fragment"><div class="line"><a class="code hl_friend" href="#a47a63154823dffd5838329527aafbd58">MultibodyPlant&lt;T&gt;</a> plant;</div>
<div class="line"><span class="comment">// Code to define bodies serving as the joint&#39;s parent and child bodies.</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody&lt;double&gt;</a>&amp; body_1 =</div>
<div class="line">  plant.<a class="code hl_function" href="#a2f347b072b9cdb7b584f7098ba7c451c">AddRigidBody</a>(<span class="stringliteral">&quot;Body1&quot;</span>, <a class="code hl_class" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia&lt;double&gt;</a>(...));</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody&lt;double&gt;</a>&amp; body_2 =</div>
<div class="line">  plant.<a class="code hl_function" href="#a2f347b072b9cdb7b584f7098ba7c451c">AddRigidBody</a>(<span class="stringliteral">&quot;Body2&quot;</span>, <a class="code hl_class" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia&lt;double&gt;</a>(...));</div>
<div class="line"><span class="comment">// RigidBody 1 serves as parent, RigidBody 2 serves as child.</span></div>
<div class="line"><span class="comment">// Define the pose X_BM of a frame M rigidly attached to child body B.</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1multibody_1_1_revolute_joint.html">RevoluteJoint&lt;double&gt;</a>&amp; elbow =</div>
<div class="line">  plant.<a class="code hl_function" href="#a80c10ac818d74ed590875fd07f477671">AddJoint</a>&lt;<a class="code hl_class" href="classdrake_1_1multibody_1_1_revolute_joint.html">RevoluteJoint</a>&gt;(</div>
<div class="line">    <span class="stringliteral">&quot;Elbow&quot;</span>,                <span class="comment">/* joint name */</span></div>
<div class="line">    body_1,                 <span class="comment">/* parent body */</span></div>
<div class="line">    {},                     <span class="comment">/* frame F IS the parent body frame P */</span></div>
<div class="line">    body_2,                 <span class="comment">/* child body, the pendulum */</span></div>
<div class="line">    X_BM,                   <span class="comment">/* pose of frame M in the body frame B */</span></div>
<div class="line">    Vector3d::UnitZ());     <span class="comment">/* revolute axis in this case */</span></div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_multibody_plant_html_a2f347b072b9cdb7b584f7098ba7c451c"><div class="ttname"><a href="#a2f347b072b9cdb7b584f7098ba7c451c">drake::multibody::MultibodyPlant::AddRigidBody</a></div><div class="ttdeci">const RigidBody&lt; T &gt; &amp; AddRigidBody(const std::string &amp;name, ModelInstanceIndex model_instance, const SpatialInertia&lt; double &gt; &amp;M_BBo_B=SpatialInertia&lt; double &gt;::Zero())</div><div class="ttdoc">Creates a rigid body with the provided name and spatial inertia.</div><div class="ttdef"><b>Definition</b> multibody_plant.h:1371</div></div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_multibody_plant_html_a80c10ac818d74ed590875fd07f477671"><div class="ttname"><a href="#a80c10ac818d74ed590875fd07f477671">drake::multibody::MultibodyPlant::AddJoint</a></div><div class="ttdeci">const JointType&lt; T &gt; &amp; AddJoint(std::unique_ptr&lt; JointType&lt; T &gt; &gt; joint)</div><div class="ttdoc">This method adds a Joint of type JointType between two bodies.</div><div class="ttdef"><b>Definition</b> multibody_plant.h:1444</div></div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_revolute_joint_html"><div class="ttname"><a href="classdrake_1_1multibody_1_1_revolute_joint.html">drake::multibody::RevoluteJoint</a></div><div class="ttdoc">This Joint allows two bodies to rotate relatively to one another around a common axis.</div><div class="ttdef"><b>Definition</b> revolute_joint.h:30</div></div>
</div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">this</span> MultibodyPlant already contains a joint with the given <span class="tt">name</span>. See <a class="el" href="#af5cc2bf03e1b34a63539f8e104425729">HasJointNamed()</a>, <a class="el" href="classdrake_1_1multibody_1_1_joint.html#a24dcbf29c0d6cd766009a182a6484e3b" title="Returns the name of this joint.">Joint::name()</a>. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if parent and child are the same body or if they are not both from <span class="tt">this</span> MultibodyPlant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>The <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> class's documentation for further details on how a <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> is defined. </dd></dl>

</div>
</div>
<a id="a80c10ac818d74ed590875fd07f477671" name="a80c10ac818d74ed590875fd07f477671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c10ac818d74ed590875fd07f477671">&#9670;&#160;</a></span>AddJoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename <a class="el" href="classdrake_1_1systems_1_1_system.html#a78eaec0a6a2d1c99d2a7eb5eeb1f8bdc">Scalar</a> &gt; class JointType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const JointType&lt; T &gt; &amp; AddJoint </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; JointType&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>joint</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method adds a <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> of type <span class="tt">JointType</span> between two bodies. </p>
<p>For more information, see the below overload of <span class="tt"><a class="el" href="#a80c10ac818d74ed590875fd07f477671" title="This method adds a Joint of type JointType between two bodies.">AddJoint</a>&lt;&gt;</span>. </p>

</div>
</div>
<a id="ae6e70af2d399ab5b665a3f36a5ada172" name="ae6e70af2d399ab5b665a3f36a5ada172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e70af2d399ab5b665a3f36a5ada172">&#9670;&#160;</a></span>AddJointActuator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp; AddJointActuator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>joint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>effort_limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;&#160;<a class="el" href="classdouble.html">double</a>&#160;&gt;::infinity()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and adds a <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a> model for an actuator acting on a given <span class="tt">joint</span>. </p>
<p>This method returns a constant reference to the actuator just added, which will remain valid for the lifetime of <span class="tt">this</span> plant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A string that uniquely identifies the new actuator to be added to <span class="tt">this</span> model. A std::runtime_error is thrown if an actuator with the same name already exists in the model. See <a class="el" href="#a7bfcc73831e073c659a3c6503e0e1e6a">HasJointActuatorNamed()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">joint</td><td>The <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> to be actuated by the new <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">effort_limit</td><td>The maximum effort for the actuator. It must be strictly positive, otherwise an std::exception is thrown. If +∞, the actuator has no limit, which is the default. The effort limit has physical units in accordance to the joint type it actuates. For instance, it will have units of N⋅m (torque) for revolute joints while it will have units of N (force) for prismatic joints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The effort limit is unused by <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> and is simply provided here for bookkeeping purposes. It will not, for instance, saturate external actuation inputs based on this value. If, for example, a user intends to saturate the force/torque that is applied to the <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> via this actuator, the user-level code (e.g., a controller) should query this effort limit and impose the saturation there. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the new <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a> just added, which will remain valid for the lifetime of <span class="tt">this</span> plant or until the <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a> has been removed from the plant with <a class="el" href="#ae9eafac01a6cf0c90fa9005418ee2ec8" title="Removes and deletes actuator from this MultibodyPlant.">RemoveJointActuator()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">joint.num_velocities() &gt; 1</span> since for now we only support actuators for single dof joints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae9eafac01a6cf0c90fa9005418ee2ec8" title="Removes and deletes actuator from this MultibodyPlant.">RemoveJointActuator()</a> </dd></dl>

</div>
</div>
<a id="a4edf1daa65069a26255c903b02bce4c6" name="a4edf1daa65069a26255c903b02bce4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4edf1daa65069a26255c903b02bce4c6">&#9670;&#160;</a></span>AddModelInstance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> AddModelInstance </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new model instance. </p>
<p>Returns the index for the model instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A string that uniquely identifies the new instance to be added to <span class="tt">this</span> model. An exception is thrown if an instance with the same name already exists in the model. See <a class="el" href="#ae12f32b40b7a41c3aa933ed74b2417fb">HasModelInstanceNamed()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a929da02905c626c447f2fcc25505391c" name="a929da02905c626c447f2fcc25505391c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929da02905c626c447f2fcc25505391c">&#9670;&#160;</a></span>AddRigidBody() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp; AddRigidBody </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>M_BBo_B</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;::Zero()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a rigid body with the provided name and spatial inertia. </p>
<p>This method returns a constant reference to the body just added, which will remain valid for the lifetime of <span class="tt">this</span> MultibodyPlant. The body will use the default model instance (<a class="el" href="model__instance_8h.html#model_instance">more on model instances</a>).</p>
<p>Example of usage: </p><div class="fragment"><div class="line"><a class="code hl_friend" href="#a47a63154823dffd5838329527aafbd58">MultibodyPlant&lt;T&gt;</a> plant;</div>
<div class="line"><span class="comment">// ... Code to define spatial_inertia, a SpatialInertia&lt;T&gt; object ...</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody&lt;T&gt;</a>&amp; body =</div>
<div class="line">  plant.<a class="code hl_function" href="#a2f347b072b9cdb7b584f7098ba7c451c">AddRigidBody</a>(<span class="stringliteral">&quot;BodyName&quot;</span>, spatial_inertia);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A string that identifies the new body to be added to <span class="tt">this</span> model. A std::runtime_error is thrown if a body named <span class="tt">name</span> already is part of the model in the default model instance. See <a class="el" href="#a5aa037adf3002834caa1aedd305fa36d">HasBodyNamed()</a>, <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html#a24dcbf29c0d6cd766009a182a6484e3b" title="Gets the name associated with this rigid body.">RigidBody::name()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M_BBo_B</td><td>The <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia.">SpatialInertia</a> of the new rigid body to be added to <span class="tt">this</span> MultibodyPlant, computed about the body frame origin <span class="tt">Bo</span> and expressed in the body frame B. When not provided, defaults to zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the new <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a> just added, which will remain valid for the lifetime of <span class="tt">this</span> MultibodyPlant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if additional model instances have been created beyond the world and default instances. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f347b072b9cdb7b584f7098ba7c451c" name="a2f347b072b9cdb7b584f7098ba7c451c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f347b072b9cdb7b584f7098ba7c451c">&#9670;&#160;</a></span>AddRigidBody() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp; AddRigidBody </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>M_BBo_B</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;::Zero()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a rigid body with the provided name and spatial inertia. </p>
<p>This method returns a constant reference to the body just added, which will remain valid for the lifetime of <span class="tt">this</span> MultibodyPlant.</p>
<p>Example of usage: </p><div class="fragment"><div class="line"><a class="code hl_friend" href="#a47a63154823dffd5838329527aafbd58">MultibodyPlant&lt;T&gt;</a> plant;</div>
<div class="line"><span class="comment">// ... Code to define spatial_inertia, a SpatialInertia&lt;T&gt; object ...</span></div>
<div class="line"><a class="code hl_typedef" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance = plant.<a class="code hl_function" href="#a4edf1daa65069a26255c903b02bce4c6">AddModelInstance</a>(<span class="stringliteral">&quot;instance&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody&lt;T&gt;</a>&amp; body =</div>
<div class="line">  plant.<a class="code hl_function" href="#a2f347b072b9cdb7b584f7098ba7c451c">AddRigidBody</a>(<span class="stringliteral">&quot;BodyName&quot;</span>, model_instance, spatial_inertia);</div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_multibody_plant_html_a4edf1daa65069a26255c903b02bce4c6"><div class="ttname"><a href="#a4edf1daa65069a26255c903b02bce4c6">drake::multibody::MultibodyPlant::AddModelInstance</a></div><div class="ttdeci">ModelInstanceIndex AddModelInstance(const std::string &amp;name)</div><div class="ttdoc">Creates a new model instance.</div><div class="ttdef"><b>Definition</b> multibody_plant.h:1670</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A string that identifies the new body to be added to <span class="tt">this</span> model. A std::runtime_error is thrown if a body named <span class="tt">name</span> already is part of <code class="param">model_instance</code>. See <a class="el" href="#a5aa037adf3002834caa1aedd305fa36d">HasBodyNamed()</a>, <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html#a24dcbf29c0d6cd766009a182a6484e3b" title="Gets the name associated with this rigid body.">RigidBody::name()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_instance</td><td>A model instance index which this body is part of. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M_BBo_B</td><td>The <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia.">SpatialInertia</a> of the new rigid body to be added to <span class="tt">this</span> MultibodyPlant, computed about the body frame origin <span class="tt">Bo</span> and expressed in the body frame B. When not provided, defaults to zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the new <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a> just added, which will remain valid for the lifetime of <span class="tt">this</span> MultibodyPlant. </dd></dl>

</div>
</div>
<a id="a7639ec04cd9ca90b649e7b712e5b839c" name="a7639ec04cd9ca90b649e7b712e5b839c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7639ec04cd9ca90b649e7b712e5b839c">&#9670;&#160;</a></span>AddTendonConstraint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a> AddTendonConstraint </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>joints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lower_limit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>upper_limit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>stiffness</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>damping</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a set of unilateral constraints on the length of an abstract tendon defined as: </p>
<p>l(q) = aᵀ⋅q + offset ∈ ℝ</p>
<p>where <b>q</b> is the configuration of the model, <b>a</b> is a vector of coefficients, and <b>offset</b> a scalar offset. This constraint imposes:</p>
<p>lₗ ≤ l(q) ≤ lᵤ</p>
<p>where <b>lₗ</b> and <b>lᵤ</b> are lower and upper bounds, respectively. Both limits are not strictly required. At most one of <b>lₗ</b> or <b>lᵤ</b> may be infinite (−∞ for <b>lₗ</b> and ∞ for <b>lᵤ</b>), indicating no lower or upper limit, respectively.</p>
<p>For finite <span class="tt">stiffness</span> and <span class="tt">damping</span>, this constraint is modeled by compliant spring-like forces:</p>
<p>fₗ = −stiffness⋅(l - lₗ) − damping⋅dl(q)/dt <br  />
 fᵤ = −stiffness⋅(lᵤ - l) + damping⋅dl(q)/dt</p>
<p>that act to keep the length within bounds. If the user provided stiffness is either omitted or set to ∞, this constraint is modeled as close to rigid as possible by the underlying solver.</p>
<dl class="section note"><dt>Note</dt><dd>The coefficients in a are expected to have units such that the abstract length l(q) has consistent units (either meters or radians) and it is up to the user to maintain consistency in these units. The (optionally user provided) <span class="tt">stiffness</span> and <span class="tt">damping</span> are expected to have consistent units such that their products have units of the corresponding generalized force. E.g. N/m for <span class="tt">stiffness</span> and N⋅s/m for <span class="tt">damping</span> when l has units of m, so that <b>fₗ</b> and <b>fᵤ</b> have units of N.</dd>
<dd>
Any joint involved in this constraint can still be actuated.</dd>
<dd>
See the MuJoCo model documentation for details the equivalent concept of a "fixed" tendon: <a href="https://mujoco.readthedocs.io/en/stable/XMLreference.html#tendon-fixed">https://mujoco.readthedocs.io/en/stable/XMLreference.html#tendon-fixed</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joints</td><td>Non-empty vector of single-dof joint indices where the configuration, qᵢ, of joints[i] corresponds to the entry a[i]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Non-empty vector of coefficients where a[i] corresponds to the configuration, qᵢ, of joints[i]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>(optional) <a class="el" href="classdrake_1_1systems_1_1_system.html#a78eaec0a6a2d1c99d2a7eb5eeb1f8bdc" title="The scalar type with which this System was instantiated.">Scalar</a> length offset in either [m] or [rad]. If std::nullopt, it is set to 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lower_limit</td><td>(optional) Lower bound on l in either [m] or [rad]. If std::nullopt, it is set to −∞. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upper_limit</td><td>Upper bound on l in either [m] or [rad]. If std::nullopt, it is set to ∞. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stiffness</td><td>(optional) Constraint stiffness in either [N/m] or [N⋅m/rad]. If std::nullopt, its default value is set to ∞ to model a rigid constraint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">damping</td><td>(optional) Constraint damping in either [N⋅s/m] or [N⋅m⋅rad/s]. If std::nullopt, it is set to 0 to model a non-dissipative constraint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Because of a restriction in the SAP solver, <b>at most</b> two kinematic trees can be represented by the joints in <span class="tt">joints</span>. This violation is only detected after the simulation has been started, in which case the solver will throw an exception when trying to add the constraint.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">joints.size() &gt; 0</span> </dd>
<dd>
<span class="tt">joints</span> contains no duplicates. </dd>
<dd>
<span class="tt">a.size() == joints.size()</span> </dd>
<dd>
<span class="tt">index ∈ joints</span> is a valid (non-removed) index to a joint in this plant. </dd>
<dd>
<span class="tt">get_joint(index).num_velocities() == 1</span> for each index in <span class="tt">joints</span>. </dd>
<dd>
<span class="tt">lower_limit &lt; ∞</span> (if not std::nullopt). </dd>
<dd>
<span class="tt">upper_limit &gt; -∞</span> (if not std::nullopt). </dd>
<dd>
At least one of <span class="tt">lower_limit</span> and <span class="tt">upper_limit</span> are finite. </dd>
<dd>
<span class="tt">lower_limit ≤ upper_limit</span> (if not std::nullopt). </dd>
<dd>
<span class="tt">stiffness &gt; 0</span> (if not std::nullopt). </dd>
<dd>
<span class="tt">damping &gt;= 0</span> (if not std::nullopt).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the MultibodyPlant has already been finalized. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">this</span> MultibodyPlant is not a discrete model (<span class="tt">is_discrete() == false</span>). </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">this</span> MultibodyPlant's underlying contact solver is not SAP. (i.e. <a class="el" href="#ad7698366750a09e383106a17bf9009a2" title="Returns the contact solver type used for discrete MultibodyPlant models.">get_discrete_contact_solver()</a> != <a class="el" href="namespacedrake_1_1multibody.html#a902306c5e0120a67c07f80e9219a3e8dad48dc7e3221aee2d9e1af665ebfbeeec" title="SAP solver, see [Castro et al., 2022].">DiscreteContactSolver::kSap</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec4f15db42bddd6789b0732762046ce6" name="aec4f15db42bddd6789b0732762046ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4f15db42bddd6789b0732762046ce6">&#9670;&#160;</a></span>AddWeldConstraint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a> AddWeldConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_AP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body_B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_BQ</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a constraint such that frame P affixed to body A is coincident at all times with frame Q affixed to body B, effectively modeling a weld joint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">body_A</td><td><a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a> to which frame P is rigidly attached. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_AP</td><td>Pose of frame P in body A's frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">body_B</td><td><a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a> to which frame Q is rigidly attached. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_BQ</td><td>Pose of frame Q in body B's frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the id of the newly added constraint.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if bodies A and B are the same body. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the MultibodyPlant has already been finalized. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">this</span> MultibodyPlant is not a discrete model (is_discrete() == false) </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">this</span> MultibodyPlant's underlying contact solver is not SAP. (i.e. <a class="el" href="#ad7698366750a09e383106a17bf9009a2" title="Returns the contact solver type used for discrete MultibodyPlant models.">get_discrete_contact_solver()</a> != <a class="el" href="namespacedrake_1_1multibody.html#a902306c5e0120a67c07f80e9219a3e8dad48dc7e3221aee2d9e1af665ebfbeeec" title="SAP solver, see [Castro et al., 2022].">DiscreteContactSolver::kSap</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8f95be2e7dd654644d866bc1bd47026" name="ad8f95be2e7dd654644d866bc1bd47026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f95be2e7dd654644d866bc1bd47026">&#9670;&#160;</a></span>CalcBiasCenterOfMassTranslationalAcceleration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; CalcBiasCenterOfMassTranslationalAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>model_instances</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a></td>          <td class="paramname"><span class="paramname"><em>with_respect_to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_E</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For the system S containing the selected model instances, calculates a𝑠Bias_AScm_E, Scm's translational acceleration bias in frame A with respect to "speeds" 𝑠, expressed in frame E, where Scm is the center of mass of S and speeds 𝑠 is either q̇ or v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Contains the state of the multibody system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_instances</td><td><a class="el" href="namespacedrake.html#a01ae662d5635b7c9efe03d15d976f7a8" title="A column vector templated on the number of rows.">Vector</a> of selected model instances. If a model instance is repeated in the vector (unusual), it is only counted once. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">with_respect_to</td><td>Enum equal to <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a> or <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a" title="J = ∂V/∂v.">JacobianWrtVariable::kV</a>, indicating whether the accceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v. Currently, an exception is thrown if with_respect_to is <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame in which a𝑠Bias_AScm is measured. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_E</td><td>The frame in which a𝑠Bias_AScm is expressed on output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a𝑠Bias_AScm_E Point Scm's translational acceleration bias in frame A with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">this</span> has no body except <a class="el" href="#a787a58094e9902e11d3359b54d20eed4" title="Returns a constant reference to the world body.">world_body()</a>. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if mₛ ≤ 0, where mₛ is the mass of system S. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if with_respect_to is <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af77549470a45208454339f59e989784a" title="Calculates J𝑠_v_AScm_E, point Scm&#39;s translational velocity Jacobian in frame A with respect to &quot;speed...">CalcJacobianCenterOfMassTranslationalVelocity()</a> to compute J𝑠_v_Scm, point Scm's translational velocity Jacobian in frame A with respect to 𝑠. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="#a787a58094e9902e11d3359b54d20eed4" title="Returns a constant reference to the world body.">world_body()</a> is ignored. asBias_AScm_E = ∑ (mᵢ aᵢ) / mₛ, where mₛ = ∑ mᵢ is the mass of system S, mᵢ is the mass of the iᵗʰ body, and aᵢ is the translational bias acceleration of Bᵢcm in frame A expressed in frame E for speeds 𝑠 (Bᵢcm is the center of mass of the iᵗʰ body). </dd>
<dd>
See <a class="el" href="#bias_acceleration_functions">Bias acceleration functions</a> for theory and details. </dd></dl>

</div>
</div>
<a id="aca44cee51105bbec8d96bf6ecba05956" name="aca44cee51105bbec8d96bf6ecba05956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca44cee51105bbec8d96bf6ecba05956">&#9670;&#160;</a></span>CalcBiasCenterOfMassTranslationalAcceleration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; CalcBiasCenterOfMassTranslationalAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a></td>          <td class="paramname"><span class="paramname"><em>with_respect_to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_E</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For the system S of all bodies other than the world body, calculates a𝑠Bias_AScm_E, Scm's translational acceleration bias in frame A with respect to "speeds" 𝑠, expressed in frame E, where Scm is the center of mass of S and speeds 𝑠 is either q̇ or v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Contains the state of the multibody system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">with_respect_to</td><td>Enum equal to <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a> or <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a" title="J = ∂V/∂v.">JacobianWrtVariable::kV</a>, indicating whether the accceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v. Currently, an exception is thrown if with_respect_to is <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame in which a𝑠Bias_AScm is measured. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_E</td><td>The frame in which a𝑠Bias_AScm is expressed on output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a𝑠Bias_AScm_E Point Scm's translational acceleration bias in frame A with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">this</span> has no body except <a class="el" href="#a787a58094e9902e11d3359b54d20eed4" title="Returns a constant reference to the world body.">world_body()</a>. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if mₛ ≤ 0, where mₛ is the mass of system S. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if with_respect_to is <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af77549470a45208454339f59e989784a" title="Calculates J𝑠_v_AScm_E, point Scm&#39;s translational velocity Jacobian in frame A with respect to &quot;speed...">CalcJacobianCenterOfMassTranslationalVelocity()</a> to compute J𝑠_v_Scm, point Scm's translational velocity Jacobian in frame A with respect to 𝑠. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="#a787a58094e9902e11d3359b54d20eed4" title="Returns a constant reference to the world body.">world_body()</a> is ignored. asBias_AScm_E = ∑ (mᵢ aᵢ) / mₛ, where mₛ = ∑ mᵢ is the mass of system S, mᵢ is the mass of the iᵗʰ body, and aᵢ is the translational bias acceleration of Bᵢcm in frame A expressed in frame E for speeds 𝑠 (Bᵢcm is the center of mass of the iᵗʰ body). </dd>
<dd>
See <a class="el" href="#bias_acceleration_functions">Bias acceleration functions</a> for theory and details. </dd></dl>

</div>
</div>
<a id="aaebf41e8c10ab8ea498ce8057ffbdbe2" name="aaebf41e8c10ab8ea498ce8057ffbdbe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaebf41e8c10ab8ea498ce8057ffbdbe2">&#9670;&#160;</a></span>CalcBiasSpatialAcceleration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt; CalcBiasSpatialAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a></td>          <td class="paramname"><span class="paramname"><em>with_respect_to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_BoBp_B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_E</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For one point Bp affixed/welded to a frame B, calculates A𝑠Bias_ABp, Bp's spatial acceleration bias in frame A with respect to "speeds" 𝑠, expressed in frame E, where speeds 𝑠 is either q̇ or v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Contains the state of the multibody system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">with_respect_to</td><td>Enum equal to <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a> or <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a" title="J = ∂V/∂v.">JacobianWrtVariable::kV</a>, indicating whether the spatial accceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v. Currently, an exception is thrown if with_respect_to is <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_B</td><td>The frame on which point Bp is affixed/welded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BoBp_B</td><td>Position vector from Bo (frame_B's origin) to point Bp (regarded as affixed/welded to B), expressed in frame_B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame in which A𝑠Bias_ABp is measured. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_E</td><td>The frame in which A𝑠Bias_ABp is expressed on output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A𝑠Bias_ABp_E Point Bp's spatial acceleration bias in frame A with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a206be3cb8c5909f50bcc671b7bedaa13" title="For one point Bp fixed/welded to a frame B, calculates J𝑠_V_ABp, Bp&#39;s spatial velocity Jacobian in fr...">CalcJacobianSpatialVelocity()</a> to compute J𝑠_V_ABp, point Bp's spatial velocity Jacobian in frame A with respect to 𝑠. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if with_respect_to is <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Use <a class="el" href="#af30522c1a4bfd5a9091d6ab97f19e313" title="For each point Bi affixed/welded to a frame B, calculates a𝑠Bias_ABi, Bi&#39;s translational acceleration...">CalcBiasTranslationalAcceleration()</a> to efficiently calculate bias translational accelerations for a list of points (each fixed to frame B). This function returns only one bias spatial acceleration, which contains both frame B's bias angular acceleration and point Bp's bias translational acceleration. </dd>
<dd>
See <a class="el" href="#bias_acceleration_functions">Bias acceleration functions</a> for theory and details. </dd></dl>

</div>
</div>
<a id="a0796a9a23609cf73cd050e3f9fa6bae2" name="a0796a9a23609cf73cd050e3f9fa6bae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0796a9a23609cf73cd050e3f9fa6bae2">&#9670;&#160;</a></span>CalcBiasTerm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CalcBiasTerm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>Cv</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the bias term <span class="tt">C(q, v) v</span> containing Coriolis, centripetal, and gyroscopic effects in the multibody equations of motion: </p>
<pre>
  M(q) v̇ + C(q, v) v = tau_app + ∑ (Jv_V_WBᵀ(q) ⋅ Fapp_Bo_W)
</pre><p> where <span class="tt">M(q)</span> is the multibody model's mass matrix (including rigid body mass properties and <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#reflected_inertia">reflected inertias</a>) and <span class="tt">tau_app</span> is a vector of applied generalized forces. The last term is a summation over all bodies of the dot-product of <span class="tt">Fapp_Bo_W</span> (applied spatial force on body B at Bo) with <span class="tt">Jv_V_WB(q)</span> (B's spatial Jacobian in world W with respect to generalized velocities v). Note: B's spatial velocity in W can be written <span class="tt">V_WB = Jv_V_WB * v</span>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Contains the state of the multibody system, including the generalized positions q and the generalized velocities v. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Cv</td><td>On output, <span class="tt">Cv</span> will contain the product <span class="tt">C(q, v)v</span>. It must be a valid (non-null) pointer to a column vector in <span class="tt">ℛⁿ</span> with n the number of generalized velocities (<a class="el" href="#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a>) of the model. This method aborts if Cv is nullptr or if it does not have the proper size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af30522c1a4bfd5a9091d6ab97f19e313" name="af30522c1a4bfd5a9091d6ab97f19e313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30522c1a4bfd5a9091d6ab97f19e313">&#9670;&#160;</a></span>CalcBiasTranslationalAcceleration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt; T &gt; CalcBiasTranslationalAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a></td>          <td class="paramname"><span class="paramname"><em>with_respect_to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_BoBi_B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_E</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each point Bi affixed/welded to a frame B, calculates a𝑠Bias_ABi, Bi's translational acceleration bias in frame A with respect to "speeds" 𝑠, expressed in frame E, where speeds 𝑠 is either q̇ or v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Contains the state of the multibody system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">with_respect_to</td><td>Enum equal to <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a> or <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a" title="J = ∂V/∂v.">JacobianWrtVariable::kV</a>, indicating whether the translational acceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v. Currently, an exception is thrown if with_respect_to is <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_B</td><td>The frame on which points Bi are affixed/welded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BoBi_B</td><td>A position vector or list of p position vectors from Bo (frame_B's origin) to points Bi (regarded as affixed to B), where each position vector is expressed in frame_B. Each column in the <span class="tt">3 x p</span> matrix p_BoBi_B corresponds to a position vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame in which a𝑠Bias_ABi is measured. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_E</td><td>The frame in which a𝑠Bias_ABi is expressed on output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a𝑠Bias_ABi_E Point Bi's translational acceleration bias in frame A with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E. a𝑠Bias_ABi_E is a <span class="tt">3 x p</span> matrix, where p is the number of points Bi. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0afc6adf5bda2b9456d67ab2405af076" title="For each point Bi affixed/welded to a frame B, calculates J𝑠_v_ABi, Bi&#39;s translational velocity Jacob...">CalcJacobianTranslationalVelocity()</a> to compute J𝑠_v_ABi, point Bi's translational velocity Jacobian in frame A with respect to 𝑠. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>p_BoBi_B must have 3 rows. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if with_respect_to is <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>See <a class="el" href="#bias_acceleration_functions">Bias acceleration functions</a> for theory and details. </dd></dl>

</div>
</div>
<a id="a36c71f9947c9cfa3874a550d82a0139d" name="a36c71f9947c9cfa3874a550d82a0139d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c71f9947c9cfa3874a550d82a0139d">&#9670;&#160;</a></span>CalcCenterOfMassPositionInWorld() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; CalcCenterOfMassPositionInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the position vector from the world origin Wo to the center of mass of all bodies in this <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>, expressed in the world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Contains the state of the model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">p_WoScm_W</td><td>position vector from Wo to Scm expressed in world frame W, where Scm is the center of mass of the system S stored by <span class="tt">this</span> plant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">this</span> has no body except <a class="el" href="#a787a58094e9902e11d3359b54d20eed4" title="Returns a constant reference to the world body.">world_body()</a>. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if mₛ ≤ 0 (where mₛ is the mass of system S). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="#a787a58094e9902e11d3359b54d20eed4" title="Returns a constant reference to the world body.">world_body()</a> is ignored. p_WoScm_W = ∑ (mᵢ pᵢ) / mₛ, where mₛ = ∑ mᵢ, mᵢ is the mass of the iᵗʰ body, and pᵢ is Bᵢcm's position from Wo expressed in frame W (Bᵢcm is the center of mass of the iᵗʰ body). </dd></dl>

</div>
</div>
<a id="ac5edd56266d5c7a41e4660ec145179c1" name="ac5edd56266d5c7a41e4660ec145179c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5edd56266d5c7a41e4660ec145179c1">&#9670;&#160;</a></span>CalcCenterOfMassPositionInWorld() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; CalcCenterOfMassPositionInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>model_instances</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the position vector from the world origin Wo to the center of mass of all non-world bodies contained in model_instances, expressed in the world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Contains the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_instances</td><td><a class="el" href="namespacedrake.html#a01ae662d5635b7c9efe03d15d976f7a8" title="A column vector templated on the number of rows.">Vector</a> of selected model instances. If a model instance is repeated in the vector (unusual), it is only counted once. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">p_WoScm_W</td><td>position vector from world origin Wo to Scm expressed in the world frame W, where Scm is the center of mass of the system S of non-world bodies contained in model_instances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if model_instances is empty or only has world body. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if mₛ ≤ 0 (where mₛ is the mass of system S). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="#a787a58094e9902e11d3359b54d20eed4" title="Returns a constant reference to the world body.">world_body()</a> is ignored. p_WoScm_W = ∑ (mᵢ pᵢ) / mₛ, where mₛ = ∑ mᵢ, mᵢ is the mass of the iᵗʰ body contained in model_instances, and pᵢ is Bᵢcm's position vector from Wo expressed in frame W (Bᵢcm is the center of mass of the iᵗʰ body). </dd></dl>

</div>
</div>
<a id="a8287928c6b0c43158cce34773370cbd3" name="a8287928c6b0c43158cce34773370cbd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8287928c6b0c43158cce34773370cbd3">&#9670;&#160;</a></span>CalcCenterOfMassTranslationalAccelerationInWorld() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; CalcCenterOfMassTranslationalAccelerationInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For the system S contained in this MultibodyPlant, calculates Scm's translational acceleration in the world frame W expressed in W, where Scm is the center of mass of S. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context contains the state of the model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">a_WScm_W</td><td>Scm's translational acceleration in the world frame W expressed in the world frame W. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">this</span> has no body except <a class="el" href="#a787a58094e9902e11d3359b54d20eed4" title="Returns a constant reference to the world body.">world_body()</a>. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if mₛ ≤ 0, where mₛ is the mass of system S. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="#a787a58094e9902e11d3359b54d20eed4" title="Returns a constant reference to the world body.">world_body()</a> is ignored. a_WScm_W = ∑ (mᵢ aᵢ) / mₛ, where mₛ = ∑ mᵢ is the mass of system S, mᵢ is the mass of the iᵗʰ body, and aᵢ is the translational acceleration of Bᵢcm in world W expressed in W (Bᵢcm is the center of mass of the iᵗʰ body). </dd>
<dd>
When cached values are out of sync with the state stored in context, this method performs an expensive forward dynamics computation, whereas once evaluated, successive calls to this method are inexpensive. </dd></dl>

</div>
</div>
<a id="ae19c48bd3033e534a9a04502af791d72" name="ae19c48bd3033e534a9a04502af791d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19c48bd3033e534a9a04502af791d72">&#9670;&#160;</a></span>CalcCenterOfMassTranslationalAccelerationInWorld() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; CalcCenterOfMassTranslationalAccelerationInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>model_instances</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For the system S containing the selected model instances, calculates Scm's translational acceleration in the world frame W expressed in W, where Scm is the center of mass of S. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context contains the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_instances</td><td><a class="el" href="namespacedrake.html#a01ae662d5635b7c9efe03d15d976f7a8" title="A column vector templated on the number of rows.">Vector</a> of selected model instances. If a model instance is repeated in the vector (unusual), it is only counted once. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">a_WScm_W</td><td>Scm's translational acceleration in the world frame W expressed in the world frame W. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if model_instances is empty or only has world body. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if mₛ ≤ 0, where mₛ is the mass of system S. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="#a787a58094e9902e11d3359b54d20eed4" title="Returns a constant reference to the world body.">world_body()</a> is ignored. a_WScm_W = ∑ (mᵢ aᵢ) / mₛ, where mₛ = ∑ mᵢ is the mass of system S, mᵢ is the mass of the iᵗʰ body in model_instances, and aᵢ is the translational acceleration of Bᵢcm in world W expressed in W (Bᵢcm is the center of mass of the iᵗʰ body). </dd>
<dd>
When cached values are out of sync with the state stored in context, this method performs an expensive forward dynamics computation, whereas once evaluated, successive calls to this method are inexpensive. </dd></dl>

</div>
</div>
<a id="af145801a5fdaddbd08ffd3f6158ec4e9" name="af145801a5fdaddbd08ffd3f6158ec4e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af145801a5fdaddbd08ffd3f6158ec4e9">&#9670;&#160;</a></span>CalcCenterOfMassTranslationalVelocityInWorld() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; CalcCenterOfMassTranslationalVelocityInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates system center of mass translational velocity in world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context contains the state of the model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">v_WScm_W</td><td>Scm's translational velocity in frame W, expressed in W, where Scm is the center of mass of the system S stored by <span class="tt">this</span> plant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">this</span> has no body except <a class="el" href="#a787a58094e9902e11d3359b54d20eed4" title="Returns a constant reference to the world body.">world_body()</a>. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if mₛ ≤ 0 (where mₛ is the mass of system S). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="#a787a58094e9902e11d3359b54d20eed4" title="Returns a constant reference to the world body.">world_body()</a> is ignored. v_WScm_W = ∑ (mᵢ vᵢ) / mₛ, where mₛ = ∑ mᵢ, mᵢ is the mass of the iᵗʰ body, and vᵢ is Bᵢcm's velocity in world W (Bᵢcm is the center of mass of the iᵗʰ body). </dd></dl>

</div>
</div>
<a id="a08450360f6b90cd5de1ce7a6d01ade63" name="a08450360f6b90cd5de1ce7a6d01ade63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08450360f6b90cd5de1ce7a6d01ade63">&#9670;&#160;</a></span>CalcCenterOfMassTranslationalVelocityInWorld() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; CalcCenterOfMassTranslationalVelocityInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>model_instances</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates system center of mass translational velocity in world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context contains the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_instances</td><td><a class="el" href="namespacedrake.html#a01ae662d5635b7c9efe03d15d976f7a8" title="A column vector templated on the number of rows.">Vector</a> of selected model instances. If a model instance is repeated in the vector (unusual), it is only counted once. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">v_WScm_W</td><td>Scm's translational velocity in frame W, expressed in W, where Scm is the center of mass of the system S of non-world bodies contained in model_instances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if model_instances is empty or only has world body. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if mₛ ≤ 0 (where mₛ is the mass of system S). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="#a787a58094e9902e11d3359b54d20eed4" title="Returns a constant reference to the world body.">world_body()</a> is ignored. v_WScm_W = ∑ (mᵢ vᵢ) / mₛ, where mₛ = ∑ mᵢ, mᵢ is the mass of the iᵗʰ body contained in model_instances, and vᵢ is Bᵢcm's velocity in world W expressed in frame W (Bᵢcm is the center of mass of the iᵗʰ body). </dd></dl>

</div>
</div>
<a id="ae1b54c8562f107e4d6e11b4b0f8d53c5" name="ae1b54c8562f107e4d6e11b4b0f8d53c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b54c8562f107e4d6e11b4b0f8d53c5">&#9670;&#160;</a></span>CalcForceElementsContribution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CalcForceElementsContribution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html">MultibodyForces</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>forces</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the combined force contribution of <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> objects in the model. </p>
<p>A <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> can apply forces as a spatial force per body or as generalized forces, depending on the <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> model. <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> contributions are a function of the state and time only. The output from this method can immediately be used as input to <a class="el" href="#af3d9f1dfe387a173b84c49a5bbe5a4c2" title="Given the state of this model in context and a known vector of generalized accelerations vdot,...">CalcInverseDynamics()</a> to include the effect of applied forces by force elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of this model. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">forces</td><td>A pointer to a valid, non nullptr, multibody forces object. On output <span class="tt">forces</span> will store the forces exerted by all the <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> objects in the model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">forces</span> is null or not compatible with this model, per MultibodyForces::CheckInvariants(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f6239b2ed3aeda23fb3d75194c84715" name="a4f6239b2ed3aeda23fb3d75194c84715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f6239b2ed3aeda23fb3d75194c84715">&#9670;&#160;</a></span>CalcFullSystemJacobian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixX&lt; T &gt; CalcFullSystemJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Evaluates the block system Jacobian, then uses it to fill in an equivalent full matrix of size 6n x m where n is the number of mobilized bodies and m the number of generalized velocities (mobilities). </p>
<p>Each mobilized body generates a 6 x m strip of the Jacobian (6 rows) and those are ordered by MobodIndex. Note that World is the 0th mobilized body so to keep the numbering consistent the first 6 rows of the Jacobian correspond to the World Mobod (and are thus all zero).</p>
<p>This is most useful for testing; it is more efficient to use <a class="el" href="#aebb50c01460083966268609d9309dbb2" title="(Internal use only) Returns the System Jacobian Jv_V_WB(q) in block form.">EvalBlockSystemJacobian()</a> and to work with the individual blocks. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#aebb50c01460083966268609d9309dbb2" title="(Internal use only) Returns the System Jacobian Jv_V_WB(q) in block form.">EvalBlockSystemJacobian()</a>, <a class="el" href="#a206be3cb8c5909f50bcc671b7bedaa13" title="For one point Bp fixed/welded to a frame B, calculates J𝑠_V_ABp, Bp&#39;s spatial velocity Jacobian in fr...">CalcJacobianSpatialVelocity()</a> </dd></dl>

</div>
</div>
<a id="a05d83f939cc098d1c25eabecf41ff588" name="a05d83f939cc098d1c25eabecf41ff588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d83f939cc098d1c25eabecf41ff588">&#9670;&#160;</a></span>CalcGeneralizedForces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CalcGeneralizedForces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html">MultibodyForces</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>forces</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>generalized_forces</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the generalized forces result of a set of <a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html" title="A class to hold a set of forces applied to a MultibodyTree system.">MultibodyForces</a> applied to this model. </p>
<p><a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html" title="A class to hold a set of forces applied to a MultibodyTree system.">MultibodyForces</a> stores applied forces as both generalized forces τ and spatial forces F on each body, refer to documentation in <a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html" title="A class to hold a set of forces applied to a MultibodyTree system.">MultibodyForces</a> for details. Users of <a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html" title="A class to hold a set of forces applied to a MultibodyTree system.">MultibodyForces</a> will use <a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html#a53d6d94643e3dad996d2217e3c7ede9f" title="(Advanced) Mutable version of generalized_forces().">MultibodyForces::mutable_generalized_forces()</a> to mutate the stored generalized forces directly and will use <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html#a64de0960e4ea0ac2144af8c2295a7871" title="Adds the SpatialForce on this RigidBody B, applied at body B&#39;s origin Bo and expressed in the world f...">RigidBody::AddInForceInWorld()</a> to append spatial forces.</p>
<p>For a given set of forces stored as <a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html" title="A class to hold a set of forces applied to a MultibodyTree system.">MultibodyForces</a>, this method will compute the total generalized forces on this model. More precisely, if J_WBo is the Jacobian (with respect to velocities) for this model, including all bodies, then this method computes: </p><pre>
  τᵣₑₛᵤₗₜ = τ + J_WBo⋅F
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Context that stores the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forces</td><td>Set of multibody forces, including both generalized forces and per-body spatial forces. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">generalized_forces</td><td>The total generalized forces on the model that would result from applying <span class="tt">forces</span>. In other words, <span class="tt">forces</span> can be replaced by the equivalent <span class="tt">generalized_forces</span>. On output, <span class="tt">generalized_forces</span> is resized to <a class="el" href="#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">forces</span> is null or not compatible with this model. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">generalized_forces</span> is not a valid non-null pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b1293f0e09ec2d3df0a9eaeab6baa9a" name="a0b1293f0e09ec2d3df0a9eaeab6baa9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1293f0e09ec2d3df0a9eaeab6baa9a">&#9670;&#160;</a></span>CalcGravityGeneralizedForces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; CalcGravityGeneralizedForces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the generalized forces <span class="tt">tau_g(q)</span> due to gravity as a function of the generalized positions <span class="tt">q</span> stored in the input <span class="tt">context</span>. </p>
<p>The vector of generalized forces due to gravity <span class="tt">tau_g(q)</span> is defined such that it appears on the right hand side of the equations of motion together with any other generalized forces, like so: </p><pre>
  Mv̇ + C(q, v)v = tau_g(q) + tau_app
</pre><p> where <span class="tt">tau_app</span> includes any other generalized forces applied on the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context storing the state of the model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tau_g A vector containing the generalized forces due to gravity. The generalized forces are consistent with the vector of generalized velocities <span class="tt">v</span> for <span class="tt">this</span> so that the inner product <span class="tt">v⋅tau_g</span> corresponds to the power applied by the gravity forces on the mechanical system. That is, <span class="tt">v⋅tau_g &gt; 0</span> corresponds to potential energy going into the system, as either mechanical kinetic energy, some other potential energy, or heat, and therefore to a decrease of the gravitational potential energy. </dd></dl>

</div>
</div>
<a id="aecbf5eca950cc15b86c9133950c14f70" name="aecbf5eca950cc15b86c9133950c14f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecbf5eca950cc15b86c9133950c14f70">&#9670;&#160;</a></span>CalcImplicitTimeDerivativesResidual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CalcImplicitTimeDerivativesResidual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">systems::ContinuousState</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>proposed_derivatives</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>residual</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> implements the <a class="el" href="classdrake_1_1systems_1_1_system.html#a8debe7d25e61fd759c918d889286525f" title="Evaluates the implicit form of the System equations and returns the residual.">systems::System::CalcImplicitTimeDerivativesResidual</a> method when the plant is modeled as a continuous-time system, returning one residual for each multibody state. </p>
<p>In particular, the first <a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">num_positions()</a> residuals are given by </p><pre>
  q̇_proposed - N(q)⋅v
</pre><p> and the final <a class="el" href="#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a> residuals are given by </p><pre>
  CalcInverseDynamics(context, v_proposed)
</pre><p> including all actuator and applied forces. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system.html#a8debe7d25e61fd759c918d889286525f" title="Evaluates the implicit form of the System equations and returns the residual.">systems::System::CalcImplicitTimeDerivativesResidual</a> for more details. </dd></dl>

</div>
</div>
<a id="af3d9f1dfe387a173b84c49a5bbe5a4c2" name="af3d9f1dfe387a173b84c49a5bbe5a4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d9f1dfe387a173b84c49a5bbe5a4c2">&#9670;&#160;</a></span>CalcInverseDynamics()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; CalcInverseDynamics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>known_vdot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html">MultibodyForces</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>external_forces</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the state of this model in <span class="tt">context</span> and a known vector of generalized accelerations <span class="tt">vdot</span>, this method computes the set of generalized forces <span class="tt">tau</span> that would need to be applied in order to attain the specified generalized accelerations. </p>
<p>Mathematically, this method computes: </p><pre>
  tau = M(q)v̇ + C(q, v)v - tau_app - ∑ J_WBᵀ(q) Fapp_Bo_W
</pre><p> where <span class="tt">M(q)</span> is the model's mass matrix (including rigid body mass properties and <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#reflected_inertia">reflected inertias</a>), <span class="tt">C(q, v)v</span> is the bias term for Coriolis and gyroscopic effects and <span class="tt">tau_app</span> consists of a vector applied generalized forces. The last term is a summation over all bodies in the model where <span class="tt">Fapp_Bo_W</span> is an applied spatial force on body B at <span class="tt">Bo</span> which gets projected into the space of generalized forces with the transpose of <span class="tt">Jv_V_WB(q)</span> (where <span class="tt">Jv_V_WB</span> is B's spatial velocity Jacobian in W with respect to generalized velocities v). Note: B's spatial velocity in W can be written as <span class="tt">V_WB = Jv_V_WB * v</span>.</p>
<p>This method does not compute explicit expressions for the mass matrix nor for the bias term, which would be of at least <span class="tt">O(n²)</span> complexity, but it implements an <span class="tt">O(n)</span> Newton-Euler recursive algorithm, where n is the number of bodies in the model. The explicit formation of the mass matrix <span class="tt">M(q)</span> would require the calculation of <span class="tt">O(n²)</span> entries while explicitly forming the product <span class="tt">C(q, v) * v</span> could require up to <span class="tt">O(n³)</span> operations (see [Featherstone 1987, §4]), depending on the implementation. The recursive Newton-Euler algorithm is the most efficient currently known general method for solving inverse dynamics [Featherstone 2008].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">known_vdot</td><td>A vector with the known generalized accelerations <span class="tt">vdot</span> for the full model. Use the provided <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> APIs in order to access entries into this array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">external_forces</td><td>A set of forces to be applied to the system either as body spatial forces <span class="tt">Fapp_Bo_W</span> or generalized forces <span class="tt">tau_app</span>, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html" title="A class to hold a set of forces applied to a MultibodyTree system.">MultibodyForces</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vector of generalized forces that would need to be applied to the mechanical system in order to achieve the desired acceleration given by <span class="tt">known_vdot</span>. </dd></dl>

</div>
</div>
<a id="a70878af42e7d09d7861e36cb4616fc0d" name="a70878af42e7d09d7861e36cb4616fc0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70878af42e7d09d7861e36cb4616fc0d">&#9670;&#160;</a></span>CalcJacobianAngularVelocity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CalcJacobianAngularVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a></td>          <td class="paramname"><span class="paramname"><em>with_respect_to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_E</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>Js_w_AB_E</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates J𝑠_w_AB, a frame B's angular velocity Jacobian in a frame A with respect to "speeds" 𝑠. </p>
<pre>
     J𝑠_w_AB ≜ [ ∂(w_AB)/∂𝑠₁,  ...  ∂(w_AB)/∂𝑠ₙ ]    (n is j or k)
     w_AB = J𝑠_w_AB ⋅ 𝑠          w_AB is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre><p> <span class="tt">w_AB</span> is B's angular velocity in frame A and "speeds" 𝑠 is either q̇ ≜ [q̇₁ ... q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v ≜ [v₁ ... vₖ]ᵀ (k generalized velocities).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The state of the multibody system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">with_respect_to</td><td>Enum equal to <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a> or <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a" title="J = ∂V/∂v.">JacobianWrtVariable::kV</a>, indicating whether the Jacobian <span class="tt">J𝑠_w_AB</span> is partial derivatives with respect to 𝑠 = q̇ (time-derivatives of generalized positions) or with respect to 𝑠 = v (generalized velocities). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_B</td><td>The frame B in <span class="tt">w_AB</span> (B's angular velocity in A). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame A in <span class="tt">w_AB</span> (B's angular velocity in A). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_E</td><td>The frame in which <span class="tt">w_AB</span> is expressed on input and the frame in which the Jacobian <span class="tt">J𝑠_w_AB</span> is expressed on output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Js_w_AB_E</td><td><a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame) of its underl...">Frame</a> B's angular velocity Jacobian in frame A with respect to speeds 𝑠 (which is either q̇ or v), expressed in frame E. The Jacobian is a function of only generalized positions q (which are pulled from the context). The previous definition shows <span class="tt">J𝑠_w_AB_E</span> is a matrix of size <span class="tt">3 x n</span>, where n is the number of elements in 𝑠. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="#Jacobian_functions">Jacobian functions</a> for related functions. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">J𝑠_w_AB_E</span> is nullptr or not of size <span class="tt">3 x n</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a8a5ba9eb6389a84e24da1c243304ca" name="a7a8a5ba9eb6389a84e24da1c243304ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8a5ba9eb6389a84e24da1c243304ca">&#9670;&#160;</a></span>CalcJacobianCenterOfMassTranslationalVelocity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CalcJacobianCenterOfMassTranslationalVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>model_instances</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a></td>          <td class="paramname"><span class="paramname"><em>with_respect_to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_E</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>Js_v_AScm_E</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates J𝑠_v_AScm_E, point Scm's translational velocity Jacobian in frame A with respect to "speeds" 𝑠, expressed in frame E, where point Scm is the center of mass of the system S of all non-world bodies contained in model_instances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>contains the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_instances</td><td><a class="el" href="namespacedrake.html#a01ae662d5635b7c9efe03d15d976f7a8" title="A column vector templated on the number of rows.">Vector</a> of selected model instances. If a model instance is repeated in the vector (unusual), it is only counted once. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">with_respect_to</td><td>Enum equal to <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a> or <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a" title="J = ∂V/∂v.">JacobianWrtVariable::kV</a>, indicating whether the Jacobian <span class="tt">J𝑠_v_AScm_E</span> is partial derivatives with respect to 𝑠 = q̇ (time-derivatives of generalized positions) or with respect to 𝑠 = v (generalized velocities). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame in which the translational velocity v_AScm and its Jacobian J𝑠_v_AScm are measured. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_E</td><td>The frame in which the Jacobian J𝑠_v_AScm is expressed on output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Js_v_AScm_E</td><td>Point Scm's translational velocity Jacobian in frame A with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E. J𝑠_v_AScm_E is a 3 x n matrix, where n is the number of elements in 𝑠. The Jacobian is a function of only generalized positions q (which are pulled from the context). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if mₛ ≤ 0 (where mₛ is the mass of all non-world bodies contained in model_instances). </td></tr>
    <tr><td class="paramname">std::exception</td><td>if model_instances is empty or only has world body. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="#a787a58094e9902e11d3359b54d20eed4" title="Returns a constant reference to the world body.">world_body()</a> is ignored. J𝑠_v_AScm_ = ∑ (mᵢ Jᵢ) / mₛ, where mₛ = ∑ mᵢ, mᵢ is the mass of the iᵗʰ body contained in model_instances, and Jᵢ is Bᵢcm's translational velocity Jacobian in frame A, expressed in frame E (Bᵢcm is the center of mass of the iᵗʰ body). </dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="#Jacobian_functions">Jacobian functions</a> for related functions. </dd></dl>

</div>
</div>
<a id="af77549470a45208454339f59e989784a" name="af77549470a45208454339f59e989784a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77549470a45208454339f59e989784a">&#9670;&#160;</a></span>CalcJacobianCenterOfMassTranslationalVelocity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CalcJacobianCenterOfMassTranslationalVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a></td>          <td class="paramname"><span class="paramname"><em>with_respect_to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_E</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>Js_v_AScm_E</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates J𝑠_v_AScm_E, point Scm's translational velocity Jacobian in frame A with respect to "speeds" 𝑠, expressed in frame E, where point Scm is the center of mass of the system S of all non-world bodies contained in <span class="tt">this</span> <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>contains the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">with_respect_to</td><td>Enum equal to <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a> or <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a" title="J = ∂V/∂v.">JacobianWrtVariable::kV</a>, indicating whether the Jacobian <span class="tt">J𝑠_v_AScm_E</span> is partial derivatives with respect to 𝑠 = q̇ (time-derivatives of generalized positions) or with respect to 𝑠 = v (generalized velocities). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame in which the translational velocity v_AScm and its Jacobian J𝑠_v_AScm are measured. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_E</td><td>The frame in which the Jacobian J𝑠_v_AScm is expressed on output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Js_v_AScm_E</td><td>Point Scm's translational velocity Jacobian in frame A with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E. J𝑠_v_AScm_E is a 3 x n matrix, where n is the number of elements in 𝑠. The Jacobian is a function of only generalized positions q (which are pulled from the context). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if Scm does not exist, which occurs if there are no massive bodies in <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> (except <a class="el" href="#a787a58094e9902e11d3359b54d20eed4" title="Returns a constant reference to the world body.">world_body()</a>). </td></tr>
    <tr><td class="paramname">std::exception</td><td>if mₛ ≤ 0 (where mₛ is the mass of all non-world bodies contained in <span class="tt">this</span> <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="#Jacobian_functions">Jacobian functions</a> for related functions. </dd></dl>

</div>
</div>
<a id="ad4f6754b441668775193177ad5dc7e09" name="ad4f6754b441668775193177ad5dc7e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f6754b441668775193177ad5dc7e09">&#9670;&#160;</a></span>CalcJacobianPositionVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CalcJacobianPositionVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_BoBi_B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_E</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>Jq_p_AoBi_E</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each point Bi affixed/welded to a frame B, calculates Jq_p_AoBi, Bi's position vector Jacobian in frame A with respect to the generalized positions q ≜ [q₁ ... qₙ]ᵀ as. </p>
<pre>
     Jq_p_AoBi ≜ [ ᴬ∂(p_AoBi)/∂q₁,  ...  ᴬ∂(p_AoBi)/∂qₙ ]
</pre><p> where p_AoBi is Bi's position vector from point Ao (frame A's origin) and ᴬ∂(p_AoBi)/∂qᵣ denotes the partial derivative in frame A of p_AoBi with respect to the generalized position qᵣ, where qᵣ is one of q₁ ... qₙ. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The state of the multibody system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_B</td><td>The frame on which point Bi is affixed/welded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BoBi_B</td><td>A position vector or list of k position vectors from Bo (frame_B's origin) to points Bi (Bi is regarded as affixed to B), where each position vector is expressed in frame_B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame in which partial derivatives are calculated and the frame in which point Ao is affixed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_E</td><td>The frame in which the Jacobian Jq_p_AoBi is expressed on output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Jq_p_AoBi_E</td><td>Point Bi's position vector Jacobian in frame A with generalized positions q, expressed in frame E. Jq_p_AoBi_E is a <span class="tt">3*k x n</span> matrix, where k is the number of points Bi and n is the number of elements in q. The Jacobian is a function of only generalized positions q (which are pulled from the context). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if Jq_p_AoBi_E is nullptr or not sized <span class="tt">3*k x n</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Jq̇_v_ABi = Jq_p_AoBi. In other words, point Bi's velocity Jacobian in frame A with respect to q̇ is equal to point Bi's position vector Jacobian in frame A with respect to q. <pre>
[∂(v_ABi)/∂q̇₁, ... ∂(v_ABi)/∂q̇ₙ] = [ᴬ∂(p_AoBi)/∂q₁, ... ᴬ∂(p_AoBi)/∂qₙ]
</pre> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0afc6adf5bda2b9456d67ab2405af076" title="For each point Bi affixed/welded to a frame B, calculates J𝑠_v_ABi, Bi&#39;s translational velocity Jacob...">CalcJacobianTranslationalVelocity()</a> for details on Jq̇_v_ABi. Note: Jq_p_AaBi = Jq_p_AoBi, where point Aa is <em><a class="el" href="namespacedrake.html#a044a99d40c78d36c585451760f6a8513" title="Checks truth for at least one element in matrix m.">any</a></em> point fixed/welded to frame A, i.e., this calculation's result is the same if point Ao is replaced with <a class="el" href="namespacedrake.html#a044a99d40c78d36c585451760f6a8513" title="Checks truth for at least one element in matrix m.">any</a> point fixed on frame A. </dd>
<dd>
See <a class="el" href="#Jacobian_functions">Jacobian functions</a> for related functions. </dd></dl>

</div>
</div>
<a id="a206be3cb8c5909f50bcc671b7bedaa13" name="a206be3cb8c5909f50bcc671b7bedaa13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206be3cb8c5909f50bcc671b7bedaa13">&#9670;&#160;</a></span>CalcJacobianSpatialVelocity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CalcJacobianSpatialVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a></td>          <td class="paramname"><span class="paramname"><em>with_respect_to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_BoBp_B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_E</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>Js_V_ABp_E</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For one point Bp fixed/welded to a frame B, calculates J𝑠_V_ABp, Bp's spatial velocity Jacobian in frame A with respect to "speeds" 𝑠. </p>
<pre>
     J𝑠_V_ABp ≜ [ ∂(V_ABp)/∂𝑠₁,  ...  ∂(V_ABp)/∂𝑠ₙ ]    (n is j or k)
     V_ABp = J𝑠_V_ABp ⋅ 𝑠          V_ABp is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre><p> <span class="tt">V_ABp</span> is Bp's spatial velocity in frame A and "speeds" 𝑠 is either q̇ ≜ [q̇₁ ... q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v ≜ [v₁ ... vₖ]ᵀ (k generalized velocities).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The state of the multibody system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">with_respect_to</td><td>Enum equal to <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a> or <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a" title="J = ∂V/∂v.">JacobianWrtVariable::kV</a>, indicating whether the Jacobian <span class="tt">J𝑠_V_ABp</span> is partial derivatives with respect to 𝑠 = q̇ (time-derivatives of generalized positions) or with respect to 𝑠 = v (generalized velocities). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_B</td><td>The frame on which point Bp is fixed/welded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BoBp_B</td><td>A position vector from Bo (frame_B's origin) to point Bp (regarded as fixed/welded to B), expressed in frame_B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame that measures <span class="tt">v_ABp</span> (Bp's velocity in A). Note: It is natural to wonder why there is no parameter p_AoAp_A (similar to the parameter p_BoBp_B for frame_B). There is no need for p_AoAp_A because Bp's velocity in A is defined as the derivative in frame A of Bp's position vector from <em>any</em> point fixed to A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_E</td><td>The frame in which <span class="tt">v_ABp</span> is expressed on input and the frame in which the Jacobian <span class="tt">J𝑠_V_ABp</span> is expressed on output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Js_V_ABp_E</td><td>Point Bp's spatial velocity Jacobian in frame A with respect to speeds 𝑠 (which is either q̇ or v), expressed in frame E. <span class="tt">J𝑠_V_ABp_E</span> is a <span class="tt">6 x n</span> matrix, where n is the number of elements in 𝑠. The Jacobian is a function of only generalized positions q (which are pulled from the context). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The returned <span class="tt">6 x n</span> matrix stores frame B's angular velocity Jacobian in A in rows 1-3 and stores point Bp's translational velocity Jacobian in A in rows 4-6, i.e., <pre>
    J𝑠_w_AB_E = J𝑠_V_ABp_E.topRows&lt;3&gt;();
    J𝑠_v_ABp_E = J𝑠_V_ABp_E.bottomRows&lt;3&gt;();
</pre> </dd>
<dd>
Consider <a class="el" href="#a0afc6adf5bda2b9456d67ab2405af076" title="For each point Bi affixed/welded to a frame B, calculates J𝑠_v_ABi, Bi&#39;s translational velocity Jacob...">CalcJacobianTranslationalVelocity()</a> for multiple points fixed to frame B and consider <a class="el" href="#a70878af42e7d09d7861e36cb4616fc0d" title="Calculates J𝑠_w_AB, a frame B&#39;s angular velocity Jacobian in a frame A with respect to &quot;speeds&quot; 𝑠.">CalcJacobianAngularVelocity()</a> to calculate frame B's angular velocity Jacobian. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="#Jacobian_functions">Jacobian functions</a> for related functions. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">J𝑠_V_ABp_E</span> is nullptr or not sized <span class="tt">6 x n</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0afc6adf5bda2b9456d67ab2405af076" name="a0afc6adf5bda2b9456d67ab2405af076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0afc6adf5bda2b9456d67ab2405af076">&#9670;&#160;</a></span>CalcJacobianTranslationalVelocity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CalcJacobianTranslationalVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a></td>          <td class="paramname"><span class="paramname"><em>with_respect_to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_BoBi_B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_E</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>Js_v_ABi_E</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each point Bi affixed/welded to a frame B, calculates J𝑠_v_ABi, Bi's translational velocity Jacobian in frame A with respect to "speeds" 𝑠. </p>
<pre>
     J𝑠_v_ABi ≜ [ ∂(v_ABi)/∂𝑠₁,  ...  ∂(v_ABi)/∂𝑠ₙ ]    (n is j or k)
     v_ABi = J𝑠_v_ABi ⋅ 𝑠          v_ABi is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre><p> <span class="tt">v_ABi</span> is Bi's translational velocity in frame A and "speeds" 𝑠 is either q̇ ≜ [q̇₁ ... q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v ≜ [v₁ ... vₖ]ᵀ (k generalized velocities).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The state of the multibody system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">with_respect_to</td><td>Enum equal to <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a> or <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a" title="J = ∂V/∂v.">JacobianWrtVariable::kV</a>, indicating whether the Jacobian <span class="tt">J𝑠_v_ABi</span> is partial derivatives with respect to 𝑠 = q̇ (time-derivatives of generalized positions) or with respect to 𝑠 = v (generalized velocities). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_B</td><td>The frame on which point Bi is affixed/welded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BoBi_B</td><td>A position vector or list of p position vectors from Bo (frame_B's origin) to points Bi (regarded as affixed to B), where each position vector is expressed in frame_B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame that measures <span class="tt">v_ABi</span> (Bi's velocity in A). Note: It is natural to wonder why there is no parameter p_AoAi_A (similar to the parameter p_BoBi_B for frame_B). There is no need for p_AoAi_A because Bi's velocity in A is defined as the derivative in frame A of Bi's position vector from <em>any</em> point affixed to A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_E</td><td>The frame in which <span class="tt">v_ABi</span> is expressed on input and the frame in which the Jacobian <span class="tt">J𝑠_v_ABi</span> is expressed on output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Js_v_ABi_E</td><td>Point Bi's velocity Jacobian in frame A with respect to speeds 𝑠 (which is either q̇ or v), expressed in frame E. <span class="tt">J𝑠_v_ABi_E</span> is a <span class="tt">3*p x n</span> matrix, where p is the number of points Bi and n is the number of elements in 𝑠. The Jacobian is a function of only generalized positions q (which are pulled from the context). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">J𝑠_v_ABi_E</span> is nullptr or not sized <span class="tt">3*p x n</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When 𝑠 = q̇, <span class="tt">Jq̇_v_ABi = Jq_p_AoBi</span>. In other words, point Bi's velocity Jacobian in frame A with respect to q̇ is equal to point Bi's position Jacobian from Ao (A's origin) in frame A with respect to q. <pre>
[∂(v_ABi)/∂q̇₁,  ...  ∂(v_ABi)/∂q̇ⱼ] = [∂(p_AoBi)/∂q₁,  ...  ∂(p_AoBi)/∂qⱼ]
</pre> Note: Each partial derivative of p_AoBi is taken in frame A. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad4f6754b441668775193177ad5dc7e09" title="For each point Bi affixed/welded to a frame B, calculates Jq_p_AoBi, Bi&#39;s position vector Jacobian in...">CalcJacobianPositionVector()</a> for details on Jq_p_AoBi. </dd>
<dd>
See <a class="el" href="#Jacobian_functions">Jacobian functions</a> for related functions. </dd></dl>

</div>
</div>
<a id="a1ba9332d8937729be136b54c8adc8b19" name="a1ba9332d8937729be136b54c8adc8b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba9332d8937729be136b54c8adc8b19">&#9670;&#160;</a></span>CalcMassMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CalcMassMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Efficiently computes the mass matrix <span class="tt">M(q)</span> of the model. </p>
<p>The generalized positions q are taken from the given <span class="tt">context</span>. M includes the mass properties of rigid bodies and <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#reflected_inertia">reflected inertias</a> as provided with <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a> specifications.</p>
<p>This method employs the Composite Body Algorithm, which we believe to be the fastest O(n²) algorithm to compute the mass matrix of a multibody system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The Context containing the state of the model from which generalized coordinates q are extracted. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td>A pointer to a square matrix in <span class="tt">ℛⁿˣⁿ</span> with n the number of generalized velocities (<a class="el" href="#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a>) of the model. Although symmetric, the matrix is filled in completely on return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>M is non-null and has the right size.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is an O(n²) algorithm. Avoid the explicit computation of the mass matrix whenever possible. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a42ee709a2ac50e2ae6c6a4cb153ea2e8" title="Computes the mass matrix M(q) of the model using a slow method (inverse dynamics).">CalcMassMatrixViaInverseDynamics()</a> (slower) </dd></dl>

</div>
</div>
<a id="a42ee709a2ac50e2ae6c6a4cb153ea2e8" name="a42ee709a2ac50e2ae6c6a4cb153ea2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ee709a2ac50e2ae6c6a4cb153ea2e8">&#9670;&#160;</a></span>CalcMassMatrixViaInverseDynamics()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CalcMassMatrixViaInverseDynamics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the mass matrix <span class="tt">M(q)</span> of the model using a slow method (inverse dynamics). </p>
<p>The generalized positions q are taken from the given <span class="tt">context</span>. M includes the mass properties of rigid bodies and <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#reflected_inertia">reflected inertias</a> as provided with <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a> specifications.</p>
<p>Use <a class="el" href="#a1ba9332d8937729be136b54c8adc8b19" title="Efficiently computes the mass matrix M(q) of the model.">CalcMassMatrix()</a> for a faster implementation using the Composite Body Algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The Context containing the state of the model from which generalized coordinates q are extracted. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td>A pointer to a square matrix in <span class="tt">ℛⁿˣⁿ</span> with n the number of generalized velocities (<a class="el" href="#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a>) of the model. Although symmetric, the matrix is filled in completely on return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>M is non-null and has the right size.</dd></dl>
<p>The algorithm used to build <span class="tt">M(q)</span> consists in computing one column of <span class="tt">M(q)</span> at a time using inverse dynamics. The result from inverse dynamics, with no applied forces, is the vector of generalized forces: </p><pre>
  tau = M(q)v̇ + C(q, v)v
</pre><p> where q and v are the generalized positions and velocities, respectively. When <span class="tt">v = 0</span> the Coriolis and gyroscopic forces term <span class="tt">C(q, v)v</span> is zero. Therefore the <span class="tt">i-th</span> column of <span class="tt">M(q)</span> can be obtained performing inverse dynamics with an acceleration vector <span class="tt">v̇ = eᵢ</span>, with <span class="tt">eᵢ</span> the standard (or natural) basis of <span class="tt">ℛⁿ</span> with n the number of generalized velocities. We write this as: </p><pre>
  M.ᵢ(q) = M(q) * e_i
</pre><p> where <span class="tt">M.ᵢ(q)</span> (notice the dot for the rows index) denotes the <span class="tt">i-th</span> column in M(q).</p>
<dl class="section warning"><dt>Warning</dt><dd>This is an O(n²) algorithm. Avoid the explicit computation of the mass matrix whenever possible. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1ba9332d8937729be136b54c8adc8b19" title="Efficiently computes the mass matrix M(q) of the model.">CalcMassMatrix()</a>, <a class="el" href="#af3d9f1dfe387a173b84c49a5bbe5a4c2" title="Given the state of this model in context and a known vector of generalized accelerations vdot,...">CalcInverseDynamics()</a> </dd></dl>

</div>
</div>
<a id="a201bed53cf6c1b61a65df508469423fc" name="a201bed53cf6c1b61a65df508469423fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201bed53cf6c1b61a65df508469423fc">&#9670;&#160;</a></span>CalcPointsPositions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CalcPointsPositions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_BQi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>p_AQi</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the positions <span class="tt">p_BQi</span> for a set of points <span class="tt">Qi</span> measured and expressed in a frame B, this method computes the positions <span class="tt">p_AQi(q)</span> of each point <span class="tt">Qi</span> in the set as measured and expressed in another frame A, as a function of the generalized positions q of the model. </p>
<p>Example of usage: Given two points Q0 and Q1 that are fixed to a frame B, the code below calculates their positions from the world frame origin, expressed in the world frame W.</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">int</span> num_position_vectors = 2;</div>
<div class="line"><a class="code hl_typedef" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX&lt;double&gt;</a> p_BQi(3, num_position_vectors);</div>
<div class="line">p_BQi.col(0) = <a class="code hl_typedef" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3&lt;double&gt;</a>(1.1, 2.2, 3.3);</div>
<div class="line">p_BQi.col(1) = <a class="code hl_typedef" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3&lt;double&gt;</a>(-9.8, 7.6, -5.43);</div>
<div class="line"><a class="code hl_typedef" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX&lt;double&gt;</a> p_WQi(3, num_position_vectors);</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1multibody_1_1_frame.html">Frame&lt;double&gt;</a>&amp; frame_W = plant.world_frame();</div>
<div class="line">plant.CalcPointsPositions(*context_, frame_B, p_BQi, frame_W, &amp;p_WQi);</div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_frame_html"><div class="ttname"><a href="classdrake_1_1multibody_1_1_frame.html">drake::multibody::Frame</a></div><div class="ttdoc">Frame is an abstract class representing a material frame (also called a physical frame) of its underl...</div><div class="ttdef"><b>Definition</b> frame.h:52</div></div>
<div class="ttc" id="anamespacedrake_html_a0ad29daab565ce347c4d1c5aae6a76c2"><div class="ttname"><a href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">drake::Vector3</a></div><div class="ttdeci">Eigen::Matrix&lt; Scalar, 3, 1 &gt; Vector3</div><div class="ttdoc">A column vector of size 3, templated on scalar type.</div><div class="ttdef"><b>Definition</b> eigen_types.h:48</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. It stores the generalized positions q of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_B</td><td>The frame B in which the positions <span class="tt">p_BQi</span> of a set of points <span class="tt">Qi</span> are given. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BQi</td><td>The input positions of each point <span class="tt">Qi</span> in frame B. <span class="tt">p_BQi ∈ ℝ³ˣⁿ</span> with <span class="tt">n</span> the number of points in the set. Each column of <span class="tt">p_BQi</span> corresponds to a vector in ℝ³ holding the position of one of the points in the set as measured and expressed in frame B. Each column of p_BQi is a position vector associated with one point Qi, and the number of columns in p_BQi is the number n of points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame A in which it is desired to compute the positions <span class="tt">p_AQi</span> of each point <span class="tt">Qi</span> in the set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_AQi</td><td>The output positions of each point <span class="tt">Qi</span> now computed as measured and expressed in frame A. The output <span class="tt">p_AQi</span> <b>must</b> have the same size as the input <span class="tt">p_BQi</span> or otherwise this method aborts. That is <span class="tt">p_AQi</span> <b>must</b> be in <span class="tt">ℝ³ˣⁿ</span>. Each column of p_AQi is a position vector associated with one point Qi, and the number of columns in p_BQi is the number n of points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Both <span class="tt">p_BQi</span> and <span class="tt">p_AQi</span> must have three rows. Otherwise this method will throw a std::exception. This method also throws a std::exception if <span class="tt">p_BQi</span> and <span class="tt">p_AQi</span> differ in the number of columns. </dd></dl>

</div>
</div>
<a id="a253d10a3004a2ac72cee5404b6192644" name="a253d10a3004a2ac72cee5404b6192644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253d10a3004a2ac72cee5404b6192644">&#9670;&#160;</a></span>CalcPointsVelocities()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CalcPointsVelocities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_BQi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_E</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>v_AQi_E</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a set of n points Qi (i = 0, ... n-1) that are regarded as fixed on a frame B, calculates the velocities v_AQi_E of Qi measured in a frame A and expressed in a frame E. </p>
<p>Example of usage: Given two points Q0 and Q1 that are fixed to a frame B, the code below calculates their velocities measured and expressed in the world frame W.</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">int</span> num_position_vectors = 2;</div>
<div class="line"><a class="code hl_typedef" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX&lt;double&gt;</a> p_BQi(3, num_position_vectors);</div>
<div class="line">p_BQi.col(0) = <a class="code hl_typedef" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3&lt;double&gt;</a>(1.1, 2.2, 3.3);</div>
<div class="line">p_BQi.col(1) = <a class="code hl_typedef" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3&lt;double&gt;</a>(-9.8, 7.6, -5.43);</div>
<div class="line"><a class="code hl_typedef" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX&lt;double&gt;</a> v_WQi_W(3, num_position_vectors);</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1multibody_1_1_frame.html">Frame&lt;double&gt;</a>&amp; frame_W = plant.world_frame();</div>
<div class="line">plant.CalcPointsVelocities(*context_, frame_B, p_BQi, frame_W, frame_W,</div>
<div class="line">                           &amp;v_WQi_W);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Contains the state of the multibody system, including the generalized positions q and the generalized velocities v. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_B</td><td>The frame B in which each point Qi is fixed and whose frame origin Bo is the starting point for position vectors in p_BQi. frame_B is also the expressed-in-frame for position vectors p_BQi. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BQi</td><td>Position vectors from Bo (frame B's origin) to each point Qi (i = 0, ... n-1), expressed in frame B. Each column of p_BQi is a position vector associated with one point Qi, and the number of columns in p_BQi is the number n of points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame in which the velocities are to be measured. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_E</td><td>The frame in which the velocities are to be expressed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v_AQi_E</td><td>The velocities of each point Qi (i = 0, ... n-1) measured in frame A and expressed in frame E. Each column of v_AQi_E is a translational velocity vector associated with one point Qi, and the number of columns in v_AQi_E is the number n of points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if p_BQi and v_AQi_E do not have three rows (are not 3 element vectors) or do not have the same number (n &gt; 0) of columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a370093b8df7b283bd4257493246c9082" name="a370093b8df7b283bd4257493246c9082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370093b8df7b283bd4257493246c9082">&#9670;&#160;</a></span>CalcRelativeRotationMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; CalcRelativeRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_B</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the rotation matrix <span class="tt">R_AB</span> relating frame A and frame B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The state of the multibody system, which includes the system's generalized positions q. Note: <span class="tt">R_AB</span> is a function of q. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame A designated in the rigid transform <span class="tt">R_AB</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_B</td><td>The frame G designated in the rigid transform <span class="tt">R_AB</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">R_AB</td><td>The RigidTransform relating frame A and frame B. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69e023f53fef5fc02b278a1c8a7b78e5" name="a69e023f53fef5fc02b278a1c8a7b78e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e023f53fef5fc02b278a1c8a7b78e5">&#9670;&#160;</a></span>CalcRelativeTransform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; CalcRelativeTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_B</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the rigid transform (pose) <span class="tt">X_AB</span> relating frame A and frame B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The state of the multibody system, which includes the system's generalized positions q. Note: <span class="tt">X_AB</span> is a function of q. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame A designated in the rigid transform <span class="tt">X_AB</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_B</td><td>The frame G designated in the rigid transform <span class="tt">X_AB</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">X_AB</td><td>The RigidTransform relating frame A and frame B. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a963cde13572c10429e85ba8de00d39e8" name="a963cde13572c10429e85ba8de00d39e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963cde13572c10429e85ba8de00d39e8">&#9670;&#160;</a></span>CalcSpatialAccelerationsFromVdot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CalcSpatialAccelerationsFromVdot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>known_vdot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>A_WB_array</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the state of this model in <span class="tt">context</span> and a known vector of generalized accelerations <span class="tt">known_vdot</span>, this method computes the spatial acceleration <span class="tt">A_WB</span> for each body as measured and expressed in the world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of this model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">known_vdot</td><td>A vector with the generalized accelerations for the full model. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_WB_array</td><td>A pointer to a valid, non nullptr, vector of spatial accelerations containing the spatial acceleration <span class="tt">A_WB</span> for each body. It must be of size equal to the number of bodies in the model. On output, entries will be ordered by <a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c" title="Type used to identify RigidBodies (a.k.a.">BodyIndex</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if A_WB_array is not of size <span class="tt"><a class="el" href="#af92b53211e54243aff4490a700168eb4" title="Returns the number of RigidBody elements in the model, including the &quot;world&quot; RigidBody,...">num_bodies()</a></span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68e79c41979c9448133534e90465b2ec" name="a68e79c41979c9448133534e90465b2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68e79c41979c9448133534e90465b2ec">&#9670;&#160;</a></span>CalcSpatialInertia()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt; CalcSpatialInertia </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_F</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">BodyIndex</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body_indexes</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns M_SFo_F, the spatial inertia of a set S of bodies about point Fo (the origin of a frame F), expressed in frame F. </p>
<p>You may regard M_SFo_F as measuring spatial inertia as if the set S of bodies were welded into a single composite body at the configuration specified in the <span class="tt">context</span>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Contains the configuration of the set S of bodies. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_F</td><td>specifies the about-point Fo (frame_F's origin) and the expressed-in frame for the returned spatial inertia. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">body_indexes</td><td>Array of selected bodies. This method does not distinguish between welded bodies, joint-connected bodies, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if body_indexes contains an invalid <a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c" title="Type used to identify RigidBodies (a.k.a.">BodyIndex</a> or if there is a repeated <a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c" title="Type used to identify RigidBodies (a.k.a.">BodyIndex</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The mass and inertia of the <a class="el" href="#a787a58094e9902e11d3359b54d20eed4" title="Returns a constant reference to the world body.">world_body()</a> does not contribute to the the returned spatial inertia. </dd></dl>

</div>
</div>
<a id="abf96d385be1144f2100b29c3e5ef7311" name="abf96d385be1144f2100b29c3e5ef7311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf96d385be1144f2100b29c3e5ef7311">&#9670;&#160;</a></span>CalcSpatialMomentumInWorldAboutPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_momentum.html">SpatialMomentum</a>&lt; T &gt; CalcSpatialMomentumInWorldAboutPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>model_instances</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_WoP_W</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method returns the spatial momentum of a set of model instances in the world frame W, about a designated point P, expressed in frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Contains the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_instances</td><td>Set of selected model instances. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_WoP_W</td><td>Position from Wo (origin of the world frame W) to an arbitrary point P, expressed in the world frame W. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">L_WSP_W,spatial</td><td>momentum of the system S represented by the model_instances, measured in world frame W, about point P, expressed in W. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>To calculate the spatial momentum of this system S in W about Scm (the system's center of mass), use something like: <pre>
  MultibodyPlant&lt;T&gt; plant;
  // ... code to create a set of selected model instances, e.g., ...
  const <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0" title="Type used to identify model instances by index within a multibody plant.">ModelInstanceIndex</a> gripper_model_instance =
    plant.GetModelInstanceByName("gripper");
  const <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0" title="Type used to identify model instances by index within a multibody plant.">ModelInstanceIndex</a> robot_model_instance =
    plant.GetBodyByName("end_effector").model_instance();
  const std::vector&lt;ModelInstanceIndex&gt; model_instances{
    gripper_model_instance, robot_model_instance};
  const <a class="el" href="class_vector3_3_01_t_01_4.html">Vector3&lt;T&gt;</a> p_WoScm_W =
    plant.CalcCenterOfMassPositionInWorld(context, model_instances);
  <a class="el" href="classdrake_1_1multibody_1_1_spatial_momentum.html" title="This class represents a spatial momentum L and has 6 elements with an angular (rotational) momentum 𝐡...">SpatialMomentum&lt;T&gt;</a> L_WScm_W =
    plant.CalcSpatialMomentumInWorldAboutPoint(context, model_instances,
                                               p_WoScm_W);
</pre> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if model_instances contains an invalid <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0" title="Type used to identify model instances by index within a multibody plant.">ModelInstanceIndex</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2999dec61302bb9a2db8f79e1a6d7413" name="a2999dec61302bb9a2db8f79e1a6d7413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2999dec61302bb9a2db8f79e1a6d7413">&#9670;&#160;</a></span>CalcSpatialMomentumInWorldAboutPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_momentum.html">SpatialMomentum</a>&lt; T &gt; CalcSpatialMomentumInWorldAboutPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_WoP_W</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method returns the spatial momentum of <span class="tt">this</span> <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> in the world frame W, about a designated point P, expressed in the world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Contains the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_WoP_W</td><td>Position from Wo (origin of the world frame W) to an arbitrary point P, expressed in the world frame W. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">L_WSP_W,spatial</td><td>momentum of the system S represented by <span class="tt">this</span> plant, measured in the world frame W, about point P, expressed in W. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>To calculate the spatial momentum of this system S in W about Scm (the system's center of mass), use something like: <pre>
  MultibodyPlant&lt;T&gt; plant;
  // ... code to load a model ....
  const <a class="el" href="class_vector3_3_01_t_01_4.html">Vector3&lt;T&gt;</a> p_WoScm_W =
    plant.CalcCenterOfMassPositionInWorld(context);
  const <a class="el" href="classdrake_1_1multibody_1_1_spatial_momentum.html" title="This class represents a spatial momentum L and has 6 elements with an angular (rotational) momentum 𝐡...">SpatialMomentum&lt;T&gt;</a> L_WScm_W =
    plant.CalcSpatialMomentumInWorldAboutPoint(context, p_WoScm_W);
</pre> </dd></dl>

</div>
</div>
<a id="ac35cf69a93ae82995b04772a811f9870" name="ac35cf69a93ae82995b04772a811f9870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac35cf69a93ae82995b04772a811f9870">&#9670;&#160;</a></span>CalcTotalMass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T CalcTotalMass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the total mass of all bodies in this <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Contains the state of the model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>total mass of all bodies or 0 if there are none. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The mass of the <a class="el" href="#a787a58094e9902e11d3359b54d20eed4" title="Returns a constant reference to the world body.">world_body()</a> does not contribute to the total mass. </dd></dl>

</div>
</div>
<a id="acffd2e6a48e88f9c1b2f561f7dec2135" name="acffd2e6a48e88f9c1b2f561f7dec2135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acffd2e6a48e88f9c1b2f561f7dec2135">&#9670;&#160;</a></span>CalcTotalMass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T CalcTotalMass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>model_instances</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the total mass of all bodies contained in model_instances. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Contains the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_instances</td><td><a class="el" href="namespacedrake.html#a01ae662d5635b7c9efe03d15d976f7a8" title="A column vector templated on the number of rows.">Vector</a> of selected model instances. This method does not distinguish between welded, joint connected, or floating bodies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>total mass of all bodies belonging to a model instance in model_instances or 0 if model_instances is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The mass of the <a class="el" href="#a787a58094e9902e11d3359b54d20eed4" title="Returns a constant reference to the world body.">world_body()</a> does not contribute to the total mass and each body only contributes to the total mass once, even if the body has repeated occurrence (instance) in model_instances. </dd></dl>

</div>
</div>
<a id="a2822cd320f693cd2191fbcdd6dba2494" name="a2822cd320f693cd2191fbcdd6dba2494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2822cd320f693cd2191fbcdd6dba2494">&#9670;&#160;</a></span>CollectRegisteredGeometries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_set.html">geometry::GeometrySet</a> CollectRegisteredGeometries </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bodies</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each of the provided <span class="tt">bodies</span>, collects up all geometries that have been registered to that body. </p>
<p>Intended to be used in conjunction with CollisionFilterDeclaration and CollisionFilterManager::Apply() to filter collisions between the geometries registered to the bodies.</p>
<p>For example: </p><div class="fragment"><div class="line"><span class="comment">// Don&#39;t report on collisions between geometries affixed to `body1`,</span></div>
<div class="line"><span class="comment">// `body2`, or `body3`.</span></div>
<div class="line">std::vector&lt;const RigidBody&lt;T&gt;*&gt; bodies{&amp;body1, &amp;body2, &amp;body3};</div>
<div class="line"><a class="code hl_class" href="classdrake_1_1geometry_1_1_geometry_set.html">geometry::GeometrySet</a> set = plant.CollectRegisteredGeometries(bodies);</div>
<div class="line">scene_graph.collision_filter_manager().Apply(</div>
<div class="line">    CollisionFilterDeclaration().ExcludeWithin(set));</div>
<div class="ttc" id="aclassdrake_1_1geometry_1_1_geometry_set_html"><div class="ttname"><a href="classdrake_1_1geometry_1_1_geometry_set.html">drake::geometry::GeometrySet</a></div><div class="ttdoc">The GeometrySet, as its name implies, is a convenience class for defining a set of geometries.</div><div class="ttdef"><b>Definition</b> geometry_set.h:36</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>There is a <em>very</em> specific order of operations:</dd></dl>
<ol type="1">
<li>Bodies and geometries must be added to the MultibodyPlant.</li>
<li>Create GeometrySet instances from bodies (via this method).</li>
<li>Invoke SceneGraph::ExcludeCollisions*() to filter collisions.</li>
<li>Allocate context.</li>
</ol>
<p>Changing the order will cause exceptions to be thrown.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">this</span> MultibodyPlant was not registered with a SceneGraph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e04d949f2b755579ea4af5adc195546" name="a2e04d949f2b755579ea4af5adc195546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e04d949f2b755579ea4af5adc195546">&#9670;&#160;</a></span>deformable_model()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_deformable_model.html">DeformableModel</a>&lt; T &gt; &amp; deformable_model </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classdrake_1_1multibody_1_1_deformable_model.html" title="DeformableModel implements the interface in PhysicalModel and provides the functionalities to specify...">DeformableModel</a> owned by this plant. </p>
<dl class="section warning"><dt>Warning</dt><dd>This feature is considered to be <b>experimental</b> and may change or be removed at any time, without any deprecation notice ahead of time. </dd></dl>

</div>
</div>
<a id="aebb50c01460083966268609d9309dbb2" name="aebb50c01460083966268609d9309dbb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb50c01460083966268609d9309dbb2">&#9670;&#160;</a></span>EvalBlockSystemJacobian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; Eigen::MatrixX&lt; T &gt; &gt; &amp; EvalBlockSystemJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Returns the System Jacobian Jv_V_WB(q) in block form. </p>
<p>Each block is dense and corresponds to one Tree of the as-built internal::SpanningForest. The blocks follow the Tree ordering defined by the SpanningForest, so are in TreeIndex order. The block for Treeᵢ is a <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95" title="A matrix of dynamic size, templated on scalar type.">MatrixX</a> of size 6nᵢ x mᵢ, where nᵢ is the number of mobilized bodies in Treeᵢ and mᵢ is the total number of mobilizer velocity degrees of freedom (mobilities) in the Tree. Every Tree has an entry even if it has no mobilities (in that case mᵢ=0). World is not part of any Tree so there is no block corresponding to World here.</p>
<p>To be precise: the iᵗʰ block Jvi_V_WB ≡ ∂Vi_WB/∂vᵢ where Vi_WB is the stacked spatial velocities for each mobilized body in Treeᵢ (in order of MobodIndex), and vᵢ is the vector of generalized velocities associated with those mobilized bodies, in the same order. Thus Jvi_V_WB⋅v for some set of mᵢ generalized velocities v, returns the spatial velocities for each body in Treeᵢ that would result from velocities v.</p>
<p>Note that locking and unlocking mobilizers does not affect the Jacobian; the Jacobian reflects what would happen if a velocity variable changed regardless of whether it can currently do so. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a206be3cb8c5909f50bcc671b7bedaa13" title="For one point Bp fixed/welded to a frame B, calculates J𝑠_V_ABp, Bp&#39;s spatial velocity Jacobian in fr...">CalcJacobianSpatialVelocity()</a>, <a class="el" href="#a4f6239b2ed3aeda23fb3d75194c84715" title="(Internal use only) Evaluates the block system Jacobian, then uses it to fill in an equivalent full m...">CalcFullSystemJacobian()</a> </dd></dl>

</div>
</div>
<a id="a08a04a92064da4bf2b791b09e7da5ab7" name="a08a04a92064da4bf2b791b09e7da5ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a04a92064da4bf2b791b09e7da5ab7">&#9670;&#160;</a></span>EvalBodyPoseInWorld()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp; EvalBodyPoseInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body_B</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the pose <span class="tt">X_WB</span> of a body B in the world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context storing the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">body_B</td><td>The body B for which the pose is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">X_WB</td><td>The pose of body frame B in the world frame W. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> was not called on <span class="tt">this</span> model or if <span class="tt">body_B</span> does not belong to this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae663a7a52206ea41f2520ec926bd2cb2" name="ae663a7a52206ea41f2520ec926bd2cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae663a7a52206ea41f2520ec926bd2cb2">&#9670;&#160;</a></span>EvalBodySpatialAccelerationInWorld()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt; &amp; EvalBodySpatialAccelerationInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body_B</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates A_WB, body B's spatial acceleration in the world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context storing the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">body_B</td><td>The body for which spatial acceleration is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">A_WB_W</td><td><a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a> B's spatial acceleration in the world frame W, expressed in W (for point Bo, the body's origin). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> was not called on <span class="tt">this</span> model or if <span class="tt">body_B</span> does not belong to this model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When cached values are out of sync with the state stored in context, this method performs an expensive forward dynamics computation, whereas once evaluated, successive calls to this method are inexpensive. </dd></dl>

</div>
</div>
<a id="ac926d8ffaa1eab38a3ba38875d11b584" name="ac926d8ffaa1eab38a3ba38875d11b584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac926d8ffaa1eab38a3ba38875d11b584">&#9670;&#160;</a></span>EvalBodySpatialVelocityInWorld()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp; EvalBodySpatialVelocityInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body_B</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates V_WB, body B's spatial velocity in the world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context storing the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">body_B</td><td>The body B for which the spatial velocity is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">V_WB_W</td><td><a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a> B's spatial velocity in the world frame W, expressed in W (for point Bo, the body's origin). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> was not called on <span class="tt">this</span> model or if <span class="tt">body_B</span> does not belong to this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a591a2dced3f64a85456b9b0eed50807c" name="a591a2dced3f64a85456b9b0eed50807c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591a2dced3f64a85456b9b0eed50807c">&#9670;&#160;</a></span>EvalSceneGraphInspector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html">geometry::SceneGraphInspector</a>&lt; T &gt; &amp; EvalSceneGraphInspector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the inspector from the <span class="tt">context</span> for the SceneGraph associated with this plant, via this plant's "geometry_query" input port. </p>
<p>(In the future, the inspector might come from a different context source that is more efficient than the "geometry_query" input port.) </p>

</div>
</div>
<a id="a41edc1b3c920a1e48f27ad5661584fad" name="a41edc1b3c920a1e48f27ad5661584fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41edc1b3c920a1e48f27ad5661584fad">&#9670;&#160;</a></span>ExcludeCollisionGeometriesWithCollisionFilterGroupPair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ExcludeCollisionGeometriesWithCollisionFilterGroupPair </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; std::string, <a class="el" href="classdrake_1_1geometry_1_1_geometry_set.html">geometry::GeometrySet</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>collision_filter_group_a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::string, <a class="el" href="classdrake_1_1geometry_1_1_geometry_set.html">geometry::GeometrySet</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>collision_filter_group_b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Excludes the collision geometries between two given collision filter groups. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="#a4a6d28ce9c8119bee923e827eb6f02ed" title="Registers this plant to serve as a source for an instance of SceneGraph.">RegisterAsSourceForSceneGraph()</a> has been called. </dd>
<dd>
<a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> has <em>not</em> been called. </dd></dl>

</div>
</div>
<a id="a8fee61d7a783cade1a3d07fe86284d27" name="a8fee61d7a783cade1a3d07fe86284d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fee61d7a783cade1a3d07fe86284d27">&#9670;&#160;</a></span>Finalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Finalize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method must be called after all elements in the model (joints, bodies, force elements, constraints, etc.) are added and before any computations are performed. </p>
<p>It essentially compiles all the necessary "topological information", i.e. how bodies, joints and, any other elements connect with each other, and performs all the required pre-processing to enable computations at a later stage.</p>
<p>If the finalize stage is successful, the topology of this MultibodyPlant is valid, meaning that the topology is up-to-date after this call. No more multibody elements can be added after a call to <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>.</p>
<p>At <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>, state and input/output ports for <span class="tt">this</span> plant are declared.</p>
<p>For a full account of the effects of <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>, see <a class="el" href="#mbp_finalize_stage">Finalize() stage</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#acf7bb2a3531c09a97fb3623ac582d840" title="Returns true if this MultibodyPlant was finalized with a call to Finalize().">is_finalized()</a>, <a class="el" href="#mbp_finalize_stage">Finalize() stage</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the MultibodyPlant has already been finalized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afad783d7e7e513feb7a73384c8080041" name="afad783d7e7e513feb7a73384c8080041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad783d7e7e513feb7a73384c8080041">&#9670;&#160;</a></span>geometry_source_is_registered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool geometry_source_is_registered </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if <span class="tt">this</span> MultibodyPlant was registered with a SceneGraph. </p>
<p>This method can be called at any time during the lifetime of <span class="tt">this</span> plant to query if <span class="tt">this</span> plant has been registered with a SceneGraph, either pre- or post-finalize, see <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </p>

</div>
</div>
<a id="a69ef9262ffab02b34bdf20449aab7551" name="a69ef9262ffab02b34bdf20449aab7551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ef9262ffab02b34bdf20449aab7551">&#9670;&#160;</a></span>get_actuation_input_port() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt; T &gt; &amp; get_actuation_input_port </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the input port for external actuation for all actuated dofs. </p>
<p>This input port is a vector valued port and can be set with <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#a696b1b608eda0468e220670462d2ed5d" title="Given the actuation values u_actuator for this actuator, updates the actuation vector u for the entir...">JointActuator::set_actuation_vector()</a>. The actuation value for a particular actuator can be found at offset <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#a42d883dde11e65819319f8060b0843b4" title="Returns the index to the first element for this joint actuator / within the vector of actuation input...">JointActuator::input_start()</a> in this vector. Refer to <a class="el" href="#mbp_actuation">Actuation</a> for further details. </p><dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> was already called on <span class="tt">this</span> plant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called before <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a776f6189a7a33efee4aed2a9135f5150" name="a776f6189a7a33efee4aed2a9135f5150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776f6189a7a33efee4aed2a9135f5150">&#9670;&#160;</a></span>get_actuation_input_port() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt; T &gt; &amp; get_actuation_input_port </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the input port for external actuation for a specific model instance. </p>
<p>This is a vector valued port with entries ordered by monotonically increasing <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> within <span class="tt">model_instance</span>. Refer to <a class="el" href="#mbp_actuation">Actuation</a> for further details.</p>
<p>Every model instance in <span class="tt">this</span> plant model has an actuation input port, even if zero sized (for model instance with no actuators).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a14c63996575e6bf19290129d32d079cc" title="Returns a list of all joint actuator indices.">GetJointActuatorIndices()</a>, <a class="el" href="#a9f04d3a518de759ddd20257be50073cc" title="Returns a list of actuated joint indices associated with model_instance.">GetActuatedJointIndices()</a>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> was already called on <span class="tt">this</span> plant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called before <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the model instance does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14ad3e6c2aa8d6de728ee3552260f428" name="a14ad3e6c2aa8d6de728ee3552260f428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ad3e6c2aa8d6de728ee3552260f428">&#9670;&#160;</a></span>get_adjacent_bodies_collision_filters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool get_adjacent_bodies_collision_filters </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether to apply collision filters to topologically adjacent bodies at <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> time. </p>

</div>
</div>
<a id="a1a18f3e06640387dc4fe29c1e0c2d80b" name="a1a18f3e06640387dc4fe29c1e0c2d80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a18f3e06640387dc4fe29c1e0c2d80b">&#9670;&#160;</a></span>get_applied_generalized_force_input_port()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt; T &gt; &amp; get_applied_generalized_force_input_port </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the vector-valued input port for applied generalized forces, and the vector will be added directly into <span class="tt">tau</span> (see <a class="el" href="#mbp_equations_of_motion">System dynamics</a>). </p>
<p>This vector is ordered using the same convention as the plant velocities: you can set the generalized forces that will be applied to model instance i using, e.g., <span class="tt"><a class="el" href="#a89105b866dae232e6a9236d50f1fb08c" title="Sets the vector of generalized velocities for model_instance in v using v_instance,...">SetVelocitiesInArray</a>(i, model_forces, &amp;force_array)</span>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called before <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a241c6a79cee07ffff3eaac93f47947c8" name="a241c6a79cee07ffff3eaac93f47947c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241c6a79cee07ffff3eaac93f47947c8">&#9670;&#160;</a></span>get_applied_spatial_force_input_port()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt; T &gt; &amp; get_applied_spatial_force_input_port </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the input port for applying spatial forces to bodies in the plant. </p>
<p>The data type for the port is an std::vector of <a class="el" href="structdrake_1_1multibody_1_1_externally_applied_spatial_force.html">ExternallyAppliedSpatialForce</a>; any number of spatial forces can be applied to any number of bodies in the plant. </p>

</div>
</div>
<a id="a8989c7aebeff42590d79635c9ba28132" name="a8989c7aebeff42590d79635c9ba28132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8989c7aebeff42590d79635c9ba28132">&#9670;&#160;</a></span>get_ball_constraint_specs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a>, internal::BallConstraintSpec &gt; &amp; get_ball_constraint_specs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Returns a reference to all of the ball constraints in this plant as a map from <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a" title="Type used to identify constraint by id within a multibody plant.">MultibodyConstraintId</a> to BallConstraintSpec. </p>

</div>
</div>
<a id="abd9a0ed88db25f4ee242584c42b401eb" name="abd9a0ed88db25f4ee242584c42b401eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9a0ed88db25f4ee242584c42b401eb">&#9670;&#160;</a></span>get_ball_constraint_specs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const internal::BallConstraintSpec &amp; get_ball_constraint_specs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Returns the ball constraint specification corresponding to <span class="tt">id</span> </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><span class="tt">id</span> is not a valid identifier for a ball constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2392f1b869287db1ea1a39183a4d23bf" name="a2392f1b869287db1ea1a39183a4d23bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2392f1b869287db1ea1a39183a4d23bf">&#9670;&#160;</a></span>get_body()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp; get_body </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">BodyIndex</a></td>          <td class="paramname"><span class="paramname"><em>body_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the body with unique index <span class="tt">body_index</span>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">body_index</span> does not correspond to a body in this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a120e794678007aaf5494894806ce3e6f" name="a120e794678007aaf5494894806ce3e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120e794678007aaf5494894806ce3e6f">&#9670;&#160;</a></span>get_body_poses_output_port()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp; get_body_poses_output_port </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the output port of all body poses in the world frame. </p>
<p>You can obtain the pose <span class="tt">X_WB</span> of a body B in the world frame W with: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; X_WB_all = plant.get_body_poses_output_port().</div>
<div class="line">    .Eval&lt;std::vector&lt;math::RigidTransform&lt;double&gt;&gt;&gt;(plant_context);</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_typedef" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">BodyIndex</a> arm_body_index = plant.GetBodyByName(<span class="stringliteral">&quot;arm&quot;</span>).index();</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform&lt;double&gt;</a>&amp; X_WArm = X_WB_all[arm_body_index];</div>
<div class="ttc" id="aclassdrake_1_1math_1_1_rigid_transform_html"><div class="ttname"><a href="classdrake_1_1math_1_1_rigid_transform.html">drake::math::RigidTransform</a></div><div class="ttdoc">This class represents a proper rigid transform between two frames which can be regarded in two ways.</div><div class="ttdef"><b>Definition</b> rigid_transform.h:73</div></div>
<div class="ttc" id="anamespacedrake_1_1multibody_html_a02d233e6f0ef016f5cf02e2222a22f5c"><div class="ttname"><a href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">drake::multibody::BodyIndex</a></div><div class="ttdeci">TypeSafeIndex&lt; class RigidBodyTag &gt; BodyIndex</div><div class="ttdoc">Type used to identify RigidBodies (a.k.a.</div><div class="ttdef"><b>Definition</b> multibody_tree_indexes.h:36</div></div>
</div><!-- fragment --><p> As shown in the example above, the resulting <span class="tt">std::vector</span> of body poses is indexed by <a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c" title="Type used to identify RigidBodies (a.k.a.">BodyIndex</a>, and it has size <a class="el" href="#af92b53211e54243aff4490a700168eb4" title="Returns the number of RigidBody elements in the model, including the &quot;world&quot; RigidBody,...">num_bodies()</a>. <a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c" title="Type used to identify RigidBodies (a.k.a.">BodyIndex</a> "zero" (0) always corresponds to the world body, with pose equal to the identity at all times. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a482d55aca3da9ee3786b507c9c964b40" name="a482d55aca3da9ee3786b507c9c964b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482d55aca3da9ee3786b507c9c964b40">&#9670;&#160;</a></span>get_body_spatial_accelerations_output_port()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp; get_body_spatial_accelerations_output_port </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the output port of all body spatial accelerations in the world frame. </p>
<p>You can obtain the spatial acceleration <span class="tt">A_WB</span> of a body B (for point Bo, the body's origin) in the world frame W with: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; A_WB_all =</div>
<div class="line">plant.get_body_spatial_accelerations_output_port().</div>
<div class="line">    .Eval&lt;std::vector&lt;SpatialAcceleration&lt;double&gt;&gt;&gt;(plant_context);</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_typedef" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">BodyIndex</a> arm_body_index = plant.GetBodyByName(<span class="stringliteral">&quot;arm&quot;</span>).index();</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity&lt;double&gt;</a>&amp; A_WArm = A_WB_all[arm_body_index];</div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_spatial_velocity_html"><div class="ttname"><a href="classdrake_1_1multibody_1_1_spatial_velocity.html">drake::multibody::SpatialVelocity</a></div><div class="ttdoc">This class represents a spatial velocity V (also called a twist) and has 6 elements with an angular (...</div><div class="ttdef"><b>Definition</b> spatial_velocity.h:40</div></div>
</div><!-- fragment --><p> As shown in the example above, the resulting <span class="tt">std::vector</span> of body spatial accelerations is indexed by <a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c" title="Type used to identify RigidBodies (a.k.a.">BodyIndex</a>, and it has size <a class="el" href="#af92b53211e54243aff4490a700168eb4" title="Returns the number of RigidBody elements in the model, including the &quot;world&quot; RigidBody,...">num_bodies()</a>. <a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c" title="Type used to identify RigidBodies (a.k.a.">BodyIndex</a> "zero" (0) always corresponds to the world body, with zero spatial acceleration at all times.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects the output of this port. See <a class="el" href="#output_port_sampling">Output port sampling</a> for details. When sampling is enabled and the plant has not yet taken a step, the output value will be all zeros.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f76813ea964f4c30e21bb841c182a0c" name="a5f76813ea964f4c30e21bb841c182a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f76813ea964f4c30e21bb841c182a0c">&#9670;&#160;</a></span>get_body_spatial_velocities_output_port()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp; get_body_spatial_velocities_output_port </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the output port of all body spatial velocities in the world frame. </p>
<p>You can obtain the spatial velocity <span class="tt">V_WB</span> of a body B in the world frame W with: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; V_WB_all = plant.get_body_spatial_velocities_output_port().</div>
<div class="line">    .Eval&lt;std::vector&lt;SpatialVelocity&lt;double&gt;&gt;&gt;(plant_context);</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_typedef" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">BodyIndex</a> arm_body_index = plant.GetBodyByName(<span class="stringliteral">&quot;arm&quot;</span>).index();</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity&lt;double&gt;</a>&amp; V_WArm = V_WB_all[arm_body_index];</div>
</div><!-- fragment --><p> As shown in the example above, the resulting <span class="tt">std::vector</span> of body spatial velocities is indexed by <a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c" title="Type used to identify RigidBodies (a.k.a.">BodyIndex</a>, and it has size <a class="el" href="#af92b53211e54243aff4490a700168eb4" title="Returns the number of RigidBody elements in the model, including the &quot;world&quot; RigidBody,...">num_bodies()</a>. <a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c" title="Type used to identify RigidBodies (a.k.a.">BodyIndex</a> "zero" (0) always corresponds to the world body, with zero spatial velocity at all times. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94d1093944c929bd5ca5322836b91bd4" name="a94d1093944c929bd5ca5322836b91bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d1093944c929bd5ca5322836b91bd4">&#9670;&#160;</a></span>get_contact_model()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4e">ContactModel</a> get_contact_model </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the model used for contact. See documentation for <a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4e" title="Enumeration for contact model options.">ContactModel</a>. </p>

</div>
</div>
<a id="a3338392f611d5d9f93d0ea90e172c68c" name="a3338392f611d5d9f93d0ea90e172c68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3338392f611d5d9f93d0ea90e172c68c">&#9670;&#160;</a></span>get_contact_penalty_method_time_scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> get_contact_penalty_method_time_scale </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a time-scale estimate <span class="tt">tc</span> based on the requested penetration allowance δ set with <a class="el" href="#a1e5e058b968b927f6342a8127aea663a" title="Sets a penetration allowance used to estimate the point contact stiffness and Hunt &amp; Crossley dissipa...">set_penetration_allowance()</a>. </p>
<p>For the compliant contact model to enforce non-penetration, this time scale relates to the time it takes the relative normal velocity between two bodies to go to zero. This time scale <span class="tt">tc</span> is a global estimate of the dynamics introduced by the compliant contact model and goes to zero in the limit to ideal rigid contact. Since numerical integration methods for continuum systems must be able to resolve a system's dynamics, the time step used by an integrator must in general be much smaller than the time scale <span class="tt">tc</span>. How much smaller will depend on the details of the problem and the convergence characteristics of the integrator and should be tuned appropriately. Another factor to take into account for setting up the simulation's time step is the speed of the objects in your simulation. If <span class="tt">vn</span> represents a reference velocity scale for the normal relative velocity between bodies, the new time scale <span class="tt">tn = δ / vn</span> represents the time it would take for the distance between two bodies approaching with relative normal velocity <span class="tt">vn</span> to decrease by the penetration_allowance δ. In this case a user should choose a time step for simulation that can resolve the smallest of the two time scales <span class="tt">tc</span> and <span class="tt">tn</span>. </p>

</div>
</div>
<a id="a38514bf9e20aa4b85ad82a0a2009a65f" name="a38514bf9e20aa4b85ad82a0a2009a65f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38514bf9e20aa4b85ad82a0a2009a65f">&#9670;&#160;</a></span>get_contact_results_output_port()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp; get_contact_results_output_port </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the port that outputs <a class="el" href="classdrake_1_1multibody_1_1_contact_results.html" title="A container class storing the contact results information for each contact pair for a given state of ...">ContactResults</a>. </p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects the output of this port. See <a class="el" href="#output_port_sampling">Output port sampling</a> for details. When sampling is enabled and the plant has not yet taken a step, the output value will be empty (no contacts).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize, see <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b82332abfb08a94d367659c3f566e21" name="a2b82332abfb08a94d367659c3f566e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b82332abfb08a94d367659c3f566e21">&#9670;&#160;</a></span>get_contact_surface_representation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1geometry.html#a227f80cb57c9c87f6ecc4e839e364979">geometry::HydroelasticContactRepresentation</a> get_contact_surface_representation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current representation of contact surfaces used by <span class="tt">this</span> MultibodyPlant. </p>

</div>
</div>
<a id="a88a57e0ca8c75b5fe55e0d87d7118fc5" name="a88a57e0ca8c75b5fe55e0d87d7118fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a57e0ca8c75b5fe55e0d87d7118fc5">&#9670;&#160;</a></span>get_coupler_constraint_specs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a>, internal::CouplerConstraintSpec &gt; &amp; get_coupler_constraint_specs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Returns a reference to the all of the coupler constraints in this plant as a map from <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a" title="Type used to identify constraint by id within a multibody plant.">MultibodyConstraintId</a> to CouplerConstraintSpec. </p>

</div>
</div>
<a id="ac6c3a91f336442760368c29976f8e65e" name="ac6c3a91f336442760368c29976f8e65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c3a91f336442760368c29976f8e65e">&#9670;&#160;</a></span>get_coupler_constraint_specs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const internal::CouplerConstraintSpec &amp; get_coupler_constraint_specs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Returns the coupler constraint specification corresponding to <span class="tt">id</span> </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><span class="tt">id</span> is not a valid identifier for a coupler constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c99a1da019a96da8acdad8b06727280" name="a7c99a1da019a96da8acdad8b06727280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c99a1da019a96da8acdad8b06727280">&#9670;&#160;</a></span>get_deformable_body_configuration_output_port()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp; get_deformable_body_configuration_output_port </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the output port for vertex positions (configurations), measured and expressed in the World frame, of the deformable bodies in <span class="tt">this</span> plant as a GeometryConfigurationVector. </p>

</div>
</div>
<a id="acb103492157aa5e69843c22c394d1de5" name="acb103492157aa5e69843c22c394d1de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb103492157aa5e69843c22c394d1de5">&#9670;&#160;</a></span>get_desired_state_input_port()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt; T &gt; &amp; get_desired_state_input_port </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For models with PD controlled joint actuators, returns the port to provide the desired state for the given <span class="tt">model_instance</span>. </p>
<p>Refer to <a class="el" href="#mbp_actuation">Actuation</a> for further details.</p>
<p>For consistency with <a class="el" href="#a69ef9262ffab02b34bdf20449aab7551" title="Returns a constant reference to the input port for external actuation for all actuated dofs.">get_actuation_input_port()</a>, each model instance in <span class="tt">this</span> plant model has a desired states input port, even if zero sized (for model instance with no actuators.)</p>
<dl class="section note"><dt>Note</dt><dd>This port always has size 2 * num_actuators(model_instance), where we assume 1-DOF actuated joints. This port must provide one desired position and one desired velocity per joint actuator, packed as xd = [qd, vd], with positions and velocities in order of increasing <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c" title="Type used to identify actuators by index within a multibody plant.">JointActuatorIndex</a>. Only desired states corresponding to PD-controlled actuators on non-locked joints (<a class="el" href="classdrake_1_1multibody_1_1_joint.html#a0c0fd3c2e27243de55385f4f9695fc0e">Joint::is_locked()</a>) are used, the rest are ignored. That is PD control on just a subset of actuators is allowed.</dd>
<dd>
The desired state input port for a given model instance is not required to be connected. If disconnected, the controllers for such model instance will be <em>disarmed</em>. Refer to <a class="el" href="#pd_controllers_and_ports">pd_controllers_and_ports</a> for further details.</dd></dl>
<p>As an example of this structure, consider the following code to fix desired states input values: </p><div class="fragment"><div class="line"><a class="code hl_friend" href="#a47a63154823dffd5838329527aafbd58">MultibodyPlant&lt;double&gt;</a> plant;</div>
<div class="line"><span class="comment">// ... Load/parse plant model ...</span></div>
<div class="line">plant.<a class="code hl_function" href="#a8fee61d7a783cade1a3d07fe86284d27">Finalize</a>();</div>
<div class="line"><span class="keyword">auto</span> context = plant.<a class="code hl_function" href="classdrake_1_1systems_1_1_system.html#aa036f873464a74c03fab943bbace8942">CreateDefaultContext</a>();</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> num_u = plant.<a class="code hl_function" href="#a8601c026e9807127b4dd41e7585d2cfc">num_actuators</a>(model_instance);</div>
<div class="line"><span class="keyword">const</span> VectorXd model_xd(2 * num_u);</div>
<div class="line"><span class="keyword">auto</span> model_qd = model_xd.head(num_u);</div>
<div class="line"><span class="keyword">auto</span> model_vd = model_xd.tail(num_u);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> a = 0;</div>
<div class="line"><span class="comment">// Specify qd and vd in increasing order of @ref JointActuatorIndex, as</span></div>
<div class="line"><span class="comment">// returned by GetJointActuatorIndices().</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_typedef" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> actuator_index :</div>
<div class="line">    plant.<a class="code hl_function" href="#a14c63996575e6bf19290129d32d079cc">GetJointActuatorIndices</a>(model_instance)) {</div>
<div class="line">  qd[a] = .... desired q value <span class="keywordflow">for</span> actuator_index</div>
<div class="line">  vd[a] = .... desired v value <span class="keywordflow">for</span> actuator_index</div>
<div class="line">  ++a;</div>
<div class="line">}</div>
<div class="line"><span class="comment">// As an example, fix values in the context.</span></div>
<div class="line">plant.<a class="code hl_function" href="#acb103492157aa5e69843c22c394d1de5">get_desired_state_input_port</a>(model_instance).FixValue(</div>
<div class="line">    &amp;plant_context, model_xd);</div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_multibody_plant_html_a14c63996575e6bf19290129d32d079cc"><div class="ttname"><a href="#a14c63996575e6bf19290129d32d079cc">drake::multibody::MultibodyPlant::GetJointActuatorIndices</a></div><div class="ttdeci">const std::vector&lt; JointActuatorIndex &gt; &amp; GetJointActuatorIndices() const</div><div class="ttdoc">Returns a list of all joint actuator indices.</div><div class="ttdef"><b>Definition</b> multibody_plant.h:5373</div></div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_multibody_plant_html_a8601c026e9807127b4dd41e7585d2cfc"><div class="ttname"><a href="#a8601c026e9807127b4dd41e7585d2cfc">drake::multibody::MultibodyPlant::num_actuators</a></div><div class="ttdeci">int num_actuators() const</div><div class="ttdoc">Returns the number of joint actuators in the model.</div><div class="ttdef"><b>Definition</b> multibody_plant.h:5481</div></div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_multibody_plant_html_a8fee61d7a783cade1a3d07fe86284d27"><div class="ttname"><a href="#a8fee61d7a783cade1a3d07fe86284d27">drake::multibody::MultibodyPlant::Finalize</a></div><div class="ttdeci">void Finalize()</div><div class="ttdoc">This method must be called after all elements in the model (joints, bodies, force elements,...</div></div>
<div class="ttc" id="aclassdrake_1_1multibody_1_1_multibody_plant_html_acb103492157aa5e69843c22c394d1de5"><div class="ttname"><a href="#acb103492157aa5e69843c22c394d1de5">drake::multibody::MultibodyPlant::get_desired_state_input_port</a></div><div class="ttdeci">const systems::InputPort&lt; T &gt; &amp; get_desired_state_input_port(ModelInstanceIndex model_instance) const</div><div class="ttdoc">For models with PD controlled joint actuators, returns the port to provide the desired state for the ...</div></div>
<div class="ttc" id="aclassdrake_1_1systems_1_1_system_html_aa036f873464a74c03fab943bbace8942"><div class="ttname"><a href="classdrake_1_1systems_1_1_system.html#aa036f873464a74c03fab943bbace8942">drake::systems::System::CreateDefaultContext</a></div><div class="ttdeci">std::unique_ptr&lt; Context&lt; T &gt; &gt; CreateDefaultContext() const</div><div class="ttdoc">This convenience method allocates a context using AllocateContext() and sets its default values using...</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad9ebfcbe324adb1d8cab32b40e4d53c4" name="ad9ebfcbe324adb1d8cab32b40e4d53c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ebfcbe324adb1d8cab32b40e4d53c4">&#9670;&#160;</a></span>get_discrete_contact_approximation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#aa1d02176591187cb83e77e9ff779d679">DiscreteContactApproximation</a> get_discrete_contact_approximation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the discrete contact solver approximation. </dd></dl>

</div>
</div>
<a id="ad7698366750a09e383106a17bf9009a2" name="ad7698366750a09e383106a17bf9009a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7698366750a09e383106a17bf9009a2">&#9670;&#160;</a></span>get_discrete_contact_solver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#a902306c5e0120a67c07f80e9219a3e8d">DiscreteContactSolver</a> get_discrete_contact_solver </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contact solver type used for discrete MultibodyPlant models. </p>

</div>
</div>
<a id="a1d93303f2e3893f893c3d77cf5df5e49" name="a1d93303f2e3893f893c3d77cf5df5e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d93303f2e3893f893c3d77cf5df5e49">&#9670;&#160;</a></span>get_force_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_force_element.html">ForceElement</a>&lt; T &gt; &amp; get_force_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#add80e949328b179d78312d1455319868">ForceElementIndex</a></td>          <td class="paramname"><span class="paramname"><em>force_element_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the force element with unique index <span class="tt">force_element_index</span>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>when <span class="tt">force_element_index</span> does not correspond to a force element in this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a780fb008e04ccdc170e84938156d0018" name="a780fb008e04ccdc170e84938156d0018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780fb008e04ccdc170e84938156d0018">&#9670;&#160;</a></span>get_frame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp; get_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a></td>          <td class="paramname"><span class="paramname"><em>frame_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the frame with unique index <span class="tt">frame_index</span>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">frame_index</span> does not correspond to a frame in this plant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1aa2696beaffa5645a301f4578776cd8" name="a1aa2696beaffa5645a301f4578776cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa2696beaffa5645a301f4578776cd8">&#9670;&#160;</a></span>get_generalized_acceleration_output_port() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp; get_generalized_acceleration_output_port </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the output port for generalized accelerations v̇ of the model. </p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects the output of this port. See <a class="el" href="#output_port_sampling">Output port sampling</a> for details. When sampling is enabled and the plant has not yet taken a step, the output value will be all zeros.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> was already called on <span class="tt">this</span> plant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called before <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a459ec616a1690ef27fe1b466fa0a46fa" name="a459ec616a1690ef27fe1b466fa0a46fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459ec616a1690ef27fe1b466fa0a46fa">&#9670;&#160;</a></span>get_generalized_acceleration_output_port() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp; get_generalized_acceleration_output_port </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the output port for the generalized accelerations v̇ᵢ ⊆ v̇ for model instance i. </p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects the output of this port. See <a class="el" href="#output_port_sampling">Output port sampling</a> for details. When sampling is enabled and the plant has not yet taken a step, the output value will be all zeros.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> was already called on <span class="tt">this</span> plant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called before <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the model instance does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64b671623de5eecd130ce235995ac320" name="a64b671623de5eecd130ce235995ac320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b671623de5eecd130ce235995ac320">&#9670;&#160;</a></span>get_generalized_contact_forces_output_port()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp; get_generalized_contact_forces_output_port </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the output port of generalized contact forces for a specific model instance. </p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects the output of this port. See <a class="el" href="#output_port_sampling">Output port sampling</a> for details. When sampling is enabled and the plant has not yet taken a step, the output value will be all zeros.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> was already called on <span class="tt">this</span> plant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called before <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the model instance does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a986b7f0917bb20533970dc7658770237" name="a986b7f0917bb20533970dc7658770237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a986b7f0917bb20533970dc7658770237">&#9670;&#160;</a></span>get_geometry_pose_output_port()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp; get_geometry_pose_output_port </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the output port of frames' poses to communicate with a SceneGraph. </p>

</div>
</div>
<a id="a38d417c47f17405fb748b5bb02140bcd" name="a38d417c47f17405fb748b5bb02140bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d417c47f17405fb748b5bb02140bcd">&#9670;&#160;</a></span>get_geometry_query_input_port()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt; T &gt; &amp; get_geometry_query_input_port </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the input port used to perform geometric queries on a SceneGraph. </p>
<p>See SceneGraph::get_query_output_port(). Refer to section <a class="el" href="#mbp_geometry">Geometry</a> of this class's documentation for further details on collision geometry registration and connection with a SceneGraph. </p>

</div>
</div>
<a id="aa5c1504637f1b0c7e455cf5b8b1496d5" name="aa5c1504637f1b0c7e455cf5b8b1496d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c1504637f1b0c7e455cf5b8b1496d5">&#9670;&#160;</a></span>get_joint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp; get_joint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a></td>          <td class="paramname"><span class="paramname"><em>joint_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the joint with unique index <span class="tt">joint_index</span>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>when <span class="tt">joint_index</span> does not correspond to a joint in this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4740af508f2c9ccdb5940698822613ba" name="a4740af508f2c9ccdb5940698822613ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4740af508f2c9ccdb5940698822613ba">&#9670;&#160;</a></span>get_joint_actuator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp; get_joint_actuator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a></td>          <td class="paramname"><span class="paramname"><em>actuator_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the joint actuator with unique index <span class="tt">actuator_index</span>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">actuator_index</span> does not correspond to a joint actuator in this tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a250ff3cf2db7d0c5ef48c94d1a18c332" name="a250ff3cf2db7d0c5ef48c94d1a18c332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250ff3cf2db7d0c5ef48c94d1a18c332">&#9670;&#160;</a></span>get_mutable_joint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp; get_mutable_joint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a></td>          <td class="paramname"><span class="paramname"><em>joint_index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable reference to the joint with unique index <span class="tt">joint_index</span>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>when <span class="tt">joint_index</span> does not correspond to a joint in this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a000f3c038ab3e66c16f2078dde9f9cee" name="a000f3c038ab3e66c16f2078dde9f9cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000f3c038ab3e66c16f2078dde9f9cee">&#9670;&#160;</a></span>get_mutable_joint_actuator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp; get_mutable_joint_actuator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a></td>          <td class="paramname"><span class="paramname"><em>actuator_index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable reference to the joint actuator with unique index <span class="tt">actuator_index</span>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">actuator_index</span> does not correspond to a joint actuator in this tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bd2d6bf64c3bc65af05bdf0b634120e" name="a1bd2d6bf64c3bc65af05bdf0b634120e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd2d6bf64c3bc65af05bdf0b634120e">&#9670;&#160;</a></span>get_net_actuation_output_port() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp; get_net_actuation_output_port </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the output port that reports actuation values applied through joint actuators. </p>
<p>This output port is a vector valued port. The actuation value for a particular actuator can be found at offset <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#a42d883dde11e65819319f8060b0843b4" title="Returns the index to the first element for this joint actuator / within the vector of actuation input...">JointActuator::input_start()</a> in this vector. Models that include PD controllers will include their contribution in this port, refer to <a class="el" href="#mbp_actuation">Actuation</a> for further details.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects the output of this port. See <a class="el" href="#output_port_sampling">Output port sampling</a> for details. When sampling is enabled and the plant has not yet taken a step, the output value will be all zeros.</p>
<dl class="section note"><dt>Note</dt><dd>PD controllers are not considered for actuators on locked joints, see <a class="el" href="classdrake_1_1multibody_1_1_joint.html#a50c7f850050d4a94641ed72dd2d1968f" title="Lock the joint.">Joint::Lock()</a>. Therefore they do not contribute to this port. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> was already called on <span class="tt">this</span> plant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called before <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afcc5bd59fc38539a6388d3a923f01cad" name="afcc5bd59fc38539a6388d3a923f01cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc5bd59fc38539a6388d3a923f01cad">&#9670;&#160;</a></span>get_net_actuation_output_port() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp; get_net_actuation_output_port </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the output port that reports actuation values applied through joint actuators, for a specific model instance. </p>
<p>Models that include PD controllers will include their contribution in this port, refer to <a class="el" href="#mbp_actuation">Actuation</a> for further details. This is a vector valued port with entries ordered by monotonically increasing <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> within <span class="tt">model_instance</span>.</p>
<p>Every model instance in <span class="tt">this</span> plant model has a net actuation output port, even if zero sized (for model instance with no actuators).</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects the output of this port. See <a class="el" href="#output_port_sampling">Output port sampling</a> for details. When sampling is enabled and the plant has not yet taken a step, the output value will be all zeros.</p>
<dl class="section note"><dt>Note</dt><dd>PD controllers are not considered for actuators on locked joints, see <a class="el" href="classdrake_1_1multibody_1_1_joint.html#a50c7f850050d4a94641ed72dd2d1968f" title="Lock the joint.">Joint::Lock()</a>. Therefore they do not contribute to this port. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> was already called on <span class="tt">this</span> plant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called before <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afaa2e09232a83be4836114260b374dfb" name="afaa2e09232a83be4836114260b374dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa2e09232a83be4836114260b374dfb">&#9670;&#160;</a></span>get_reaction_forces_output_port()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp; get_reaction_forces_output_port </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the port for joint reaction forces. </p>
<p>A <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> models the kinematical relationship which characterizes the possible relative motion between two bodies. In Drake, a joint connects a frame <span class="tt">Jp</span> on <em>parent</em> body P with a frame <span class="tt">Jc</span> on a <em>child</em> body C. This usage of the terms <em>parent</em> and <em>child</em> is just a convention and implies nothing about the inboard-outboard relationship between the bodies. Since a <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> imposes a kinematical relationship which characterizes the possible relative motion between frames Jp and Jc, reaction forces on each body are established. That is, we could cut the model at the joint and replace it with equivalent forces equal to these reaction forces in order to attain the same motions of the mechanical system.</p>
<p>This output port allows to evaluate the reaction force <span class="tt">F_CJc_Jc</span> on the <em>child</em> body C, at <span class="tt">Jc</span>, and expressed in Jc for all joints in the model. This port evaluates to a vector of type std::vector&lt;SpatialForce&lt;T&gt;&gt; and size <a class="el" href="#a636804b6c40e538d83d5c2dfefb7929e" title="Returns the number of joints in the model.">num_joints()</a> indexed by <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0" title="Type used to identify joints by index within a multibody plant.">JointIndex</a>, see <a class="el" href="classdrake_1_1multibody_1_1_joint.html#afa899cef34bf7c256f877cc3dc08cb65" title="Returns this element&#39;s unique index.">Joint::index()</a>. Each entry corresponds to the spatial force <span class="tt">F_CJc_Jc</span> applied on the joint's child body C (<a class="el" href="classdrake_1_1multibody_1_1_joint.html#a0eef20ebf8722c46dd275423668541ee" title="Returns a const reference to the child body B.">Joint::child_body()</a>), at the joint's child frame <span class="tt">Jc</span> (<a class="el" href="classdrake_1_1multibody_1_1_joint.html#a917fd98d10c7cfc608ac584cb5a34957" title="Returns a const reference to the frame M attached on the child body B.">Joint::frame_on_child()</a>) and expressed in frame <span class="tt">Jc</span>.</p>
<p>In a discrete-time plant, the use_sampled_output_ports setting affects the output of this port. See <a class="el" href="#output_port_sampling">Output port sampling</a> for details. When sampling is enabled and the plant has not yet taken a step, the output value will be all zeros.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa17b98a3d4e8ab45709c6d462f458933" name="aa17b98a3d4e8ab45709c6d462f458933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17b98a3d4e8ab45709c6d462f458933">&#9670;&#160;</a></span>get_sap_near_rigid_threshold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> get_sap_near_rigid_threshold </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the SAP near rigid regime threshold. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="#a857ba74bdbf10e03cbaf8acbfa4b044b" title="Non-negative dimensionless number typically in the range [0.0, 1.0], though larger values are allowed...">set_sap_near_rigid_threshold()</a>. </dd></dl>

</div>
</div>
<a id="a6e219dfe1b9145c9c244a4195bc382a6" name="a6e219dfe1b9145c9c244a4195bc382a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e219dfe1b9145c9c244a4195bc382a6">&#9670;&#160;</a></span>get_source_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacedrake_1_1geometry.html#ac53cb597123131fb23a7af26e8d350bf">geometry::SourceId</a> &gt; get_source_id </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the unique id identifying <span class="tt">this</span> plant as a source for a SceneGraph. </p>
<p>Returns <span class="tt">nullopt</span> if <span class="tt">this</span> plant did not register any geometry. This method can be called at any time during the lifetime of <span class="tt">this</span> plant to query if <span class="tt">this</span> plant has been registered with a SceneGraph, either pre- or post-finalize, see <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. However, a <a class="el" href="namespacedrake_1_1geometry.html#ac53cb597123131fb23a7af26e8d350bf" title="Type used to identify geometry sources in SceneGraph.">geometry::SourceId</a> is only assigned once at the first call of any of this plant's geometry registration methods, and it does not change after that. Post-finalize calls will always return the same value. </p>

</div>
</div>
<a id="a3c6b13fba0889c4bb9a88610254a387b" name="a3c6b13fba0889c4bb9a88610254a387b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c6b13fba0889c4bb9a88610254a387b">&#9670;&#160;</a></span>get_state_output_port() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp; get_state_output_port </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the output port for the multibody state x = [q, v] of the model. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> was already called on <span class="tt">this</span> plant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called before <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a913ca524f43c5b9ab8273d271b807c22" name="a913ca524f43c5b9ab8273d271b807c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913ca524f43c5b9ab8273d271b807c22">&#9670;&#160;</a></span>get_state_output_port() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp; get_state_output_port </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the output port for the state xᵢ = [qᵢ vᵢ] of model instance i. </p>
<p>(Here qᵢ ⊆ q and vᵢ ⊆ v.) </p><dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> was already called on <span class="tt">this</span> plant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called before <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the model instance does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad729a55177cb828cdc0f1fd990e4b05e" name="ad729a55177cb828cdc0f1fd990e4b05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad729a55177cb828cdc0f1fd990e4b05e">&#9670;&#160;</a></span>get_tendon_constraint_specs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a>, internal::TendonConstraintSpec &gt; &amp; get_tendon_constraint_specs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Returns a reference to the all of the tendon constraints in this plant as a map from <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a" title="Type used to identify constraint by id within a multibody plant.">MultibodyConstraintId</a> to TendonConstraintSpec. </p>

</div>
</div>
<a id="a57d85a2af04011b2f5ec52a68b6a6bee" name="a57d85a2af04011b2f5ec52a68b6a6bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d85a2af04011b2f5ec52a68b6a6bee">&#9670;&#160;</a></span>get_tendon_constraint_specs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const internal::TendonConstraintSpec &amp; get_tendon_constraint_specs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Returns the tendon constraint specification corresponding to <span class="tt">id</span> </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><span class="tt">id</span> is not a valid identifier for a tendon constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac582c6c556a8d449478bd4a32b7144c9" name="ac582c6c556a8d449478bd4a32b7144c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac582c6c556a8d449478bd4a32b7144c9">&#9670;&#160;</a></span>get_weld_constraint_specs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a>, internal::WeldConstraintSpec &gt; &amp; get_weld_constraint_specs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Returns a reference to the all of the weld constraints in this plant as a map from <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a" title="Type used to identify constraint by id within a multibody plant.">MultibodyConstraintId</a> to WeldConstraintSpec. </p>

</div>
</div>
<a id="af92a76ea886e8c4281ac658d0bf1073e" name="af92a76ea886e8c4281ac658d0bf1073e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92a76ea886e8c4281ac658d0bf1073e">&#9670;&#160;</a></span>get_weld_constraint_specs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const internal::WeldConstraintSpec &amp; get_weld_constraint_specs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Returns the weld constraint specification corresponding to <span class="tt">id</span> </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><span class="tt">id</span> is not a valid identifier for a weld constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8161e656bfc1653349b90539553a1ba4" name="a8161e656bfc1653349b90539553a1ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8161e656bfc1653349b90539553a1ba4">&#9670;&#160;</a></span>GetAccelerationLowerLimits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; GetAccelerationLowerLimits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of size <span class="tt"><a class="el" href="#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a></span> containing the lower acceleration limits for every generalized velocity coordinate. </p>
<p>These include joint and free body coordinates. Any unbounded or unspecified limits will be -infinity. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45b1fa10c461a184984c241fd91cc28e" name="a45b1fa10c461a184984c241fd91cc28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b1fa10c461a184984c241fd91cc28e">&#9670;&#160;</a></span>GetAccelerationUpperLimits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; GetAccelerationUpperLimits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upper limit analog of GetAccelerationsLowerLimits(), where any unbounded or unspecified limits will be +infinity. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8161e656bfc1653349b90539553a1ba4" title="Returns a vector of size num_velocities() containing the lower acceleration limits for every generali...">GetAccelerationLowerLimits()</a> for more information. </dd></dl>

</div>
</div>
<a id="a9f04d3a518de759ddd20257be50073cc" name="a9f04d3a518de759ddd20257be50073cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f04d3a518de759ddd20257be50073cc">&#9670;&#160;</a></span>GetActuatedJointIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt; GetActuatedJointIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of actuated joint indices associated with <span class="tt">model_instance</span>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a29c9845043cc59458a5a3f3d8fd5f6" name="a7a29c9845043cc59458a5a3f3d8fd5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a29c9845043cc59458a5a3f3d8fd5f6">&#9670;&#160;</a></span>GetActuationFromArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; GetActuationFromArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of actuation values for <span class="tt">model_instance</span> from a vector <span class="tt">u</span> of actuation values for the entire plant model. </p>
<p>Refer to <a class="el" href="#mbp_actuation">Actuation</a> for further details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>Actuation values for the entire model. The actuation value in <span class="tt">u</span> for a particular actuator must be found at offset <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#a42d883dde11e65819319f8060b0843b4" title="Returns the index to the first element for this joint actuator / within the vector of actuation input...">JointActuator::input_start()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Actuation values for <span class="tt">model_instance</span>, ordered by monotonically increasing <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">u</span> is not of size <a class="el" href="#ae3fc8de8de8eaf2d37a24c79d6be8e97" title="Returns the total number of actuated degrees of freedom.">MultibodyPlant::num_actuated_dofs()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc48985677d2b6db6916e452ab8e4eef" name="afc48985677d2b6db6916e452ab8e4eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc48985677d2b6db6916e452ab8e4eef">&#9670;&#160;</a></span>GetActuatorNames() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; GetActuatorNames </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>add_model_instance_prefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of string names corresponding to each element of the actuation vector. </p>
<p>These strings take the form <span class="tt">{model_instance_name}_{joint_actuator_name}</span>, but the prefix may optionally be withheld using <code class="param">add_model_instance_prefix</code>.</p>
<p>The returned names are guaranteed to be unique if <code class="param">add_model_instance_prefix</code> is <span class="tt">true</span> (the default).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the plant is not finalized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87bda03db9b65dfc45756ca6b6f73b11" name="a87bda03db9b65dfc45756ca6b6f73b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87bda03db9b65dfc45756ca6b6f73b11">&#9670;&#160;</a></span>GetActuatorNames() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; GetActuatorNames </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>add_model_instance_prefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of string names corresponding to each element of the actuation vector. </p>
<p>These strings take the form <span class="tt">{model_instance_name}_{joint_actuator_name}</span>, but the prefix may optionally be withheld using <code class="param">add_model_instance_prefix</code>.</p>
<p>The returned names are guaranteed to be unique.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the plant is not finalized or if the <code class="param">model_instance</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b9dbdb48dceb9427775abedf465150c" name="a4b9dbdb48dceb9427775abedf465150c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b9dbdb48dceb9427775abedf465150c">&#9670;&#160;</a></span>GetBaseBodyJointType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#ab69d6cd821353ffa5ba779a02269852d">BaseBodyJointType</a> GetBaseBodyJointType </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the currently-set choice for base body joint type, either for the global setting or for a specific model instance if provided. </p>
<p>If a model instance is provided for which no explicit choice has been made, the global setting is returned. Any model instance index is acceptable here; if not recognized then the global setting is returned. This can be called any time &ndash; pre-finalize it returns the joint type that will be used by <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>; post-finalize it returns the joint type that <em>was</em> used if there were any base bodies in need of a joint. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7c9672b405425259b192131304f14f9c" title="Sets the type of joint to be used by Finalize() to connect any otherwise unconnected bodies to World.">SetBaseBodyJointType()</a> </dd></dl>

</div>
</div>
<a id="a137b408b19244d236d315e5b95dbcac9" name="a137b408b19244d236d315e5b95dbcac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137b408b19244d236d315e5b95dbcac9">&#9670;&#160;</a></span>GetBodiesKinematicallyAffectedBy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">BodyIndex</a> &gt; GetBodiesKinematicallyAffectedBy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>joint_indexes</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all bodies whose kinematics are transitively affected by the given vector of Joints. </p>
<p>This is a <em>kinematic</em> relationship rather than a dynamic one. It is is inherently a query on the topology of the plant's modeled tree. Constraints are likewise not considered.</p>
<p>The affected bodies are returned in increasing order of body indices. A body is included in the output if that body's spatial velocity is affected by the generalized velocities v of one of the indicated joints.</p>
<p>As such, there are some notable implications:</p>
<ol type="1">
<li>If a body has an inboard free (6 dof) joint, it will be <em>kinematically</em> affected by joints further inboard, even though there might not be any dynamic influence on that body.</li>
<li>If the set of joints have no velocities (i.e., they are all weld (0 dof) joints), then, by definition, no bodies will be affected.</li>
</ol>
<p>This function can be only be called post-finalize, see <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if any of the given joint has an invalid index, doesn't correspond to a mobilizer, or is welded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28590d2acb4d289a18569894ef3b764f" name="a28590d2acb4d289a18569894ef3b764f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28590d2acb4d289a18569894ef3b764f">&#9670;&#160;</a></span>GetBodiesWeldedTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; * &gt; GetBodiesWeldedTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all bodies that are transitively welded, or rigidly affixed, to <span class="tt">body</span>, per these two definitions: </p>
<ol type="1">
<li>A body is always considered welded to itself.</li>
<li>Two unique bodies are considered welded together exclusively by the presence of a weld joint, not by other constructs that prevent mobility (e.g. constraints).</li>
</ol>
<p>This method can be called at any time during the lifetime of <span class="tt">this</span> plant, either pre- or post-finalize, see <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>.</p>
<p>Meant to be used with <span class="tt"><a class="el" href="#a2822cd320f693cd2191fbcdd6dba2494" title="For each of the provided bodies, collects up all geometries that have been registered to that body.">CollectRegisteredGeometries</a></span>.</p>
<p>The following example demonstrates filtering collisions between all bodies rigidly affixed to a door (which could be moving) and all bodies rigidly affixed to the world: </p><div class="fragment"><div class="line">GeometrySet g_world = plant.CollectRegisteredGeometries(</div>
<div class="line">    plant.GetBodiesWeldedTo(plant.world_body()));</div>
<div class="line">GeometrySet g_door = plant.CollectRegisteredGeometries(</div>
<div class="line">    plant.GetBodiesWeldedTo(plant.GetBodyByName(<span class="stringliteral">&quot;door&quot;</span>)));</div>
<div class="line">scene_graph.ExcludeCollisionsBetweeen(g_world, g_door);</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Usages akin to this example may introduce redundant collision filtering; this will not have a functional impact, but may have a minor performance impact.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>all bodies rigidly fixed to <span class="tt">body</span>. This does not return the bodies in any prescribed order. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">body</span> is not part of this plant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb6e264c4c8e38a30a9e3965209d3dea" name="abb6e264c4c8e38a30a9e3965209d3dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6e264c4c8e38a30a9e3965209d3dea">&#9670;&#160;</a></span>GetBodyByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp; GetBodyByName </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to a body that is identified by the string <span class="tt">name</span> in <span class="tt">this</span> MultibodyPlant. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there is no body with the requested name. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the body name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5aa037adf3002834caa1aedd305fa36d">HasBodyNamed()</a> to query if there exists a body in <span class="tt">this</span> MultibodyPlant with a given specified name. </dd></dl>

</div>
</div>
<a id="a3493d2245659015fc2ce6b713ef9d21c" name="a3493d2245659015fc2ce6b713ef9d21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3493d2245659015fc2ce6b713ef9d21c">&#9670;&#160;</a></span>GetBodyByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp; GetBodyByName </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the body that is uniquely identified by the string <span class="tt">name</span> and <code class="param">model_instance</code> in <span class="tt">this</span> MultibodyPlant. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there is no body with the requested name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5aa037adf3002834caa1aedd305fa36d">HasBodyNamed()</a> to query if there exists a body in <span class="tt">this</span> MultibodyPlant with a given specified name. </dd></dl>

</div>
</div>
<a id="a808a317dc7b18b637901509dfb5a788e" name="a808a317dc7b18b637901509dfb5a788e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808a317dc7b18b637901509dfb5a788e">&#9670;&#160;</a></span>GetBodyFrameIdIfExists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">geometry::FrameId</a> &gt; GetBodyFrameIdIfExists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">BodyIndex</a></td>          <td class="paramname"><span class="paramname"><em>body_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the body with <span class="tt">body_index</span> belongs to the called plant, it returns the <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb" title="Type used to identify geometry frames in SceneGraph.">geometry::FrameId</a> associated with it. </p>
<p>Otherwise, it returns nullopt. </p>

</div>
</div>
<a id="afdcdcb4e7798a5aef9bc3111402dfa5e" name="afdcdcb4e7798a5aef9bc3111402dfa5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdcdcb4e7798a5aef9bc3111402dfa5e">&#9670;&#160;</a></span>GetBodyFrameIdOrThrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">geometry::FrameId</a> GetBodyFrameIdOrThrow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">BodyIndex</a></td>          <td class="paramname"><span class="paramname"><em>body_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the body with <span class="tt">body_index</span> belongs to the called plant, it returns the <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb" title="Type used to identify geometry frames in SceneGraph.">geometry::FrameId</a> associated with it. </p>
<p>Otherwise this method throws an exception. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the called plant does not have the body indicated by <span class="tt">body_index</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a861e318468cd1ce72c9cf94566aac812" name="a861e318468cd1ce72c9cf94566aac812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861e318468cd1ce72c9cf94566aac812">&#9670;&#160;</a></span>GetBodyFromFrameId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; * GetBodyFromFrameId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">geometry::FrameId</a></td>          <td class="paramname"><span class="paramname"><em>frame_id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a geometry frame identifier, returns a pointer to the body associated with that id (nullptr if there is no such body). </p>

</div>
</div>
<a id="a03a6543ccf56f3fd4c8b0aa2420648e6" name="a03a6543ccf56f3fd4c8b0aa2420648e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a6543ccf56f3fd4c8b0aa2420648e6">&#9670;&#160;</a></span>GetBodyIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">BodyIndex</a> &gt; GetBodyIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of body indices associated with <span class="tt">model_instance</span>. </p>

</div>
</div>
<a id="a6e0adfbc5ece81c87ea5d428011ff96c" name="a6e0adfbc5ece81c87ea5d428011ff96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e0adfbc5ece81c87ea5d428011ff96c">&#9670;&#160;</a></span>GetCollisionGeometriesForBody()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> &gt; &amp; GetCollisionGeometriesForBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array of GeometryId's identifying the different contact geometries for <span class="tt">body</span> previously registered with a SceneGraph. </p>
<dl class="section note"><dt>Note</dt><dd>This method can be called at any time during the lifetime of <span class="tt">this</span> plant, either pre- or post-finalize, see <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. Post-finalize calls will always return the same value. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a90d32a93de07ef91744b95ed152c578d" title="Registers geometry in a SceneGraph with a given geometry::Shape to be used for the contact modeling o...">RegisterCollisionGeometry()</a>, <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> </dd></dl>

</div>
</div>
<a id="a8f75638f952ae11ee62d8c8458a47415" name="a8f75638f952ae11ee62d8c8458a47415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f75638f952ae11ee62d8c8458a47415">&#9670;&#160;</a></span>GetConstraintActiveStatus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool GetConstraintActiveStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the active status of the constraint given by <span class="tt">id</span> in <span class="tt">context</span>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the MultibodyPlant has not been finalized. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">id</span> does not belong to any multibody constraint in <span class="tt">context</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa84267261a17f03b155394a33523aec8" name="aa84267261a17f03b155394a33523aec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84267261a17f03b155394a33523aec8">&#9670;&#160;</a></span>GetConstraintIds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a> &gt; GetConstraintIds </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of all constraint identifiers. </p>
<p>The returned vector becomes invalid after any calls to Add*Constraint() or <a class="el" href="#ab868821d19fbf79f94b50147c4d90b9b" title="Removes the constraint id from the plant.">RemoveConstraint()</a>. </p>

</div>
</div>
<a id="a93cf63581a2d40a28d9cf65a3017839b" name="a93cf63581a2d40a28d9cf65a3017839b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93cf63581a2d40a28d9cf65a3017839b">&#9670;&#160;</a></span>GetDefaultContactSurfaceRepresentation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1geometry.html#a227f80cb57c9c87f6ecc4e839e364979">geometry::HydroelasticContactRepresentation</a> GetDefaultContactSurfaceRepresentation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>time_step</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the default value for contact representation, given the desired time step. </p>
<p>Discrete systems default to use polygons; continuous systems default to use triangles. </p>

</div>
</div>
<a id="a6fceec5d0aeba35c15cb3e5e9fdc3250" name="a6fceec5d0aeba35c15cb3e5e9fdc3250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fceec5d0aeba35c15cb3e5e9fdc3250">&#9670;&#160;</a></span>GetDefaultDistanceConstraintParams()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a>, <a class="el" href="classdrake_1_1multibody_1_1_distance_constraint_params.html">DistanceConstraintParams</a> &gt; &amp; GetDefaultDistanceConstraintParams </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all default distance constraint parameters, as registered via <a class="el" href="#aa141315d9a08af4dc7f82c8d3f9f1367" title="Defines a distance constraint between a point P on a body A and a point Q on a body B.">AddDistanceConstraint()</a>. </p>
<p>See <a class="el" href="#a65c964835794b9477b7bc1d0752b3ac7" title="Returns all distance constraint parameters currently stored in context.">GetDistanceConstraintParams()</a> and <a class="el" href="#a6672fc5264442466b21708b7008421fe" title="Stores in context the parameters params for the distance constraint with identifier id.">SetDistanceConstraintParams()</a> for working with parameters stored in a context. </p>

</div>
</div>
<a id="ab368246484a46e333b6edce659f42cfb" name="ab368246484a46e333b6edce659f42cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab368246484a46e333b6edce659f42cfb">&#9670;&#160;</a></span>GetDefaultFloatingBaseBodyPose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; GetDefaultFloatingBaseBodyPose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the provisional default pose of <span class="tt">body</span> as set by <a class="el" href="#aadfba35383b020c7184081574cbfcbbd" title="Provisionally records a default World pose for body, to be used in case body turns out to be a floati...">SetDefaultFloatingBaseBodyPose()</a>. </p>
<p>If no pose was specified for <span class="tt">body</span>, returns the identity pose. This may be called pre- or post-Finalize().</p>
<dl class="section warning"><dt>Warning</dt><dd>This value is only meaningful for bodies that turn out to be floating base bodies after <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. If called on any other body, the result simply echoes whatever provisional pose was set in <a class="el" href="#aadfba35383b020c7184081574cbfcbbd" title="Provisionally records a default World pose for body, to be used in case body turns out to be a floati...">SetDefaultFloatingBaseBodyPose()</a> but has no other effect. Use the <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> API to get the default pose for any body that has an explicitly-defined joint to its parent body.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Post-Finalize(), a floating base body's default pose may be set either by <a class="el" href="#aadfba35383b020c7184081574cbfcbbd" title="Provisionally records a default World pose for body, to be used in case body turns out to be a floati...">SetDefaultFloatingBaseBodyPose()</a> or by setting the default pose directly through the <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> API applied to the automatically-added floating joint. <a class="el" href="#ab368246484a46e333b6edce659f42cfb" title="Gets the provisional default pose of body as set by SetDefaultFloatingBaseBodyPose().">GetDefaultFloatingBaseBodyPose()</a> will return the most-recent value set by either method.</dd></dl>
<p>See <a class="el" href="#mbp_working_with_free_bodies">above for details</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">body</td><td><a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a> whose default pose will be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">X_WB</td><td>The default pose of the floating base body B in World. Not meaningful if <span class="tt">body</span> is not a floating base body. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2c0bf5b2fcbf8715b416864fc507a56" name="ae2c0bf5b2fcbf8715b416864fc507a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c0bf5b2fcbf8715b416864fc507a56">&#9670;&#160;</a></span>GetDefaultFreeBodyPose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; GetDefaultFreeBodyPose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000027">Deprecated</a></b></dt><dd>Use GetDefaultFloatingBaseBodyPose() instead. <br  />
 This will be removed from Drake on or after 2026-06-01. </dd></dl>

</div>
</div>
<a id="ac9bcc022da125a839e3673beb0f9dc9b" name="ac9bcc022da125a839e3673beb0f9dc9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9bcc022da125a839e3673beb0f9dc9b">&#9670;&#160;</a></span>GetDefaultPositions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; GetDefaultPositions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the default positions for the plant, which can be changed via <a class="el" href="#aa293696b845c071deb902d3ee6d3bcc3" title="Sets the default positions for the plant.">SetDefaultPositions()</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the plant is not finalized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa68446168fd4dd3f5778716192d6fdc3" name="aa68446168fd4dd3f5778716192d6fdc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68446168fd4dd3f5778716192d6fdc3">&#9670;&#160;</a></span>GetDefaultPositions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; GetDefaultPositions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the default positions for the plant for a given model instance, which can be changed via <a class="el" href="#aa293696b845c071deb902d3ee6d3bcc3" title="Sets the default positions for the plant.">SetDefaultPositions()</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the plant is not finalized, or if the model_instance is invalid, </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65c964835794b9477b7bc1d0752b3ac7" name="a65c964835794b9477b7bc1d0752b3ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c964835794b9477b7bc1d0752b3ac7">&#9670;&#160;</a></span>GetDistanceConstraintParams() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; <a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a>, <a class="el" href="classdrake_1_1multibody_1_1_distance_constraint_params.html">DistanceConstraintParams</a> &gt; &amp; GetDistanceConstraintParams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all distance constraint parameters currently stored in <span class="tt">context</span>. </p>

</div>
</div>
<a id="af25ef52efba5ea5e62c292a43faaf7d8" name="af25ef52efba5ea5e62c292a43faaf7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25ef52efba5ea5e62c292a43faaf7d8">&#9670;&#160;</a></span>GetDistanceConstraintParams() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_distance_constraint_params.html">DistanceConstraintParams</a> &amp; GetDistanceConstraintParams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the parameters for the distance constraint that corresponds to identifier <span class="tt">id</span>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><span class="tt">id</span> is not a valid identifier for a distance constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acabcf82b7950bc33f824a9209ec76841" name="acabcf82b7950bc33f824a9209ec76841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabcf82b7950bc33f824a9209ec76841">&#9670;&#160;</a></span>GetEffortLowerLimits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; GetEffortLowerLimits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of size <span class="tt"><a class="el" href="#ae3fc8de8de8eaf2d37a24c79d6be8e97" title="Returns the total number of actuated degrees of freedom.">num_actuated_dofs()</a></span> containing the lower effort limits for every actuator. </p>
<p>Any unbounded or unspecified limits will be -∞. The returned vector is indexed by <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a>, see <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#a0da0b00b025a7bb19e574feabb91668f" title="Returns this element&#39;s unique index.">JointActuator::index()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8344811188893c52deeb10e478b4f8f1" title="Returns a vector of size num_actuated_dofs() containing the upper effort limits for every actuator.">GetEffortUpperLimits()</a> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8344811188893c52deeb10e478b4f8f1" name="a8344811188893c52deeb10e478b4f8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8344811188893c52deeb10e478b4f8f1">&#9670;&#160;</a></span>GetEffortUpperLimits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; GetEffortUpperLimits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of size <span class="tt"><a class="el" href="#ae3fc8de8de8eaf2d37a24c79d6be8e97" title="Returns the total number of actuated degrees of freedom.">num_actuated_dofs()</a></span> containing the upper effort limits for every actuator. </p>
<p>Any unbounded or unspecified limits will be +∞. The returned vector is indexed by <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a>, see <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#a0da0b00b025a7bb19e574feabb91668f" title="Returns this element&#39;s unique index.">JointActuator::index()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#acabcf82b7950bc33f824a9209ec76841" title="Returns a vector of size num_actuated_dofs() containing the lower effort limits for every actuator.">GetEffortLowerLimits()</a> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab593b96202e54f20747521c815b8989f" name="ab593b96202e54f20747521c815b8989f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab593b96202e54f20747521c815b8989f">&#9670;&#160;</a></span>GetFloatingBaseBodies()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; <a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">BodyIndex</a> &gt; GetFloatingBaseBodies </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of body indices corresponding to the floating base bodies in the model, in no particular order. </p>
<p>See <a class="el" href="#mbp_working_with_free_bodies">above for details</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize, see <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a172026ba093a622e831746fc2a18b713" name="a172026ba093a622e831746fc2a18b713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172026ba093a622e831746fc2a18b713">&#9670;&#160;</a></span>GetForceElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename &gt; class ForceElementType = ForceElement&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const ForceElementType&lt; T &gt; &amp; GetForceElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#add80e949328b179d78312d1455319868">ForceElementIndex</a></td>          <td class="paramname"><span class="paramname"><em>force_element_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to a force element identified by its unique index in <span class="tt">this</span> MultibodyPlant. </p>
<p>If the optional template argument is supplied, then the returned value is downcast to the specified <span class="tt">ForceElementType</span>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForceElementType</td><td>The specific type of the <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> to be retrieved. It must be a subclass of <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the force element is not of type <span class="tt">ForceElementType</span> or if there is no <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> with that index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a214b22ac2258ec73e6eeb2a07011a7f1" name="a214b22ac2258ec73e6eeb2a07011a7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214b22ac2258ec73e6eeb2a07011a7f1">&#9670;&#160;</a></span>GetFrameByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp; GetFrameByName </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to a frame that is identified by the string <span class="tt">name</span> in <span class="tt">this</span> model. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there is no frame with the requested name. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the frame name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8f099f6f98dbec124151d83b25fe2edc">HasFrameNamed()</a> to query if there exists a frame in <span class="tt">this</span> model with a given specified name. </dd></dl>

</div>
</div>
<a id="af2b58a281bbc2d62b94b569bba2388c6" name="af2b58a281bbc2d62b94b569bba2388c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b58a281bbc2d62b94b569bba2388c6">&#9670;&#160;</a></span>GetFrameByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp; GetFrameByName </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the frame that is uniquely identified by the string <span class="tt">name</span> in <code class="param">model_instance</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there is no frame with the requested name. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <code class="param">model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8f099f6f98dbec124151d83b25fe2edc">HasFrameNamed()</a> to query if there exists a frame in <span class="tt">this</span> model with a given specified name. </dd></dl>

</div>
</div>
<a id="a9dc72553d42ef7bbadddb2822a883746" name="a9dc72553d42ef7bbadddb2822a883746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc72553d42ef7bbadddb2822a883746">&#9670;&#160;</a></span>GetFrameIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a> &gt; GetFrameIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of frame indices associated with <span class="tt">model_instance</span>. </p>

</div>
</div>
<a id="a4ac585d6a0c8abd7893374d2e6e907fd" name="a4ac585d6a0c8abd7893374d2e6e907fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac585d6a0c8abd7893374d2e6e907fd">&#9670;&#160;</a></span>GetFreeBodyPose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; GetFreeBodyPose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For any free body's 6-dof joint, gets the pose X_JpJc of the child frame Jc in its parent frame Jp. </p>
<dl class="section note"><dt>Note</dt><dd>Unless <span class="tt">body</span> is a floating base body, the parent frame Jp is not necessarily the World frame W, and the child frame Jc is not necessarily the body frame B.</dd></dl>
<p>See <a class="el" href="#mbp_working_with_free_bodies">above for details</a>. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">X_JpJc</td><td>The current pose of child frame Jc in its parent frame Jp. Returns X_WB if <span class="tt">body</span> B is a floating base body. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">body</span> is not a free body. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a652be40ec0f98f6489931fb9162098" name="a2a652be40ec0f98f6489931fb9162098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a652be40ec0f98f6489931fb9162098">&#9670;&#160;</a></span>GetJointActuatorByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp; GetJointActuatorByName </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to an actuator that is identified by the string <span class="tt">name</span> in <span class="tt">this</span> MultibodyPlant. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there is no actuator with the requested name. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the actuator name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7bfcc73831e073c659a3c6503e0e1e6a">HasJointActuatorNamed()</a> to query if there exists an actuator in <span class="tt">this</span> MultibodyPlant with a given specified name. </dd></dl>

</div>
</div>
<a id="ad24b3a18e439aaf29ccfec8fc2917c96" name="ad24b3a18e439aaf29ccfec8fc2917c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24b3a18e439aaf29ccfec8fc2917c96">&#9670;&#160;</a></span>GetJointActuatorByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp; GetJointActuatorByName </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the actuator that is uniquely identified by the string <span class="tt">name</span> and <code class="param">model_instance</code> in <span class="tt">this</span> MultibodyPlant. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there is no actuator with the requested name. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <code class="param">model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7bfcc73831e073c659a3c6503e0e1e6a">HasJointActuatorNamed()</a> to query if there exists an actuator in <span class="tt">this</span> MultibodyPlant with a given specified name. </dd></dl>

</div>
</div>
<a id="a14c63996575e6bf19290129d32d079cc" name="a14c63996575e6bf19290129d32d079cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c63996575e6bf19290129d32d079cc">&#9670;&#160;</a></span>GetJointActuatorIndices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> &gt; &amp; GetJointActuatorIndices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of all joint actuator indices. </p>
<p>The vector is ordered by monotonically increasing <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a>, but the indices will in general not be consecutive due to actuators that were removed. </p>

</div>
</div>
<a id="a03f7c6810cf38ce83a6046e3243f3e28" name="a03f7c6810cf38ce83a6046e3243f3e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f7c6810cf38ce83a6046e3243f3e28">&#9670;&#160;</a></span>GetJointActuatorIndices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> &gt; GetJointActuatorIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of joint actuator indices associated with <span class="tt">model_instance</span>. </p>
<p>The vector is ordered by monotonically increasing <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65a8bf98a3d37404d4a9de8d59e1ca70" name="a65a8bf98a3d37404d4a9de8d59e1ca70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a8bf98a3d37404d4a9de8d59e1ca70">&#9670;&#160;</a></span>GetJointByName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename &gt; class JointType = Joint&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const JointType&lt; T &gt; &amp; GetJointByName </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to a joint that is identified by the string <span class="tt">name</span> in <span class="tt">this</span> MultibodyPlant. </p>
<p>If the optional template argument is supplied, then the returned value is downcast to the specified <span class="tt">JointType</span>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">JointType</td><td>The specific type of the <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> to be retrieved. It must be a subclass of <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the named joint is not of type <span class="tt">JointType</span> or if there is no <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> with that name. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <code class="param">model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af5cc2bf03e1b34a63539f8e104425729">HasJointNamed()</a> to query if there exists a joint in <span class="tt">this</span> MultibodyPlant with a given specified name. </dd></dl>

</div>
</div>
<a id="acf9168de86a03b26abf216dd93de6a80" name="acf9168de86a03b26abf216dd93de6a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9168de86a03b26abf216dd93de6a80">&#9670;&#160;</a></span>GetJointIndices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt; &amp; GetJointIndices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of all joint indices. </p>
<p>The vector is ordered by monotonically increasing <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a>, but the indices will in general not be consecutive due to joints that were removed. </p>

</div>
</div>
<a id="a3321b82d96b679209efb4aec0974d9bc" name="a3321b82d96b679209efb4aec0974d9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3321b82d96b679209efb4aec0974d9bc">&#9670;&#160;</a></span>GetJointIndices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt; GetJointIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of joint indices associated with <span class="tt">model_instance</span>. </p>

</div>
</div>
<a id="ae6d03c873e08ade99e59d68af8375355" name="ae6d03c873e08ade99e59d68af8375355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d03c873e08ade99e59d68af8375355">&#9670;&#160;</a></span>GetModelInstanceByName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> GetModelInstanceByName </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index to the model instance that is uniquely identified by the string <span class="tt">name</span> in <span class="tt">this</span> MultibodyPlant. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there is no instance with the requested name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae12f32b40b7a41c3aa933ed74b2417fb">HasModelInstanceNamed()</a> to query if there exists an instance in <span class="tt">this</span> MultibodyPlant with a given specified name. </dd></dl>

</div>
</div>
<a id="a6967a3b13b5d006821d7590945a0c168" name="a6967a3b13b5d006821d7590945a0c168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6967a3b13b5d006821d7590945a0c168">&#9670;&#160;</a></span>GetModelInstanceName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; GetModelInstanceName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of a <span class="tt">model_instance</span>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>when <span class="tt">model_instance</span> does not correspond to a model in this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7dcf66ff2d8900efa1d376d753238e7c" name="a7dcf66ff2d8900efa1d376d753238e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dcf66ff2d8900efa1d376d753238e7c">&#9670;&#160;</a></span>GetMutableJointByName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename &gt; class JointType = Joint&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">JointType&lt; T &gt; &amp; GetMutableJointByName </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A version of GetJointByName that returns a mutable reference. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a65a8bf98a3d37404d4a9de8d59e1ca70" title="Returns a constant reference to a joint that is identified by the string name in this MultibodyPlant.">GetJointByName</a>. </dd></dl>

</div>
</div>
<a id="a4b131944f330a62a756b00d401a14a72" name="a4b131944f330a62a756b00d401a14a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b131944f330a62a756b00d401a14a72">&#9670;&#160;</a></span>GetMutableSceneGraphPreFinalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt; * GetMutableSceneGraphPreFinalize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Returns a mutable pointer to the SceneGraph that this plant is registered as a source for. </p>
<p>This method can only be used pre-Finalize.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="#acf7bb2a3531c09a97fb3623ac582d840" title="Returns true if this MultibodyPlant was finalized with a call to Finalize().">is_finalized()</a> == true || <a class="el" href="#afad783d7e7e513feb7a73384c8080041" title="Returns true if this MultibodyPlant was registered with a SceneGraph.">geometry_source_is_registered()</a> == false </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00df1769efd86a386234debfca2acc2e" name="a00df1769efd86a386234debfca2acc2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00df1769efd86a386234debfca2acc2e">&#9670;&#160;</a></span>GetPositionLowerLimits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; GetPositionLowerLimits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of size <span class="tt"><a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">num_positions()</a></span> containing the lower position limits for every generalized position coordinate. </p>
<p>These include joint and free body coordinates. Any unbounded or unspecified limits will be -infinity. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae77ccdb449347f6eacb212c46eb2d9c7" name="ae77ccdb449347f6eacb212c46eb2d9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77ccdb449347f6eacb212c46eb2d9c7">&#9670;&#160;</a></span>GetPositionNames() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; GetPositionNames </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>add_model_instance_prefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>always_add_suffix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of string names corresponding to each element of the position vector. </p>
<p>These strings take the form <span class="tt">{model_instance_name}_{joint_name}_{joint_position_suffix}</span>, but the prefix and suffix may optionally be withheld using <code class="param">add_model_instance_prefix</code> and <code class="param">always_add_suffix</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">always_add_suffix</td><td>(optional). If true, then the suffix is always added. If false, then the suffix is only added for joints that have more than one position (in this case, not adding would lead to ambiguity).</td></tr>
  </table>
  </dd>
</dl>
<p>The returned names are guaranteed to be unique if <code class="param">add_model_instance_prefix</code> is <span class="tt">true</span> (the default).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the plant is not finalized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dfe71a78246c3a81abc33954aed21df" name="a5dfe71a78246c3a81abc33954aed21df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dfe71a78246c3a81abc33954aed21df">&#9670;&#160;</a></span>GetPositionNames() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; GetPositionNames </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>add_model_instance_prefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>always_add_suffix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of string names corresponding to each element of the position vector. </p>
<p>These strings take the form <span class="tt">{model_instance_name}_{joint_name}_{joint_position_suffix}</span>, but the prefix and suffix may optionally be withheld using <code class="param">add_model_instance_prefix</code> and <code class="param">always_add_suffix</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">always_add_suffix</td><td>(optional). If true, then the suffix is always added. If false, then the suffix is only added for joints that have more than one position (in this case, not adding would lead to ambiguity).</td></tr>
  </table>
  </dd>
</dl>
<p>The returned names are guaranteed to be unique.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the plant is not finalized or if the <code class="param">model_instance</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15aab0eeb92b8e9f0a9bfcab8abaca69" name="a15aab0eeb92b8e9f0a9bfcab8abaca69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15aab0eeb92b8e9f0a9bfcab8abaca69">&#9670;&#160;</a></span>GetPositions() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; GetPositions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const vector reference to the vector of generalized positions q in a given Context. </p>
<dl class="section note"><dt>Note</dt><dd>This method returns a reference to existing data, exhibits constant i.e., O(1) time complexity, and runs very quickly. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">context</span> does not correspond to the Context for a multibody model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca5f136c4c48997ffc6284a25f85a16d" name="aca5f136c4c48997ffc6284a25f85a16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5f136c4c48997ffc6284a25f85a16d">&#9670;&#160;</a></span>GetPositions() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; GetPositions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector containing the generalized positions q of a specified model instance in a given Context. </p>
<dl class="section note"><dt>Note</dt><dd>Returns a dense vector of dimension <span class="tt">num_positions(model_instance)</span> associated with <span class="tt">model_instance</span> by copying from <span class="tt">context</span>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">context</span> does not correspond to the Context for a multibody model or <span class="tt">model_instance</span> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33d9285487483014120ce10524b0f762" name="a33d9285487483014120ce10524b0f762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d9285487483014120ce10524b0f762">&#9670;&#160;</a></span>GetPositions() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GetPositions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>q_out</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Populates output vector q_out with the generalized positions q of a specified model instance in a given Context. </p>
<dl class="section note"><dt>Note</dt><dd>q_out is a dense vector of dimension <span class="tt">num_positions(model_instance)</span> associated with <span class="tt">model_instance</span> and is populated by copying from <span class="tt">context</span>. </dd>
<dd>
This function is guaranteed to allocate no heap. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">context</span> does not correspond to the Context for a multibody model or <span class="tt">model_instance</span> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61c4037d7f25d2e511f86e9102772290" name="a61c4037d7f25d2e511f86e9102772290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c4037d7f25d2e511f86e9102772290">&#9670;&#160;</a></span>GetPositionsAndVelocities() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; GetPositionsAndVelocities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const vector reference <span class="tt">[q; v]</span> to the generalized positions q and generalized velocities v in a given Context. </p>
<dl class="section note"><dt>Note</dt><dd>This method returns a reference to existing data, exhibits constant i.e., O(1) time complexity, and runs very quickly. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">context</span> does not correspond to the Context for a multibody model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ed3389732867302278b87d4605509a2" name="a7ed3389732867302278b87d4605509a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed3389732867302278b87d4605509a2">&#9670;&#160;</a></span>GetPositionsAndVelocities() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; GetPositionsAndVelocities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector <span class="tt">[q; v]</span> containing the generalized positions q and generalized velocities v of a specified model instance in a given Context. </p>
<dl class="section note"><dt>Note</dt><dd>Returns a dense vector of dimension <span class="tt">num_positions(model_instance) + num_velocities(model_instance)</span> associated with <span class="tt">model_instance</span> by copying from <span class="tt">context</span>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">context</span> does not correspond to the Context for a multibody model or <span class="tt">model_instance</span> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98228721376112290679f89f8333b78c" name="a98228721376112290679f89f8333b78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98228721376112290679f89f8333b78c">&#9670;&#160;</a></span>GetPositionsAndVelocities() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GetPositionsAndVelocities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>qv_out</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Populates output vector qv_out representing the generalized positions q and generalized velocities v of a specified model instance in a given Context. </p>
<dl class="section note"><dt>Note</dt><dd>qv_out is a dense vector of dimensions <span class="tt">num_positions(model_instance) + num_velocities(model_instance)</span> associated with <span class="tt">model_instance</span> and is populated by copying from <span class="tt">context</span>. </dd>
<dd>
This function is guaranteed to allocate no heap. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">context</span> does not correspond to the Context for a multibody model or <span class="tt">model_instance</span> is invalid. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if qv_out does not have size <span class="tt">num_positions(model_instance) + num_velocities(model_instance)</span> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d2ae02e64d4433eb7c5bbebd2a9dd0d" name="a5d2ae02e64d4433eb7c5bbebd2a9dd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2ae02e64d4433eb7c5bbebd2a9dd0d">&#9670;&#160;</a></span>GetPositionsFromArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; GetPositionsFromArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of generalized positions for <span class="tt">model_instance</span> from a vector <span class="tt">q_array</span> of generalized positions for the entire model model. </p>
<p>This method throws an exception if <span class="tt">q</span> is not of size <a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">MultibodyPlant::num_positions()</a>. </p>

</div>
</div>
<a id="ac99acfa004ed8d14c7b950ae3cefc233" name="ac99acfa004ed8d14c7b950ae3cefc233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99acfa004ed8d14c7b950ae3cefc233">&#9670;&#160;</a></span>GetPositionsFromArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GetPositionsFromArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>q_out</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Populates output vector q_out and with the generalized positions for <span class="tt">model_instance</span> from a vector <span class="tt">q</span> of generalized positions for the entire model. </p>
<p>This method throws an exception if <span class="tt">q</span> is not of size <a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">MultibodyPlant::num_positions()</a>. </p>

</div>
</div>
<a id="a496aaac0e459e3762b0694fb41e7bab6" name="a496aaac0e459e3762b0694fb41e7bab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a496aaac0e459e3762b0694fb41e7bab6">&#9670;&#160;</a></span>GetPositionUpperLimits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; GetPositionUpperLimits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upper limit analog of <a class="el" href="#a00df1769efd86a386234debfca2acc2e" title="Returns a vector of size num_positions() containing the lower position limits for every generalized p...">GetPositionLowerLimits()</a>, where any unbounded or unspecified limits will be +infinity. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a00df1769efd86a386234debfca2acc2e" title="Returns a vector of size num_positions() containing the lower position limits for every generalized p...">GetPositionLowerLimits()</a> for more information. </dd></dl>

</div>
</div>
<a id="ad46fb49fc69d22b8a08d4dedc574ee1e" name="ad46fb49fc69d22b8a08d4dedc574ee1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46fb49fc69d22b8a08d4dedc574ee1e">&#9670;&#160;</a></span>GetRigidBodyByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp; GetRigidBodyByName </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to a rigid body that is identified by the string <span class="tt">name</span> in <span class="tt">this</span> model. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there is no body with the requested name. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the body name occurs in multiple model instances. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the requested body is not a <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5aa037adf3002834caa1aedd305fa36d">HasBodyNamed()</a> to query if there exists a body in <span class="tt">this</span> model with a given specified name. </dd></dl>

</div>
</div>
<a id="a64e0914d716083743514bf46460ca5c1" name="a64e0914d716083743514bf46460ca5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e0914d716083743514bf46460ca5c1">&#9670;&#160;</a></span>GetRigidBodyByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp; GetRigidBodyByName </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the rigid body that is uniquely identified by the string <span class="tt">name</span> in <code class="param">model_instance</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there is no body with the requested name. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the requested body is not a <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a>. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <code class="param">model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5aa037adf3002834caa1aedd305fa36d">HasBodyNamed()</a> to query if there exists a body in <span class="tt">this</span> model with a given specified name. </dd></dl>

</div>
</div>
<a id="a407f8d30b37d10d4070126c980fed288" name="a407f8d30b37d10d4070126c980fed288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407f8d30b37d10d4070126c980fed288">&#9670;&#160;</a></span>GetStateNames() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; GetStateNames </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>add_model_instance_prefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of string names corresponding to each element of the multibody state vector. </p>
<p>These strings take the form <span class="tt">{model_instance_name}_{joint_name}_{joint_position_suffix |
joint_velocity_suffix}</span>, but the prefix may optionally be withheld using <code class="param">add_model_instance_prefix</code>.</p>
<p>The returned names are guaranteed to be unique if <code class="param">add_model_instance_prefix</code> is <span class="tt">true</span> (the default).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the plant is not finalized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0eee063ebd3e815ccdb6116e67f8d31" name="ad0eee063ebd3e815ccdb6116e67f8d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0eee063ebd3e815ccdb6116e67f8d31">&#9670;&#160;</a></span>GetStateNames() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; GetStateNames </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>add_model_instance_prefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of string names corresponding to each element of the multibody state vector. </p>
<p>These strings take the form <span class="tt">{model_instance_name}_{joint_name}_{joint_position_suffix |
joint_velocity_suffix}</span>, but the prefix may optionally be withheld using <code class="param">add_model_instance_prefix</code>.</p>
<p>The returned names are guaranteed to be unique.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the plant is not finalized or if the <code class="param">model_instance</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a113f30d2b1b3a8151b638300231975fa" name="a113f30d2b1b3a8151b638300231975fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113f30d2b1b3a8151b638300231975fa">&#9670;&#160;</a></span>GetTopologyGraphvizString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string GetTopologyGraphvizString </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a Graphviz string describing the topology of this plant. </p>
<p>To render the string, use the Graphviz tool, <span class="tt">dot</span>. <a href="http://www.graphviz.org/">http://www.graphviz.org/</a></p>
<p>Note: this method can be called either before or after <span class="tt"><a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a></span>. </p>

</div>
</div>
<a id="a24ec51f3cfb9ff7bb1a19034abe25d3a" name="a24ec51f3cfb9ff7bb1a19034abe25d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ec51f3cfb9ff7bb1a19034abe25d3a">&#9670;&#160;</a></span>GetUniqueFloatingBaseBodyOrThrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp; GetUniqueFloatingBaseBodyOrThrow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If there is a single base body in the model given by <span class="tt">model_instance</span>, and that body is a floating base body, returns that floating base body. </p>
<p>Otherwise, throws an exception. Use <a class="el" href="#a7f07529f78963c62ca6a651a96619fbe" title="Returns true if there is a single base body in the model given by model_instance, and that body is a ...">HasUniqueFloatingBaseBody()</a> to check first.</p>
<p>See <a class="el" href="#mbp_working_with_free_bodies">above for details</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">model_instance</span> is not valid. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if !HasUniqueFloatingBaseBody(model_instance). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7f07529f78963c62ca6a651a96619fbe" title="Returns true if there is a single base body in the model given by model_instance, and that body is a ...">HasUniqueFloatingBaseBody()</a>, <a class="el" href="#ab593b96202e54f20747521c815b8989f" title="Returns the set of body indices corresponding to the floating base bodies in the model,...">GetFloatingBaseBodies()</a> </dd></dl>

</div>
</div>
<a id="ae89c0d301b92604e7e15bfb5c62697b8" name="ae89c0d301b92604e7e15bfb5c62697b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89c0d301b92604e7e15bfb5c62697b8">&#9670;&#160;</a></span>GetUniqueFreeBaseBodyOrThrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp; GetUniqueFreeBaseBodyOrThrow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000025">Deprecated</a></b></dt><dd>Use GetUniqueFloatingBaseBodyOrThrow() instead. <br  />
 This will be removed from Drake on or after 2026-06-01. </dd></dl>

</div>
</div>
<a id="a83faa6d43006794cd8f7ee6f851e1d09" name="a83faa6d43006794cd8f7ee6f851e1d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83faa6d43006794cd8f7ee6f851e1d09">&#9670;&#160;</a></span>GetVelocities() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; GetVelocities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const vector reference to the generalized velocities v in a given Context. </p>
<dl class="section note"><dt>Note</dt><dd>This method returns a reference to existing data, exhibits constant i.e., O(1) time complexity, and runs very quickly. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">context</span> does not correspond to the Context for a multibody model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ac68a304522ced0b67b93deeb9152cc" name="a6ac68a304522ced0b67b93deeb9152cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac68a304522ced0b67b93deeb9152cc">&#9670;&#160;</a></span>GetVelocities() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; GetVelocities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector containing the generalized velocities v of a specified model instance in a given Context. </p>
<dl class="section note"><dt>Note</dt><dd>returns a dense vector of dimension <span class="tt">num_velocities(model_instance)</span> associated with <span class="tt">model_instance</span> by copying from <span class="tt">context</span>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">context</span> does not correspond to the Context for a multibody model or <span class="tt">model_instance</span> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abad057c31de6451c9925dffb8fe4612e" name="abad057c31de6451c9925dffb8fe4612e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad057c31de6451c9925dffb8fe4612e">&#9670;&#160;</a></span>GetVelocities() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GetVelocities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>v_out</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Populates output vector v_out with the generalized velocities v of a specified model instance in a given Context. </p>
<dl class="section note"><dt>Note</dt><dd>v_out is a dense vector of dimension <span class="tt">num_velocities(model_instance)</span> associated with <span class="tt">model_instance</span> and is populated by copying from <span class="tt">context</span>. </dd>
<dd>
This function is guaranteed to allocate no heap. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">context</span> does not correspond to the Context for a multibody model or <span class="tt">model_instance</span> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52b25b565255d213a7f483b12f18ab68" name="a52b25b565255d213a7f483b12f18ab68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b25b565255d213a7f483b12f18ab68">&#9670;&#160;</a></span>GetVelocitiesFromArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; GetVelocitiesFromArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of generalized velocities for <span class="tt">model_instance</span> from a vector <span class="tt">v</span> of generalized velocities for the entire <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> model. </p>
<p>This method throws an exception if the input array is not of size <a class="el" href="#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">MultibodyPlant::num_velocities()</a>. </p>

</div>
</div>
<a id="afd9d34274a3e772f96ab8060e604cda1" name="afd9d34274a3e772f96ab8060e604cda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9d34274a3e772f96ab8060e604cda1">&#9670;&#160;</a></span>GetVelocitiesFromArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GetVelocitiesFromArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>v_out</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Populates output vector v_out with the generalized velocities for <span class="tt">model_instance</span> from a vector <span class="tt">v</span> of generalized velocities for the entire model. </p>
<p>This method throws an exception if <span class="tt">v</span> is not of size <a class="el" href="#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">MultibodyPlant::num_velocities()</a>. </p>

</div>
</div>
<a id="a83365196f5b81dbb51d3e09827e4d71b" name="a83365196f5b81dbb51d3e09827e4d71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83365196f5b81dbb51d3e09827e4d71b">&#9670;&#160;</a></span>GetVelocityLowerLimits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; GetVelocityLowerLimits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of size <span class="tt"><a class="el" href="#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a></span> containing the lower velocity limits for every generalized velocity coordinate. </p>
<p>These include joint and free body coordinates. Any unbounded or unspecified limits will be -infinity. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa39318cfd5bf8d55192c15985af19e26" name="aa39318cfd5bf8d55192c15985af19e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39318cfd5bf8d55192c15985af19e26">&#9670;&#160;</a></span>GetVelocityNames() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; GetVelocityNames </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>add_model_instance_prefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>always_add_suffix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of string names corresponding to each element of the velocity vector. </p>
<p>These strings take the form <span class="tt">{model_instance_name}_{joint_name}_{joint_velocity_suffix}</span>, but the prefix and suffix may optionally be withheld using <code class="param">add_model_instance_prefix</code> and <code class="param">always_add_suffix</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">always_add_suffix</td><td>(optional). If true, then the suffix is always added. If false, then the suffix is only added for joints that have more than one position (in this case, not adding would lead to ambiguity).</td></tr>
  </table>
  </dd>
</dl>
<p>The returned names are guaranteed to be unique if <code class="param">add_model_instance_prefix</code> is <span class="tt">true</span> (the default).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the plant is not finalized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7ff5492ccf95a01e734827ae8953584" name="af7ff5492ccf95a01e734827ae8953584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ff5492ccf95a01e734827ae8953584">&#9670;&#160;</a></span>GetVelocityNames() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; GetVelocityNames </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>add_model_instance_prefix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>always_add_suffix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of string names corresponding to each element of the velocity vector. </p>
<p>These strings take the form <span class="tt">{model_instance_name}_{joint_name}_{joint_velocity_suffix}</span>, but the prefix and suffix may optionally be withheld using <code class="param">add_model_instance_prefix</code> and <code class="param">always_add_suffix</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">always_add_suffix</td><td>(optional). If true, then the suffix is always added. If false, then the suffix is only added for joints that have more than one position (in this case, not adding would lead to ambiguity).</td></tr>
  </table>
  </dd>
</dl>
<p>The returned names are guaranteed to be unique.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the plant is not finalized or if the <code class="param">model_instance</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ba581177b15efe8e7a26c4709a77752" name="a5ba581177b15efe8e7a26c4709a77752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba581177b15efe8e7a26c4709a77752">&#9670;&#160;</a></span>GetVelocityUpperLimits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; GetVelocityUpperLimits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upper limit analog of GetVelocitysLowerLimits(), where any unbounded or unspecified limits will be +infinity. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a83365196f5b81dbb51d3e09827e4d71b" title="Returns a vector of size num_velocities() containing the lower velocity limits for every generalized ...">GetVelocityLowerLimits()</a> for more information. </dd></dl>

</div>
</div>
<a id="af76b81d10dd0c9689ef62b4c44e63ead" name="af76b81d10dd0c9689ef62b4c44e63ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af76b81d10dd0c9689ef62b4c44e63ead">&#9670;&#160;</a></span>GetVisualGeometriesForBody()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> &gt; &amp; GetVisualGeometriesForBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array of GeometryId's identifying the different visual geometries for <span class="tt">body</span> previously registered with a SceneGraph. </p>
<dl class="section note"><dt>Note</dt><dd>This method can be called at any time during the lifetime of <span class="tt">this</span> plant, either pre- or post-finalize, see <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. Post-finalize calls will always return the same value. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af475e2acc5c4720650cf004a37f1ce95" title="Registers geometry in a SceneGraph with a given geometry::Shape to be used for visualization of a giv...">RegisterVisualGeometry()</a>, <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> </dd></dl>

</div>
</div>
<a id="a262bfea040b50f4e5db5cb8778161655" name="a262bfea040b50f4e5db5cb8778161655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262bfea040b50f4e5db5cb8778161655">&#9670;&#160;</a></span>graph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const internal::LinkJointGraph &amp; graph </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Provides access to the internal::LinkJointGraph. </p>
<p>You can use <a class="el" href="#a262bfea040b50f4e5db5cb8778161655" title="(Internal use only) Provides access to the internal::LinkJointGraph.">graph()</a>.forest() to access the as-built internal::SpanningForest if you've already called <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </p>

</div>
</div>
<a id="a0fbda7f9bfa1e15586be2c35abafd03a" name="a0fbda7f9bfa1e15586be2c35abafd03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fbda7f9bfa1e15586be2c35abafd03a">&#9670;&#160;</a></span>gravity_field()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_uniform_gravity_field_element.html">UniformGravityFieldElement</a>&lt; T &gt; &amp; gravity_field </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An accessor to the current gravity field. </p>

</div>
</div>
<a id="a8414166617acf540e58c360f9cc9714f" name="a8414166617acf540e58c360f9cc9714f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8414166617acf540e58c360f9cc9714f">&#9670;&#160;</a></span>has_body()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool has_body </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">BodyIndex</a></td>          <td class="paramname"><span class="paramname"><em>body_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if plant has a rigid body with unique index <span class="tt">body_index</span>. </p>

</div>
</div>
<a id="aee8d8c1e520c405dc36cbffccbfe2ad8" name="aee8d8c1e520c405dc36cbffccbfe2ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8d8c1e520c405dc36cbffccbfe2ad8">&#9670;&#160;</a></span>has_joint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool has_joint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a></td>          <td class="paramname"><span class="paramname"><em>joint_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if plant has a joint with unique index <span class="tt">joint_index</span>. </p>
<p>The value could be false if the joint was removed using <a class="el" href="#af9ac269076a123de9d88132d946d0827" title="Removes and deletes joint from this MultibodyPlant.">RemoveJoint()</a>. </p>

</div>
</div>
<a id="a3fc00564be4a547c6ba3d476ab128d2c" name="a3fc00564be4a547c6ba3d476ab128d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc00564be4a547c6ba3d476ab128d2c">&#9670;&#160;</a></span>has_joint_actuator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool has_joint_actuator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a></td>          <td class="paramname"><span class="paramname"><em>actuator_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if plant has a joint actuator with unique index <span class="tt">actuator_index</span>. </p>
<p>The value could be false if the actuator was removed using <a class="el" href="#ae9eafac01a6cf0c90fa9005418ee2ec8" title="Removes and deletes actuator from this MultibodyPlant.">RemoveJointActuator()</a>. </p>

</div>
</div>
<a id="ad6b97bb53425156402e7f46d72859e1e" name="ad6b97bb53425156402e7f46d72859e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b97bb53425156402e7f46d72859e1e">&#9670;&#160;</a></span>has_sampled_output_ports()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool has_sampled_output_ports </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) If <span class="tt">this</span> plant is continuous (i.e., is_discrete() is <span class="tt">false</span>), returns false. </p>
<p>If <span class="tt">this</span> plant is discrete, returns whether or not the output ports are sampled (change only at a time step boundary) or live (instantaneously reflect changes to the input ports). See <a class="el" href="#output_port_sampling">Output port sampling</a> for details. </p>

</div>
</div>
<a id="a5aa037adf3002834caa1aedd305fa36d" name="a5aa037adf3002834caa1aedd305fa36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa037adf3002834caa1aedd305fa36d">&#9670;&#160;</a></span>HasBodyNamed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool HasBodyNamed </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if a body named <span class="tt">name</span> was added to the MultibodyPlant. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2f347b072b9cdb7b584f7098ba7c451c" title="Creates a rigid body with the provided name and spatial inertia.">AddRigidBody()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the body name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6d3aab3bdad70348d9201bb855bcde7" name="ae6d3aab3bdad70348d9201bb855bcde7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d3aab3bdad70348d9201bb855bcde7">&#9670;&#160;</a></span>HasBodyNamed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool HasBodyNamed </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if a body named <span class="tt">name</span> was added to the MultibodyPlant in <code class="param">model_instance</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2f347b072b9cdb7b584f7098ba7c451c" title="Creates a rigid body with the provided name and spatial inertia.">AddRigidBody()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code class="param">model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f099f6f98dbec124151d83b25fe2edc" name="a8f099f6f98dbec124151d83b25fe2edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f099f6f98dbec124151d83b25fe2edc">&#9670;&#160;</a></span>HasFrameNamed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool HasFrameNamed </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if a frame named <span class="tt">name</span> was added to the model. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8026d4144953acf4c1d89b128f678ba0" title="This method adds a Frame of type FrameType&lt;T&gt;.">AddFrame()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the frame name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26990e5cf2851439bbfb5c89e18362e3" name="a26990e5cf2851439bbfb5c89e18362e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26990e5cf2851439bbfb5c89e18362e3">&#9670;&#160;</a></span>HasFrameNamed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool HasFrameNamed </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if a frame named <span class="tt">name</span> was added to <code class="param">model_instance</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8026d4144953acf4c1d89b128f678ba0" title="This method adds a Frame of type FrameType&lt;T&gt;.">AddFrame()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code class="param">model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bfcc73831e073c659a3c6503e0e1e6a" name="a7bfcc73831e073c659a3c6503e0e1e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfcc73831e073c659a3c6503e0e1e6a">&#9670;&#160;</a></span>HasJointActuatorNamed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool HasJointActuatorNamed </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if an actuator named <span class="tt">name</span> was added to this model. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae6e70af2d399ab5b665a3f36a5ada172" title="Creates and adds a JointActuator model for an actuator acting on a given joint.">AddJointActuator()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the actuator name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1f7756f142c8453aca4b70542b90d00" name="af1f7756f142c8453aca4b70542b90d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f7756f142c8453aca4b70542b90d00">&#9670;&#160;</a></span>HasJointActuatorNamed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool HasJointActuatorNamed </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if an actuator named <span class="tt">name</span> was added to <code class="param">model_instance</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae6e70af2d399ab5b665a3f36a5ada172" title="Creates and adds a JointActuator model for an actuator acting on a given joint.">AddJointActuator()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code class="param">model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5cc2bf03e1b34a63539f8e104425729" name="af5cc2bf03e1b34a63539f8e104425729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5cc2bf03e1b34a63539f8e104425729">&#9670;&#160;</a></span>HasJointNamed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool HasJointNamed </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if a joint named <span class="tt">name</span> was added to this model. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a80c10ac818d74ed590875fd07f477671" title="This method adds a Joint of type JointType between two bodies.">AddJoint()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the joint name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add62ae8b7ca0c50c87fc93abbf8fd843" name="add62ae8b7ca0c50c87fc93abbf8fd843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add62ae8b7ca0c50c87fc93abbf8fd843">&#9670;&#160;</a></span>HasJointNamed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool HasJointNamed </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if a joint named <span class="tt">name</span> was added to <code class="param">model_instance</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a80c10ac818d74ed590875fd07f477671" title="This method adds a Joint of type JointType between two bodies.">AddJoint()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code class="param">model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae12f32b40b7a41c3aa933ed74b2417fb" name="ae12f32b40b7a41c3aa933ed74b2417fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12f32b40b7a41c3aa933ed74b2417fb">&#9670;&#160;</a></span>HasModelInstanceNamed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool HasModelInstanceNamed </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if a model instance named <span class="tt">name</span> was added to this model. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4edf1daa65069a26255c903b02bce4c6" title="Creates a new model instance.">AddModelInstance()</a>. </dd></dl>

</div>
</div>
<a id="a7f07529f78963c62ca6a651a96619fbe" name="a7f07529f78963c62ca6a651a96619fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f07529f78963c62ca6a651a96619fbe">&#9670;&#160;</a></span>HasUniqueFloatingBaseBody()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool HasUniqueFloatingBaseBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if there is a single base body in the model given by <span class="tt">model_instance</span>, and that body is a floating base body. </p>
<p>See <a class="el" href="#mbp_working_with_free_bodies">above for details</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">model_instance</span> is not valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a24ec51f3cfb9ff7bb1a19034abe25d3a" title="If there is a single base body in the model given by model_instance, and that body is a floating base...">GetUniqueFloatingBaseBodyOrThrow()</a> </dd></dl>

</div>
</div>
<a id="afc9ce98e9025085b7511227e5d12ebf1" name="afc9ce98e9025085b7511227e5d12ebf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9ce98e9025085b7511227e5d12ebf1">&#9670;&#160;</a></span>HasUniqueFreeBaseBody()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool HasUniqueFreeBaseBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000028">Deprecated</a></b></dt><dd>Use HasUniqueFloatingBaseBody() instead. <br  />
 This will be removed from Drake on or after 2026-06-01. </dd></dl>

</div>
</div>
<a id="acf7bb2a3531c09a97fb3623ac582d840" name="acf7bb2a3531c09a97fb3623ac582d840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf7bb2a3531c09a97fb3623ac582d840">&#9670;&#160;</a></span>is_finalized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_finalized </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if this MultibodyPlant was finalized with a call to <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </dd></dl>

</div>
</div>
<a id="a5e8ecddaf1d1c2b4389e028d7b1b66e8" name="a5e8ecddaf1d1c2b4389e028d7b1b66e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8ecddaf1d1c2b4389e028d7b1b66e8">&#9670;&#160;</a></span>is_gravity_enabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_gravity_enabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> iff gravity is enabled for <span class="tt">model_instance</span>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aef9f4c4f6df3cdd1f69b014a6fb0b333" title="Sets is_gravity_enabled() for model_instance to is_enabled.">set_gravity_enabled()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the model instance is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a609a2709f986c17f80438eac93e829" name="a9a609a2709f986c17f80438eac93e829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a609a2709f986c17f80438eac93e829">&#9670;&#160;</a></span>IsAnchored()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool IsAnchored </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if <code class="param">body</code> is anchored (i.e. </p>
<p>the kinematic path between <code class="param">body</code> and the world only contains weld joints.) </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa20199c5afe02d72dab2e59f1523fcae" name="aa20199c5afe02d72dab2e59f1523fcae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20199c5afe02d72dab2e59f1523fcae">&#9670;&#160;</a></span>IsVelocityEqualToQDot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool IsVelocityEqualToQDot </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the generalized velocity v is exactly the time derivative q̇ of the generalized coordinates q. </p>
<p>In this case <a class="el" href="#ae1a772571ef9869938fd98b5a4c635f5" title="Transforms the time derivative qdot of the generalized positions vector q (stored in context) to gene...">MapQDotToVelocity()</a> and <a class="el" href="#aad7c5cf6df811b52e1622f085a63d8c5" title="Transforms generalized velocities v to time derivatives qdot of the generalized positions vector q (s...">MapVelocityToQDot()</a> implement the identity map. This method is, in the worst case, O(n), where n is the number of joints. </p>

</div>
</div>
<a id="aa4dc238d06e942e23f0d948f96bc3cfb" name="aa4dc238d06e942e23f0d948f96bc3cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4dc238d06e942e23f0d948f96bc3cfb">&#9670;&#160;</a></span>MakeActuationMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; MakeActuationMatrix </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method creates an actuation matrix B mapping a vector of actuation values u into generalized forces <span class="tt">tau_u = B * u</span>, where B is a matrix of size <span class="tt">nv x nu</span> with <span class="tt">nu</span> equal to <a class="el" href="#ae3fc8de8de8eaf2d37a24c79d6be8e97" title="Returns the total number of actuated degrees of freedom.">num_actuated_dofs()</a> and <span class="tt">nv</span> equal to <a class="el" href="#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a>. </p>
<p>The vector u of actuation values is of size <a class="el" href="#ae3fc8de8de8eaf2d37a24c79d6be8e97" title="Returns the total number of actuated degrees of freedom.">num_actuated_dofs()</a>. For a given <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a>, <span class="tt">u[<a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#a42d883dde11e65819319f8060b0843b4" title="Returns the index to the first element for this joint actuator / within the vector of actuation input...">JointActuator::input_start()</a>]</span> stores the value for the external actuation corresponding to that actuator. <span class="tt">tau_u</span> on the other hand is indexed by generalized velocity indices according to <span class="tt"><a class="el" href="classdrake_1_1multibody_1_1_joint.html#ae24835fcef569246252959b18d0027d6" title="Returns the index to the first generalized velocity for this joint within the vector v of generalized...">Joint::velocity_start()</a></span>. </p><dl class="section warning"><dt>Warning</dt><dd>B is a permutation matrix. While making a permutation has <span class="tt">O(n)</span> complexity, making a full B matrix has <span class="tt">O(n²)</span> complexity. For most applications this cost can be neglected but it could become significant for very large systems. </dd></dl>

</div>
</div>
<a id="a5746187726bdac7a915a2435e0cba13e" name="a5746187726bdac7a915a2435e0cba13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5746187726bdac7a915a2435e0cba13e">&#9670;&#160;</a></span>MakeActuationMatrixPseudoinverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::SparseMatrix&lt; <a class="el" href="classdouble.html">double</a> &gt; MakeActuationMatrixPseudoinverse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the pseudoinverse of the actuation matrix B directly (without requiring an explicit inverse calculation). </p>
<p>See <a class="el" href="#aa4dc238d06e942e23f0d948f96bc3cfb" title="This method creates an actuation matrix B mapping a vector of actuation values u into generalized for...">MakeActuationMatrix()</a>.</p>
<p>Notably, when B is full row rank (the system is fully actuated), then the pseudoinverse is a true inverse. </p>

</div>
</div>
<a id="a91d9ba2b26eb3887a1e277875a5af127" name="a91d9ba2b26eb3887a1e277875a5af127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d9ba2b26eb3887a1e277875a5af127">&#9670;&#160;</a></span>MakeActuatorSelectorMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; MakeActuatorSelectorMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>user_to_actuator_index_map</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method allows user to map a vector <span class="tt">uₛ</span> containing the actuation for a set of selected actuators into the vector u containing the actuation values for <span class="tt">this</span> full model. </p>
<p>The mapping, or selection, is returned in the form of a selector matrix Su such that <span class="tt">u = Su⋅uₛ</span>. The size nₛ of uₛ is always smaller or equal than the size of the full vector of actuation values u. That is, a user might be interested in only a given subset of actuators in the model.</p>
<p>This selection matrix is particularly useful when adding PID control on a portion of the state, see <a class="el" href="classdrake_1_1systems_1_1controllers_1_1_pid_controller.html" title="Implements the PID controller.">systems::controllers::PidController</a>.</p>
<p>A user specifies the preferred order in uₛ via <span class="tt">user_to_actuator_index_map</span>. The actuation values in uₛ are a concatenation of the values for each actuator in the order they appear in <span class="tt">user_to_actuator_index_map</span>. The actuation value in the full vector of actuation values <span class="tt">u</span> for a particular actuator can be found at offset <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#a42d883dde11e65819319f8060b0843b4" title="Returns the index to the first element for this joint actuator / within the vector of actuation input...">JointActuator::input_start()</a>. </p>

</div>
</div>
<a id="af90a2eb58b242d1a85176e32435004c9" name="af90a2eb58b242d1a85176e32435004c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90a2eb58b242d1a85176e32435004c9">&#9670;&#160;</a></span>MakeActuatorSelectorMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; MakeActuatorSelectorMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>user_to_joint_index_map</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternative signature to build an actuation selector matrix <span class="tt">Su</span> such that <span class="tt">u = Su⋅uₛ</span>, where u is the vector of actuation values for the full model (see <a class="el" href="#a69ef9262ffab02b34bdf20449aab7551" title="Returns a constant reference to the input port for external actuation for all actuated dofs.">get_actuation_input_port()</a>) and uₛ is a vector of actuation values for the actuators acting on the joints listed by <span class="tt">user_to_joint_index_map</span>. </p>
<p>It is assumed that all joints referenced by <span class="tt">user_to_joint_index_map</span> are actuated. See MakeActuatorSelectorMatrix(const std::vector&lt;JointActuatorIndex&gt;&amp;) for details. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if any of the joints in <span class="tt">user_to_joint_index_map</span> does not have an actuator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c93a7afbc73ba1624288d42c1f97600" name="a8c93a7afbc73ba1624288d42c1f97600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c93a7afbc73ba1624288d42c1f97600">&#9670;&#160;</a></span>MakeQDotToVelocityMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::SparseMatrix&lt; T &gt; MakeQDotToVelocityMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the matrix <span class="tt">N⁺(q)</span>, which maps <span class="tt">v = N⁺(q)⋅q̇</span>, as described in <a class="el" href="#ae1a772571ef9869938fd98b5a4c635f5" title="Transforms the time derivative qdot of the generalized positions vector q (stored in context) to gene...">MapQDotToVelocity()</a>. </p>
<p>Prefer calling <a class="el" href="#ae1a772571ef9869938fd98b5a4c635f5" title="Transforms the time derivative qdot of the generalized positions vector q (stored in context) to gene...">MapQDotToVelocity()</a> directly; this entry point is provided to support callers that require the explicit linear form (once q is given) of the relationship. This method is, in the worst case, O(n), where n is the number of joints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aad7c5cf6df811b52e1622f085a63d8c5" title="Transforms generalized velocities v to time derivatives qdot of the generalized positions vector q (s...">MapVelocityToQDot()</a> </dd></dl>

</div>
</div>
<a id="ae1c9973e5bec9022fa46dfcedb34df84" name="ae1c9973e5bec9022fa46dfcedb34df84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c9973e5bec9022fa46dfcedb34df84">&#9670;&#160;</a></span>MakeStateSelectorMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; MakeStateSelectorMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>user_to_joint_index_map</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method allows users to map the state of <span class="tt">this</span> model, x, into a vector of selected state xₛ with a given preferred ordering. </p>
<p>The mapping, or selection, is returned in the form of a selector matrix Sx such that <span class="tt">xₛ = Sx⋅x</span>. The size nₛ of xₛ is always smaller or equal than the size of the full state x. That is, a user might be interested in only a given portion of the full state x.</p>
<p>This selection matrix is particularly useful when adding PID control on a portion of the state, see <a class="el" href="classdrake_1_1systems_1_1controllers_1_1_pid_controller.html" title="Implements the PID controller.">systems::controllers::PidController</a>.</p>
<p>A user specifies the preferred order in xₛ via <span class="tt">user_to_joint_index_map</span>. The selected state is built such that selected positions are followed by selected velocities, as in <span class="tt">xₛ = [qₛ, vₛ]</span>. The positions in qₛ are a concatenation of the positions for each joint in the order they appear in <span class="tt">user_to_joint_index_map</span>. That is, the positions for <span class="tt">user_to_joint_index_map[0]</span> are first, followed by the positions for <span class="tt">user_to_joint_index_map[1]</span>, etc. Similarly for the selected velocities vₛ.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there are repeated indices in <span class="tt">user_to_joint_index_map</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad91322eedc3ad026f5c1cb3b8d6c6b7" name="aad91322eedc3ad026f5c1cb3b8d6c6b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad91322eedc3ad026f5c1cb3b8d6c6b7">&#9670;&#160;</a></span>MakeVelocityToQDotMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::SparseMatrix&lt; T &gt; MakeVelocityToQDotMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the matrix <span class="tt">N(q)</span>, which maps <span class="tt">q̇ = N(q)⋅v</span>, as described in <a class="el" href="#aad7c5cf6df811b52e1622f085a63d8c5" title="Transforms generalized velocities v to time derivatives qdot of the generalized positions vector q (s...">MapVelocityToQDot()</a>. </p>
<p>Prefer calling <a class="el" href="#aad7c5cf6df811b52e1622f085a63d8c5" title="Transforms generalized velocities v to time derivatives qdot of the generalized positions vector q (s...">MapVelocityToQDot()</a> directly; this entry point is provided to support callers that require the explicit linear form (once q is given) of the relationship. Do not take the (pseudo-)inverse of <span class="tt">N(q)</span>; call MakeQDotToVelocityMap instead. This method is, in the worst case, O(n), where n is the number of joints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aad7c5cf6df811b52e1622f085a63d8c5" title="Transforms generalized velocities v to time derivatives qdot of the generalized positions vector q (s...">MapVelocityToQDot()</a> </dd></dl>

</div>
</div>
<a id="ae1a772571ef9869938fd98b5a4c635f5" name="ae1a772571ef9869938fd98b5a4c635f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a772571ef9869938fd98b5a4c635f5">&#9670;&#160;</a></span>MapQDotToVelocity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MapQDotToVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>qdot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms the time derivative <span class="tt">qdot</span> of the generalized positions vector <span class="tt">q</span> (stored in <span class="tt">context</span>) to generalized velocities <span class="tt">v</span>. </p>
<p><span class="tt">v</span> and <span class="tt">q̇</span> are related linearly by <span class="tt">q̇ = N(q)⋅v</span>. Although <span class="tt">N(q)</span> is not necessarily square, its left pseudo-inverse <span class="tt">N⁺(q)</span> can be used to invert that relationship without residual error, provided that <span class="tt">qdot</span> is in the range space of <span class="tt">N(q)</span> (that is, if it <em>could</em> have been produced as <span class="tt">q̇ = N(q)⋅v</span> for some <span class="tt">v</span>). Using the configuration <span class="tt">q</span> stored in the given <span class="tt">context</span> this method calculates <span class="tt">v = N⁺(q)⋅q̇</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qdot</td><td>A vector containing the time derivatives of the generalized positions. This method aborts if <span class="tt">qdot</span> is not of size <a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">num_positions()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>A valid (non-null) pointer to a vector in <span class="tt">ℛⁿ</span> with n the number of generalized velocities. This method aborts if v is nullptr or if it is not of size <a class="el" href="#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aad7c5cf6df811b52e1622f085a63d8c5" title="Transforms generalized velocities v to time derivatives qdot of the generalized positions vector q (s...">MapVelocityToQDot()</a> </dd>
<dd>
Mobilizer::MapQDotToVelocity() </dd></dl>

</div>
</div>
<a id="aad7c5cf6df811b52e1622f085a63d8c5" name="aad7c5cf6df811b52e1622f085a63d8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad7c5cf6df811b52e1622f085a63d8c5">&#9670;&#160;</a></span>MapVelocityToQDot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MapVelocityToQDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>qdot</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms generalized velocities v to time derivatives <span class="tt">qdot</span> of the generalized positions vector <span class="tt">q</span> (stored in <span class="tt">context</span>). </p>
<p><span class="tt">v</span> and <span class="tt">qdot</span> are related linearly by <span class="tt">q̇ = N(q)⋅v</span>. Using the configuration <span class="tt">q</span> stored in the given <span class="tt">context</span> this method calculates <span class="tt">q̇ = N(q)⋅v</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>A vector of generalized velocities for this model. This method aborts if v is not of size <a class="el" href="#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qdot</td><td>A valid (non-null) pointer to a vector in <span class="tt">ℝⁿ</span> with n being the number of generalized positions in this model, given by <span class="tt"><a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">num_positions()</a></span>. This method aborts if <span class="tt">qdot</span> is nullptr or if it is not of size <a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">num_positions()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae1a772571ef9869938fd98b5a4c635f5" title="Transforms the time derivative qdot of the generalized positions vector q (stored in context) to gene...">MapQDotToVelocity()</a> </dd>
<dd>
Mobilizer::MapVelocityToQDot() </dd></dl>

</div>
</div>
<a id="ae61da45e6c6c646b11b8ea4a53bcbd32" name="ae61da45e6c6c646b11b8ea4a53bcbd32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61da45e6c6c646b11b8ea4a53bcbd32">&#9670;&#160;</a></span>mutable_deformable_model()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_deformable_model.html">DeformableModel</a>&lt; T &gt; &amp; mutable_deformable_model </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable reference to the <a class="el" href="classdrake_1_1multibody_1_1_deformable_model.html" title="DeformableModel implements the interface in PhysicalModel and provides the functionalities to specify...">DeformableModel</a> owned by this plant. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the plant is finalized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This feature is considered to be <b>experimental</b> and may change or be removed at any time, without any deprecation notice ahead of time. </dd></dl>

</div>
</div>
<a id="a3218db3534d3bfccc59eb387d04fc884" name="a3218db3534d3bfccc59eb387d04fc884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3218db3534d3bfccc59eb387d04fc884">&#9670;&#160;</a></span>mutable_gravity_field()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_uniform_gravity_field_element.html">UniformGravityFieldElement</a>&lt; T &gt; &amp; mutable_gravity_field </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A mutable accessor to the current gravity field. </p>

</div>
</div>
<a id="ae3fc8de8de8eaf2d37a24c79d6be8e97" name="ae3fc8de8de8eaf2d37a24c79d6be8e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3fc8de8de8eaf2d37a24c79d6be8e97">&#9670;&#160;</a></span>num_actuated_dofs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_actuated_dofs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total number of actuated degrees of freedom. </p>
<p>That is, the vector of actuation values u has this size. See <a class="el" href="#ae6e70af2d399ab5b665a3f36a5ada172" title="Creates and adds a JointActuator model for an actuator acting on a given joint.">AddJointActuator()</a>. </p>

</div>
</div>
<a id="a279e31367e76849d4a45fd7db0f116f1" name="a279e31367e76849d4a45fd7db0f116f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279e31367e76849d4a45fd7db0f116f1">&#9670;&#160;</a></span>num_actuated_dofs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_actuated_dofs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total number of actuated degrees of freedom for a specific model instance. </p>
<p>That is, the vector of actuation values u has this size. See <a class="el" href="#ae6e70af2d399ab5b665a3f36a5ada172" title="Creates and adds a JointActuator model for an actuator acting on a given joint.">AddJointActuator()</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8601c026e9807127b4dd41e7585d2cfc" name="a8601c026e9807127b4dd41e7585d2cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8601c026e9807127b4dd41e7585d2cfc">&#9670;&#160;</a></span>num_actuators() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_actuators </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of joint actuators in the model. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae6e70af2d399ab5b665a3f36a5ada172" title="Creates and adds a JointActuator model for an actuator acting on a given joint.">AddJointActuator()</a>. </dd></dl>

</div>
</div>
<a id="a2ced71a0d382b846bf68813aa3ab93d6" name="a2ced71a0d382b846bf68813aa3ab93d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ced71a0d382b846bf68813aa3ab93d6">&#9670;&#160;</a></span>num_actuators() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_actuators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of actuators for a specific model instance. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff063ba2ef6ea43b0abf574e27846c29" name="aff063ba2ef6ea43b0abf574e27846c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff063ba2ef6ea43b0abf574e27846c29">&#9670;&#160;</a></span>num_ball_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_ball_constraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total number of ball constraints specified by the user. </p>

</div>
</div>
<a id="af92b53211e54243aff4490a700168eb4" name="af92b53211e54243aff4490a700168eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92b53211e54243aff4490a700168eb4">&#9670;&#160;</a></span>num_bodies()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_bodies </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a> elements in the model, including the "world" <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a>, which is always part of the model. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2f347b072b9cdb7b584f7098ba7c451c" title="Creates a rigid body with the provided name and spatial inertia.">AddRigidBody()</a>. </dd></dl>

</div>
</div>
<a id="ac1b107ecf3446e56cb203461440200c1" name="ac1b107ecf3446e56cb203461440200c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b107ecf3446e56cb203461440200c1">&#9670;&#160;</a></span>num_collision_geometries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_collision_geometries </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of geometries registered for contact modeling. </p>
<p>This method can be called at any time during the lifetime of <span class="tt">this</span> plant, either pre- or post-finalize, see <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. Post-finalize calls will always return the same value. </p>

</div>
</div>
<a id="a23f1475b0c301d9d78814fce265fd6ea" name="a23f1475b0c301d9d78814fce265fd6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f1475b0c301d9d78814fce265fd6ea">&#9670;&#160;</a></span>num_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_constraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total number of constraints specified by the user. </p>

</div>
</div>
<a id="aabbb62902b23cee44ddb8a5ad0b04e07" name="aabbb62902b23cee44ddb8a5ad0b04e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbb62902b23cee44ddb8a5ad0b04e07">&#9670;&#160;</a></span>num_coupler_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_coupler_constraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total number of coupler constraints specified by the user. </p>

</div>
</div>
<a id="adcd3b83abdfc7ffd22359f73c540f166" name="adcd3b83abdfc7ffd22359f73c540f166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd3b83abdfc7ffd22359f73c540f166">&#9670;&#160;</a></span>num_distance_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_distance_constraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total number of distance constraints specified by the user. </p>

</div>
</div>
<a id="a6b7f0267d163693025fa04f78bb18333" name="a6b7f0267d163693025fa04f78bb18333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7f0267d163693025fa04f78bb18333">&#9670;&#160;</a></span>num_force_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_force_elements </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> objects. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a82719521a8b2d69b6d3ce0bbb462d6e8" title="Adds a new force element model of type ForceElementType to this MultibodyPlant.">AddForceElement()</a>. </dd></dl>

</div>
</div>
<a id="ada7f02e861a8f89fc0b575b2f30333d3" name="ada7f02e861a8f89fc0b575b2f30333d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7f02e861a8f89fc0b575b2f30333d3">&#9670;&#160;</a></span>num_frames()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_frames </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame) of its underl...">Frame</a> objects in this model. </p>
<p>Frames include body frames associated with each of the bodies, including the <em>world</em> body. This means the minimum number of frames is one. </p>

</div>
</div>
<a id="a636804b6c40e538d83d5c2dfefb7929e" name="a636804b6c40e538d83d5c2dfefb7929e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636804b6c40e538d83d5c2dfefb7929e">&#9670;&#160;</a></span>num_joints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_joints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of joints in the model. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a80c10ac818d74ed590875fd07f477671" title="This method adds a Joint of type JointType between two bodies.">AddJoint()</a>. </dd></dl>

</div>
</div>
<a id="ac89140adb93cb9e507f71c30eb783198" name="ac89140adb93cb9e507f71c30eb783198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89140adb93cb9e507f71c30eb783198">&#9670;&#160;</a></span>num_model_instances()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_model_instances </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of model instances in the model. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4edf1daa65069a26255c903b02bce4c6" title="Creates a new model instance.">AddModelInstance()</a>. </dd></dl>

</div>
</div>
<a id="ac80c61762d32b97a34f02a0374fc6fe3" name="ac80c61762d32b97a34f02a0374fc6fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80c61762d32b97a34f02a0374fc6fe3">&#9670;&#160;</a></span>num_multibody_states() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_multibody_states </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the multibody system state vector x = [q v]. </p>
<p>This will be <span class="tt"><a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">num_positions()</a></span> plus <span class="tt"><a class="el" href="#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a></span>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07d0d29cbbe6e1de7cbaf90fefc5e652" name="a07d0d29cbbe6e1de7cbaf90fefc5e652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d0d29cbbe6e1de7cbaf90fefc5e652">&#9670;&#160;</a></span>num_multibody_states() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_multibody_states </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the multibody system state vector xᵢ = [qᵢ vᵢ] for model instance i. </p>
<p>(Here qᵢ ⊆ q and vᵢ ⊆ v.) will be <span class="tt">num_positions(model_instance)</span> plus <span class="tt">num_velocities(model_instance)</span>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba2887f0ca1fbbdfb49cf6b0ee21e553" name="aba2887f0ca1fbbdfb49cf6b0ee21e553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2887f0ca1fbbdfb49cf6b0ee21e553">&#9670;&#160;</a></span>num_positions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_positions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the generalized position vector q for this model. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab669e070e6178c4aeeb067a1f4b6122e" name="ab669e070e6178c4aeeb067a1f4b6122e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab669e070e6178c4aeeb067a1f4b6122e">&#9670;&#160;</a></span>num_positions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_positions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the generalized position vector qᵢ for model instance i. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abea05e15475afa8545b1ce34795261a6" name="abea05e15475afa8545b1ce34795261a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea05e15475afa8545b1ce34795261a6">&#9670;&#160;</a></span>num_tendon_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_tendon_constraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total number of tendon constraints specified by the user. </p>

</div>
</div>
<a id="ae0163ac0976659d811e3337647ff0313" name="ae0163ac0976659d811e3337647ff0313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0163ac0976659d811e3337647ff0313">&#9670;&#160;</a></span>num_velocities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_velocities </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the generalized velocity vector v for this model. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a686a8389beffdc5fb8a7690967e741" name="a0a686a8389beffdc5fb8a7690967e741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a686a8389beffdc5fb8a7690967e741">&#9670;&#160;</a></span>num_velocities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_velocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the generalized velocity vector vᵢ for model instance i. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7c0b698e0102d42f085ca39f337b019" name="aa7c0b698e0102d42f085ca39f337b019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c0b698e0102d42f085ca39f337b019">&#9670;&#160;</a></span>num_visual_geometries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_visual_geometries </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of geometries registered for visualization. </p>
<p>This method can be called at any time during the lifetime of <span class="tt">this</span> plant, either pre- or post-finalize, see <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. Post-finalize calls will always return the same value. </p>

</div>
</div>
<a id="a96b8512dd5edf0fcb41d2ebd2e650bf7" name="a96b8512dd5edf0fcb41d2ebd2e650bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b8512dd5edf0fcb41d2ebd2e650bf7">&#9670;&#160;</a></span>num_weld_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_weld_constraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total number of weld constraints specified by the user. </p>

</div>
</div>
<a id="abaf942dfd740bf10fda323de2710b211" name="abaf942dfd740bf10fda323de2710b211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf942dfd740bf10fda323de2710b211">&#9670;&#160;</a></span>NumBodiesWithName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int NumBodiesWithName </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The total number of bodies (across all model instances) with the given name. </dd></dl>

</div>
</div>
<a id="a4fef5f5f8133f2d54825ef109c80f1c2" name="a4fef5f5f8133f2d54825ef109c80f1c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fef5f5f8133f2d54825ef109c80f1c2">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a47a63154823dffd5838329527aafbd58">MultibodyPlant</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a47a63154823dffd5838329527aafbd58">MultibodyPlant</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f52507b11d3c1c5f7d9364d363457e6" name="a5f52507b11d3c1c5f7d9364d363457e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f52507b11d3c1c5f7d9364d363457e6">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a47a63154823dffd5838329527aafbd58">MultibodyPlant</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a47a63154823dffd5838329527aafbd58">MultibodyPlant</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a6d28ce9c8119bee923e827eb6f02ed" name="a4a6d28ce9c8119bee923e827eb6f02ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6d28ce9c8119bee923e827eb6f02ed">&#9670;&#160;</a></span>RegisterAsSourceForSceneGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1geometry.html#ac53cb597123131fb23a7af26e8d350bf">geometry::SourceId</a> RegisterAsSourceForSceneGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>scene_graph</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers <span class="tt">this</span> plant to serve as a source for an instance of SceneGraph. </p>
<p>This registration allows MultibodyPlant to register geometry with <span class="tt">scene_graph</span> for visualization and/or collision queries. The string returned by <span class="tt">this-&gt;<a class="el" href="classdrake_1_1systems_1_1_system_base.html#a28946d25d4b7a62a454a700665874285" title="Returns the name last supplied to set_name(), if any.">get_name()</a></span> is passed to SceneGraph's RegisterSource, so it is highly recommended that you give the plant a recognizable name before calling this. Successive registration calls with SceneGraph <b>must</b> be performed on the same instance to which the pointer argument <span class="tt">scene_graph</span> points to. Failure to do so will result in runtime exceptions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scene_graph</td><td>A valid non nullptr to the SceneGraph instance for which <span class="tt">this</span> plant will sever as a source, see SceneGraph documentation for further details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the SourceId of <span class="tt">this</span> plant in <span class="tt">scene_graph</span>. It can also later on be retrieved with <a class="el" href="#a6e219dfe1b9145c9c244a4195bc382a6" title="Returns the unique id identifying this plant as a source for a SceneGraph.">get_source_id()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called post-finalize. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">scene_graph</span> is the nullptr. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if called more than once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69fb5b620b296ff32415dd5d70366814" name="a69fb5b620b296ff32415dd5d70366814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fb5b620b296ff32415dd5d70366814">&#9670;&#160;</a></span>RegisterCollisionGeometry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> RegisterCollisionGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_BG</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>coulomb_friction</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload which specifies a single property: coulomb_friction. </p>

</div>
</div>
<a id="a90d32a93de07ef91744b95ed152c578d" name="a90d32a93de07ef91744b95ed152c578d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d32a93de07ef91744b95ed152c578d">&#9670;&#160;</a></span>RegisterCollisionGeometry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> RegisterCollisionGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_BG</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">geometry::ProximityProperties</a></td>          <td class="paramname"><span class="paramname"><em>properties</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers geometry in a SceneGraph with a given <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The abstract base class for all shape specifications.">geometry::Shape</a> to be used for the contact modeling of a given <span class="tt">body</span>. </p>
<p>More than one geometry can be registered with a body, in which case the body's contact geometry is the union of all geometries registered to that body.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">body</td><td>The body for which geometry is being registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_BG</td><td>The fixed pose of the geometry frame G in the body frame B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>The <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The abstract base class for all shape specifications.">geometry::Shape</a> used for collision and contact. E.g.: <a class="el" href="classdrake_1_1geometry_1_1_sphere.html" title="Definition of sphere.">geometry::Sphere</a>, <a class="el" href="classdrake_1_1geometry_1_1_cylinder.html" title="Definition of a cylinder.">geometry::Cylinder</a>, etc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">properties</td><td>The proximity properties associated with the collision geometry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called post-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5490007419496acf56fe363344abfe1e" name="a5490007419496acf56fe363344abfe1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5490007419496acf56fe363344abfe1e">&#9670;&#160;</a></span>RegisterVisualGeometry() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> RegisterVisualGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_BG</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for visual geometry registration. </p>
<p>The ("label", "id") property is set in the perception properties (as documented above).</p>
<p>See <a class="el" href="#mbp_geometry">the overview</a> for more details. </p>

</div>
</div>
<a id="af475e2acc5c4720650cf004a37f1ce95" name="af475e2acc5c4720650cf004a37f1ce95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af475e2acc5c4720650cf004a37f1ce95">&#9670;&#160;</a></span>RegisterVisualGeometry() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> RegisterVisualGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_BG</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html">geometry::IllustrationProperties</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>properties</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers geometry in a SceneGraph with a given <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The abstract base class for all shape specifications.">geometry::Shape</a> to be used for visualization of a given <span class="tt">body</span>. </p>
<p>The perception properties are a copy of the given <span class="tt">properties</span>. If the resulting perception properties do not include ("label", "id"), then it is added as documented above.</p>
<p>See <a class="el" href="#mbp_geometry">the overview</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">body</td><td>The body for which geometry is being registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_BG</td><td>The fixed pose of the geometry frame G in the body frame B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>The <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The abstract base class for all shape specifications.">geometry::Shape</a> used for visualization. E.g.: <a class="el" href="classdrake_1_1geometry_1_1_sphere.html" title="Definition of sphere.">geometry::Sphere</a>, <a class="el" href="classdrake_1_1geometry_1_1_cylinder.html" title="Definition of a cylinder.">geometry::Cylinder</a>, etc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name for the geometry. It must satisfy the requirements defined in <a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html" title="A geometry instance combines a geometry definition (i.e., a shape of some sort), a pose (relative to ...">drake::geometry::GeometryInstance</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">properties</td><td>The illustration properties for this geometry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called post-finalize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the id for the registered geometry. </dd></dl>

</div>
</div>
<a id="a5939a509468cd3c7cc7b30b1ecafa625" name="a5939a509468cd3c7cc7b30b1ecafa625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5939a509468cd3c7cc7b30b1ecafa625">&#9670;&#160;</a></span>RegisterVisualGeometry() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> RegisterVisualGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_BG</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>diffuse_color</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for visual geometry registration. </p>
<p>The following properties are set:</p><ul>
<li>("phong", "diffuse") = <span class="tt">diffuse_color</span> in both sets of properties.</li>
<li>("label", "id") in perception properties as documented above.</li>
</ul>
<p>See <a class="el" href="#mbp_geometry">the overview</a> for more details. </p>

</div>
</div>
<a id="a49e35f6a4879f7aaf6a75221962efb23" name="a49e35f6a4879f7aaf6a75221962efb23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e35f6a4879f7aaf6a75221962efb23">&#9670;&#160;</a></span>RegisterVisualGeometry() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> RegisterVisualGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html">geometry::GeometryInstance</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>geometry_instance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the given <span class="tt">geometry_instance</span> in a SceneGraph to be used for visualization of a given <span class="tt">body</span>. </p>
<p>The roles that <span class="tt">geometry_instance</span> gets assigned (illustration/perception) in SceneGraph depend solely on the properties that have <em>already</em> been assigned to <span class="tt">geometry_instance</span>. If <em>any</em> visual roles have been assigned, those will be the only roles used. If <em>no</em> visual roles have been assigned, then both roles will be assigned using the default set of property values.</p>
<p>If the registered geometry has the perception role, it will have the ("label", "id") property. Possibly assigned as documented above.</p>
<p>See <a class="el" href="#mbp_geometry">the overview</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">body</td><td>The body for which geometry is being registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">geometry_instance</td><td>The geometry to associate with the visual appearance of <span class="tt">body</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">geometry_instance</span> is null. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if called post-finalize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the id for the registered geometry. </dd></dl>

</div>
</div>
<a id="ab868821d19fbf79f94b50147c4d90b9b" name="ab868821d19fbf79f94b50147c4d90b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab868821d19fbf79f94b50147c4d90b9b">&#9670;&#160;</a></span>RemoveConstraint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RemoveConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the constraint <span class="tt">id</span> from the plant. </p>
<p>Note that this will <em>not</em> remove constraints registered directly with <a class="el" href="classdrake_1_1multibody_1_1_deformable_model.html" title="DeformableModel implements the interface in PhysicalModel and provides the functionalities to specify...">DeformableModel</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the MultibodyPlant has already been finalized. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">id</span> does not identify any multibody constraint in this plant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9ac269076a123de9d88132d946d0827" name="af9ac269076a123de9d88132d946d0827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ac269076a123de9d88132d946d0827">&#9670;&#160;</a></span>RemoveJoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RemoveJoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>joint</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and deletes <span class="tt">joint</span> from this MultibodyPlant. </p>
<p>Any existing references to <span class="tt">joint</span> will become invalid, and future calls to <span class="tt">get_joint(joint_index)</span> will throw an exception. Other elements of the plant may depend on <span class="tt">joint</span> at the time of removal and should be removed first. For example, a <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a> that depends on <span class="tt">joint</span> should be removed with <a class="el" href="#ae9eafac01a6cf0c90fa9005418ee2ec8" title="Removes and deletes actuator from this MultibodyPlant.">RemoveJointActuator()</a>. Currently, we do not provide joint dependency tracking for force elements or constraints, so this function will throw an exception if there are <em>any</em> user-added force elements or constraints in the plant.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the plant is already finalized. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the plant contains a non-zero number of user-added force elements or user-added constraints. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">joint</span> has a dependent <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a80c10ac818d74ed590875fd07f477671" title="This method adds a Joint of type JointType between two bodies.">AddJoint()</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is important to note that the <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0" title="Type used to identify joints by index within a multibody plant.">JointIndex</a> assigned to a joint is immutable. New joint indices are assigned in increasing order, even if a joint with a lower index has been removed. This has the consequence that when a joint is removed from the plant, the sequence <span class="tt">[0, <a class="el" href="#a636804b6c40e538d83d5c2dfefb7929e" title="Returns the number of joints in the model.">num_joints()</a>)</span> is not necessarily the correct set of un-removed joint indices in the plant. Thus, it is important <em>NOT</em> to loop over joint indices sequentially from <span class="tt">0</span> to <span class="tt"><a class="el" href="#a636804b6c40e538d83d5c2dfefb7929e" title="Returns the number of joints in the model.">num_joints()</a> - 1</span>. Instead users should use the provided <a class="el" href="#acf9168de86a03b26abf216dd93de6a80" title="Returns a list of all joint indices.">GetJointIndices()</a> and GetJointIndices(ModelIndex) functions: <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code hl_typedef" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> index : plant.GetJointIndices()) {</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1multibody_1_1_joint.html">Joint&lt;double&gt;</a>&amp; joint = plant.get_joint(index);</div>
<div class="line">  ...</div>
<div class="line"> }</div>
<div class="ttc" id="anamespacedrake_1_1multibody_html_a27485be8a33f5ed2ee7f3f8de9dd40c0"><div class="ttname"><a href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">drake::multibody::JointIndex</a></div><div class="ttdeci">TypeSafeIndex&lt; class JointElementTag &gt; JointIndex</div><div class="ttdoc">Type used to identify joints by index within a multibody plant.</div><div class="ttdef"><b>Definition</b> multibody_tree_indexes.h:42</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae9eafac01a6cf0c90fa9005418ee2ec8" name="ae9eafac01a6cf0c90fa9005418ee2ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9eafac01a6cf0c90fa9005418ee2ec8">&#9670;&#160;</a></span>RemoveJointActuator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RemoveJointActuator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>actuator</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and deletes <span class="tt">actuator</span> from this MultibodyPlant. </p>
<p>Any existing references to <span class="tt">actuator</span> will become invalid, and future calls to <span class="tt">get_joint_actuator(actuator_index)</span> will throw an exception.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the plant is already finalized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae6e70af2d399ab5b665a3f36a5ada172" title="Creates and adds a JointActuator model for an actuator acting on a given joint.">AddJointActuator()</a> </dd></dl>

</div>
</div>
<a id="a43433a05aa2c28c03644da7319adab9f" name="a43433a05aa2c28c03644da7319adab9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43433a05aa2c28c03644da7319adab9f">&#9670;&#160;</a></span>RenameModelInstance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RenameModelInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renames an existing model instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">model_instance</td><td>The instance to rename. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A string that uniquely identifies the instance within <span class="tt">this</span> model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called after <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">model_instance</span> is not a valid index. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if HasModelInstanceNamed(<span class="tt">name</span>) is true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada6a17fc10f55293cc507b583220f8d7" name="ada6a17fc10f55293cc507b583220f8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6a17fc10f55293cc507b583220f8d7">&#9670;&#160;</a></span>set_adjacent_bodies_collision_filters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_adjacent_bodies_collision_filters </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether to apply collision filters to topologically adjacent bodies at <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> time. </p>
<p>Filters are applied when there exists a joint between bodies, except in the case of 6-dof joints or joints in which the parent body is <span class="tt">world</span>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>iff called post-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad253ab790ff8e142080cedd210e982da" name="ad253ab790ff8e142080cedd210e982da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad253ab790ff8e142080cedd210e982da">&#9670;&#160;</a></span>set_contact_model()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_contact_model </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4e">ContactModel</a></td>          <td class="paramname"><span class="paramname"><em>model</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the contact model to be used by <span class="tt">this</span> MultibodyPlant, see <a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4e" title="Enumeration for contact model options.">ContactModel</a> for available options. </p>
<p>The default contact model is <a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea8ad3adce463edb0d2843e1f1c0057d4a" title="Contact forces are computed using the hydroelastic model, where possible.">ContactModel::kHydroelasticWithFallback</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>iff called post-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6df8a26aa42b59344e931ac9d6f5357" name="ad6df8a26aa42b59344e931ac9d6f5357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6df8a26aa42b59344e931ac9d6f5357">&#9670;&#160;</a></span>set_contact_surface_representation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_contact_surface_representation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a227f80cb57c9c87f6ecc4e839e364979">geometry::HydroelasticContactRepresentation</a></td>          <td class="paramname"><span class="paramname"><em>representation</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the representation of contact surfaces to be used by <span class="tt">this</span> MultibodyPlant. </p>
<p>See <a class="el" href="namespacedrake_1_1geometry.html#a227f80cb57c9c87f6ecc4e839e364979" title="Reports on how a hydroelastic contact surface is represented.">geometry::HydroelasticContactRepresentation</a> for available options. See <a class="el" href="#a93cf63581a2d40a28d9cf65a3017839b" title="Return the default value for contact representation, given the desired time step.">GetDefaultContactSurfaceRepresentation()</a> for explanation of default values. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called post-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b3f429ca991bd1028f4f60d6d5f2e61" name="a9b3f429ca991bd1028f4f60d6d5f2e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3f429ca991bd1028f4f60d6d5f2e61">&#9670;&#160;</a></span>set_discrete_contact_approximation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_discrete_contact_approximation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#aa1d02176591187cb83e77e9ff779d679">DiscreteContactApproximation</a></td>          <td class="paramname"><span class="paramname"><em>approximation</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the discrete contact model approximation. </p>
<dl class="section note"><dt>Note</dt><dd>Calling this method also sets the contact solver type (see <a class="el" href="#ad7698366750a09e383106a17bf9009a2" title="Returns the contact solver type used for discrete MultibodyPlant models.">get_discrete_contact_solver()</a>) according to:<ul>
<li><a class="el" href="namespacedrake_1_1multibody.html#aa1d02176591187cb83e77e9ff779d679ad454de89727cb520148830aa54cb3a90" title="TAMSI solver approximation, see [Castro et al., 2019].">DiscreteContactApproximation::kTamsi</a> sets the solver to <a class="el" href="namespacedrake_1_1multibody.html#a902306c5e0120a67c07f80e9219a3e8dad454de89727cb520148830aa54cb3a90" title="TAMSI solver, see [Castro et al., 2019].">DiscreteContactSolver::kTamsi</a>.</li>
<li><a class="el" href="namespacedrake_1_1multibody.html#aa1d02176591187cb83e77e9ff779d679ad48dc7e3221aee2d9e1af665ebfbeeec" title="SAP solver model approximation, see [Castro et al., 2022].">DiscreteContactApproximation::kSap</a>, <a class="el" href="namespacedrake_1_1multibody.html#aa1d02176591187cb83e77e9ff779d679ac9a6ebef7049abc9802a9d0705a2e976" title="Similarity approximation found in [Castro et al., 2023].">DiscreteContactApproximation::kSimilar</a> and <a class="el" href="namespacedrake_1_1multibody.html#aa1d02176591187cb83e77e9ff779d679a22387111372cb701adbd49eaa6a28261" title="Approximation in which the normal force is lagged in Coulomb&#39;s law, such that ‖γₜ‖ ≤ μ γₙ₀,...">DiscreteContactApproximation::kLagged</a> set the solver to <a class="el" href="namespacedrake_1_1multibody.html#a902306c5e0120a67c07f80e9219a3e8dad48dc7e3221aee2d9e1af665ebfbeeec" title="SAP solver, see [Castro et al., 2022].">DiscreteContactSolver::kSap</a>.</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">iff</td><td><span class="tt">this</span> plant is continuous (i.e. is_discrete() is <span class="tt">false</span>.) </td></tr>
    <tr><td class="paramname">std::exception</td><td>iff called post-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef9f4c4f6df3cdd1f69b014a6fb0b333" name="aef9f4c4f6df3cdd1f69b014a6fb0b333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef9f4c4f6df3cdd1f69b014a6fb0b333">&#9670;&#160;</a></span>set_gravity_enabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_gravity_enabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_enabled</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <a class="el" href="#a5e8ecddaf1d1c2b4389e028d7b1b66e8">is_gravity_enabled()</a> for <span class="tt">model_instance</span> to <span class="tt">is_enabled</span>. </p>
<p>The effect of <span class="tt">is_enabled = false</span> is effectively equivalent to disabling (or making zero) gravity for all bodies in the specified model instance. By default <a class="el" href="#a5e8ecddaf1d1c2b4389e028d7b1b66e8">is_gravity_enabled()</a> equals <span class="tt">true</span> for all model instances. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called post-finalize. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the model instance is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e5e058b968b927f6342a8127aea663a" name="a1e5e058b968b927f6342a8127aea663a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5e058b968b927f6342a8127aea663a">&#9670;&#160;</a></span>set_penetration_allowance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_penetration_allowance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>penetration_allowance</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structdrake_1_1multibody_1_1_multibody_plant_config.html">MultibodyPlantConfig</a>{}.penetration_allowance</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a penetration allowance used to estimate the point contact stiffness and Hunt &amp; Crossley dissipation parameters. </p>
<p>Refer to the section <a class="el" href="group__compliant__contact.html#point_contact_defaults">Point Contact Default Parameters</a> for further details.</p>
<dl class="section warning"><dt>Warning</dt><dd>This will be deprecated. Prefer using defaults specified in <a class="el" href="structdrake_1_1geometry_1_1_default_proximity_properties.html" title="These properties will be used as defaults when the geometry as added via API calls or parsed from mod...">geometry::DefaultProximityProperties</a>.</dd>
<dd>
Values provided in <a class="el" href="structdrake_1_1geometry_1_1_default_proximity_properties.html" title="These properties will be used as defaults when the geometry as added via API calls or parsed from mod...">geometry::DefaultProximityProperties</a> have precedence. If values estimated based on penetration allowance are desired, set defaults in <a class="el" href="structdrake_1_1geometry_1_1_default_proximity_properties.html" title="These properties will be used as defaults when the geometry as added via API calls or parsed from mod...">geometry::DefaultProximityProperties</a> to std::nullopt.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if penetration_allowance is not positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a857ba74bdbf10e03cbaf8acbfa4b044b" name="a857ba74bdbf10e03cbaf8acbfa4b044b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857ba74bdbf10e03cbaf8acbfa4b044b">&#9670;&#160;</a></span>set_sap_near_rigid_threshold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_sap_near_rigid_threshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>near_rigid_threshold</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structdrake_1_1multibody_1_1_multibody_plant_config.html">MultibodyPlantConfig</a>{}.sap_near_rigid_threshold</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-negative dimensionless number typically in the range [0.0, 1.0], though larger values are allowed even if uncommon. </p>
<p>This parameter controls the "near rigid" regime of the SAP solver, β in section V.B of [Castro et al., 2021]. It essentially controls a threshold value for the maximum amount of stiffness SAP can handle robustly. Beyond this value, stiffness saturates as explained in [Castro et al., 2021]. A value of 1.0 is a conservative choice to avoid ill-conditioning that might lead to softer than expected contact. If this is your case, consider turning off this approximation by setting this parameter to zero. For difficult cases where ill-conditioning is a problem, a small but non-zero number can be used, e.g. 1.0e-3. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if near_rigid_threshold is negative. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if called post-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa94cf2eeba3e27ad35132211ae6d074" name="afa94cf2eeba3e27ad35132211ae6d074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa94cf2eeba3e27ad35132211ae6d074">&#9670;&#160;</a></span>set_stiction_tolerance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_stiction_tolerance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>v_stiction</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structdrake_1_1multibody_1_1_multibody_plant_config.html">MultibodyPlantConfig</a>{}.<a class="el" href="#a0cef6f48aa258bbb487ab62cec437cb8">stiction_tolerance</a></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="anchor" id="mbp_stribeck_model"></a></p>
<h3>Stribeck model of friction</h3>
<p>Currently MultibodyPlant uses the Stribeck approximation to model dry friction. The Stribeck model of friction is an approximation to Coulomb's law of friction that allows using continuous time integration without the need to specify complementarity constraints. While this results in a simpler model immediately tractable with standard numerical methods for integration of ODE's, it often leads to stiff dynamics that require an explicit integrator to take very small time steps. It is therefore recommended to use error controlled integrators when using this model or the discrete time stepping (see <a class="el" href="group__multibody__solvers.html#multibody_simulation">Simulation of Multibody Systems with Frictional Contact</a>). See <a class="el" href="group__mbp__continuous.html#stribeck_approximation">Continuous Approximation of Coulomb Friction</a> for a detailed discussion of the Stribeck model.</p>
<p>Sets the stiction tolerance <span class="tt">v_stiction</span> for the Stribeck model, where <span class="tt">v_stiction</span> must be specified in m/s (meters per second.) <span class="tt">v_stiction</span> defaults to a value of 1 millimeter per second. In selecting a value for <span class="tt">v_stiction</span>, you must ask yourself the question, "When two objects are ostensibly in stiction, how much slip am I willing
to allow?" There are two opposing design issues in picking a value for vₛ. On the one hand, small values of vₛ make the problem numerically stiff during stiction, potentially increasing the integration cost. On the other hand, it should be picked to be appropriate for the scale of the problem. For example, a car simulation could allow a "large" value for vₛ of 1 cm/s (1×10⁻² m/s), but reasonable stiction for grasping a 10 cm box might require limiting residual slip to 1×10⁻³ m/s or less. Ultimately, picking the largest viable value will allow your simulation to run faster and more robustly. Note that <span class="tt">v_stiction</span> is the slip velocity that we'd have when we are at edge of the friction cone. For cases when the friction force is well within the friction cone the slip velocity will always be smaller than this value. See also <a class="el" href="group__mbp__continuous.html#stribeck_approximation">Continuous Approximation of Coulomb Friction</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">v_stiction</span> is non-positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a695e24adcadab868d6dd5a57f51953fd" name="a695e24adcadab868d6dd5a57f51953fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695e24adcadab868d6dd5a57f51953fd">&#9670;&#160;</a></span>SetActuationInArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetActuationInArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>u_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given actuation values <span class="tt">u_instance</span> for the actuators in <span class="tt">model_instance</span>, this function updates the actuation vector u for the entire plant model to which this actuator belongs to. </p>
<p>Refer to <a class="el" href="#mbp_actuation">Actuation</a> for further details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u_instance</td><td>Actuation values for the model instance. Values are ordered by monotonically increasing <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> within the model instance. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">u</td><td>Actuation values for the entire plant model. The actuation value in <span class="tt">u</span> for a particular actuator must be found at offset <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#a42d883dde11e65819319f8060b0843b4" title="Returns the index to the first element for this joint actuator / within the vector of actuation input...">JointActuator::input_start()</a>. Only values corresponding to <span class="tt">model_instance</span> are changed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the size of <span class="tt">u_instance</span> is not equal to the number of actuation inputs for the joints of <span class="tt">model_instance</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c9672b405425259b192131304f14f9c" name="a7c9672b405425259b192131304f14f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9672b405425259b192131304f14f9c">&#9670;&#160;</a></span>SetBaseBodyJointType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetBaseBodyJointType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#ab69d6cd821353ffa5ba779a02269852d">BaseBodyJointType</a></td>          <td class="paramname"><span class="paramname"><em>joint_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the type of joint to be used by <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> to connect any otherwise unconnected bodies to World. </p>
<p>Bodies connected by a joint to World are called <em>base bodies</em> and are determined during <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> when we build a forest structure to model the multibody system for efficient computation. See <a class="el" href="#mbp_working_with_free_bodies">Working with free bodies</a> for a longer discussion.</p>
<p>This can be set globally or for a particular model instance. Global options are used for any model elements that belong to model instances for which no options have been set explicitly. The default is to use a quaternion floating joint.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><a class="el" href="namespacedrake_1_1multibody.html#ab69d6cd821353ffa5ba779a02269852d" title="The kind of joint to be used to connect base bodies to world at Finalize().">BaseBodyJointType</a>::  </th><th class="markdownTableHeadNone">Notes  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">kQuaternionFloatingJoint  </td><td class="markdownTableBodyNone">6 dofs, unrestricted orientation  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">kRpyFloatingJoint †  </td><td class="markdownTableBodyNone">6 dofs, uses 3 angles for orientation  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">kWeldJoint  </td><td class="markdownTableBodyNone">0 dofs, welded to World ("anchored")  </td></tr>
</table>
<p>† The 3-angle orientation representation used by <a class="el" href="classdrake_1_1multibody_1_1_rpy_floating_joint.html" title="This Joint allows a rigid body to move freely with respect to its parent rigid body.">RpyFloatingJoint</a> can be easier to work with than a quaternion (especially for optimization) but has a singular orientation which must be avoided (pitch angle near 90°).</p>
<dl class="section note"><dt>Note</dt><dd>Reminder: if you aren't satisfied with the particular selection of joints here, you can always add an explicit joint to World with <a class="el" href="#a80c10ac818d74ed590875fd07f477671" title="This method adds a Joint of type JointType between two bodies.">AddJoint()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">joint_type</td><td>The joint type to be used for base bodies. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_instance</td><td>(optional) the index of the model instance to which <span class="tt">joint_type</span> is to be applied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called after <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0308169d8d70b7f20285b0d5df3f046f" name="a0308169d8d70b7f20285b0d5df3f046f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0308169d8d70b7f20285b0d5df3f046f">&#9670;&#160;</a></span>SetConstraintActiveStatus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetConstraintActiveStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>status</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the active status of the constraint given by <span class="tt">id</span> in <span class="tt">context</span>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the MultibodyPlant has not been finalized. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">context</span> == nullptr </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">id</span> does not belong to any multibody constraint in <span class="tt">context</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadfba35383b020c7184081574cbfcbbd" name="aadfba35383b020c7184081574cbfcbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfba35383b020c7184081574cbfcbbd">&#9670;&#160;</a></span>SetDefaultFloatingBaseBodyPose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetDefaultFloatingBaseBodyPose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_WB</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provisionally records a default World pose for <span class="tt">body</span>, to be used in case <span class="tt">body</span> turns out to be a floating base body after <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </p>
<p>This may be called pre- or post-Finalize(). Pre-Finalize() this is the only way to set the default pose of a floating base body. Post-Finalize(), a floating base body's default pose may be set either by this function or by setting the default pose directly through the <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> API applied to the automatically-added floating joint. The most recent value set by either method will be used to initialize the floating joint's coordinates in subsequently-created Contexts.</p>
<dl class="section warning"><dt>Warning</dt><dd>If this is called on a <span class="tt">body</span> that does <em>not</em> turn out to be a floating base body after <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>, it will have no effect other than to be echoed back in <a class="el" href="#ab368246484a46e333b6edce659f42cfb" title="Gets the provisional default pose of body as set by SetDefaultFloatingBaseBodyPose().">GetDefaultFloatingBaseBodyPose()</a>; in particular it will not affect the initial state in a subsequently-created Context. Use the <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> API to set the default pose for any body that has an explicitly-defined joint to its parent body.</dd></dl>
<p>See <a class="el" href="#mbp_working_with_free_bodies">above for details</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">body</td><td><a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a> whose default pose will be set if it turns out to be a floating base body. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_WB</td><td>Default pose of the floating base body in the World frame. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd1c4b1852853c9cf02613bfef053d8e" name="afd1c4b1852853c9cf02613bfef053d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd1c4b1852853c9cf02613bfef053d8e">&#9670;&#160;</a></span>SetDefaultFreeBodyPose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetDefaultFreeBodyPose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_PB</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000026">Deprecated</a></b></dt><dd>Use SetDefaultFloatingBaseBodyPose() instead. <br  />
 This will be removed from Drake on or after 2026-06-01. </dd></dl>

</div>
</div>
<a id="aa293696b845c071deb902d3ee6d3bcc3" name="aa293696b845c071deb902d3ee6d3bcc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa293696b845c071deb902d3ee6d3bcc3">&#9670;&#160;</a></span>SetDefaultPositions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetDefaultPositions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the default positions for the plant. </p>
<p>Calls to CreateDefaultContext or SetDefaultContext/SetDefaultState will return a Context populated with these position values. They have no other effects on the dynamics of the system. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the plant is not finalized, if q is not of size <a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">num_positions()</a>, or <span class="tt">q</span> contains non-finite values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71998d3f5e8bc65b742c03235c805fd9" name="a71998d3f5e8bc65b742c03235c805fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71998d3f5e8bc65b742c03235c805fd9">&#9670;&#160;</a></span>SetDefaultPositions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetDefaultPositions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q_instance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the default positions for the model instance. </p>
<p>Calls to CreateDefaultContext or SetDefaultContext/SetDefaultState will return a Context populated with these position values. They have no other effects on the dynamics of the system. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the plant is not finalized, if the model_instance is invalid, if the length of <span class="tt">q_instance</span> is not equal to <span class="tt">num_positions(model_instance)</span>, or if <span class="tt">q_instance</span> contains non-finite values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae73edc00d493b3f15ba7679cc14830a0" name="ae73edc00d493b3f15ba7679cc14830a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73edc00d493b3f15ba7679cc14830a0">&#9670;&#160;</a></span>SetDefaultState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetDefaultState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <span class="tt">state</span> according to defaults set by the user for joints (e.g. </p>
<p><a class="el" href="classdrake_1_1multibody_1_1_revolute_joint.html#a5608e4f04daa177004efade938e77fbf" title="Sets the default_positions of this joint (in this case a single angle).">RevoluteJoint::set_default_angle()</a>) and free bodies (<a class="el" href="#afd1c4b1852853c9cf02613bfef053d8e" title="(Deprecated.)">SetDefaultFreeBodyPose()</a>). If the user does not specify defaults, the state corresponds to zero generalized positions and velocities. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. See <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ac920e22e905b83dbc0abaaa57d2c0251">LeafSystem&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a70ab37a42372902087db6fabe55118c7" name="a70ab37a42372902087db6fabe55118c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ab37a42372902087db6fabe55118c7">&#9670;&#160;</a></span>SetDiscreteUpdateManager()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetDiscreteUpdateManager </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; internal::DiscreteUpdateManager&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>manager</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For use only by advanced developers wanting to try out their custom time stepping strategies, including contact resolution. </p>
<dl class="section warning"><dt>Warning</dt><dd>This feature is considered to be <b>experimental</b> and may change or be removed at any time, without any deprecation notice ahead of time.</dd></dl>
<p>With this method <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> takes ownership of <span class="tt">manager</span>.</p>
<dl class="section note"><dt>Note</dt><dd>Setting a contact manager bypasses the mechanism to set a different contact solver with SetContactSolver(). Use only one of these two experimental mechanisms but never both.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manager</td><td>After this call the new manager is used to advance discrete states. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>this MultibodyPlant is discrete. </dd>
<dd>
manager != nullptr. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. See <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6672fc5264442466b21708b7008421fe" name="a6672fc5264442466b21708b7008421fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6672fc5264442466b21708b7008421fe">&#9670;&#160;</a></span>SetDistanceConstraintParams()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetDistanceConstraintParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a319faaf6ac907f922a1b51dd3d32325a">MultibodyConstraintId</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_distance_constraint_params.html">DistanceConstraintParams</a></td>          <td class="paramname"><span class="paramname"><em>params</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores in <span class="tt">context</span> the parameters <span class="tt">params</span> for the distance constraint with identifier <span class="tt">id</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">context</td><td>The plant's context. On output it stores <span class="tt">params</span> for the requested distance constraint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Unique identifier of the constraint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>The new set of parameters to be stored in <span class="tt">context</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><span class="tt">id</span> is not a valid identifier for a distance constraint. </td></tr>
    <tr><td class="paramname">if</td><td>params.bodyA() or params.bodyB() do not correspond to rigid bodies in <span class="tt">this</span> MultibodyPlant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27c312732aae22e08b580998d6e09334" name="a27c312732aae22e08b580998d6e09334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c312732aae22e08b580998d6e09334">&#9670;&#160;</a></span>SetFloatingBaseBodyPoseInAnchoredFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetFloatingBaseBodyPoseInAnchoredFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_F</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_FB</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates <span class="tt">context</span> to store the World-frame pose of floating base body B, given its pose <span class="tt">X_FB</span> in an arbitrary anchored frame F. </p>
<p><a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame) of its underl...">Frame</a> F must be <em>anchored</em>, meaning that it is either on a body which is directly welded to a frame on the World body, or more generally, that it is on a body for which there is a kinematic path between that body and the world body that only includes weld joints.</p>
<dl class="section warning"><dt>Warning</dt><dd>The World-frame pose is calculated here and stored in <span class="tt">context</span>. Moving F subsequently will not change the stored pose unless you call this method again.</dd></dl>
<p>See <a class="el" href="#mbp_working_with_free_bodies">above for details</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if frame F is not anchored to the world. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">body</span> is not a floating base body. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ade7e309b20dc5f8d7010730d224381" name="a5ade7e309b20dc5f8d7010730d224381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ade7e309b20dc5f8d7010730d224381">&#9670;&#160;</a></span>SetFloatingBaseBodyPoseInWorldFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetFloatingBaseBodyPoseInWorldFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_WB</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates <span class="tt">context</span> to store the pose <span class="tt">X_WB</span> of a given floating base body B's body frame in the World frame W. </p>
<p>See <a class="el" href="#mbp_working_with_free_bodies">above for details</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">body</span> is not a floating base body. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4672adb9536501522b21851abcd9912" name="ad4672adb9536501522b21851abcd9912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4672adb9536501522b21851abcd9912">&#9670;&#160;</a></span>SetFreeBodyPose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodyPose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_JpJc</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Variant of <a class="el" href="#ae76c5ef45f57813ea469894cf79d5ef8" title="For any free body&#39;s 6-dof joint, sets context to store the pose X_JpJc of child frame Jc in its paren...">SetFreeBodyPose()</a> that writes to a given <span class="tt">state</span> rather than directly to the Context. </p>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">state</span> comes from this MultibodyPlant. </dd></dl>

</div>
</div>
<a id="ae76c5ef45f57813ea469894cf79d5ef8" name="ae76c5ef45f57813ea469894cf79d5ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76c5ef45f57813ea469894cf79d5ef8">&#9670;&#160;</a></span>SetFreeBodyPose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodyPose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_JpJc</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For any free body's 6-dof joint, sets <span class="tt">context</span> to store the pose X_JpJc of child frame Jc in its parent frame Jp. </p>
<dl class="section note"><dt>Note</dt><dd>Unless <span class="tt">body</span> is a floating base body, the parent frame Jp is not necessarily the World frame W, and the child frame Jc is not necessarily the body frame B. For a floating base body B, this method sets X_WB, the pose of body B in World.</dd></dl>
<p>See <a class="el" href="#mbp_working_with_free_bodies">above for details</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">body</span> is not a free body. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa046883a4c5530d09082bf39638c119a" name="aa046883a4c5530d09082bf39638c119a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa046883a4c5530d09082bf39638c119a">&#9670;&#160;</a></span>SetFreeBodyPoseInAnchoredFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodyPoseInAnchoredFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_F</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_FB</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000024">Deprecated</a></b></dt><dd>Use SetFloatingBaseBodyPoseInAnchoredFrame() instead. <br  />
 This will be removed from Drake on or after 2026-06-01. </dd></dl>

</div>
</div>
<a id="a97c0546b4129dad123a33b9b84831157" name="a97c0546b4129dad123a33b9b84831157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c0546b4129dad123a33b9b84831157">&#9670;&#160;</a></span>SetFreeBodyPoseInWorldFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodyPoseInWorldFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_WB</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000023">Deprecated</a></b></dt><dd>Use SetFloatingBaseBodyPoseInWorldFrame() instead. <br  />
 This will be removed from Drake on or after 2026-06-01. </dd></dl>

</div>
</div>
<a id="a9e833c04c184ed89a4af6632b827500b" name="a9e833c04c184ed89a4af6632b827500b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e833c04c184ed89a4af6632b827500b">&#9670;&#160;</a></span>SetFreeBodyRandomAnglesDistribution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodyRandomAnglesDistribution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html">math::RollPitchYaw</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>angles</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For any free body's 6-dof joint, sets the distribution used by <a class="el" href="#a470c99c41ab31927ae50c9996786bd10" title="Assigns random values to all elements of the state, by drawing samples independently for each joint/f...">SetRandomState()</a> to populate the orientation of its child frame Jc with respect to its parent frame Jp, expressed with roll-pitch-yaw angles. </p>
<p>Requires that the free body is modeled using an <a class="el" href="classdrake_1_1multibody_1_1_rpy_floating_joint.html" title="This Joint allows a rigid body to move freely with respect to its parent rigid body.">RpyFloatingJoint</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Unless <span class="tt">body</span> is a floating base body, the parent frame Jp is not necessarily the World frame W, and the child frame Jc is not necessarily the body frame B. For a floating base body B, this method sets the distribution of R_WB, the orientation of body B's frame in World (as roll-pitch-yaw angles).</dd>
<dd>
This distribution is not uniform over the sphere reachable by the three angles. For a uniform alternative, switch the joint to <a class="el" href="classdrake_1_1multibody_1_1_quaternion_floating_joint.html" title="This Joint allows two bodies to move freely relatively to one another.">QuaternionFloatingJoint</a> and use <a class="el" href="#a057dc09db3cf93f1cc47fb1db6995ca0" title="For any free body&#39;s 6-dof joint, sets the distribution used by SetRandomState() to populate the orien...">SetFreeBodyRandomRotationDistributionToUniform()</a>.</dd></dl>
<p>See <a class="el" href="#mbp_working_with_free_bodies">above for details</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">body</span> is not a free body in the model. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the free body is not modeled with an <a class="el" href="classdrake_1_1multibody_1_1_rpy_floating_joint.html" title="This Joint allows a rigid body to move freely with respect to its parent rigid body.">RpyFloatingJoint</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0e948d3233ccb5bf0001d5bd7425062a" title="For any free body&#39;s 6-dof joint, sets the distribution used by SetRandomState() to populate the orien...">SetFreeBodyRandomRotationDistribution()</a> for a free body that is modeled using a <a class="el" href="classdrake_1_1multibody_1_1_quaternion_floating_joint.html" title="This Joint allows two bodies to move freely relatively to one another.">QuaternionFloatingJoint</a>. </dd>
<dd>
<a class="el" href="#a7c9672b405425259b192131304f14f9c" title="Sets the type of joint to be used by Finalize() to connect any otherwise unconnected bodies to World.">SetBaseBodyJointType()</a> for <a class="el" href="group__control.html" title="A collection of algorithms for synthesizing feedback control.">Feedback Control Design</a> over the type of automatically- added joints. </dd></dl>

</div>
</div>
<a id="a0e948d3233ccb5bf0001d5bd7425062a" name="a0e948d3233ccb5bf0001d5bd7425062a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e948d3233ccb5bf0001d5bd7425062a">&#9670;&#160;</a></span>SetFreeBodyRandomRotationDistribution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodyRandomRotationDistribution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Quaternion&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rotation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For any free body's 6-dof joint, sets the distribution used by <a class="el" href="#a470c99c41ab31927ae50c9996786bd10" title="Assigns random values to all elements of the state, by drawing samples independently for each joint/f...">SetRandomState()</a> to populate the orientation of its child frame Jc with respect to its parent frame Jp, expressed as a quaternion. </p>
<p>Requires that the free body is modeled using a <a class="el" href="classdrake_1_1multibody_1_1_quaternion_floating_joint.html" title="This Joint allows two bodies to move freely relatively to one another.">QuaternionFloatingJoint</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Unless <span class="tt">body</span> is a floating base body, the parent frame Jp is not necessarily the World frame W, and the child frame Jc is not necessarily the body frame B. For a floating base body B, this method sets the distribution of R_WB, the orientation of body B's frame in World (as a quaternion).</dd>
<dd>
This distribution is not necessarily uniform over the sphere reachable by the quaternion; that depends on the quaternion expression provided in <span class="tt">rotation</span>. See <a class="el" href="#a057dc09db3cf93f1cc47fb1db6995ca0" title="For any free body&#39;s 6-dof joint, sets the distribution used by SetRandomState() to populate the orien...">SetFreeBodyRandomRotationDistributionToUniform()</a> for a uniform alternative.</dd></dl>
<p>See <a class="el" href="#mbp_working_with_free_bodies">above for details</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">body</span> is not a free body. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the free body is not modeled with a <a class="el" href="classdrake_1_1multibody_1_1_quaternion_floating_joint.html" title="This Joint allows two bodies to move freely relatively to one another.">QuaternionFloatingJoint</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9e833c04c184ed89a4af6632b827500b" title="For any free body&#39;s 6-dof joint, sets the distribution used by SetRandomState() to populate the orien...">SetFreeBodyRandomAnglesDistribution()</a> for a free body that is modeled using an <a class="el" href="classdrake_1_1multibody_1_1_rpy_floating_joint.html" title="This Joint allows a rigid body to move freely with respect to its parent rigid body.">RpyFloatingJoint</a>. </dd>
<dd>
<a class="el" href="#a7c9672b405425259b192131304f14f9c" title="Sets the type of joint to be used by Finalize() to connect any otherwise unconnected bodies to World.">SetBaseBodyJointType()</a> for <a class="el" href="group__control.html" title="A collection of algorithms for synthesizing feedback control.">Feedback Control Design</a> over the type of automatically- added joints. </dd></dl>

</div>
</div>
<a id="a057dc09db3cf93f1cc47fb1db6995ca0" name="a057dc09db3cf93f1cc47fb1db6995ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057dc09db3cf93f1cc47fb1db6995ca0">&#9670;&#160;</a></span>SetFreeBodyRandomRotationDistributionToUniform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodyRandomRotationDistributionToUniform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For any free body's 6-dof joint, sets the distribution used by <a class="el" href="#a470c99c41ab31927ae50c9996786bd10" title="Assigns random values to all elements of the state, by drawing samples independently for each joint/f...">SetRandomState()</a> to populate the orientation of its child frame Jc with respect to its parent frame Jp using uniformly random rotations (expressed as a quaternion). </p>
<p>Requires that the free body is modeled using a <a class="el" href="classdrake_1_1multibody_1_1_quaternion_floating_joint.html" title="This Joint allows two bodies to move freely relatively to one another.">QuaternionFloatingJoint</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Unless <span class="tt">body</span> is a floating base body, the parent frame Jp is not necessarily the World frame W, and the child frame Jc is not necessarily the body frame B. For a floating base body B, this method sets the distribution of R_WB, the orientation of body B's frame in World (as a quaternion).</dd></dl>
<p>See <a class="el" href="#mbp_working_with_free_bodies">above for details</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">body</span> is not a free body in the model. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the free body is not modeled with a <a class="el" href="classdrake_1_1multibody_1_1_quaternion_floating_joint.html" title="This Joint allows two bodies to move freely relatively to one another.">QuaternionFloatingJoint</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9e833c04c184ed89a4af6632b827500b" title="For any free body&#39;s 6-dof joint, sets the distribution used by SetRandomState() to populate the orien...">SetFreeBodyRandomAnglesDistribution()</a> for a free body that is modeled using an <a class="el" href="classdrake_1_1multibody_1_1_rpy_floating_joint.html" title="This Joint allows a rigid body to move freely with respect to its parent rigid body.">RpyFloatingJoint</a>. </dd>
<dd>
<a class="el" href="#a7c9672b405425259b192131304f14f9c" title="Sets the type of joint to be used by Finalize() to connect any otherwise unconnected bodies to World.">SetBaseBodyJointType()</a> for <a class="el" href="group__control.html" title="A collection of algorithms for synthesizing feedback control.">Feedback Control Design</a> over the type of automatically- added joints. </dd></dl>

</div>
</div>
<a id="ad44332b9a38a3534af794581915407ec" name="ad44332b9a38a3534af794581915407ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad44332b9a38a3534af794581915407ec">&#9670;&#160;</a></span>SetFreeBodyRandomTranslationDistribution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodyRandomTranslationDistribution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>translation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For any free body's 6-dof joint, sets the distribution used by <a class="el" href="#a470c99c41ab31927ae50c9996786bd10" title="Assigns random values to all elements of the state, by drawing samples independently for each joint/f...">SetRandomState()</a> to populate the x-y-z <span class="tt">translation</span> of its child frame Jc with respect to its parent frame Jp. </p>
<dl class="section note"><dt>Note</dt><dd>Unless <span class="tt">body</span> is a floating base body, the parent frame Jp is not necessarily the World frame W, and the child frame Jc is not necessarily the body frame B. For a floating base body B, this method sets the distribution of p_WBo, the position of body B's frame origin Bo in World.</dd></dl>
<p>See <a class="el" href="#mbp_working_with_free_bodies">above for details</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">body</span> is not a free body. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1f546d3cb8d03ec2e105839d817b687" name="aa1f546d3cb8d03ec2e105839d817b687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f546d3cb8d03ec2e105839d817b687">&#9670;&#160;</a></span>SetFreeBodySpatialVelocity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodySpatialVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>V_JpJc</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Variant of <a class="el" href="#ac0d39c3dc950bc14797e787e873110d8" title="For any free body&#39;s 6-dof joint, sets context to store the spatial velocity V_JpJc of child frame Jc ...">SetFreeBodySpatialVelocity()</a> that writes to a given <span class="tt">state</span> rather than directly to the Context. </p>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">state</span> comes from this MultibodyPlant. </dd></dl>

</div>
</div>
<a id="ac0d39c3dc950bc14797e787e873110d8" name="ac0d39c3dc950bc14797e787e873110d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d39c3dc950bc14797e787e873110d8">&#9670;&#160;</a></span>SetFreeBodySpatialVelocity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodySpatialVelocity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>body</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>V_JpJc</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For any free body's 6-dof joint, sets <span class="tt">context</span> to store the spatial velocity V_JpJc of child frame Jc in its parent frame Jp. </p>
<dl class="section note"><dt>Note</dt><dd>Unless <span class="tt">body</span> is a floating base body, the parent frame Jp is not necessarily the World frame W, and the child frame Jc is not necessarily the body frame B. For a floating base body B, this method sets V_WB, the spatial velocity of body B in World.</dd></dl>
<p>See <a class="el" href="#mbp_working_with_free_bodies">above for details</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">body</span> is not a free body. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36c37052d28bb9bcb7b70e7b6a6a6321" name="a36c37052d28bb9bcb7b70e7b6a6a6321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c37052d28bb9bcb7b70e7b6a6a6321">&#9670;&#160;</a></span>SetPositions() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetPositions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q_instance</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Sets the generalized positions q for a particular model instance in a given State from a given vector. </p>
<dl class="section note"><dt>Note</dt><dd>No cache invalidation occurs. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <span class="tt">context</span> is nullptr, if <span class="tt">context</span> does not correspond to the Context for a multibody model, if the model instance index is invalid, if the length of <span class="tt">q_instance</span> is not equal to <span class="tt">num_positions(model_instance)</span>, or if <span class="tt">q_instance</span> contains non-finite values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">state</span> comes from this <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>. </dd></dl>

</div>
</div>
<a id="a40ecddd72c91e66ee38fe023bc58b3a0" name="a40ecddd72c91e66ee38fe023bc58b3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ecddd72c91e66ee38fe023bc58b3a0">&#9670;&#160;</a></span>SetPositions() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetPositions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the generalized positions q in a given Context from a given vector. </p>
<p>Prefer this method over GetMutablePositions(). </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">context</span> is nullptr, if <span class="tt">context</span> does not correspond to the Context for a multibody model, if the length of <span class="tt">q</span> is not equal to <span class="tt"><a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">num_positions()</a></span>, or if <span class="tt">q</span> contains non-finite values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd0b27947d35ab2005eda04b6f67c6a8" name="abd0b27947d35ab2005eda04b6f67c6a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0b27947d35ab2005eda04b6f67c6a8">&#9670;&#160;</a></span>SetPositions() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetPositions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q_instance</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the generalized positions q for a particular model instance in a given Context from a given vector. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <span class="tt">context</span> is nullptr, if <span class="tt">context</span> does not correspond to the Context for a multibody model, if the model instance index is invalid, if the length of <span class="tt">q_instance</span> is not equal to <span class="tt">num_positions(model_instance)</span>, or if <span class="tt">q_instance</span> contains non-finite values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdf6af4e5e5e71b55ea7ea3034ac5e90" name="acdf6af4e5e5e71b55ea7ea3034ac5e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf6af4e5e5e71b55ea7ea3034ac5e90">&#9670;&#160;</a></span>SetPositionsAndVelocities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetPositionsAndVelocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q_v</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets generalized positions q and generalized velocities v in a given Context from a given vector [q; v]. </p>
<p>Prefer this method over GetMutablePositionsAndVelocities(). </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">context</span> is nullptr, if <span class="tt">context</span> does not correspond to the context for a multibody model, if the length of <span class="tt">q_v</span> is not equal to <span class="tt"><a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">num_positions()</a> + <a class="el" href="#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a></span>, or if <span class="tt">q_v</span> contains non-finite values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7fa1955c5b663dd2ed08671c95f1fbe" name="aa7fa1955c5b663dd2ed08671c95f1fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7fa1955c5b663dd2ed08671c95f1fbe">&#9670;&#160;</a></span>SetPositionsAndVelocities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetPositionsAndVelocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q_v</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets generalized positions q and generalized velocities v from a given vector [q; v] for a specified model instance in a given Context. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">context</span> is nullptr, if <span class="tt">context</span> does not correspond to the Context for a multibody model, if the model instance index is invalid, if the length of <span class="tt">q_v</span> is not equal to <span class="tt">num_positions(model_instance) + num_velocities(model_instance)</span>, or if <span class="tt">q_v</span> contains non-finite values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab264035a2e8c56b57bd80afb0b6ffb48" name="ab264035a2e8c56b57bd80afb0b6ffb48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab264035a2e8c56b57bd80afb0b6ffb48">&#9670;&#160;</a></span>SetPositionsInArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetPositionsInArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the vector of generalized positions for <span class="tt">model_instance</span> in <span class="tt">q</span> using <span class="tt">q_instance</span>, leaving all other elements in the array untouched. </p>
<p>This method throws an exception if <span class="tt">q</span> is not of size <a class="el" href="#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">MultibodyPlant::num_positions()</a> or <span class="tt">q_instance</span> is not of size <span class="tt">MultibodyPlant::num_positions(model_instance)</span>. </p>

</div>
</div>
<a id="a470c99c41ab31927ae50c9996786bd10" name="a470c99c41ab31927ae50c9996786bd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470c99c41ab31927ae50c9996786bd10">&#9670;&#160;</a></span>SetRandomState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetRandomState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *</td>          <td class="paramname"><span class="paramname"><em>generator</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns random values to all elements of the state, by drawing samples independently for each joint/free body (coming soon: and then solving a mathematical program to "project" these samples onto the registered system constraints). </p>
<p>If a random distribution is not specified for a joint/free body, the default state is used.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__stochastic__systems.html">Stochastic Systems</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classdrake_1_1systems_1_1_system.html#a47a8dc372e0063851c9851ee15da74e9">System&lt; T &gt;</a>.</p>

</div>
</div>
<a id="adb2f51f2f513478a97b0175bff3a65ae" name="adb2f51f2f513478a97b0175bff3a65ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2f51f2f513478a97b0175bff3a65ae">&#9670;&#160;</a></span>SetUseSampledOutputPorts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetUseSampledOutputPorts </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_sampled_output_ports</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) For a discrete-time plant, configures whether the output ports are sampled (the default) or live (opt-in). </p>
<p>See <a class="el" href="#output_port_sampling">Output port sampling</a> for details. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the plant is already finalized. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">use_sampled_output_ports</span> is <span class="tt">true</span> but <span class="tt">this</span> MultibodyPlant is not a discrete model (is_discrete() == false). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9f727a51103f28b4e0ee0ce66adc0cd" name="ae9f727a51103f28b4e0ee0ce66adc0cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f727a51103f28b4e0ee0ce66adc0cd">&#9670;&#160;</a></span>SetVelocities() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetVelocities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v_instance</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Sets the generalized velocities v for a particular model instance in a given State from a given vector. </p>
<dl class="section note"><dt>Note</dt><dd>No cache invalidation occurs. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <span class="tt">context</span> is nullptr, if <span class="tt">context</span> does not correspond to the Context for a multibody model, if the model instance index is invalid, if the length of <span class="tt">v_instance</span> is not equal to <span class="tt">num_velocities(model_instance)</span>, or if <span class="tt">v_instance</span> contains non-finite values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">state</span> comes from this <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>. </dd></dl>

</div>
</div>
<a id="aa6864e2bce8855ab702b8ea1bb748f00" name="aa6864e2bce8855ab702b8ea1bb748f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6864e2bce8855ab702b8ea1bb748f00">&#9670;&#160;</a></span>SetVelocities() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetVelocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the generalized velocities v in a given Context from a given vector. </p>
<p>Prefer this method over GetMutableVelocities(). </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <span class="tt">context</span> is nullptr, if the context does not correspond to the context for a multibody model, if the length of <span class="tt">v</span> is not equal to <span class="tt"><a class="el" href="#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a></span>, or if <span class="tt">v</span> contains non-finite values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3040154a84f6d45b28d0408a7826e2a9" name="a3040154a84f6d45b28d0408a7826e2a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3040154a84f6d45b28d0408a7826e2a9">&#9670;&#160;</a></span>SetVelocities() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetVelocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v_instance</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the generalized velocities v for a particular model instance in a given Context from a given vector. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <span class="tt">context</span> is nullptr, if <span class="tt">context</span> does not correspond to the Context for a multibody model, if the model instance index is invalid, if the length of <span class="tt">v_instance</span> is not equal to <span class="tt">num_velocities(model_instance)</span>, or if <span class="tt">v_instance</span> contains non-finite values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89105b866dae232e6a9236d50f1fb08c" name="a89105b866dae232e6a9236d50f1fb08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89105b866dae232e6a9236d50f1fb08c">&#9670;&#160;</a></span>SetVelocitiesInArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetVelocitiesInArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a></td>          <td class="paramname"><span class="paramname"><em>model_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v_instance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the vector of generalized velocities for <span class="tt">model_instance</span> in <span class="tt">v</span> using <span class="tt">v_instance</span>, leaving all other elements in the array untouched. </p>
<p>This method throws an exception if <span class="tt">v</span> is not of size <a class="el" href="#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">MultibodyPlant::num_velocities()</a>, <span class="tt">v_instance</span> is not of size <span class="tt">MultibodyPlant::num_positions(model_instance)</span>, or <span class="tt">v_instance</span> contains non-finite values. </p>

</div>
</div>
<a id="a0cef6f48aa258bbb487ab62cec437cb8" name="a0cef6f48aa258bbb487ab62cec437cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cef6f48aa258bbb487ab62cec437cb8">&#9670;&#160;</a></span>stiction_tolerance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> stiction_tolerance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the stiction tolerance parameter, in m/s. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#afa94cf2eeba3e27ad35132211ae6d074">set_stiction_tolerance</a>. </dd></dl>

</div>
</div>
<a id="a8daceb7a3c384d6ad9f305e42b5fc1c6" name="a8daceb7a3c384d6ad9f305e42b5fc1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8daceb7a3c384d6ad9f305e42b5fc1c6">&#9670;&#160;</a></span>time_step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> time_step </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The time step (or period) used to model <span class="tt">this</span> plant as a discrete system with periodic updates. </p>
<p>Returns 0 (zero) if the plant is modeled as a continuous system. This property of the plant is specified at construction and therefore this query can be performed either pre- or post-finalize, see <a class="el" href="#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3296be9fa9bc35e6639460f54029c4c9" title="This constructor creates a plant with a single &quot;world&quot; body.">MultibodyPlant::MultibodyPlant(double)</a> </dd></dl>

</div>
</div>
<a id="ae39937d8af6ec034bf8d41770a4ff658" name="ae39937d8af6ec034bf8d41770a4ff658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae39937d8af6ec034bf8d41770a4ff658">&#9670;&#160;</a></span>WeldFrames()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_weld_joint.html">WeldJoint</a>&lt; T &gt; &amp; WeldFrames </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_on_parent_F</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_on_child_M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_FM</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt;&#160;<a class="el" href="classdouble.html">double</a>&#160;&gt;::Identity()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Welds <span class="tt">frame_on_parent_F</span> and <span class="tt">frame_on_child_M</span> with relative pose <span class="tt">X_FM</span>. </p>
<p>That is, the pose of frame M in frame F is fixed, with value <span class="tt">X_FM</span>. If <span class="tt">X_FM</span> is omitted, the identity transform will be used. The call to this method creates and adds a new <a class="el" href="classdrake_1_1multibody_1_1_weld_joint.html" title="This Joint fixes the relative pose between two frames as if &quot;welding&quot; them together.">WeldJoint</a> to the model. The new <a class="el" href="classdrake_1_1multibody_1_1_weld_joint.html" title="This Joint fixes the relative pose between two frames as if &quot;welding&quot; them together.">WeldJoint</a> is named as: frame_on_parent_F.name() + "_welds_to_" + frame_on_child_M.name(). </p><dl class="section return"><dt>Returns</dt><dd>a constant reference to the <a class="el" href="classdrake_1_1multibody_1_1_weld_joint.html" title="This Joint fixes the relative pose between two frames as if &quot;welding&quot; them together.">WeldJoint</a> welding frames F and M. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the weld produces a duplicate joint name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a787a58094e9902e11d3359b54d20eed4" name="a787a58094e9902e11d3359b54d20eed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787a58094e9902e11d3359b54d20eed4">&#9670;&#160;</a></span>world_body()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp; world_body </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the <em>world</em> body. </p>

</div>
</div>
<a id="ad65885e8d50cbd5462360af46bbc10fc" name="ad65885e8d50cbd5462360af46bbc10fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65885e8d50cbd5462360af46bbc10fc">&#9670;&#160;</a></span>world_frame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body_frame.html">RigidBodyFrame</a>&lt; T &gt; &amp; world_frame </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the <em>world</em> frame. </p>

</div>
</div>
<a name="doc-related-members" id="doc-related-members"></a><h2 id="header-doc-related-members" class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a8b71553122d35a449d2131789a3f94c2" name="a8b71553122d35a449d2131789a3f94c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b71553122d35a449d2131789a3f94c2">&#9670;&#160;</a></span>AddMultibodyPlantSceneGraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1multibody_1_1_add_multibody_plant_scene_graph_result.html">AddMultibodyPlantSceneGraphResult</a>&lt; T &gt; AddMultibodyPlantSceneGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_diagram_builder.html">systems::DiagramBuilder</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>time_step</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>scene_graph</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel related">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a new <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> with discrete update period <span class="tt"><a class="el" href="#a8daceb7a3c384d6ad9f305e42b5fc1c6" title="The time step (or period) used to model this plant as a discrete system with periodic updates.">time_step</a></span> and adds it to a diagram builder together with the provided SceneGraph instance, connecting the geometry ports. </p>
<dl class="section note"><dt>Note</dt><dd>Usage examples in <a class="el" href="#add_multibody_plant_scene_graph">AddMultibodyPlantSceneGraph</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">builder</td><td>Builder to add to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_step</td><td>The discrete update period for the new <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> to be added. Please refer to the documentation provided in <a class="el" href="#a3296be9fa9bc35e6639460f54029c4c9" title="This constructor creates a plant with a single &quot;world&quot; body.">MultibodyPlant::MultibodyPlant(double)</a> for further details on the parameter <span class="tt"><a class="el" href="#a8daceb7a3c384d6ad9f305e42b5fc1c6" title="The time step (or period) used to model this plant as a discrete system with periodic updates.">time_step</a></span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scene_graph</td><td>(optional) Constructed scene graph. If none is provided, one will be created and used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of the registered plant and scene graph. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">builder</span> must be non-null. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abee1730bcdfcda3c985ab6e0c2b4e4b0" name="abee1730bcdfcda3c985ab6e0c2b4e4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee1730bcdfcda3c985ab6e0c2b4e4b0">&#9670;&#160;</a></span>AddMultibodyPlantSceneGraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1multibody_1_1_add_multibody_plant_scene_graph_result.html">AddMultibodyPlantSceneGraphResult</a>&lt; T &gt; AddMultibodyPlantSceneGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_diagram_builder.html">systems::DiagramBuilder</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="#a47a63154823dffd5838329527aafbd58">MultibodyPlant</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>plant</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>scene_graph</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel related">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> and a SceneGraph instance to a diagram builder, connecting the geometry ports. </p>
<dl class="section note"><dt>Note</dt><dd>Usage examples in <a class="el" href="#add_multibody_plant_scene_graph">AddMultibodyPlantSceneGraph</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">builder</td><td>Builder to add to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plant</td><td>Plant to be added to the builder. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scene_graph</td><td>(optional) Constructed scene graph. If none is provided, one will be created and used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of the registered plant and scene graph. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">builder</span> and <span class="tt">plant</span> must be non-null. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bf56e6eda41a6cc82296377a2267479" name="a9bf56e6eda41a6cc82296377a2267479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf56e6eda41a6cc82296377a2267479">&#9670;&#160;</a></span>internal::MultibodyPlantDiscreteUpdateManagerAttorney&lt; T &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::MultibodyPlantDiscreteUpdateManagerAttorney&lt; T &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae31c5abf29d1134fe77df48a1152980a" name="ae31c5abf29d1134fe77df48a1152980a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31c5abf29d1134fe77df48a1152980a">&#9670;&#160;</a></span>internal::MultibodyPlantIcfAttorney&lt; T &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::MultibodyPlantIcfAttorney&lt; T &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7266290642dbb492700e7ebae2e00a20" name="a7266290642dbb492700e7ebae2e00a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7266290642dbb492700e7ebae2e00a20">&#9670;&#160;</a></span>internal::MultibodyPlantModelAttorney&lt; T &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::MultibodyPlantModelAttorney&lt; T &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a47a63154823dffd5838329527aafbd58" name="a47a63154823dffd5838329527aafbd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a63154823dffd5838329527aafbd58">&#9670;&#160;</a></span>MultibodyPlant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class MultibodyPlant</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a42efef893a4d8eed1d593caff328f599" name="a42efef893a4d8eed1d593caff328f599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42efef893a4d8eed1d593caff328f599">&#9670;&#160;</a></span>MultibodyPlantTester</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class MultibodyPlantTester</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>drake/multibody/plant/<a class="el" href="deformable__model_8h.html">deformable_model.h</a></li>
<li>drake/multibody/plant/<a class="el" href="multibody__plant_8h.html">multibody_plant.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
