<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: Iris</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__planning__iris.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Iris <div class="ingroups"><a class="el" href="group__algorithms.html">Algorithms</a> &raquo; <a class="el" href="group__planning.html">Planning</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>These algorithms help construct regions of configuration space that are collision free. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:CIrisCollisionGeometry" id="r_CIrisCollisionGeometry"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_c_iris_collision_geometry.html">CIrisCollisionGeometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains the necessary information about the collision geometry used in C-IRIS.  <a href="classdrake_1_1geometry_1_1optimization_1_1_c_iris_collision_geometry.html#details">More...</a><br /></td></tr>
<tr class="memitem:CspaceFreeBox" id="r_CspaceFreeBox"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cspace_free_box.html">CspaceFreeBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class tries to find large axis-aligned bounding boxes in the configuration space, such that all configurations in the boxes are collision free.  <a href="classdrake_1_1geometry_1_1optimization_1_1_cspace_free_box.html#details">More...</a><br /></td></tr>
<tr class="memitem:CspaceFreePolytope" id="r_CspaceFreePolytope"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cspace_free_polytope.html">CspaceFreePolytope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class tries to find large convex polytopes in the tangential-configuration space, such that all configurations in the convex polytopes is collision free.  <a href="classdrake_1_1geometry_1_1optimization_1_1_cspace_free_polytope.html#details">More...</a><br /></td></tr>
<tr class="memitem:CspaceFreePolytopeBase" id="r_CspaceFreePolytopeBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cspace_free_polytope_base.html">CspaceFreePolytopeBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This virtual class is the base of <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cspace_free_polytope.html" title="This class tries to find large convex polytopes in the tangential-configuration space,...">CspaceFreePolytope</a> and <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cspace_free_box.html" title="This class tries to find large axis-aligned bounding boxes in the configuration space,...">CspaceFreeBox</a>.  <a href="classdrake_1_1geometry_1_1optimization_1_1_cspace_free_polytope_base.html#details">More...</a><br /></td></tr>
<tr class="memitem:IrisOptions" id="r_IrisOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">IrisOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration options for the IRIS algorithm.  <a href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html#details">More...</a><br /></td></tr>
<tr class="memitem:CommonSampledIrisOptions" id="r_CommonSampledIrisOptions"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1_common_sampled_iris_options.html">CommonSampledIrisOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various options which are common to the sampling-based algorithms IrisNp2 and IrisZo for generating collision free polytopes in configuration space.  <a href="classdrake_1_1planning_1_1_common_sampled_iris_options.html#details">More...</a><br /></td></tr>
<tr class="memitem:IrisParameterizationFunction" id="r_IrisParameterizationFunction"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1_iris_parameterization_function.html">IrisParameterizationFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordinarily, IRIS algorithms grow collision free regions in the robot's configuration space C.  <a href="classdrake_1_1planning_1_1_iris_parameterization_function.html#details">More...</a><br /></td></tr>
<tr class="memitem:RaySamplerOptions" id="r_RaySamplerOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1planning_1_1_ray_sampler_options.html">RaySamplerOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structdrake_1_1planning_1_1_ray_sampler_options.html" title="RaySamplerOptions contains settings specific to the kRaySampler strategy for drawing the initial samp...">RaySamplerOptions</a> contains settings specific to the kRaySampler strategy for drawing the initial samples.  <a href="structdrake_1_1planning_1_1_ray_sampler_options.html#details">More...</a><br /></td></tr>
<tr class="memitem:IrisNp2Options" id="r_IrisNp2Options"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1_iris_np2_options.html">IrisNp2Options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdrake_1_1planning_1_1_iris_np2_options.html" title="IrisNp2Options collects all parameters for the IRIS-NP2 algorithm.">IrisNp2Options</a> collects all parameters for the IRIS-NP2 algorithm.  <a href="classdrake_1_1planning_1_1_iris_np2_options.html#details">More...</a><br /></td></tr>
<tr class="memitem:IrisZoOptions" id="r_IrisZoOptions"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1planning_1_1_iris_zo_options.html">IrisZoOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdrake_1_1planning_1_1_iris_zo_options.html" title="IrisZoOptions collects all parameters for the IRIS-ZO algorithm.">IrisZoOptions</a> collects all parameters for the IRIS-ZO algorithm.  <a href="classdrake_1_1planning_1_1_iris_zo_options.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga10b0e0579060ac0afdf6344627ffabd2" id="r_ga10b0e0579060ac0afdf6344627ffabd2"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">HPolyhedron</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga10b0e0579060ac0afdf6344627ffabd2">IrisRegions</a></td></tr>
<tr class="memdesc:ga10b0e0579060ac0afdf6344627ffabd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a standardized representation for (named) <a class="el" href="#ga10b0e0579060ac0afdf6344627ffabd2" title="Defines a standardized representation for (named) IrisRegions, which can be serialized in both C++ an...">IrisRegions</a>, which can be serialized in both C++ and Python.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga41ad36e136530c33abb2d19a40f4f5e3" id="r_ga41ad36e136530c33abb2d19a40f4f5e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">HPolyhedron</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga41ad36e136530c33abb2d19a40f4f5e3">Iris</a> (const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;obstacles, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;sample, const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">HPolyhedron</a> &amp;domain, const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">IrisOptions</a> &amp;options=<a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">IrisOptions</a>())</td></tr>
<tr class="memdesc:ga41ad36e136530c33abb2d19a40f4f5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The IRIS (Iterative Region Inflation by Semidefinite programming) algorithm, as described in.  <br /></td></tr>
<tr class="memitem:ga1695afcbf10d19b297140421a5a5ade8" id="r_ga1695afcbf10d19b297140421a5a5ade8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1695afcbf10d19b297140421a5a5ade8">MakeIrisObstacles</a> (const <a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a>&lt; double &gt; &amp;query_object, std::optional&lt; <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> &gt; reference_frame=std::nullopt)</td></tr>
<tr class="memdesc:ga1695afcbf10d19b297140421a5a5ade8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html" title="Abstract base class for defining a convex set.">ConvexSet</a> representations of obstacles for IRIS in 3D using the geometry from a <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> <a class="el" href="classdrake_1_1geometry_1_1_query_object.html" title="The QueryObject serves as a mechanism to perform geometry queries on the world&#39;s geometry.">QueryObject</a>.  <br /></td></tr>
<tr class="memitem:ga9a3aba193bc960e38b6ae305e30dd13c" id="r_ga9a3aba193bc960e38b6ae305e30dd13c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">HPolyhedron</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9a3aba193bc960e38b6ae305e30dd13c">IrisNp</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">multibody::MultibodyPlant</a>&lt; double &gt; &amp;plant, const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; double &gt; &amp;context, const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">IrisOptions</a> &amp;options=<a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">IrisOptions</a>())</td></tr>
<tr class="memdesc:ga9a3aba193bc960e38b6ae305e30dd13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of the Iris (Iterative Region Inflation by Semidefinite programming) algorithm which finds collision-free regions in the <em>configuration space</em> of <code class="param">plant</code>.  <br /></td></tr>
<tr class="memitem:gaece042cde9122f05ca663a27fa7d0ea9" id="r_gaece042cde9122f05ca663a27fa7d0ea9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaece042cde9122f05ca663a27fa7d0ea9">SetEdgeContainmentTerminationCondition</a> (<a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">IrisOptions</a> *iris_options, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;x_1, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;x_2, const double epsilon=1e-3, const double tol=1e-6)</td></tr>
<tr class="memdesc:gaece042cde9122f05ca663a27fa7d0ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the <code class="param">iris_options</code> to facilitate finding a region that contains the edge between x_1 and x_2.  <br /></td></tr>
<tr class="memitem:ga95b21d4800c09233dd7a489238bced19" id="r_ga95b21d4800c09233dd7a489238bced19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga95b21d4800c09233dd7a489238bced19">IrisInConfigurationSpaceFromCliqueCover</a> (const <a class="el" href="classdrake_1_1planning_1_1_collision_checker.html">CollisionChecker</a> &amp;checker, const <a class="el" href="structdrake_1_1planning_1_1_iris_from_clique_cover_options.html">IrisFromCliqueCoverOptions</a> &amp;options, <a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *generator, std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">geometry::optimization::HPolyhedron</a> &gt; *sets, const <a class="el" href="classdrake_1_1planning_1_1graph__algorithms_1_1_max_clique_solver_base.html">planning::graph_algorithms::MaxCliqueSolverBase</a> *max_clique_solver=nullptr)</td></tr>
<tr class="memdesc:ga95b21d4800c09233dd7a489238bced19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cover the configuration space in Iris regions using the Visibility Clique Cover Algorithm as described in.  <br /></td></tr>
<tr class="memitem:gaf5bc571d0ee3753c976d3b521de397c4" id="r_gaf5bc571d0ee3753c976d3b521de397c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">geometry::optimization::HPolyhedron</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf5bc571d0ee3753c976d3b521de397c4">IrisNp2</a> (const <a class="el" href="classdrake_1_1planning_1_1_scene_graph_collision_checker.html">SceneGraphCollisionChecker</a> &amp;checker, const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_hyperellipsoid.html">geometry::optimization::Hyperellipsoid</a> &amp;starting_ellipsoid, const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">geometry::optimization::HPolyhedron</a> &amp;domain, const <a class="el" href="classdrake_1_1planning_1_1_iris_np2_options.html">IrisNp2Options</a> &amp;options=<a class="el" href="classdrake_1_1planning_1_1_iris_np2_options.html">IrisNp2Options</a>())</td></tr>
<tr class="memdesc:gaf5bc571d0ee3753c976d3b521de397c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The IRIS-NP2 (Iterative Regional Inflation by Semidefinite and Nonlinear Programming 2) algorithm, as described in.  <br /></td></tr>
<tr class="memitem:ga9b44245010bfdc8163645f0c62f9e9ab" id="r_ga9b44245010bfdc8163645f0c62f9e9ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">geometry::optimization::HPolyhedron</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9b44245010bfdc8163645f0c62f9e9ab">IrisZo</a> (const <a class="el" href="classdrake_1_1planning_1_1_collision_checker.html">CollisionChecker</a> &amp;checker, const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_hyperellipsoid.html">geometry::optimization::Hyperellipsoid</a> &amp;starting_ellipsoid, const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">geometry::optimization::HPolyhedron</a> &amp;domain, const <a class="el" href="classdrake_1_1planning_1_1_iris_zo_options.html">IrisZoOptions</a> &amp;options=<a class="el" href="classdrake_1_1planning_1_1_iris_zo_options.html">IrisZoOptions</a>())</td></tr>
<tr class="memdesc:ga9b44245010bfdc8163645f0c62f9e9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The IRIS-ZO (Iterative Regional Inflation by Semidefinite programming - Zero Order) algorithm, as described in.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gae1b0dda8a6f7a3ed77c6e247018c0008" id="r_gae1b0dda8a6f7a3ed77c6e247018c0008"><td class="memItemLeft" align="right" valign="top">std::variant&lt; <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">geometry::optimization::IrisOptions</a>, <a class="el" href="classdrake_1_1planning_1_1_iris_np2_options.html">IrisNp2Options</a>, <a class="el" href="classdrake_1_1planning_1_1_iris_zo_options.html">IrisZoOptions</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae1b0dda8a6f7a3ed77c6e247018c0008">iris_options</a> {<a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">geometry::optimization::IrisOptions</a>{.<a class="el" href="structdrake_1_1planning_1_1_iris_from_clique_cover_options.html#ab9404d7dc104e7eb4e27ed7e38ccff72">iteration_limit</a> = 1}}</td></tr>
<tr class="memdesc:gae1b0dda8a6f7a3ed77c6e247018c0008"><td class="mdescLeft">&#160;</td><td class="mdescRight">The options used on internal calls to Iris.  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="ga10b0e0579060ac0afdf6344627ffabd2" name="ga10b0e0579060ac0afdf6344627ffabd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10b0e0579060ac0afdf6344627ffabd2">&#9670;&#160;</a></span>IrisRegions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">HPolyhedron</a>&gt; <a class="el" href="#ga10b0e0579060ac0afdf6344627ffabd2">IrisRegions</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a standardized representation for (named) <a class="el" href="#ga10b0e0579060ac0afdf6344627ffabd2" title="Defines a standardized representation for (named) IrisRegions, which can be serialized in both C++ an...">IrisRegions</a>, which can be serialized in both C++ and Python. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga41ad36e136530c33abb2d19a40f4f5e3" name="ga41ad36e136530c33abb2d19a40f4f5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41ad36e136530c33abb2d19a40f4f5e3">&#9670;&#160;</a></span>Iris()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">HPolyhedron</a> Iris </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>obstacles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sample</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">HPolyhedron</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">IrisOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">IrisOptions</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The IRIS (Iterative Region Inflation by Semidefinite programming) algorithm, as described in. </p>
<p>R. L. H. Deits and R. Tedrake, “Computing large convex regions of obstacle-free space through semidefinite programming,” Workshop on the Algorithmic Fundamentals of Robotics, Istanbul, Aug. 2014. <a href="http://groups.csail.mit.edu/robotics-center/public_papers/Deits14.pdf">http://groups.csail.mit.edu/robotics-center/public_papers/Deits14.pdf</a></p>
<p>This algorithm attempts to locally maximize the volume of a convex polytope representing obstacle-free space given a sample point and list of convex obstacles. Rather than compute the volume of the polytope directly, the algorithm maximizes the volume of an inscribed ellipsoid. It alternates between finding separating hyperplanes between the ellipsoid and the obstacles and then finding a new maximum-volume inscribed ellipsoid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obstacles</td><td>is a vector of convex sets representing the occupied space. </td></tr>
    <tr><td class="paramname">sample</td><td>provides a point in the space; the algorithm is initialized using a tiny sphere around this point. The algorithm is only guaranteed to succeed if this sample point is collision free (outside of all obstacles), but in practice the algorithm can often escape bad initialization (assuming the require_sample_point_is_contained option is false). </td></tr>
    <tr><td class="paramname">domain</td><td>describes the total region of interest; computed IRIS regions will be inside this domain. It must be bounded, and is typically a simple bounding box (e.g. from <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html#a90a3c53754fc20d77419aae25ed1b1c1" title="Constructs a polyhedron as an axis-aligned box from the lower and upper corners.">HPolyhedron::MakeBox</a>).</td></tr>
  </table>
  </dd>
</dl>
<p>The <code class="param">obstacles</code>, <code class="param">sample</code>, and the <code class="param">domain</code> must describe elements in the same ambient dimension (but that dimension can be any positive integer).</p>
<dl class="section note"><dt>Note</dt><dd>Some members of <span class="tt">options</span> are only applicable to IrisNp. The members relevant for this function are starting_ellipse, termination_func, bounding_region, verify_domain_boundedness, require_sample_point_is_contained, iteration_limit, termination_threshold, relative_termination_threshold. </dd></dl>

</div>
</div>
<a id="ga95b21d4800c09233dd7a489238bced19" name="ga95b21d4800c09233dd7a489238bced19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95b21d4800c09233dd7a489238bced19">&#9670;&#160;</a></span>IrisInConfigurationSpaceFromCliqueCover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IrisInConfigurationSpaceFromCliqueCover </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1planning_1_1_collision_checker.html">CollisionChecker</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>checker</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1planning_1_1_iris_from_clique_cover_options.html">IrisFromCliqueCoverOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *</td>          <td class="paramname"><span class="paramname"><em>generator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">geometry::optimization::HPolyhedron</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>sets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1planning_1_1graph__algorithms_1_1_max_clique_solver_base.html">planning::graph_algorithms::MaxCliqueSolverBase</a> *</td>          <td class="paramname"><span class="paramname"><em>max_clique_solver</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cover the configuration space in Iris regions using the Visibility Clique Cover Algorithm as described in. </p>
<p>P. Werner, A. Amice, T. Marcucci, D. Rus, R. Tedrake "Approximating Robot
Configuration Spaces with few Convex Sets using Clique Covers of Visibility
Graphs" In 2024 IEEE Internation Conference on Robotics and Automation. <a href="https://arxiv.org/abs/2310.02875">https://arxiv.org/abs/2310.02875</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">checker</td><td>The collision checker containing the plant and its associated scene_graph. </td></tr>
    <tr><td class="paramname">generator</td><td>There are points in the algorithm requiring randomness. The generator controls this source of randomness. </td></tr>
    <tr><td class="paramname">sets</td><td>[in/out] initial sets covering the space (potentially empty). The cover is written into this vector. </td></tr>
    <tr><td class="paramname">max_clique_solver</td><td>The min clique cover problem is approximatley solved by repeatedly solving max clique on the uncovered graph and adding this largest clique to the cover. The max clique problem is solved by this solver. If parallelism is set to allow more than 1 thread, then the solver <b>must</b> be implemented in C++.</td></tr>
  </table>
  </dd>
</dl>
<p>If nullptr is passed as the <span class="tt">max_clique_solver</span>, then max clique will be solved using an instance of MaxCliqueSolverViaGreedy, which is a fast heuristic. If higher quality cliques are desired, consider changing the solver to an instance of MaxCliqueSolverViaMip. Currently, the padding in the collision checker is not forwarded to the algorithm, and therefore the final regions do not necessarily respect this padding. Effectively, this means that the regions are generated as if the padding is set to 0. This behavior may be adjusted in the future at the resolution of #18830.</p>
<dl class="section note"><dt>Note</dt><dd>that MaxCliqueSolverViaMip requires the availability of a Mixed-Integer Linear Programming solver (e.g. Gurobi and/or Mosek). We recommend enabling those solvers if possible because they produce higher quality cliques (<a href="https://drake.mit.edu/bazel.html#proprietary_solvers">https://drake.mit.edu/bazel.html#proprietary_solvers</a>). The method will throw if <code class="param">max_clique_solver</code> cannot solve the max clique problem. </dd>
<dd>
If <a class="el" href="classdrake_1_1planning_1_1_iris_np2_options.html" title="IrisNp2Options collects all parameters for the IRIS-NP2 algorithm.">IrisNp2Options</a> is used, then the collision checker must be a <a class="el" href="classdrake_1_1planning_1_1_scene_graph_collision_checker.html" title="An implementation of CollisionChecker that uses SceneGraph to provide collision checks.">SceneGraphCollisionChecker</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>Parameterizations are not currently supported for <span class="tt"><a class="el" href="#ga9b44245010bfdc8163645f0c62f9e9ab" title="The IRIS-ZO (Iterative Regional Inflation by Semidefinite programming - Zero Order) algorithm,...">IrisZo</a></span> and <span class="tt"><a class="el" href="#gaf5bc571d0ee3753c976d3b521de397c4" title="The IRIS-NP2 (Iterative Regional Inflation by Semidefinite and Nonlinear Programming 2) algorithm,...">IrisNp2</a></span> when running <span class="tt">IrisFromCliqueCover</span>. This method will throw if options.iris_options is of type <span class="tt"><a class="el" href="classdrake_1_1planning_1_1_iris_zo_options.html" title="IrisZoOptions collects all parameters for the IRIS-ZO algorithm.">IrisZoOptions</a></span> or <span class="tt"><a class="el" href="classdrake_1_1planning_1_1_iris_np2_options.html" title="IrisNp2Options collects all parameters for the IRIS-NP2 algorithm.">IrisNp2Options</a></span> and specifies a parametrization function. See the documentation of <span class="tt"><a class="el" href="classdrake_1_1planning_1_1_iris_zo_options.html" title="IrisZoOptions collects all parameters for the IRIS-ZO algorithm.">IrisZoOptions</a></span> and <span class="tt"><a class="el" href="classdrake_1_1planning_1_1_iris_np2_options.html" title="IrisNp2Options collects all parameters for the IRIS-NP2 algorithm.">IrisNp2Options</a></span> for more information about subspace parametrization. </td></tr>
    <tr><td class="paramname">std::exception</td><td>If the options.iris_options.prog_with_additional_constraints is not nullptr i.e. if a prog with additional constraints is provided. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9a3aba193bc960e38b6ae305e30dd13c" name="ga9a3aba193bc960e38b6ae305e30dd13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a3aba193bc960e38b6ae305e30dd13c">&#9670;&#160;</a></span>IrisNp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">HPolyhedron</a> IrisNp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">multibody::MultibodyPlant</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>plant</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">IrisOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">IrisOptions</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variation of the Iris (Iterative Region Inflation by Semidefinite programming) algorithm which finds collision-free regions in the <em>configuration space</em> of <code class="param">plant</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga41ad36e136530c33abb2d19a40f4f5e3" title="The IRIS (Iterative Region Inflation by Semidefinite programming) algorithm, as described in.">Iris</a> for details on the original algorithm. This variant uses nonlinear <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html">optimization</a> (instead of convex <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html">optimization</a>) to find collisions in configuration space; each potential collision is probabilistically "certified" by restarting the nonlinear <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html">optimization</a> from random initial seeds inside the candidate IRIS region until it fails to find a collision in <span class="tt">options.num_collision_infeasible_samples</span> consecutive attempts.</dd></dl>
<p>This method constructs a single Iris region in the configuration space of <code class="param">plant</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga95b21d4800c09233dd7a489238bced19" title="Cover the configuration space in Iris regions using the Visibility Clique Cover Algorithm as describe...">planning::IrisInConfigurationSpaceFromCliqueCover</a> for a method to automatically cover the configuration space with multiple <a class="el" href="#ga41ad36e136530c33abb2d19a40f4f5e3" title="The IRIS (Iterative Region Inflation by Semidefinite programming) algorithm, as described in.">Iris</a> regions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plant</td><td>describes the kinematics of configuration space. It must be connected to a <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> in a <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">systems::Diagram</a>. </td></tr>
    <tr><td class="paramname">context</td><td>is a context of the <code class="param">plant</code>. The context must have the positions of the plant set to the initialIRIS seed configuration. </td></tr>
    <tr><td class="paramname">options</td><td>provides additional configuration options. In particular, increasing <span class="tt">options.num_collision_infeasible_samples</span> increases the chances that the IRIS regions are collision free but can also significantly increase the run-time of the algorithm. The same goes for <span class="tt">options.num_additional_constraints_infeasible_samples</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the sample configuration in <code class="param">context</code> is infeasible. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if termination_func is invalid on the domain. See <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html#a087724eb9045117415e4d5a93db67ab1" title="A user-defined termination function to determine whether the iterations should stop.">IrisOptions.termination_func</a> for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf5bc571d0ee3753c976d3b521de397c4" name="gaf5bc571d0ee3753c976d3b521de397c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5bc571d0ee3753c976d3b521de397c4">&#9670;&#160;</a></span>IrisNp2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">geometry::optimization::HPolyhedron</a> IrisNp2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1planning_1_1_scene_graph_collision_checker.html">SceneGraphCollisionChecker</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>checker</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_hyperellipsoid.html">geometry::optimization::Hyperellipsoid</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>starting_ellipsoid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">geometry::optimization::HPolyhedron</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1planning_1_1_iris_np2_options.html">IrisNp2Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1planning_1_1_iris_np2_options.html">IrisNp2Options</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The IRIS-NP2 (Iterative Regional Inflation by Semidefinite and Nonlinear Programming 2) algorithm, as described in. </p>
<p>[Werner et al., 2024] P. Werner, T. Cohn*, R. H. Jiang*, T. Seyde, M. Simchowitz, R. Tedrake, and D. Rus, "Faster Algorithms for Growing
Collision-Free Convex Polytopes in Robot Configuration Space," &#160;* Denotes equal contribution.</p>
<p><a href="https://groups.csail.mit.edu/robotics-center/public_papers/Werner24.pdf">https://groups.csail.mit.edu/robotics-center/public_papers/Werner24.pdf</a></p>
<p>This algorithm constructs probabilistically collision-free polytopes in robot configuration space using a scene graph collision checker. The sets are constructed by identifying collisions with sampling and nonlinear programming. The produced polytope P is probabilistically collision-free in the sense that one gets to control the probability δ that the fraction of the volume-in-collision is larger than ε</p>
<p>Pr[λ(P\Cfree)/λ(P) &gt; ε] ≤ δ.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">starting_ellipsoid</td><td>provides the initial ellipsoid around which to grow the region. This is typically a small ball around a collision-free configuration (e.g. Hyperellipsoid::MakeHyperSphere(radius, seed_point)). The center of this ellipsoid is required to be collision-free. </td></tr>
    <tr><td class="paramname">domain</td><td>describes the total region of interest; computed IRIS regions will be inside this domain. It must be bounded, and is typically a simple bounding box representing joint limits (e.g. from HPolyhedron::MakeBox). </td></tr>
    <tr><td class="paramname">options</td><td>contains algorithm parameters such as the desired collision-free fraction, confidence level, and various algorithmic settings.</td></tr>
  </table>
  </dd>
</dl>
<p>The <code class="param">starting_ellipsoid</code> and <code class="param">domain</code> must describe elements in the same ambient dimension as the configuration space of the robot, unless a parameterization is specified (in which case, they must match <span class="tt">options.parameterization_dimension</span>). </p><dl class="section return"><dt>Returns</dt><dd>A HPolyhedron representing the computed collision-free region in configuration space.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This feature is considered to be <b>experimental</b> and may change or be removed at any time, without any deprecation notice ahead of time.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>the center of <span class="tt">starting_ellipsoid</span> is in collision, or violates any of the user-specified constraints in <span class="tt">options.prog_with_additional_constraints</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This can be a long running function that needs to solve many QPs. If you have a solver which requires a license, consider acquiring the license before solving this function. See AcquireLicense for more details.</dd></dl>
<p>IrisNp2 is still in development, so certain features of <a class="el" href="classdrake_1_1planning_1_1_scene_graph_collision_checker.html" title="An implementation of CollisionChecker that uses SceneGraph to provide collision checks.">SceneGraphCollisionChecker</a> and parts of [Werner et al., 2024] are not yet supported.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>any collision pairs in <span class="tt">checker</span> have negative padding. </td></tr>
    <tr><td class="paramname">if</td><td>any collision geometries have been been added in <span class="tt">checker</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9b44245010bfdc8163645f0c62f9e9ab" name="ga9b44245010bfdc8163645f0c62f9e9ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b44245010bfdc8163645f0c62f9e9ab">&#9670;&#160;</a></span>IrisZo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">geometry::optimization::HPolyhedron</a> IrisZo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1planning_1_1_collision_checker.html">CollisionChecker</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>checker</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_hyperellipsoid.html">geometry::optimization::Hyperellipsoid</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>starting_ellipsoid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">geometry::optimization::HPolyhedron</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1planning_1_1_iris_zo_options.html">IrisZoOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1planning_1_1_iris_zo_options.html">IrisZoOptions</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The IRIS-ZO (Iterative Regional Inflation by Semidefinite programming - Zero Order) algorithm, as described in. </p>
<p>P. Werner, T. Cohn*, R. H. Jiang*, T. Seyde, M. Simchowitz, R. Tedrake, and D. Rus, "Faster Algorithms for Growing Collision-Free Convex Polytopes in Robot
Configuration Space," &#160;* Denotes equal contribution.</p>
<p><a href="https://groups.csail.mit.edu/robotics-center/public_papers/Werner24.pdf">https://groups.csail.mit.edu/robotics-center/public_papers/Werner24.pdf</a></p>
<p>This algorithm constructs probabilistically collision-free polytopes in robot configuration space while only relying on a collision checker. The sets are constructed using a simple parallel zero-order optimization strategy. The produced polytope P is probabilistically collision-free in the sense that one gets to control the probability δ that the fraction of the volume-in-collision is larger than ε</p>
<p>Pr[λ(P\Cfree)/λ(P) &gt; ε] ≤ δ.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">starting_ellipsoid</td><td>provides the initial ellipsoid around which to grow the region. This is typically a small ball around a collision-free configuration (e.g. Hyperellipsoid::MakeHyperSphere(radius, seed_point)). The center of this ellipsoid is required to be collision-free. </td></tr>
    <tr><td class="paramname">domain</td><td>describes the total region of interest; computed IRIS regions will be inside this domain. It must be bounded, and is typically a simple bounding box representing joint limits (e.g. from HPolyhedron::MakeBox). </td></tr>
    <tr><td class="paramname">options</td><td>contains algorithm parameters such as the desired collision-free fraction, confidence level, and various algorithmic settings.</td></tr>
  </table>
  </dd>
</dl>
<p>The <code class="param">starting_ellipsoid</code> and <code class="param">domain</code> must describe elements in the same ambient dimension as the configuration space of the robot, unless a parameterization is specified (in which case, they must match <span class="tt">options.parameterization_dimension</span>). </p><dl class="section return"><dt>Returns</dt><dd>A HPolyhedron representing the computed collision-free region in configuration space.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This feature is considered to be <b>experimental</b> and may change or be removed at any time, without any deprecation notice ahead of time.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>the center of <span class="tt">starting_ellipsoid</span> is in collision, or violates any of the user-specified constraints in <span class="tt">options.prog_with_additional_constraints</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This can be a long running function that needs to solve many QPs. If you have a solver which requires a license, consider acquiring the license before solving this function. See AcquireLicense for more details. </dd></dl>

</div>
</div>
<a id="ga1695afcbf10d19b297140421a5a5ade8" name="ga1695afcbf10d19b297140421a5a5ade8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1695afcbf10d19b297140421a5a5ade8">&#9670;&#160;</a></span>MakeIrisObstacles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> MakeIrisObstacles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>query_object</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>reference_frame</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html" title="Abstract base class for defining a convex set.">ConvexSet</a> representations of obstacles for IRIS in 3D using the geometry from a <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> <a class="el" href="classdrake_1_1geometry_1_1_query_object.html" title="The QueryObject serves as a mechanism to perform geometry queries on the world&#39;s geometry.">QueryObject</a>. </p>
<p>All geometry in the scene with a proximity role, both anchored and dynamic, are consider to be <em>fixed</em> obstacles frozen in the poses captured in the context used to create the <a class="el" href="classdrake_1_1geometry_1_1_query_object.html" title="The QueryObject serves as a mechanism to perform geometry queries on the world&#39;s geometry.">QueryObject</a>.</p>
<p>When multiple representations are available for a particular geometry (e.g. a <a class="el" href="classdrake_1_1geometry_1_1_box.html" title="Definition of a box.">Box</a> can be represented as either an <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html" title="Implements a polyhedral convex set using the half-space representation: {x| A x ≤ b}...">HPolyhedron</a> or a <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_v_polytope.html" title="A polytope described using the vertex representation.">VPolytope</a>), then this method will prioritize the representation that we expect is most performant for the current implementation of the IRIS algorithm. </p>

</div>
</div>
<a id="gaece042cde9122f05ca663a27fa7d0ea9" name="gaece042cde9122f05ca663a27fa7d0ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaece042cde9122f05ca663a27fa7d0ea9">&#9670;&#160;</a></span>SetEdgeContainmentTerminationCondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetEdgeContainmentTerminationCondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">IrisOptions</a> *</td>          <td class="paramname"><span class="paramname"><em>iris_options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x_1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x_2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>epsilon</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-3</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-6</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the <code class="param">iris_options</code> to facilitate finding a region that contains the edge between x_1 and x_2. </p>
<p>It sets <code class="param">iris_options.starting_ellipse</code> to be a hyperellipsoid that contains the edge, is centered at the midpoint of the edge and extends in other directions by epsilon. It also sets <code class="param">iris_options.termination_func</code> such that IRIS iterations terminate when the edge is no longer contained in the IRIS region with tolerance tol.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if x_1.size() != x_2.size(). </td></tr>
    <tr><td class="paramname">std::exception</td><td>if epsilon &lt;= 0. This is due to the fact that the hyperellipsoid for <code class="param">iris_options.starting_ellipse</code> must have non-zero volume. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="gae1b0dda8a6f7a3ed77c6e247018c0008" name="gae1b0dda8a6f7a3ed77c6e247018c0008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1b0dda8a6f7a3ed77c6e247018c0008">&#9670;&#160;</a></span>iris_options</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt;<a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">geometry::optimization::IrisOptions</a>, <a class="el" href="classdrake_1_1planning_1_1_iris_np2_options.html">IrisNp2Options</a>, <a class="el" href="classdrake_1_1planning_1_1_iris_zo_options.html">IrisZoOptions</a>&gt; iris_options {<a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">geometry::optimization::IrisOptions</a>{.<a class="el" href="structdrake_1_1planning_1_1_iris_from_clique_cover_options.html#ab9404d7dc104e7eb4e27ed7e38ccff72">iteration_limit</a> = 1}}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The options used on internal calls to Iris. </p>
<p>The type of this option determines which variant of Iris is called. Currently, it is recommended to only run Iris for one iteration when building from a clique so as to avoid discarding the information gained from the clique.</p>
<p>Note that <span class="tt">IrisOptions</span> can optionally include a meshcat instance to provide debugging visualization. If this is provided <span class="tt">IrisFromCliqueCover</span> will provide debug visualization in meshcat showing where in configuration space it is drawing from. However, if the parallelism option is set to allow more than 1 thread, then the debug visualizations of internal Iris calls will be disabled. This is due to a limitation of drawing to meshcat from outside the main thread. </p><dl class="section note"><dt>Note</dt><dd>some of these variants specify a parallelism parameter. In IrisInConfigurationSpaceFromCliqueCover, the iris_options.parallelism is ignored and the value of parallelism specified by <span class="tt">this.parallelism</span> will be used instead. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
