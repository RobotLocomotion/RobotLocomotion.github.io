<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: System&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1systems_1_1_system.html','','classdrake_1_1systems_1_1_system-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">System&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel abstract">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class drake::systems::System&lt; T &gt;</div><p>Base class for all <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> functionality that is dependent on the templatized scalar type T for input, state, parameters, and outputs. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/systems/framework/system.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a78eaec0a6a2d1c99d2a7eb5eeb1f8bdc" id="r_a78eaec0a6a2d1c99d2a7eb5eeb1f8bdc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78eaec0a6a2d1c99d2a7eb5eeb1f8bdc">Scalar</a> = T</td></tr>
<tr class="memdesc:a78eaec0a6a2d1c99d2a7eb5eeb1f8bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scalar type with which this System was instantiated.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abfc527f890d8846b751645ab81a67bb1" id="r_abfc527f890d8846b751645ab81a67bb1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfc527f890d8846b751645ab81a67bb1">~System</a> () override</td></tr>
<tr class="memitem:a8cb9e835ba22d40ee92cafd4ebee5813" id="r_a8cb9e835ba22d40ee92cafd4ebee5813"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cb9e835ba22d40ee92cafd4ebee5813">Accept</a> (<a class="el" href="classdrake_1_1systems_1_1_system_visitor.html">SystemVisitor</a>&lt; T &gt; *v) const</td></tr>
<tr class="memdesc:a8cb9e835ba22d40ee92cafd4ebee5813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a visitor pattern.  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:a718e74eb516f658aa9f80ab77706e4e5" id="r_a718e74eb516f658aa9f80ab77706e4e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a718e74eb516f658aa9f80ab77706e4e5">System</a> (const System &amp;)=delete</td></tr>
<tr class="memitem:a7623bef605c331dd6ffbf1e1436c4a41" id="r_a7623bef605c331dd6ffbf1e1436c4a41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7623bef605c331dd6ffbf1e1436c4a41">operator=</a> (const <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a> &amp;)=delete</td></tr>
<tr class="memitem:a51e42f15501f79c6a60375041a7e3729" id="r_a51e42f15501f79c6a60375041a7e3729"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51e42f15501f79c6a60375041a7e3729">System</a> (System &amp;&amp;)=delete</td></tr>
<tr class="memitem:ab8b7c37e1f1027f9aa77d77efaffeb0d" id="r_ab8b7c37e1f1027f9aa77d77efaffeb0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8b7c37e1f1027f9aa77d77efaffeb0d">operator=</a> (<a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a> &amp;&amp;)=delete</td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Resource allocation and initialization</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>These methods are used to allocate and initialize <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> resources. </p>
</div></td></tr>
<tr class="memitem:a78fda6d982dc968061c5d92e32173629" id="r_a78fda6d982dc968061c5d92e32173629"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78fda6d982dc968061c5d92e32173629">AllocateContext</a> () const</td></tr>
<tr class="memdesc:a78fda6d982dc968061c5d92e32173629"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Returns an <b>uninitialized</b> <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context&lt;T&gt;</a> suitable for use with this System&lt;T&gt;.  <br /></td></tr>
<tr class="memitem:a6cc7dd6cf032c4b3137de55349d8e99b" id="r_a6cc7dd6cf032c4b3137de55349d8e99b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cc7dd6cf032c4b3137de55349d8e99b">AllocateCompositeEventCollection</a> () const</td></tr>
<tr class="memdesc:a6cc7dd6cf032c4b3137de55349d8e99b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html" title="This class bundles an instance of each EventCollection&lt;EventType&gt; into one object that stores the het...">CompositeEventCollection</a> for this system.  <br /></td></tr>
<tr class="memitem:ab7ce7f3c3ed819de001d4ab977ee65bf" id="r_ab7ce7f3c3ed819de001d4ab977ee65bf"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7ce7f3c3ed819de001d4ab977ee65bf">AllocateInputVector</a> (const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;input_port) const</td></tr>
<tr class="memdesc:ab7ce7f3c3ed819de001d4ab977ee65bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input port, allocates the vector storage.  <br /></td></tr>
<tr class="memitem:a69db7d7d92345c74487bc38c5d136a07" id="r_a69db7d7d92345c74487bc38c5d136a07"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69db7d7d92345c74487bc38c5d136a07">AllocateInputAbstract</a> (const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;input_port) const</td></tr>
<tr class="memdesc:a69db7d7d92345c74487bc38c5d136a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input port, allocates the abstract storage.  <br /></td></tr>
<tr class="memitem:af46c35210719be2e1035e14ea9a11299" id="r_af46c35210719be2e1035e14ea9a11299"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_system_output.html">SystemOutput</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af46c35210719be2e1035e14ea9a11299">AllocateOutput</a> () const</td></tr>
<tr class="memdesc:af46c35210719be2e1035e14ea9a11299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a container that can hold the values of all of this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>'s output ports.  <br /></td></tr>
<tr class="memitem:a672f9ea75065ea78820a04982cca899c" id="r_a672f9ea75065ea78820a04982cca899c"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a672f9ea75065ea78820a04982cca899c">AllocateTimeDerivatives</a> () const =0</td></tr>
<tr class="memdesc:a672f9ea75065ea78820a04982cca899c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html" title="ContinuousState is a view of, and optionally a container for, all the continuous state variables xc o...">ContinuousState</a> of the same size as the continuous_state allocated in CreateDefaultContext.  <br /></td></tr>
<tr class="memitem:a7bb970a7568116aa65af6d2526ff5977" id="r_a7bb970a7568116aa65af6d2526ff5977"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bb970a7568116aa65af6d2526ff5977">AllocateImplicitTimeDerivativesResidual</a> () const</td></tr>
<tr class="memdesc:a7bb970a7568116aa65af6d2526ff5977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85" title="A column vector of any size, templated on scalar type.">VectorX</a> suitable for use as the output argument to the <a class="el" href="#a8debe7d25e61fd759c918d889286525f" title="Evaluates the implicit form of the System equations and returns the residual.">CalcImplicitTimeDerivativesResidual()</a> method.  <br /></td></tr>
<tr class="memitem:ad67b4bb437d72bc3ee99a4c66ad51b6f" id="r_ad67b4bb437d72bc3ee99a4c66ad51b6f"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad67b4bb437d72bc3ee99a4c66ad51b6f">AllocateDiscreteVariables</a> () const =0</td></tr>
<tr class="memdesc:ad67b4bb437d72bc3ee99a4c66ad51b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classdrake_1_1systems_1_1_discrete_values.html" title="DiscreteValues is a container for numerical but non-continuous state and parameters.">DiscreteValues</a> of the same dimensions as the discrete_state allocated in CreateDefaultContext.  <br /></td></tr>
<tr class="memitem:aa036f873464a74c03fab943bbace8942" id="r_aa036f873464a74c03fab943bbace8942"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa036f873464a74c03fab943bbace8942">CreateDefaultContext</a> () const</td></tr>
<tr class="memdesc:aa036f873464a74c03fab943bbace8942"><td class="mdescLeft">&#160;</td><td class="mdescRight">This convenience method allocates a context using <a class="el" href="#a78fda6d982dc968061c5d92e32173629" title="(Advanced) Returns an uninitialized Context&lt;T&gt; suitable for use with this System&lt;T&gt;.">AllocateContext()</a> and sets its default values using <a class="el" href="#ab4e6ee413f4f47a20f6dcc2cbd831b88" title="Sets Context fields to their default values.">SetDefaultContext()</a>.  <br /></td></tr>
<tr class="memitem:abb9c4edaf95ef26f1ec419f32446e042" id="r_abb9c4edaf95ef26f1ec419f32446e042"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb9c4edaf95ef26f1ec419f32446e042">SetDefaultParameters</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_parameters.html">Parameters</a>&lt; T &gt; *parameters) const =0</td></tr>
<tr class="memdesc:abb9c4edaf95ef26f1ec419f32446e042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns default values to all parameters.  <br /></td></tr>
<tr class="memitem:a909935648b14e55b07263264616ace3c" id="r_a909935648b14e55b07263264616ace3c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a909935648b14e55b07263264616ace3c">SetDefaultState</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *state) const =0</td></tr>
<tr class="memdesc:a909935648b14e55b07263264616ace3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns default values to all elements of the state.  <br /></td></tr>
<tr class="memitem:ab4e6ee413f4f47a20f6dcc2cbd831b88" id="r_ab4e6ee413f4f47a20f6dcc2cbd831b88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4e6ee413f4f47a20f6dcc2cbd831b88">SetDefaultContext</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:ab4e6ee413f4f47a20f6dcc2cbd831b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> fields to their default values.  <br /></td></tr>
<tr class="memitem:a47a8dc372e0063851c9851ee15da74e9" id="r_a47a8dc372e0063851c9851ee15da74e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47a8dc372e0063851c9851ee15da74e9">SetRandomState</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *state, <a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *generator) const</td></tr>
<tr class="memdesc:a47a8dc372e0063851c9851ee15da74e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns random values to all elements of the state.  <br /></td></tr>
<tr class="memitem:af7a8969fd7784256a68402b391f8902b" id="r_af7a8969fd7784256a68402b391f8902b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7a8969fd7784256a68402b391f8902b">SetRandomParameters</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_parameters.html">Parameters</a>&lt; T &gt; *parameters, <a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *generator) const</td></tr>
<tr class="memdesc:af7a8969fd7784256a68402b391f8902b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns random values to all parameters.  <br /></td></tr>
<tr class="memitem:a6a5a403983483dda39f8196a241225f2" id="r_a6a5a403983483dda39f8196a241225f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a5a403983483dda39f8196a241225f2">SetRandomContext</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context, <a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *generator) const</td></tr>
<tr class="memdesc:a6a5a403983483dda39f8196a241225f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> fields to random values.  <br /></td></tr>
<tr class="memitem:a47ec86445724fd77391af7874bfc4848" id="r_a47ec86445724fd77391af7874bfc4848"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47ec86445724fd77391af7874bfc4848">AllocateFixedInputs</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:a47ec86445724fd77391af7874bfc4848"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each input port, allocates a fixed input of the concrete type that this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> requires, and binds it to the port, disconnecting any prior input.  <br /></td></tr>
<tr class="memitem:a037dd9c0afe6e059e67edb4c9c01eeb3" id="r_a037dd9c0afe6e059e67edb4c9c01eeb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a037dd9c0afe6e059e67edb4c9c01eeb3">HasAnyDirectFeedthrough</a> () const</td></tr>
<tr class="memdesc:a037dd9c0afe6e059e67edb4c9c01eeb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if any of the inputs to the system might be directly fed through to any of its outputs and <span class="tt">false</span> otherwise.  <br /></td></tr>
<tr class="memitem:a51acfa17df1bc87ce8eaa0e1556f6d46" id="r_a51acfa17df1bc87ce8eaa0e1556f6d46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51acfa17df1bc87ce8eaa0e1556f6d46">HasDirectFeedthrough</a> (int output_port) const</td></tr>
<tr class="memdesc:a51acfa17df1bc87ce8eaa0e1556f6d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there might be direct-feedthrough from any input port to the given <code class="param">output_port</code>, and false otherwise.  <br /></td></tr>
<tr class="memitem:a8dd5092dc2aa2c8f38e0d6336437012d" id="r_a8dd5092dc2aa2c8f38e0d6336437012d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dd5092dc2aa2c8f38e0d6336437012d">HasDirectFeedthrough</a> (int input_port, int output_port) const</td></tr>
<tr class="memdesc:a8dd5092dc2aa2c8f38e0d6336437012d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there might be direct-feedthrough from the given <code class="param">input_port</code> to the given <code class="param">output_port</code>, and false otherwise.  <br /></td></tr>
<tr class="memitem:abde83cc85484e49d2edf404f64be27b5" id="r_abde83cc85484e49d2edf404f64be27b5"><td class="memItemLeft" align="right" valign="top">virtual std::multimap&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abde83cc85484e49d2edf404f64be27b5">GetDirectFeedthroughs</a> () const=0</td></tr>
<tr class="memdesc:abde83cc85484e49d2edf404f64be27b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports all direct feedthroughs from input ports to output ports.  <br /></td></tr>
<tr id="pub-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Publishing</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>Publishing is the primary mechanism for a System to communicate with the world outside the System abstraction during a simulation.</p>
<p>Publishing occurs at user-specified times or events and can generate side-effect results such as terminal output, visualization, logging, plotting, and network messages. Other than computational cost, publishing has no effect on the progress of a simulation. </p>
</div></td></tr>
<tr class="memitem:a432d732019c64ca4a869b35d4d63bb3d" id="r_a432d732019c64ca4a869b35d4d63bb3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_event_status.html">EventStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a432d732019c64ca4a869b35d4d63bb3d">Publish</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt; &gt; &amp;events) const</td></tr>
<tr class="memdesc:a432d732019c64ca4a869b35d4d63bb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the public entry point for dispatching all publish event handlers.  <br /></td></tr>
<tr class="memitem:a59e69babd4887d33fc65c02fa7d0aafb" id="r_a59e69babd4887d33fc65c02fa7d0aafb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59e69babd4887d33fc65c02fa7d0aafb">ForcedPublish</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a59e69babd4887d33fc65c02fa7d0aafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Manually triggers any <a class="el" href="classdrake_1_1systems_1_1_publish_event.html" title="This class represents a publish event.">PublishEvent</a> that has trigger type kForced.  <br /></td></tr>
<tr id="pub-methods-3" class="groupHeader"><td colspan="2"><div class="groupHeader">Cached evaluations</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>Given the values in a <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>, a Drake System must be able to provide the results of particular computations needed for analysis and simulation of the System.</p>
<p>These results are maintained in a mutable cache within the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> so that a result need be computed only once, the first time it is requested after a change to one of its prerequisite values.</p>
<p>The <span class="tt">Eval</span> methods in this group return a reference to the already-computed result in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>'s cache. If the current value is out of date, they first update the cache entry using the corresponding <span class="tt">Calc</span> method from the "Calculations" group. Evaluations of input ports instead delegate to the containing <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a>, which arranges to have the appropriate subsystem evaluate the source output port.</p>
<p>Methods in this group that specify preconditions operate as follows: The preconditions will be checked in Debug builds but some or all might not be checked in Release builds for performance reasons. If we do check and a precondition is violated, an std::logic_error will be thrown with a helpful message. </p>
</div></td></tr>
<tr class="memitem:a15b6e794826488cdb01ef10a2b21a5dd" id="r_a15b6e794826488cdb01ef10a2b21a5dd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15b6e794826488cdb01ef10a2b21a5dd">EvalTimeDerivatives</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a15b6e794826488cdb01ef10a2b21a5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the cached value of the continuous state variable time derivatives, evaluating first if necessary using <a class="el" href="#af2677f8773e90a538483eedd80a81a9f" title="Calculates the time derivatives ẋ꜀ of the continuous state x꜀ into a given output argument.">CalcTimeDerivatives()</a>.  <br /></td></tr>
<tr class="memitem:a63db490cc14b49e3a67f5195a69cd869" id="r_a63db490cc14b49e3a67f5195a69cd869"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63db490cc14b49e3a67f5195a69cd869">get_time_derivatives_cache_entry</a> () const</td></tr>
<tr class="memdesc:a63db490cc14b49e3a67f5195a69cd869"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Returns the <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html" title="A CacheEntry belongs to a System and represents the properties of one of that System&#39;s cached computa...">CacheEntry</a> used to cache time derivatives for <a class="el" href="#a15b6e794826488cdb01ef10a2b21a5dd" title="Returns a reference to the cached value of the continuous state variable time derivatives,...">EvalTimeDerivatives()</a>.  <br /></td></tr>
<tr class="memitem:a97c1ac3506af8f2c386ba74b5fbc1e48" id="r_a97c1ac3506af8f2c386ba74b5fbc1e48"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97c1ac3506af8f2c386ba74b5fbc1e48">EvalPotentialEnergy</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a97c1ac3506af8f2c386ba74b5fbc1e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the cached value of the potential energy (PE), evaluating first if necessary using <a class="el" href="#a3d5eb1d2630aab1938230257554d1f43" title="Calculates and returns the potential energy represented by the current configuration provided in cont...">CalcPotentialEnergy()</a>.  <br /></td></tr>
<tr class="memitem:abfc345ff50df77ad2ae727e6d3a9b939" id="r_abfc345ff50df77ad2ae727e6d3a9b939"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfc345ff50df77ad2ae727e6d3a9b939">EvalKineticEnergy</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:abfc345ff50df77ad2ae727e6d3a9b939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the cached value of the kinetic energy (KE), evaluating first if necessary using <a class="el" href="#aad01402fef0de79310989d7d22dfde92" title="Calculates and returns the kinetic energy represented by the current configuration and velocity provi...">CalcKineticEnergy()</a>.  <br /></td></tr>
<tr class="memitem:a94bf4d9472a96aad5d65e47375cf035f" id="r_a94bf4d9472a96aad5d65e47375cf035f"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94bf4d9472a96aad5d65e47375cf035f">EvalConservativePower</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a94bf4d9472a96aad5d65e47375cf035f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the cached value of the conservative power (Pc), evaluating first if necessary using <a class="el" href="#a5674ae416c2808c939dffc117b209f23" title="Calculates and returns the conservative power represented by the current contents of the given contex...">CalcConservativePower()</a>.  <br /></td></tr>
<tr class="memitem:a08ed6bf23e134cbc50d073e81ffc247f" id="r_a08ed6bf23e134cbc50d073e81ffc247f"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08ed6bf23e134cbc50d073e81ffc247f">EvalNonConservativePower</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a08ed6bf23e134cbc50d073e81ffc247f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the cached value of the non-conservative power (Pnc), evaluating first if necessary using <a class="el" href="#a23fe133b70153e382d7f50c38b96bf1f" title="Calculates and returns the non-conservative power represented by the current contents of the given co...">CalcNonConservativePower()</a>.  <br /></td></tr>
<tr class="memitem:af396318b2f8da923d1981bb40f9ab2f7" id="r_af396318b2f8da923d1981bb40f9ab2f7"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class Vec = BasicVector&gt; </td></tr>
<tr class="memitem:af396318b2f8da923d1981bb40f9ab2f7 template"><td class="memItemLeft" align="right" valign="top">const Vec&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af396318b2f8da923d1981bb40f9ab2f7">EvalVectorInput</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, int port_index) const</td></tr>
<tr class="memdesc:af396318b2f8da923d1981bb40f9ab2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the vector-valued input port with the given <span class="tt">port_index</span> as a <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase.">BasicVector</a> or a specific subclass <span class="tt">Vec</span> derived from <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase.">BasicVector</a>.  <br /></td></tr>
<tr id="pub-methods-4" class="groupHeader"><td colspan="2"><div class="groupHeader">Constraint-related functions</div></td></tr>
<tr class="memitem:ad97e05bf6c16c4bbf058d3cd4978f696" id="r_ad97e05bf6c16c4bbf058d3cd4978f696"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad97e05bf6c16c4bbf058d3cd4978f696">AddExternalConstraint</a> (<a class="el" href="classdrake_1_1systems_1_1_external_system_constraint.html">ExternalSystemConstraint</a> constraint)</td></tr>
<tr class="memdesc:ad97e05bf6c16c4bbf058d3cd4978f696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an "external" constraint to this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>.  <br /></td></tr>
<tr id="pub-methods-5" class="groupHeader"><td colspan="2"><div class="groupHeader">Calculations</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>A Drake System defines a set of common computations that are understood by the framework.</p>
<p>Most of these are embodied in a <span class="tt">Calc</span> method that unconditionally performs the calculation into an output argument of the appropriate type, using only values from the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. These are paired with an <span class="tt">Eval</span> method that returns a reference to an already-calculated result residing in the cache; if needed that result is first obtained using the <span class="tt">Calc</span> method. See the "Evaluations" group for more information.</p>
<p>This group also includes additional System-specific operations that depend on both <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> and additional input arguments. </p>
</div></td></tr>
<tr class="memitem:af2677f8773e90a538483eedd80a81a9f" id="r_af2677f8773e90a538483eedd80a81a9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2677f8773e90a538483eedd80a81a9f">CalcTimeDerivatives</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; *derivatives) const</td></tr>
<tr class="memdesc:af2677f8773e90a538483eedd80a81a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the time derivatives ẋ꜀ of the continuous state x꜀ into a given output argument.  <br /></td></tr>
<tr class="memitem:a8debe7d25e61fd759c918d889286525f" id="r_a8debe7d25e61fd759c918d889286525f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8debe7d25e61fd759c918d889286525f">CalcImplicitTimeDerivativesResidual</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &amp;proposed_derivatives, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; residual) const</td></tr>
<tr class="memdesc:a8debe7d25e61fd759c918d889286525f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the implicit form of the System equations and returns the residual.  <br /></td></tr>
<tr class="memitem:ac520da0941e15dff2045e3c8701dfdab" id="r_ac520da0941e15dff2045e3c8701dfdab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_event_status.html">EventStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac520da0941e15dff2045e3c8701dfdab">CalcDiscreteVariableUpdate</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &gt; &amp;events, <a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *discrete_state) const</td></tr>
<tr class="memdesc:ac520da0941e15dff2045e3c8701dfdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the public entry point for dispatching all discrete variable update event handlers.  <br /></td></tr>
<tr class="memitem:a7fd83875ab52bec063989cd186980fef" id="r_a7fd83875ab52bec063989cd186980fef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fd83875ab52bec063989cd186980fef">ApplyDiscreteVariableUpdate</a> (const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &gt; &amp;events, <a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *discrete_state, <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:a7fd83875ab52bec063989cd186980fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the <code class="param">discrete_state</code> results of a previous call to <a class="el" href="#ac520da0941e15dff2045e3c8701dfdab" title="This method is the public entry point for dispatching all discrete variable update event handlers.">CalcDiscreteVariableUpdate()</a> that dispatched the given collection of events, modifies the <code class="param">context</code> to reflect the updated <code class="param">discrete_state</code>.  <br /></td></tr>
<tr class="memitem:ae5fb4376d5f80e2fbaecae478c2ab10b" id="r_ae5fb4376d5f80e2fbaecae478c2ab10b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5fb4376d5f80e2fbaecae478c2ab10b">CalcForcedDiscreteVariableUpdate</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *discrete_state) const</td></tr>
<tr class="memdesc:ae5fb4376d5f80e2fbaecae478c2ab10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Manually triggers any <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html" title="This class represents a discrete update event.">DiscreteUpdateEvent</a> that has trigger type kForced.  <br /></td></tr>
<tr class="memitem:a6af241ea78c280884f5f638f68426e28" id="r_a6af241ea78c280884f5f638f68426e28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_event_status.html">EventStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6af241ea78c280884f5f638f68426e28">CalcUnrestrictedUpdate</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; &gt; &amp;events, <a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *state) const</td></tr>
<tr class="memdesc:a6af241ea78c280884f5f638f68426e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the public entry point for dispatching all unrestricted update event handlers.  <br /></td></tr>
<tr class="memitem:a35a230308db94f60cc1b813bca064f6e" id="r_a35a230308db94f60cc1b813bca064f6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35a230308db94f60cc1b813bca064f6e">ApplyUnrestrictedUpdate</a> (const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; &gt; &amp;events, <a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *state, <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:a35a230308db94f60cc1b813bca064f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the <code class="param">state</code> results of a previous call to <a class="el" href="#a6af241ea78c280884f5f638f68426e28" title="This method is the public entry point for dispatching all unrestricted update event handlers.">CalcUnrestrictedUpdate()</a> that dispatched the given collection of events, modifies the <code class="param">context</code> to reflect the updated <code class="param">state</code>.  <br /></td></tr>
<tr class="memitem:a38e86af4aa006febb699db0433d434da" id="r_a38e86af4aa006febb699db0433d434da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38e86af4aa006febb699db0433d434da">CalcForcedUnrestrictedUpdate</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *state) const</td></tr>
<tr class="memdesc:a38e86af4aa006febb699db0433d434da"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Manually triggers any <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html" title="This class represents an unrestricted update event.">UnrestrictedUpdateEvent</a> that has trigger type kForced.  <br /></td></tr>
<tr class="memitem:a164afe3c1db737b93696b8808bb2c942" id="r_a164afe3c1db737b93696b8808bb2c942"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a164afe3c1db737b93696b8808bb2c942">CalcNextUpdateTime</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events) const</td></tr>
<tr class="memdesc:a164afe3c1db737b93696b8808bb2c942"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called by a <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> during its calculation of the size of the next continuous step to attempt.  <br /></td></tr>
<tr class="memitem:adf1f428d7eb6e62bcdd26e9d5a770cba" id="r_adf1f428d7eb6e62bcdd26e9d5a770cba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf1f428d7eb6e62bcdd26e9d5a770cba">GetPeriodicEvents</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events) const</td></tr>
<tr class="memdesc:adf1f428d7eb6e62bcdd26e9d5a770cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all periodic events in this System.  <br /></td></tr>
<tr class="memitem:ad8a24b8f910f9d990db8e59bf2bae6d0" id="r_ad8a24b8f910f9d990db8e59bf2bae6d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8a24b8f910f9d990db8e59bf2bae6d0">GetPerStepEvents</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events) const</td></tr>
<tr class="memdesc:ad8a24b8f910f9d990db8e59bf2bae6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called by <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Simulator::Initialize()</a> to gather all update and publish events that are to be handled in AdvanceTo() at the point before <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> integrates continuous state.  <br /></td></tr>
<tr class="memitem:ae6f84e649d76754f38ea7420a21a1a04" id="r_ae6f84e649d76754f38ea7420a21a1a04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6f84e649d76754f38ea7420a21a1a04">GetInitializationEvents</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events) const</td></tr>
<tr class="memdesc:ae6f84e649d76754f38ea7420a21a1a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called by <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Simulator::Initialize()</a> to gather all update and publish events that need to be handled at initialization before the simulator starts integration.  <br /></td></tr>
<tr class="memitem:affcc9107de045c4500b366b947a3796a" id="r_affcc9107de045c4500b366b947a3796a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affcc9107de045c4500b366b947a3796a">ExecuteInitializationEvents</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:affcc9107de045c4500b366b947a3796a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method triggers all of the initialization events returned by <a class="el" href="#ae6f84e649d76754f38ea7420a21a1a04" title="This method is called by Simulator::Initialize() to gather all update and publish events that need to...">GetInitializationEvents()</a>.  <br /></td></tr>
<tr class="memitem:a90b36c14bbcdf47bf14f2906e18573ca" id="r_a90b36c14bbcdf47bf14f2906e18573ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90b36c14bbcdf47bf14f2906e18573ca">ExecuteForcedEvents</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context, bool publish=true) const</td></tr>
<tr class="memdesc:a90b36c14bbcdf47bf14f2906e18573ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method triggers all of the forced events registered with this System (which might be a <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a>).  <br /></td></tr>
<tr class="memitem:a0e7bc22bdd95c7c611e859c12dfef3e1" id="r_a0e7bc22bdd95c7c611e859c12dfef3e1"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classdrake_1_1systems_1_1_periodic_event_data.html">PeriodicEventData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e7bc22bdd95c7c611e859c12dfef3e1">GetUniquePeriodicDiscreteUpdateAttribute</a> () const</td></tr>
<tr class="memdesc:a0e7bc22bdd95c7c611e859c12dfef3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether there exists a unique periodic timing (offset and period) that triggers one or more discrete update events (and, if so, returns that unique periodic timing).  <br /></td></tr>
<tr class="memitem:a1117b27ee2c4131dbcf1e0179c4b9113" id="r_a1117b27ee2c4131dbcf1e0179c4b9113"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1117b27ee2c4131dbcf1e0179c4b9113">EvalUniquePeriodicDiscreteUpdate</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a1117b27ee2c4131dbcf1e0179c4b9113"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this System contains a unique periodic timing for discrete update events, this function executes the handlers for those periodic events to determine what their effect would be.  <br /></td></tr>
<tr class="memitem:aeb5016cfee3ccd384e0a0ba62b4da5bc" id="r_aeb5016cfee3ccd384e0a0ba62b4da5bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb5016cfee3ccd384e0a0ba62b4da5bc">IsDifferenceEquationSystem</a> (double *time_period=nullptr) const</td></tr>
<tr class="memdesc:aeb5016cfee3ccd384e0a0ba62b4da5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the state dynamics of this system are governed exclusively by a difference equation on a single discrete state group and with a unique periodic update (having zero offset).  <br /></td></tr>
<tr class="memitem:a6c3ec92003f2a50d5d2b0c49aa296b86" id="r_a6c3ec92003f2a50d5d2b0c49aa296b86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c3ec92003f2a50d5d2b0c49aa296b86">IsDifferentialEquationSystem</a> () const</td></tr>
<tr class="memdesc:a6c3ec92003f2a50d5d2b0c49aa296b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the state dynamics of this system are governed exclusively by a differential equation.  <br /></td></tr>
<tr class="memitem:a60cb116e195ba4b7d23fa39e094b4402" id="r_a60cb116e195ba4b7d23fa39e094b4402"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classdrake_1_1systems_1_1_periodic_event_data.html">PeriodicEventData</a>, std::vector&lt; const <a class="el" href="classdrake_1_1systems_1_1_event.html">Event</a>&lt; T &gt; * &gt;, <a class="el" href="structdrake_1_1systems_1_1_periodic_event_data_comparator.html">PeriodicEventDataComparator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60cb116e195ba4b7d23fa39e094b4402">MapPeriodicEventsByTiming</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context=nullptr) const</td></tr>
<tr class="memdesc:a60cb116e195ba4b7d23fa39e094b4402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps all periodic triggered events for a System, organized by timing.  <br /></td></tr>
<tr class="memitem:a574467e50cf5c242f665557daca33111" id="r_a574467e50cf5c242f665557daca33111"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a574467e50cf5c242f665557daca33111">CalcOutput</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_system_output.html">SystemOutput</a>&lt; T &gt; *outputs) const</td></tr>
<tr class="memdesc:a574467e50cf5c242f665557daca33111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method that computes for <em>every</em> output port i the value y(i) that should result from the current contents of the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <br /></td></tr>
<tr class="memitem:a3d5eb1d2630aab1938230257554d1f43" id="r_a3d5eb1d2630aab1938230257554d1f43"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d5eb1d2630aab1938230257554d1f43">CalcPotentialEnergy</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a3d5eb1d2630aab1938230257554d1f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the potential energy represented by the current configuration provided in <span class="tt">context</span>.  <br /></td></tr>
<tr class="memitem:aad01402fef0de79310989d7d22dfde92" id="r_aad01402fef0de79310989d7d22dfde92"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad01402fef0de79310989d7d22dfde92">CalcKineticEnergy</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aad01402fef0de79310989d7d22dfde92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the kinetic energy represented by the current configuration and velocity provided in <span class="tt">context</span>.  <br /></td></tr>
<tr class="memitem:a5674ae416c2808c939dffc117b209f23" id="r_a5674ae416c2808c939dffc117b209f23"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5674ae416c2808c939dffc117b209f23">CalcConservativePower</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a5674ae416c2808c939dffc117b209f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the conservative power represented by the current contents of the given <span class="tt">context</span>.  <br /></td></tr>
<tr class="memitem:a23fe133b70153e382d7f50c38b96bf1f" id="r_a23fe133b70153e382d7f50c38b96bf1f"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23fe133b70153e382d7f50c38b96bf1f">CalcNonConservativePower</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a23fe133b70153e382d7f50c38b96bf1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the non-conservative power represented by the current contents of the given <span class="tt">context</span>.  <br /></td></tr>
<tr class="memitem:a05cc5df6d0d0fe4ea54b522ae776ca39" id="r_a05cc5df6d0d0fe4ea54b522ae776ca39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05cc5df6d0d0fe4ea54b522ae776ca39">MapVelocityToQDot</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;generalized_velocity, <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *qdot) const</td></tr>
<tr class="memdesc:a05cc5df6d0d0fe4ea54b522ae776ca39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a given generalized velocity <span class="tt">v</span> to the time derivative <span class="tt">qdot</span> of the generalized configuration <span class="tt">q</span> taken from the supplied <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <br /></td></tr>
<tr class="memitem:a5225185780af0a535ea7733ce801e1ff" id="r_a5225185780af0a535ea7733ce801e1ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5225185780af0a535ea7733ce801e1ff">MapVelocityToQDot</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;generalized_velocity, <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *qdot) const</td></tr>
<tr class="memdesc:a5225185780af0a535ea7733ce801e1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given generalized velocity to the time derivative of generalized configuration.  <br /></td></tr>
<tr class="memitem:a10eba167739bfe8e7e419b5c8ae41537" id="r_a10eba167739bfe8e7e419b5c8ae41537"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10eba167739bfe8e7e419b5c8ae41537">MapQDotToVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;qdot, <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *generalized_velocity) const</td></tr>
<tr class="memdesc:a10eba167739bfe8e7e419b5c8ae41537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the time derivative <span class="tt">qdot</span> of the generalized configuration <span class="tt">q</span> to generalized velocities <span class="tt">v</span>.  <br /></td></tr>
<tr class="memitem:a0e3359a1ddbc3371e70de3a053113c00" id="r_a0e3359a1ddbc3371e70de3a053113c00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e3359a1ddbc3371e70de3a053113c00">MapQDotToVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;qdot, <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *generalized_velocity) const</td></tr>
<tr class="memdesc:a0e3359a1ddbc3371e70de3a053113c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given time derivative <span class="tt">qdot</span> of generalized configuration <span class="tt">q</span> to generalized velocity <span class="tt">v</span>.  <br /></td></tr>
<tr id="pub-methods-6" class="groupHeader"><td colspan="2"><div class="groupHeader">Subcontext access</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>Methods in this section locate the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> belonging to a particular subsystem, from within the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> for a containing <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> (typically a <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a>).</p>
<p>There are two common circumstances where this is needed:</p>
<ol type="1">
<li>You are given a <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> and its <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>, and have a reference to a particular subsystem contained somewhere in that <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> (that is, an immediate child or deeper descendent). You can ask the <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> to find the subcontext of that subsystem, using <a class="el" href="#aaaa7a04bd169a920b4ae90d4e1db4fe5" title="Returns a const reference to the subcontext that corresponds to the contained System subsystem.">GetSubsystemContext()</a> or <a class="el" href="#a95ce57e23ae030c0ef224b0d0b7cc70c" title="Returns a mutable reference to the subcontext that corresponds to the contained System subsystem.">GetMutableSubsystemContext()</a>.</li>
<li>You are given the root <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> for a complete <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> (typically by the <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> as part of a generated trajectory). You don't have a reference to the <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a>, but you do have a reference to a subsystem of interest. You want to find its subcontext from within the root <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. Use <a class="el" href="#accf801fb0529fd09f9a2c3e9ae941147" title="Returns the const Context for this subsystem, given a root context.">GetMyContextFromRoot()</a> or <a class="el" href="#abb6f679178e8c8864dfb7d65a3198ee3" title="Returns the mutable subsystem context for this system, given a root context.">GetMyMutableContextFromRoot()</a>.</li>
</ol>
<p>The second case is particularly useful in monitor functions for the Drake <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a>. </p>
</div></td></tr>
<tr class="memitem:aaaa7a04bd169a920b4ae90d4e1db4fe5" id="r_aaaa7a04bd169a920b4ae90d4e1db4fe5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaaa7a04bd169a920b4ae90d4e1db4fe5">GetSubsystemContext</a> (const <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; T &gt; &amp;subsystem, const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aaaa7a04bd169a920b4ae90d4e1db4fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the subcontext that corresponds to the contained System <span class="tt">subsystem</span>.  <br /></td></tr>
<tr class="memitem:a95ce57e23ae030c0ef224b0d0b7cc70c" id="r_a95ce57e23ae030c0ef224b0d0b7cc70c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95ce57e23ae030c0ef224b0d0b7cc70c">GetMutableSubsystemContext</a> (const <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; T &gt; &amp;subsystem, <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:a95ce57e23ae030c0ef224b0d0b7cc70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable reference to the subcontext that corresponds to the contained System <span class="tt">subsystem</span>.  <br /></td></tr>
<tr class="memitem:accf801fb0529fd09f9a2c3e9ae941147" id="r_accf801fb0529fd09f9a2c3e9ae941147"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accf801fb0529fd09f9a2c3e9ae941147">GetMyContextFromRoot</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;root_context) const</td></tr>
<tr class="memdesc:accf801fb0529fd09f9a2c3e9ae941147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the const <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> for <span class="tt">this</span> subsystem, given a root context.  <br /></td></tr>
<tr class="memitem:abb6f679178e8c8864dfb7d65a3198ee3" id="r_abb6f679178e8c8864dfb7d65a3198ee3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb6f679178e8c8864dfb7d65a3198ee3">GetMyMutableContextFromRoot</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *root_context) const</td></tr>
<tr class="memdesc:abb6f679178e8c8864dfb7d65a3198ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mutable subsystem context for <span class="tt">this</span> system, given a root context.  <br /></td></tr>
<tr id="pub-methods-7" class="groupHeader"><td colspan="2"><div class="groupHeader">Utility methods</div></td></tr>
<tr class="memitem:a07efaabcfc908b179f7c468a5db507b1" id="r_a07efaabcfc908b179f7c468a5db507b1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07efaabcfc908b179f7c468a5db507b1">get_input_port</a> (int port_index, bool warn_deprecated=true) const</td></tr>
<tr class="memdesc:a07efaabcfc908b179f7c468a5db507b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the typed input port at index <span class="tt">port_index</span>.  <br /></td></tr>
<tr class="memitem:ad0fe2f150e5e48e0797b00fb8344ae97" id="r_ad0fe2f150e5e48e0797b00fb8344ae97"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0fe2f150e5e48e0797b00fb8344ae97">get_input_port</a> () const</td></tr>
<tr class="memdesc:ad0fe2f150e5e48e0797b00fb8344ae97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for the case of exactly one input port.  <br /></td></tr>
<tr class="memitem:ada70a32e95cd84cd4fe02c1d25be437d" id="r_ada70a32e95cd84cd4fe02c1d25be437d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada70a32e95cd84cd4fe02c1d25be437d">get_input_port_selection</a> (std::variant&lt; <a class="el" href="namespacedrake_1_1systems.html#a5484375bdbfb17f525cd2ed396d747f9">InputPortSelection</a>, <a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> &gt; port_index) const</td></tr>
<tr class="memdesc:ada70a32e95cd84cd4fe02c1d25be437d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the typed input port specified by the <a class="el" href="namespacedrake_1_1systems.html#a5484375bdbfb17f525cd2ed396d747f9" title="Intended for use in e.g.">InputPortSelection</a> or by the <a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0" title="Serves as the local index for the input ports of a given System.">InputPortIndex</a>.  <br /></td></tr>
<tr class="memitem:a0b235f5342408f469d02b5b5d2dfb555" id="r_a0b235f5342408f469d02b5b5d2dfb555"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b235f5342408f469d02b5b5d2dfb555">GetInputPort</a> (const std::string &amp;port_name) const</td></tr>
<tr class="memdesc:a0b235f5342408f469d02b5b5d2dfb555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the typed input port with the unique name <code class="param">port_name</code>.  <br /></td></tr>
<tr class="memitem:a2de14ac72441c44be8dec6cc6719dd1e" id="r_a2de14ac72441c44be8dec6cc6719dd1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2de14ac72441c44be8dec6cc6719dd1e">HasInputPort</a> (const std::string &amp;port_name) const</td></tr>
<tr class="memdesc:a2de14ac72441c44be8dec6cc6719dd1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the system has an <a class="el" href="classdrake_1_1systems_1_1_input_port.html" title="An InputPort is a System resource that describes the kind of input a System accepts,...">InputPort</a> of the given <code class="param">port_name</code>.  <br /></td></tr>
<tr class="memitem:ac3465aeda1eaa9b43827b15090e9d5dc" id="r_ac3465aeda1eaa9b43827b15090e9d5dc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3465aeda1eaa9b43827b15090e9d5dc">get_output_port</a> (int port_index, bool warn_deprecated=true) const</td></tr>
<tr class="memdesc:ac3465aeda1eaa9b43827b15090e9d5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the typed output port at index <span class="tt">port_index</span>.  <br /></td></tr>
<tr class="memitem:a09d8b12e579f9f806cdf01b645759aef" id="r_a09d8b12e579f9f806cdf01b645759aef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09d8b12e579f9f806cdf01b645759aef">get_output_port</a> () const</td></tr>
<tr class="memdesc:a09d8b12e579f9f806cdf01b645759aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for the case of exactly one output port.  <br /></td></tr>
<tr class="memitem:a991e02715eef0ca58a3ee6dda24a3395" id="r_a991e02715eef0ca58a3ee6dda24a3395"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a991e02715eef0ca58a3ee6dda24a3395">get_output_port_selection</a> (std::variant&lt; <a class="el" href="namespacedrake_1_1systems.html#a00432489001229d1f63cb6d373403a6e">OutputPortSelection</a>, <a class="el" href="namespacedrake_1_1systems.html#afb427ae7d4f36f7a3cfe34eb5a3d51aa">OutputPortIndex</a> &gt; port_index) const</td></tr>
<tr class="memdesc:a991e02715eef0ca58a3ee6dda24a3395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the typed output port specified by the <a class="el" href="namespacedrake_1_1systems.html#a00432489001229d1f63cb6d373403a6e" title="Intended for use in e.g.">OutputPortSelection</a> or by the <a class="el" href="namespacedrake_1_1systems.html#afb427ae7d4f36f7a3cfe34eb5a3d51aa" title="Serves as the local index for the output ports of a given System.">OutputPortIndex</a>.  <br /></td></tr>
<tr class="memitem:af900e8c1b8e91219a8771c54f1d130ab" id="r_af900e8c1b8e91219a8771c54f1d130ab"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af900e8c1b8e91219a8771c54f1d130ab">GetOutputPort</a> (const std::string &amp;port_name) const</td></tr>
<tr class="memdesc:af900e8c1b8e91219a8771c54f1d130ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the typed output port with the unique name <code class="param">port_name</code>.  <br /></td></tr>
<tr class="memitem:a70946c955bb9100cc8e9dc1f5df5c8bc" id="r_a70946c955bb9100cc8e9dc1f5df5c8bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70946c955bb9100cc8e9dc1f5df5c8bc">HasOutputPort</a> (const std::string &amp;port_name) const</td></tr>
<tr class="memdesc:a70946c955bb9100cc8e9dc1f5df5c8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the system has an <a class="el" href="classdrake_1_1systems_1_1_output_port.html" title="An OutputPort belongs to a System and represents the properties of one of that System&#39;s output ports.">OutputPort</a> of the given <code class="param">port_name</code>.  <br /></td></tr>
<tr class="memitem:a23f1475b0c301d9d78814fce265fd6ea" id="r_a23f1475b0c301d9d78814fce265fd6ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23f1475b0c301d9d78814fce265fd6ea">num_constraints</a> () const</td></tr>
<tr class="memdesc:a23f1475b0c301d9d78814fce265fd6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of constraints specified for the system.  <br /></td></tr>
<tr class="memitem:ac72d50dd5540d7a303b1bb8135df5a80" id="r_ac72d50dd5540d7a303b1bb8135df5a80"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_system_constraint.html">SystemConstraint</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac72d50dd5540d7a303b1bb8135df5a80">get_constraint</a> (<a class="el" href="namespacedrake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a> constraint_index) const</td></tr>
<tr class="memdesc:ac72d50dd5540d7a303b1bb8135df5a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint at index <code class="param">constraint_index</code>.  <br /></td></tr>
<tr class="memitem:a75fef66587073b52e0e69c84a736bd72" id="r_a75fef66587073b52e0e69c84a736bd72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75fef66587073b52e0e69c84a736bd72">CheckSystemConstraintsSatisfied</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, double tol) const</td></tr>
<tr class="memdesc:a75fef66587073b52e0e69c84a736bd72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code class="param">context</code> satisfies all of the registered SystemConstraints with tolerance <code class="param">tol</code>.  <br /></td></tr>
<tr class="memitem:a46b662b8346e6250f8c4340c18658084" id="r_a46b662b8346e6250f8c4340c18658084"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46b662b8346e6250f8c4340c18658084">CopyContinuousStateVector</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a46b662b8346e6250f8c4340c18658084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the continuous state vector x꜀ into an Eigen vector.  <br /></td></tr>
<tr class="memitem:a9714aaf76aca9169da6de7fbcb8339fb" id="r_a9714aaf76aca9169da6de7fbcb8339fb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9714aaf76aca9169da6de7fbcb8339fb">GetMemoryObjectName</a> () const</td></tr>
<tr class="memdesc:a9714aaf76aca9169da6de7fbcb8339fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a name for this System based on a stringification of its type name and memory address.  <br /></td></tr>
<tr class="memitem:a94a6d73c74c7268734792b3703e8600d" id="r_a94a6d73c74c7268734792b3703e8600d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94a6d73c74c7268734792b3703e8600d">num_input_ports</a> () const</td></tr>
<tr class="memdesc:a94a6d73c74c7268734792b3703e8600d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of input ports currently allocated in this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>.  <br /></td></tr>
<tr class="memitem:a7ceec1b22b6b1b25fc675234e78e71be" id="r_a7ceec1b22b6b1b25fc675234e78e71be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ceec1b22b6b1b25fc675234e78e71be">num_output_ports</a> () const</td></tr>
<tr class="memdesc:a7ceec1b22b6b1b25fc675234e78e71be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of output ports currently allocated in this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>.  <br /></td></tr>
<tr id="pub-methods-8" class="groupHeader"><td colspan="2"><div class="groupHeader">Scalar type conversion utilities</div></td></tr>
<tr class="memitem:a601fb2c6cf565d954253d25725ae9d6b" id="r_a601fb2c6cf565d954253d25725ae9d6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a601fb2c6cf565d954253d25725ae9d6b">FixInputPortsFrom</a> (const <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; double &gt; &amp;other_system, const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; double &gt; &amp;other_context, <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *target_context) const</td></tr>
<tr class="memdesc:a601fb2c6cf565d954253d25725ae9d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixes all of the input ports in <code class="param">target_context</code> to their current values in <code class="param">other_context</code>, as evaluated by <code class="param">other_system</code>.  <br /></td></tr>
<tr class="memitem:a4f520e00ddac3d41f7e2df922de46da4" id="r_a4f520e00ddac3d41f7e2df922de46da4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_system_scalar_converter.html">SystemScalarConverter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f520e00ddac3d41f7e2df922de46da4">get_system_scalar_converter</a> () const</td></tr>
<tr class="memdesc:a4f520e00ddac3d41f7e2df922de46da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Returns the <a class="el" href="classdrake_1_1systems_1_1_system_scalar_converter.html" title="Helper class to convert a System into a System&lt;T&gt;, intended for internal use by the System framework,...">SystemScalarConverter</a> for this object.  <br /></td></tr>
<tr id="pub-methods-9" class="groupHeader"><td colspan="2"><div class="groupHeader">Graphviz methods</div></td></tr>
<tr class="memitem:a7af7e8c763be91ade9abe02f16bda206" id="r_a7af7e8c763be91ade9abe02f16bda206"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7af7e8c763be91ade9abe02f16bda206">GetGraphvizString</a> (std::optional&lt; int &gt; max_depth={}, const std::map&lt; std::string, std::string &gt; &amp;options={}) const</td></tr>
<tr class="memdesc:a7af7e8c763be91ade9abe02f16bda206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Graphviz string describing this System.  <br /></td></tr>
<tr class="inherit_header pub_methods_classdrake_1_1systems_1_1_system_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classdrake_1_1systems_1_1_system_base')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Member Functions inherited from <a class="el" href="classdrake_1_1systems_1_1_system_base.html">SystemBase</a></td></tr>
<tr class="memitem:ae7271d3848e9754bee3e07c53614100c inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_ae7271d3848e9754bee3e07c53614100c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ae7271d3848e9754bee3e07c53614100c">~SystemBase</a> () override</td></tr>
<tr class="memitem:ad5260b9627048b854b45d05ed34adc22 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_ad5260b9627048b854b45d05ed34adc22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ad5260b9627048b854b45d05ed34adc22">set_name</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ad5260b9627048b854b45d05ed34adc22 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of the system.  <br /></td></tr>
<tr class="memitem:a28946d25d4b7a62a454a700665874285 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a28946d25d4b7a62a454a700665874285"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a28946d25d4b7a62a454a700665874285">get_name</a> () const</td></tr>
<tr class="memdesc:a28946d25d4b7a62a454a700665874285 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name last supplied to <a class="el" href="classdrake_1_1systems_1_1_system_base.html#ad5260b9627048b854b45d05ed34adc22" title="Sets the name of the system.">set_name()</a>, if any.  <br /></td></tr>
<tr class="memitem:a9714aaf76aca9169da6de7fbcb8339fb inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a9714aaf76aca9169da6de7fbcb8339fb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a9714aaf76aca9169da6de7fbcb8339fb">GetMemoryObjectName</a> () const</td></tr>
<tr class="memdesc:a9714aaf76aca9169da6de7fbcb8339fb inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a name for this System based on a stringification of its type name and memory address.  <br /></td></tr>
<tr class="memitem:a4cc158b94e07fcd1fd577cd20f5a9c72 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a4cc158b94e07fcd1fd577cd20f5a9c72"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a4cc158b94e07fcd1fd577cd20f5a9c72">GetSystemName</a> () const final</td></tr>
<tr class="memdesc:a4cc158b94e07fcd1fd577cd20f5a9c72 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a human-readable name for this system, for use in messages and logging.  <br /></td></tr>
<tr class="memitem:ac8f54385db97ee385847ad7577dbe34e inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_ac8f54385db97ee385847ad7577dbe34e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ac8f54385db97ee385847ad7577dbe34e">GetSystemPathname</a> () const final</td></tr>
<tr class="memdesc:ac8f54385db97ee385847ad7577dbe34e inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns a human-readable full path name of this subsystem, for use in messages and logging.  <br /></td></tr>
<tr class="memitem:a283b89b5f6b6d1745bc590e6050177a9 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a283b89b5f6b6d1745bc590e6050177a9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a283b89b5f6b6d1745bc590e6050177a9">GetSystemType</a> () const final</td></tr>
<tr class="memdesc:a283b89b5f6b6d1745bc590e6050177a9 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the most-derived type of this concrete <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> object as a human-readable string suitable for use in error messages.  <br /></td></tr>
<tr class="memitem:aea45a9d994b55cdb8ae9acf037888c98 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_aea45a9d994b55cdb8ae9acf037888c98"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aea45a9d994b55cdb8ae9acf037888c98">AllocateContext</a> () const</td></tr>
<tr class="memdesc:aea45a9d994b55cdb8ae9acf037888c98 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> suitable for use with this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>.  <br /></td></tr>
<tr class="memitem:a0b7f7189714d79a830e909e281324533 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a0b7f7189714d79a830e909e281324533"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a0b7f7189714d79a830e909e281324533">SystemBase</a> (const SystemBase &amp;)=delete</td></tr>
<tr class="memitem:a6cb6779d23c807189b453351e392b0eb inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a6cb6779d23c807189b453351e392b0eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a0b7f7189714d79a830e909e281324533">SystemBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a6cb6779d23c807189b453351e392b0eb">operator=</a> (const <a class="el" href="classdrake_1_1systems_1_1_system_base.html#a0b7f7189714d79a830e909e281324533">SystemBase</a> &amp;)=delete</td></tr>
<tr class="memitem:a14e502b9bccb8c93c30f872d3eb00e9b inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a14e502b9bccb8c93c30f872d3eb00e9b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a14e502b9bccb8c93c30f872d3eb00e9b">SystemBase</a> (SystemBase &amp;&amp;)=delete</td></tr>
<tr class="memitem:a9c1a291cbd2c29e6fcb14bfc90f32c42 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a9c1a291cbd2c29e6fcb14bfc90f32c42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a0b7f7189714d79a830e909e281324533">SystemBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a9c1a291cbd2c29e6fcb14bfc90f32c42">operator=</a> (<a class="el" href="classdrake_1_1systems_1_1_system_base.html#a0b7f7189714d79a830e909e281324533">SystemBase</a> &amp;&amp;)=delete</td></tr>
<tr class="memitem:a7af7e8c763be91ade9abe02f16bda206 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a7af7e8c763be91ade9abe02f16bda206"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a7af7e8c763be91ade9abe02f16bda206">GetGraphvizString</a> (std::optional&lt; int &gt; max_depth={}, const std::map&lt; std::string, std::string &gt; &amp;options={}) const</td></tr>
<tr class="memdesc:a7af7e8c763be91ade9abe02f16bda206 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Graphviz string describing this System.  <br /></td></tr>
<tr class="memitem:abfd58214195f7fbebfb65a7ef0c84d06 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_abfd58214195f7fbebfb65a7ef0c84d06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1systems_1_1_system_base_1_1_graphviz_fragment.html">GraphvizFragment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#abfd58214195f7fbebfb65a7ef0c84d06">GetGraphvizFragment</a> (std::optional&lt; int &gt; max_depth={}, const std::map&lt; std::string, std::string &gt; &amp;options={}) const</td></tr>
<tr class="memdesc:abfd58214195f7fbebfb65a7ef0c84d06 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Like <a class="el" href="classdrake_1_1systems_1_1_system_base.html#a7af7e8c763be91ade9abe02f16bda206" title="Returns a Graphviz string describing this System.">GetGraphvizString()</a> but does not wrap the string in a <span class="tt">digraph { … }</span>.  <br /></td></tr>
<tr class="memitem:a62ba7c6b62b14b2955bdf40e62e38eef inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a62ba7c6b62b14b2955bdf40e62e38eef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a62ba7c6b62b14b2955bdf40e62e38eef">EvalAbstractInput</a> (const <a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> &amp;context, int port_index) const</td></tr>
<tr class="memdesc:a62ba7c6b62b14b2955bdf40e62e38eef inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the input port with the given <span class="tt">port_index</span> as an <a class="el" href="classdrake_1_1_abstract_value.html" title="A fully type-erased container class.">AbstractValue</a>, which is permitted for ports of any type.  <br /></td></tr>
<tr class="memitem:a057507075ac1337a693e3b83c0e6cac6 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a057507075ac1337a693e3b83c0e6cac6"><td class="memTemplParams" colspan="2">template&lt;typename V&gt; </td></tr>
<tr class="memitem:a057507075ac1337a693e3b83c0e6cac6 inherit pub_methods_classdrake_1_1systems_1_1_system_base template"><td class="memItemLeft" align="right" valign="top">const V *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a057507075ac1337a693e3b83c0e6cac6">EvalInputValue</a> (const <a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> &amp;context, int port_index) const</td></tr>
<tr class="memdesc:a057507075ac1337a693e3b83c0e6cac6 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of an abstract-valued input port with the given <span class="tt">port_index</span> as a value of known type <span class="tt">V</span>.  <br /></td></tr>
<tr class="memitem:a94a6d73c74c7268734792b3703e8600d inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a94a6d73c74c7268734792b3703e8600d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a94a6d73c74c7268734792b3703e8600d">num_input_ports</a> () const</td></tr>
<tr class="memdesc:a94a6d73c74c7268734792b3703e8600d inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of input ports currently allocated in this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>.  <br /></td></tr>
<tr class="memitem:a7ceec1b22b6b1b25fc675234e78e71be inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a7ceec1b22b6b1b25fc675234e78e71be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a7ceec1b22b6b1b25fc675234e78e71be">num_output_ports</a> () const</td></tr>
<tr class="memdesc:a7ceec1b22b6b1b25fc675234e78e71be inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of output ports currently allocated in this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>.  <br /></td></tr>
<tr class="memitem:a3648b9aa60f5efa28351a4c3e304fa46 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a3648b9aa60f5efa28351a4c3e304fa46"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port_base.html">InputPortBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a3648b9aa60f5efa28351a4c3e304fa46">get_input_port_base</a> (<a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> port_index) const</td></tr>
<tr class="memdesc:a3648b9aa60f5efa28351a4c3e304fa46 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to an <a class="el" href="classdrake_1_1systems_1_1_input_port.html" title="An InputPort is a System resource that describes the kind of input a System accepts,...">InputPort</a> given its <span class="tt">port_index</span>.  <br /></td></tr>
<tr class="memitem:a6f53ee12019051510940db4a0b8bdd76 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a6f53ee12019051510940db4a0b8bdd76"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port_base.html">OutputPortBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a6f53ee12019051510940db4a0b8bdd76">get_output_port_base</a> (<a class="el" href="namespacedrake_1_1systems.html#afb427ae7d4f36f7a3cfe34eb5a3d51aa">OutputPortIndex</a> port_index) const</td></tr>
<tr class="memdesc:a6f53ee12019051510940db4a0b8bdd76 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to an <a class="el" href="classdrake_1_1systems_1_1_output_port.html" title="An OutputPort belongs to a System and represents the properties of one of that System&#39;s output ports.">OutputPort</a> given its <span class="tt">port_index</span>.  <br /></td></tr>
<tr class="memitem:a61fbc5b339d9006ff53e39b8df10c611 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a61fbc5b339d9006ff53e39b8df10c611"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a61fbc5b339d9006ff53e39b8df10c611">num_total_inputs</a> () const</td></tr>
<tr class="memdesc:a61fbc5b339d9006ff53e39b8df10c611 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total dimension of all of the vector-valued input ports (as if they were muxed).  <br /></td></tr>
<tr class="memitem:ae1394e3cf29023475b4983cb4ad16e86 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_ae1394e3cf29023475b4983cb4ad16e86"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ae1394e3cf29023475b4983cb4ad16e86">num_total_outputs</a> () const</td></tr>
<tr class="memdesc:ae1394e3cf29023475b4983cb4ad16e86 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total dimension of all of the vector-valued output ports (as if they were muxed).  <br /></td></tr>
<tr class="memitem:a87a98a257dc03eb749975de05778dbc8 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a87a98a257dc03eb749975de05778dbc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a87a98a257dc03eb749975de05778dbc8">num_cache_entries</a> () const</td></tr>
<tr class="memdesc:a87a98a257dc03eb749975de05778dbc8 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number nc of cache entries currently allocated in this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>.  <br /></td></tr>
<tr class="memitem:a9862034f2949ceee61cb29015fc32c3d inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a9862034f2949ceee61cb29015fc32c3d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a9862034f2949ceee61cb29015fc32c3d">get_cache_entry</a> (<a class="el" href="namespacedrake_1_1systems.html#a06ac9ad764b14ccff79b6feb393be498">CacheIndex</a> index) const</td></tr>
<tr class="memdesc:a9862034f2949ceee61cb29015fc32c3d inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to a <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html" title="A CacheEntry belongs to a System and represents the properties of one of that System&#39;s cached computa...">CacheEntry</a> given its <span class="tt">index</span>.  <br /></td></tr>
<tr class="memitem:a4b3c6e033fa772534a71055393d9bac3 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a4b3c6e033fa772534a71055393d9bac3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a4b3c6e033fa772534a71055393d9bac3">get_mutable_cache_entry</a> (<a class="el" href="namespacedrake_1_1systems.html#a06ac9ad764b14ccff79b6feb393be498">CacheIndex</a> index)</td></tr>
<tr class="memdesc:a4b3c6e033fa772534a71055393d9bac3 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Returns a mutable reference to a <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html" title="A CacheEntry belongs to a System and represents the properties of one of that System&#39;s cached computa...">CacheEntry</a> given its <span class="tt">index</span>.  <br /></td></tr>
<tr class="memitem:adf86073429b07d388b0157956bfdbac6 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_adf86073429b07d388b0157956bfdbac6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#adf86073429b07d388b0157956bfdbac6">discrete_state_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#acf2a50397e9fa764d32553cf98460ba7">DiscreteStateIndex</a> index) const</td></tr>
<tr class="memdesc:adf86073429b07d388b0157956bfdbac6 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on a particular discrete state variable xdᵢ (may be a vector).  <br /></td></tr>
<tr class="memitem:a4a8d4f32034a610ea30a283699040708 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a4a8d4f32034a610ea30a283699040708"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a4a8d4f32034a610ea30a283699040708">abstract_state_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#a8c3a27f43e356726f770159944adb929">AbstractStateIndex</a> index) const</td></tr>
<tr class="memdesc:a4a8d4f32034a610ea30a283699040708 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on a particular abstract state variable xaᵢ.  <br /></td></tr>
<tr class="memitem:a45e0bf1fd3096bff3df2587ec4f02285 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a45e0bf1fd3096bff3df2587ec4f02285"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a45e0bf1fd3096bff3df2587ec4f02285">numeric_parameter_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#af11369a06c5bfd3fa18acb79f85777df">NumericParameterIndex</a> index) const</td></tr>
<tr class="memdesc:a45e0bf1fd3096bff3df2587ec4f02285 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on a particular numeric parameter pnᵢ (may be a vector).  <br /></td></tr>
<tr class="memitem:a1a4ef0e0e633c6f722ee518308d7cb5a inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a1a4ef0e0e633c6f722ee518308d7cb5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a1a4ef0e0e633c6f722ee518308d7cb5a">abstract_parameter_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#a86b350169906f6d5e07e9db46e36d57a">AbstractParameterIndex</a> index) const</td></tr>
<tr class="memdesc:a1a4ef0e0e633c6f722ee518308d7cb5a inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on a particular abstract parameter paᵢ.  <br /></td></tr>
<tr class="memitem:a191b7cb5dcbfee51a62fa042ec14561f inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a191b7cb5dcbfee51a62fa042ec14561f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a191b7cb5dcbfee51a62fa042ec14561f">input_port_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> index) const</td></tr>
<tr class="memdesc:a191b7cb5dcbfee51a62fa042ec14561f inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on input port uᵢ indicated by <span class="tt">index</span>.  <br /></td></tr>
<tr class="memitem:a7e92c6f01c04b3591d642d27a467b093 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a7e92c6f01c04b3591d642d27a467b093"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a7e92c6f01c04b3591d642d27a467b093">cache_entry_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#a06ac9ad764b14ccff79b6feb393be498">CacheIndex</a> index) const</td></tr>
<tr class="memdesc:a7e92c6f01c04b3591d642d27a467b093 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on the cache entry indicated by <span class="tt">index</span>.  <br /></td></tr>
<tr class="memitem:a7c95876fd161fda4fb4fb7d51bec2a81 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a7c95876fd161fda4fb4fb7d51bec2a81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a7c95876fd161fda4fb4fb7d51bec2a81">output_port_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#afb427ae7d4f36f7a3cfe34eb5a3d51aa">OutputPortIndex</a> index) const</td></tr>
<tr class="memdesc:a7c95876fd161fda4fb4fb7d51bec2a81 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns a ticket indicating dependence on the output port indicated by <span class="tt">index</span>.  <br /></td></tr>
<tr class="memitem:aa568c26e18ea55bb339893881cff3e73 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_aa568c26e18ea55bb339893881cff3e73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aa568c26e18ea55bb339893881cff3e73">num_continuous_states</a> () const</td></tr>
<tr class="memdesc:aa568c26e18ea55bb339893881cff3e73 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of declared continuous state variables.  <br /></td></tr>
<tr class="memitem:a1a03d2d5e70020145bd659eba780f967 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a1a03d2d5e70020145bd659eba780f967"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a1a03d2d5e70020145bd659eba780f967">num_discrete_state_groups</a> () const</td></tr>
<tr class="memdesc:a1a03d2d5e70020145bd659eba780f967 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of declared discrete state groups (each group is a vector-valued discrete state variable).  <br /></td></tr>
<tr class="memitem:ad2c71c7988b370b4e93ea1c33a2a0e9b inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_ad2c71c7988b370b4e93ea1c33a2a0e9b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ad2c71c7988b370b4e93ea1c33a2a0e9b">num_abstract_states</a> () const</td></tr>
<tr class="memdesc:ad2c71c7988b370b4e93ea1c33a2a0e9b inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of declared abstract state variables.  <br /></td></tr>
<tr class="memitem:aff6508ca0ff8f5e886e63fb9c830e36a inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_aff6508ca0ff8f5e886e63fb9c830e36a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aff6508ca0ff8f5e886e63fb9c830e36a">num_numeric_parameter_groups</a> () const</td></tr>
<tr class="memdesc:aff6508ca0ff8f5e886e63fb9c830e36a inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of declared numeric parameters (each of these is a vector-valued parameter).  <br /></td></tr>
<tr class="memitem:a0232523ac7f8337a392b321ffd282187 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a0232523ac7f8337a392b321ffd282187"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a0232523ac7f8337a392b321ffd282187">num_abstract_parameters</a> () const</td></tr>
<tr class="memdesc:a0232523ac7f8337a392b321ffd282187 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of declared abstract parameters.  <br /></td></tr>
<tr class="memitem:aba0bd9017cbe1fbf0f02912f0d45fd10 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_aba0bd9017cbe1fbf0f02912f0d45fd10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aba0bd9017cbe1fbf0f02912f0d45fd10">implicit_time_derivatives_residual_size</a> () const</td></tr>
<tr class="memdesc:aba0bd9017cbe1fbf0f02912f0d45fd10 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the implicit time derivatives residual vector.  <br /></td></tr>
<tr class="memitem:a7622a0fb573704de7505804d57e66a79 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a7622a0fb573704de7505804d57e66a79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a7622a0fb573704de7505804d57e66a79">ValidateContext</a> (const <a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> &amp;context) const final</td></tr>
<tr class="memdesc:a7622a0fb573704de7505804d57e66a79 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the given context was created for this system.  <br /></td></tr>
<tr class="memitem:a4eded72dc7f57febf1d8c171426d81de inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_a4eded72dc7f57febf1d8c171426d81de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a4eded72dc7f57febf1d8c171426d81de">ValidateContext</a> (const <a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> *context) const</td></tr>
<tr class="memdesc:a4eded72dc7f57febf1d8c171426d81de inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the given context was created for this system.  <br /></td></tr>
<tr class="memitem:aa4fd1fc18c838f00d24942d8afcd26e4 inherit pub_methods_classdrake_1_1systems_1_1_system_base" id="r_aa4fd1fc18c838f00d24942d8afcd26e4"><td class="memTemplParams" colspan="2">template&lt;class Clazz&gt; </td></tr>
<tr class="memitem:aa4fd1fc18c838f00d24942d8afcd26e4 inherit pub_methods_classdrake_1_1systems_1_1_system_base template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aa4fd1fc18c838f00d24942d8afcd26e4">ValidateCreatedForThisSystem</a> (const Clazz &amp;object) const</td></tr>
<tr class="memdesc:aa4fd1fc18c838f00d24942d8afcd26e4 inherit pub_methods_classdrake_1_1systems_1_1_system_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the given object was created for this system.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-methods" class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr id="pro-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">(Internal use only) Event handler dispatch mechanism</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>The pure virtuals declared here are intended to be implemented only by Drake's <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a> and <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> (plus a few unit tests) and those implementations must be <span class="tt">final</span>.</p>
<p>For a <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>, these functions need to call each event's handler callback, For a <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>, the pseudo code of the complete default publish event handler dispatching is roughly: </p><pre>
  leaf_sys.Publish(context, event_collection)
  -&gt; leaf_sys.DispatchPublishHandler(context, event_collection)
      for (event : event_collection_events):
        if (event.has_handler)
          event.handler(context)
</pre><p> Discrete update events and unrestricted update events are dispatched similarly for a <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a>. <a class="el" href="classdrake_1_1systems_1_1_event_status.html" title="Holds the return status from execution of an event handler function, or the effective status after a ...">EventStatus</a> is propagated upwards from the individual event handlers with the first worst retained.</p>
<p>For a <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a>, these functions must iterate through all subsystems, extract their corresponding subcontext and subevent collections from <span class="tt">context</span> and <span class="tt">events</span>, and pass those to the subsystems' public non-virtual event dispatchers if the subevent collection is nonempty (e.g. <a class="el" href="#a432d732019c64ca4a869b35d4d63bb3d" title="This method is the public entry point for dispatching all publish event handlers.">System::Publish()</a> for publish events).</p>
<p>All of these functions are only called from their corresponding public non-virtual event dispatchers, where <span class="tt">context</span> is error checked. The derived implementations can assume that <span class="tt">context</span> is valid. See, e.g., LeafSystem::DispatchPublishHandler() and Diagram::DispatchPublishHandler() for more details. </p>
</div></td></tr>
<tr class="memitem:a2c5d5ccabe4f4b0eec04d62d407737d7" id="r_a2c5d5ccabe4f4b0eec04d62d407737d7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrake_1_1systems_1_1_event_status.html">EventStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c5d5ccabe4f4b0eec04d62d407737d7">DispatchPublishHandler</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt; &gt; &amp;events) const =0</td></tr>
<tr class="memdesc:a2c5d5ccabe4f4b0eec04d62d407737d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) This function dispatches all publish events to the appropriate handlers.  <br /></td></tr>
<tr class="memitem:ac9457822be4fc7aabaef0beb95b4264a" id="r_ac9457822be4fc7aabaef0beb95b4264a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrake_1_1systems_1_1_event_status.html">EventStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9457822be4fc7aabaef0beb95b4264a">DispatchDiscreteVariableUpdateHandler</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &gt; &amp;events, <a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *discrete_state) const =0</td></tr>
<tr class="memdesc:ac9457822be4fc7aabaef0beb95b4264a"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) This function dispatches all discrete update events to the appropriate handlers.  <br /></td></tr>
<tr class="memitem:ab104dfba98dd39ff4a7dd6ab5e178c8a" id="r_ab104dfba98dd39ff4a7dd6ab5e178c8a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab104dfba98dd39ff4a7dd6ab5e178c8a">DoApplyDiscreteVariableUpdate</a> (const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &gt; &amp;events, <a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *discrete_state, <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context) const =0</td></tr>
<tr class="memdesc:ab104dfba98dd39ff4a7dd6ab5e178c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Updates the given <span class="tt">context</span> with the results returned from a previous call to <a class="el" href="#ac9457822be4fc7aabaef0beb95b4264a" title="(Internal use only) This function dispatches all discrete update events to the appropriate handlers.">DispatchDiscreteVariableUpdateHandler()</a> that handled the given <span class="tt">events</span>.  <br /></td></tr>
<tr class="memitem:a28700b2d1c21cd7956f9a68fd3f1fd2e" id="r_a28700b2d1c21cd7956f9a68fd3f1fd2e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrake_1_1systems_1_1_event_status.html">EventStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28700b2d1c21cd7956f9a68fd3f1fd2e">DispatchUnrestrictedUpdateHandler</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; &gt; &amp;events, <a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *state) const =0</td></tr>
<tr class="memdesc:a28700b2d1c21cd7956f9a68fd3f1fd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) This function dispatches all unrestricted update events to the appropriate handlers.  <br /></td></tr>
<tr class="memitem:acc5802cd006ea71b0c68d4b48a1736e7" id="r_acc5802cd006ea71b0c68d4b48a1736e7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc5802cd006ea71b0c68d4b48a1736e7">DoApplyUnrestrictedUpdate</a> (const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; &gt; &amp;events, <a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *state, <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *context) const =0</td></tr>
<tr class="memdesc:acc5802cd006ea71b0c68d4b48a1736e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Updates the given <span class="tt">context</span> with the results returned from a previous call to <a class="el" href="#a28700b2d1c21cd7956f9a68fd3f1fd2e" title="(Internal use only) This function dispatches all unrestricted update events to the appropriate handle...">DispatchUnrestrictedUpdateHandler()</a> that handled the given <span class="tt">events</span>.  <br /></td></tr>
<tr id="pro-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">System construction</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>Authors of derived Systems can use these methods in the constructor for those Systems. </p>
</div></td></tr>
<tr class="memitem:aa1b849c60d9ec6bbfeac42dc3c075a02" id="r_aa1b849c60d9ec6bbfeac42dc3c075a02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1b849c60d9ec6bbfeac42dc3c075a02">System</a> (<a class="el" href="classdrake_1_1systems_1_1_system_scalar_converter.html">SystemScalarConverter</a> converter)</td></tr>
<tr class="memdesc:aa1b849c60d9ec6bbfeac42dc3c075a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty System base class object and allocates base class resources, possibly supporting scalar-type conversion support (AutoDiff, etc.) using <code class="param">converter</code>.  <br /></td></tr>
<tr class="memitem:af0b57e4cacf2beba4ef87c87f824aba8" id="r_af0b57e4cacf2beba4ef87c87f824aba8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0b57e4cacf2beba4ef87c87f824aba8">DeclareInputPort</a> (std::variant&lt; std::string, <a class="el" href="structdrake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; name, <a class="el" href="namespacedrake_1_1systems.html#ae516fceb67f15f61c7a232b9cc483fbe">PortDataType</a> type, int size, std::optional&lt; <a class="el" href="namespacedrake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a> &gt; random_type=std::nullopt)</td></tr>
<tr class="memdesc:af0b57e4cacf2beba4ef87c87f824aba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a port with the specified <code class="param">type</code> and <code class="param">size</code> to the input topology.  <br /></td></tr>
<tr class="memitem:a1da97485fe927a5d199634ee0643456b" id="r_a1da97485fe927a5d199634ee0643456b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1da97485fe927a5d199634ee0643456b">AddConstraint</a> (std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_system_constraint.html">SystemConstraint</a>&lt; T &gt; &gt; constraint)</td></tr>
<tr class="memdesc:a1da97485fe927a5d199634ee0643456b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an already-created constraint to the list of constraints for this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>.  <br /></td></tr>
<tr id="pro-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Virtual methods for calculations</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>These virtuals allow concrete systems to implement the calculations defined by the <span class="tt">Calc</span> methods in the public interface.</p>
<p>Most have default implementations that are usable for simple systems, but you are likely to need to override some or all of these in your concrete system to produce meaningful calculations.</p>
<p>These methods are invoked by the corresponding method in the public interface that has the same name with <span class="tt">Do</span> removed. The public method performs error checking on the arguments so you do not need to do so in your implementation. Users cannot invoke these directly since they are protected. You should place your overrides in the protected or private sections of your concrete class. </p>
</div></td></tr>
<tr class="memitem:a2d2b6bbca36ba86a269c9fd42ddfb6d0" id="r_a2d2b6bbca36ba86a269c9fd42ddfb6d0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d2b6bbca36ba86a269c9fd42ddfb6d0">DoCalcTimeDerivatives</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; *derivatives) const</td></tr>
<tr class="memdesc:a2d2b6bbca36ba86a269c9fd42ddfb6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this if you have any continuous state variables x꜀ in your concrete System to calculate their time derivatives.  <br /></td></tr>
<tr class="memitem:a1612bbeeab77dfe57f08df56b7869a68" id="r_a1612bbeeab77dfe57f08df56b7869a68"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1612bbeeab77dfe57f08df56b7869a68">DoCalcImplicitTimeDerivativesResidual</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &amp;proposed_derivatives, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; residual) const</td></tr>
<tr class="memdesc:a1612bbeeab77dfe57f08df56b7869a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this if you have an efficient way to evaluate the implicit time derivatives residual for this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>.  <br /></td></tr>
<tr class="memitem:afdc9aebb6327099391cd0f621b4b8d44" id="r_afdc9aebb6327099391cd0f621b4b8d44"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdc9aebb6327099391cd0f621b4b8d44">DoCalcNextUpdateTime</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events, T *time) const</td></tr>
<tr class="memdesc:afdc9aebb6327099391cd0f621b4b8d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the next time at which this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> must perform a discrete action.  <br /></td></tr>
<tr class="memitem:a9ab8eeda0691dddf88db4c45618a0303" id="r_a9ab8eeda0691dddf88db4c45618a0303"><td class="memItemLeft" align="right" valign="top">virtual std::map&lt; <a class="el" href="classdrake_1_1systems_1_1_periodic_event_data.html">PeriodicEventData</a>, std::vector&lt; const <a class="el" href="classdrake_1_1systems_1_1_event.html">Event</a>&lt; T &gt; * &gt;, <a class="el" href="structdrake_1_1systems_1_1_periodic_event_data_comparator.html">PeriodicEventDataComparator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ab8eeda0691dddf88db4c45618a0303">DoMapPeriodicEventsByTiming</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const =0</td></tr>
<tr class="memdesc:a9ab8eeda0691dddf88db4c45618a0303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this method to return all periodic triggered events organized by timing.  <br /></td></tr>
<tr class="memitem:adc8a45777136aa90b4390b611efc4d36" id="r_adc8a45777136aa90b4390b611efc4d36"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc8a45777136aa90b4390b611efc4d36">DoGetPeriodicEvents</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events) const</td></tr>
<tr class="memdesc:adc8a45777136aa90b4390b611efc4d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this method to return any periodic events.  <br /></td></tr>
<tr class="memitem:aaa8100d7c746acc72a3a86fe8cad9d7c" id="r_aaa8100d7c746acc72a3a86fe8cad9d7c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa8100d7c746acc72a3a86fe8cad9d7c">DoGetPerStepEvents</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events) const</td></tr>
<tr class="memdesc:aaa8100d7c746acc72a3a86fe8cad9d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this method to return any events to be handled before the simulator integrates the system's continuous state at each time step.  <br /></td></tr>
<tr class="memitem:a0a38740aa5d71df2a0bab769c29fff7c" id="r_a0a38740aa5d71df2a0bab769c29fff7c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a38740aa5d71df2a0bab769c29fff7c">DoGetInitializationEvents</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events) const</td></tr>
<tr class="memdesc:a0a38740aa5d71df2a0bab769c29fff7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this method to return any events to be handled at the simulator's initialization step.  <br /></td></tr>
<tr class="memitem:a40f055c2fb422eefe50faf9a0979c1e0" id="r_a40f055c2fb422eefe50faf9a0979c1e0"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40f055c2fb422eefe50faf9a0979c1e0">DoCalcPotentialEnergy</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a40f055c2fb422eefe50faf9a0979c1e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this method for physical systems to calculate the potential energy PE currently stored in the configuration provided in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <br /></td></tr>
<tr class="memitem:a8de30438c7fbda84a0cc9a35ca543c8e" id="r_a8de30438c7fbda84a0cc9a35ca543c8e"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8de30438c7fbda84a0cc9a35ca543c8e">DoCalcKineticEnergy</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a8de30438c7fbda84a0cc9a35ca543c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this method for physical systems to calculate the kinetic energy KE currently present in the motion provided in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <br /></td></tr>
<tr class="memitem:aafa6ce88c0e7ba9f6592713d36bc4047" id="r_aafa6ce88c0e7ba9f6592713d36bc4047"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafa6ce88c0e7ba9f6592713d36bc4047">DoCalcConservativePower</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aafa6ce88c0e7ba9f6592713d36bc4047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this method to return the rate Pc at which mechanical energy is being converted <em>from</em> potential energy <em>to</em> kinetic energy by this system in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <br /></td></tr>
<tr class="memitem:a3bc39e42fbb88d08592d2f7e7c12637d" id="r_a3bc39e42fbb88d08592d2f7e7c12637d"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bc39e42fbb88d08592d2f7e7c12637d">DoCalcNonConservativePower</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a3bc39e42fbb88d08592d2f7e7c12637d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this method to return the rate Pnc at which work W is done on the system by non-conservative forces.  <br /></td></tr>
<tr class="memitem:af11d9e638906b337b149babc5d65d4c1" id="r_af11d9e638906b337b149babc5d65d4c1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af11d9e638906b337b149babc5d65d4c1">DoMapQDotToVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;qdot, <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *generalized_velocity) const</td></tr>
<tr class="memdesc:af11d9e638906b337b149babc5d65d4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the substantive implementation of <a class="el" href="#a10eba167739bfe8e7e419b5c8ae41537" title="Transforms the time derivative qdot of the generalized configuration q to generalized velocities v.">MapQDotToVelocity()</a>.  <br /></td></tr>
<tr class="memitem:a4b3dda5682eaa8cadbcc7137661ed3a3" id="r_a4b3dda5682eaa8cadbcc7137661ed3a3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b3dda5682eaa8cadbcc7137661ed3a3">DoMapVelocityToQDot</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;generalized_velocity, <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *qdot) const</td></tr>
<tr class="memdesc:a4b3dda5682eaa8cadbcc7137661ed3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the substantive implementation of <a class="el" href="#a05cc5df6d0d0fe4ea54b522ae776ca39" title="Transforms a given generalized velocity v to the time derivative qdot of the generalized configuratio...">MapVelocityToQDot()</a>.  <br /></td></tr>
<tr class="memitem:a1cd0ce5bd76208e8110ad85a956e3127" id="r_a1cd0ce5bd76208e8110ad85a956e3127"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a1cd0ce5bd76208e8110ad85a956e3127">SystemBase</a> ()=default</td></tr>
<tr class="memdesc:a1cd0ce5bd76208e8110ad85a956e3127"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only).  <br /></td></tr>
<tr class="memitem:a1a97898d5e2f921cdb729f02a3c88074" id="r_a1a97898d5e2f921cdb729f02a3c88074"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a1a97898d5e2f921cdb729f02a3c88074">DeclareCacheEntry</a> (std::string description, <a class="el" href="classdrake_1_1systems_1_1_value_producer.html">ValueProducer</a> value_producer, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:a1a97898d5e2f921cdb729f02a3c88074"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="DeclareCacheEntry_primary"></a> <br /></td></tr>
<tr class="memitem:a4076a7594095a9ca6936dd70c7254f84" id="r_a4076a7594095a9ca6936dd70c7254f84"><td class="memTemplParams" colspan="2">template&lt;class MySystem, class MyContext, typename ValueType&gt; </td></tr>
<tr class="memitem:a4076a7594095a9ca6936dd70c7254f84 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a4076a7594095a9ca6936dd70c7254f84">DeclareCacheEntry</a> (std::string description, const ValueType &amp;model_value, void(MySystem::*calc)(const MyContext &amp;, ValueType *) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:a4076a7594095a9ca6936dd70c7254f84"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="DeclareCacheEntry_model_and_calc"></a> <br /></td></tr>
<tr class="memitem:a7d078e4f799ae50f07ae35389352835f" id="r_a7d078e4f799ae50f07ae35389352835f"><td class="memTemplParams" colspan="2">template&lt;class MySystem, class MyContext, typename ValueType&gt; </td></tr>
<tr class="memitem:a7d078e4f799ae50f07ae35389352835f template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a7d078e4f799ae50f07ae35389352835f">DeclareCacheEntry</a> (std::string description, void(MySystem::*calc)(const MyContext &amp;, ValueType *) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:a7d078e4f799ae50f07ae35389352835f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="DeclareCacheEntry_calc_only"></a> <br /></td></tr>
<tr class="memitem:ab83ce091f3aba8ecb71e72262fc1fd6b" id="r_ab83ce091f3aba8ecb71e72262fc1fd6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ab83ce091f3aba8ecb71e72262fc1fd6b">AddInputPort</a> (std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_input_port_base.html">InputPortBase</a> &gt; port)</td></tr>
<tr class="memdesc:ab83ce091f3aba8ecb71e72262fc1fd6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Adds an already-constructed input port to this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>.  <br /></td></tr>
<tr class="memitem:a89be3ba9e76827e83fb1e139e5b750cc" id="r_a89be3ba9e76827e83fb1e139e5b750cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a89be3ba9e76827e83fb1e139e5b750cc">AddOutputPort</a> (std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_output_port_base.html">OutputPortBase</a> &gt; port)</td></tr>
<tr class="memdesc:a89be3ba9e76827e83fb1e139e5b750cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Adds an already-constructed output port to this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>.  <br /></td></tr>
<tr class="memitem:a9fd030b5ac189d066b7c8725b65d550c" id="r_a9fd030b5ac189d066b7c8725b65d550c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a9fd030b5ac189d066b7c8725b65d550c">NextInputPortName</a> (std::variant&lt; std::string, <a class="el" href="structdrake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; given_name) const</td></tr>
<tr class="memdesc:a9fd030b5ac189d066b7c8725b65d550c"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns a name for the next input port, using the given name if it isn't kUseDefaultName, otherwise making up a name like "u3" from the next available input port index.  <br /></td></tr>
<tr class="memitem:ac0bf41c62cddfdf3d006ce88e3768b3d" id="r_ac0bf41c62cddfdf3d006ce88e3768b3d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ac0bf41c62cddfdf3d006ce88e3768b3d">NextOutputPortName</a> (std::variant&lt; std::string, <a class="el" href="structdrake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt; given_name) const</td></tr>
<tr class="memdesc:ac0bf41c62cddfdf3d006ce88e3768b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns a name for the next output port, using the given name if it isn't kUseDefaultName, otherwise making up a name like "y3" from the next available output port index.  <br /></td></tr>
<tr class="memitem:ab4e83668b3fecff021600eff4390cc2a" id="r_ab4e83668b3fecff021600eff4390cc2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ab4e83668b3fecff021600eff4390cc2a">AddDiscreteStateGroup</a> (<a class="el" href="namespacedrake_1_1systems.html#acf2a50397e9fa764d32553cf98460ba7">DiscreteStateIndex</a> index)</td></tr>
<tr class="memdesc:ab4e83668b3fecff021600eff4390cc2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Assigns a ticket to a new discrete variable group with the given <span class="tt">index</span>.  <br /></td></tr>
<tr class="memitem:af329e5c00e271bc61a65b0227d34c76e" id="r_af329e5c00e271bc61a65b0227d34c76e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#af329e5c00e271bc61a65b0227d34c76e">AddAbstractState</a> (<a class="el" href="namespacedrake_1_1systems.html#a8c3a27f43e356726f770159944adb929">AbstractStateIndex</a> index)</td></tr>
<tr class="memdesc:af329e5c00e271bc61a65b0227d34c76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Assigns a ticket to a new abstract state variable with the given <span class="tt">index</span>.  <br /></td></tr>
<tr class="memitem:a794ca537e26044e254cda9ccba0a6385" id="r_a794ca537e26044e254cda9ccba0a6385"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a794ca537e26044e254cda9ccba0a6385">AddNumericParameter</a> (<a class="el" href="namespacedrake_1_1systems.html#af11369a06c5bfd3fa18acb79f85777df">NumericParameterIndex</a> index)</td></tr>
<tr class="memdesc:a794ca537e26044e254cda9ccba0a6385"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Assigns a ticket to a new numeric parameter with the given <span class="tt">index</span>.  <br /></td></tr>
<tr class="memitem:accca12932eb38b764d93ab6bed8f02fc" id="r_accca12932eb38b764d93ab6bed8f02fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#accca12932eb38b764d93ab6bed8f02fc">AddAbstractParameter</a> (<a class="el" href="namespacedrake_1_1systems.html#a86b350169906f6d5e07e9db46e36d57a">AbstractParameterIndex</a> index)</td></tr>
<tr class="memdesc:accca12932eb38b764d93ab6bed8f02fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Assigns a ticket to a new abstract parameter with the given <span class="tt">index</span>.  <br /></td></tr>
<tr class="memitem:a47fc57338deed2fa61c0bdf4fcb35389" id="r_a47fc57338deed2fa61c0bdf4fcb35389"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a47fc57338deed2fa61c0bdf4fcb35389">DeclareCacheEntryWithKnownTicket</a> (<a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> known_ticket, std::string description, <a class="el" href="classdrake_1_1systems_1_1_value_producer.html">ValueProducer</a> value_producer, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:a47fc57338deed2fa61c0bdf4fcb35389"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) This is for cache entries associated with pre-defined tickets, for example the cache entry for time derivatives.  <br /></td></tr>
<tr class="memitem:ac2097c5ded1166b6b04cf1260151508f" id="r_ac2097c5ded1166b6b04cf1260151508f"><td class="memItemLeft" align="right" valign="top">const internal::SystemParentServiceInterface *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ac2097c5ded1166b6b04cf1260151508f">get_parent_service</a> () const</td></tr>
<tr class="memdesc:ac2097c5ded1166b6b04cf1260151508f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the service interface of the immediately enclosing <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> if one has been set, otherwise nullptr.  <br /></td></tr>
<tr class="memitem:a161f7073ea98c0a25ca55f5dd4186dca" id="r_a161f7073ea98c0a25ca55f5dd4186dca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a161f7073ea98c0a25ca55f5dd4186dca">assign_next_dependency_ticket</a> ()</td></tr>
<tr class="memdesc:a161f7073ea98c0a25ca55f5dd4186dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Assigns the next unused dependency ticket number, unique only within a particular system.  <br /></td></tr>
<tr class="memitem:ae0773c5cc1799bd669111705a476b052" id="r_ae0773c5cc1799bd669111705a476b052"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ae0773c5cc1799bd669111705a476b052">IsObviouslyNotInputDependent</a> (<a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> dependency_ticket) const</td></tr>
<tr class="memdesc:ae0773c5cc1799bd669111705a476b052"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Checks if a ticket depends on (any) input port.  <br /></td></tr>
<tr class="memitem:a4f89d878ae72c67da5af5acb06f48a22" id="r_a4f89d878ae72c67da5af5acb06f48a22"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a4f89d878ae72c67da5af5acb06f48a22">EvalAbstractInputImpl</a> (const char *func, const <a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> &amp;context, <a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> port_index) const</td></tr>
<tr class="memdesc:a4f89d878ae72c67da5af5acb06f48a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Shared code for updating an input port and returning a pointer to its abstract value, or nullptr if the port is not connected.  <br /></td></tr>
<tr class="memitem:aa640b3592c2af42c76fac2d8a048d25c" id="r_aa640b3592c2af42c76fac2d8a048d25c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aa640b3592c2af42c76fac2d8a048d25c">ThrowNegativePortIndex</a> (const char *func, int port_index) const</td></tr>
<tr class="memdesc:aa640b3592c2af42c76fac2d8a048d25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws std::exception to report a negative <span class="tt">port_index</span> that was passed to API method <span class="tt">func</span>.  <br /></td></tr>
<tr class="memitem:a9295e809fe1cff333430e1b00a84520c" id="r_a9295e809fe1cff333430e1b00a84520c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a9295e809fe1cff333430e1b00a84520c">ThrowInputPortIndexOutOfRange</a> (const char *func, <a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> port_index) const</td></tr>
<tr class="memdesc:a9295e809fe1cff333430e1b00a84520c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws std::exception to report bad input <span class="tt">port_index</span> that was passed to API method <span class="tt">func</span>.  <br /></td></tr>
<tr class="memitem:af58594b987a3e5b1684d4e38bf00767e" id="r_af58594b987a3e5b1684d4e38bf00767e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#af58594b987a3e5b1684d4e38bf00767e">ThrowOutputPortIndexOutOfRange</a> (const char *func, <a class="el" href="namespacedrake_1_1systems.html#afb427ae7d4f36f7a3cfe34eb5a3d51aa">OutputPortIndex</a> port_index) const</td></tr>
<tr class="memdesc:af58594b987a3e5b1684d4e38bf00767e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws std::exception to report bad output <span class="tt">port_index</span> that was passed to API method <span class="tt">func</span>.  <br /></td></tr>
<tr class="memitem:aee2dfff6a2db34da2c791a7971e2af0c" id="r_aee2dfff6a2db34da2c791a7971e2af0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aee2dfff6a2db34da2c791a7971e2af0c">ThrowNotAVectorInputPort</a> (const char *func, <a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> port_index) const</td></tr>
<tr class="memdesc:aee2dfff6a2db34da2c791a7971e2af0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws std::exception because someone misused API method <span class="tt">func</span>, that is only allowed for declared-vector input ports, on an abstract port whose index is given here.  <br /></td></tr>
<tr class="memitem:a2200e7d8b6b39e758e5df64ee81c356a" id="r_a2200e7d8b6b39e758e5df64ee81c356a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a2200e7d8b6b39e758e5df64ee81c356a">ThrowInputPortHasWrongType</a> (const char *func, <a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> port_index, const std::string &amp;expected_type, const std::string &amp;actual_type) const</td></tr>
<tr class="memdesc:a2200e7d8b6b39e758e5df64ee81c356a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws std::exception because someone called API method <span class="tt">func</span> claiming the input port had some value type that was wrong.  <br /></td></tr>
<tr class="memitem:a49bc2d35e014b293b9564cb9e85e5390" id="r_a49bc2d35e014b293b9564cb9e85e5390"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a49bc2d35e014b293b9564cb9e85e5390">ThrowCantEvaluateInputPort</a> (const char *func, <a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> port_index) const</td></tr>
<tr class="memdesc:a49bc2d35e014b293b9564cb9e85e5390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws std::exception because someone called API method <span class="tt">func</span>, that requires this input port to be evaluatable, but the port was neither fixed nor connected.  <br /></td></tr>
<tr class="memitem:a6653b06cef5a262a38767bd07bfc7723" id="r_a6653b06cef5a262a38767bd07bfc7723"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port_base.html">InputPortBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a6653b06cef5a262a38767bd07bfc7723">GetInputPortBaseOrThrow</a> (const char *func, int port_index, bool warn_deprecated) const</td></tr>
<tr class="memdesc:a6653b06cef5a262a38767bd07bfc7723"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns the <a class="el" href="classdrake_1_1systems_1_1_input_port_base.html" title="An InputPort is a System resource that describes the kind of input a System accepts,...">InputPortBase</a> at index <span class="tt">port_index</span>, throwing std::exception we don't like the port index.  <br /></td></tr>
<tr class="memitem:af1ebe946141901f25db81d72eb5f2e15" id="r_af1ebe946141901f25db81d72eb5f2e15"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port_base.html">OutputPortBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#af1ebe946141901f25db81d72eb5f2e15">GetOutputPortBaseOrThrow</a> (const char *func, int port_index, bool warn_deprecated) const</td></tr>
<tr class="memdesc:af1ebe946141901f25db81d72eb5f2e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns the <a class="el" href="classdrake_1_1systems_1_1_output_port_base.html" title="OutputPortBase handles the scalar type-independent aspects of an OutputPort.">OutputPortBase</a> at index <span class="tt">port_index</span>, throwing std::exception if we don't like the port index.  <br /></td></tr>
<tr class="memitem:a36ffbedd99e6e5c0fb71753ad2b833b7" id="r_a36ffbedd99e6e5c0fb71753ad2b833b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a36ffbedd99e6e5c0fb71753ad2b833b7">ThrowValidateContextMismatch</a> (const <a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> &amp;) const</td></tr>
<tr class="memdesc:a36ffbedd99e6e5c0fb71753ad2b833b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Throws std::exception with a message that the sanity check(s) given by ValidateContext have failed.  <br /></td></tr>
<tr class="memitem:a777cf2547a697f92ae1f556b0b637150" id="r_a777cf2547a697f92ae1f556b0b637150"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a777cf2547a697f92ae1f556b0b637150">GetUnsupportedScalarConversionMessage</a> (const std::type_info &amp;source_type, const std::type_info &amp;destination_type) const</td></tr>
<tr class="memdesc:a777cf2547a697f92ae1f556b0b637150"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns the message to use for a std::exception in the case of unsupported scalar type conversions.  <br /></td></tr>
<tr class="memitem:a0eb74936487f1ae4658b54979195fa1b" id="r_a0eb74936487f1ae4658b54979195fa1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a0eb74936487f1ae4658b54979195fa1b">InitializeContextBase</a> (<a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> *context) const</td></tr>
<tr class="memdesc:a0eb74936487f1ae4658b54979195fa1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method must be invoked from within derived class <a class="el" href="classdrake_1_1systems_1_1_system_base.html#af5531068228f18fbd9deb50e465234dc" title="Derived class implementations should allocate a suitable concrete Context type, then invoke the above...">DoAllocateContext()</a> implementations right after the concrete <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> object has been allocated.  <br /></td></tr>
<tr class="memitem:af5531068228f18fbd9deb50e465234dc" id="r_af5531068228f18fbd9deb50e465234dc"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_context_base.html">ContextBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#af5531068228f18fbd9deb50e465234dc">DoAllocateContext</a> () const =0</td></tr>
<tr class="memdesc:af5531068228f18fbd9deb50e465234dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class implementations should allocate a suitable concrete <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> type, then invoke the above <a class="el" href="classdrake_1_1systems_1_1_system_base.html#a0eb74936487f1ae4658b54979195fa1b" title="This method must be invoked from within derived class DoAllocateContext() implementations right after...">InitializeContextBase()</a> method.  <br /></td></tr>
<tr class="memitem:a1a1549d45dd51325abb27bce961aaea7" id="r_a1a1549d45dd51325abb27bce961aaea7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdrake_1_1systems_1_1_system_base_1_1_context_sizes.html">ContextSizes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a1a1549d45dd51325abb27bce961aaea7">get_context_sizes</a> () const</td></tr>
<tr class="memdesc:a1a1549d45dd51325abb27bce961aaea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains access to the declared <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> partition sizes as accumulated during <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a> or <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> construction .  <br /></td></tr>
<tr class="memitem:a247e9d169c01573138faa94891f04304" id="r_a247e9d169c01573138faa94891f04304"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1systems_1_1_system_base_1_1_context_sizes.html">ContextSizes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a247e9d169c01573138faa94891f04304">get_mutable_context_sizes</a> ()</td></tr>
<tr class="memdesc:a247e9d169c01573138faa94891f04304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains mutable access to the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> sizes struct.  <br /></td></tr>
<tr class="memitem:a67f200e6184921996fcce55fcb18fba6" id="r_a67f200e6184921996fcce55fcb18fba6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a67f200e6184921996fcce55fcb18fba6">set_implicit_time_derivatives_residual_size</a> (int n)</td></tr>
<tr class="memdesc:a67f200e6184921996fcce55fcb18fba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows a <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a> to override the default size for the implicit time derivatives residual and a <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> to sum up the total size.  <br /></td></tr>
<tr class="memitem:a1b3f9382208d13e11984a54afa711577" id="r_a1b3f9382208d13e11984a54afa711577"><td class="memItemLeft" align="right" valign="top">internal::SystemId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a1b3f9382208d13e11984a54afa711577">get_system_id</a> () const</td></tr>
<tr class="memdesc:a1b3f9382208d13e11984a54afa711577"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal) Gets the id used to tag context data as being created by this system.  <br /></td></tr>
<tr class="memitem:a140f5e4ae62c9208e368ea15d7612155" id="r_a140f5e4ae62c9208e368ea15d7612155"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structdrake_1_1systems_1_1_system_base_1_1_graphviz_fragment.html">GraphvizFragment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a140f5e4ae62c9208e368ea15d7612155">DoGetGraphvizFragment</a> (const <a class="el" href="structdrake_1_1systems_1_1_system_base_1_1_graphviz_fragment_params.html">GraphvizFragmentParams</a> &amp;params) const</td></tr>
<tr class="memdesc:a140f5e4ae62c9208e368ea15d7612155"><td class="mdescLeft">&#160;</td><td class="mdescRight">The NVI implementation of <a class="el" href="classdrake_1_1systems_1_1_system_base.html#abfd58214195f7fbebfb65a7ef0c84d06" title="(Advanced) Like GetGraphvizString() but does not wrap the string in a digraph { … }...">GetGraphvizFragment()</a> for subclasses to override if desired.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Utility methods (protected)</h2></td></tr>
<tr class="memitem:a70a6f9e15c48813e173ebd6d48770fa1" id="r_a70a6f9e15c48813e173ebd6d48770fa1"><td class="memTemplParams" colspan="2">template&lt;typename&gt; </td></tr>
<tr class="memitem:a70a6f9e15c48813e173ebd6d48770fa1 template"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a></td></tr>
<tr class="memitem:a7f62cabd62a694728e1ae913d6d99163" id="r_a7f62cabd62a694728e1ae913d6d99163"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:a7f62cabd62a694728e1ae913d6d99163 template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f62cabd62a694728e1ae913d6d99163">HandlePostConstructionScalarConversion</a> (const <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; U &gt; &amp;from, <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; T &gt; *to)</td></tr>
<tr class="memdesc:a7f62cabd62a694728e1ae913d6d99163"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) <a class="el" href="#a78eaec0a6a2d1c99d2a7eb5eeb1f8bdc" title="The scalar type with which this System was instantiated.">Scalar</a> conversion (e.g., ToAutoDiffXd) will first call the <a class="el" href="classdrake_1_1systems_1_1_system_scalar_converter.html" title="Helper class to convert a System into a System&lt;T&gt;, intended for internal use by the System framework,...">SystemScalarConverter</a> to construct the converted system, and then call this function for any post-construction cleanup.  <br /></td></tr>
<tr class="memitem:a6278437ceb2dce5a6c8f70f19285319a" id="r_a6278437ceb2dce5a6c8f70f19285319a"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6278437ceb2dce5a6c8f70f19285319a">GetMutableOutputVector</a> (<a class="el" href="classdrake_1_1systems_1_1_system_output.html">SystemOutput</a>&lt; T &gt; *output, int port_index) const</td></tr>
<tr class="memdesc:a6278437ceb2dce5a6c8f70f19285319a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable Eigen expression for a vector valued output port with index <code class="param">port_index</code> in this system.  <br /></td></tr>
<tr class="memitem:ad8812e3795d6c187c6f21fb441a717db" id="r_ad8812e3795d6c187c6f21fb441a717db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8812e3795d6c187c6f21fb441a717db">forced_publish_events_exist</a> () const</td></tr>
<tr class="memitem:a582cbe45eeaf9fe74b7143a1b71ff958" id="r_a582cbe45eeaf9fe74b7143a1b71ff958"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a582cbe45eeaf9fe74b7143a1b71ff958">forced_discrete_update_events_exist</a> () const</td></tr>
<tr class="memitem:a06f70983cdba078821ed784fcf2f775f" id="r_a06f70983cdba078821ed784fcf2f775f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06f70983cdba078821ed784fcf2f775f">forced_unrestricted_update_events_exist</a> () const</td></tr>
<tr class="memitem:ad73b451207ec33640ac284fd90e5232e" id="r_ad73b451207ec33640ac284fd90e5232e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad73b451207ec33640ac284fd90e5232e">get_mutable_forced_publish_events</a> ()</td></tr>
<tr class="memitem:aef1a605368f8aab79cb543b54d905390" id="r_aef1a605368f8aab79cb543b54d905390"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef1a605368f8aab79cb543b54d905390">get_mutable_forced_discrete_update_events</a> ()</td></tr>
<tr class="memitem:aa6d855ef062a5d964dbdeff200b1bc85" id="r_aa6d855ef062a5d964dbdeff200b1bc85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6d855ef062a5d964dbdeff200b1bc85">get_mutable_forced_unrestricted_update_events</a> ()</td></tr>
<tr class="memitem:ae108fee2883346485c35d2f44af45c55" id="r_ae108fee2883346485c35d2f44af45c55"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae108fee2883346485c35d2f44af45c55">get_forced_discrete_update_events</a> () const</td></tr>
<tr class="memitem:a10c48210c1b86512cf31e885a21d14f7" id="r_a10c48210c1b86512cf31e885a21d14f7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10c48210c1b86512cf31e885a21d14f7">get_forced_unrestricted_update_events</a> () const</td></tr>
<tr class="memitem:a4be1a810c98e302ef15018ddcbe35b70" id="r_a4be1a810c98e302ef15018ddcbe35b70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4be1a810c98e302ef15018ddcbe35b70">set_forced_publish_events</a> (std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt; &gt; &gt; forced)</td></tr>
<tr class="memitem:a5628467a4abaa6312e4389cb7c02a687" id="r_a5628467a4abaa6312e4389cb7c02a687"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5628467a4abaa6312e4389cb7c02a687">set_forced_discrete_update_events</a> (std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &gt; &gt; forced)</td></tr>
<tr class="memitem:a8eb3004ad3b51c25596cf422355fde54" id="r_a8eb3004ad3b51c25596cf422355fde54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8eb3004ad3b51c25596cf422355fde54">set_forced_unrestricted_update_events</a> (std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; &gt; &gt; forced)</td></tr>
<tr class="memitem:abe4ee13b132d5d8ebabff1c029f19a60" id="r_abe4ee13b132d5d8ebabff1c029f19a60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_system_scalar_converter.html">SystemScalarConverter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe4ee13b132d5d8ebabff1c029f19a60">get_mutable_system_scalar_converter</a> ()</td></tr>
<tr class="memdesc:abe4ee13b132d5d8ebabff1c029f19a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classdrake_1_1systems_1_1_system_scalar_converter.html" title="Helper class to convert a System into a System&lt;T&gt;, intended for internal use by the System framework,...">SystemScalarConverter</a> for <span class="tt">this</span> system.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Cloning</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>These functions make a deep copy of a system. </p>
</td></tr>
<tr class="memitem:ad0a03a7f6f5f95c30952aac17c46c3b4" id="r_ad0a03a7f6f5f95c30952aac17c46c3b4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0a03a7f6f5f95c30952aac17c46c3b4">Clone</a> () const</td></tr>
<tr class="memdesc:ad0a03a7f6f5f95c30952aac17c46c3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this system.  <br /></td></tr>
<tr class="memitem:a619dc4f1c01b7bae6019aefd5d0d7eca" id="r_a619dc4f1c01b7bae6019aefd5d0d7eca"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class S = ::drake::systems::System&gt; </td></tr>
<tr class="memitem:a619dc4f1c01b7bae6019aefd5d0d7eca template"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; S&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a619dc4f1c01b7bae6019aefd5d0d7eca">Clone</a> (const S&lt; T &gt; &amp;from)</td></tr>
<tr class="memdesc:a619dc4f1c01b7bae6019aefd5d0d7eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this system.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Automatic differentiation</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>From a System templatized by <span class="tt">double</span>, you can obtain an identical system templatized by an automatic differentiation scalar providing machine-precision computation of partial derivatives of any numerical result of the System with respect to any of the numerical values that can be contained in a <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> (time, inputs, parameters, and state). </p>
</td></tr>
<tr class="memitem:af4283f9cfe4969e5760164a5528b6960" id="r_af4283f9cfe4969e5760164a5528b6960"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; <a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854">AutoDiffXd</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4283f9cfe4969e5760164a5528b6960">ToAutoDiffXd</a> () const</td></tr>
<tr class="memdesc:af4283f9cfe4969e5760164a5528b6960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>, transmogrified to use the autodiff scalar type, with a dynamic-sized vector of partial derivatives.  <br /></td></tr>
<tr class="memitem:ac91d9e1abca4161ce227d4ebafb3496a" id="r_ac91d9e1abca4161ce227d4ebafb3496a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; <a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854">AutoDiffXd</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac91d9e1abca4161ce227d4ebafb3496a">ToAutoDiffXdMaybe</a> () const</td></tr>
<tr class="memdesc:ac91d9e1abca4161ce227d4ebafb3496a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this system exactly like <a class="el" href="#af4283f9cfe4969e5760164a5528b6960" title="Creates a deep copy of this System, transmogrified to use the autodiff scalar type,...">ToAutoDiffXd()</a>, but returns nullptr if this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> does not support autodiff, instead of throwing an exception.  <br /></td></tr>
<tr class="memitem:aa1d9f903212bc7c15bda23fe8e97d9fa" id="r_aa1d9f903212bc7c15bda23fe8e97d9fa"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class S = ::drake::systems::System&gt; </td></tr>
<tr class="memitem:aa1d9f903212bc7c15bda23fe8e97d9fa template"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; S&lt; <a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854">AutoDiffXd</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1d9f903212bc7c15bda23fe8e97d9fa">ToAutoDiffXd</a> (const S&lt; T &gt; &amp;from)</td></tr>
<tr class="memdesc:aa1d9f903212bc7c15bda23fe8e97d9fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of <span class="tt">from</span>, transmogrified to use the autodiff scalar type, with a dynamic-sized vector of partial derivatives.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Symbolics</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>From a System templatized by <span class="tt">double</span>, you can obtain an identical system templatized by a symbolic expression scalar. </p>
</td></tr>
<tr class="memitem:a23b6ffa087bb0a1ec114d07d777adc75" id="r_a23b6ffa087bb0a1ec114d07d777adc75"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23b6ffa087bb0a1ec114d07d777adc75">ToSymbolic</a> () const</td></tr>
<tr class="memdesc:a23b6ffa087bb0a1ec114d07d777adc75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>, transmogrified to use the symbolic scalar type.  <br /></td></tr>
<tr class="memitem:aabd70fbba6ec19f5519e468f29d36179" id="r_aabd70fbba6ec19f5519e468f29d36179"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabd70fbba6ec19f5519e468f29d36179">ToSymbolicMaybe</a> () const</td></tr>
<tr class="memdesc:aabd70fbba6ec19f5519e468f29d36179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this system exactly like <a class="el" href="#a23b6ffa087bb0a1ec114d07d777adc75" title="Creates a deep copy of this System, transmogrified to use the symbolic scalar type.">ToSymbolic()</a>, but returns nullptr if this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> does not support symbolic, instead of throwing an exception.  <br /></td></tr>
<tr class="memitem:a61510196a7b8f132b3c5b737b6f3f3da" id="r_a61510196a7b8f132b3c5b737b6f3f3da"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class S = ::drake::systems::System&gt; </td></tr>
<tr class="memitem:a61510196a7b8f132b3c5b737b6f3f3da template"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; S&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61510196a7b8f132b3c5b737b6f3f3da">ToSymbolic</a> (const S&lt; T &gt; &amp;from)</td></tr>
<tr class="memdesc:a61510196a7b8f132b3c5b737b6f3f3da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of <span class="tt">from</span>, transmogrified to use the symbolic scalar type.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Scalar type conversion by template parameter</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>These routines allow arbitrary scalar type conversion to be attempted.</p>
<p>Not all conversions will be supported, for various reasons.</p>
<ul>
<li>"Self conversions" (T=U) are not supported because the definitions would be ambiguous with the (deleted) copy constructor.</li>
<li>Derived systems may decline to support some scalar types. </li>
</ul>
</td></tr>
<tr class="memitem:ad122edf04333ce57b3520d14f06939b2" id="r_ad122edf04333ce57b3520d14f06939b2"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:ad122edf04333ce57b3520d14f06939b2 template"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; U &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad122edf04333ce57b3520d14f06939b2">ToScalarType</a> () const</td></tr>
<tr class="memdesc:ad122edf04333ce57b3520d14f06939b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>, transmogrified to use the scalar type selected by a template parameter.  <br /></td></tr>
<tr class="memitem:ae892341d1a1fcad061949cdfb231c819" id="r_ae892341d1a1fcad061949cdfb231c819"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:ae892341d1a1fcad061949cdfb231c819 template"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; U &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae892341d1a1fcad061949cdfb231c819">ToScalarTypeMaybe</a> () const</td></tr>
<tr class="memdesc:ae892341d1a1fcad061949cdfb231c819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this system exactly like <a class="el" href="#ad122edf04333ce57b3520d14f06939b2" title="Creates a deep copy of this System, transmogrified to use the scalar type selected by a template para...">ToScalarType()</a>, but returns nullptr if this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> does not support the destination type, instead of throwing an exception.  <br /></td></tr>
<tr class="memitem:ab9f777bd94a7d9188a905ac6ecfff577" id="r_ab9f777bd94a7d9188a905ac6ecfff577"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9f777bd94a7d9188a905ac6ecfff577">GetWitnessFunctions</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, std::vector&lt; const <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; * &gt; *w) const</td></tr>
<tr class="memdesc:ab9f777bd94a7d9188a905ac6ecfff577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the witness functions active for the given state.  <br /></td></tr>
<tr class="memitem:a2949deb61db7903dae4c0b7cb9633fac" id="r_a2949deb61db7903dae4c0b7cb9633fac"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2949deb61db7903dae4c0b7cb9633fac">CalcWitnessValue</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &amp;witness_func) const</td></tr>
<tr class="memdesc:a2949deb61db7903dae4c0b7cb9633fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a witness function at the given context.  <br /></td></tr>
<tr class="memitem:a838b32b3b596aae6c11fa9c19e655407" id="r_a838b32b3b596aae6c11fa9c19e655407"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a838b32b3b596aae6c11fa9c19e655407">AddTriggeredWitnessFunctionToCompositeEventCollection</a> (<a class="el" href="classdrake_1_1systems_1_1_event.html">Event</a>&lt; T &gt; *event, <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *events) const =0</td></tr>
<tr class="memdesc:a838b32b3b596aae6c11fa9c19e655407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <span class="tt">event</span> to <span class="tt">events</span> due to a witness function triggering.  <br /></td></tr>
<tr class="memitem:adf86073429b07d388b0157956bfdbac6" id="r_adf86073429b07d388b0157956bfdbac6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf86073429b07d388b0157956bfdbac6">discrete_state_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#acf2a50397e9fa764d32553cf98460ba7">DiscreteStateIndex</a> index) const</td></tr>
<tr class="memdesc:adf86073429b07d388b0157956bfdbac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on a particular discrete state variable xdᵢ (may be a vector).  <br /></td></tr>
<tr class="memitem:a4a8d4f32034a610ea30a283699040708" id="r_a4a8d4f32034a610ea30a283699040708"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a8d4f32034a610ea30a283699040708">abstract_state_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#a8c3a27f43e356726f770159944adb929">AbstractStateIndex</a> index) const</td></tr>
<tr class="memdesc:a4a8d4f32034a610ea30a283699040708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on a particular abstract state variable xaᵢ.  <br /></td></tr>
<tr class="memitem:a45e0bf1fd3096bff3df2587ec4f02285" id="r_a45e0bf1fd3096bff3df2587ec4f02285"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45e0bf1fd3096bff3df2587ec4f02285">numeric_parameter_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#af11369a06c5bfd3fa18acb79f85777df">NumericParameterIndex</a> index) const</td></tr>
<tr class="memdesc:a45e0bf1fd3096bff3df2587ec4f02285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on a particular numeric parameter pnᵢ (may be a vector).  <br /></td></tr>
<tr class="memitem:a1a4ef0e0e633c6f722ee518308d7cb5a" id="r_a1a4ef0e0e633c6f722ee518308d7cb5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a4ef0e0e633c6f722ee518308d7cb5a">abstract_parameter_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#a86b350169906f6d5e07e9db46e36d57a">AbstractParameterIndex</a> index) const</td></tr>
<tr class="memdesc:a1a4ef0e0e633c6f722ee518308d7cb5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on a particular abstract parameter paᵢ.  <br /></td></tr>
<tr class="memitem:a191b7cb5dcbfee51a62fa042ec14561f" id="r_a191b7cb5dcbfee51a62fa042ec14561f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a191b7cb5dcbfee51a62fa042ec14561f">input_port_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> index) const</td></tr>
<tr class="memdesc:a191b7cb5dcbfee51a62fa042ec14561f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on input port uᵢ indicated by <span class="tt">index</span>.  <br /></td></tr>
<tr class="memitem:a7e92c6f01c04b3591d642d27a467b093" id="r_a7e92c6f01c04b3591d642d27a467b093"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e92c6f01c04b3591d642d27a467b093">cache_entry_ticket</a> (<a class="el" href="namespacedrake_1_1systems.html#a06ac9ad764b14ccff79b6feb393be498">CacheIndex</a> index) const</td></tr>
<tr class="memdesc:a7e92c6f01c04b3591d642d27a467b093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on the cache entry indicated by <span class="tt">index</span>.  <br /></td></tr>
<tr class="memitem:ad0c1bcc05d4a4ecd79cd4c2e5edd0cb6" id="r_ad0c1bcc05d4a4ecd79cd4c2e5edd0cb6"><td class="memTemplParams" colspan="2">template&lt;typename U, template&lt; typename &gt; class S = ::drake::systems::System&gt; </td></tr>
<tr class="memitem:ad0c1bcc05d4a4ecd79cd4c2e5edd0cb6 template"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; S&lt; U &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0c1bcc05d4a4ecd79cd4c2e5edd0cb6">ToScalarType</a> (const S&lt; T &gt; &amp;from)</td></tr>
<tr class="memdesc:ad0c1bcc05d4a4ecd79cd4c2e5edd0cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of <span class="tt">from</span>, transmogrified to use the scalar type selected by a template parameter.  <br /></td></tr>
<tr class="memitem:a6fe75ddbd79ab1d862df9a50b3c8a624" id="r_a6fe75ddbd79ab1d862df9a50b3c8a624"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fe75ddbd79ab1d862df9a50b3c8a624">nothing_ticket</a> ()</td></tr>
<tr class="memdesc:a6fe75ddbd79ab1d862df9a50b3c8a624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating that a computation does not depend on <em>any</em> source value; that is, it is a constant.  <br /></td></tr>
<tr class="memitem:a68516072b2dc51a601f2de699691f1c3" id="r_a68516072b2dc51a601f2de699691f1c3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68516072b2dc51a601f2de699691f1c3">time_ticket</a> ()</td></tr>
<tr class="memdesc:a68516072b2dc51a601f2de699691f1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on time.  <br /></td></tr>
<tr class="memitem:ad649083fc3bcb645671be3fad577d2ab" id="r_ad649083fc3bcb645671be3fad577d2ab"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad649083fc3bcb645671be3fad577d2ab">accuracy_ticket</a> ()</td></tr>
<tr class="memdesc:ad649083fc3bcb645671be3fad577d2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on the accuracy setting in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <br /></td></tr>
<tr class="memitem:a41d3cdadf7d6b62b055993148b82df19" id="r_a41d3cdadf7d6b62b055993148b82df19"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41d3cdadf7d6b62b055993148b82df19">q_ticket</a> ()</td></tr>
<tr class="memdesc:a41d3cdadf7d6b62b055993148b82df19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating that a computation depends on configuration state variables q.  <br /></td></tr>
<tr class="memitem:ab858ddb6f259d65f760c2032b3bd5164" id="r_ab858ddb6f259d65f760c2032b3bd5164"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab858ddb6f259d65f760c2032b3bd5164">v_ticket</a> ()</td></tr>
<tr class="memdesc:ab858ddb6f259d65f760c2032b3bd5164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on velocity state variables v.  <br /></td></tr>
<tr class="memitem:a340a9b088fc407f703a9e21ed9dee32e" id="r_a340a9b088fc407f703a9e21ed9dee32e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a340a9b088fc407f703a9e21ed9dee32e">z_ticket</a> ()</td></tr>
<tr class="memdesc:a340a9b088fc407f703a9e21ed9dee32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on any or all of the miscellaneous continuous state variables z.  <br /></td></tr>
<tr class="memitem:a385e0d5605b81db0fbfc6bdd57affb5e" id="r_a385e0d5605b81db0fbfc6bdd57affb5e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a385e0d5605b81db0fbfc6bdd57affb5e">xc_ticket</a> ()</td></tr>
<tr class="memdesc:a385e0d5605b81db0fbfc6bdd57affb5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on <em>all</em> of the continuous state variables q, v, or z.  <br /></td></tr>
<tr class="memitem:a64938d044107c8eedc97f89aaf0e4a32" id="r_a64938d044107c8eedc97f89aaf0e4a32"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64938d044107c8eedc97f89aaf0e4a32">xd_ticket</a> ()</td></tr>
<tr class="memdesc:a64938d044107c8eedc97f89aaf0e4a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all of the numerical discrete state variables, in any discrete variable group.  <br /></td></tr>
<tr class="memitem:a19842775d11b50e5ae56abcc6d38ccc4" id="r_a19842775d11b50e5ae56abcc6d38ccc4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19842775d11b50e5ae56abcc6d38ccc4">xa_ticket</a> ()</td></tr>
<tr class="memdesc:a19842775d11b50e5ae56abcc6d38ccc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all of the abstract state variables in the current <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <br /></td></tr>
<tr class="memitem:a2789768c5d75378c081683a8016f0784" id="r_a2789768c5d75378c081683a8016f0784"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2789768c5d75378c081683a8016f0784">all_state_ticket</a> ()</td></tr>
<tr class="memdesc:a2789768c5d75378c081683a8016f0784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on <em>all</em> state variables x in this system, including continuous variables xc, discrete (numeric) variables xd, and abstract state variables xa.  <br /></td></tr>
<tr class="memitem:aaeae092662e78f50416eb6dc01ad3ddb" id="r_aaeae092662e78f50416eb6dc01ad3ddb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaeae092662e78f50416eb6dc01ad3ddb">pn_ticket</a> ()</td></tr>
<tr class="memdesc:aaeae092662e78f50416eb6dc01ad3ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all of the numerical parameters in the current <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <br /></td></tr>
<tr class="memitem:af3c65473a41f73091c600eaead714fe2" id="r_af3c65473a41f73091c600eaead714fe2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3c65473a41f73091c600eaead714fe2">pa_ticket</a> ()</td></tr>
<tr class="memdesc:af3c65473a41f73091c600eaead714fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all of the abstract parameters pa in the current <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <br /></td></tr>
<tr class="memitem:ad6b63a1cb8922051fb1a7fe4b56092bf" id="r_ad6b63a1cb8922051fb1a7fe4b56092bf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6b63a1cb8922051fb1a7fe4b56092bf">all_parameters_ticket</a> ()</td></tr>
<tr class="memdesc:ad6b63a1cb8922051fb1a7fe4b56092bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on <em>all</em> parameters p in this system, including numeric parameters pn, and abstract parameters pa.  <br /></td></tr>
<tr class="memitem:a6d7c526102c09a75195c57ebf5f54a11" id="r_a6d7c526102c09a75195c57ebf5f54a11"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d7c526102c09a75195c57ebf5f54a11">all_input_ports_ticket</a> ()</td></tr>
<tr class="memdesc:a6d7c526102c09a75195c57ebf5f54a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on <em>all</em> input ports u of this system.  <br /></td></tr>
<tr class="memitem:af0b9bc9f93181e042bdb2c36f4dbea10" id="r_af0b9bc9f93181e042bdb2c36f4dbea10"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a> ()</td></tr>
<tr class="memdesc:af0b9bc9f93181e042bdb2c36f4dbea10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on every possible independent source value, including time, accuracy, state, input ports, and parameters (but not cache entries).  <br /></td></tr>
<tr class="memitem:a28830dced98dcdc1f498d8d250db0ae4" id="r_a28830dced98dcdc1f498d8d250db0ae4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28830dced98dcdc1f498d8d250db0ae4">configuration_ticket</a> ()</td></tr>
<tr class="memdesc:a28830dced98dcdc1f498d8d250db0ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all source values that may affect configuration-dependent computations.  <br /></td></tr>
<tr class="memitem:a1291b5091aa55dbd03c9b5944dbced09" id="r_a1291b5091aa55dbd03c9b5944dbced09"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1291b5091aa55dbd03c9b5944dbced09">kinematics_ticket</a> ()</td></tr>
<tr class="memdesc:a1291b5091aa55dbd03c9b5944dbced09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all source values that may affect configuration- or velocity-dependent computations.  <br /></td></tr>
<tr class="memitem:ab42cd3bff14253894eb0a29edf843b3f" id="r_ab42cd3bff14253894eb0a29edf843b3f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab42cd3bff14253894eb0a29edf843b3f">xcdot_ticket</a> ()</td></tr>
<tr class="memdesc:ab42cd3bff14253894eb0a29edf843b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds time derivatives of the continuous variables.  <br /></td></tr>
<tr class="memitem:a49f1689b1ae9f05b6e2f194db873927b" id="r_a49f1689b1ae9f05b6e2f194db873927b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49f1689b1ae9f05b6e2f194db873927b">pe_ticket</a> ()</td></tr>
<tr class="memdesc:a49f1689b1ae9f05b6e2f194db873927b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds the potential energy calculation.  <br /></td></tr>
<tr class="memitem:a66e1d9af27119011a497b78df6907b1a" id="r_a66e1d9af27119011a497b78df6907b1a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66e1d9af27119011a497b78df6907b1a">ke_ticket</a> ()</td></tr>
<tr class="memdesc:a66e1d9af27119011a497b78df6907b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds the kinetic energy calculation.  <br /></td></tr>
<tr class="memitem:afdc60bc4c201f17bd35bf40c13a183b3" id="r_afdc60bc4c201f17bd35bf40c13a183b3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdc60bc4c201f17bd35bf40c13a183b3">pc_ticket</a> ()</td></tr>
<tr class="memdesc:afdc60bc4c201f17bd35bf40c13a183b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds the conservative power calculation.  <br /></td></tr>
<tr class="memitem:a0afc9712c887706c12039e871476f30c" id="r_a0afc9712c887706c12039e871476f30c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0afc9712c887706c12039e871476f30c">pnc_ticket</a> ()</td></tr>
<tr class="memdesc:a0afc9712c887706c12039e871476f30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds the non-conservative power calculation.  <br /></td></tr>
<tr class="memitem:abeb2444df5d7f4eeec63962393985bcd" id="r_abeb2444df5d7f4eeec63962393985bcd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abeb2444df5d7f4eeec63962393985bcd">FindUniquePeriodicDiscreteUpdatesOrThrow</a> (const char *api_name, const <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; T &gt; &amp;system, const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, std::optional&lt; <a class="el" href="classdrake_1_1systems_1_1_periodic_event_data.html">PeriodicEventData</a> &gt; *timing, <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &gt; *events)</td></tr>
<tr class="memdesc:abeb2444df5d7f4eeec63962393985bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Static interface to DoFindUniquePeriodicDiscreteUpdatesOrThrow() to allow a <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> to invoke that private method on its subsystems.  <br /></td></tr>
<tr class="memitem:a9440f6840ccb22a989d50ff8a7e65760" id="r_a9440f6840ccb22a989d50ff8a7e65760"><td class="memItemLeft" align="right" valign="top">virtual T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9440f6840ccb22a989d50ff8a7e65760">DoCalcWitnessValue</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &amp;witness_func) const =0</td></tr>
<tr class="memdesc:a9440f6840ccb22a989d50ff8a7e65760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes will implement this method to evaluate a witness function at the given context.  <br /></td></tr>
<tr class="memitem:af6d0f8fa7471b9cf026c9b7bf86f615c" id="r_af6d0f8fa7471b9cf026c9b7bf86f615c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6d0f8fa7471b9cf026c9b7bf86f615c">DoGetWitnessFunctions</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;, std::vector&lt; const <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; * &gt; *) const</td></tr>
<tr class="memdesc:af6d0f8fa7471b9cf026c9b7bf86f615c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes can override this method to provide witness functions active for the given state.  <br /></td></tr>
<tr class="memitem:a1a97898d5e2f921cdb729f02a3c88074" id="r_a1a97898d5e2f921cdb729f02a3c88074"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a97898d5e2f921cdb729f02a3c88074">DeclareCacheEntry</a> (std::string description, <a class="el" href="classdrake_1_1systems_1_1_value_producer.html">ValueProducer</a> value_producer, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:a1a97898d5e2f921cdb729f02a3c88074"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="DeclareCacheEntry_primary"></a> <br /></td></tr>
<tr class="memitem:a4076a7594095a9ca6936dd70c7254f84" id="r_a4076a7594095a9ca6936dd70c7254f84"><td class="memTemplParams" colspan="2">template&lt;class MySystem, class MyContext, typename ValueType&gt; </td></tr>
<tr class="memitem:a4076a7594095a9ca6936dd70c7254f84 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4076a7594095a9ca6936dd70c7254f84">DeclareCacheEntry</a> (std::string description, const ValueType &amp;model_value, void(MySystem::*calc)(const MyContext &amp;, ValueType *) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:a4076a7594095a9ca6936dd70c7254f84"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="DeclareCacheEntry_model_and_calc"></a> <br /></td></tr>
<tr class="memitem:a7d078e4f799ae50f07ae35389352835f" id="r_a7d078e4f799ae50f07ae35389352835f"><td class="memTemplParams" colspan="2">template&lt;class MySystem, class MyContext, typename ValueType&gt; </td></tr>
<tr class="memitem:a7d078e4f799ae50f07ae35389352835f template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d078e4f799ae50f07ae35389352835f">DeclareCacheEntry</a> (std::string description, void(MySystem::*calc)(const MyContext &amp;, ValueType *) const, std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt; prerequisites_of_calc={ <a class="el" href="#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()})</td></tr>
<tr class="memdesc:a7d078e4f799ae50f07ae35389352835f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="anchor" id="DeclareCacheEntry_calc_only"></a> <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-inherited" class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="memitem:a6fe75ddbd79ab1d862df9a50b3c8a624" id="r_a6fe75ddbd79ab1d862df9a50b3c8a624"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a6fe75ddbd79ab1d862df9a50b3c8a624">nothing_ticket</a> ()</td></tr>
<tr class="memdesc:a6fe75ddbd79ab1d862df9a50b3c8a624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating that a computation does not depend on <em>any</em> source value; that is, it is a constant.  <br /></td></tr>
<tr class="memitem:a68516072b2dc51a601f2de699691f1c3" id="r_a68516072b2dc51a601f2de699691f1c3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a68516072b2dc51a601f2de699691f1c3">time_ticket</a> ()</td></tr>
<tr class="memdesc:a68516072b2dc51a601f2de699691f1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on time.  <br /></td></tr>
<tr class="memitem:ad649083fc3bcb645671be3fad577d2ab" id="r_ad649083fc3bcb645671be3fad577d2ab"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ad649083fc3bcb645671be3fad577d2ab">accuracy_ticket</a> ()</td></tr>
<tr class="memdesc:ad649083fc3bcb645671be3fad577d2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on the accuracy setting in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <br /></td></tr>
<tr class="memitem:a41d3cdadf7d6b62b055993148b82df19" id="r_a41d3cdadf7d6b62b055993148b82df19"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a41d3cdadf7d6b62b055993148b82df19">q_ticket</a> ()</td></tr>
<tr class="memdesc:a41d3cdadf7d6b62b055993148b82df19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating that a computation depends on configuration state variables q.  <br /></td></tr>
<tr class="memitem:ab858ddb6f259d65f760c2032b3bd5164" id="r_ab858ddb6f259d65f760c2032b3bd5164"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ab858ddb6f259d65f760c2032b3bd5164">v_ticket</a> ()</td></tr>
<tr class="memdesc:ab858ddb6f259d65f760c2032b3bd5164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on velocity state variables v.  <br /></td></tr>
<tr class="memitem:a340a9b088fc407f703a9e21ed9dee32e" id="r_a340a9b088fc407f703a9e21ed9dee32e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a340a9b088fc407f703a9e21ed9dee32e">z_ticket</a> ()</td></tr>
<tr class="memdesc:a340a9b088fc407f703a9e21ed9dee32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on any or all of the miscellaneous continuous state variables z.  <br /></td></tr>
<tr class="memitem:a385e0d5605b81db0fbfc6bdd57affb5e" id="r_a385e0d5605b81db0fbfc6bdd57affb5e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a385e0d5605b81db0fbfc6bdd57affb5e">xc_ticket</a> ()</td></tr>
<tr class="memdesc:a385e0d5605b81db0fbfc6bdd57affb5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on <em>all</em> of the continuous state variables q, v, or z.  <br /></td></tr>
<tr class="memitem:a64938d044107c8eedc97f89aaf0e4a32" id="r_a64938d044107c8eedc97f89aaf0e4a32"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a64938d044107c8eedc97f89aaf0e4a32">xd_ticket</a> ()</td></tr>
<tr class="memdesc:a64938d044107c8eedc97f89aaf0e4a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all of the numerical discrete state variables, in any discrete variable group.  <br /></td></tr>
<tr class="memitem:a19842775d11b50e5ae56abcc6d38ccc4" id="r_a19842775d11b50e5ae56abcc6d38ccc4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a19842775d11b50e5ae56abcc6d38ccc4">xa_ticket</a> ()</td></tr>
<tr class="memdesc:a19842775d11b50e5ae56abcc6d38ccc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all of the abstract state variables in the current <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <br /></td></tr>
<tr class="memitem:a2789768c5d75378c081683a8016f0784" id="r_a2789768c5d75378c081683a8016f0784"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a2789768c5d75378c081683a8016f0784">all_state_ticket</a> ()</td></tr>
<tr class="memdesc:a2789768c5d75378c081683a8016f0784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on <em>all</em> state variables x in this system, including continuous variables xc, discrete (numeric) variables xd, and abstract state variables xa.  <br /></td></tr>
<tr class="memitem:aaeae092662e78f50416eb6dc01ad3ddb" id="r_aaeae092662e78f50416eb6dc01ad3ddb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aaeae092662e78f50416eb6dc01ad3ddb">pn_ticket</a> ()</td></tr>
<tr class="memdesc:aaeae092662e78f50416eb6dc01ad3ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all of the numerical parameters in the current <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <br /></td></tr>
<tr class="memitem:af3c65473a41f73091c600eaead714fe2" id="r_af3c65473a41f73091c600eaead714fe2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#af3c65473a41f73091c600eaead714fe2">pa_ticket</a> ()</td></tr>
<tr class="memdesc:af3c65473a41f73091c600eaead714fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all of the abstract parameters pa in the current <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <br /></td></tr>
<tr class="memitem:ad6b63a1cb8922051fb1a7fe4b56092bf" id="r_ad6b63a1cb8922051fb1a7fe4b56092bf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ad6b63a1cb8922051fb1a7fe4b56092bf">all_parameters_ticket</a> ()</td></tr>
<tr class="memdesc:ad6b63a1cb8922051fb1a7fe4b56092bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on <em>all</em> parameters p in this system, including numeric parameters pn, and abstract parameters pa.  <br /></td></tr>
<tr class="memitem:a6d7c526102c09a75195c57ebf5f54a11" id="r_a6d7c526102c09a75195c57ebf5f54a11"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a6d7c526102c09a75195c57ebf5f54a11">all_input_ports_ticket</a> ()</td></tr>
<tr class="memdesc:a6d7c526102c09a75195c57ebf5f54a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on <em>all</em> input ports u of this system.  <br /></td></tr>
<tr class="memitem:abcd2ceca3da3b633da04d2f11c206b30" id="r_abcd2ceca3da3b633da04d2f11c206b30"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#abcd2ceca3da3b633da04d2f11c206b30">all_sources_except_input_ports_ticket</a> ()</td></tr>
<tr class="memdesc:abcd2ceca3da3b633da04d2f11c206b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on every possible independent source value <em>except</em> input ports.  <br /></td></tr>
<tr class="memitem:af0b9bc9f93181e042bdb2c36f4dbea10" id="r_af0b9bc9f93181e042bdb2c36f4dbea10"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a> ()</td></tr>
<tr class="memdesc:af0b9bc9f93181e042bdb2c36f4dbea10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on every possible independent source value, including time, accuracy, state, input ports, and parameters (but not cache entries).  <br /></td></tr>
<tr class="memitem:a28830dced98dcdc1f498d8d250db0ae4" id="r_a28830dced98dcdc1f498d8d250db0ae4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a28830dced98dcdc1f498d8d250db0ae4">configuration_ticket</a> ()</td></tr>
<tr class="memdesc:a28830dced98dcdc1f498d8d250db0ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all source values that may affect configuration-dependent computations.  <br /></td></tr>
<tr class="memitem:a1291b5091aa55dbd03c9b5944dbced09" id="r_a1291b5091aa55dbd03c9b5944dbced09"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a1291b5091aa55dbd03c9b5944dbced09">kinematics_ticket</a> ()</td></tr>
<tr class="memdesc:a1291b5091aa55dbd03c9b5944dbced09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket indicating dependence on all source values that may affect configuration- or velocity-dependent computations.  <br /></td></tr>
<tr class="memitem:ab42cd3bff14253894eb0a29edf843b3f" id="r_ab42cd3bff14253894eb0a29edf843b3f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#ab42cd3bff14253894eb0a29edf843b3f">xcdot_ticket</a> ()</td></tr>
<tr class="memdesc:ab42cd3bff14253894eb0a29edf843b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds time derivatives of the continuous variables.  <br /></td></tr>
<tr class="memitem:a49f1689b1ae9f05b6e2f194db873927b" id="r_a49f1689b1ae9f05b6e2f194db873927b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a49f1689b1ae9f05b6e2f194db873927b">pe_ticket</a> ()</td></tr>
<tr class="memdesc:a49f1689b1ae9f05b6e2f194db873927b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds the potential energy calculation.  <br /></td></tr>
<tr class="memitem:a66e1d9af27119011a497b78df6907b1a" id="r_a66e1d9af27119011a497b78df6907b1a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a66e1d9af27119011a497b78df6907b1a">ke_ticket</a> ()</td></tr>
<tr class="memdesc:a66e1d9af27119011a497b78df6907b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds the kinetic energy calculation.  <br /></td></tr>
<tr class="memitem:afdc60bc4c201f17bd35bf40c13a183b3" id="r_afdc60bc4c201f17bd35bf40c13a183b3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#afdc60bc4c201f17bd35bf40c13a183b3">pc_ticket</a> ()</td></tr>
<tr class="memdesc:afdc60bc4c201f17bd35bf40c13a183b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds the conservative power calculation.  <br /></td></tr>
<tr class="memitem:a0afc9712c887706c12039e871476f30c" id="r_a0afc9712c887706c12039e871476f30c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a0afc9712c887706c12039e871476f30c">pnc_ticket</a> ()</td></tr>
<tr class="memdesc:a0afc9712c887706c12039e871476f30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a ticket for the cache entry that holds the non-conservative power calculation.  <br /></td></tr>
<tr class="memitem:a5cf3c0c47d4d7a5b2a28a8c0e76a4811" id="r_a5cf3c0c47d4d7a5b2a28a8c0e76a4811"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a5cf3c0c47d4d7a5b2a28a8c0e76a4811">xd_unique_periodic_update_ticket</a> ()</td></tr>
<tr class="memdesc:a5cf3c0c47d4d7a5b2a28a8c0e76a4811"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Returns a ticket for the cache entry that holds the unique periodic discrete update computation.  <br /></td></tr>
<tr class="memitem:abbed6ab1f586a7b4d4a6131c6fa415ab" id="r_abbed6ab1f586a7b4d4a6131c6fa415ab"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#abbed6ab1f586a7b4d4a6131c6fa415ab">set_parent_service</a> (<a class="el" href="classdrake_1_1systems_1_1_system_base.html#a0b7f7189714d79a830e909e281324533">SystemBase</a> *child, const internal::SystemParentServiceInterface *parent_service)</td></tr>
<tr class="memdesc:abbed6ab1f586a7b4d4a6131c6fa415ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Declares that <span class="tt">parent_service</span> is the service interface of the <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> that owns this subsystem.  <br /></td></tr>
<tr class="memitem:a647a29d1660bcca523c4943cdc0ca1c8" id="r_a647a29d1660bcca523c4943cdc0ca1c8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#a647a29d1660bcca523c4943cdc0ca1c8">ThrowInputPortHasWrongType</a> (const char *func, const std::string &amp;system_pathname, <a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a>, const std::string &amp;port_name, const std::string &amp;expected_type, const std::string &amp;actual_type)</td></tr>
<tr class="memdesc:a647a29d1660bcca523c4943cdc0ca1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws std::exception because someone called API method <span class="tt">func</span> claiming the input port had some value type that was wrong.  <br /></td></tr>
<tr class="memitem:aafed5396ca3aeeb501eb4481486154f6" id="r_aafed5396ca3aeeb501eb4481486154f6"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structdrake_1_1systems_1_1_system_base_1_1_context_sizes.html">ContextSizes</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aafed5396ca3aeeb501eb4481486154f6">get_context_sizes</a> (const <a class="el" href="classdrake_1_1systems_1_1_system_base.html#a0b7f7189714d79a830e909e281324533">SystemBase</a> &amp;system)</td></tr>
<tr class="memdesc:aafed5396ca3aeeb501eb4481486154f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> to access protected <a class="el" href="classdrake_1_1systems_1_1_system_base.html#a1a1549d45dd51325abb27bce961aaea7" title="Obtains access to the declared Context partition sizes as accumulated during LeafSystem or Diagram co...">get_context_sizes()</a> recursively on its subsystems.  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a78eaec0a6a2d1c99d2a7eb5eeb1f8bdc" name="a78eaec0a6a2d1c99d2a7eb5eeb1f8bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78eaec0a6a2d1c99d2a7eb5eeb1f8bdc">&#9670;&#160;</a></span>Scalar</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a78eaec0a6a2d1c99d2a7eb5eeb1f8bdc">Scalar</a> = T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The scalar type with which this System was instantiated. </p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a718e74eb516f658aa9f80ab77706e4e5" name="a718e74eb516f658aa9f80ab77706e4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718e74eb516f658aa9f80ab77706e4e5">&#9670;&#160;</a></span>System() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">System </td>
          <td>(</td>
          <td class="paramtype">const System&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51e42f15501f79c6a60375041a7e3729" name="a51e42f15501f79c6a60375041a7e3729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e42f15501f79c6a60375041a7e3729">&#9670;&#160;</a></span>System() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">System </td>
          <td>(</td>
          <td class="paramtype">System&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abfc527f890d8846b751645ab81a67bb1" name="abfc527f890d8846b751645ab81a67bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc527f890d8846b751645ab81a67bb1">&#9670;&#160;</a></span>~System()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1b849c60d9ec6bbfeac42dc3c075a02" name="aa1b849c60d9ec6bbfeac42dc3c075a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b849c60d9ec6bbfeac42dc3c075a02">&#9670;&#160;</a></span>System() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">System </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_system_scalar_converter.html">SystemScalarConverter</a></td>          <td class="paramname"><span class="paramname"><em>converter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty System base class object and allocates base class resources, possibly supporting scalar-type conversion support (AutoDiff, etc.) using <code class="param">converter</code>. </p>
<p>See <a class="el" href="group__system__scalar__conversion.html">System Scalar Conversion</a> for detailed background and examples related to scalar-type conversion support. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a1a4ef0e0e633c6f722ee518308d7cb5a" name="a1a4ef0e0e633c6f722ee518308d7cb5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4ef0e0e633c6f722ee518308d7cb5a">&#9670;&#160;</a></span>abstract_parameter_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> abstract_parameter_ticket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1systems.html#a86b350169906f6d5e07e9db46e36d57a">AbstractParameterIndex</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a ticket indicating dependence on a particular abstract parameter paᵢ. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af3c65473a41f73091c600eaead714fe2" title="Returns a ticket indicating dependence on all of the abstract parameters pa in the current Context.">pa_ticket()</a> to obtain a ticket for <em><a class="el" href="namespacedrake.html#a6f017505f166d0b60735ba1c4a9b4f23" title="Checks truth for all elements in matrix m.">all</a></em> abstract parameters. </dd></dl>

</div>
</div>
<a id="a4a8d4f32034a610ea30a283699040708" name="a4a8d4f32034a610ea30a283699040708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8d4f32034a610ea30a283699040708">&#9670;&#160;</a></span>abstract_state_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> abstract_state_ticket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1systems.html#a8c3a27f43e356726f770159944adb929">AbstractStateIndex</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a ticket indicating dependence on a particular abstract state variable xaᵢ. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a19842775d11b50e5ae56abcc6d38ccc4" title="Returns a ticket indicating dependence on all of the abstract state variables in the current Context.">xa_ticket()</a> to obtain a ticket for <em><a class="el" href="namespacedrake.html#a6f017505f166d0b60735ba1c4a9b4f23" title="Checks truth for all elements in matrix m.">all</a></em> abstract variables. </dd></dl>

</div>
</div>
<a id="a8cb9e835ba22d40ee92cafd4ebee5813" name="a8cb9e835ba22d40ee92cafd4ebee5813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb9e835ba22d40ee92cafd4ebee5813">&#9670;&#160;</a></span>Accept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_system_visitor.html">SystemVisitor</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements a visitor pattern. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system_visitor.html" title="Provides a &quot;Visitor Pattern&quot; for System and Diagram.">SystemVisitor&lt;T&gt;</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#af1ae7c5586621d54d7b87de44171beb4">Diagram&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_diagram.html#af1ae7c5586621d54d7b87de44171beb4">Diagram&lt; double &gt;</a>.</p>

</div>
</div>
<a id="ad649083fc3bcb645671be3fad577d2ab" name="ad649083fc3bcb645671be3fad577d2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad649083fc3bcb645671be3fad577d2ab">&#9670;&#160;</a></span>accuracy_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> accuracy_ticket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a ticket indicating dependence on the accuracy setting in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. </p>
<p>This is the same ticket for all systems and refers to the same accuracy value. </p>

</div>
</div>
<a id="a1da97485fe927a5d199634ee0643456b" name="a1da97485fe927a5d199634ee0643456b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da97485fe927a5d199634ee0643456b">&#9670;&#160;</a></span>AddConstraint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a> AddConstraint </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_system_constraint.html">SystemConstraint</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>constraint</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an already-created constraint to the list of constraints for this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>. </p>
<p>Ownership of the <a class="el" href="classdrake_1_1systems_1_1_system_constraint.html" title="A SystemConstraint is a generic base-class for constraints on Systems.">SystemConstraint</a> is transferred to this system. </p>

</div>
</div>
<a id="ad97e05bf6c16c4bbf058d3cd4978f696" name="ad97e05bf6c16c4bbf058d3cd4978f696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97e05bf6c16c4bbf058d3cd4978f696">&#9670;&#160;</a></span>AddExternalConstraint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a> AddExternalConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_external_system_constraint.html">ExternalSystemConstraint</a></td>          <td class="paramname"><span class="paramname"><em>constraint</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an "external" constraint to this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>. </p>
<p>This method is intended for use by applications that are examining this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> to add additional constraints based on their particular situation (e.g., that a velocity state element has an upper bound); it is not intended for declaring intrinsic constraints that some particular <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> subclass might always impose on itself (e.g., that a mass parameter is non-negative). To that end, this method should not be called by subclasses of <span class="tt">this</span> during their constructor.</p>
<p>The <span class="tt">constraint</span> will automatically persist across system scalar conversion. </p>

</div>
</div>
<a id="a838b32b3b596aae6c11fa9c19e655407" name="a838b32b3b596aae6c11fa9c19e655407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838b32b3b596aae6c11fa9c19e655407">&#9670;&#160;</a></span>AddTriggeredWitnessFunctionToCompositeEventCollection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AddTriggeredWitnessFunctionToCompositeEventCollection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_event.html">Event</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>event</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>events</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add <span class="tt">event</span> to <span class="tt">events</span> due to a witness function triggering. </p>
<p><span class="tt">events</span> should be allocated with this system's AllocateCompositeEventCollection. Neither <span class="tt">event</span> nor <span class="tt">events</span> can be nullptr. Additionally, <span class="tt">event</span> must contain event data (event-&gt;get_event_data() must not be nullptr) and the type of that data must be <a class="el" href="classdrake_1_1systems_1_1_witness_triggered_event_data.html" title="An event data variant for storing data from a witness function triggering to be passed to event handl...">WitnessTriggeredEventData</a>. </p>

<p>Implemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#af3167bd30bfa014aa61d55fb50ed36f9">Diagram&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#af3167bd30bfa014aa61d55fb50ed36f9">Diagram&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#af3167bd30bfa014aa61d55fb50ed36f9">LeafSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#af3167bd30bfa014aa61d55fb50ed36f9">LeafSystem&lt; double &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#af3167bd30bfa014aa61d55fb50ed36f9">LeafSystem&lt; drake::ad::AutoDiff &gt;</a>.</p>

</div>
</div>
<a id="a6d7c526102c09a75195c57ebf5f54a11" name="a6d7c526102c09a75195c57ebf5f54a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7c526102c09a75195c57ebf5f54a11">&#9670;&#160;</a></span>all_input_ports_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> all_input_ports_ticket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a ticket indicating dependence on <em>all</em> input ports u of this system. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a191b7cb5dcbfee51a62fa042ec14561f" title="Returns a ticket indicating dependence on input port uᵢ indicated by index.">input_port_ticket()</a> to obtain a ticket for just one input port. </dd></dl>

</div>
</div>
<a id="ad6b63a1cb8922051fb1a7fe4b56092bf" name="ad6b63a1cb8922051fb1a7fe4b56092bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b63a1cb8922051fb1a7fe4b56092bf">&#9670;&#160;</a></span>all_parameters_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> all_parameters_ticket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a ticket indicating dependence on <em>all</em> parameters p in this system, including numeric parameters pn, and abstract parameters pa. </p>

</div>
</div>
<a id="af0b9bc9f93181e042bdb2c36f4dbea10" name="af0b9bc9f93181e042bdb2c36f4dbea10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b9bc9f93181e042bdb2c36f4dbea10">&#9670;&#160;</a></span>all_sources_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> all_sources_ticket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a ticket indicating dependence on every possible independent source value, including time, accuracy, state, input ports, and parameters (but not cache entries). </p>
<p>This is the default dependency for computations that have not specified anything more refined. It is equivalent to the set <span class="tt">{<a class="el" href="classdrake_1_1systems_1_1_system_base.html#abcd2ceca3da3b633da04d2f11c206b30" title="Returns a ticket indicating dependence on every possible independent source value except input ports.">all_sources_except_input_ports_ticket()</a>, <a class="el" href="#a6d7c526102c09a75195c57ebf5f54a11" title="Returns a ticket indicating dependence on all input ports u of this system.">all_input_ports_ticket()</a>}</span>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7e92c6f01c04b3591d642d27a467b093" title="Returns a ticket indicating dependence on the cache entry indicated by index.">cache_entry_ticket()</a> to obtain a ticket for a cache entry. </dd></dl>

</div>
</div>
<a id="a2789768c5d75378c081683a8016f0784" name="a2789768c5d75378c081683a8016f0784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2789768c5d75378c081683a8016f0784">&#9670;&#160;</a></span>all_state_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> all_state_ticket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a ticket indicating dependence on <em>all</em> state variables x in this system, including continuous variables xc, discrete (numeric) variables xd, and abstract state variables xa. </p>
<p>This does not imply dependence on time, accuracy, parameters, or inputs; those must be specified separately. If you mean to express dependence on all possible value sources, use <a class="el" href="#af0b9bc9f93181e042bdb2c36f4dbea10" title="Returns a ticket indicating dependence on every possible independent source value,...">all_sources_ticket()</a> instead. </p>

</div>
</div>
<a id="a6cc7dd6cf032c4b3137de55349d8e99b" name="a6cc7dd6cf032c4b3137de55349d8e99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc7dd6cf032c4b3137de55349d8e99b">&#9670;&#160;</a></span>AllocateCompositeEventCollection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; &gt; AllocateCompositeEventCollection </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html" title="This class bundles an instance of each EventCollection&lt;EventType&gt; into one object that stores the het...">CompositeEventCollection</a> for this system. </p>
<p>The allocated instance is used for populating collections of triggered events; for example, <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> passes this object to <a class="el" href="#a164afe3c1db737b93696b8808bb2c942" title="This method is called by a Simulator during its calculation of the size of the next continuous step t...">System::CalcNextUpdateTime()</a> to allow the system to identify and handle upcoming events. </p>

</div>
</div>
<a id="a78fda6d982dc968061c5d92e32173629" name="a78fda6d982dc968061c5d92e32173629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fda6d982dc968061c5d92e32173629">&#9670;&#160;</a></span>AllocateContext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &gt; AllocateContext </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Returns an <b>uninitialized</b> <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context&lt;T&gt;</a> suitable for use with this System&lt;T&gt;. </p>
<p>Most users should use <a class="el" href="#aa036f873464a74c03fab943bbace8942" title="This convenience method allocates a context using AllocateContext() and sets its default values using...">CreateDefaultContext()</a>, instead. </p><dl class="section warning"><dt>Warning</dt><dd>The returned context is uninitialized (contains invalid data). It is useful for pre-allocating storage which will later be overwritten (e.g., by <a class="el" href="#ab4e6ee413f4f47a20f6dcc2cbd831b88" title="Sets Context fields to their default values.">SetDefaultContext()</a> or <a class="el" href="classdrake_1_1systems_1_1_context.html#ae55845b172939052d02ea437df63cfbc" title="Copies time, accuracy, all state and all parameters in source, where numerical values are of type U,...">Context&lt;T&gt;::SetTimeStateAndParametersFrom()</a>) and <b>must not</b> be used for any calculations until it's been overwritten. </dd></dl>

</div>
</div>
<a id="ad67b4bb437d72bc3ee99a4c66ad51b6f" name="ad67b4bb437d72bc3ee99a4c66ad51b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67b4bb437d72bc3ee99a4c66ad51b6f">&#9670;&#160;</a></span>AllocateDiscreteVariables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; &gt; AllocateDiscreteVariables </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classdrake_1_1systems_1_1_discrete_values.html" title="DiscreteValues is a container for numerical but non-continuous state and parameters.">DiscreteValues</a> of the same dimensions as the discrete_state allocated in CreateDefaultContext. </p>
<p>The simulator will provide this state as the output argument to Update. </p>

<p>Implemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a75a46315bf6c86eefd7e4cf0f600c7ae">Diagram&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a75a46315bf6c86eefd7e4cf0f600c7ae">Diagram&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a75a46315bf6c86eefd7e4cf0f600c7ae">LeafSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a75a46315bf6c86eefd7e4cf0f600c7ae">LeafSystem&lt; double &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a75a46315bf6c86eefd7e4cf0f600c7ae">LeafSystem&lt; drake::ad::AutoDiff &gt;</a>.</p>

</div>
</div>
<a id="a47ec86445724fd77391af7874bfc4848" name="a47ec86445724fd77391af7874bfc4848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ec86445724fd77391af7874bfc4848">&#9670;&#160;</a></span>AllocateFixedInputs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AllocateFixedInputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each input port, allocates a fixed input of the concrete type that this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> requires, and binds it to the port, disconnecting any prior input. </p>
<p>Does not assign any values to the fixed inputs. </p>

</div>
</div>
<a id="a7bb970a7568116aa65af6d2526ff5977" name="a7bb970a7568116aa65af6d2526ff5977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb970a7568116aa65af6d2526ff5977">&#9670;&#160;</a></span>AllocateImplicitTimeDerivativesResidual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; AllocateImplicitTimeDerivativesResidual </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85" title="A column vector of any size, templated on scalar type.">VectorX</a> suitable for use as the output argument to the <a class="el" href="#a8debe7d25e61fd759c918d889286525f" title="Evaluates the implicit form of the System equations and returns the residual.">CalcImplicitTimeDerivativesResidual()</a> method. </p>
<p>The returned <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85" title="A column vector of any size, templated on scalar type.">VectorX</a> will have size <a class="el" href="classdrake_1_1systems_1_1_system_base.html#aba0bd9017cbe1fbf0f02912f0d45fd10" title="Returns the size of the implicit time derivatives residual vector.">implicit_time_derivatives_residual_size()</a> with the elements uninitialized. This is just a convenience method &ndash; you are free to use any properly-sized mutable Eigen object as the residual vector. </p>

</div>
</div>
<a id="a69db7d7d92345c74487bc38c5d136a07" name="a69db7d7d92345c74487bc38c5d136a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69db7d7d92345c74487bc38c5d136a07">&#9670;&#160;</a></span>AllocateInputAbstract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a> &gt; AllocateInputAbstract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>input_port</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an input port, allocates the abstract storage. </p>
<p>The <code class="param">input_port</code> must match a port declared via DeclareInputPort. </p>

</div>
</div>
<a id="ab7ce7f3c3ed819de001d4ab977ee65bf" name="ab7ce7f3c3ed819de001d4ab977ee65bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ce7f3c3ed819de001d4ab977ee65bf">&#9670;&#160;</a></span>AllocateInputVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html">BasicVector</a>&lt; T &gt; &gt; AllocateInputVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>input_port</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an input port, allocates the vector storage. </p>
<p>The <code class="param">input_port</code> must match a port declared via DeclareInputPort. </p>

</div>
</div>
<a id="af46c35210719be2e1035e14ea9a11299" name="af46c35210719be2e1035e14ea9a11299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46c35210719be2e1035e14ea9a11299">&#9670;&#160;</a></span>AllocateOutput()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_system_output.html">SystemOutput</a>&lt; T &gt; &gt; AllocateOutput </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a container that can hold the values of all of this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>'s output ports. </p>
<p>It is sized with the number of output ports and uses each output port's allocation method to provide an object of the right type for that port. </p>

</div>
</div>
<a id="a672f9ea75065ea78820a04982cca899c" name="a672f9ea75065ea78820a04982cca899c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672f9ea75065ea78820a04982cca899c">&#9670;&#160;</a></span>AllocateTimeDerivatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &gt; AllocateTimeDerivatives </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html" title="ContinuousState is a view of, and optionally a container for, all the continuous state variables xc o...">ContinuousState</a> of the same size as the continuous_state allocated in CreateDefaultContext. </p>
<p>The simulator will provide this state as the output argument to EvalTimeDerivatives. </p>

<p>Implemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#ad305239ecbafb0545520bb5b2898312d">Diagram&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#ad305239ecbafb0545520bb5b2898312d">Diagram&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ad305239ecbafb0545520bb5b2898312d">LeafSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ad305239ecbafb0545520bb5b2898312d">LeafSystem&lt; double &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ad305239ecbafb0545520bb5b2898312d">LeafSystem&lt; drake::ad::AutoDiff &gt;</a>.</p>

</div>
</div>
<a id="a7fd83875ab52bec063989cd186980fef" name="a7fd83875ab52bec063989cd186980fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd83875ab52bec063989cd186980fef">&#9670;&#160;</a></span>ApplyDiscreteVariableUpdate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ApplyDiscreteVariableUpdate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>events</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>discrete_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the <code class="param">discrete_state</code> results of a previous call to <a class="el" href="#ac520da0941e15dff2045e3c8701dfdab" title="This method is the public entry point for dispatching all discrete variable update event handlers.">CalcDiscreteVariableUpdate()</a> that dispatched the given collection of events, modifies the <code class="param">context</code> to reflect the updated <code class="param">discrete_state</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">events</td><td>The <a class="el" href="classdrake_1_1systems_1_1_event.html" title="Abstract base class that represents an event.">Event</a> collection that resulted in the given <code class="param">discrete_state</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">discrete_state</td><td>The updated discrete state from a <a class="el" href="#ac520da0941e15dff2045e3c8701dfdab" title="This method is the public entry point for dispatching all discrete variable update event handlers.">CalcDiscreteVariableUpdate()</a> call. This is mutable to permit its contents to be swapped with the corresponding <code class="param">context</code> contents (rather than copied). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">context</td><td>The <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> whose discrete state is modified to match <code class="param">discrete_state</code>. Note that swapping contents with <code class="param">discrete_state</code> may cause addresses of individual discrete state group vectors in <code class="param">context</code> to be different on return than they were on entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code class="param">discrete_state</code> is the result of a previous <a class="el" href="#ac520da0941e15dff2045e3c8701dfdab" title="This method is the public entry point for dispatching all discrete variable update event handlers.">CalcDiscreteVariableUpdate()</a> call that dispatched this <code class="param">events</code> collection. </dd></dl>

</div>
</div>
<a id="a35a230308db94f60cc1b813bca064f6e" name="a35a230308db94f60cc1b813bca064f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a230308db94f60cc1b813bca064f6e">&#9670;&#160;</a></span>ApplyUnrestrictedUpdate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ApplyUnrestrictedUpdate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>events</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the <code class="param">state</code> results of a previous call to <a class="el" href="#a6af241ea78c280884f5f638f68426e28" title="This method is the public entry point for dispatching all unrestricted update event handlers.">CalcUnrestrictedUpdate()</a> that dispatched the given collection of events, modifies the <code class="param">context</code> to reflect the updated <code class="param">state</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">events</td><td>The <a class="el" href="classdrake_1_1systems_1_1_event.html" title="Abstract base class that represents an event.">Event</a> collection that resulted in the given <code class="param">state</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">state</td><td>The updated <a class="el" href="classdrake_1_1systems_1_1_state.html" title="State is a container for all the data comprising the complete state of a particular System at a parti...">State</a> from a <a class="el" href="#a6af241ea78c280884f5f638f68426e28" title="This method is the public entry point for dispatching all unrestricted update event handlers.">CalcUnrestrictedUpdate()</a> call. This is mutable to permit its contents to be swapped with the corresponding <code class="param">context</code> contents (rather than copied). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">context</td><td>The <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> whose <a class="el" href="classdrake_1_1systems_1_1_state.html" title="State is a container for all the data comprising the complete state of a particular System at a parti...">State</a> is modified to match <code class="param">state</code>. Note that swapping contents with the <code class="param">state</code> may cause addresses of continuous, discrete, and abstract state containers in <code class="param">context</code> to be different on return than they were on entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code class="param">state</code> is the result of a previous <a class="el" href="#a6af241ea78c280884f5f638f68426e28" title="This method is the public entry point for dispatching all unrestricted update event handlers.">CalcUnrestrictedUpdate()</a> call that dispatched this <code class="param">events</code> collection. </dd></dl>

</div>
</div>
<a id="a7e92c6f01c04b3591d642d27a467b093" name="a7e92c6f01c04b3591d642d27a467b093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e92c6f01c04b3591d642d27a467b093">&#9670;&#160;</a></span>cache_entry_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> cache_entry_ticket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1systems.html#a06ac9ad764b14ccff79b6feb393be498">CacheIndex</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a ticket indicating dependence on the cache entry indicated by <span class="tt">index</span>. </p>
<p>Note that cache entries are <em>not</em> included in the <span class="tt">all_sources</span> ticket so must be listed separately. </p><dl class="section pre"><dt>Precondition</dt><dd><span class="tt">index</span> selects an existing cache entry in this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>. </dd></dl>

</div>
</div>
<a id="a5674ae416c2808c939dffc117b209f23" name="a5674ae416c2808c939dffc117b209f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5674ae416c2808c939dffc117b209f23">&#9670;&#160;</a></span>CalcConservativePower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T CalcConservativePower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates and returns the conservative power represented by the current contents of the given <span class="tt">context</span>. </p>
<p>Prefer <a class="el" href="#a94bf4d9472a96aad5d65e47375cf035f" title="Returns a reference to the cached value of the conservative power (Pc), evaluating first if necessary...">EvalConservativePower()</a> to avoid unnecessary recalculation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a94bf4d9472a96aad5d65e47375cf035f" title="Returns a reference to the cached value of the conservative power (Pc), evaluating first if necessary...">EvalConservativePower()</a> for more information. </dd></dl>

</div>
</div>
<a id="ac520da0941e15dff2045e3c8701dfdab" name="ac520da0941e15dff2045e3c8701dfdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac520da0941e15dff2045e3c8701dfdab">&#9670;&#160;</a></span>CalcDiscreteVariableUpdate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_event_status.html">EventStatus</a> CalcDiscreteVariableUpdate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>events</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>discrete_state</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is the public entry point for dispatching all discrete variable update event handlers. </p>
<p>Using all the discrete update handlers in <code class="param">events</code>, the method calculates the update <span class="tt">xd(n+1)</span> to discrete variables <span class="tt">xd(n)</span> in <code class="param">context</code> and outputs the results to <code class="param">discrete_state</code>. See documentation for <a class="el" href="#ac9457822be4fc7aabaef0beb95b4264a" title="(Internal use only) This function dispatches all discrete update events to the appropriate handlers.">DispatchDiscreteVariableUpdateHandler()</a> for more details. </p>

</div>
</div>
<a id="ae5fb4376d5f80e2fbaecae478c2ab10b" name="ae5fb4376d5f80e2fbaecae478c2ab10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5fb4376d5f80e2fbaecae478c2ab10b">&#9670;&#160;</a></span>CalcForcedDiscreteVariableUpdate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CalcForcedDiscreteVariableUpdate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>discrete_state</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Manually triggers any <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html" title="This class represents a discrete update event.">DiscreteUpdateEvent</a> that has trigger type kForced. </p>
<p>Invokes the discrete event dispatcher on this System with the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> providing the initial values for the discrete variables. The updated values of the discrete variables are written to the <span class="tt">discrete_state</span> output argument; no change is made to the Context.</p>
<p>The default dispatcher will invoke the handlers (if any) associated with each force-triggered event.</p>
<dl class="section note"><dt>Note</dt><dd>There will always be at least one force-triggered event, though with no associated handler. By default that will do nothing when triggered, but that behavior can be changed by overriding the dispatcher (not recommended).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if it invokes an event handler that returns status indicating failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac520da0941e15dff2045e3c8701dfdab" title="This method is the public entry point for dispatching all discrete variable update event handlers.">CalcDiscreteVariableUpdate()</a>, <a class="el" href="#a38e86af4aa006febb699db0433d434da" title="(Advanced) Manually triggers any UnrestrictedUpdateEvent that has trigger type kForced.">CalcForcedUnrestrictedUpdate()</a> </dd></dl>

</div>
</div>
<a id="a38e86af4aa006febb699db0433d434da" name="a38e86af4aa006febb699db0433d434da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e86af4aa006febb699db0433d434da">&#9670;&#160;</a></span>CalcForcedUnrestrictedUpdate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CalcForcedUnrestrictedUpdate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Manually triggers any <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html" title="This class represents an unrestricted update event.">UnrestrictedUpdateEvent</a> that has trigger type kForced. </p>
<p>Invokes the unrestricted event dispatcher on this System with the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> providing the initial values for the state variables. The updated values of the state variables are written to the <span class="tt">state</span> output argument; no change is made to the Context.</p>
<p>The default dispatcher will invoke the handlers (if any) associated with each force-triggered event.</p>
<dl class="section note"><dt>Note</dt><dd>There will always be at least one force-triggered event, though with no associated handler. By default that will do nothing when triggered, but that behavior can be changed by overriding the dispatcher (not recommended).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if it invokes an event handler that returns status indicating failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a6af241ea78c280884f5f638f68426e28" title="This method is the public entry point for dispatching all unrestricted update event handlers.">CalcUnrestrictedUpdate()</a> </dd></dl>

</div>
</div>
<a id="a8debe7d25e61fd759c918d889286525f" name="a8debe7d25e61fd759c918d889286525f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8debe7d25e61fd759c918d889286525f">&#9670;&#160;</a></span>CalcImplicitTimeDerivativesResidual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CalcImplicitTimeDerivativesResidual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>proposed_derivatives</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>residual</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the implicit form of the System equations and returns the residual. </p>
<p>The explicit and implicit forms of the System equations are </p><pre class="fragment">(1) ẋ꜀ = fₑ(𝓒)            explicit
(2) 0 = fᵢ(𝓒; ẋ꜀)         implicit
</pre><p>where <span class="tt">𝓒 = {a, p, t, x, u}</span> is the current value of the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> from which accuracy a, parameters p, time t, state x (<span class="tt">={x꜀ xd xₐ}</span>) and input values u are obtained. Substituting (1) into (2) shows that the following condition must always hold: </p><pre class="fragment">(3) fᵢ(𝓒; fₑ(𝓒)) = 0      always true
</pre><p>When <span class="tt">fᵢ(𝓒; ẋ꜀ₚ)</span> is evaluated with a proposed time derivative ẋ꜀ₚ that differs from ẋ꜀ the result will be non-zero; we call that the <em>residual</em> of the implicit equation. Given a <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> and proposed time derivative ẋ꜀ₚ, this method returns the residual r such that </p><pre class="fragment">(4) r = fᵢ(𝓒; ẋ꜀ₚ).
</pre><p>The returned r will typically be the same length as x꜀ although that is not required. And even if r and x꜀ are the same size, there will not necessarily be any elementwise correspondence between them. (That is, you should not assume that r[i] is the "residual" of ẋ꜀ₚ[i].) For a <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a>, r is the concatenation of residuals from each of the subsystems, in order of subsystem index within the <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a>.</p>
<p>A default implementation fᵢ⁽ᵈᵉᶠ⁾ for the implicit form is always provided and makes use of the explicit form as follows: </p><pre class="fragment">(5) fᵢ⁽ᵈᵉᶠ⁾(𝓒; ẋ꜀ₚ) ≜ ẋ꜀ₚ − fₑ(𝓒)
</pre><p>which satisfies condition (3) by construction. (Note that the default implementation requires the residual to have the same size as x꜀.) Substantial efficiency gains can often be obtained by replacing the default function with a customized implementation. Override <a class="el" href="#a1612bbeeab77dfe57f08df56b7869a68" title="Override this if you have an efficient way to evaluate the implicit time derivatives residual for thi...">DoCalcImplicitTimeDerivativesResidual()</a> to replace the default implementation with a better one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The source for time, state, inputs, etc. to be used in calculating the residual. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">proposed_derivatives</td><td>The proposed value ẋ꜀ₚ for the time derivatives of x꜀. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">residual</td><td>The result r of evaluating the implicit function. Can be any mutable Eigen vector object of size <a class="el" href="classdrake_1_1systems_1_1_system_base.html#aba0bd9017cbe1fbf0f02912f0d45fd10" title="Returns the size of the implicit time derivatives residual vector.">implicit_time_derivatives_residual_size()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">proposed_derivatives</span> is compatible with this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>. </dd>
<dd>
<span class="tt">residual</span> is of size <a class="el" href="classdrake_1_1systems_1_1_system_base.html#aba0bd9017cbe1fbf0f02912f0d45fd10" title="Returns the size of the implicit time derivatives residual vector.">implicit_time_derivatives_residual_size()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system_base.html#aba0bd9017cbe1fbf0f02912f0d45fd10" title="Returns the size of the implicit time derivatives residual vector.">SystemBase::implicit_time_derivatives_residual_size()</a> </dd>
<dd>
<a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#af35335637b5cf1c763d5e9112864fe09" title="(Advanced) Overrides the default size for the implicit time derivatives residual.">LeafSystem::DeclareImplicitTimeDerivativesResidualSize()</a> </dd>
<dd>
<a class="el" href="#a1612bbeeab77dfe57f08df56b7869a68" title="Override this if you have an efficient way to evaluate the implicit time derivatives residual for thi...">DoCalcImplicitTimeDerivativesResidual()</a> </dd>
<dd>
<a class="el" href="#af2677f8773e90a538483eedd80a81a9f" title="Calculates the time derivatives ẋ꜀ of the continuous state x꜀ into a given output argument.">CalcTimeDerivatives()</a> </dd></dl>

</div>
</div>
<a id="aad01402fef0de79310989d7d22dfde92" name="aad01402fef0de79310989d7d22dfde92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad01402fef0de79310989d7d22dfde92">&#9670;&#160;</a></span>CalcKineticEnergy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T CalcKineticEnergy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates and returns the kinetic energy represented by the current configuration and velocity provided in <span class="tt">context</span>. </p>
<p>Prefer <a class="el" href="#abfc345ff50df77ad2ae727e6d3a9b939" title="Returns a reference to the cached value of the kinetic energy (KE), evaluating first if necessary usi...">EvalKineticEnergy()</a> to avoid unnecessary recalculation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#abfc345ff50df77ad2ae727e6d3a9b939" title="Returns a reference to the cached value of the kinetic energy (KE), evaluating first if necessary usi...">EvalKineticEnergy()</a> for more information. </dd></dl>

</div>
</div>
<a id="a164afe3c1db737b93696b8808bb2c942" name="a164afe3c1db737b93696b8808bb2c942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164afe3c1db737b93696b8808bb2c942">&#9670;&#160;</a></span>CalcNextUpdateTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T CalcNextUpdateTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>events</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is called by a <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> during its calculation of the size of the next continuous step to attempt. </p>
<p>The <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> returns the next time at which some discrete action must be taken, and records what those actions ought to be in <code class="param">events</code>. Upon reaching that time, the simulator will merge <code class="param">events</code> with the other <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html" title="This class bundles an instance of each EventCollection&lt;EventType&gt; into one object that stores the het...">CompositeEventCollection</a> instances triggered through other mechanisms (e.g. <a class="el" href="#ad8a24b8f910f9d990db8e59bf2bae6d0" title="This method is called by Simulator::Initialize() to gather all update and publish events that are to ...">GetPerStepEvents()</a>), and the merged <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html" title="This class bundles an instance of each EventCollection&lt;EventType&gt; into one object that stores the het...">CompositeEventCollection</a> will be passed to all event handling mechanisms.</p>
<p>Despite the name, the returned events includes both state-updating events and publish events.</p>
<p>If there is no timed event coming, the return value is Infinity. If a finite update time is returned, there will be at least one <a class="el" href="classdrake_1_1systems_1_1_event.html" title="Abstract base class that represents an event.">Event</a> object in the returned event collection.</p>
<p><code class="param">events</code> cannot be null. <code class="param">events</code> will be cleared on entry. </p>

</div>
</div>
<a id="a23fe133b70153e382d7f50c38b96bf1f" name="a23fe133b70153e382d7f50c38b96bf1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23fe133b70153e382d7f50c38b96bf1f">&#9670;&#160;</a></span>CalcNonConservativePower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T CalcNonConservativePower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates and returns the non-conservative power represented by the current contents of the given <span class="tt">context</span>. </p>
<p>Prefer <a class="el" href="#a08ed6bf23e134cbc50d073e81ffc247f" title="Returns a reference to the cached value of the non-conservative power (Pnc), evaluating first if nece...">EvalNonConservativePower()</a> to avoid unnecessary recalculation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a08ed6bf23e134cbc50d073e81ffc247f" title="Returns a reference to the cached value of the non-conservative power (Pnc), evaluating first if nece...">EvalNonConservativePower()</a> for more information. </dd></dl>

</div>
</div>
<a id="a574467e50cf5c242f665557daca33111" name="a574467e50cf5c242f665557daca33111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574467e50cf5c242f665557daca33111">&#9670;&#160;</a></span>CalcOutput()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CalcOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_system_output.html">SystemOutput</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>outputs</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method that computes for <em>every</em> output port i the value y(i) that should result from the current contents of the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. </p>
<p>Note that individual output port values can be calculated using <span class="tt">get_output_port(i).Calc()</span>; this method invokes that for each output port in index order. The result may depend on time and the current values of input ports, parameters, and state variables. The result is written to <span class="tt">outputs</span> which must already have been allocated to have the right number of entries of the right types. </p>

</div>
</div>
<a id="a3d5eb1d2630aab1938230257554d1f43" name="a3d5eb1d2630aab1938230257554d1f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5eb1d2630aab1938230257554d1f43">&#9670;&#160;</a></span>CalcPotentialEnergy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T CalcPotentialEnergy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates and returns the potential energy represented by the current configuration provided in <span class="tt">context</span>. </p>
<p>Prefer <a class="el" href="#a97c1ac3506af8f2c386ba74b5fbc1e48" title="Returns a reference to the cached value of the potential energy (PE), evaluating first if necessary u...">EvalPotentialEnergy()</a> to avoid unnecessary recalculation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a97c1ac3506af8f2c386ba74b5fbc1e48" title="Returns a reference to the cached value of the potential energy (PE), evaluating first if necessary u...">EvalPotentialEnergy()</a> for more information. </dd></dl>

</div>
</div>
<a id="af2677f8773e90a538483eedd80a81a9f" name="af2677f8773e90a538483eedd80a81a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2677f8773e90a538483eedd80a81a9f">&#9670;&#160;</a></span>CalcTimeDerivatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CalcTimeDerivatives </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>derivatives</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the time derivatives ẋ꜀ of the continuous state x꜀ into a given output argument. </p>
<p>Prefer <a class="el" href="#a15b6e794826488cdb01ef10a2b21a5dd" title="Returns a reference to the cached value of the continuous state variable time derivatives,...">EvalTimeDerivatives()</a> instead to avoid unnecessary recomputation.</p>
<p>This method solves the System equations in explicit form: </p><pre class="fragment">ẋ꜀ = fₑ(𝓒)
</pre><p>where <span class="tt">𝓒 = {a, p, t, x, u}</span> is the current value of the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> from which accuracy a, parameters p, time t, state x (<span class="tt">={x꜀ xd xₐ}</span>) and input values u are obtained.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The source for time, state, inputs, etc. defining the point at which the derivatives should be calculated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">derivatives</td><td>The time derivatives ẋ꜀. Must be the same size as the continuous state vector in <span class="tt">context</span>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a15b6e794826488cdb01ef10a2b21a5dd" title="Returns a reference to the cached value of the continuous state variable time derivatives,...">EvalTimeDerivatives()</a> for more information. </dd>
<dd>
<a class="el" href="#a8debe7d25e61fd759c918d889286525f" title="Evaluates the implicit form of the System equations and returns the residual.">CalcImplicitTimeDerivativesResidual()</a> for the implicit form of these equations. </dd></dl>

</div>
</div>
<a id="a6af241ea78c280884f5f638f68426e28" name="a6af241ea78c280884f5f638f68426e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af241ea78c280884f5f638f68426e28">&#9670;&#160;</a></span>CalcUnrestrictedUpdate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_event_status.html">EventStatus</a> CalcUnrestrictedUpdate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>events</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is the public entry point for dispatching all unrestricted update event handlers. </p>
<p>Using all the unrestricted update handlers in <code class="param">events</code>, it updates <em>any</em> state variables in the <code class="param">context</code>, and outputs the results to <code class="param">state</code>. It does not allow the dimensionality of the state variables to change. See the documentation for <a class="el" href="#a28700b2d1c21cd7956f9a68fd3f1fd2e" title="(Internal use only) This function dispatches all unrestricted update events to the appropriate handle...">DispatchUnrestrictedUpdateHandler()</a> for more details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the dimensionality of the state variables changes in the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2949deb61db7903dae4c0b7cb9633fac" name="a2949deb61db7903dae4c0b7cb9633fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2949deb61db7903dae4c0b7cb9633fac">&#9670;&#160;</a></span>CalcWitnessValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T CalcWitnessValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>witness_func</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a witness function at the given context. </p>

</div>
</div>
<a id="a75fef66587073b52e0e69c84a736bd72" name="a75fef66587073b52e0e69c84a736bd72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75fef66587073b52e0e69c84a736bd72">&#9670;&#160;</a></span>CheckSystemConstraintsSatisfied()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt; CheckSystemConstraintsSatisfied </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tol</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code class="param">context</code> satisfies all of the registered SystemConstraints with tolerance <code class="param">tol</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_system_constraint.html#ad3f53cdfa63d96ca565f65b29dbdc03a" title="Evaluates the function pointer, and check if all of the outputs are within the desired bounds.">SystemConstraint::CheckSatisfied</a>. </dd></dl>

</div>
</div>
<a id="ad0a03a7f6f5f95c30952aac17c46c3b4" name="ad0a03a7f6f5f95c30952aac17c46c3b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a03a7f6f5f95c30952aac17c46c3b4">&#9670;&#160;</a></span>Clone() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; T &gt; &gt; Clone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a deep copy of this system. </p>
<p>Even though the cloned system is functionally identical, any contexts created for this system are not compatible with the cloned system, and vice versa.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_context.html#ae55845b172939052d02ea437df63cfbc" title="Copies time, accuracy, all state and all parameters in source, where numerical values are of type U,...">Context::SetTimeStateAndParametersFrom()</a> for how to copy context data between clones.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This implementation is somewhat incomplete at the moment. Many systems will not be able to be cloned, and will throw an exception instead. To be cloned, at minimum a system must support scalar conversion. See <a class="el" href="group__system__scalar__conversion.html">System Scalar Conversion</a>.</dd></dl>
<p>The result is never nullptr. </p>

</div>
</div>
<a id="a619dc4f1c01b7bae6019aefd5d0d7eca" name="a619dc4f1c01b7bae6019aefd5d0d7eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619dc4f1c01b7bae6019aefd5d0d7eca">&#9670;&#160;</a></span>Clone() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename &gt; class S = ::drake::systems::System&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; S&lt; T &gt; &gt; Clone </td>
          <td>(</td>
          <td class="paramtype">const S&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a deep copy of this system. </p>
<p>In contrast with the instance member function <span class="tt">sys.Clone()</span>, this static member function <span class="tt">Clone(sys)</span> is useful for C++ users to preserve the <b>declared</b> type of the system being cloned in the returned pointer. (For both clone overloads, the <b>runtime</b> type is always the same.)</p>
<p>Even though the cloned system is functionally identical, any contexts created for this system are not compatible with the cloned system, and vice versa.</p>
<dl class="section warning"><dt>Warning</dt><dd>This implementation is somewhat incomplete at the moment. Many systems will not be able to be cloned, and will throw an exception instead. To be cloned, at minimum a system must support scalar conversion. See <a class="el" href="group__system__scalar__conversion.html">System Scalar Conversion</a>.</dd></dl>
<p>The result is never nullptr.</p>
<p>Usage: </p><div class="fragment"><div class="line">MySystem&lt;double&gt; plant;</div>
<div class="line">unique_ptr&lt;MySystem&lt;double&gt;&gt; copy = <a class="code hl_function" href="#ad0a03a7f6f5f95c30952aac17c46c3b4">System&lt;double&gt;::Clone</a>(plant);</div>
<div class="ttc" id="aclassdrake_1_1systems_1_1_system_html_ad0a03a7f6f5f95c30952aac17c46c3b4"><div class="ttname"><a href="#ad0a03a7f6f5f95c30952aac17c46c3b4">drake::systems::System::Clone</a></div><div class="ttdeci">std::unique_ptr&lt; System&lt; T &gt; &gt; Clone() const</div><div class="ttdoc">Creates a deep copy of this system.</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The specific <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> type to accept and return. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28830dced98dcdc1f498d8d250db0ae4" name="a28830dced98dcdc1f498d8d250db0ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28830dced98dcdc1f498d8d250db0ae4">&#9670;&#160;</a></span>configuration_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> configuration_ticket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a ticket indicating dependence on all source values that may affect configuration-dependent computations. </p>
<p>In particular, this category <em>does not</em> include time, generalized velocities v, miscellaneous continuous state variables z, or input ports. Generalized coordinates q are included, as well as any discrete state variables that have been declared as configuration variables, and configuration-affecting parameters. Finally we assume that the accuracy setting may affect some configuration-dependent computations. Examples: a parameter that affects length may change the computation of an end-effector location. A change in accuracy requirement may require recomputation of an iterative approximation of contact forces. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1291b5091aa55dbd03c9b5944dbced09" title="Returns a ticket indicating dependence on all source values that may affect configuration- or velocit...">kinematics_ticket()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Currently there is no way to declare specific variables and parameters to be configuration-affecting so we include all state variables and parameters except for state variables v and z. </dd></dl>

</div>
</div>
<a id="a46b662b8346e6250f8c4340c18658084" name="a46b662b8346e6250f8c4340c18658084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b662b8346e6250f8c4340c18658084">&#9670;&#160;</a></span>CopyContinuousStateVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; CopyContinuousStateVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of the continuous state vector x꜀ into an Eigen vector. </p>

</div>
</div>
<a id="aa036f873464a74c03fab943bbace8942" name="aa036f873464a74c03fab943bbace8942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa036f873464a74c03fab943bbace8942">&#9670;&#160;</a></span>CreateDefaultContext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &gt; CreateDefaultContext </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This convenience method allocates a context using <a class="el" href="#a78fda6d982dc968061c5d92e32173629" title="(Advanced) Returns an uninitialized Context&lt;T&gt; suitable for use with this System&lt;T&gt;.">AllocateContext()</a> and sets its default values using <a class="el" href="#ab4e6ee413f4f47a20f6dcc2cbd831b88" title="Sets Context fields to their default values.">SetDefaultContext()</a>. </p>

</div>
</div>
<a id="a4076a7594095a9ca6936dd70c7254f84" name="a4076a7594095a9ca6936dd70c7254f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4076a7594095a9ca6936dd70c7254f84">&#9670;&#160;</a></span>DeclareCacheEntry() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class MySystem, class MyContext, typename ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp; DeclareCacheEntry </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>description</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>model_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MySystem&lt; T &gt;::*</td>          <td class="paramname"><span class="paramname"><em>calc&#160;</em></span>)(const MyContext &amp;, ValueType *) const, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>prerequisites_of_calc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{&#160;<a class="el" href="#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="anchor" id="DeclareCacheEntry_model_and_calc"></a></p>
<p>Declares a cache entry by specifying a model value of concrete type <span class="tt">ValueType</span> and a calculator function that is a class member function (method) with signature: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MySystem::CalcCacheValue(<span class="keyword">const</span> MyContext&amp;, ValueType*) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> where <span class="tt">MySystem</span> is a class derived from <span class="tt"><a class="el" href="classdrake_1_1systems_1_1_system_base.html" title="Provides non-templatized functionality shared by the templatized System classes.">SystemBase</a></span>, <span class="tt">MyContext</span> is a class derived from <span class="tt"><a class="el" href="classdrake_1_1systems_1_1_context_base.html" title="Provides non-templatized Context functionality shared by the templatized derived classes.">ContextBase</a></span>, and <span class="tt">ValueType</span> is any concrete type such that <span class="tt"><a class="el" href="classdrake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">Value</a>&lt;ValueType&gt;</span> is permitted. (The method names are arbitrary.) Template arguments will be deduced and do not need to be specified. See the <a class="el" href="classdrake_1_1systems_1_1_system_base.html#DeclareCacheEntry_primary">primary DeclareCacheEntry() signature</a> above for more information about the parameters and behavior. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">drake::Value</a> </dd></dl>

</div>
</div>
<a id="a1a97898d5e2f921cdb729f02a3c88074" name="a1a97898d5e2f921cdb729f02a3c88074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a97898d5e2f921cdb729f02a3c88074">&#9670;&#160;</a></span>DeclareCacheEntry() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp; DeclareCacheEntry </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>description</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_value_producer.html">ValueProducer</a></td>          <td class="paramname"><span class="paramname"><em>value_producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>prerequisites_of_calc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{&#160;<a class="el" href="#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="anchor" id="DeclareCacheEntry_primary"></a></p>
<p>Declares a new CacheEntry in this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> using the most generic form of the calculation function. Prefer one of the more convenient signatures below if you can. The new cache entry is assigned a unique <a class="el" href="namespacedrake_1_1systems.html#a06ac9ad764b14ccff79b6feb393be498" title="Serves as a unique identifier for a particular CacheEntry in a System and the corresponding CacheEntr...">CacheIndex</a> and <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee" title="Identifies a particular source value or computation for purposes of declaring and managing dependenci...">DependencyTicket</a>, which can be obtained from the returned CacheEntry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">description</td><td>A human-readable description of this cache entry, most useful for debugging and documentation. Not interpreted in any way by Drake; it is retained by the cache entry and used to generate the description for the corresponding <a class="el" href="classdrake_1_1systems_1_1_cache_entry_value.html" title="(Advanced) This is the representation in the Context for the value of one of a System&#39;s CacheEntry ob...">CacheEntryValue</a> in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_producer</td><td>Provides the computation that maps from a given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> to the current value that this cache entry should have, as well as a way to allocate storage prior to the computation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prerequisites_of_calc</td><td>Provides the <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee" title="Identifies a particular source value or computation for purposes of declaring and managing dependenci...">DependencyTicket</a> list containing a ticket for <em>every</em> <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> value on which <span class="tt">calc_function</span> may depend when it computes its result. Defaults to <span class="tt">{<a class="el" href="#af0b9bc9f93181e042bdb2c36f4dbea10" title="Returns a ticket indicating dependence on every possible independent source value,...">all_sources_ticket()</a>}</span> if unspecified. If the cache value is truly independent of the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> (rare!) say so explicitly by providing the list <span class="tt">{<a class="el" href="#a6fe75ddbd79ab1d862df9a50b3c8a624" title="Returns a ticket indicating that a computation does not depend on any source value; that is,...">nothing_ticket()</a>}</span>; an explicitly empty list <span class="tt">{}</span> is forbidden. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the newly-created CacheEntry. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if given an explicitly empty prerequisite list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d078e4f799ae50f07ae35389352835f" name="a7d078e4f799ae50f07ae35389352835f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d078e4f799ae50f07ae35389352835f">&#9670;&#160;</a></span>DeclareCacheEntry() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class MySystem, class MyContext, typename ValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp; DeclareCacheEntry </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>description</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MySystem&lt; T &gt;::*</td>          <td class="paramname"><span class="paramname"><em>calc&#160;</em></span>)(const MyContext &amp;, ValueType *) const, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>prerequisites_of_calc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{&#160;<a class="el" href="#af0b9bc9f93181e042bdb2c36f4dbea10">all_sources_ticket</a>()}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="anchor" id="DeclareCacheEntry_calc_only"></a></p>
<p>Declares a cache entry by specifying only a calculator function that is a class member function (method) with signature: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MySystem::CalcCacheValue(<span class="keyword">const</span> MyContext&amp;, ValueType*) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> where <span class="tt">MySystem</span> is a class derived from <span class="tt"><a class="el" href="classdrake_1_1systems_1_1_system_base.html" title="Provides non-templatized functionality shared by the templatized System classes.">SystemBase</a></span> and <span class="tt">MyContext</span> is a class derived from <span class="tt"><a class="el" href="classdrake_1_1systems_1_1_context_base.html" title="Provides non-templatized Context functionality shared by the templatized derived classes.">ContextBase</a></span>. <span class="tt">ValueType</span> is a concrete type such that (a) <span class="tt"><a class="el" href="classdrake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">Value</a>&lt;ValueType&gt;</span> is permitted, and (b) <span class="tt">ValueType</span> is default constructible. That allows us to create a model value using <span class="tt"><a class="el" href="classdrake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">Value</a>&lt;ValueType&gt;{}</span> (value initialized so numerical types will be zeroed in the model). (The method name is arbitrary.) Template arguments will be deduced and do not need to be specified. See the first <a class="el" href="#a1a97898d5e2f921cdb729f02a3c88074">DeclareCacheEntry()</a> signature above for more information about the parameters and behavior.</p>
<dl class="section note"><dt>Note</dt><dd>The default constructor will be called once immediately to create a model value, and subsequent allocations will just copy the model value without invoking the constructor again. If you want the constructor invoked again at each allocation (not common), use one of the other signatures to explicitly provide a method for the allocator to call; that method can then invoke the <span class="tt">ValueType</span> default constructor each time it is called. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">drake::Value</a> </dd></dl>

</div>
</div>
<a id="af0b57e4cacf2beba4ef87c87f824aba8" name="af0b57e4cacf2beba4ef87c87f824aba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b57e4cacf2beba4ef87c87f824aba8">&#9670;&#160;</a></span>DeclareInputPort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp; DeclareInputPort </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; std::string, <a class="el" href="structdrake_1_1systems_1_1_use_default_name.html">UseDefaultName</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1systems.html#ae516fceb67f15f61c7a232b9cc483fbe">PortDataType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespacedrake.html#a72383be4710d27584d0821effc6506a5">RandomDistribution</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>random_type</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a port with the specified <code class="param">type</code> and <code class="param">size</code> to the input topology. </p>
<p>Input port names must be unique for this system (passing in a duplicate <code class="param">name</code> will throw std::exception). If <code class="param">name</code> is given as kUseDefaultName, then a default value of e.g. "u2", where 2 is the input number will be provided. An empty <code class="param">name</code> is not permitted.</p>
<p>If the port is intended to model a random noise or disturbance input, <code class="param">random_type</code> can (optionally) be used to label it as such; doing so enables algorithms for design and analysis (e.g. state estimation) to reason explicitly about randomness at the system level. All random input ports are assumed to be statistically independent. </p><dl class="section pre"><dt>Precondition</dt><dd><code class="param">name</code> must not be empty. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for a duplicate port name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the declared port. </dd></dl>

</div>
</div>
<a id="adf86073429b07d388b0157956bfdbac6" name="adf86073429b07d388b0157956bfdbac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf86073429b07d388b0157956bfdbac6">&#9670;&#160;</a></span>discrete_state_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> discrete_state_ticket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1systems.html#acf2a50397e9fa764d32553cf98460ba7">DiscreteStateIndex</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a ticket indicating dependence on a particular discrete state variable xdᵢ (may be a vector). </p>
<p>(We sometimes refer to this as a "discrete
variable group".) </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a64938d044107c8eedc97f89aaf0e4a32" title="Returns a ticket indicating dependence on all of the numerical discrete state variables,...">xd_ticket()</a> to obtain a ticket for <em><a class="el" href="namespacedrake.html#a6f017505f166d0b60735ba1c4a9b4f23" title="Checks truth for all elements in matrix m.">all</a></em> discrete variables. </dd></dl>

</div>
</div>
<a id="ac9457822be4fc7aabaef0beb95b4264a" name="ac9457822be4fc7aabaef0beb95b4264a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9457822be4fc7aabaef0beb95b4264a">&#9670;&#160;</a></span>DispatchDiscreteVariableUpdateHandler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrake_1_1systems_1_1_event_status.html">EventStatus</a> DispatchDiscreteVariableUpdateHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>events</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>discrete_state</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Internal use only) This function dispatches all discrete update events to the appropriate handlers. </p>
<p><code class="param">discrete_state</code> cannot be null. Only <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a> and <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> (and some unit test code) provide implementations and those must be <span class="tt">final</span>. </p>

</div>
</div>
<a id="a2c5d5ccabe4f4b0eec04d62d407737d7" name="a2c5d5ccabe4f4b0eec04d62d407737d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5d5ccabe4f4b0eec04d62d407737d7">&#9670;&#160;</a></span>DispatchPublishHandler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrake_1_1systems_1_1_event_status.html">EventStatus</a> DispatchPublishHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>events</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Internal use only) This function dispatches all publish events to the appropriate handlers. </p>
<p>Only <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a> and <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> (and some unit test code) provide implementations and those must be <span class="tt">final</span>. </p>

</div>
</div>
<a id="a28700b2d1c21cd7956f9a68fd3f1fd2e" name="a28700b2d1c21cd7956f9a68fd3f1fd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28700b2d1c21cd7956f9a68fd3f1fd2e">&#9670;&#160;</a></span>DispatchUnrestrictedUpdateHandler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrake_1_1systems_1_1_event_status.html">EventStatus</a> DispatchUnrestrictedUpdateHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>events</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Internal use only) This function dispatches all unrestricted update events to the appropriate handlers. </p>
<p><code class="param">state</code> cannot be null. Only <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a> and <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> (and some unit test code) provide implementations and those must be <span class="tt">final</span>. </p>

</div>
</div>
<a id="ab104dfba98dd39ff4a7dd6ab5e178c8a" name="ab104dfba98dd39ff4a7dd6ab5e178c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab104dfba98dd39ff4a7dd6ab5e178c8a">&#9670;&#160;</a></span>DoApplyDiscreteVariableUpdate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoApplyDiscreteVariableUpdate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>events</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>discrete_state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Internal use only) Updates the given <span class="tt">context</span> with the results returned from a previous call to <a class="el" href="#ac9457822be4fc7aabaef0beb95b4264a" title="(Internal use only) This function dispatches all discrete update events to the appropriate handlers.">DispatchDiscreteVariableUpdateHandler()</a> that handled the given <span class="tt">events</span>. </p>

</div>
</div>
<a id="acc5802cd006ea71b0c68d4b48a1736e7" name="acc5802cd006ea71b0c68d4b48a1736e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5802cd006ea71b0c68d4b48a1736e7">&#9670;&#160;</a></span>DoApplyUnrestrictedUpdate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoApplyUnrestrictedUpdate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>events</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Internal use only) Updates the given <span class="tt">context</span> with the results returned from a previous call to <a class="el" href="#a28700b2d1c21cd7956f9a68fd3f1fd2e" title="(Internal use only) This function dispatches all unrestricted update events to the appropriate handle...">DispatchUnrestrictedUpdateHandler()</a> that handled the given <span class="tt">events</span>. </p>

</div>
</div>
<a id="aafa6ce88c0e7ba9f6592713d36bc4047" name="aafa6ce88c0e7ba9f6592713d36bc4047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa6ce88c0e7ba9f6592713d36bc4047">&#9670;&#160;</a></span>DoCalcConservativePower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T DoCalcConservativePower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override this method to return the rate Pc at which mechanical energy is being converted <em>from</em> potential energy <em>to</em> kinetic energy by this system in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. </p>
<p>By default, returns zero. Physical systems should override. You may assume that <span class="tt">context</span> has already been validated before it is passed to you here.</p>
<p>See <a class="el" href="#a94bf4d9472a96aad5d65e47375cf035f" title="Returns a reference to the cached value of the conservative power (Pc), evaluating first if necessary...">EvalConservativePower()</a> for details on what you must compute here. In particular, this quantity must be <em>positive</em> when potential energy is <em>decreasing</em>, and your conservative power method must <em>not</em> depend explicitly on time or any input port values. </p>

</div>
</div>
<a id="a1612bbeeab77dfe57f08df56b7869a68" name="a1612bbeeab77dfe57f08df56b7869a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1612bbeeab77dfe57f08df56b7869a68">&#9670;&#160;</a></span>DoCalcImplicitTimeDerivativesResidual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoCalcImplicitTimeDerivativesResidual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>proposed_derivatives</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>residual</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override this if you have an efficient way to evaluate the implicit time derivatives residual for this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>. </p>
<p>Otherwise the default implementation is <span class="tt">residual = proposed_derivatives − EvalTimeDerivatives(context)</span>. Note that you cannot use the default implementation if you have changed the declared residual size.</p>
<dl class="section note"><dt>Note</dt><dd>The public method has already verified that <span class="tt">proposed_derivatives</span> is compatible with this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> and that <span class="tt">residual</span> is non-null and of the declared size (as reported by <a class="el" href="classdrake_1_1systems_1_1_system_base.html#aba0bd9017cbe1fbf0f02912f0d45fd10" title="Returns the size of the implicit time derivatives residual vector.">SystemBase::implicit_time_derivatives_residual_size()</a>). You do not have to check those two conditions in your implementation, but if you have additional restrictions you should validate that they are also met. </dd></dl>

</div>
</div>
<a id="a8de30438c7fbda84a0cc9a35ca543c8e" name="a8de30438c7fbda84a0cc9a35ca543c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de30438c7fbda84a0cc9a35ca543c8e">&#9670;&#160;</a></span>DoCalcKineticEnergy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T DoCalcKineticEnergy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override this method for physical systems to calculate the kinetic energy KE currently present in the motion provided in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. </p>
<p>The default implementation returns 0 which is correct for non-physical systems. You may assume that <span class="tt">context</span> has already been validated before it is passed to you here.</p>
<p>See <a class="el" href="#abfc345ff50df77ad2ae727e6d3a9b939" title="Returns a reference to the cached value of the kinetic energy (KE), evaluating first if necessary usi...">EvalKineticEnergy()</a> for details on what you must compute here. In particular, your kinetic energy method must <em>not</em> depend explicitly on time or any input port values. </p>

</div>
</div>
<a id="afdc9aebb6327099391cd0f621b4b8d44" name="afdc9aebb6327099391cd0f621b4b8d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc9aebb6327099391cd0f621b4b8d44">&#9670;&#160;</a></span>DoCalcNextUpdateTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoCalcNextUpdateTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>events</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>time</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the next time at which this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> must perform a discrete action. </p>
<p>Override this method if your <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> has any discrete actions which must interrupt the continuous simulation. This method is called only from the public non-virtual <a class="el" href="#a164afe3c1db737b93696b8808bb2c942" title="This method is called by a Simulator during its calculation of the size of the next continuous step t...">CalcNextUpdateTime()</a> which will already have error-checked the parameters so you don't have to. You may assume that <code class="param">context</code> has already been validated and <code class="param">events</code> pointer is not null.</p>
<p>If you override this method, you <em>must</em> set the returned <code class="param">time</code>. Set it to Infinity if there are no upcoming timed events. If you return a finite update time, you <em>must</em> put at least one <a class="el" href="classdrake_1_1systems_1_1_event.html" title="Abstract base class that represents an event.">Event</a> object in the <code class="param">events</code> collection. These requirements are enforced by the public <a class="el" href="#a164afe3c1db737b93696b8808bb2c942" title="This method is called by a Simulator during its calculation of the size of the next continuous step t...">CalcNextUpdateTime()</a> method.</p>
<dl class="section note"><dt>Note</dt><dd>Despite the name, you must include publish events along with state-updating events.</dd></dl>
<p>The default implementation returns with the next sample time being Infinity and no events added to <code class="param">events</code>. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a44e600fb330237f0e76dfc4f6f1b6faf">Diagram&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a44e600fb330237f0e76dfc4f6f1b6faf">Diagram&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1lcm_1_1_lcm_log_playback_system.html#aef25b6bf7f703116ca7188bffdee593c">LcmLogPlaybackSystem</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a5c883b4b0aa7a507e29dee582d9ed0fb">LeafSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a5c883b4b0aa7a507e29dee582d9ed0fb">LeafSystem&lt; double &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a5c883b4b0aa7a507e29dee582d9ed0fb">LeafSystem&lt; drake::ad::AutoDiff &gt;</a>.</p>

</div>
</div>
<a id="a3bc39e42fbb88d08592d2f7e7c12637d" name="a3bc39e42fbb88d08592d2f7e7c12637d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc39e42fbb88d08592d2f7e7c12637d">&#9670;&#160;</a></span>DoCalcNonConservativePower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T DoCalcNonConservativePower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override this method to return the rate Pnc at which work W is done on the system by non-conservative forces. </p>
<p>By default, returns zero. Physical systems should override. You may assume that <span class="tt">context</span> has already been validated before it is passed to you here.</p>
<p>See <a class="el" href="#a08ed6bf23e134cbc50d073e81ffc247f" title="Returns a reference to the cached value of the non-conservative power (Pnc), evaluating first if nece...">EvalNonConservativePower()</a> for details on what you must compute here. In particular, this quantity must be <em>negative</em> if the non-conservative forces are <em>dissipative</em>, positive otherwise. Your non-conservative power method can depend on anything you find in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>, including time and input ports. </p>

</div>
</div>
<a id="a40f055c2fb422eefe50faf9a0979c1e0" name="a40f055c2fb422eefe50faf9a0979c1e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f055c2fb422eefe50faf9a0979c1e0">&#9670;&#160;</a></span>DoCalcPotentialEnergy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T DoCalcPotentialEnergy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override this method for physical systems to calculate the potential energy PE currently stored in the configuration provided in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. </p>
<p>The default implementation returns 0 which is correct for non-physical systems. You may assume that <span class="tt">context</span> has already been validated before it is passed to you here.</p>
<p>See <a class="el" href="#a97c1ac3506af8f2c386ba74b5fbc1e48" title="Returns a reference to the cached value of the potential energy (PE), evaluating first if necessary u...">EvalPotentialEnergy()</a> for details on what you must compute here. In particular, your potential energy method must <em>not</em> depend explicitly on time, velocities, or any input port values. </p>

</div>
</div>
<a id="a2d2b6bbca36ba86a269c9fd42ddfb6d0" name="a2d2b6bbca36ba86a269c9fd42ddfb6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2b6bbca36ba86a269c9fd42ddfb6d0">&#9670;&#160;</a></span>DoCalcTimeDerivatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoCalcTimeDerivatives </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>derivatives</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override this if you have any continuous state variables x꜀ in your concrete System to calculate their time derivatives. </p>
<p>The <span class="tt">derivatives</span> vector will correspond elementwise with the state vector <span class="tt">Context.state.continuous_state.get_state()</span>. Thus, if the state in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> has second-order structure <span class="tt">x꜀=[q v z]</span>, that same structure applies to the derivatives.</p>
<p>This method is called only from the public non-virtual <a class="el" href="#af2677f8773e90a538483eedd80a81a9f" title="Calculates the time derivatives ẋ꜀ of the continuous state x꜀ into a given output argument.">CalcTimeDerivatives()</a> which will already have error-checked the parameters so you don't have to. In particular, implementations may assume that the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> is valid for this System; that the <span class="tt">derivatives</span> pointer is non-null, and that the referenced object has the same constituent structure as was produced by <a class="el" href="#a672f9ea75065ea78820a04982cca899c" title="Returns a ContinuousState of the same size as the continuous_state allocated in CreateDefaultContext.">AllocateTimeDerivatives()</a>.</p>
<p>The default implementation does nothing if the <span class="tt">derivatives</span> vector is size zero and aborts otherwise. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1controllers_1_1_pid_controller.html#a18737529bba0537a9fa06a649378b1a8">PidController&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_time_varying_affine_system.html#a18737529bba0537a9fa06a649378b1a8">TimeVaryingAffineSystem&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_vector_system.html#a021b8135deba8c945c9deea3cb4ce7a0">VectorSystem&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a9440f6840ccb22a989d50ff8a7e65760" name="a9440f6840ccb22a989d50ff8a7e65760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9440f6840ccb22a989d50ff8a7e65760">&#9670;&#160;</a></span>DoCalcWitnessValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T DoCalcWitnessValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>witness_func</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived classes will implement this method to evaluate a witness function at the given context. </p>

<p>Implemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#ae1f1eff5e4fd7f55d152a1b3b9d4bcd1">Diagram&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#ae1f1eff5e4fd7f55d152a1b3b9d4bcd1">Diagram&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ae1f1eff5e4fd7f55d152a1b3b9d4bcd1">LeafSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ae1f1eff5e4fd7f55d152a1b3b9d4bcd1">LeafSystem&lt; double &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ae1f1eff5e4fd7f55d152a1b3b9d4bcd1">LeafSystem&lt; drake::ad::AutoDiff &gt;</a>.</p>

</div>
</div>
<a id="a0a38740aa5d71df2a0bab769c29fff7c" name="a0a38740aa5d71df2a0bab769c29fff7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a38740aa5d71df2a0bab769c29fff7c">&#9670;&#160;</a></span>DoGetInitializationEvents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoGetInitializationEvents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>events</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement this method to return any events to be handled at the simulator's initialization step. </p>
<p><code class="param">events</code> is cleared in the public non-virtual <a class="el" href="#ae6f84e649d76754f38ea7420a21a1a04" title="This method is called by Simulator::Initialize() to gather all update and publish events that need to...">GetInitializationEvents()</a>. You may assume that <code class="param">context</code> has already been validated and that <code class="param">events</code> is not null. <code class="param">events</code> can be changed freely by the overriding implementation.</p>
<p>The default implementation returns without changing <code class="param">events</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae6f84e649d76754f38ea7420a21a1a04" title="This method is called by Simulator::Initialize() to gather all update and publish events that need to...">GetInitializationEvents()</a> </dd></dl>

</div>
</div>
<a id="adc8a45777136aa90b4390b611efc4d36" name="adc8a45777136aa90b4390b611efc4d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8a45777136aa90b4390b611efc4d36">&#9670;&#160;</a></span>DoGetPeriodicEvents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoGetPeriodicEvents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>events</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement this method to return any periodic events. </p>
<p><code class="param">events</code> is cleared in the public non-virtual <a class="el" href="#adf1f428d7eb6e62bcdd26e9d5a770cba" title="Returns all periodic events in this System.">GetPeriodicEvents()</a>. You may assume that <code class="param">context</code> has already been validated and that <code class="param">events</code> is not null. <code class="param">events</code> can be changed freely by the overriding implementation.</p>
<p>The default implementation returns without changing <code class="param">events</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#adf1f428d7eb6e62bcdd26e9d5a770cba" title="Returns all periodic events in this System.">GetPeriodicEvents()</a> </dd></dl>

</div>
</div>
<a id="aaa8100d7c746acc72a3a86fe8cad9d7c" name="aaa8100d7c746acc72a3a86fe8cad9d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8100d7c746acc72a3a86fe8cad9d7c">&#9670;&#160;</a></span>DoGetPerStepEvents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoGetPerStepEvents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>events</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement this method to return any events to be handled before the simulator integrates the system's continuous state at each time step. </p>
<p><code class="param">events</code> is cleared in the public non-virtual <a class="el" href="#ad8a24b8f910f9d990db8e59bf2bae6d0" title="This method is called by Simulator::Initialize() to gather all update and publish events that are to ...">GetPerStepEvents()</a> before that method calls this function. You may assume that <code class="param">context</code> has already been validated and that <code class="param">events</code> is not null. <code class="param">events</code> can be changed freely by the overriding implementation.</p>
<p>The default implementation returns without changing <code class="param">events</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad8a24b8f910f9d990db8e59bf2bae6d0" title="This method is called by Simulator::Initialize() to gather all update and publish events that are to ...">GetPerStepEvents()</a> </dd></dl>

</div>
</div>
<a id="af6d0f8fa7471b9cf026c9b7bf86f615c" name="af6d0f8fa7471b9cf026c9b7bf86f615c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d0f8fa7471b9cf026c9b7bf86f615c">&#9670;&#160;</a></span>DoGetWitnessFunctions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoGetWitnessFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; * &gt; *</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived classes can override this method to provide witness functions active for the given state. </p>
<p>The default implementation does nothing. On entry to this function, the context will have already been validated and the vector of witness functions will have been validated to be both empty and non-null. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#ae9a7957f87c97bd9853220bceb9d8a3a">Diagram&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_diagram.html#ae9a7957f87c97bd9853220bceb9d8a3a">Diagram&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a9ab8eeda0691dddf88db4c45618a0303" name="a9ab8eeda0691dddf88db4c45618a0303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab8eeda0691dddf88db4c45618a0303">&#9670;&#160;</a></span>DoMapPeriodicEventsByTiming()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::map&lt; <a class="el" href="classdrake_1_1systems_1_1_periodic_event_data.html">PeriodicEventData</a>, std::vector&lt; const <a class="el" href="classdrake_1_1systems_1_1_event.html">Event</a>&lt; T &gt; * &gt;, <a class="el" href="structdrake_1_1systems_1_1_periodic_event_data_comparator.html">PeriodicEventDataComparator</a> &gt; DoMapPeriodicEventsByTiming </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement this method to return all periodic triggered events organized by timing. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a60cb116e195ba4b7d23fa39e094b4402" title="Maps all periodic triggered events for a System, organized by timing.">MapPeriodicEventsByTiming()</a> for a detailed description of the returned variable. </dd></dl>

</div>
</div>
<a id="af11d9e638906b337b149babc5d65d4c1" name="af11d9e638906b337b149babc5d65d4c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af11d9e638906b337b149babc5d65d4c1">&#9670;&#160;</a></span>DoMapQDotToVelocity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoMapQDotToVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>qdot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>generalized_velocity</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the substantive implementation of <a class="el" href="#a10eba167739bfe8e7e419b5c8ae41537" title="Transforms the time derivative qdot of the generalized configuration q to generalized velocities v.">MapQDotToVelocity()</a>. </p>
<p>The default implementation uses the identity mapping, and correctly does nothing if the System does not have second-order state variables. It throws std::exception if the <span class="tt">generalized_velocity</span> and <span class="tt">qdot</span> are not the same size, but that is not enough to guarantee that the default implementation is adequate. Child classes must override this function if qdot != v (even if they are the same size). This occurs, for example, if a joint uses roll-pitch-yaw rotation angles for orientation but angular velocity for rotational rate rather than rotation angle derivatives.</p>
<p>If you implement this method you are required to use no more than <span class="tt">O(nq)</span> time where <span class="tt">nq</span> is the size of <span class="tt">qdot</span>, so that the System can meet the performance guarantee made for the public interface, and you must also implement <a class="el" href="#a4b3dda5682eaa8cadbcc7137661ed3a3" title="Provides the substantive implementation of MapVelocityToQDot().">DoMapVelocityToQDot()</a>. Implementations may assume that <span class="tt">qdot</span> has already been validated to be the same size as <span class="tt">q</span> in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>, and that <span class="tt">generalized_velocity</span> is non-null. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a3a7c35ef0bddf217364408481fe234b5">Diagram&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a3a7c35ef0bddf217364408481fe234b5">Diagram&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a4b3dda5682eaa8cadbcc7137661ed3a3" name="a4b3dda5682eaa8cadbcc7137661ed3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b3dda5682eaa8cadbcc7137661ed3a3">&#9670;&#160;</a></span>DoMapVelocityToQDot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoMapVelocityToQDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>generalized_velocity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>qdot</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides the substantive implementation of <a class="el" href="#a05cc5df6d0d0fe4ea54b522ae776ca39" title="Transforms a given generalized velocity v to the time derivative qdot of the generalized configuratio...">MapVelocityToQDot()</a>. </p>
<p>The default implementation uses the identity mapping, and correctly does nothing if the System does not have second-order state variables. It throws std::exception if the <span class="tt">generalized_velocity</span> (<span class="tt">v</span>) and <span class="tt">qdot</span> are not the same size, but that is not enough to guarantee that the default implementation is adequate. Child classes must override this function if <span class="tt">qdot != v</span> (even if they are the same size). This occurs, for example, if a joint uses roll-pitch-yaw rotation angles for orientation but angular velocity for rotational rate rather than rotation angle derivatives.</p>
<p>If you implement this method you are required to use no more than <span class="tt">O(nq)</span> time where <span class="tt">nq</span> is the size of <span class="tt">qdot</span>, so that the System can meet the performance guarantee made for the public interface, and you must also implement <a class="el" href="#af11d9e638906b337b149babc5d65d4c1" title="Provides the substantive implementation of MapQDotToVelocity().">DoMapQDotToVelocity()</a>. Implementations may assume that <span class="tt">generalized_velocity</span> has already been validated to be the same size as <span class="tt">v</span> in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>, and that <span class="tt">qdot</span> is non-null. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a8334cee1ad48029f35de2b4fc5d830c2">Diagram&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a8334cee1ad48029f35de2b4fc5d830c2">Diagram&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a94bf4d9472a96aad5d65e47375cf035f" name="a94bf4d9472a96aad5d65e47375cf035f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bf4d9472a96aad5d65e47375cf035f">&#9670;&#160;</a></span>EvalConservativePower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; EvalConservativePower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the cached value of the conservative power (Pc), evaluating first if necessary using <a class="el" href="#a5674ae416c2808c939dffc117b209f23" title="Calculates and returns the conservative power represented by the current contents of the given contex...">CalcConservativePower()</a>. </p>
<p>The returned Pc represents the rate at which mechanical energy is being converted <em>from</em> potential energy (PE) <em>to</em> kinetic energy (KE) by this system in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. This quantity will be <em>positive</em> when PE is <em>decreasing</em>. By definition here, conservative power may depend only on quantities that explicitly contribute to PE and KE. See <a class="el" href="#a97c1ac3506af8f2c386ba74b5fbc1e48" title="Returns a reference to the cached value of the potential energy (PE), evaluating first if necessary u...">EvalPotentialEnergy()</a> and <a class="el" href="#abfc345ff50df77ad2ae727e6d3a9b939" title="Returns a reference to the cached value of the kinetic energy (KE), evaluating first if necessary usi...">EvalKineticEnergy()</a> for details.</p>
<p>Power due to non-conservative forces (e.g. dampers) can contribute to the rate of change of KE. Therefore this method alone cannot be used to determine whether KE is increasing or decreasing, only whether the conservative power is adding or removing kinetic energy. <a class="el" href="#a08ed6bf23e134cbc50d073e81ffc247f" title="Returns a reference to the cached value of the non-conservative power (Pnc), evaluating first if nece...">EvalNonConservativePower()</a> can be used in conjunction with this method to find the total rate of change of KE.</p>
<p>Non-physical systems where Pc is not meaningful will return Pc = 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> whose contents may be used to evaluate conservative power. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Pc</td><td>The conservative power in watts (W or J/s) represented by the contents of the given <span class="tt">context</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5674ae416c2808c939dffc117b209f23" title="Calculates and returns the conservative power represented by the current contents of the given contex...">CalcConservativePower()</a>, <a class="el" href="#a08ed6bf23e134cbc50d073e81ffc247f" title="Returns a reference to the cached value of the non-conservative power (Pnc), evaluating first if nece...">EvalNonConservativePower()</a>, <a class="el" href="#a97c1ac3506af8f2c386ba74b5fbc1e48" title="Returns a reference to the cached value of the potential energy (PE), evaluating first if necessary u...">EvalPotentialEnergy()</a>, <a class="el" href="#abfc345ff50df77ad2ae727e6d3a9b939" title="Returns a reference to the cached value of the kinetic energy (KE), evaluating first if necessary usi...">EvalKineticEnergy()</a> </dd></dl>

</div>
</div>
<a id="abfc345ff50df77ad2ae727e6d3a9b939" name="abfc345ff50df77ad2ae727e6d3a9b939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc345ff50df77ad2ae727e6d3a9b939">&#9670;&#160;</a></span>EvalKineticEnergy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; EvalKineticEnergy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the cached value of the kinetic energy (KE), evaluating first if necessary using <a class="el" href="#aad01402fef0de79310989d7d22dfde92" title="Calculates and returns the kinetic energy represented by the current configuration and velocity provi...">CalcKineticEnergy()</a>. </p>
<p>By definition here, kinetic energy depends only on "configuration" and "velocity" (e.g. angular and translational velocity) of moving masses which includes a subset of the state variables, and parameters that affect configuration, velocities, or mass properties. The calculated value may also be affected by the accuracy value supplied in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. KE cannot depend explicitly on time (∂KE/∂t = 0) or input port values (∂KE/∂u = 0).</p>
<p>Non-physical systems where KE is not meaningful will return KE = 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> whose configuration and velocity variables may be used to evaluate kinetic energy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">KE</td><td>The kinetic energy in joules (J) represented by the configuration and velocity given in <span class="tt">context</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aad01402fef0de79310989d7d22dfde92" title="Calculates and returns the kinetic energy represented by the current configuration and velocity provi...">CalcKineticEnergy()</a> </dd></dl>

</div>
</div>
<a id="a08ed6bf23e134cbc50d073e81ffc247f" name="a08ed6bf23e134cbc50d073e81ffc247f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ed6bf23e134cbc50d073e81ffc247f">&#9670;&#160;</a></span>EvalNonConservativePower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; EvalNonConservativePower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the cached value of the non-conservative power (Pnc), evaluating first if necessary using <a class="el" href="#a23fe133b70153e382d7f50c38b96bf1f" title="Calculates and returns the non-conservative power represented by the current contents of the given co...">CalcNonConservativePower()</a>. </p>
<p>The returned Pnc represents the rate at which work W is done on the system by non-conservative forces. Pnc is <em>negative</em> if the non-conservative forces are <em>dissipative</em>, positive otherwise. Time integration of Pnc yields work W, and the total mechanical energy <span class="tt">E = PE + KE − W</span> should be conserved by any physically-correct model, to within integration accuracy of W. Power is in watts (J/s). (Watts are abbreviated W but not to be confused with work!) Any values in the supplied <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> (including time and input ports) may contribute to the computation of non-conservative power.</p>
<p>Non-physical systems where Pnc is not meaningful will return Pnc = 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> whose contents may be used to evaluate non-conservative power. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Pnc</td><td>The non-conservative power in watts (W or J/s) represented by the contents of the given <span class="tt">context</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a23fe133b70153e382d7f50c38b96bf1f" title="Calculates and returns the non-conservative power represented by the current contents of the given co...">CalcNonConservativePower()</a>, <a class="el" href="#a94bf4d9472a96aad5d65e47375cf035f" title="Returns a reference to the cached value of the conservative power (Pc), evaluating first if necessary...">EvalConservativePower()</a> </dd></dl>

</div>
</div>
<a id="a97c1ac3506af8f2c386ba74b5fbc1e48" name="a97c1ac3506af8f2c386ba74b5fbc1e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c1ac3506af8f2c386ba74b5fbc1e48">&#9670;&#160;</a></span>EvalPotentialEnergy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; EvalPotentialEnergy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the cached value of the potential energy (PE), evaluating first if necessary using <a class="el" href="#a3d5eb1d2630aab1938230257554d1f43" title="Calculates and returns the potential energy represented by the current configuration provided in cont...">CalcPotentialEnergy()</a>. </p>
<p>By definition here, potential energy depends only on "configuration" (e.g. orientation and position), which includes a subset of the state variables, and parameters that affect configuration or conservative forces (such as lengths and masses). The calculated value may also be affected by the accuracy value supplied in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. PE cannot depend explicitly on time (∂PE/∂t = 0), velocities (∂PE/∂v = 0), or input port values (∂PE/∂u = 0).</p>
<p>Non-physical systems where PE is not meaningful will return PE = 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> whose configuration variables may be used to evaluate potential energy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">PE</td><td>The potential energy in joules (J) represented by the configuration given in <span class="tt">context</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3d5eb1d2630aab1938230257554d1f43" title="Calculates and returns the potential energy represented by the current configuration provided in cont...">CalcPotentialEnergy()</a> </dd></dl>

</div>
</div>
<a id="a15b6e794826488cdb01ef10a2b21a5dd" name="a15b6e794826488cdb01ef10a2b21a5dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b6e794826488cdb01ef10a2b21a5dd">&#9670;&#160;</a></span>EvalTimeDerivatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_continuous_state.html">ContinuousState</a>&lt; T &gt; &amp; EvalTimeDerivatives </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the cached value of the continuous state variable time derivatives, evaluating first if necessary using <a class="el" href="#af2677f8773e90a538483eedd80a81a9f" title="Calculates the time derivatives ẋ꜀ of the continuous state x꜀ into a given output argument.">CalcTimeDerivatives()</a>. </p>
<p>This method returns the time derivatives ẋ꜀ of the continuous state x꜀. The referenced return object will correspond elementwise with the continuous state in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. Thus, if the state in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> has second-order structure <span class="tt">x꜀ = [q v z]</span>, that same structure applies to the derivatives so we will have <span class="tt">ẋ꜀ = [q̇ ̇v̇ ż]</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> whose time, input port, parameter, state, and accuracy values may be used to evaluate the derivatives.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">xcdot</td><td>Time derivatives ẋ꜀ of x꜀ returned as a reference to an object of the same type and size as <span class="tt">context</span>'s continuous state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1systems.html#a9bbfb3fbf0e3c139e11fcbe99cfbb825" title="Evaluates the time derivatives of a system at many times, states, and inputs.">BatchEvalTimeDerivatives()</a> for a batch version of this method. </dd>
<dd>
<a class="el" href="#af2677f8773e90a538483eedd80a81a9f" title="Calculates the time derivatives ẋ꜀ of the continuous state x꜀ into a given output argument.">CalcTimeDerivatives()</a>, <a class="el" href="#a8debe7d25e61fd759c918d889286525f" title="Evaluates the implicit form of the System equations and returns the residual.">CalcImplicitTimeDerivativesResidual()</a>, <a class="el" href="#a63db490cc14b49e3a67f5195a69cd869" title="(Advanced) Returns the CacheEntry used to cache time derivatives for EvalTimeDerivatives().">get_time_derivatives_cache_entry()</a> </dd></dl>

</div>
</div>
<a id="a1117b27ee2c4131dbcf1e0179c4b9113" name="a1117b27ee2c4131dbcf1e0179c4b9113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1117b27ee2c4131dbcf1e0179c4b9113">&#9670;&#160;</a></span>EvalUniquePeriodicDiscreteUpdate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues</a>&lt; T &gt; &amp; EvalUniquePeriodicDiscreteUpdate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If this System contains a unique periodic timing for discrete update events, this function executes the handlers for those periodic events to determine what their effect would be. </p>
<p>Returns a reference to the discrete variable cache entry containing what values the discrete variables would have if these periodic events were triggered.</p>
<p>Note that this function <em>does not</em> change the value of the discrete variables in the supplied <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. However, you can apply the result to the Context like this: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1systems_1_1_discrete_values.html">DiscreteValues&lt;T&gt;</a>&amp; updated =</div>
<div class="line">    system.EvalUniquePeriodicDiscreteUpdate(context);</div>
<div class="line">context.SetDiscreteState(updated);</div>
<div class="ttc" id="aclassdrake_1_1systems_1_1_discrete_values_html"><div class="ttname"><a href="classdrake_1_1systems_1_1_discrete_values.html">drake::systems::DiscreteValues</a></div><div class="ttdoc">DiscreteValues is a container for numerical but non-continuous state and parameters.</div><div class="ttdef"><b>Definition</b> discrete_values.h:37</div></div>
</div><!-- fragment --><p> You can write the updated values to a different Context than the one you used to calculate the update; the requirement is only that the discrete state in the destination has the same structure (number of groups and size of each group).</p>
<p>You can use <a class="el" href="#a0e7bc22bdd95c7c611e859c12dfef3e1" title="Determines whether there exists a unique periodic timing (offset and period) that triggers one or mor...">GetUniquePeriodicDiscreteUpdateAttribute()</a> to check whether you can call EvalUniquePeriodicDiscreteUpdate() safely, and to find the unique periodic timing information (offset and period).</p>
<dl class="section warning"><dt>Warning</dt><dd>Even if we find a unique discrete update timing as described above, there may also be unrestricted updates performed with that timing or other timings. (Unrestricted updates can modify any state variables <em>including</em> discrete variables.) Also, there may be trigger types other than periodic that can modify discrete variables. This function does not attempt to look for any of those; they are simply ignored. If you are concerned with those, you can use <a class="el" href="#ad8a24b8f910f9d990db8e59bf2bae6d0" title="This method is called by Simulator::Initialize() to gather all update and publish events that are to ...">GetPerStepEvents()</a>, <a class="el" href="#ae6f84e649d76754f38ea7420a21a1a04" title="This method is called by Simulator::Initialize() to gather all update and publish events that need to...">GetInitializationEvents()</a>, and <a class="el" href="#adf1f428d7eb6e62bcdd26e9d5a770cba" title="Returns all periodic events in this System.">GetPeriodicEvents()</a> to get a more comprehensive picture of the event landscape.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> containing the current System state and the mutable cache space into which the result is written. The current state is <em>not</em> modified, though the cache entry may be updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the <a class="el" href="classdrake_1_1systems_1_1_discrete_values.html" title="DiscreteValues is a container for numerical but non-continuous state and parameters.">DiscreteValues</a> cache space in <span class="tt">context</span> containing the result of applying the discrete update event handlers to the current discrete variable values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The referenced cache entry is recalculated if anything in the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> has changed since last calculation. Subsequent calls just return the already-calculated value.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there is not exactly one periodic timing in this System (which may be a <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a>) that triggers discrete update events.</td></tr>
    <tr><td class="paramname">std::exception</td><td>if it invokes an event handler that returns status indicating failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Implementation If recalculation is needed, copies the current discrete</dt><dd>state values into preallocated <span class="tt">context</span> cache space. Applies the discrete update event handlers (in an unspecified order) to the cache copy, possibly updating it. Returns a reference to the possibly-updated cache space.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1systems.html#ad8972abc5e9551f0127a6c9e73b2cc8d" title="Evaluates the dynamics of a difference equation system at many times, states, and inputs.">BatchEvalUniquePeriodicDiscreteUpdate()</a> for a batch version of this method. </dd>
<dd>
<a class="el" href="#a0e7bc22bdd95c7c611e859c12dfef3e1" title="Determines whether there exists a unique periodic timing (offset and period) that triggers one or mor...">GetUniquePeriodicDiscreteUpdateAttribute()</a>, <a class="el" href="#adf1f428d7eb6e62bcdd26e9d5a770cba" title="Returns all periodic events in this System.">GetPeriodicEvents()</a> </dd></dl>

</div>
</div>
<a id="af396318b2f8da923d1981bb40f9ab2f7" name="af396318b2f8da923d1981bb40f9ab2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af396318b2f8da923d1981bb40f9ab2f7">&#9670;&#160;</a></span>EvalVectorInput()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename &gt; class Vec = BasicVector&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Vec&lt; T &gt; * EvalVectorInput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>port_index</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the vector-valued input port with the given <span class="tt">port_index</span> as a <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase.">BasicVector</a> or a specific subclass <span class="tt">Vec</span> derived from <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase.">BasicVector</a>. </p>
<p>Causes the value to become up to date first if necessary. See <a class="el" href="classdrake_1_1systems_1_1_system_base.html#a62ba7c6b62b14b2955bdf40e62e38eef" title="Returns the value of the input port with the given port_index as an AbstractValue,...">EvalAbstractInput()</a> for more information.</p>
<p>The result is returned as a pointer to the input port's value of type <span class="tt">Vec&lt;T&gt;</span> or nullptr if the port is not connected.</p>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">port_index</span> selects an existing input port of this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>. </dd>
<dd>
the port must have been declared to be vector-valued. </dd>
<dd>
the port's value must be of type Vec&lt;T&gt;.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vec</td><td>The template type of the input vector, which must be a subclass of <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase.">BasicVector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90b36c14bbcdf47bf14f2906e18573ca" name="a90b36c14bbcdf47bf14f2906e18573ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b36c14bbcdf47bf14f2906e18573ca">&#9670;&#160;</a></span>ExecuteForcedEvents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ExecuteForcedEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>publish</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method triggers all of the forced events registered with this System (which might be a <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a>). </p>
<p>Ordering and status return handling mimic the <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a>: unrestricted events are processed first, then discrete update events, then publish events. "Reached termination" status returns are ignored.</p>
<p>An option is provided to suppress publish events. This can be useful, for example, to update state in a <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> without triggering a visualization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">context</td><td>The <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> supplied to the handlers and modified in place on return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if it invokes an event handler that returns status indicating failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affcc9107de045c4500b366b947a3796a" name="affcc9107de045c4500b366b947a3796a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affcc9107de045c4500b366b947a3796a">&#9670;&#160;</a></span>ExecuteInitializationEvents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ExecuteInitializationEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method triggers all of the initialization events returned by <a class="el" href="#ae6f84e649d76754f38ea7420a21a1a04" title="This method is called by Simulator::Initialize() to gather all update and publish events that need to...">GetInitializationEvents()</a>. </p>
<p>The method allocates temporary storage to perform the updates, and is intended only as a convenience method for callers who do not want to use the full <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> workflow.</p>
<p>Note that this is not fully equivalent to <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Simulator::Initialize()</a> because <em>only</em> initialization events are handled here, while <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Simulator::Initialize()</a> also processes other events associated with time zero. Also, "reached
termination" returns are ignored here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">context</td><td>The <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> supplied to the handlers and modified in place on return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if it invokes an event handler that returns status indicating failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abeb2444df5d7f4eeec63962393985bcd" name="abeb2444df5d7f4eeec63962393985bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb2444df5d7f4eeec63962393985bcd">&#9670;&#160;</a></span>FindUniquePeriodicDiscreteUpdatesOrThrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FindUniquePeriodicDiscreteUpdatesOrThrow </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>api_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>system</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classdrake_1_1systems_1_1_periodic_event_data.html">PeriodicEventData</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>timing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>events</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Internal use only) Static interface to DoFindUniquePeriodicDiscreteUpdatesOrThrow() to allow a <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> to invoke that private method on its subsystems. </p>

</div>
</div>
<a id="a601fb2c6cf565d954253d25725ae9d6b" name="a601fb2c6cf565d954253d25725ae9d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601fb2c6cf565d954253d25725ae9d6b">&#9670;&#160;</a></span>FixInputPortsFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FixInputPortsFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other_system</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other_context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>target_context</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fixes all of the input ports in <code class="param">target_context</code> to their current values in <code class="param">other_context</code>, as evaluated by <code class="param">other_system</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>unless <span class="tt">other_context</span> and <span class="tt">target_context</span> both have the same shape as this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>, and the <span class="tt">other_system</span>. Ignores disconnected inputs. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">this</span> system's scalar type T != double and <span class="tt">other_system</span> has any abstract input ports whose contained type depends on scalar type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a582cbe45eeaf9fe74b7143a1b71ff958" name="a582cbe45eeaf9fe74b7143a1b71ff958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a582cbe45eeaf9fe74b7143a1b71ff958">&#9670;&#160;</a></span>forced_discrete_update_events_exist()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool forced_discrete_update_events_exist </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8812e3795d6c187c6f21fb441a717db" name="ad8812e3795d6c187c6f21fb441a717db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8812e3795d6c187c6f21fb441a717db">&#9670;&#160;</a></span>forced_publish_events_exist()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool forced_publish_events_exist </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06f70983cdba078821ed784fcf2f775f" name="a06f70983cdba078821ed784fcf2f775f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f70983cdba078821ed784fcf2f775f">&#9670;&#160;</a></span>forced_unrestricted_update_events_exist()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool forced_unrestricted_update_events_exist </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a59e69babd4887d33fc65c02fa7d0aafb" name="a59e69babd4887d33fc65c02fa7d0aafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e69babd4887d33fc65c02fa7d0aafb">&#9670;&#160;</a></span>ForcedPublish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ForcedPublish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Manually triggers any <a class="el" href="classdrake_1_1systems_1_1_publish_event.html" title="This class represents a publish event.">PublishEvent</a> that has trigger type kForced. </p>
<p>Invokes the publish event dispatcher on this System with the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.</p>
<p>The default dispatcher will invoke the handlers (if any) associated with each force-triggered event.</p>
<dl class="section note"><dt>Note</dt><dd>There will always be at least one force-triggered event, though with no associated handler (so will do nothing when triggered).</dd></dl>
<p>The <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> can be configured to call this in <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Simulator::Initialize()</a> and at the start of each continuous integration step. See the <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> API for more details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if it invokes an event handler that returns status indicating failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a432d732019c64ca4a869b35d4d63bb3d" title="This method is the public entry point for dispatching all publish event handlers.">Publish()</a>, <a class="el" href="#ae5fb4376d5f80e2fbaecae478c2ab10b" title="(Advanced) Manually triggers any DiscreteUpdateEvent that has trigger type kForced.">CalcForcedDiscreteVariableUpdate()</a>, <a class="el" href="#a38e86af4aa006febb699db0433d434da" title="(Advanced) Manually triggers any UnrestrictedUpdateEvent that has trigger type kForced.">CalcForcedUnrestrictedUpdate()</a> </dd></dl>

</div>
</div>
<a id="ac72d50dd5540d7a303b1bb8135df5a80" name="ac72d50dd5540d7a303b1bb8135df5a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72d50dd5540d7a303b1bb8135df5a80">&#9670;&#160;</a></span>get_constraint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_system_constraint.html">SystemConstraint</a>&lt; T &gt; &amp; get_constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1systems.html#a69608eb99ec6982ed17d1ac6d3d6dce1">SystemConstraintIndex</a></td>          <td class="paramname"><span class="paramname"><em>constraint_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the constraint at index <code class="param">constraint_index</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>for an invalid constraint_index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae108fee2883346485c35d2f44af45c55" name="ae108fee2883346485c35d2f44af45c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae108fee2883346485c35d2f44af45c55">&#9670;&#160;</a></span>get_forced_discrete_update_events()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &gt; &amp; get_forced_discrete_update_events </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a10c48210c1b86512cf31e885a21d14f7" name="a10c48210c1b86512cf31e885a21d14f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c48210c1b86512cf31e885a21d14f7">&#9670;&#160;</a></span>get_forced_unrestricted_update_events()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; &gt; &amp; get_forced_unrestricted_update_events </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0fe2f150e5e48e0797b00fb8344ae97" name="ad0fe2f150e5e48e0797b00fb8344ae97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0fe2f150e5e48e0797b00fb8344ae97">&#9670;&#160;</a></span>get_input_port() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp; get_input_port </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method for the case of exactly one input port. </p>
<p>This function ignores deprecated ports, unless there is only one port in which case it will return the deprecated port. </p>

</div>
</div>
<a id="a07efaabcfc908b179f7c468a5db507b1" name="a07efaabcfc908b179f7c468a5db507b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07efaabcfc908b179f7c468a5db507b1">&#9670;&#160;</a></span>get_input_port() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp; get_input_port </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>port_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>warn_deprecated</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the typed input port at index <span class="tt">port_index</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">warn_deprecated</td><td>Whether or not to print a warning in case the port was marked as deprecated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada70a32e95cd84cd4fe02c1d25be437d" name="ada70a32e95cd84cd4fe02c1d25be437d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada70a32e95cd84cd4fe02c1d25be437d">&#9670;&#160;</a></span>get_input_port_selection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; * get_input_port_selection </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; <a class="el" href="namespacedrake_1_1systems.html#a5484375bdbfb17f525cd2ed396d747f9">InputPortSelection</a>, <a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>port_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the typed input port specified by the <a class="el" href="namespacedrake_1_1systems.html#a5484375bdbfb17f525cd2ed396d747f9" title="Intended for use in e.g.">InputPortSelection</a> or by the <a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0" title="Serves as the local index for the input ports of a given System.">InputPortIndex</a>. </p>
<p>Returns nullptr if no port is selected. This is provided as a convenience method since many algorithms provide the same common default or optional port semantics. </p>

</div>
</div>
<a id="aef1a605368f8aab79cb543b54d905390" name="aef1a605368f8aab79cb543b54d905390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef1a605368f8aab79cb543b54d905390">&#9670;&#160;</a></span>get_mutable_forced_discrete_update_events()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &gt; &amp; get_mutable_forced_discrete_update_events </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad73b451207ec33640ac284fd90e5232e" name="ad73b451207ec33640ac284fd90e5232e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73b451207ec33640ac284fd90e5232e">&#9670;&#160;</a></span>get_mutable_forced_publish_events()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt; &gt; &amp; get_mutable_forced_publish_events </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6d855ef062a5d964dbdeff200b1bc85" name="aa6d855ef062a5d964dbdeff200b1bc85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d855ef062a5d964dbdeff200b1bc85">&#9670;&#160;</a></span>get_mutable_forced_unrestricted_update_events()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; &gt; &amp; get_mutable_forced_unrestricted_update_events </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abe4ee13b132d5d8ebabff1c029f19a60" name="abe4ee13b132d5d8ebabff1c029f19a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4ee13b132d5d8ebabff1c029f19a60">&#9670;&#160;</a></span>get_mutable_system_scalar_converter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_system_scalar_converter.html">SystemScalarConverter</a> &amp; get_mutable_system_scalar_converter </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classdrake_1_1systems_1_1_system_scalar_converter.html" title="Helper class to convert a System into a System&lt;T&gt;, intended for internal use by the System framework,...">SystemScalarConverter</a> for <span class="tt">this</span> system. </p>

</div>
</div>
<a id="a09d8b12e579f9f806cdf01b645759aef" name="a09d8b12e579f9f806cdf01b645759aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d8b12e579f9f806cdf01b645759aef">&#9670;&#160;</a></span>get_output_port() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp; get_output_port </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method for the case of exactly one output port. </p>
<p>This function ignores deprecated ports, unless there is only one port in which case it will return the deprecated port. </p>

</div>
</div>
<a id="ac3465aeda1eaa9b43827b15090e9d5dc" name="ac3465aeda1eaa9b43827b15090e9d5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3465aeda1eaa9b43827b15090e9d5dc">&#9670;&#160;</a></span>get_output_port() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp; get_output_port </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>port_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>warn_deprecated</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the typed output port at index <span class="tt">port_index</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">warn_deprecated</td><td>Whether or not to print a warning in case the port was marked as deprecated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a991e02715eef0ca58a3ee6dda24a3395" name="a991e02715eef0ca58a3ee6dda24a3395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991e02715eef0ca58a3ee6dda24a3395">&#9670;&#160;</a></span>get_output_port_selection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; * get_output_port_selection </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; <a class="el" href="namespacedrake_1_1systems.html#a00432489001229d1f63cb6d373403a6e">OutputPortSelection</a>, <a class="el" href="namespacedrake_1_1systems.html#afb427ae7d4f36f7a3cfe34eb5a3d51aa">OutputPortIndex</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>port_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the typed output port specified by the <a class="el" href="namespacedrake_1_1systems.html#a00432489001229d1f63cb6d373403a6e" title="Intended for use in e.g.">OutputPortSelection</a> or by the <a class="el" href="namespacedrake_1_1systems.html#afb427ae7d4f36f7a3cfe34eb5a3d51aa" title="Serves as the local index for the output ports of a given System.">OutputPortIndex</a>. </p>
<p>Returns nullptr if no port is selected. This is provided as a convenience method since many algorithms provide the same common default or optional port semantics. </p>

</div>
</div>
<a id="a4f520e00ddac3d41f7e2df922de46da4" name="a4f520e00ddac3d41f7e2df922de46da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f520e00ddac3d41f7e2df922de46da4">&#9670;&#160;</a></span>get_system_scalar_converter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_system_scalar_converter.html">SystemScalarConverter</a> &amp; get_system_scalar_converter </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Returns the <a class="el" href="classdrake_1_1systems_1_1_system_scalar_converter.html" title="Helper class to convert a System into a System&lt;T&gt;, intended for internal use by the System framework,...">SystemScalarConverter</a> for this object. </p>
<p>This is an expert-level API intended for framework authors. Most users should prefer the convenience helpers such as <a class="el" href="#af4283f9cfe4969e5760164a5528b6960" title="Creates a deep copy of this System, transmogrified to use the autodiff scalar type,...">System::ToAutoDiffXd</a>. </p>

</div>
</div>
<a id="a63db490cc14b49e3a67f5195a69cd869" name="a63db490cc14b49e3a67f5195a69cd869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63db490cc14b49e3a67f5195a69cd869">&#9670;&#160;</a></span>get_time_derivatives_cache_entry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html">CacheEntry</a> &amp; get_time_derivatives_cache_entry </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Returns the <a class="el" href="classdrake_1_1systems_1_1_cache_entry.html" title="A CacheEntry belongs to a System and represents the properties of one of that System&#39;s cached computa...">CacheEntry</a> used to cache time derivatives for <a class="el" href="#a15b6e794826488cdb01ef10a2b21a5dd" title="Returns a reference to the cached value of the continuous state variable time derivatives,...">EvalTimeDerivatives()</a>. </p>

</div>
</div>
<a id="abde83cc85484e49d2edf404f64be27b5" name="abde83cc85484e49d2edf404f64be27b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abde83cc85484e49d2edf404f64be27b5">&#9670;&#160;</a></span>GetDirectFeedthroughs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::multimap&lt; int, int &gt; GetDirectFeedthroughs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports all direct feedthroughs from input ports to output ports. </p>
<p>For a system with m input ports: <span class="tt">I = i₀, i₁, ..., iₘ₋₁</span>, and n output ports, <span class="tt">O = o₀, o₁, ..., oₙ₋₁</span>, the return map will contain pairs (u, v) such that</p>
<ul>
<li>0 ≤ u &lt; m,</li>
<li>0 ≤ v &lt; n,</li>
<li>and there <em>might</em> be a direct feedthrough from input iᵤ to each output oᵥ.</li>
</ul>
<p>See <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#DeclareLeafOutputPort_feedthrough">DeclareLeafOutputPort</a> documentation for how leaf systems can report their feedthrough. </p>

<p>Implements <a class="el" href="classdrake_1_1systems_1_1_system_base.html#a55e94ea90f24e5f430d37452d723a1cd">SystemBase</a>.</p>

</div>
</div>
<a id="a7af7e8c763be91ade9abe02f16bda206" name="a7af7e8c763be91ade9abe02f16bda206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af7e8c763be91ade9abe02f16bda206">&#9670;&#160;</a></span>GetGraphvizString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string GetGraphvizString </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; int &gt;</td>          <td class="paramname"><span class="paramname"><em>max_depth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a Graphviz string describing this System. </p>
<p>To render the string, use the <a href="http://www.graphviz.org/">Graphviz</a> tool, <span class="tt">dot</span>.</p>
<p>Notes about the display conventions:</p>
<ul>
<li>The nodes of the graph are systems, and the solid edges are connections between system input and output ports.</li>
<li>The class name of a System is shown in <b>Bold</b> atop the node.</li>
<li>Under the class name, if a System has been given a name via <a class="el" href="classdrake_1_1systems_1_1_system_base.html#ad5260b9627048b854b45d05ed34adc22" title="Sets the name of the system.">set_name()</a>, it will be displayed as <span class="tt">name=...</span>.</li>
<li>Systems can elect to display additional properties besides their name; see GraphvizFragmentParams::header_lines for implementation details.</li>
<li>A <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a>'s input ports are shown with a <span style="border:2px solid blue;border-radius:4px">blue border</span> and output ports are shown with a <span style="border:2px solid green;border-radius:4px">green border</span>.</li>
<li>Zero-sized ports are <span style="color:grey">greyed out</span>.</li>
<li>Deprecated ports are <strike>struck through</strike> and flagged with a headstone emoji (🪦) after their name.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_depth</td><td>Sets a limit to the depth of nested diagrams to visualize. Use zero to render a diagram as a single system block.</td></tr>
    <tr><td class="paramname">options</td><td>Arbitrary strings to request alterations to the output. Options that are unknown will be silently skipped. These options are often bespoke flags that are only understood by particular systems, but Drake has one built-in flag that is generally applicable: <span class="tt">"split"</span>. When set to <span class="tt">"I/O"</span>, the system will be added as two nodes with all inputs on one node and all outputs on the other; this is useful for systems that might otherwise cause problematic visual cycles.</td></tr>
  </table>
  </dd>
</dl>
<p>Options are applied only to this immediate system; they are not inherited by the subsystems of a Diagram. To specify an option for a Diagram's subsystem, prefix the option name with the subsystem's path, e.g., use <span class="tt">"plant/split"="I/O"</span> to set the <span class="tt">"split"</span> option on the subsystem named <span class="tt">"plant"</span>. </p>

</div>
</div>
<a id="ae6f84e649d76754f38ea7420a21a1a04" name="ae6f84e649d76754f38ea7420a21a1a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f84e649d76754f38ea7420a21a1a04">&#9670;&#160;</a></span>GetInitializationEvents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GetInitializationEvents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>events</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is called by <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Simulator::Initialize()</a> to gather all update and publish events that need to be handled at initialization before the simulator starts integration. </p>
<p><code class="param">events</code> cannot be null. <code class="param">events</code> will be cleared on entry. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#adf1f428d7eb6e62bcdd26e9d5a770cba" title="Returns all periodic events in this System.">GetPeriodicEvents()</a>, <a class="el" href="#ad8a24b8f910f9d990db8e59bf2bae6d0" title="This method is called by Simulator::Initialize() to gather all update and publish events that are to ...">GetPerStepEvents()</a> </dd></dl>

</div>
</div>
<a id="a0b235f5342408f469d02b5b5d2dfb555" name="a0b235f5342408f469d02b5b5d2dfb555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b235f5342408f469d02b5b5d2dfb555">&#9670;&#160;</a></span>GetInputPort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">InputPort</a>&lt; T &gt; &amp; GetInputPort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>port_name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the typed input port with the unique name <code class="param">port_name</code>. </p>
<p>The current implementation performs a linear search over strings; prefer <a class="el" href="#a07efaabcfc908b179f7c468a5db507b1" title="Returns the typed input port at index port_index.">get_input_port()</a> when performance is a concern. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if port_name is not found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9714aaf76aca9169da6de7fbcb8339fb" name="a9714aaf76aca9169da6de7fbcb8339fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9714aaf76aca9169da6de7fbcb8339fb">&#9670;&#160;</a></span>GetMemoryObjectName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string GetMemoryObjectName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a name for this System based on a stringification of its type name and memory address. </p>
<p>This is intended for use in diagnostic output and should not be used for behavioral logic, because the stringification of the type name may produce differing results across platforms and because the address can vary from run to run. </p>

</div>
</div>
<a id="a6278437ceb2dce5a6c8f70f19285319a" name="a6278437ceb2dce5a6c8f70f19285319a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6278437ceb2dce5a6c8f70f19285319a">&#9670;&#160;</a></span>GetMutableOutputVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; GetMutableOutputVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_system_output.html">SystemOutput</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>port_index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a mutable Eigen expression for a vector valued output port with index <code class="param">port_index</code> in this system. </p>
<p>All input ports that directly depend on this output port will be notified that upstream data has changed, and may invalidate cache entries as a result. </p>

</div>
</div>
<a id="a95ce57e23ae030c0ef224b0d0b7cc70c" name="a95ce57e23ae030c0ef224b0d0b7cc70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ce57e23ae030c0ef224b0d0b7cc70c">&#9670;&#160;</a></span>GetMutableSubsystemContext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp; GetMutableSubsystemContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>subsystem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable reference to the subcontext that corresponds to the contained System <span class="tt">subsystem</span>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">subsystem</span> not contained in <span class="tt">this</span> System. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given <span class="tt">context</span> is valid for use with <span class="tt">this</span> System. </dd></dl>

</div>
</div>
<a id="accf801fb0529fd09f9a2c3e9ae941147" name="accf801fb0529fd09f9a2c3e9ae941147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf801fb0529fd09f9a2c3e9ae941147">&#9670;&#160;</a></span>GetMyContextFromRoot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp; GetMyContextFromRoot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>root_context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the const <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> for <span class="tt">this</span> subsystem, given a root context. </p>
<p>If <span class="tt">this</span> System is already the top level (root) System, just returns <span class="tt">root_context</span>. (A root <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> is one that does not have a parent <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.) </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the given <span class="tt">root_context</span> is not actually a root context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aaaa7a04bd169a920b4ae90d4e1db4fe5" title="Returns a const reference to the subcontext that corresponds to the contained System subsystem.">GetSubsystemContext()</a> </dd></dl>

</div>
</div>
<a id="abb6f679178e8c8864dfb7d65a3198ee3" name="abb6f679178e8c8864dfb7d65a3198ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6f679178e8c8864dfb7d65a3198ee3">&#9670;&#160;</a></span>GetMyMutableContextFromRoot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp; GetMyMutableContextFromRoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>root_context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the mutable subsystem context for <span class="tt">this</span> system, given a root context. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#accf801fb0529fd09f9a2c3e9ae941147" title="Returns the const Context for this subsystem, given a root context.">GetMyContextFromRoot()</a> </dd></dl>

</div>
</div>
<a id="af900e8c1b8e91219a8771c54f1d130ab" name="af900e8c1b8e91219a8771c54f1d130ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af900e8c1b8e91219a8771c54f1d130ab">&#9670;&#160;</a></span>GetOutputPort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">OutputPort</a>&lt; T &gt; &amp; GetOutputPort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>port_name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the typed output port with the unique name <code class="param">port_name</code>. </p>
<p>The current implementation performs a linear search over strings; prefer <a class="el" href="#ac3465aeda1eaa9b43827b15090e9d5dc" title="Returns the typed output port at index port_index.">get_output_port()</a> when performance is a concern. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if port_name is not found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf1f428d7eb6e62bcdd26e9d5a770cba" name="adf1f428d7eb6e62bcdd26e9d5a770cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1f428d7eb6e62bcdd26e9d5a770cba">&#9670;&#160;</a></span>GetPeriodicEvents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GetPeriodicEvents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>events</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all periodic events in this System. </p>
<p>This includes publish, discrete update, and unrestricted update events.</p>
<p><code class="param">events</code> cannot be null. <code class="param">events</code> will be cleared on entry. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad8a24b8f910f9d990db8e59bf2bae6d0" title="This method is called by Simulator::Initialize() to gather all update and publish events that are to ...">GetPerStepEvents()</a>, <a class="el" href="#ae6f84e649d76754f38ea7420a21a1a04" title="This method is called by Simulator::Initialize() to gather all update and publish events that need to...">GetInitializationEvents()</a> </dd></dl>

</div>
</div>
<a id="ad8a24b8f910f9d990db8e59bf2bae6d0" name="ad8a24b8f910f9d990db8e59bf2bae6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a24b8f910f9d990db8e59bf2bae6d0">&#9670;&#160;</a></span>GetPerStepEvents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GetPerStepEvents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html">CompositeEventCollection</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>events</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is called by <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Simulator::Initialize()</a> to gather all update and publish events that are to be handled in AdvanceTo() at the point before <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> integrates continuous state. </p>
<p>It is assumed that these events remain constant throughout the simulation. The "step" here refers to the major time step taken by the <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a>. During every simulation step, the simulator will merge <code class="param">events</code> with the event collections populated by other types of event triggering mechanism (e.g., <a class="el" href="#a164afe3c1db737b93696b8808bb2c942" title="This method is called by a Simulator during its calculation of the size of the next continuous step t...">CalcNextUpdateTime()</a>), and the merged <a class="el" href="classdrake_1_1systems_1_1_composite_event_collection.html" title="This class bundles an instance of each EventCollection&lt;EventType&gt; into one object that stores the het...">CompositeEventCollection</a> objects will be passed to the appropriate handlers before <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> integrates the continuous state.</p>
<p><code class="param">events</code> cannot be null. <code class="param">events</code> will be cleared on entry. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#adf1f428d7eb6e62bcdd26e9d5a770cba" title="Returns all periodic events in this System.">GetPeriodicEvents()</a>, <a class="el" href="#ae6f84e649d76754f38ea7420a21a1a04" title="This method is called by Simulator::Initialize() to gather all update and publish events that need to...">GetInitializationEvents()</a> </dd></dl>

</div>
</div>
<a id="aaaa7a04bd169a920b4ae90d4e1db4fe5" name="aaaa7a04bd169a920b4ae90d4e1db4fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa7a04bd169a920b4ae90d4e1db4fe5">&#9670;&#160;</a></span>GetSubsystemContext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp; GetSubsystemContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>subsystem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const reference to the subcontext that corresponds to the contained System <span class="tt">subsystem</span>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">subsystem</span> not contained in <span class="tt">this</span> System. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given <span class="tt">context</span> is valid for use with <span class="tt">this</span> System. </dd></dl>

</div>
</div>
<a id="a0e7bc22bdd95c7c611e859c12dfef3e1" name="a0e7bc22bdd95c7c611e859c12dfef3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7bc22bdd95c7c611e859c12dfef3e1">&#9670;&#160;</a></span>GetUniquePeriodicDiscreteUpdateAttribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classdrake_1_1systems_1_1_periodic_event_data.html">PeriodicEventData</a> &gt; GetUniquePeriodicDiscreteUpdateAttribute </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether there exists a unique periodic timing (offset and period) that triggers one or more discrete update events (and, if so, returns that unique periodic timing). </p>
<p>Thus, this method can be used (1) as a test to determine whether a system's dynamics are at least partially governed by difference equations, and (2) to obtain the difference equation update times. Use <a class="el" href="#a1117b27ee2c4131dbcf1e0179c4b9113" title="If this System contains a unique periodic timing for discrete update events, this function executes t...">EvalUniquePeriodicDiscreteUpdate()</a> if you want to determine the actual effects of triggering these events.</p>
<dl class="section warning"><dt>Warning</dt><dd>Even if we find a unique discrete update timing as described above, there may also be unrestricted updates performed with that timing or other timings. (Unrestricted updates can modify any state variables <em>including</em> discrete variables.) Also, there may be trigger types other than periodic that can modify discrete variables. This function does not attempt to look for any of those; they are simply ignored. If you are concerned with those, you can use <a class="el" href="#ad8a24b8f910f9d990db8e59bf2bae6d0" title="This method is called by Simulator::Initialize() to gather all update and publish events that are to ...">GetPerStepEvents()</a>, <a class="el" href="#ae6f84e649d76754f38ea7420a21a1a04" title="This method is called by Simulator::Initialize() to gather all update and publish events that need to...">GetInitializationEvents()</a>, and <a class="el" href="#adf1f428d7eb6e62bcdd26e9d5a770cba" title="Returns all periodic events in this System.">GetPeriodicEvents()</a> to get a more comprehensive picture of the event landscape.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>optional&lt;PeriodicEventData&gt; Contains the unique periodic trigger timing if it exists, otherwise <span class="tt">nullopt</span>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1117b27ee2c4131dbcf1e0179c4b9113" title="If this System contains a unique periodic timing for discrete update events, this function executes t...">EvalUniquePeriodicDiscreteUpdate()</a>, <a class="el" href="#aeb5016cfee3ccd384e0a0ba62b4da5bc" title="Returns true iff the state dynamics of this system are governed exclusively by a difference equation ...">IsDifferenceEquationSystem()</a> </dd></dl>

</div>
</div>
<a id="ab9f777bd94a7d9188a905ac6ecfff577" name="ab9f777bd94a7d9188a905ac6ecfff577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f777bd94a7d9188a905ac6ecfff577">&#9670;&#160;</a></span>GetWitnessFunctions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GetWitnessFunctions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="classdrake_1_1systems_1_1_witness_function.html">WitnessFunction</a>&lt; T &gt; * &gt; *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the witness functions active for the given state. </p>
<p><a class="el" href="#af6d0f8fa7471b9cf026c9b7bf86f615c" title="Derived classes can override this method to provide witness functions active for the given state.">DoGetWitnessFunctions()</a> does the actual work. The vector of active witness functions are expected to change only upon an unrestricted update. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">context</td><td>a valid context for the <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> (aborts if not true). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>a valid pointer to an empty vector that will store pointers to the witness functions active for the current state. The method aborts if witnesses is null or non-empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f62cabd62a694728e1ae913d6d99163" name="a7f62cabd62a694728e1ae913d6d99163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f62cabd62a694728e1ae913d6d99163">&#9670;&#160;</a></span>HandlePostConstructionScalarConversion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HandlePostConstructionScalarConversion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Internal use only) <a class="el" href="#a78eaec0a6a2d1c99d2a7eb5eeb1f8bdc" title="The scalar type with which this System was instantiated.">Scalar</a> conversion (e.g., ToAutoDiffXd) will first call the <a class="el" href="classdrake_1_1systems_1_1_system_scalar_converter.html" title="Helper class to convert a System into a System&lt;T&gt;, intended for internal use by the System framework,...">SystemScalarConverter</a> to construct the converted system, and then call this function for any post-construction cleanup. </p>

</div>
</div>
<a id="a037dd9c0afe6e059e67edb4c9c01eeb3" name="a037dd9c0afe6e059e67edb4c9c01eeb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037dd9c0afe6e059e67edb4c9c01eeb3">&#9670;&#160;</a></span>HasAnyDirectFeedthrough()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool HasAnyDirectFeedthrough </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if any of the inputs to the system might be directly fed through to any of its outputs and <span class="tt">false</span> otherwise. </p>

</div>
</div>
<a id="a8dd5092dc2aa2c8f38e0d6336437012d" name="a8dd5092dc2aa2c8f38e0d6336437012d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd5092dc2aa2c8f38e0d6336437012d">&#9670;&#160;</a></span>HasDirectFeedthrough() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool HasDirectFeedthrough </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>input_port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>output_port</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if there might be direct-feedthrough from the given <code class="param">input_port</code> to the given <code class="param">output_port</code>, and false otherwise. </p>

</div>
</div>
<a id="a51acfa17df1bc87ce8eaa0e1556f6d46" name="a51acfa17df1bc87ce8eaa0e1556f6d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51acfa17df1bc87ce8eaa0e1556f6d46">&#9670;&#160;</a></span>HasDirectFeedthrough() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool HasDirectFeedthrough </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>output_port</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if there might be direct-feedthrough from any input port to the given <code class="param">output_port</code>, and false otherwise. </p>

</div>
</div>
<a id="a2de14ac72441c44be8dec6cc6719dd1e" name="a2de14ac72441c44be8dec6cc6719dd1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de14ac72441c44be8dec6cc6719dd1e">&#9670;&#160;</a></span>HasInputPort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool HasInputPort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>port_name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the system has an <a class="el" href="classdrake_1_1systems_1_1_input_port.html" title="An InputPort is a System resource that describes the kind of input a System accepts,...">InputPort</a> of the given <code class="param">port_name</code>. </p>

</div>
</div>
<a id="a70946c955bb9100cc8e9dc1f5df5c8bc" name="a70946c955bb9100cc8e9dc1f5df5c8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70946c955bb9100cc8e9dc1f5df5c8bc">&#9670;&#160;</a></span>HasOutputPort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool HasOutputPort </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>port_name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the system has an <a class="el" href="classdrake_1_1systems_1_1_output_port.html" title="An OutputPort belongs to a System and represents the properties of one of that System&#39;s output ports.">OutputPort</a> of the given <code class="param">port_name</code>. </p>

</div>
</div>
<a id="a191b7cb5dcbfee51a62fa042ec14561f" name="a191b7cb5dcbfee51a62fa042ec14561f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191b7cb5dcbfee51a62fa042ec14561f">&#9670;&#160;</a></span>input_port_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> input_port_ticket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1systems.html#aa53feaf560f7ff6cfa4add8dc6ff0db0">InputPortIndex</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a ticket indicating dependence on input port uᵢ indicated by <span class="tt">index</span>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">index</span> selects an existing input port of this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>. </dd></dl>

</div>
</div>
<a id="aeb5016cfee3ccd384e0a0ba62b4da5bc" name="aeb5016cfee3ccd384e0a0ba62b4da5bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5016cfee3ccd384e0a0ba62b4da5bc">&#9670;&#160;</a></span>IsDifferenceEquationSystem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool IsDifferenceEquationSystem </td>
          <td>(</td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>time_period</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the state dynamics of this system are governed exclusively by a difference equation on a single discrete state group and with a unique periodic update (having zero offset). </p>
<p>E.g., it is amenable to analysis of the form: </p><pre class="fragment">x[n+1] = f(n, x[n], u[n], w[n]; p)
</pre><p>where t is time, x is (discrete) state, u is a vector input, w is random (disturbance) input, and p are parameters. Note that we do NOT consider the number of input ports here, because in practice many systems of interest (e.g. MultibodyPlant) have input ports that are safely treated as constant during the analysis. Consider using <a class="el" href="#ada70a32e95cd84cd4fe02c1d25be437d" title="Returns the typed input port specified by the InputPortSelection or by the InputPortIndex.">get_input_port_selection()</a> to choose one.</p>
<dl class="section warning"><dt>Warning</dt><dd>In determining whether this system is governed as above, we do not consider unrestricted updates nor any update events that have trigger types other than periodic. See <a class="el" href="#a0e7bc22bdd95c7c611e859c12dfef3e1" title="Determines whether there exists a unique periodic timing (offset and period) that triggers one or mor...">GetUniquePeriodicDiscreteUpdateAttribute()</a> for more information.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">time_period</td><td>if non-null, then iff the function returns <span class="tt">true</span>, then time_period is set to the period data returned from <a class="el" href="#a0e7bc22bdd95c7c611e859c12dfef3e1" title="Determines whether there exists a unique periodic timing (offset and period) that triggers one or mor...">GetUniquePeriodicDiscreteUpdateAttribute()</a>. If the function returns <span class="tt">false</span> (the system is not a difference equation system), then <span class="tt">time_period</span> does not receive a value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0e7bc22bdd95c7c611e859c12dfef3e1" title="Determines whether there exists a unique periodic timing (offset and period) that triggers one or mor...">GetUniquePeriodicDiscreteUpdateAttribute()</a> </dd>
<dd>
<a class="el" href="#a1117b27ee2c4131dbcf1e0179c4b9113" title="If this System contains a unique periodic timing for discrete update events, this function executes t...">EvalUniquePeriodicDiscreteUpdate()</a> </dd></dl>

</div>
</div>
<a id="a6c3ec92003f2a50d5d2b0c49aa296b86" name="a6c3ec92003f2a50d5d2b0c49aa296b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3ec92003f2a50d5d2b0c49aa296b86">&#9670;&#160;</a></span>IsDifferentialEquationSystem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool IsDifferentialEquationSystem </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the state dynamics of this system are governed exclusively by a differential equation. </p>
<p>E.g., it is amenable to analysis of the form: </p><pre class="fragment">ẋ = f(t, x(t), u(t), w(t); p),
</pre><p>where t is time, x is (continuous) state, u is a vector input, w is random (disturbance) input, and p are parameters. This requires that it has no discrete nor abstract states, and no abstract input ports.</p>
<dl class="section warning"><dt>Warning</dt><dd>In determining whether this system is governed as above, we do not consider unrestricted updates which could potentially update the state. </dd></dl>

</div>
</div>
<a id="a66e1d9af27119011a497b78df6907b1a" name="a66e1d9af27119011a497b78df6907b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e1d9af27119011a497b78df6907b1a">&#9670;&#160;</a></span>ke_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> ke_ticket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a ticket for the cache entry that holds the kinetic energy calculation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#abfc345ff50df77ad2ae727e6d3a9b939" title="Returns a reference to the cached value of the kinetic energy (KE), evaluating first if necessary usi...">System::EvalKineticEnergy()</a> </dd></dl>

</div>
</div>
<a id="a1291b5091aa55dbd03c9b5944dbced09" name="a1291b5091aa55dbd03c9b5944dbced09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1291b5091aa55dbd03c9b5944dbced09">&#9670;&#160;</a></span>kinematics_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> kinematics_ticket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a ticket indicating dependence on all source values that may affect configuration- or velocity-dependent computations. </p>
<p>This ticket depends on the configuration_ticket defined above, and adds in velocity-affecting source values. This <em>does not</em> include time or input ports. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a28830dced98dcdc1f498d8d250db0ae4" title="Returns a ticket indicating dependence on all source values that may affect configuration-dependent c...">configuration_ticket()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Currently there is no way to declare specific variables and parameters to be configuration- or velocity-affecting so we include all state variables and parameters except for state variables z. </dd></dl>

</div>
</div>
<a id="a60cb116e195ba4b7d23fa39e094b4402" name="a60cb116e195ba4b7d23fa39e094b4402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60cb116e195ba4b7d23fa39e094b4402">&#9670;&#160;</a></span>MapPeriodicEventsByTiming()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; <a class="el" href="classdrake_1_1systems_1_1_periodic_event_data.html">PeriodicEventData</a>, std::vector&lt; const <a class="el" href="classdrake_1_1systems_1_1_event.html">Event</a>&lt; T &gt; * &gt;, <a class="el" href="structdrake_1_1systems_1_1_periodic_event_data_comparator.html">PeriodicEventDataComparator</a> &gt; MapPeriodicEventsByTiming </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps all periodic triggered events for a System, organized by timing. </p>
<p>Each unique periodic timing attribute (offset and period) is mapped to the set of <a class="el" href="classdrake_1_1systems_1_1_event.html" title="Abstract base class that represents an event.">Event</a> objects that are triggered with that timing. Those may include a mix of Publish, DiscreteUpdate, and UnrestrictedUpdate events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Optional <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> to pass on to <a class="el" href="classdrake_1_1systems_1_1_event.html" title="Abstract base class that represents an event.">Event</a> selection functions; not commonly needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e3359a1ddbc3371e70de3a053113c00" name="a0e3359a1ddbc3371e70de3a053113c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3359a1ddbc3371e70de3a053113c00">&#9670;&#160;</a></span>MapQDotToVelocity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MapQDotToVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>qdot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>generalized_velocity</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms the given time derivative <span class="tt">qdot</span> of generalized configuration <span class="tt">q</span> to generalized velocity <span class="tt">v</span>. </p>
<p>This signature takes <span class="tt">qdot</span> as an Eigen <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85" title="A column vector of any size, templated on scalar type.">VectorX</a> object for faster speed. See the other signature of <a class="el" href="#a10eba167739bfe8e7e419b5c8ae41537" title="Transforms the time derivative qdot of the generalized configuration q to generalized velocities v.">MapQDotToVelocity()</a> for additional information. </p>

</div>
</div>
<a id="a10eba167739bfe8e7e419b5c8ae41537" name="a10eba167739bfe8e7e419b5c8ae41537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10eba167739bfe8e7e419b5c8ae41537">&#9670;&#160;</a></span>MapQDotToVelocity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MapQDotToVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>qdot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>generalized_velocity</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms the time derivative <span class="tt">qdot</span> of the generalized configuration <span class="tt">q</span> to generalized velocities <span class="tt">v</span>. </p>
<p><span class="tt">v</span> and <span class="tt">qdot</span> are related linearly by <span class="tt">qdot = N(q) * v</span>, where <span class="tt">N</span> is a block diagonal matrix. For example, in a multibody system there will be one block of <span class="tt">N</span> per tree joint. Although <span class="tt">N</span> is not necessarily square, its left pseudo-inverse <span class="tt">N+</span> can be used to invert that relationship without residual error, provided that <span class="tt">qdot</span> is in the range space of <span class="tt">N</span> (that is, if it <em>could</em> have been produced as <span class="tt">qdot=N*v</span> for some <span class="tt">v</span>). Using the configuration <span class="tt">q</span> from the given <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> this method calculates <span class="tt">v = N+ * qdot</span> (where <span class="tt">N+=N+(q)</span>) for a given <span class="tt">qdot</span>. This computation requires only <span class="tt">O(nq)</span> time where <span class="tt">nq</span> is the size of <span class="tt">qdot</span>. Note that this method does not take <span class="tt">qdot</span> from the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.</p>
<p>See the alternate signature if you already have <span class="tt">qdot</span> in an Eigen <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85" title="A column vector of any size, templated on scalar type.">VectorX</a> object; this signature will copy the <a class="el" href="classdrake_1_1systems_1_1_vector_base.html" title="VectorBase is an abstract base class that real-valued signals between Systems and real-valued System ...">VectorBase</a> into an Eigen object before performing the computation. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a05cc5df6d0d0fe4ea54b522ae776ca39" title="Transforms a given generalized velocity v to the time derivative qdot of the generalized configuratio...">MapVelocityToQDot()</a> </dd></dl>

</div>
</div>
<a id="a5225185780af0a535ea7733ce801e1ff" name="a5225185780af0a535ea7733ce801e1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5225185780af0a535ea7733ce801e1ff">&#9670;&#160;</a></span>MapVelocityToQDot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MapVelocityToQDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>generalized_velocity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>qdot</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms the given generalized velocity to the time derivative of generalized configuration. </p>
<p>See the other signature of <a class="el" href="#a05cc5df6d0d0fe4ea54b522ae776ca39" title="Transforms a given generalized velocity v to the time derivative qdot of the generalized configuratio...">MapVelocityToQDot()</a> for more information. </p>

</div>
</div>
<a id="a05cc5df6d0d0fe4ea54b522ae776ca39" name="a05cc5df6d0d0fe4ea54b522ae776ca39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05cc5df6d0d0fe4ea54b522ae776ca39">&#9670;&#160;</a></span>MapVelocityToQDot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MapVelocityToQDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>generalized_velocity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>qdot</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a given generalized velocity <span class="tt">v</span> to the time derivative <span class="tt">qdot</span> of the generalized configuration <span class="tt">q</span> taken from the supplied <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. </p>
<p><span class="tt">v</span> and <span class="tt">qdot</span> are related linearly by <span class="tt">qdot = N(q) * v</span>, where <span class="tt">N</span> is a block diagonal matrix. For example, in a multibody system there will be one block of <span class="tt">N</span> per tree joint. This computation requires only <span class="tt">O(nq)</span> time where <span class="tt">nq</span> is the size of <span class="tt">qdot</span>. Note that <span class="tt">v</span> is <em>not</em> taken from the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>; it is given as an argument here.</p>
<p>See the alternate signature if you already have the generalized velocity in an Eigen <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85" title="A column vector of any size, templated on scalar type.">VectorX</a> object; this signature will copy the <a class="el" href="classdrake_1_1systems_1_1_vector_base.html" title="VectorBase is an abstract base class that real-valued signals between Systems and real-valued System ...">VectorBase</a> into an Eigen object before performing the computation. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a10eba167739bfe8e7e419b5c8ae41537" title="Transforms the time derivative qdot of the generalized configuration q to generalized velocities v.">MapQDotToVelocity()</a> </dd></dl>

</div>
</div>
<a id="a6fe75ddbd79ab1d862df9a50b3c8a624" name="a6fe75ddbd79ab1d862df9a50b3c8a624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe75ddbd79ab1d862df9a50b3c8a624">&#9670;&#160;</a></span>nothing_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> nothing_ticket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a ticket indicating that a computation does not depend on <em>any</em> source value; that is, it is a constant. </p>
<p>If this appears in a prerequisite list, it must be the only entry. </p>

</div>
</div>
<a id="a23f1475b0c301d9d78814fce265fd6ea" name="a23f1475b0c301d9d78814fce265fd6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f1475b0c301d9d78814fce265fd6ea">&#9670;&#160;</a></span>num_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_constraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of constraints specified for the system. </p>

</div>
</div>
<a id="a94a6d73c74c7268734792b3703e8600d" name="a94a6d73c74c7268734792b3703e8600d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a6d73c74c7268734792b3703e8600d">&#9670;&#160;</a></span>num_input_ports()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_input_ports </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of input ports currently allocated in this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>. </p>
<p>These are indexed from 0 to num_input_ports()-1. </p>

</div>
</div>
<a id="a7ceec1b22b6b1b25fc675234e78e71be" name="a7ceec1b22b6b1b25fc675234e78e71be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ceec1b22b6b1b25fc675234e78e71be">&#9670;&#160;</a></span>num_output_ports()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_output_ports </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of output ports currently allocated in this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>. </p>
<p>These are indexed from 0 to num_output_ports()-1. </p>

</div>
</div>
<a id="a45e0bf1fd3096bff3df2587ec4f02285" name="a45e0bf1fd3096bff3df2587ec4f02285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e0bf1fd3096bff3df2587ec4f02285">&#9670;&#160;</a></span>numeric_parameter_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> numeric_parameter_ticket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1systems.html#af11369a06c5bfd3fa18acb79f85777df">NumericParameterIndex</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a ticket indicating dependence on a particular numeric parameter pnᵢ (may be a vector). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aaeae092662e78f50416eb6dc01ad3ddb" title="Returns a ticket indicating dependence on all of the numerical parameters in the current Context.">pn_ticket()</a> to obtain a ticket for <em><a class="el" href="namespacedrake.html#a6f017505f166d0b60735ba1c4a9b4f23" title="Checks truth for all elements in matrix m.">all</a></em> numeric parameters. </dd></dl>

</div>
</div>
<a id="a7623bef605c331dd6ffbf1e1436c4a41" name="a7623bef605c331dd6ffbf1e1436c4a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7623bef605c331dd6ffbf1e1436c4a41">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8b7c37e1f1027f9aa77d77efaffeb0d" name="ab8b7c37e1f1027f9aa77d77efaffeb0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b7c37e1f1027f9aa77d77efaffeb0d">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af3c65473a41f73091c600eaead714fe2" name="af3c65473a41f73091c600eaead714fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c65473a41f73091c600eaead714fe2">&#9670;&#160;</a></span>pa_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> pa_ticket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a ticket indicating dependence on all of the abstract parameters pa in the current <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1a4ef0e0e633c6f722ee518308d7cb5a" title="Returns a ticket indicating dependence on a particular abstract parameter paᵢ.">abstract_parameter_ticket()</a> to obtain a ticket for just one abstract parameter. </dd></dl>

</div>
</div>
<a id="afdc60bc4c201f17bd35bf40c13a183b3" name="afdc60bc4c201f17bd35bf40c13a183b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc60bc4c201f17bd35bf40c13a183b3">&#9670;&#160;</a></span>pc_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> pc_ticket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a ticket for the cache entry that holds the conservative power calculation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a94bf4d9472a96aad5d65e47375cf035f" title="Returns a reference to the cached value of the conservative power (Pc), evaluating first if necessary...">System::EvalConservativePower()</a> </dd></dl>

</div>
</div>
<a id="a49f1689b1ae9f05b6e2f194db873927b" name="a49f1689b1ae9f05b6e2f194db873927b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f1689b1ae9f05b6e2f194db873927b">&#9670;&#160;</a></span>pe_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> pe_ticket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a ticket for the cache entry that holds the potential energy calculation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a97c1ac3506af8f2c386ba74b5fbc1e48" title="Returns a reference to the cached value of the potential energy (PE), evaluating first if necessary u...">System::EvalPotentialEnergy()</a> </dd></dl>

</div>
</div>
<a id="aaeae092662e78f50416eb6dc01ad3ddb" name="aaeae092662e78f50416eb6dc01ad3ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeae092662e78f50416eb6dc01ad3ddb">&#9670;&#160;</a></span>pn_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> pn_ticket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a ticket indicating dependence on all of the numerical parameters in the current <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a45e0bf1fd3096bff3df2587ec4f02285" title="Returns a ticket indicating dependence on a particular numeric parameter pnᵢ (may be a vector).">numeric_parameter_ticket()</a> to obtain a ticket for just one numeric parameter. </dd></dl>

</div>
</div>
<a id="a0afc9712c887706c12039e871476f30c" name="a0afc9712c887706c12039e871476f30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0afc9712c887706c12039e871476f30c">&#9670;&#160;</a></span>pnc_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> pnc_ticket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a ticket for the cache entry that holds the non-conservative power calculation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a08ed6bf23e134cbc50d073e81ffc247f" title="Returns a reference to the cached value of the non-conservative power (Pnc), evaluating first if nece...">System::EvalNonConservativePower()</a> </dd></dl>

</div>
</div>
<a id="a432d732019c64ca4a869b35d4d63bb3d" name="a432d732019c64ca4a869b35d4d63bb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a432d732019c64ca4a869b35d4d63bb3d">&#9670;&#160;</a></span>Publish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_event_status.html">EventStatus</a> Publish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>events</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is the public entry point for dispatching all publish event handlers. </p>
<p>It checks the validity of <code class="param">context</code>, and directly calls DispatchPublishHandler. <code class="param">events</code> is a homogeneous collection of publish events.</p>
<dl class="section note"><dt>Note</dt><dd>When publishing is triggered at particular times, those times likely will not coincide with integrator step times. A <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> may interpolate to generate a suitable <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>, or it may adjust the integrator step size so that a step begins exactly at the next publication time. In the latter case the change in step size may affect the numerical result somewhat since a smaller integrator step produces a more accurate solution. </dd></dl>

</div>
</div>
<a id="a41d3cdadf7d6b62b055993148b82df19" name="a41d3cdadf7d6b62b055993148b82df19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d3cdadf7d6b62b055993148b82df19">&#9670;&#160;</a></span>q_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> q_ticket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a ticket indicating that a computation depends on configuration state variables q. </p>
<p>There is no ticket representing just one of the state variables qᵢ. </p>

</div>
</div>
<a id="a5628467a4abaa6312e4389cb7c02a687" name="a5628467a4abaa6312e4389cb7c02a687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5628467a4abaa6312e4389cb7c02a687">&#9670;&#160;</a></span>set_forced_discrete_update_events()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_forced_discrete_update_events </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_discrete_update_event.html">DiscreteUpdateEvent</a>&lt; T &gt; &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>forced</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4be1a810c98e302ef15018ddcbe35b70" name="a4be1a810c98e302ef15018ddcbe35b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be1a810c98e302ef15018ddcbe35b70">&#9670;&#160;</a></span>set_forced_publish_events()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_forced_publish_events </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_publish_event.html">PublishEvent</a>&lt; T &gt; &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>forced</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8eb3004ad3b51c25596cf422355fde54" name="a8eb3004ad3b51c25596cf422355fde54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb3004ad3b51c25596cf422355fde54">&#9670;&#160;</a></span>set_forced_unrestricted_update_events()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_forced_unrestricted_update_events </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_event_collection.html">EventCollection</a>&lt; <a class="el" href="classdrake_1_1systems_1_1_unrestricted_update_event.html">UnrestrictedUpdateEvent</a>&lt; T &gt; &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>forced</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4e6ee413f4f47a20f6dcc2cbd831b88" name="ab4e6ee413f4f47a20f6dcc2cbd831b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e6ee413f4f47a20f6dcc2cbd831b88">&#9670;&#160;</a></span>SetDefaultContext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetDefaultContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> fields to their default values. </p>
<p>User code should not override. </p>

</div>
</div>
<a id="abb9c4edaf95ef26f1ec419f32446e042" name="abb9c4edaf95ef26f1ec419f32446e042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9c4edaf95ef26f1ec419f32446e042">&#9670;&#160;</a></span>SetDefaultParameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetDefaultParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_parameters.html">Parameters</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>parameters</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns default values to all parameters. </p>
<p>Overrides must not change the number of parameters.</p>
<dl class="section warning"><dt>Warning</dt><dd><span class="tt">parameters</span> <em>may be</em> a mutable view into <span class="tt">context</span>. Don't assume that evaluating <span class="tt">context</span> will be independent of writing to <span class="tt">parameters</span>. </dd></dl>

<p>Implemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a032a4baedb53bf9cf8579913217fe335">Diagram&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a032a4baedb53bf9cf8579913217fe335">Diagram&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a48a5a76172d2c18e3ac495b44c866c1b">LeafSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a48a5a76172d2c18e3ac495b44c866c1b">LeafSystem&lt; double &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a48a5a76172d2c18e3ac495b44c866c1b">LeafSystem&lt; drake::ad::AutoDiff &gt;</a>.</p>

</div>
</div>
<a id="a909935648b14e55b07263264616ace3c" name="a909935648b14e55b07263264616ace3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909935648b14e55b07263264616ace3c">&#9670;&#160;</a></span>SetDefaultState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetDefaultState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns default values to all elements of the state. </p>
<p>Overrides must not change the number of state variables. The context's default parameters will have already been set.</p>
<dl class="section warning"><dt>Warning</dt><dd><span class="tt">state</span> <em>may be</em> a mutable view into <span class="tt">context</span>. Don't assume that evaluating <span class="tt">context</span> will be independent of writing to <span class="tt">state</span>. </dd></dl>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_differential_inverse_kinematics_controller.html#a8df1b6085b2b28bb6c0207e5ac345bfc">DifferentialInverseKinematicsController</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae73edc00d493b3f15ba7679cc14830a0">MultibodyPlant&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae73edc00d493b3f15ba7679cc14830a0">MultibodyPlant&lt; double &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae73edc00d493b3f15ba7679cc14830a0">MultibodyPlant&lt; drake::ad::AutoDiff &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#ac920e22e905b83dbc0abaaa57d2c0251">Diagram&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#ac920e22e905b83dbc0abaaa57d2c0251">Diagram&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ac920e22e905b83dbc0abaaa57d2c0251">LeafSystem&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ac920e22e905b83dbc0abaaa57d2c0251">LeafSystem&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#ac920e22e905b83dbc0abaaa57d2c0251">LeafSystem&lt; drake::ad::AutoDiff &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_time_varying_affine_system.html#ac920e22e905b83dbc0abaaa57d2c0251">TimeVaryingAffineSystem&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a6a5a403983483dda39f8196a241225f2" name="a6a5a403983483dda39f8196a241225f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5a403983483dda39f8196a241225f2">&#9670;&#160;</a></span>SetRandomContext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetRandomContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *</td>          <td class="paramname"><span class="paramname"><em>generator</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> fields to random values. </p>
<p>User code should not override. </p>

</div>
</div>
<a id="af7a8969fd7784256a68402b391f8902b" name="af7a8969fd7784256a68402b391f8902b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a8969fd7784256a68402b391f8902b">&#9670;&#160;</a></span>SetRandomParameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetRandomParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_parameters.html">Parameters</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>parameters</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *</td>          <td class="paramname"><span class="paramname"><em>generator</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns random values to all parameters. </p>
<p>This default implementation calls SetDefaultParameters; override this method to provide random parameters using the stdc++ random library, e.g.: </p><div class="fragment"><div class="line">std::uniform_real_distribution&lt;T&gt; uniform();</div>
<div class="line">parameters-&gt;get_mutable_numeric_parameter(0)</div>
<div class="line">          -&gt;SetAtIndex(0, uniform(*generator));</div>
</div><!-- fragment --><p> Overrides must not change the number of state variables.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__stochastic__systems.html">Stochastic Systems</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a90905f3227a56e00876f9954f0f044f5">Diagram&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#a90905f3227a56e00876f9954f0f044f5">Diagram&lt; double &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_multilayer_perceptron.html#ad2efb988c6fc13502a486a9798f0a5e0">MultilayerPerceptron&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a47a8dc372e0063851c9851ee15da74e9" name="a47a8dc372e0063851c9851ee15da74e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a8dc372e0063851c9851ee15da74e9">&#9670;&#160;</a></span>SetRandomState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetRandomState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">State</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *</td>          <td class="paramname"><span class="paramname"><em>generator</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns random values to all elements of the state. </p>
<p>This default implementation calls SetDefaultState; override this method to provide random initial conditions using the stdc++ random library, e.g.: </p><div class="fragment"><div class="line">std::normal_distribution&lt;T&gt; gaussian();</div>
<div class="line">state-&gt;get_mutable_continuous_state()-&gt;get_mutable_vector()</div>
<div class="line">     -&gt;SetAtIndex(0, gaussian(*generator));</div>
</div><!-- fragment --><p> Overrides must not change the number of state variables.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__stochastic__systems.html">Stochastic Systems</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classdrake_1_1multibody_1_1_differential_inverse_kinematics_controller.html#a3a3736e022ec7b3289503180e38c1d35">DifferentialInverseKinematicsController</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a470c99c41ab31927ae50c9996786bd10">MultibodyPlant&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a470c99c41ab31927ae50c9996786bd10">MultibodyPlant&lt; double &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a470c99c41ab31927ae50c9996786bd10">MultibodyPlant&lt; drake::ad::AutoDiff &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#aa6c1de9b14d8feed0e50ac1e49c9a661">Diagram&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_diagram.html#aa6c1de9b14d8feed0e50ac1e49c9a661">Diagram&lt; double &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_time_varying_affine_system.html#aa6c1de9b14d8feed0e50ac1e49c9a661">TimeVaryingAffineSystem&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a68516072b2dc51a601f2de699691f1c3" name="a68516072b2dc51a601f2de699691f1c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68516072b2dc51a601f2de699691f1c3">&#9670;&#160;</a></span>time_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> time_ticket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a ticket indicating dependence on time. </p>
<p>This is the same ticket for all systems and refers to the same time value. </p>

</div>
</div>
<a id="af4283f9cfe4969e5760164a5528b6960" name="af4283f9cfe4969e5760164a5528b6960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4283f9cfe4969e5760164a5528b6960">&#9670;&#160;</a></span>ToAutoDiffXd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; <a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854">AutoDiffXd</a> &gt; &gt; ToAutoDiffXd </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a deep copy of this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>, transmogrified to use the autodiff scalar type, with a dynamic-sized vector of partial derivatives. </p>
<p>The result is never nullptr. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> does not support autodiff</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="group__system__scalar__conversion.html">System Scalar Conversion</a> for detailed background and examples related to scalar-type conversion support. </p>

</div>
</div>
<a id="aa1d9f903212bc7c15bda23fe8e97d9fa" name="aa1d9f903212bc7c15bda23fe8e97d9fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d9f903212bc7c15bda23fe8e97d9fa">&#9670;&#160;</a></span>ToAutoDiffXd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename &gt; class S = ::drake::systems::System&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; S&lt; <a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854">AutoDiffXd</a> &gt; &gt; ToAutoDiffXd </td>
          <td>(</td>
          <td class="paramtype">const S&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a deep copy of <span class="tt">from</span>, transmogrified to use the autodiff scalar type, with a dynamic-sized vector of partial derivatives. </p>
<p>The result is never nullptr. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">from</span> does not support autodiff</td></tr>
  </table>
  </dd>
</dl>
<p>Usage: </p><div class="fragment"><div class="line">MySystem&lt;double&gt; plant;</div>
<div class="line">std::unique_ptr&lt;MySystem&lt;AutoDiffXd&gt;&gt; ad_plant =</div>
<div class="line">    <a class="code hl_function" href="#af4283f9cfe4969e5760164a5528b6960">systems::System&lt;double&gt;::ToAutoDiffXd</a>(plant);</div>
<div class="ttc" id="aclassdrake_1_1systems_1_1_system_html_af4283f9cfe4969e5760164a5528b6960"><div class="ttname"><a href="#af4283f9cfe4969e5760164a5528b6960">drake::systems::System::ToAutoDiffXd</a></div><div class="ttdeci">std::unique_ptr&lt; System&lt; AutoDiffXd &gt; &gt; ToAutoDiffXd() const</div><div class="ttdoc">Creates a deep copy of this System, transmogrified to use the autodiff scalar type,...</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The specific <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> type to accept and return.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="group__system__scalar__conversion.html">System Scalar Conversion</a> for detailed background and examples related to scalar-type conversion support. </p>

</div>
</div>
<a id="ac91d9e1abca4161ce227d4ebafb3496a" name="ac91d9e1abca4161ce227d4ebafb3496a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91d9e1abca4161ce227d4ebafb3496a">&#9670;&#160;</a></span>ToAutoDiffXdMaybe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; <a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854">AutoDiffXd</a> &gt; &gt; ToAutoDiffXdMaybe </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a deep copy of this system exactly like <a class="el" href="#af4283f9cfe4969e5760164a5528b6960" title="Creates a deep copy of this System, transmogrified to use the autodiff scalar type,...">ToAutoDiffXd()</a>, but returns nullptr if this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> does not support autodiff, instead of throwing an exception. </p>

</div>
</div>
<a id="ad122edf04333ce57b3520d14f06939b2" name="ad122edf04333ce57b3520d14f06939b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad122edf04333ce57b3520d14f06939b2">&#9670;&#160;</a></span>ToScalarType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; U &gt; &gt; ToScalarType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a deep copy of this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>, transmogrified to use the scalar type selected by a template parameter. </p>
<p>The result is never nullptr. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> does not support the destination type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The destination scalar type. For a list of supported types, see the <a class="el" href="group__default__scalars.html">default scalars</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="group__system__scalar__conversion.html">System Scalar Conversion</a> for detailed background and examples related to scalar-type conversion support. </p>

</div>
</div>
<a id="ad0c1bcc05d4a4ecd79cd4c2e5edd0cb6" name="ad0c1bcc05d4a4ecd79cd4c2e5edd0cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c1bcc05d4a4ecd79cd4c2e5edd0cb6">&#9670;&#160;</a></span>ToScalarType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U, template&lt; typename &gt; class S = ::drake::systems::System&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; S&lt; U &gt; &gt; ToScalarType </td>
          <td>(</td>
          <td class="paramtype">const S&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a deep copy of <span class="tt">from</span>, transmogrified to use the scalar type selected by a template parameter. </p>
<p>The result is never nullptr. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">from</span> does not support the destination type.</td></tr>
  </table>
  </dd>
</dl>
<p>Usage: </p><div class="fragment"><div class="line">MySystem&lt;double&gt; plant;</div>
<div class="line"><span class="keyword">auto</span> sym_plant =</div>
<div class="line">  <a class="code hl_function" href="#ad122edf04333ce57b3520d14f06939b2">systems::System&lt;double&gt;::ToScalarType&lt;symbolic::Expression&gt;</a>(plant);</div>
<div class="ttc" id="aclassdrake_1_1systems_1_1_system_html_ad122edf04333ce57b3520d14f06939b2"><div class="ttname"><a href="#ad122edf04333ce57b3520d14f06939b2">drake::systems::System::ToScalarType</a></div><div class="ttdeci">std::unique_ptr&lt; System&lt; U &gt; &gt; ToScalarType() const</div><div class="ttdoc">Creates a deep copy of this System, transmogrified to use the scalar type selected by a template para...</div><div class="ttdef"><b>Definition</b> system.h:1392</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The destination scalar type. For a list of supported types, see the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
    <tr><td class="paramname">S</td><td>The specific <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> pointer type to return.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="group__system__scalar__conversion.html">System Scalar Conversion</a> for detailed background and examples related to scalar-type conversion support. </p>

</div>
</div>
<a id="ae892341d1a1fcad061949cdfb231c819" name="ae892341d1a1fcad061949cdfb231c819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae892341d1a1fcad061949cdfb231c819">&#9670;&#160;</a></span>ToScalarTypeMaybe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; U &gt; &gt; ToScalarTypeMaybe </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a deep copy of this system exactly like <a class="el" href="#ad122edf04333ce57b3520d14f06939b2" title="Creates a deep copy of this System, transmogrified to use the scalar type selected by a template para...">ToScalarType()</a>, but returns nullptr if this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> does not support the destination type, instead of throwing an exception. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The destination scalar type. For a list of supported types, see the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23b6ffa087bb0a1ec114d07d777adc75" name="a23b6ffa087bb0a1ec114d07d777adc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b6ffa087bb0a1ec114d07d777adc75">&#9670;&#160;</a></span>ToSymbolic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; ToSymbolic </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a deep copy of this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>, transmogrified to use the symbolic scalar type. </p>
<p>The result is never nullptr. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> does not support symbolic</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="group__system__scalar__conversion.html">System Scalar Conversion</a> for detailed background and examples related to scalar-type conversion support. </p>

</div>
</div>
<a id="a61510196a7b8f132b3c5b737b6f3f3da" name="a61510196a7b8f132b3c5b737b6f3f3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61510196a7b8f132b3c5b737b6f3f3da">&#9670;&#160;</a></span>ToSymbolic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename &gt; class S = ::drake::systems::System&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; S&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; ToSymbolic </td>
          <td>(</td>
          <td class="paramtype">const S&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a deep copy of <span class="tt">from</span>, transmogrified to use the symbolic scalar type. </p>
<p>The result is never nullptr. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">from</span> does not support symbolic</td></tr>
  </table>
  </dd>
</dl>
<p>Usage: </p><div class="fragment"><div class="line">MySystem&lt;double&gt; plant;</div>
<div class="line">std::unique_ptr&lt;MySystem&lt;symbolic::Expression&gt;&gt; sym_plant =</div>
<div class="line">    <a class="code hl_function" href="#a23b6ffa087bb0a1ec114d07d777adc75">systems::System&lt;double&gt;::ToSymbolic</a>(plant);</div>
<div class="ttc" id="aclassdrake_1_1systems_1_1_system_html_a23b6ffa087bb0a1ec114d07d777adc75"><div class="ttname"><a href="#a23b6ffa087bb0a1ec114d07d777adc75">drake::systems::System::ToSymbolic</a></div><div class="ttdeci">std::unique_ptr&lt; System&lt; symbolic::Expression &gt; &gt; ToSymbolic() const</div><div class="ttdoc">Creates a deep copy of this System, transmogrified to use the symbolic scalar type.</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The specific <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> pointer type to return.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="group__system__scalar__conversion.html">System Scalar Conversion</a> for detailed background and examples related to scalar-type conversion support. </p>

</div>
</div>
<a id="aabd70fbba6ec19f5519e468f29d36179" name="aabd70fbba6ec19f5519e468f29d36179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd70fbba6ec19f5519e468f29d36179">&#9670;&#160;</a></span>ToSymbolicMaybe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="#a70a6f9e15c48813e173ebd6d48770fa1">System</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; ToSymbolicMaybe </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a deep copy of this system exactly like <a class="el" href="#a23b6ffa087bb0a1ec114d07d777adc75" title="Creates a deep copy of this System, transmogrified to use the symbolic scalar type.">ToSymbolic()</a>, but returns nullptr if this <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> does not support symbolic, instead of throwing an exception. </p>

</div>
</div>
<a id="ab858ddb6f259d65f760c2032b3bd5164" name="ab858ddb6f259d65f760c2032b3bd5164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab858ddb6f259d65f760c2032b3bd5164">&#9670;&#160;</a></span>v_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> v_ticket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a ticket indicating dependence on velocity state variables v. </p>
<p>This does <em>not</em> also indicate a dependence on configuration variables q &ndash; you must list that explicitly or use <a class="el" href="#a1291b5091aa55dbd03c9b5944dbced09" title="Returns a ticket indicating dependence on all source values that may affect configuration- or velocit...">kinematics_ticket()</a> instead. There is no ticket representing just one of the state variables vᵢ. </p>

</div>
</div>
<a id="a19842775d11b50e5ae56abcc6d38ccc4" name="a19842775d11b50e5ae56abcc6d38ccc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19842775d11b50e5ae56abcc6d38ccc4">&#9670;&#160;</a></span>xa_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> xa_ticket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a ticket indicating dependence on all of the abstract state variables in the current <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4a8d4f32034a610ea30a283699040708" title="Returns a ticket indicating dependence on a particular abstract state variable xaᵢ.">abstract_state_ticket()</a> to obtain a ticket for just one abstract state variable. </dd></dl>

</div>
</div>
<a id="a385e0d5605b81db0fbfc6bdd57affb5e" name="a385e0d5605b81db0fbfc6bdd57affb5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385e0d5605b81db0fbfc6bdd57affb5e">&#9670;&#160;</a></span>xc_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> xc_ticket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a ticket indicating dependence on <em>all</em> of the continuous state variables q, v, or z. </p>

</div>
</div>
<a id="ab42cd3bff14253894eb0a29edf843b3f" name="ab42cd3bff14253894eb0a29edf843b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42cd3bff14253894eb0a29edf843b3f">&#9670;&#160;</a></span>xcdot_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> xcdot_ticket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a ticket for the cache entry that holds time derivatives of the continuous variables. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a15b6e794826488cdb01ef10a2b21a5dd" title="Returns a reference to the cached value of the continuous state variable time derivatives,...">EvalTimeDerivatives()</a> </dd></dl>

</div>
</div>
<a id="a64938d044107c8eedc97f89aaf0e4a32" name="a64938d044107c8eedc97f89aaf0e4a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64938d044107c8eedc97f89aaf0e4a32">&#9670;&#160;</a></span>xd_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> xd_ticket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a ticket indicating dependence on all of the numerical discrete state variables, in any discrete variable group. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#adf86073429b07d388b0157956bfdbac6" title="Returns a ticket indicating dependence on a particular discrete state variable xdᵢ (may be a vector).">discrete_state_ticket()</a> to obtain a ticket for just one discrete state variable. </dd></dl>

</div>
</div>
<a id="a340a9b088fc407f703a9e21ed9dee32e" name="a340a9b088fc407f703a9e21ed9dee32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340a9b088fc407f703a9e21ed9dee32e">&#9670;&#160;</a></span>z_ticket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1systems.html#a4dead03a05139d2c4dfc0a7042a936ee">DependencyTicket</a> z_ticket </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a ticket indicating dependence on any or all of the miscellaneous continuous state variables z. </p>
<p>There is no ticket representing just one of the state variables zᵢ. </p>

</div>
</div>
<a name="doc-related-members" id="doc-related-members"></a><h2 id="header-doc-related-members" class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a70a6f9e15c48813e173ebd6d48770fa1" name="a70a6f9e15c48813e173ebd6d48770fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a6f9e15c48813e173ebd6d48770fa1">&#9670;&#160;</a></span>System</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class System</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>drake/systems/framework/<a class="el" href="event_8h.html">event.h</a></li>
<li>drake/systems/framework/<a class="el" href="system_8h.html">system.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1systems.html">systems</a></li><li class="navelem"><a href="classdrake_1_1systems_1_1_system.html">System</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="https://accessibility.mit.edu/" class="site-menu-item">Accessibility</a>
        </li>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
