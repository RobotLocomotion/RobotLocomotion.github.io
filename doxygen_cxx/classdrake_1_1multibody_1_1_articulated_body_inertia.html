<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: ArticulatedBodyInertia&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only‚Ä¶">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake‚Ä¶">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1multibody_1_1_articulated_body_inertia.html','','classdrake_1_1multibody_1_1_articulated_body_inertia-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">ArticulatedBodyInertia&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class drake::multibody::ArticulatedBodyInertia&lt; T &gt;</div><p><em>Articulated Body Inertia</em> is the inertia that a body appears to have when it is the base (or root) of a rigid-body system, also referred to as <em>Articulated Body</em> in the context of articulated body algorithms. </p>
<p>The <em>Articulated Body Inertia</em> is a very useful multibody dynamics concept that was introduced by Featherstone [Featherstone 1983] to develop the remarkable <span class="tt">O(n)</span> Articulated <a class="el" href="namespacedrake_1_1multibody.html#a7f0a405774254de6133e7aa5d3960150" title="(Compatibility) Prefer RigidBody to Body, however this dispreferred alias is available to permit olde...">Body</a> Algorithm (ABA) for solving forward dynamics. Recall that the Newton-Euler equations allow us to describe the combined rotational and translational dynamics of a rigid body: </p><pre>
  F_BBo_W = M_B_W * A_WB + Fb_Bo_W                                     (1)
</pre><p> where the spatial inertia (see <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia.">SpatialInertia</a>) <span class="tt">M_B_W</span> of body B expressed in the world frame W linearly relates the spatial acceleration (see <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html" title="This class represents a spatial acceleration A and has 6 elements with an angular (rotational) accele...">SpatialAcceleration</a>) of body B in the world frame with the total applied spatial forces (see <a class="el" href="classdrake_1_1multibody_1_1_spatial_force.html" title="This class represents a spatial force F (also called a wrench) and has 6 elements with a torque ùõï (3-...">SpatialForce</a>) <span class="tt">F_BBo</span> on body B and where <span class="tt">Fb_Bo_W</span> contains the velocity dependent gyroscopic terms.</p>
<p>A similar relationship is found for an articulated body with a rigid body B at the base (or root). Even though the bodies in this multibody system are allowed to have relative motions among them, there still is a linear relationship between the spatial force <span class="tt">F_BBo_W</span> applied on this body and the resulting acceleration <span class="tt">A_WB</span>: <a class="anchor" id="abi_eq_definition"></a></p><pre>
  F_BBo_W = P_B_W * A_WB + Z_Bo_W                                       (2)
</pre><p> where <span class="tt">P_B_W</span> is the articulated body inertia of body B and <span class="tt">Z_Bo_W</span> is a bias force that includes the gyroscopic and Coriolis forces and becomes zero when all body velocities and all applied generalized forces outboard from body B are zero [Jain 2010, ¬ß7.2.1]. The articulated body inertia <span class="tt">P_B_W</span> is related to the multibody subsystem consisting only of bodies that are outboard of body B. We refer to this subsystem as the <em>articulated body subsystem</em> associated with body B. Equation (2) describes the acceleration response of body B, but also taking into account all outboard bodies connected to B. A special case is that of an articulated body composed of a single rigid body. For this special case, Eq. (2) reduces to Eq. (1) for the dynamics of rigid body B. In other words, the ABI for an articulated body consisting of a single rigid body exactly equals the spatial inertia of that body.</p>
<p>Articulated body inertias are elements of ‚Ñù‚Å∂À£‚Å∂ that, as for spatial inertias, are symmetric and positive semi-definite. However, ABI objects <b>are not</b> spatial inertias. The spatial inertia of a rigid body can be described by a reduced set of ten parameters, namely the mass, center of mass and the six components of the rotational inertia for that body. However, this parametrization by ten parameters is just not possible for an ABI and the full 21 elements of the symmetric <span class="tt">6x6</span> matrix must be specified [Jain 2010, ¬ß6.4]. As a result ABI objects can have different properties than spatial inertia objects. As an example, the apparent mass of an articulated body will in general depend on the direction of the applied force. That is, the simple relationship <span class="tt">F = m * a</span> is no longer valid for an articulated body's center of mass (refer to the excellent example 7.1 in [Featherstone 2008]).</p>
<p>We adopt the notation introduced by [Jain 2010] and generally we will use an uppercase P to represent an ABI. Thus, in typeset material we use the symbol \( [P^{A/Q}]_E \) to represent the spatial inertia of an articulated body A, about a point Q, expressed in a frame E. For this inertia, the monogram notation reads <span class="tt">P_AQ_E</span>.</p>
<dl class="section note"><dt>Note</dt><dd>This class does not implement any mechanism to track the frame E in which an articulated body inertia is expressed or about what point is computed. Methods and operators on this class have no means to determine frame consistency through operations. It is therefore the responsibility of users of this class to keep track of frames in which operations are performed. We suggest doing that using disciplined notation, as described above.</dd></dl>
<ul>
<li>[Featherstone 1983] Featherstone, R., 1983. The calculation of robot dynamics using articulated-body inertias. The International Journal of Robotics Research, 2(1), pp.13-30.</li>
<li>[Featherstone 2008] Featherstone, R., 2008. Rigid body dynamics algorithms. Springer.</li>
<li>[Jain 2010] Jain, A., 2010. Robot and multibody dynamics: analysis and algorithms. Springer Science &amp; Business Media.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/multibody/tree/articulated_body_inertia.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a789bb634fbbbc0569e5e9c59584b3657" id="r_a789bb634fbbbc0569e5e9c59584b3657"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a789bb634fbbbc0569e5e9c59584b3657">ArticulatedBodyInertia</a> ()=default</td></tr>
<tr class="memdesc:a789bb634fbbbc0569e5e9c59584b3657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default <a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html" title="Articulated Body Inertia is the inertia that a body appears to have when it is the base (or root) of ...">ArticulatedBodyInertia</a> constructor initializes all matrix values to NaN for a quick detection of uninitialized values.  <br /></td></tr>
<tr class="memitem:a508691682062b23625c4b3f75a134709" id="r_a508691682062b23625c4b3f75a134709"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a508691682062b23625c4b3f75a134709">ArticulatedBodyInertia</a> (const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt; &amp;M_SQ_E)</td></tr>
<tr class="memdesc:a508691682062b23625c4b3f75a134709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an articulated body inertia for an articulated body consisting of a single rigid body given its spatial inertia.  <br /></td></tr>
<tr class="memitem:acb919c29ad40fcea2d070cd32f8ff854" id="r_acb919c29ad40fcea2d070cd32f8ff854"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:acb919c29ad40fcea2d070cd32f8ff854 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb919c29ad40fcea2d070cd32f8ff854">ArticulatedBodyInertia</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;matrix)</td></tr>
<tr class="memdesc:acb919c29ad40fcea2d070cd32f8ff854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an articulated body inertia from an input matrix.  <br /></td></tr>
<tr class="memitem:ae68beebe14471f1821b46e52da79af50" id="r_ae68beebe14471f1821b46e52da79af50"><td class="memTemplParams" colspan="2">template&lt;typename Scalar&gt; </td></tr>
<tr class="memitem:ae68beebe14471f1821b46e52da79af50 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a>&lt; Scalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae68beebe14471f1821b46e52da79af50">cast</a> () const</td></tr>
<tr class="memdesc:ae68beebe14471f1821b46e52da79af50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new ArticulatedBodyInertia object templated on <span class="tt">Scalar</span> with casted values of <span class="tt">this</span> articulated body inertia.  <br /></td></tr>
<tr class="memitem:aa28dea09b9769096566d570d7e513a01" id="r_aa28dea09b9769096566d570d7e513a01"><td class="memTemplParams" colspan="2">template&lt;typename T1 = T&gt; </td></tr>
<tr class="memitem:aa28dea09b9769096566d570d7e513a01 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structdrake_1_1scalar__predicate.html">scalar_predicate</a>&lt; T1 &gt;::is_bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa28dea09b9769096566d570d7e513a01">IsPhysicallyValid</a> () const</td></tr>
<tr class="memdesc:aa28dea09b9769096566d570d7e513a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a number of checks to verify that this is a physically valid articulated body inertia.  <br /></td></tr>
<tr class="memitem:a4f331eab57373e455e4bdd7cbc7fbb1c" id="r_a4f331eab57373e455e4bdd7cbc7fbb1c"><td class="memTemplParams" colspan="2">template&lt;typename T1 = T&gt; </td></tr>
<tr class="memitem:a4f331eab57373e455e4bdd7cbc7fbb1c template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="structdrake_1_1scalar__predicate.html">scalar_predicate</a>&lt; T1 &gt;::is_bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f331eab57373e455e4bdd7cbc7fbb1c">IsPhysicallyValid</a> () const</td></tr>
<tr class="memdesc:a4f331eab57373e455e4bdd7cbc7fbb1c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#aa28dea09b9769096566d570d7e513a01" title="Performs a number of checks to verify that this is a physically valid articulated body inertia.">IsPhysicallyValid()</a> for non-numeric scalar types is not supported.  <br /></td></tr>
<tr class="memitem:a142933f9b21ece9d4401fdb1e27d1e60" id="r_a142933f9b21ece9d4401fdb1e27d1e60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a11f9aa896d31437a219ed19fa944fe20">Matrix6</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a142933f9b21ece9d4401fdb1e27d1e60">CopyToFullMatrix6</a> () const</td></tr>
<tr class="memdesc:a142933f9b21ece9d4401fdb1e27d1e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy to a full 6x6 matrix representation.  <br /></td></tr>
<tr class="memitem:ad00ef87db45627df9128fd872dcebdc4" id="r_ad00ef87db45627df9128fd872dcebdc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad00ef87db45627df9128fd872dcebdc4">ShiftInPlace</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_QR_E)</td></tr>
<tr class="memdesc:ad00ef87db45627df9128fd872dcebdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <span class="tt">this</span> articulated body inertia <span class="tt">P_AQ_E</span> for some articulated body A, computed about point Q, and expressed in frame E, this method uses the rigid body shift operator to compute the same articulated body inertia about a new point R.  <br /></td></tr>
<tr class="memitem:a277a994f18600e133cd033f5b272f383" id="r_a277a994f18600e133cd033f5b272f383"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a277a994f18600e133cd033f5b272f383">Shift</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_QR_E) const</td></tr>
<tr class="memdesc:a277a994f18600e133cd033f5b272f383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <span class="tt">this</span> articulated body inertia <span class="tt">P_AQ_E</span> for some articulated body A, computed about point Q, and expressed in frame E, this method uses the rigid body shift operator to compute the same articulated body inertia about a new point R.  <br /></td></tr>
<tr class="memitem:aaec625819aa09fb9e0208bff278f9caf" id="r_aaec625819aa09fb9e0208bff278f9caf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaec625819aa09fb9e0208bff278f9caf">operator+=</a> (const <a class="el" href="#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a>&lt; T &gt; &amp;P_BQ_E)</td></tr>
<tr class="memdesc:aaec625819aa09fb9e0208bff278f9caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds in to this articulated body inertia <span class="tt">P_AQ_E</span> for an articulated body A about a point Q and expressed in a frame E the articulated body inertia <span class="tt">P_BQ_E</span> for a second articulated body B about the same point Q and expressed in the same frame E.  <br /></td></tr>
<tr class="memitem:ad8a4f67fbf76bb6f0388958644f6452f" id="r_ad8a4f67fbf76bb6f0388958644f6452f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8a4f67fbf76bb6f0388958644f6452f">operator-=</a> (const <a class="el" href="#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a>&lt; T &gt; &amp;P_BQ_E)</td></tr>
<tr class="memdesc:ad8a4f67fbf76bb6f0388958644f6452f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts <span class="tt">P_BQ_E</span> from <span class="tt">this</span> articulated body inertia.  <br /></td></tr>
<tr class="memitem:ad40227c19339519faa0a1252f3d3888b" id="r_ad40227c19339519faa0a1252f3d3888b"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived&gt; </td></tr>
<tr class="memitem:ad40227c19339519faa0a1252f3d3888b template"><td class="memItemLeft" align="right" valign="top">const Eigen::Product&lt; Eigen::SelfAdjointView&lt; const <a class="el" href="namespacedrake.html#a11f9aa896d31437a219ed19fa944fe20">Matrix6</a>&lt; T &gt;, Eigen::Lower &gt;, OtherDerived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad40227c19339519faa0a1252f3d3888b">operator*</a> (const Eigen::MatrixBase&lt; OtherDerived &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:ad40227c19339519faa0a1252f3d3888b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <span class="tt">this</span> articulated body inertia on the right by a matrix or vector.  <br /></td></tr>
<tr class="memitem:ac46cc6a9a7cb66ed822f8d54070e47e2" id="r_ac46cc6a9a7cb66ed822f8d54070e47e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_force.html">SpatialForce</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac46cc6a9a7cb66ed822f8d54070e47e2">operator*</a> (const <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt; &amp;A_WB_E) const</td></tr>
<tr class="memdesc:ac46cc6a9a7cb66ed822f8d54070e47e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <span class="tt">this</span> articulated body inertia on the right by a spatial acceleration.  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:ab1114b94d5f66d6df3605856fa2c6cc6" id="r_ab1114b94d5f66d6df3605856fa2c6cc6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1114b94d5f66d6df3605856fa2c6cc6">ArticulatedBodyInertia</a> (const ArticulatedBodyInertia &amp;)=default</td></tr>
<tr class="memitem:ac6b8de80bcfea934c7aab07304c41472" id="r_ac6b8de80bcfea934c7aab07304c41472"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6b8de80bcfea934c7aab07304c41472">operator=</a> (const <a class="el" href="#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a> &amp;)=default</td></tr>
<tr class="memitem:a05bea6e19974f4c24d747976ada0efef" id="r_a05bea6e19974f4c24d747976ada0efef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05bea6e19974f4c24d747976ada0efef">ArticulatedBodyInertia</a> (ArticulatedBodyInertia &amp;&amp;)=default</td></tr>
<tr class="memitem:a91422a291be533e6b4674363e35be539" id="r_a91422a291be533e6b4674363e35be539"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91422a291be533e6b4674363e35be539">operator=</a> (<a class="el" href="#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a> &amp;&amp;)=default</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-friends" class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af8b25c3b08abdc24e4de1e63ab09ef04" id="r_af8b25c3b08abdc24e4de1e63ab09ef04"><td class="memTemplParams" colspan="2">template&lt;typename&gt; </td></tr>
<tr class="memitem:af8b25c3b08abdc24e4de1e63ab09ef04 template"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a></td></tr>
<tr class="memitem:aaa3389c3680e46b98028dfedc84239a7" id="r_aaa3389c3680e46b98028dfedc84239a7"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived&gt; </td></tr>
<tr class="memitem:aaa3389c3680e46b98028dfedc84239a7 template"><td class="memItemLeft" align="right" valign="top">const Eigen::Product&lt; OtherDerived, Eigen::SelfAdjointView&lt; const <a class="el" href="namespacedrake.html#a11f9aa896d31437a219ed19fa944fe20">Matrix6</a>&lt; T &gt;, Eigen::Lower &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa3389c3680e46b98028dfedc84239a7">operator*</a> (const Eigen::MatrixBase&lt; OtherDerived &gt; &amp;lhs, const <a class="el" href="#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a> &amp;rhs)</td></tr>
<tr class="memdesc:aaa3389c3680e46b98028dfedc84239a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <span class="tt">this</span> articulated body inertia on the left by a matrix or vector.  <br /></td></tr>
</table>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab1114b94d5f66d6df3605856fa2c6cc6" name="ab1114b94d5f66d6df3605856fa2c6cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1114b94d5f66d6df3605856fa2c6cc6">&#9670;&#160;</a></span>ArticulatedBodyInertia() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ArticulatedBodyInertia </td>
          <td>(</td>
          <td class="paramtype">const ArticulatedBodyInertia&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a05bea6e19974f4c24d747976ada0efef" name="a05bea6e19974f4c24d747976ada0efef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05bea6e19974f4c24d747976ada0efef">&#9670;&#160;</a></span>ArticulatedBodyInertia() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ArticulatedBodyInertia </td>
          <td>(</td>
          <td class="paramtype">ArticulatedBodyInertia&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a789bb634fbbbc0569e5e9c59584b3657" name="a789bb634fbbbc0569e5e9c59584b3657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789bb634fbbbc0569e5e9c59584b3657">&#9670;&#160;</a></span>ArticulatedBodyInertia() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ArticulatedBodyInertia </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default <a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html" title="Articulated Body Inertia is the inertia that a body appears to have when it is the base (or root) of ...">ArticulatedBodyInertia</a> constructor initializes all matrix values to NaN for a quick detection of uninitialized values. </p>

</div>
</div>
<a id="a508691682062b23625c4b3f75a134709" name="a508691682062b23625c4b3f75a134709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508691682062b23625c4b3f75a134709">&#9670;&#160;</a></span>ArticulatedBodyInertia() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ArticulatedBodyInertia </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>M_SQ_E</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an articulated body inertia for an articulated body consisting of a single rigid body given its spatial inertia. </p>
<p>From an input spatial inertia <span class="tt">M_SQ_E</span> for a body or composite body S, about point Q, and expressed in a frame E, this constructor creates an articulated body inertia about the same point Q and expressed in the same frame E.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M_SQ_E</td><td>The spatial inertia of a body or composite body S about point Q and expressed in frame E. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb919c29ad40fcea2d070cd32f8ff854" name="acb919c29ad40fcea2d070cd32f8ff854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb919c29ad40fcea2d070cd32f8ff854">&#9670;&#160;</a></span>ArticulatedBodyInertia() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ArticulatedBodyInertia </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an articulated body inertia from an input matrix. </p>
<p>In Debug, this constructor checks for the physical validity of the resulting ArticulatedBodyInertia with <a class="el" href="#aa28dea09b9769096566d570d7e513a01" title="Performs a number of checks to verify that this is a physically valid articulated body inertia.">IsPhysicallyValid()</a> and throws a std::runtime_error exception in the event the provided input matrix leads to a non-physically viable articulated body inertia.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>A matrix or matrix expression representing the articulated body inertia. Only the lower triangular region is used and the strictly upper part is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>in Debug builds if <a class="el" href="#aa28dea09b9769096566d570d7e513a01" title="Performs a number of checks to verify that this is a physically valid articulated body inertia.">IsPhysicallyValid()</a> for <span class="tt">this</span> inertia is <span class="tt">false</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ae68beebe14471f1821b46e52da79af50" name="ae68beebe14471f1821b46e52da79af50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68beebe14471f1821b46e52da79af50">&#9670;&#160;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a>&lt; Scalar &gt; cast </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new ArticulatedBodyInertia object templated on <span class="tt">Scalar</span> with casted values of <span class="tt">this</span> articulated body inertia. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type on which the new articulated body inertia will be templated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><span class="tt"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html" title="Articulated Body Inertia is the inertia that a body appears to have when it is the base (or root) of ...">ArticulatedBodyInertia</a>&lt;From&gt;::<a class="el" href="#ae68beebe14471f1821b46e52da79af50" title="Returns a new ArticulatedBodyInertia object templated on Scalar with casted values of this articulate...">cast</a>&lt;To&gt;()</span> creates a new <span class="tt"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html" title="Articulated Body Inertia is the inertia that a body appears to have when it is the base (or root) of ...">ArticulatedBodyInertia</a>&lt;To&gt;</span> from an <span class="tt"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html" title="Articulated Body Inertia is the inertia that a body appears to have when it is the base (or root) of ...">ArticulatedBodyInertia</a>&lt;From&gt;</span> but only if type <span class="tt">To</span> is constructible from type <span class="tt">From</span>. As an example of this, <span class="tt"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html" title="Articulated Body Inertia is the inertia that a body appears to have when it is the base (or root) of ...">ArticulatedBodyInertia</a>&lt;double&gt;::<a class="el" href="#ae68beebe14471f1821b46e52da79af50" title="Returns a new ArticulatedBodyInertia object templated on Scalar with casted values of this articulate...">cast</a>&lt;<a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854" title="A scalar type that performs automatic differentiation.">AutoDiffXd</a>&gt;()</span> is valid since <span class="tt"><a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854" title="A scalar type that performs automatic differentiation.">AutoDiffXd</a> a(1.0)</span> is valid. However, <span class="tt"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html" title="Articulated Body Inertia is the inertia that a body appears to have when it is the base (or root) of ...">ArticulatedBodyInertia</a>&lt;<a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854" title="A scalar type that performs automatic differentiation.">AutoDiffXd</a>&gt;::<a class="el" href="#ae68beebe14471f1821b46e52da79af50" title="Returns a new ArticulatedBodyInertia object templated on Scalar with casted values of this articulate...">cast</a>&lt;double&gt;()</span> is not. </dd></dl>

</div>
</div>
<a id="a142933f9b21ece9d4401fdb1e27d1e60" name="a142933f9b21ece9d4401fdb1e27d1e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142933f9b21ece9d4401fdb1e27d1e60">&#9670;&#160;</a></span>CopyToFullMatrix6()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a11f9aa896d31437a219ed19fa944fe20">Matrix6</a>&lt; T &gt; CopyToFullMatrix6 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy to a full 6x6 matrix representation. </p>

</div>
</div>
<a id="a4f331eab57373e455e4bdd7cbc7fbb1c" name="a4f331eab57373e455e4bdd7cbc7fbb1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f331eab57373e455e4bdd7cbc7fbb1c">&#9670;&#160;</a></span>IsPhysicallyValid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename T1 = T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="structdrake_1_1scalar__predicate.html">scalar_predicate</a>&lt; T1 &gt;::is_bool, bool &gt; IsPhysicallyValid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#aa28dea09b9769096566d570d7e513a01" title="Performs a number of checks to verify that this is a physically valid articulated body inertia.">IsPhysicallyValid()</a> for non-numeric scalar types is not supported. </p>

</div>
</div>
<a id="aa28dea09b9769096566d570d7e513a01" name="aa28dea09b9769096566d570d7e513a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa28dea09b9769096566d570d7e513a01">&#9670;&#160;</a></span>IsPhysicallyValid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename T1 = T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structdrake_1_1scalar__predicate.html">scalar_predicate</a>&lt; T1 &gt;::is_bool, bool &gt; IsPhysicallyValid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a number of checks to verify that this is a physically valid articulated body inertia. </p>
<p>The checks performed are:</p><ul>
<li>The matrix is positive semi-definite. </li>
</ul>

</div>
</div>
<a id="ad40227c19339519faa0a1252f3d3888b" name="ad40227c19339519faa0a1252f3d3888b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40227c19339519faa0a1252f3d3888b">&#9670;&#160;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Product&lt; Eigen::SelfAdjointView&lt; const <a class="el" href="namespacedrake.html#a11f9aa896d31437a219ed19fa944fe20">Matrix6</a>&lt; T &gt;, Eigen::Lower &gt;, OtherDerived &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; OtherDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies <span class="tt">this</span> articulated body inertia on the right by a matrix or vector. </p>
<dl class="section note"><dt>Note</dt><dd>This method does not evaluate the product immediately. Instead, it returns an intermediate Eigen quantity that can be optimized automatically during compile time. </dd></dl>

</div>
</div>
<a id="ac46cc6a9a7cb66ed822f8d54070e47e2" name="ac46cc6a9a7cb66ed822f8d54070e47e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46cc6a9a7cb66ed822f8d54070e47e2">&#9670;&#160;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_force.html">SpatialForce</a>&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A_WB_E</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies <span class="tt">this</span> articulated body inertia on the right by a spatial acceleration. </p>
<p>See <a class="el" href="#abi_eq_definition">Eq. (2)</a> for an example. </p>

</div>
</div>
<a id="aaec625819aa09fb9e0208bff278f9caf" name="aaec625819aa09fb9e0208bff278f9caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec625819aa09fb9e0208bff278f9caf">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a>&lt; T &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>P_BQ_E</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds in to this articulated body inertia <span class="tt">P_AQ_E</span> for an articulated body A about a point Q and expressed in a frame E the articulated body inertia <span class="tt">P_BQ_E</span> for a second articulated body B about the same point Q and expressed in the same frame E. </p>
<p>The result is equivalent to the articulated body inertia <span class="tt">P_CQ_E</span> for the composite articulated body C which has at its base a rigid body composed of the bases of A and B welded together [Featherstone 2008, example 7.1]. The composite articulated body inertia <span class="tt">P_CQ_E</span> is also about the same point Q and expressed in the same frame E as the addends.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P_BQ_E</td><td>An articulated body inertia of some articulated body B to be added to <span class="tt">this</span> articulated body inertia. It must be defined about the same point Q as <span class="tt">this</span> inertia, and expressed in the same frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <span class="tt">this</span> articulated body inertia, which has been updated to include the given articulated body inertia <span class="tt">P_BQ_E</span>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This operation is only valid if both articulated body inertias are computed about the same point Q and expressed in the same frame E. </dd></dl>

</div>
</div>
<a id="ad8a4f67fbf76bb6f0388958644f6452f" name="ad8a4f67fbf76bb6f0388958644f6452f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a4f67fbf76bb6f0388958644f6452f">&#9670;&#160;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a>&lt; T &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>P_BQ_E</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts <span class="tt">P_BQ_E</span> from <span class="tt">this</span> articulated body inertia. </p>
<p><span class="tt">P_BQ_E</span> must be for the same articulated body B as this ABI (about the same point Q and expressed in the same frame E). The resulting inertia will have the same properties. </p>

</div>
</div>
<a id="a91422a291be533e6b4674363e35be539" name="a91422a291be533e6b4674363e35be539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91422a291be533e6b4674363e35be539">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6b8de80bcfea934c7aab07304c41472" name="ac6b8de80bcfea934c7aab07304c41472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b8de80bcfea934c7aab07304c41472">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a277a994f18600e133cd033f5b272f383" name="a277a994f18600e133cd033f5b272f383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277a994f18600e133cd033f5b272f383">&#9670;&#160;</a></span>Shift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a>&lt; T &gt; Shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_QR_E</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given <span class="tt">this</span> articulated body inertia <span class="tt">P_AQ_E</span> for some articulated body A, computed about point Q, and expressed in frame E, this method uses the rigid body shift operator to compute the same articulated body inertia about a new point R. </p>
<p>The result still is expressed in frame E.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad00ef87db45627df9128fd872dcebdc4" title="Given this articulated body inertia P_AQ_E for some articulated body A, computed about point Q,...">ShiftInPlace()</a> for more details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_QR_E</td><td><a class="el" href="namespacedrake.html#a01ae662d5635b7c9efe03d15d976f7a8" title="A column vector templated on the number of rows.">Vector</a> from the original about point Q to the new about point R, expressed in the same frame E <span class="tt">this</span> articulated body inertia is expressed in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">P_AR_E</td><td>This same articulated body inertia for articulated body A but now computed about a new point R. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad00ef87db45627df9128fd872dcebdc4" name="ad00ef87db45627df9128fd872dcebdc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00ef87db45627df9128fd872dcebdc4">&#9670;&#160;</a></span>ShiftInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ShiftInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_QR_E</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given <span class="tt">this</span> articulated body inertia <span class="tt">P_AQ_E</span> for some articulated body A, computed about point Q, and expressed in frame E, this method uses the rigid body shift operator to compute the same articulated body inertia about a new point R. </p>
<p>The result still is expressed in frame E.</p>
<p>Mathematically, this is equivalent to: </p><pre>
P_AR_E = Œ¶(P_RQ_E) P_AQ_E Œ¶(p_RQ_E)·µÄ
</pre><p> where <span class="tt">Œ¶(p_RQ_E)</span> is the rigid body shift operator as defined by [Jain 2010]. The definition of <span class="tt">Œ¶(p_RQ_E)</span> uses <span class="tt">p_QR_E√ó</span>, which is the skew-symmetric cross product matrix (defined such that <span class="tt">a√ó b = a.cross(b)</span>). </p><pre>
Œ¶(p_RQ_E) =
| I‚ÇÉ  p_RQ_E√ó |
| 0        I‚ÇÉ |
</pre><p> where <span class="tt">p_RQ_E√ó = -p_QR_E√ó</span>.</p>
<p>This operation is performed in-place modifying the original object. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a277a994f18600e133cd033f5b272f383" title="Given this articulated body inertia P_AQ_E for some articulated body A, computed about point Q,...">Shift()</a> which does not modify this object.</dd></dl>
<p>For details see Section 6.2.5, Page 105 of [Jain 2010].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_QR_E</td><td><a class="el" href="namespacedrake.html#a01ae662d5635b7c9efe03d15d976f7a8" title="A column vector templated on the number of rows.">Vector</a> from the original about point Q to the new about point R, expressed in the same frame E <span class="tt">this</span> articulated body inertia is expressed in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-related-members" id="doc-related-members"></a><h2 id="header-doc-related-members" class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="af8b25c3b08abdc24e4de1e63ab09ef04" name="af8b25c3b08abdc24e4de1e63ab09ef04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b25c3b08abdc24e4de1e63ab09ef04">&#9670;&#160;</a></span>ArticulatedBodyInertia</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ArticulatedBodyInertia</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa3389c3680e46b98028dfedc84239a7" name="aaa3389c3680e46b98028dfedc84239a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3389c3680e46b98028dfedc84239a7">&#9670;&#160;</a></span>operator*</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Product&lt; OtherDerived, Eigen::SelfAdjointView&lt; const <a class="el" href="namespacedrake.html#a11f9aa896d31437a219ed19fa944fe20">Matrix6</a>&lt; T &gt;, Eigen::Lower &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; OtherDerived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#af8b25c3b08abdc24e4de1e63ab09ef04">ArticulatedBodyInertia</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies <span class="tt">this</span> articulated body inertia on the left by a matrix or vector. </p>
<dl class="section note"><dt>Note</dt><dd>This method does not evaluate the product immediately. Instead, it returns an intermediate Eigen quantity that can be optimized automatically during compile time. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/multibody/tree/<a class="el" href="articulated__body__inertia_8h.html">articulated_body_inertia.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="https://accessibility.mit.edu/" class="site-menu-item">Accessibility</a>
        </li>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name‚Ä¶';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
