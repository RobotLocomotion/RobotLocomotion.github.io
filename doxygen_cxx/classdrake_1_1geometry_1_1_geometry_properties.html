<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: GeometryProperties Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1geometry_1_1_geometry_properties.html','','classdrake_1_1geometry_1_1_geometry_properties-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">GeometryProperties Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The base class for defining a set of geometry properties. </p>
<p>Each property consists of a <span class="tt">(group, property)</span> name-pair and a typed value. The name pair allows for reuse of common property names (e.g., "diffuse") to be differentiated in interpretation by associating them with different groups. The only restriction on the value type is that it must be either cloneable or copy-constructible.</p>
<p>A set of geometry property values are defined when geometry is registered with <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> by an instantiator and accessed by some downstream consumer entity. Each consumer specifies what properties it expects to find and what default values (if any) it provides. For example, the consumer could document that a particular property is always required and its absence would throw an exception. Alternatively, it could indicate that a property is optional and a default value will be used in its absence. It is the responsibility of the instantiator to make sure that the geometry property values are <em>correctly</em> defined according to the expected consumer's specification. Correctness includes such issues as key-value pairs placed into a <em>correctly</em>-spelled group, property keys being likewise correctly spelled, and values of the expected type. Correct spelling includes correct case. The instantiator uses the <a class="el" href="#a5c36bb4c5566a8316bc8b52601e49d27" title="Adds the named property (group_name, name) with the given value.">AddProperty()</a> method to add new properties to the set.</p>
<p>To read the property (<span class="tt">some_group</span>, <span class="tt">some_property</span>) from a property set:</p>
<ol type="1">
<li>Optionally test to see if the property exists by confirming the group <span class="tt">some_group</span> is in the set via <a class="el" href="#ad4a46edb0e7b07e1aa49ddb946ddecc0" title="Reports if the given named group is part of this property set.">HasGroup()</a> and that the property <span class="tt">some_property</span> is in <span class="tt">some_group</span> via <a class="el" href="#ace6a963ab7442bf3f29d9ebacdc849ca" title="Reports if the property (group_name, name) exists in the group.">HasProperty()</a>. Attempting to access a property with a non-existent (group, property) pair may lead to an exception (see API documentation below).</li>
<li>Acquire a property value via the <a class="el" href="#aaaa9388bc0cffeef445272cc5234b087" title="Retrieves the typed value for the property (group_name, name) from this set of properties.">GetProperty()</a> or <a class="el" href="#a7b425641c9937dea89f553cabba9b186" title="Retrieves the typed value for the property (group_name, name) from the set of properties (if it exist...">GetPropertyOrDefault()</a> methods. NOTE: Reading a property requires a compile-time declaration of the <em>type</em> of value being read. If the stored value is of a different type, an exception will be thrown.</li>
</ol>
<h2>Common workflows</h2>
<p>The following examples outline a number of ways to create and consume geometry properties. By design, GeometryProperties cannot be constructed, copied, or moved directly. Only derived classes can do so. This facilitates <em>strongly typed</em> sets of properties associated with particular geometry roles. So, for these examples we'll exercise the derived class associated with proximity queries: <a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html" title="The set of properties for geometry used in a proximity role.">ProximityProperties</a>.</p>
<p>The string-based structure of GeometryProperties provides a great deal of flexibility at the cost of spelling sensitivity. It would be easy to introduce typos that would then "hide" property values in some group a consumer wouldn't look. In these examples, we avoid using string literals as group or property names (at least in the cases where the same name is used multiple times) to help avoid the possibility of typo-induced errors. That is not required and certainly not the only way to avoid such bugs.</p>
<h3>Creating properties</h3>
<h4>Creating properties in a new group</h4>
<p>This is a simple example in which a single group is added with properties of various types.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::string group_name(<span class="stringliteral">&quot;my_group&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> properties;</div>
<div class="line"><span class="comment">// This first invocation implicitly creates the group &quot;my_group&quot;.</span></div>
<div class="line">properties.<a class="code hl_function" href="#a5c36bb4c5566a8316bc8b52601e49d27">AddProperty</a>(group_name, <span class="stringliteral">&quot;count&quot;</span>, 7);     <span class="comment">// int type</span></div>
<div class="line">properties.<a class="code hl_function" href="#a5c36bb4c5566a8316bc8b52601e49d27">AddProperty</a>(group_name, <span class="stringliteral">&quot;length&quot;</span>, 7.);   <span class="comment">// double type</span></div>
<div class="line">properties.<a class="code hl_function" href="#a5c36bb4c5566a8316bc8b52601e49d27">AddProperty</a>(group_name, <span class="stringliteral">&quot;name&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>);    <span class="comment">// std::string type</span></div>
<div class="ttc" id="aclassdrake_1_1geometry_1_1_geometry_properties_html_a5c36bb4c5566a8316bc8b52601e49d27"><div class="ttname"><a href="#a5c36bb4c5566a8316bc8b52601e49d27">drake::geometry::GeometryProperties::AddProperty</a></div><div class="ttdeci">void AddProperty(const std::string &amp;group_name, const std::string &amp;name, const ValueType &amp;value)</div><div class="ttdoc">Adds the named property (group_name, name) with the given value.</div><div class="ttdef"><b>Definition</b> geometry_properties.h:264</div></div>
<div class="ttc" id="aclassdrake_1_1geometry_1_1_proximity_properties_html"><div class="ttname"><a href="classdrake_1_1geometry_1_1_proximity_properties.html">drake::geometry::ProximityProperties</a></div><div class="ttdoc">The set of properties for geometry used in a proximity role.</div><div class="ttdef"><b>Definition</b> geometry_roles.h:171</div></div>
</div><!-- fragment --><h4>Creating properties in the default group</h4>
<p>Similar to the previous examples, the properties are added to the default group. Just be aware that if multiple sites in your code add properties to the default group, the possibility that names get repeated increases. Property names <em>must</em> be unique within a single group, including the default group.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classdrake_1_1geometry_1_1_proximity_properties.html">ProximityProperties</a> properties;</div>
<div class="line">properties.<a class="code hl_function" href="#a5c36bb4c5566a8316bc8b52601e49d27">AddProperty</a>(<a class="code hl_function" href="#a7c9d7d51d987f24034f0949aba25a608">ProximityProperties::default_group_name</a>(), <span class="stringliteral">&quot;count&quot;</span>, 7);</div>
<div class="line">properties.<a class="code hl_function" href="#a5c36bb4c5566a8316bc8b52601e49d27">AddProperty</a>(<a class="code hl_function" href="#a7c9d7d51d987f24034f0949aba25a608">ProximityProperties::default_group_name</a>(), <span class="stringliteral">&quot;width&quot;</span>, 7.);</div>
<div class="line">properties.<a class="code hl_function" href="#a5c36bb4c5566a8316bc8b52601e49d27">AddProperty</a>(<a class="code hl_function" href="#a7c9d7d51d987f24034f0949aba25a608">ProximityProperties::default_group_name</a>(), <span class="stringliteral">&quot;name&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>);</div>
<div class="ttc" id="aclassdrake_1_1geometry_1_1_geometry_properties_html_a7c9d7d51d987f24034f0949aba25a608"><div class="ttname"><a href="#a7c9d7d51d987f24034f0949aba25a608">drake::geometry::GeometryProperties::default_group_name</a></div><div class="ttdeci">static const std::string &amp; default_group_name()</div><div class="ttdoc">Returns the default group name.</div><div class="ttdef"><b>Definition</b> geometry_properties.h:409</div></div>
</div><!-- fragment --><h4>Aggregate properties in a struct</h4>
<p>In some cases, there is a set of values that will <em>always</em> be accessed together (specified with coordinated semantics). In these cases, it makes sense to aggregate them into a struct and store that as a single value. This reduces the number of lookups required.</p>
<p>It's worth noting, that if the data value is a struct, calls to <a class="el" href="#a7b425641c9937dea89f553cabba9b186" title="Retrieves the typed value for the property (group_name, name) from the set of properties (if it exist...">GetPropertyOrDefault()</a> still operate as an "all-or-nothing" basis. If the property <em>struct</em> exists, it will be returned, if it's missing the default struct will be returned. There is no concept of a "partial" struct in which some undefined values in the struct will be replaced with their corresponding values in the default struct.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyData {</div>
<div class="line">   <span class="keywordtype">int</span> i{};</div>
<div class="line">   <span class="keywordtype">double</span> d{};</div>
<div class="line">   std::string s;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">ProximityProperties properties;</div>
<div class="line"><span class="keyword">const</span> std::string group_name(<span class="stringliteral">&quot;my_group&quot;</span>);</div>
<div class="line">MyData data{7, 7., <span class="stringliteral">&quot;7&quot;</span>};</div>
<div class="line">properties.AddProperty(group_name, <span class="stringliteral">&quot;data1&quot;</span>, data);</div>
<div class="line"><span class="comment">// These alternate forms are also acceptable (but not in succession, as the</span></div>
<div class="line"><span class="comment">// property name has already been used by the first invocation).</span></div>
<div class="line">properties.AddProperty(group_name, <span class="stringliteral">&quot;data2&quot;</span>, MyData{6, 6., <span class="stringliteral">&quot;6&quot;</span>});</div>
<div class="line">properties.AddProperty&lt;MyData&gt;(group_name, <span class="stringliteral">&quot;data2&quot;</span>, {6, 6., <span class="stringliteral">&quot;6&quot;</span>});</div>
</div><!-- fragment --><h3>Reading properties</h3>
<p>This section describes how to read properties under several different scenarios: (a) when specific properties are required, (b) when the consumer provides a default value for missing properties, and (c) when the consumer needs to inspect what properties are available.</p>
<h4>Look up specific, <em>required</em> properties</h4>
<p>In this case, the consumer of the properties is looking for one or more specific properties. It will ignore any other properties. More particularly, if those properties are missing, it is considered a runtime error and an exception is thrown.</p>
<p>The error can be handled in one of two ways: simply let the generic exception generated by GeometryProperties propagate upward, or detect the missing property and throw an exception with a custom message. The example below shows both approaches.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1geometry_1_1_illustration_properties.html">IllustrationProperties</a>&amp; properties = FunctionThatReturnsProperties();</div>
<div class="line"><span class="comment">// Looking for a Rgba of rgba colors named &quot;rgba&quot; - send generic error that</span></div>
<div class="line"><span class="comment">// the property set is missing the required property.</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1geometry_1_1_rgba.html">Rgba</a> rgba =</div>
<div class="line">    properties.<a class="code hl_function" href="#aaaa9388bc0cffeef445272cc5234b087">GetProperty</a>&lt;<a class="code hl_class" href="classdrake_1_1geometry_1_1_rgba.html">Rgba</a>&gt;(<span class="stringliteral">&quot;MyGroup&quot;</span>, <span class="stringliteral">&quot;rgba&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Explicitly detect missing property and throw exception with custom message.</span></div>
<div class="line"><span class="keywordflow">if</span> (!properties.<a class="code hl_function" href="#ace6a963ab7442bf3f29d9ebacdc849ca">HasProperty</a>(<span class="stringliteral">&quot;MyGroup&quot;</span>, <span class="stringliteral">&quot;rgba&quot;</span>)) {</div>
<div class="line">  <span class="keywordflow">throw</span> std::logic_error(</div>
<div class="line">      <span class="stringliteral">&quot;ThisClass: Missing the necessary &#39;rgba&#39; property; the object cannot be &quot;</span></div>
<div class="line">      <span class="stringliteral">&quot;rendered&quot;</span>);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// Otherwise acquire value, confident that no exception will be thrown.</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1geometry_1_1_rgba.html">Rgba</a> rgba =</div>
<div class="line">    properties.<a class="code hl_function" href="#aaaa9388bc0cffeef445272cc5234b087">GetProperty</a>&lt;<a class="code hl_class" href="classdrake_1_1geometry_1_1_rgba.html">Rgba</a>&gt;(<span class="stringliteral">&quot;MyGroup&quot;</span>, <span class="stringliteral">&quot;rgba&quot;</span>);</div>
<div class="ttc" id="aclassdrake_1_1geometry_1_1_geometry_properties_html_aaaa9388bc0cffeef445272cc5234b087"><div class="ttname"><a href="#aaaa9388bc0cffeef445272cc5234b087">drake::geometry::GeometryProperties::GetProperty</a></div><div class="ttdeci">decltype(auto) GetProperty(const std::string &amp;group_name, const std::string &amp;name) const</div><div class="ttdoc">Retrieves the typed value for the property (group_name, name) from this set of properties.</div><div class="ttdef"><b>Definition</b> geometry_properties.h:337</div></div>
<div class="ttc" id="aclassdrake_1_1geometry_1_1_geometry_properties_html_ace6a963ab7442bf3f29d9ebacdc849ca"><div class="ttname"><a href="#ace6a963ab7442bf3f29d9ebacdc849ca">drake::geometry::GeometryProperties::HasProperty</a></div><div class="ttdeci">bool HasProperty(const std::string &amp;group_name, const std::string &amp;name) const</div><div class="ttdoc">Reports if the property (group_name, name) exists in the group.</div></div>
<div class="ttc" id="aclassdrake_1_1geometry_1_1_illustration_properties_html"><div class="ttname"><a href="classdrake_1_1geometry_1_1_illustration_properties.html">drake::geometry::IllustrationProperties</a></div><div class="ttdoc">The set of properties for geometry used in an &quot;illustration&quot; role.</div><div class="ttdef"><b>Definition</b> geometry_roles.h:197</div></div>
<div class="ttc" id="aclassdrake_1_1geometry_1_1_rgba_html"><div class="ttname"><a href="classdrake_1_1geometry_1_1_rgba.html">drake::geometry::Rgba</a></div><div class="ttdoc">Defines RGBA (red, green, blue, alpha) values on the range [0, 1].</div><div class="ttdef"><b>Definition</b> rgba.h:21</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>calls to <span class="tt"><a class="el" href="#aaaa9388bc0cffeef445272cc5234b087" title="Retrieves the typed value for the property (group_name, name) from this set of properties.">GetProperty()</a></span> always require the return type template value (e.g., <span class="tt"><a class="el" href="classdrake_1_1geometry_1_1_rgba.html" title="Defines RGBA (red, green, blue, alpha) values on the range [0, 1].">Rgba</a></span>) to be specified in the call.</dd></dl>
<h4>Look up specific properties with default property values</h4>
<p>As with the previous case, the consumer is looking for one or more specific properties. However, in this case, the consumer provides a default value to use in case the target property is not defined. In this invocation, the template parameter need not be explicitly declared &ndash; the inferred return type will be the same as the default value.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1geometry_1_1_illustration_properties.html">IllustrationProperties</a>&amp; properties = FunctionThatReturnsProperties();</div>
<div class="line"><span class="comment">// Looking for a Rgba of rgba colors named &quot;rgba&quot;.</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1geometry_1_1_rgba.html">Rgba</a> default_color{0.9, 0.9, 0.9};</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1geometry_1_1_rgba.html">Rgba</a> rgba =</div>
<div class="line">    properties.<a class="code hl_function" href="#a7b425641c9937dea89f553cabba9b186">GetPropertyOrDefault</a>(<span class="stringliteral">&quot;MyGroup&quot;</span>, <span class="stringliteral">&quot;rgba&quot;</span>, default_color);</div>
<div class="ttc" id="aclassdrake_1_1geometry_1_1_geometry_properties_html_a7b425641c9937dea89f553cabba9b186"><div class="ttname"><a href="#a7b425641c9937dea89f553cabba9b186">drake::geometry::GeometryProperties::GetPropertyOrDefault</a></div><div class="ttdeci">ValueType GetPropertyOrDefault(const std::string &amp;group_name, const std::string &amp;name, ValueType default_value) const</div><div class="ttdoc">Retrieves the typed value for the property (group_name, name) from the set of properties (if it exist...</div><div class="ttdef"><b>Definition</b> geometry_properties.h:385</div></div>
</div><!-- fragment --><p>Alternatively, the default value can be provided in one of the following forms:</p>
<div class="fragment"><div class="line">properties.<a class="code hl_function" href="#a7b425641c9937dea89f553cabba9b186">GetPropertyOrDefault</a>(<span class="stringliteral">&quot;MyGroup&quot;</span>, <span class="stringliteral">&quot;rgba&quot;</span>,</div>
<div class="line">    <a class="code hl_class" href="classdrake_1_1geometry_1_1_rgba.html">Rgba</a>{0.9, 0.9, 0.9});</div>
<div class="line">properties.<a class="code hl_function" href="#a7b425641c9937dea89f553cabba9b186">GetPropertyOrDefault</a>&lt;<a class="code hl_class" href="classdrake_1_1geometry_1_1_rgba.html">Rgba</a>&gt;(<span class="stringliteral">&quot;MyGroup&quot;</span>, <span class="stringliteral">&quot;rgba&quot;</span>,</div>
<div class="line">    {0.9, 0.9, 0.9});</div>
</div><!-- fragment --><h4>Iterating through provided properties</h4>
<p>Another alternative is to iterate through the properties that <em>have</em> been provided. This might be done for several reasons, e.g.:</p>
<ul>
<li>the consumer wants to validate the set of properties, giving the user feedback if an unsupported property has been provided, and/or</li>
<li>the consumer has a default value for every property and allows the registering code to define only those properties that deviate from the specified default.</li>
</ul>
<p>Working with properties in this manner requires knowledge of how to work with <a class="el" href="classdrake_1_1_abstract_value.html" title="A fully type-erased container class.">AbstractValue</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1geometry_1_1_illustration_properties.html">IllustrationProperties</a>&amp; properties = FunctionThatReturnsProperties();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pair : properties.GetGroupProperties(<span class="stringliteral">&quot;MyGroup&quot;</span>) {</div>
<div class="line">  const std::string&amp; name = pair.first;</div>
<div class="line">  if (name == <span class="stringliteral">&quot;rgba&quot;</span>) {</div>
<div class="line">    <span class="comment">// Throws an exception if the named parameter is of the wrong type.</span></div>
<div class="line">    const Rgba&amp; rgba =</div>
<div class="line">        pair.second-&gt;GetValueOrThrow&lt;Rgba&gt;();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> </div>
<p><code>#include &lt;drake/geometry/geometry_properties.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae8d3ca3bf519ceabc12e40a299696adb" id="r_ae8d3ca3bf519ceabc12e40a299696adb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8d3ca3bf519ceabc12e40a299696adb">Group</a></td></tr>
<tr class="memdesc:ae8d3ca3bf519ceabc12e40a299696adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The properties for a single group as a property name-value map.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adc0376813bd4cbe81ce36cdd9b5ab391" id="r_adc0376813bd4cbe81ce36cdd9b5ab391"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc0376813bd4cbe81ce36cdd9b5ab391">~GeometryProperties</a> ()</td></tr>
<tr class="memitem:ad4a46edb0e7b07e1aa49ddb946ddecc0" id="r_ad4a46edb0e7b07e1aa49ddb946ddecc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4a46edb0e7b07e1aa49ddb946ddecc0">HasGroup</a> (const std::string &amp;group_name) const</td></tr>
<tr class="memdesc:ad4a46edb0e7b07e1aa49ddb946ddecc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports if the given named group is part of this property set.  <br /></td></tr>
<tr class="memitem:ae3d6aafba237b9251e8fabd0dbe76528" id="r_ae3d6aafba237b9251e8fabd0dbe76528"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3d6aafba237b9251e8fabd0dbe76528">num_groups</a> () const</td></tr>
<tr class="memdesc:ae3d6aafba237b9251e8fabd0dbe76528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the number of property groups in this set.  <br /></td></tr>
<tr class="memitem:abce3d9a80b9d65281dd993cecbfe79db" id="r_abce3d9a80b9d65281dd993cecbfe79db"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#ae8d3ca3bf519ceabc12e40a299696adb">Group</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abce3d9a80b9d65281dd993cecbfe79db">GetPropertiesInGroup</a> (const std::string &amp;group_name) const</td></tr>
<tr class="memdesc:abce3d9a80b9d65281dd993cecbfe79db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the indicated property group.  <br /></td></tr>
<tr class="memitem:a693753eed604320bb10bc05ad3a67605" id="r_a693753eed604320bb10bc05ad3a67605"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a693753eed604320bb10bc05ad3a67605">GetGroupNames</a> () const</td></tr>
<tr class="memdesc:a693753eed604320bb10bc05ad3a67605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all of the defined group names.  <br /></td></tr>
<tr class="memitem:a5c36bb4c5566a8316bc8b52601e49d27" id="r_a5c36bb4c5566a8316bc8b52601e49d27"><td class="memTemplParams" colspan="2">template&lt;typename ValueType&gt; </td></tr>
<tr class="memitem:a5c36bb4c5566a8316bc8b52601e49d27 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c36bb4c5566a8316bc8b52601e49d27">AddProperty</a> (const std::string &amp;group_name, const std::string &amp;name, const ValueType &amp;value)</td></tr>
<tr class="memdesc:a5c36bb4c5566a8316bc8b52601e49d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the named property (<span class="tt">group_name</span>, <span class="tt">name</span>) with the given <span class="tt">value</span>.  <br /></td></tr>
<tr class="memitem:ad519098cc972ba24c36302f3290d2b06" id="r_ad519098cc972ba24c36302f3290d2b06"><td class="memTemplParams" colspan="2">template&lt;typename ValueType&gt; </td></tr>
<tr class="memitem:ad519098cc972ba24c36302f3290d2b06 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad519098cc972ba24c36302f3290d2b06">UpdateProperty</a> (const std::string &amp;group_name, const std::string &amp;name, const ValueType &amp;value)</td></tr>
<tr class="memdesc:ad519098cc972ba24c36302f3290d2b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the named property (<span class="tt">group_name</span>, <span class="tt">name</span>) with the given <span class="tt">value</span>.  <br /></td></tr>
<tr class="memitem:aa944be9be3bd2cdefdad5f3d56648408" id="r_aa944be9be3bd2cdefdad5f3d56648408"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa944be9be3bd2cdefdad5f3d56648408">AddPropertyAbstract</a> (const std::string &amp;group_name, const std::string &amp;name, const <a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a> &amp;value)</td></tr>
<tr class="memdesc:aa944be9be3bd2cdefdad5f3d56648408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the named property (<span class="tt">group_name</span>, <span class="tt">name</span>) with the given type-erased <span class="tt">value</span>.  <br /></td></tr>
<tr class="memitem:ad9c4c3542d53e235c4624e4f753692f4" id="r_ad9c4c3542d53e235c4624e4f753692f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9c4c3542d53e235c4624e4f753692f4">UpdatePropertyAbstract</a> (const std::string &amp;group_name, const std::string &amp;name, const <a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a> &amp;value)</td></tr>
<tr class="memdesc:ad9c4c3542d53e235c4624e4f753692f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the named property (<span class="tt">group_name</span>, <span class="tt">name</span>) with the given type-erased <span class="tt">value</span>.  <br /></td></tr>
<tr class="memitem:ace6a963ab7442bf3f29d9ebacdc849ca" id="r_ace6a963ab7442bf3f29d9ebacdc849ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace6a963ab7442bf3f29d9ebacdc849ca">HasProperty</a> (const std::string &amp;group_name, const std::string &amp;name) const</td></tr>
<tr class="memdesc:ace6a963ab7442bf3f29d9ebacdc849ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports if the property (<span class="tt">group_name</span>, <span class="tt">name</span>) exists in the group.  <br /></td></tr>
<tr class="memitem:aaaa9388bc0cffeef445272cc5234b087" id="r_aaaa9388bc0cffeef445272cc5234b087"><td class="memTemplParams" colspan="2">template&lt;typename ValueType&gt; </td></tr>
<tr class="memitem:aaaa9388bc0cffeef445272cc5234b087 template"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaaa9388bc0cffeef445272cc5234b087">GetProperty</a> (const std::string &amp;group_name, const std::string &amp;name) const</td></tr>
<tr class="memdesc:aaaa9388bc0cffeef445272cc5234b087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the typed value for the property (<span class="tt">group_name</span>, <span class="tt">name</span>) from this set of properties.  <br /></td></tr>
<tr class="memitem:a3f20c0b20b717cb1f84afc2ba68bb33d" id="r_a3f20c0b20b717cb1f84afc2ba68bb33d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f20c0b20b717cb1f84afc2ba68bb33d">GetPropertyAbstract</a> (const std::string &amp;group_name, const std::string &amp;name) const</td></tr>
<tr class="memdesc:a3f20c0b20b717cb1f84afc2ba68bb33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the type-erased value for the property (<span class="tt">group_name</span>, <span class="tt">name</span>) from this set of properties.  <br /></td></tr>
<tr class="memitem:a7b425641c9937dea89f553cabba9b186" id="r_a7b425641c9937dea89f553cabba9b186"><td class="memTemplParams" colspan="2">template&lt;typename ValueType&gt; </td></tr>
<tr class="memitem:a7b425641c9937dea89f553cabba9b186 template"><td class="memItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b425641c9937dea89f553cabba9b186">GetPropertyOrDefault</a> (const std::string &amp;group_name, const std::string &amp;name, ValueType default_value) const</td></tr>
<tr class="memdesc:a7b425641c9937dea89f553cabba9b186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the typed value for the property (<span class="tt">group_name</span>, <span class="tt">name</span>) from the set of properties (if it exists), otherwise returns the given default value.  <br /></td></tr>
<tr class="memitem:a221c35662fe3549e2fd6ca5457d70c0c" id="r_a221c35662fe3549e2fd6ca5457d70c0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a221c35662fe3549e2fd6ca5457d70c0c">RemoveProperty</a> (const std::string &amp;group_name, const std::string &amp;name)</td></tr>
<tr class="memdesc:a221c35662fe3549e2fd6ca5457d70c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the (<span class="tt">group_name</span>, <span class="tt">name</span>) property (if it exists).  <br /></td></tr>
<tr class="memitem:aac993ecccd3d88aafefb6b8e3caa1dee" id="r_aac993ecccd3d88aafefb6b8e3caa1dee"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac993ecccd3d88aafefb6b8e3caa1dee">to_string</a> () const</td></tr>
<tr class="memdesc:aac993ecccd3d88aafefb6b8e3caa1dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the <a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html" title="The base class for defining a set of geometry properties.">GeometryProperties</a> to a string representation.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7c9d7d51d987f24034f0949aba25a608" id="r_a7c9d7d51d987f24034f0949aba25a608"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c9d7d51d987f24034f0949aba25a608">default_group_name</a> ()</td></tr>
<tr class="memdesc:a7c9d7d51d987f24034f0949aba25a608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default group name.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-methods" class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad86db1a9e167f7f17c42d65edca84383" id="r_ad86db1a9e167f7f17c42d65edca84383"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad86db1a9e167f7f17c42d65edca84383">GeometryProperties</a> ()</td></tr>
<tr class="memdesc:ad86db1a9e167f7f17c42d65edca84383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a property set with the default group.  <br /></td></tr>
<tr id="pro-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:a985605d92e6d5ae06e51f2b3ad109c14" id="r_a985605d92e6d5ae06e51f2b3ad109c14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a985605d92e6d5ae06e51f2b3ad109c14">GeometryProperties</a> (const GeometryProperties &amp;)=default</td></tr>
<tr class="memitem:a34a562badbd08d95cee5cd7d453cae3a" id="r_a34a562badbd08d95cee5cd7d453cae3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad86db1a9e167f7f17c42d65edca84383">GeometryProperties</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34a562badbd08d95cee5cd7d453cae3a">operator=</a> (const <a class="el" href="#ad86db1a9e167f7f17c42d65edca84383">GeometryProperties</a> &amp;)=default</td></tr>
<tr class="memitem:a32edcdb0f6338ecb9342d79d03035bcc" id="r_a32edcdb0f6338ecb9342d79d03035bcc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32edcdb0f6338ecb9342d79d03035bcc">GeometryProperties</a> (GeometryProperties &amp;&amp;)=default</td></tr>
<tr class="memitem:ab87e5af2da5303047d73bfaa83044a26" id="r_ab87e5af2da5303047d73bfaa83044a26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad86db1a9e167f7f17c42d65edca84383">GeometryProperties</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab87e5af2da5303047d73bfaa83044a26">operator=</a> (<a class="el" href="#ad86db1a9e167f7f17c42d65edca84383">GeometryProperties</a> &amp;&amp;)=default</td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="ae8d3ca3bf519ceabc12e40a299696adb" name="ae8d3ca3bf519ceabc12e40a299696adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d3ca3bf519ceabc12e40a299696adb">&#9670;&#160;</a></span>Group</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae8d3ca3bf519ceabc12e40a299696adb">Group</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      std::unordered_map&lt;std::string, copyable_unique_ptr&lt;AbstractValue&gt;&gt;</div>
</div><!-- fragment -->
<p>The properties for a single group as a property name-value map. </p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adc0376813bd4cbe81ce36cdd9b5ab391" name="adc0376813bd4cbe81ce36cdd9b5ab391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0376813bd4cbe81ce36cdd9b5ab391">&#9670;&#160;</a></span>~GeometryProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="#ad86db1a9e167f7f17c42d65edca84383">GeometryProperties</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad86db1a9e167f7f17c42d65edca84383" name="ad86db1a9e167f7f17c42d65edca84383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86db1a9e167f7f17c42d65edca84383">&#9670;&#160;</a></span>GeometryProperties() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GeometryProperties </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a property set with the default group. </p>
<p>Only invoked by final subclasses. </p>

</div>
</div>
<a id="a985605d92e6d5ae06e51f2b3ad109c14" name="a985605d92e6d5ae06e51f2b3ad109c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985605d92e6d5ae06e51f2b3ad109c14">&#9670;&#160;</a></span>GeometryProperties() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GeometryProperties </td>
          <td>(</td>
          <td class="paramtype">const GeometryProperties &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32edcdb0f6338ecb9342d79d03035bcc" name="a32edcdb0f6338ecb9342d79d03035bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32edcdb0f6338ecb9342d79d03035bcc">&#9670;&#160;</a></span>GeometryProperties() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GeometryProperties </td>
          <td>(</td>
          <td class="paramtype">GeometryProperties &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a5c36bb4c5566a8316bc8b52601e49d27" name="a5c36bb4c5566a8316bc8b52601e49d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c36bb4c5566a8316bc8b52601e49d27">&#9670;&#160;</a></span>AddProperty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void AddProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the named property (<span class="tt">group_name</span>, <span class="tt">name</span>) with the given <span class="tt">value</span>. </p>
<p>Adds the group if it doesn't already exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_name</td><td>The group name. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the property &ndash; must be unique in the group. </td></tr>
    <tr><td class="paramname">value</td><td>The value to assign to the property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the property already exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The type of data to store with the attribute &ndash; must be copy constructible or cloneable (see <a class="el" href="classdrake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">Value</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa944be9be3bd2cdefdad5f3d56648408" name="aa944be9be3bd2cdefdad5f3d56648408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa944be9be3bd2cdefdad5f3d56648408">&#9670;&#160;</a></span>AddPropertyAbstract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddPropertyAbstract </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the named property (<span class="tt">group_name</span>, <span class="tt">name</span>) with the given type-erased <span class="tt">value</span>. </p>
<p>Adds the group if it doesn't already exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_name</td><td>The group name. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the property &ndash; must be unique in the group. </td></tr>
    <tr><td class="paramname">value</td><td>The value to assign to the property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the property already exists. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c9d7d51d987f24034f0949aba25a608" name="a7c9d7d51d987f24034f0949aba25a608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9d7d51d987f24034f0949aba25a608">&#9670;&#160;</a></span>default_group_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; default_group_name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the default group name. </p>
<p>There is no guarantee as to <em>what</em> string corresponds to the default group. Therefore it should always be accessed via this method. </p>

</div>
</div>
<a id="a693753eed604320bb10bc05ad3a67605" name="a693753eed604320bb10bc05ad3a67605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693753eed604320bb10bc05ad3a67605">&#9670;&#160;</a></span>GetGroupNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::string &gt; GetGroupNames </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all of the defined group names. </p>

</div>
</div>
<a id="abce3d9a80b9d65281dd993cecbfe79db" name="abce3d9a80b9d65281dd993cecbfe79db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce3d9a80b9d65281dd993cecbfe79db">&#9670;&#160;</a></span>GetPropertiesInGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#ae8d3ca3bf519ceabc12e40a299696adb">Group</a> &amp; GetPropertiesInGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group_name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the indicated property group. </p>
<p>The returned group is valid for as long as this instance. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there is no group with the given name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaaa9388bc0cffeef445272cc5234b087" name="aaaa9388bc0cffeef445272cc5234b087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa9388bc0cffeef445272cc5234b087">&#9670;&#160;</a></span>GetProperty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) GetProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the typed value for the property (<span class="tt">group_name</span>, <span class="tt">name</span>) from this set of properties. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_name</td><td>The name of the group to which the property belongs. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the desired property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if a) the group name is invalid, b) the property name is invalid, or c) the property type is not that specified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The expected type of the desired property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const ValueType&amp; of stored value. If ValueType is Eigen::Vector4d, the return type will be a copy translated from <a class="el" href="classdrake_1_1geometry_1_1_rgba.html" title="Defines RGBA (red, green, blue, alpha) values on the range [0, 1].">Rgba</a>. </dd></dl>

</div>
</div>
<a id="a3f20c0b20b717cb1f84afc2ba68bb33d" name="a3f20c0b20b717cb1f84afc2ba68bb33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f20c0b20b717cb1f84afc2ba68bb33d">&#9670;&#160;</a></span>GetPropertyAbstract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a> &amp; GetPropertyAbstract </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the type-erased value for the property (<span class="tt">group_name</span>, <span class="tt">name</span>) from this set of properties. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_name</td><td>The name of the group to which the property belongs. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the desired property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if a) the group name is invalid, or b) the property name is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b425641c9937dea89f553cabba9b186" name="a7b425641c9937dea89f553cabba9b186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b425641c9937dea89f553cabba9b186">&#9670;&#160;</a></span>GetPropertyOrDefault()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValueType GetPropertyOrDefault </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType</td>          <td class="paramname"><span class="paramname"><em>default_value</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the typed value for the property (<span class="tt">group_name</span>, <span class="tt">name</span>) from the set of properties (if it exists), otherwise returns the given default value. </p>
<p>The given <span class="tt">default_value</span> is returned only if the property is missing. If the property exists and is of a <em>different</em> type, an exception will be thrown. If it is of the expected type, the stored value will be returned.</p>
<p>Generally, it is unnecessary to explicitly declare the <span class="tt">ValueType</span> of the property value; it will be inferred from the provided default value. Sometimes it is convenient to provide the default value in a form that can be implicitly converted to the final type. In that case, it is necessary to explicitly declare the desired <span class="tt">ValueType</span> so the compiler does not infer the wrong type, e.g.:</p>
<div class="fragment"><div class="line"><span class="comment">// Note the _integer_ value as default value.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> my_value = properties.GetPropertyOrDefault&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;g&quot;</span>, <span class="stringliteral">&quot;p&quot;</span>, 2);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_name</td><td>The name of the group to which the property belongs. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the desired property. </td></tr>
    <tr><td class="paramname">default_value</td><td>The alternate value to return if the property cannot be acquired. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if a property of the given name exists but is not of <span class="tt">ValueType</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4a46edb0e7b07e1aa49ddb946ddecc0" name="ad4a46edb0e7b07e1aa49ddb946ddecc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a46edb0e7b07e1aa49ddb946ddecc0">&#9670;&#160;</a></span>HasGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group_name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports if the given named group is part of this property set. </p>

</div>
</div>
<a id="ace6a963ab7442bf3f29d9ebacdc849ca" name="ace6a963ab7442bf3f29d9ebacdc849ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6a963ab7442bf3f29d9ebacdc849ca">&#9670;&#160;</a></span>HasProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports if the property (<span class="tt">group_name</span>, <span class="tt">name</span>) exists in the group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_name</td><td>The name of the group to which the tested property should belong. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the property under question. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff the group exists and a property with the given <span class="tt">name</span> exists in that group. </dd></dl>

</div>
</div>
<a id="ae3d6aafba237b9251e8fabd0dbe76528" name="ae3d6aafba237b9251e8fabd0dbe76528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d6aafba237b9251e8fabd0dbe76528">&#9670;&#160;</a></span>num_groups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int num_groups </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the number of property groups in this set. </p>

</div>
</div>
<a id="a34a562badbd08d95cee5cd7d453cae3a" name="a34a562badbd08d95cee5cd7d453cae3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a562badbd08d95cee5cd7d453cae3a">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad86db1a9e167f7f17c42d65edca84383">GeometryProperties</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad86db1a9e167f7f17c42d65edca84383">GeometryProperties</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab87e5af2da5303047d73bfaa83044a26" name="ab87e5af2da5303047d73bfaa83044a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87e5af2da5303047d73bfaa83044a26">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad86db1a9e167f7f17c42d65edca84383">GeometryProperties</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad86db1a9e167f7f17c42d65edca84383">GeometryProperties</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a221c35662fe3549e2fd6ca5457d70c0c" name="a221c35662fe3549e2fd6ca5457d70c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221c35662fe3549e2fd6ca5457d70c0c">&#9670;&#160;</a></span>RemoveProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RemoveProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the (<span class="tt">group_name</span>, <span class="tt">name</span>) property (if it exists). </p>
<p>Upon completion the property will not be in the set. </p><dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the property existed prior to the call. </dd></dl>

</div>
</div>
<a id="aac993ecccd3d88aafefb6b8e3caa1dee" name="aac993ecccd3d88aafefb6b8e3caa1dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac993ecccd3d88aafefb6b8e3caa1dee">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the <a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html" title="The base class for defining a set of geometry properties.">GeometryProperties</a> to a string representation. </p>

</div>
</div>
<a id="ad519098cc972ba24c36302f3290d2b06" name="ad519098cc972ba24c36302f3290d2b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad519098cc972ba24c36302f3290d2b06">&#9670;&#160;</a></span>UpdateProperty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void UpdateProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the named property (<span class="tt">group_name</span>, <span class="tt">name</span>) with the given <span class="tt">value</span>. </p>
<p>If the property doesn't already exist, it is equivalent to calling <span class="tt"><a class="el" href="#a5c36bb4c5566a8316bc8b52601e49d27" title="Adds the named property (group_name, name) with the given value.">AddProperty</a></span>. If the property does exist, its value (which must have the same type as <span class="tt">value</span>) will be replaced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_name</td><td>The group name. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the property &ndash; must be unique in the group. </td></tr>
    <tr><td class="paramname">value</td><td>The value to assign to the property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the property exists with a different type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The type of data to store with the attribute &ndash; must be copy constructible or cloneable (see <a class="el" href="classdrake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">Value</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9c4c3542d53e235c4624e4f753692f4" name="ad9c4c3542d53e235c4624e4f753692f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c4c3542d53e235c4624e4f753692f4">&#9670;&#160;</a></span>UpdatePropertyAbstract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UpdatePropertyAbstract </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>group_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the named property (<span class="tt">group_name</span>, <span class="tt">name</span>) with the given type-erased <span class="tt">value</span>. </p>
<p>If the property doesn't already exist, it is equivalent to calling <span class="tt"><a class="el" href="#aa944be9be3bd2cdefdad5f3d56648408" title="Adds the named property (group_name, name) with the given type-erased value.">AddPropertyAbstract</a></span>. If the property does exist, its value (which must have the same type as <span class="tt">value</span>) will be replaced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_name</td><td>The group name. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the property &ndash; must be unique in the group. </td></tr>
    <tr><td class="paramname">value</td><td>The value to assign to the property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the property exists with a different type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/geometry/<a class="el" href="geometry__properties_8h.html">geometry_properties.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1geometry.html">geometry</a></li><li class="navelem"><a href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="https://accessibility.mit.edu/" class="site-menu-item">Accessibility</a>
        </li>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
