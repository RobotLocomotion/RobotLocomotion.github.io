<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: GeometryProperties Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1geometry_1_1_geometry_properties.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdrake_1_1geometry_1_1_geometry_properties-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GeometryProperties Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The base class for defining a set of geometry properties. </p>
<p>Each property consists of a <code>(group, property)</code> name-pair and a typed value. The name pair allows for reuse of common property names (e.g., "diffuse") to be differentiated in interpretation by associating them with different groups. The only restriction on the value type is that it must be either cloneable or copy-constructible.</p>
<p>A set of geometry property values are defined when geometry is registered with <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> by an instantiator and accessed by some downstream consumer entity. Each consumer specifies what properties it expects to find and what default values (if any) it provides. For example, the consumer could document that a particular property is always required and its absence would throw an exception. Alternatively, it could indicate that a property is optional and a default value will be used in its absence. It is the responsibility of the instantiator to make sure that the geometry property values are <em>correctly</em> defined according to the expected consumer's specification. Correctness includes such issues as key-value pairs placed into a <em>correctly</em>-spelled group, property keys being likewise correctly spelled, and values of the expected type. Correct spelling includes correct case. The instantiator uses the <a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#a5c36bb4c5566a8316bc8b52601e49d27" title="Adds the named property (group_name, name) with the given value.">AddProperty()</a> method to add new properties to the set.</p>
<p>To read the property (<code>some_group</code>, <code>some_property</code>) from a property set:</p>
<ol type="1">
<li>Optionally test to see if the property exists by confirming the group <code>some_group</code> is in the set via <a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#ad4a46edb0e7b07e1aa49ddb946ddecc0" title="Reports if the given named group is part of this property set.">HasGroup()</a> and that the property <code>some_property</code> is in <code>some_group</code> via <a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#ace6a963ab7442bf3f29d9ebacdc849ca" title="Reports if the property (group_name, name) exists in the group.">HasProperty()</a>. Attempting to access a property with a non-existent (group, property) pair may lead to an exception (see API documentation below).</li>
<li>Acquire a property value via the <a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#aaaa9388bc0cffeef445272cc5234b087" title="Retrieves the typed value for the property (group_name, name) from this set of properties.">GetProperty()</a> or <a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#a7b425641c9937dea89f553cabba9b186" title="Retrieves the typed value for the property (group_name, name) from the set of properties (if it exist...">GetPropertyOrDefault()</a> methods. NOTE: Reading a property requires a compile-time declaration of the <em>type</em> of value being read. If the stored value is of a different type, an exception will be thrown.</li>
</ol>
<h2>Common workflows</h2>
<p>The following examples outline a number of ways to create and consume geometry properties. By design, GeometryProperties cannot be constructed, copied, or moved directly. Only derived classes can do so. This facilitates <em>strongly typed</em> sets of properties associated with particular geometry roles. So, for these examples we'll exercise the derived class associated with proximity queries: <a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html" title="The set of properties for geometry used in a proximity role.">ProximityProperties</a>.</p>
<p>The string-based structure of GeometryProperties provides a great deal of flexibility at the cost of spelling sensitivity. It would be easy to introduce typos that would then "hide" property values in some group a consumer wouldn't look. In these examples, we avoid using string literals as group or property names (at least in the cases where the same name is used multiple times) to help avoid the possibility of typo-induced errors. That is not required and certainly not the only way to avoid such bugs.</p>
<h3>Creating properties</h3>
<h4>Creating properties in a new group</h4>
<p>This is a simple example in which a single group is added with properties of various types.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::string group_name(<span class="stringliteral">&quot;my_group&quot;</span>);</div><div class="line">ProximityProperties properties;</div><div class="line"><span class="comment">// This first invocation implicitly creates the group &quot;my_group&quot;.</span></div><div class="line">properties.AddProperty(group_name, <span class="stringliteral">&quot;count&quot;</span>, 7);     <span class="comment">// int type</span></div><div class="line">properties.AddProperty(group_name, <span class="stringliteral">&quot;length&quot;</span>, 7.);   <span class="comment">// double type</span></div><div class="line">properties.AddProperty(group_name, <span class="stringliteral">&quot;name&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>);    <span class="comment">// std::string type</span></div></div><!-- fragment --><h4>Creating properties in the default group</h4>
<p>Similar to the previous examples, the properties are added to the default group. Just be aware that if multiple sites in your code add properties to the default group, the possibility that names get repeated increases. Property names <em>must</em> be unique within a single group, including the default group.</p>
<div class="fragment"><div class="line">ProximityProperties properties;</div><div class="line">properties.AddProperty(<a class="code" href="classdrake_1_1geometry_1_1_geometry_properties.html#aa9fbb361a1fc07d3f00cd10905d27e23">ProximityProperties::default_group_name</a>(), <span class="stringliteral">&quot;count&quot;</span>, 7);</div><div class="line">properties.AddProperty(<a class="code" href="classdrake_1_1geometry_1_1_geometry_properties.html#aa9fbb361a1fc07d3f00cd10905d27e23">ProximityProperties::default_group_name</a>(), <span class="stringliteral">&quot;width&quot;</span>, 7.);</div><div class="line">properties.AddProperty(<a class="code" href="classdrake_1_1geometry_1_1_geometry_properties.html#aa9fbb361a1fc07d3f00cd10905d27e23">ProximityProperties::default_group_name</a>(), <span class="stringliteral">&quot;name&quot;</span>, <span class="stringliteral">&quot;7&quot;</span>);</div></div><!-- fragment --><h4>Aggregate properties in a struct</h4>
<p>In some cases, there is a set of values that will <em>always</em> be accessed together (specified with coordinated semantics). In these cases, it makes sense to aggregate them into a struct and store that as a single value. This reduces the number of lookups required.</p>
<p>It's worth noting, that if the data value is a struct, calls to <a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#a7b425641c9937dea89f553cabba9b186" title="Retrieves the typed value for the property (group_name, name) from the set of properties (if it exist...">GetPropertyOrDefault()</a> still operate as an "all-or-nothing" basis. If the property <em>struct</em> exists, it will be returned, if it's missing the default struct will be returned. There is no concept of a "partial" struct in which some undefined values in the struct will be replaced with their corresponding values in the default struct.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyData {</div><div class="line">   <span class="keywordtype">int</span> i{};</div><div class="line">   <span class="keywordtype">double</span> d{};</div><div class="line">   std::string s;</div><div class="line">};</div><div class="line"></div><div class="line">ProximityProperties properties;</div><div class="line"><span class="keyword">const</span> std::string group_name(<span class="stringliteral">&quot;my_group&quot;</span>);</div><div class="line">MyData data{7, 7., <span class="stringliteral">&quot;7&quot;</span>};</div><div class="line">properties.AddProperty(group_name, <span class="stringliteral">&quot;data1&quot;</span>, data);</div><div class="line"><span class="comment">// These alternate forms are also acceptable (but not in succession, as the</span></div><div class="line"><span class="comment">// property name has already been used by the first invocation).</span></div><div class="line">properties.AddProperty(group_name, <span class="stringliteral">&quot;data2&quot;</span>, MyData{6, 6., <span class="stringliteral">&quot;6&quot;</span>});</div><div class="line">properties.AddProperty&lt;MyData&gt;(group_name, <span class="stringliteral">&quot;data2&quot;</span>, {6, 6., <span class="stringliteral">&quot;6&quot;</span>});</div></div><!-- fragment --><h3>Reading properties</h3>
<p>This section describes how to read properties under several different scenarios: (a) when specific properties are required, (b) when the consumer provides a default value for missing properties, and (c) when the consumer needs to inspect what properties are available.</p>
<h4>Look up specific, <em>required</em> properties</h4>
<p>In this case, the consumer of the properties is looking for one or more specific properties. It will ignore any other properties. More particularly, if those properties are missing, it is considered a runtime error and an exception is thrown.</p>
<p>The error can be handled in one of two ways: simply let the generic exception generated by GeometryProperties propagate upward, or detect the missing property and throw an exception with a custom message. The example below shows both approaches.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> IllustrationProperties&amp; properties = FunctionThatReturnsProperties();</div><div class="line"><span class="comment">// Looking for a Rgba of rgba colors named &quot;rgba&quot; - send generic error that</span></div><div class="line"><span class="comment">// the property set is missing the required property.</span></div><div class="line"><span class="keyword">const</span> Rgba rgba =</div><div class="line">    properties.GetProperty&lt;Rgba&gt;(<span class="stringliteral">&quot;MyGroup&quot;</span>, <span class="stringliteral">&quot;rgba&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Explicitly detect missing property and throw exception with custom message.</span></div><div class="line"><span class="keywordflow">if</span> (!properties.HasProperty(<span class="stringliteral">&quot;MyGroup&quot;</span>, <span class="stringliteral">&quot;rgba&quot;</span>)) {</div><div class="line">  <span class="keywordflow">throw</span> std::logic_error(</div><div class="line">      <span class="stringliteral">&quot;ThisClass: Missing the necessary &#39;rgba&#39; property; the object cannot be &quot;</span></div><div class="line">      <span class="stringliteral">&quot;rendered&quot;</span>);</div><div class="line">}</div><div class="line"><span class="comment">// Otherwise acquire value, confident that no exception will be thrown.</span></div><div class="line"><span class="keyword">const</span> Rgba rgba =</div><div class="line">    properties.GetProperty&lt;Rgba&gt;(<span class="stringliteral">&quot;MyGroup&quot;</span>, <span class="stringliteral">&quot;rgba&quot;</span>);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>calls to <code><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#aaaa9388bc0cffeef445272cc5234b087" title="Retrieves the typed value for the property (group_name, name) from this set of properties.">GetProperty()</a></code> always require the return type template value (e.g., <code><a class="el" href="classdrake_1_1geometry_1_1_rgba.html" title="Defines RGBA (red, green, blue, alpha) values on the range [0, 1].">Rgba</a></code>) to be specified in the call.</dd></dl>
<h4>Look up specific properties with default property values</h4>
<p>As with the previous case, the consumer is looking for one or more specific properties. However, in this case, the consumer provides a default value to use in case the target property is not defined. In this invocation, the template parameter need not be explicitly declared &ndash; the inferred return type will be the same as the default value.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> IllustrationProperties&amp; properties = FunctionThatReturnsProperties();</div><div class="line"><span class="comment">// Looking for a Rgba of rgba colors named &quot;rgba&quot;.</span></div><div class="line"><span class="keyword">const</span> Rgba default_color{0.9, 0.9, 0.9};</div><div class="line"><span class="keyword">const</span> Rgba rgba =</div><div class="line">    properties.GetPropertyOrDefault(<span class="stringliteral">&quot;MyGroup&quot;</span>, <span class="stringliteral">&quot;rgba&quot;</span>, default_color);</div></div><!-- fragment --><p>Alternatively, the default value can be provided in one of the following forms:</p>
<div class="fragment"><div class="line">properties.GetPropertyOrDefault(<span class="stringliteral">&quot;MyGroup&quot;</span>, <span class="stringliteral">&quot;rgba&quot;</span>,</div><div class="line">    Rgba{0.9, 0.9, 0.9});</div><div class="line">properties.GetPropertyOrDefault&lt;Rgba&gt;(<span class="stringliteral">&quot;MyGroup&quot;</span>, <span class="stringliteral">&quot;rgba&quot;</span>,</div><div class="line">    {0.9, 0.9, 0.9});</div></div><!-- fragment --><h4>Iterating through provided properties</h4>
<p>Another alternative is to iterate through the properties that <em>have</em> been provided. This might be done for several reasons, e.g.:</p>
<ul>
<li>the consumer wants to validate the set of properties, giving the user feedback if an unsupported property has been provided, and/or</li>
<li>the consumer has a default value for every property and allows the registering code to define only those properties that deviate from the specified default.</li>
</ul>
<p>Working with properties in this manner requires knowledge of how to work with <a class="el" href="classdrake_1_1_abstract_value.html" title="A fully type-erased container class.">AbstractValue</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> IllustrationProperties&amp; properties = FunctionThatReturnsProperties();</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pair : properties.GetGroupProperties(<span class="stringliteral">&quot;MyGroup&quot;</span>) {</div><div class="line">  <span class="keyword">const</span> std::string&amp; name = pair.first;</div><div class="line">  <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;rgba&quot;</span>) {</div><div class="line">    <span class="comment">// Throws an exception if the named parameter is of the wrong type.</span></div><div class="line">    <span class="keyword">const</span> Rgba&amp; rgba =</div><div class="line">        pair.second-&gt;GetValueOrThrow&lt;Rgba&gt;();</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --> </div>
<p><code>#include &lt;drake/geometry/geometry_properties.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1094a6990819e25b5d259c0d35affe66"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#a1094a6990819e25b5d259c0d35affe66">Group</a> = std::unordered_map&lt; std::string, <a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; <a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a> &gt; &gt;</td></tr>
<tr class="memdesc:a1094a6990819e25b5d259c0d35affe66"><td class="mdescLeft">&#160;</td><td class="mdescRight">The properties for a single group as a property name-value map.  <a href="#a1094a6990819e25b5d259c0d35affe66">More...</a><br /></td></tr>
<tr class="separator:a1094a6990819e25b5d259c0d35affe66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a94116c2953fa02aea8b4398148685e82"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#a94116c2953fa02aea8b4398148685e82">~GeometryProperties</a> ()=default</td></tr>
<tr class="separator:a94116c2953fa02aea8b4398148685e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a46edb0e7b07e1aa49ddb946ddecc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#ad4a46edb0e7b07e1aa49ddb946ddecc0">HasGroup</a> (const std::string &amp;group_name) const</td></tr>
<tr class="memdesc:ad4a46edb0e7b07e1aa49ddb946ddecc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports if the given named group is part of this property set.  <a href="#ad4a46edb0e7b07e1aa49ddb946ddecc0">More...</a><br /></td></tr>
<tr class="separator:ad4a46edb0e7b07e1aa49ddb946ddecc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d6aafba237b9251e8fabd0dbe76528"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#ae3d6aafba237b9251e8fabd0dbe76528">num_groups</a> () const</td></tr>
<tr class="memdesc:ae3d6aafba237b9251e8fabd0dbe76528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the number of property groups in this set.  <a href="#ae3d6aafba237b9251e8fabd0dbe76528">More...</a><br /></td></tr>
<tr class="separator:ae3d6aafba237b9251e8fabd0dbe76528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1faa50f8c98b05093c22e7d1ce5ee630"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#a1094a6990819e25b5d259c0d35affe66">Group</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#a1faa50f8c98b05093c22e7d1ce5ee630">GetPropertiesInGroup</a> (const std::string &amp;group_name) const</td></tr>
<tr class="memdesc:a1faa50f8c98b05093c22e7d1ce5ee630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the indicated property group.  <a href="#a1faa50f8c98b05093c22e7d1ce5ee630">More...</a><br /></td></tr>
<tr class="separator:a1faa50f8c98b05093c22e7d1ce5ee630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228de14aac3d5f432178df9d0cc8aa43"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#a228de14aac3d5f432178df9d0cc8aa43">GetGroupNames</a> () const</td></tr>
<tr class="memdesc:a228de14aac3d5f432178df9d0cc8aa43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all of the defined group names.  <a href="#a228de14aac3d5f432178df9d0cc8aa43">More...</a><br /></td></tr>
<tr class="separator:a228de14aac3d5f432178df9d0cc8aa43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c36bb4c5566a8316bc8b52601e49d27"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a5c36bb4c5566a8316bc8b52601e49d27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#a5c36bb4c5566a8316bc8b52601e49d27">AddProperty</a> (const std::string &amp;group_name, const std::string &amp;name, const ValueType &amp;value)</td></tr>
<tr class="memdesc:a5c36bb4c5566a8316bc8b52601e49d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the named property (<code>group_name</code>, <code>name</code>) with the given <code>value</code>.  <a href="#a5c36bb4c5566a8316bc8b52601e49d27">More...</a><br /></td></tr>
<tr class="separator:a5c36bb4c5566a8316bc8b52601e49d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad519098cc972ba24c36302f3290d2b06"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ad519098cc972ba24c36302f3290d2b06"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#ad519098cc972ba24c36302f3290d2b06">UpdateProperty</a> (const std::string &amp;group_name, const std::string &amp;name, const ValueType &amp;value)</td></tr>
<tr class="memdesc:ad519098cc972ba24c36302f3290d2b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the named property (<code>group_name</code>, <code>name</code>) with the given <code>value</code>.  <a href="#ad519098cc972ba24c36302f3290d2b06">More...</a><br /></td></tr>
<tr class="separator:ad519098cc972ba24c36302f3290d2b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa944be9be3bd2cdefdad5f3d56648408"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#aa944be9be3bd2cdefdad5f3d56648408">AddPropertyAbstract</a> (const std::string &amp;group_name, const std::string &amp;name, const <a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a> &amp;value)</td></tr>
<tr class="memdesc:aa944be9be3bd2cdefdad5f3d56648408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the named property (<code>group_name</code>, <code>name</code>) with the given type-erased <code>value</code>.  <a href="#aa944be9be3bd2cdefdad5f3d56648408">More...</a><br /></td></tr>
<tr class="separator:aa944be9be3bd2cdefdad5f3d56648408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c4c3542d53e235c4624e4f753692f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#ad9c4c3542d53e235c4624e4f753692f4">UpdatePropertyAbstract</a> (const std::string &amp;group_name, const std::string &amp;name, const <a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a> &amp;value)</td></tr>
<tr class="memdesc:ad9c4c3542d53e235c4624e4f753692f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the named property (<code>group_name</code>, <code>name</code>) with the given type-erased <code>value</code>.  <a href="#ad9c4c3542d53e235c4624e4f753692f4">More...</a><br /></td></tr>
<tr class="separator:ad9c4c3542d53e235c4624e4f753692f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6a963ab7442bf3f29d9ebacdc849ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#ace6a963ab7442bf3f29d9ebacdc849ca">HasProperty</a> (const std::string &amp;group_name, const std::string &amp;name) const</td></tr>
<tr class="memdesc:ace6a963ab7442bf3f29d9ebacdc849ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports if the property (<code>group_name</code>, <code>name</code>) exists in the group.  <a href="#ace6a963ab7442bf3f29d9ebacdc849ca">More...</a><br /></td></tr>
<tr class="separator:ace6a963ab7442bf3f29d9ebacdc849ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa9388bc0cffeef445272cc5234b087"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:aaaa9388bc0cffeef445272cc5234b087"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#aaaa9388bc0cffeef445272cc5234b087">GetProperty</a> (const std::string &amp;group_name, const std::string &amp;name) const</td></tr>
<tr class="memdesc:aaaa9388bc0cffeef445272cc5234b087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the typed value for the property (<code>group_name</code>, <code>name</code>) from this set of properties.  <a href="#aaaa9388bc0cffeef445272cc5234b087">More...</a><br /></td></tr>
<tr class="separator:aaaa9388bc0cffeef445272cc5234b087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e2f97729521683e525ce0090c6c9b0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#a73e2f97729521683e525ce0090c6c9b0">GetPropertyAbstract</a> (const std::string &amp;group_name, const std::string &amp;name) const</td></tr>
<tr class="memdesc:a73e2f97729521683e525ce0090c6c9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the type-erased value for the property (<code>group_name</code>, <code>name</code>) from this set of properties.  <a href="#a73e2f97729521683e525ce0090c6c9b0">More...</a><br /></td></tr>
<tr class="separator:a73e2f97729521683e525ce0090c6c9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b425641c9937dea89f553cabba9b186"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a7b425641c9937dea89f553cabba9b186"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#a7b425641c9937dea89f553cabba9b186">GetPropertyOrDefault</a> (const std::string &amp;group_name, const std::string &amp;name, ValueType default_value) const</td></tr>
<tr class="memdesc:a7b425641c9937dea89f553cabba9b186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the typed value for the property (<code>group_name</code>, <code>name</code>) from the set of properties (if it exists), otherwise returns the given default value.  <a href="#a7b425641c9937dea89f553cabba9b186">More...</a><br /></td></tr>
<tr class="separator:a7b425641c9937dea89f553cabba9b186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221c35662fe3549e2fd6ca5457d70c0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#a221c35662fe3549e2fd6ca5457d70c0c">RemoveProperty</a> (const std::string &amp;group_name, const std::string &amp;name)</td></tr>
<tr class="memdesc:a221c35662fe3549e2fd6ca5457d70c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the (<code>group_name</code>, <code>name</code>) property (if it exists).  <a href="#a221c35662fe3549e2fd6ca5457d70c0c">More...</a><br /></td></tr>
<tr class="separator:a221c35662fe3549e2fd6ca5457d70c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa9fbb361a1fc07d3f00cd10905d27e23"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#aa9fbb361a1fc07d3f00cd10905d27e23">default_group_name</a> ()</td></tr>
<tr class="memdesc:aa9fbb361a1fc07d3f00cd10905d27e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default group name.  <a href="#aa9fbb361a1fc07d3f00cd10905d27e23">More...</a><br /></td></tr>
<tr class="separator:aa9fbb361a1fc07d3f00cd10905d27e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad86db1a9e167f7f17c42d65edca84383"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#ad86db1a9e167f7f17c42d65edca84383">GeometryProperties</a> ()</td></tr>
<tr class="memdesc:ad86db1a9e167f7f17c42d65edca84383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a property set with the default group.  <a href="#ad86db1a9e167f7f17c42d65edca84383">More...</a><br /></td></tr>
<tr class="separator:ad86db1a9e167f7f17c42d65edca84383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:a985605d92e6d5ae06e51f2b3ad109c14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#a985605d92e6d5ae06e51f2b3ad109c14">GeometryProperties</a> (const <a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a> &amp;)=default</td></tr>
<tr class="separator:a985605d92e6d5ae06e51f2b3ad109c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712ab4f9a8262cd128edc096ee17beca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#a712ab4f9a8262cd128edc096ee17beca">operator=</a> (const <a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a> &amp;)=default</td></tr>
<tr class="separator:a712ab4f9a8262cd128edc096ee17beca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32edcdb0f6338ecb9342d79d03035bcc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#a32edcdb0f6338ecb9342d79d03035bcc">GeometryProperties</a> (<a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a32edcdb0f6338ecb9342d79d03035bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9b1631582bac387f68c1cf684b1679"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#a0b9b1631582bac387f68c1cf684b1679">operator=</a> (<a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a0b9b1631582bac387f68c1cf684b1679"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a672f8cee5f2aea664b41091816e8b6b1"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#a672f8cee5f2aea664b41091816e8b6b1">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a> &amp;props)</td></tr>
<tr class="separator:a672f8cee5f2aea664b41091816e8b6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1094a6990819e25b5d259c0d35affe66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1094a6990819e25b5d259c0d35affe66">&#9670;&nbsp;</a></span>Group</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#a1094a6990819e25b5d259c0d35affe66">Group</a> =  std::unordered_map&lt;std::string, <a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt;<a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The properties for a single group as a property name-value map. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a94116c2953fa02aea8b4398148685e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94116c2953fa02aea8b4398148685e82">&#9670;&nbsp;</a></span>~GeometryProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad86db1a9e167f7f17c42d65edca84383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86db1a9e167f7f17c42d65edca84383">&#9670;&nbsp;</a></span>GeometryProperties() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a property set with the default group. </p>
<p>Only invoked by final subclasses. </p>

</div>
</div>
<a id="a985605d92e6d5ae06e51f2b3ad109c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985605d92e6d5ae06e51f2b3ad109c14">&#9670;&nbsp;</a></span>GeometryProperties() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32edcdb0f6338ecb9342d79d03035bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32edcdb0f6338ecb9342d79d03035bcc">&#9670;&nbsp;</a></span>GeometryProperties() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5c36bb4c5566a8316bc8b52601e49d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c36bb4c5566a8316bc8b52601e49d27">&#9670;&nbsp;</a></span>AddProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the named property (<code>group_name</code>, <code>name</code>) with the given <code>value</code>. </p>
<p>Adds the group if it doesn't already exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_name</td><td>The group name. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the property &ndash; must be unique in the group. </td></tr>
    <tr><td class="paramname">value</td><td>The value to assign to the property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the property already exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The type of data to store with the attribute &ndash; must be copy constructible or cloneable (see <a class="el" href="classdrake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">Value</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa944be9be3bd2cdefdad5f3d56648408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa944be9be3bd2cdefdad5f3d56648408">&#9670;&nbsp;</a></span>AddPropertyAbstract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddPropertyAbstract </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the named property (<code>group_name</code>, <code>name</code>) with the given type-erased <code>value</code>. </p>
<p>Adds the group if it doesn't already exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_name</td><td>The group name. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the property &ndash; must be unique in the group. </td></tr>
    <tr><td class="paramname">value</td><td>The value to assign to the property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the property already exists. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9fbb361a1fc07d3f00cd10905d27e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9fbb361a1fc07d3f00cd10905d27e23">&#9670;&nbsp;</a></span>default_group_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; default_group_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the default group name. </p>
<p>There is no guarantee as to <em>what</em> string corresponds to the default group. Therefore it should always be accessed via this method. </p>

</div>
</div>
<a id="a228de14aac3d5f432178df9d0cc8aa43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a228de14aac3d5f432178df9d0cc8aa43">&#9670;&nbsp;</a></span>GetGroupNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;std::string&gt; GetGroupNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all of the defined group names. </p>

</div>
</div>
<a id="a1faa50f8c98b05093c22e7d1ce5ee630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1faa50f8c98b05093c22e7d1ce5ee630">&#9670;&nbsp;</a></span>GetPropertiesInGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html#a1094a6990819e25b5d259c0d35affe66">Group</a>&amp; GetPropertiesInGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the indicated property group. </p>
<p>The returned group is valid for as long as this instance. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there is no group with the given name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaaa9388bc0cffeef445272cc5234b087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa9388bc0cffeef445272cc5234b087">&#9670;&nbsp;</a></span>GetProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) GetProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the typed value for the property (<code>group_name</code>, <code>name</code>) from this set of properties. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_name</td><td>The name of the group to which the property belongs. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the desired property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if a) the group name is invalid, b) the property name is invalid, or c) the property type is not that specified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The expected type of the desired property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const ValueType&amp; of stored value. If ValueType is Eigen::Vector4d, the return type will be a copy translated from <a class="el" href="classdrake_1_1geometry_1_1_rgba.html" title="Defines RGBA (red, green, blue, alpha) values on the range [0, 1].">Rgba</a>. </dd></dl>

</div>
</div>
<a id="a73e2f97729521683e525ce0090c6c9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e2f97729521683e525ce0090c6c9b0">&#9670;&nbsp;</a></span>GetPropertyAbstract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a>&amp; GetPropertyAbstract </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the type-erased value for the property (<code>group_name</code>, <code>name</code>) from this set of properties. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_name</td><td>The name of the group to which the property belongs. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the desired property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if a) the group name is invalid, or b) the property name is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b425641c9937dea89f553cabba9b186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b425641c9937dea89f553cabba9b186">&#9670;&nbsp;</a></span>GetPropertyOrDefault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ValueType GetPropertyOrDefault </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the typed value for the property (<code>group_name</code>, <code>name</code>) from the set of properties (if it exists), otherwise returns the given default value. </p>
<p>The given <code>default_value</code> is returned only if the property is missing. If the property exists and is of a <em>different</em> type, an exception will be thrown. If it is of the expected type, the stored value will be returned.</p>
<p>Generally, it is unnecessary to explicitly declare the <code>ValueType</code> of the property value; it will be inferred from the provided default value. Sometimes it is convenient to provide the default value in a form that can be implicitly converted to the final type. In that case, it is necessary to explicitly declare the desired <code>ValueType</code> so the compiler does not infer the wrong type, e.g.:</p>
<div class="fragment"><div class="line"><span class="comment">// Note the _integer_ value as default value.</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> my_value = properties.GetPropertyOrDefault&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;g&quot;</span>, <span class="stringliteral">&quot;p&quot;</span>, 2);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_name</td><td>The name of the group to which the property belongs. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the desired property. </td></tr>
    <tr><td class="paramname">default_value</td><td>The alternate value to return if the property cannot be acquired. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if a property of the given name exists but is not of <code>ValueType</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4a46edb0e7b07e1aa49ddb946ddecc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a46edb0e7b07e1aa49ddb946ddecc0">&#9670;&nbsp;</a></span>HasGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports if the given named group is part of this property set. </p>

</div>
</div>
<a id="ace6a963ab7442bf3f29d9ebacdc849ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6a963ab7442bf3f29d9ebacdc849ca">&#9670;&nbsp;</a></span>HasProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports if the property (<code>group_name</code>, <code>name</code>) exists in the group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_name</td><td>The name of the group to which the tested property should belong. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the property under question. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff the group exists and a property with the given <code>name</code> exists in that group. </dd></dl>

</div>
</div>
<a id="ae3d6aafba237b9251e8fabd0dbe76528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d6aafba237b9251e8fabd0dbe76528">&#9670;&nbsp;</a></span>num_groups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_groups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the number of property groups in this set. </p>

</div>
</div>
<a id="a0b9b1631582bac387f68c1cf684b1679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b9b1631582bac387f68c1cf684b1679">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a712ab4f9a8262cd128edc096ee17beca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712ab4f9a8262cd128edc096ee17beca">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a221c35662fe3549e2fd6ca5457d70c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221c35662fe3549e2fd6ca5457d70c0c">&#9670;&nbsp;</a></span>RemoveProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RemoveProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the (<code>group_name</code>, <code>name</code>) property (if it exists). </p>
<p>Upon completion the property will not be in the set. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the property existed prior to the call. </dd></dl>

</div>
</div>
<a id="ad519098cc972ba24c36302f3290d2b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad519098cc972ba24c36302f3290d2b06">&#9670;&nbsp;</a></span>UpdateProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UpdateProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the named property (<code>group_name</code>, <code>name</code>) with the given <code>value</code>. </p>
<p>If the property doesn't already exist, it is equivalent to calling <code>AddProperty</code>. If the property does exist, its value (which must have the same type as <code>value</code>) will be replaced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_name</td><td>The group name. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the property &ndash; must be unique in the group. </td></tr>
    <tr><td class="paramname">value</td><td>The value to assign to the property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the property exists with a different type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The type of data to store with the attribute &ndash; must be copy constructible or cloneable (see <a class="el" href="classdrake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">Value</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9c4c3542d53e235c4624e4f753692f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c4c3542d53e235c4624e4f753692f4">&#9670;&nbsp;</a></span>UpdatePropertyAbstract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UpdatePropertyAbstract </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_abstract_value.html">AbstractValue</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the named property (<code>group_name</code>, <code>name</code>) with the given type-erased <code>value</code>. </p>
<p>If the property doesn't already exist, it is equivalent to calling <code>AddPropertyAbstract</code>. If the property does exist, its value (which must have the same type as <code>value</code>) will be replaced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group_name</td><td>The group name. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the property &ndash; must be unique in the group. </td></tr>
    <tr><td class="paramname">value</td><td>The value to assign to the property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the property exists with a different type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a672f8cee5f2aea664b41091816e8b6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672f8cee5f2aea664b41091816e8b6b1">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>props</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/geometry/<a class="el" href="geometry__properties_8h.html">geometry_properties.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1geometry.html">geometry</a></li><li class="navelem"><a class="el" href="classdrake_1_1geometry_1_1_geometry_properties.html">GeometryProperties</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
