<!-- HTML header for doxygen 1.14.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: GraphOfConvexSets Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html','','classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">GraphOfConvexSets Class Reference<div class="ingroups"><a class="el" href="group__geometry.html">Geometric Representations</a> &#124; <a class="el" href="group__solvers.html">Formulating and Solving Optimization Problems</a> &raquo; <a class="el" href="group__geometry__optimization.html">Geometry Optimization</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html" title="GraphOfConvexSets (GCS) implements the design pattern and optimization problems first introduced in t...">GraphOfConvexSets</a> (GCS) implements the design pattern and optimization problems first introduced in the paper "Shortest Paths in Graphs of Convex Sets". </p>
<p>"Shortest Paths in Graphs of Convex Sets" by Tobia Marcucci, Jack Umenberger, Pablo A. Parrilo, Russ Tedrake. <a href="https://arxiv.org/abs/2101.11565">https://arxiv.org/abs/2101.11565</a></p>
<dl class="section warning"><dt>Warning</dt><dd>This feature is considered to be <b>experimental</b> and may change or be removed at any time, without any deprecation notice ahead of time.</dd></dl>
<p>Each vertex in the graph is associated with a convex set over continuous variables, edges in the graph contain convex costs and constraints on these continuous variables. We can then formulate optimization problems over this graph, such as the shortest path problem where each visit to a vertex also corresponds to selecting an element from the convex set subject to the costs and constraints. Behind the scenes, we construct efficient mixed-integer convex transcriptions of the graph problem using MathematicalProgram. However, we provide the option to solve an often tight convex relaxation of the problem with <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html#a6787cfcca13150e38baf6ec079b36cc6" title="Flag to solve the relaxed version of the problem.">GraphOfConvexSetsOptions::convex_relaxation</a> and employ a cheap rounding stage which solves the convex restriction along potential paths to find a feasible solution to the original problem.</p>
<p>Design note: This class avoids providing any direct access to the MathematicalProgram that it constructs nor to the decision variables / constraints. The users should be able to write constraints against "placeholder" decision variables on the vertices and edges, but these get translated in non-trivial ways to the underlying program.</p>
<p><a class="anchor" id="nonconvex_graph_of_convex_sets"></a><b>Advanced Usage: Guiding Non-convex Optimization with the GraphOfConvexSets</b></p>
<p>Solving a GCS problem using convex relaxation involves two components:</p><ul>
<li><a class="el" href="classdrake_1_1geometry_1_1_convex.html" title="Definition of a convex surface mesh.">Convex</a> Relaxation: The relaxation of the binary variables (edge activations) and perspective operations on the convex cost/constraints leads to a convex problem that considers the graph as a whole.</li>
<li>Rounding: After solving the relaxation, a randomized rounding scheme is applied to obtain a feasible solution for the original problem. We interpret the relaxed flow variables as edge probabilities to guide the maximum likelyhood depth first search from the source to target vertices. Each rounding is calling SolveConvexRestriction.</li>
</ul>
<p>To handle non-convex constraints, one can provide convex surrogates to the relaxation and the true non-convex constraints to the rounding problem. These surrogates approximate the non-convex constraints, making the relaxation solvable as a convex optimization to guide the non-convex rounding. This can be controlled by the <a class="el" href="#a5b9188d435083bda24dd1cb73a7b5d5b" title="Specify the transcription of the optimization problem to which a constraint or cost should be added,...">Transcription</a> enum in the AddConstraint method. We encourage users to provide a strong convex surrogate, when possible, to better approximate the original non-convex problem.</p>
<p>Users can also specify a GCS implicitly, which can be important for very large or infinite graphs, by deriving from <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_implicit_graph_of_convex_sets.html" title="A base class to define the interface to an implicit graph of convex sets.">ImplicitGraphOfConvexSets</a>. </p>
</div>
<p><code>#include &lt;drake/geometry/optimization/graph_of_convex_sets.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:Edge" id="r_Edge"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An edge in the graph connects between vertex <span class="tt">u</span> and vertex <span class="tt">v</span>.  <a href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html#details">More...</a><br /></td></tr>
<tr class="memitem:Vertex" id="r_Vertex"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each vertex in the graph has a corresponding <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html" title="Abstract base class for defining a convex set.">ConvexSet</a>, and a std::string name.  <a href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5b9188d435083bda24dd1cb73a7b5d5b" id="r_a5b9188d435083bda24dd1cb73a7b5d5b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b9188d435083bda24dd1cb73a7b5d5b">Transcription</a> { <a class="el" href="#a5b9188d435083bda24dd1cb73a7b5d5ba058f4d93de65b4c9dd778be760beaa90">kMIP</a>
, <a class="el" href="#a5b9188d435083bda24dd1cb73a7b5d5baf0eaaa21b3713d009fbdbbcfc1f8b9b8">kRelaxation</a>
, <a class="el" href="#a5b9188d435083bda24dd1cb73a7b5d5bae6e3b13561e5aed0294cf5ca5765dd02">kRestriction</a>
 }</td></tr>
<tr class="memdesc:a5b9188d435083bda24dd1cb73a7b5d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the transcription of the optimization problem to which a constraint or cost should be added, or from which they should be retrieved.  <a href="#a5b9188d435083bda24dd1cb73a7b5d5b">More...</a><br /></td></tr>
<tr class="memitem:a40866c7a0f18b425f096b14788af5301" id="r_a40866c7a0f18b425f096b14788af5301"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40866c7a0f18b425f096b14788af5301">VertexId</a> = <a class="el" href="classdrake_1_1_identifier.html">Identifier</a>&lt;class VertexTag&gt;</td></tr>
<tr class="memitem:a4df1a3580f1ae7e96903c7b3f7b00974" id="r_a4df1a3580f1ae7e96903c7b3f7b00974"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4df1a3580f1ae7e96903c7b3f7b00974">EdgeId</a> = <a class="el" href="classdrake_1_1_identifier.html">Identifier</a>&lt;class EdgeTag&gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad8bcf2497fef00ed8a3fa1bc7458c365" id="r_ad8bcf2497fef00ed8a3fa1bc7458c365"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8bcf2497fef00ed8a3fa1bc7458c365">GraphOfConvexSets</a> ()=default</td></tr>
<tr class="memdesc:ad8bcf2497fef00ed8a3fa1bc7458c365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty graph.  <br /></td></tr>
<tr class="memitem:a2b683685b055f28b9d4eff7e4c191025" id="r_a2b683685b055f28b9d4eff7e4c191025"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b683685b055f28b9d4eff7e4c191025">~GraphOfConvexSets</a> ()</td></tr>
<tr class="memitem:ae7d6ffac8fecf15e356b5c3fa3f98ea8" id="r_ae7d6ffac8fecf15e356b5c3fa3f98ea8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html">GraphOfConvexSets</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7d6ffac8fecf15e356b5c3fa3f98ea8">Clone</a> () const</td></tr>
<tr class="memdesc:ae7d6ffac8fecf15e356b5c3fa3f98ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a deep copy of this graph.  <br /></td></tr>
<tr class="memitem:a8a38ae600b614e18dc8b409d1c29de9d" id="r_a8a38ae600b614e18dc8b409d1c29de9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a38ae600b614e18dc8b409d1c29de9d">AddVertex</a> (const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a> &amp;set, std::string name=&quot;&quot;)</td></tr>
<tr class="memdesc:a8a38ae600b614e18dc8b409d1c29de9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a vertex to the graph.  <br /></td></tr>
<tr class="memitem:a5bfa15b2aa6fc1490803df6addd1b5e3" id="r_a5bfa15b2aa6fc1490803df6addd1b5e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bfa15b2aa6fc1490803df6addd1b5e3">AddVertexFromTemplate</a> (const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> &amp;template_vertex)</td></tr>
<tr class="memdesc:a5bfa15b2aa6fc1490803df6addd1b5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new vertex to the graph (and assigns a new unique <a class="el" href="#a40866c7a0f18b425f096b14788af5301">VertexId</a>) by taking the name, costs, and constraints (but not any edges) from <span class="tt">template_vertex</span>.  <br /></td></tr>
<tr class="memitem:a4002f4a460d919a5f8e0281bcdbc76ab" id="r_a4002f4a460d919a5f8e0281bcdbc76ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4002f4a460d919a5f8e0281bcdbc76ab">AddEdge</a> (<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> *u, <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> *v, std::string name=&quot;&quot;)</td></tr>
<tr class="memdesc:a4002f4a460d919a5f8e0281bcdbc76ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an edge to the graph from <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html" title="Each vertex in the graph has a corresponding ConvexSet, and a std::string name.">Vertex</a> <code class="param">u</code> to <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html" title="Each vertex in the graph has a corresponding ConvexSet, and a std::string name.">Vertex</a> <code class="param">v</code>.  <br /></td></tr>
<tr class="memitem:afaf6d7776abab0acb11a8ebd26d9984d" id="r_afaf6d7776abab0acb11a8ebd26d9984d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afaf6d7776abab0acb11a8ebd26d9984d">AddEdgeFromTemplate</a> (<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> *u, <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> *v, const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> &amp;template_edge)</td></tr>
<tr class="memdesc:afaf6d7776abab0acb11a8ebd26d9984d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an edge to the graph from <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html" title="Each vertex in the graph has a corresponding ConvexSet, and a std::string name.">Vertex</a> <span class="tt">u</span> to <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html" title="Each vertex in the graph has a corresponding ConvexSet, and a std::string name.">Vertex</a> <span class="tt">v</span> (and assigns a new unique <a class="el" href="#a4df1a3580f1ae7e96903c7b3f7b00974">EdgeId</a>), by taking the name, costs, and constraints from <span class="tt">template_edge</span>.  <br /></td></tr>
<tr class="memitem:ac85fd0ac4471b4d8119f0640115de0ee" id="r_ac85fd0ac4471b4d8119f0640115de0ee"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac85fd0ac4471b4d8119f0640115de0ee">GetVertexByName</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:ac85fd0ac4471b4d8119f0640115de0ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first vertex (by the order added to <span class="tt">this</span>) with the given name, or nullptr if no such vertex exists.  <br /></td></tr>
<tr class="memitem:a273abff5531d11c634320c3d5881e00c" id="r_a273abff5531d11c634320c3d5881e00c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a273abff5531d11c634320c3d5881e00c">GetMutableVertexByName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a273abff5531d11c634320c3d5881e00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first vertex (by the order added to <span class="tt">this</span>) with the given name, or nullptr if no such vertex exists.  <br /></td></tr>
<tr class="memitem:a7450bb1cb7e92eea712bc3e45b4b6fe3" id="r_a7450bb1cb7e92eea712bc3e45b4b6fe3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7450bb1cb7e92eea712bc3e45b4b6fe3">GetEdgeByName</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a7450bb1cb7e92eea712bc3e45b4b6fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first edge (by the order added to <span class="tt">this</span>) with the given name, or nullptr if no such edge exists.  <br /></td></tr>
<tr class="memitem:a8f410011b7134f2c68050a7a12ea1131" id="r_a8f410011b7134f2c68050a7a12ea1131"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f410011b7134f2c68050a7a12ea1131">GetMutableEdgeByName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a8f410011b7134f2c68050a7a12ea1131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first edge (by the order added to <span class="tt">this</span>) with the given name, or nullptr if no such edge exists.  <br /></td></tr>
<tr class="memitem:a219e082fcdebc032744ff53102dc0e1f" id="r_a219e082fcdebc032744ff53102dc0e1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a219e082fcdebc032744ff53102dc0e1f">RemoveVertex</a> (<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> *vertex)</td></tr>
<tr class="memdesc:a219e082fcdebc032744ff53102dc0e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes vertex <code class="param">vertex</code> from the graph as well as any edges from or to the vertex.  <br /></td></tr>
<tr class="memitem:a4a8e888889d95b9ad42a70d3eff08801" id="r_a4a8e888889d95b9ad42a70d3eff08801"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a8e888889d95b9ad42a70d3eff08801">RemoveEdge</a> (<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> *edge)</td></tr>
<tr class="memdesc:a4a8e888889d95b9ad42a70d3eff08801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes edge <code class="param">edge</code> from the graph.  <br /></td></tr>
<tr class="memitem:a319e621fc359dd8daad48247f95b12fa" id="r_a319e621fc359dd8daad48247f95b12fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a319e621fc359dd8daad48247f95b12fa">num_vertices</a> () const</td></tr>
<tr class="memitem:a398b8f00a51ced684a0759baaf58eadf" id="r_a398b8f00a51ced684a0759baaf58eadf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a398b8f00a51ced684a0759baaf58eadf">num_edges</a> () const</td></tr>
<tr class="memitem:a218ed7a0a0d2964a04fafda73458c910" id="r_a218ed7a0a0d2964a04fafda73458c910"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a218ed7a0a0d2964a04fafda73458c910">Vertices</a> ()</td></tr>
<tr class="memdesc:a218ed7a0a0d2964a04fafda73458c910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns mutable pointers to the vertices stored in the graph.  <br /></td></tr>
<tr class="memitem:a7a4adcc6bb5a3aae888409174ff4bc6b" id="r_a7a4adcc6bb5a3aae888409174ff4bc6b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a4adcc6bb5a3aae888409174ff4bc6b">Vertices</a> () const</td></tr>
<tr class="memdesc:a7a4adcc6bb5a3aae888409174ff4bc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointers to the vertices stored in the graph.  <br /></td></tr>
<tr class="memitem:acb3eddbd1a9f658734ada7fd2d3eb1af" id="r_acb3eddbd1a9f658734ada7fd2d3eb1af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb3eddbd1a9f658734ada7fd2d3eb1af">IsValid</a> (const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> &amp;v) const</td></tr>
<tr class="memdesc:acb3eddbd1a9f658734ada7fd2d3eb1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff <span class="tt">v</span> is registered as a vertex with <span class="tt">this</span>.  <br /></td></tr>
<tr class="memitem:acaea4aad6b2d0bbe789f825dae72ac0c" id="r_acaea4aad6b2d0bbe789f825dae72ac0c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acaea4aad6b2d0bbe789f825dae72ac0c">Edges</a> ()</td></tr>
<tr class="memdesc:acaea4aad6b2d0bbe789f825dae72ac0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns mutable pointers to the edges stored in the graph.  <br /></td></tr>
<tr class="memitem:af159cff804c67cfedb32e7cc522c6aaf" id="r_af159cff804c67cfedb32e7cc522c6aaf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af159cff804c67cfedb32e7cc522c6aaf">Edges</a> () const</td></tr>
<tr class="memdesc:af159cff804c67cfedb32e7cc522c6aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointers to the edges stored in the graph.  <br /></td></tr>
<tr class="memitem:a278d09b44f0001d420492e3898abe7d8" id="r_a278d09b44f0001d420492e3898abe7d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a278d09b44f0001d420492e3898abe7d8">IsValid</a> (const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> &amp;e) const</td></tr>
<tr class="memdesc:a278d09b44f0001d420492e3898abe7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff <span class="tt">e</span> is registered as an edge with <span class="tt">this</span>.  <br /></td></tr>
<tr class="memitem:af3d4326967d3460e7a5fd585dbdde489" id="r_af3d4326967d3460e7a5fd585dbdde489"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3d4326967d3460e7a5fd585dbdde489">ClearAllPhiConstraints</a> ()</td></tr>
<tr class="memdesc:af3d4326967d3460e7a5fd585dbdde489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all constraints added to any edge with AddPhiConstraint.  <br /></td></tr>
<tr class="memitem:a83e922bd80ce2192fb2cee1c9b92f63a" id="r_a83e922bd80ce2192fb2cee1c9b92f63a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83e922bd80ce2192fb2cee1c9b92f63a">GetGraphvizString</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a> *result=nullptr, const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_gcs_graphviz_options.html">GcsGraphvizOptions</a> &amp;options=<a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_gcs_graphviz_options.html">GcsGraphvizOptions</a>(), const std::vector&lt; const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> * &gt; *active_path=nullptr) const</td></tr>
<tr class="memdesc:a83e922bd80ce2192fb2cee1c9b92f63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Graphviz string describing the graph vertices and edges.  <br /></td></tr>
<tr class="memitem:a51f263df76c721f1bbdeb5708bf7df86" id="r_a51f263df76c721f1bbdeb5708bf7df86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51f263df76c721f1bbdeb5708bf7df86">SolveShortestPath</a> (const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> &amp;source, const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> &amp;target, const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html">GraphOfConvexSetsOptions</a> &amp;options=<a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html">GraphOfConvexSetsOptions</a>()) const</td></tr>
<tr class="memdesc:a51f263df76c721f1bbdeb5708bf7df86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formulates and solves the mixed-integer convex formulation of the shortest path problem on the graph, as discussed in detail in.  <br /></td></tr>
<tr class="memitem:a43692d45e7c821c7512607320ea5db55" id="r_a43692d45e7c821c7512607320ea5db55"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43692d45e7c821c7512607320ea5db55">GetSolutionPath</a> (const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> &amp;source, const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> &amp;target, const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a> &amp;result, <a class="el" href="classdouble.html">double</a> tolerance=1e-3) const</td></tr>
<tr class="memdesc:a43692d45e7c821c7512607320ea5db55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a path from <span class="tt">source</span> to <span class="tt">target</span> described by the <span class="tt">result</span> returned by <a class="el" href="#a51f263df76c721f1bbdeb5708bf7df86" title="Formulates and solves the mixed-integer convex formulation of the shortest path problem on the graph,...">SolveShortestPath()</a>, via depth-first search following the largest values of the edge binary variables.  <br /></td></tr>
<tr class="memitem:a979984734376fe12bc5a245cfe08a465" id="r_a979984734376fe12bc5a245cfe08a465"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a979984734376fe12bc5a245cfe08a465">SamplePaths</a> (const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> &amp;source, const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> &amp;target, const std::unordered_map&lt; const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> *, <a class="el" href="classdouble.html">double</a> &gt; &amp;flows, const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html">GraphOfConvexSetsOptions</a> &amp;options) const</td></tr>
<tr class="memdesc:a979984734376fe12bc5a245cfe08a465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples a collection of unique paths from <span class="tt">source</span> to <span class="tt">target</span>, where the flow values (the relaxed binary variables associated with each <span class="tt"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html" title="An edge in the graph connects between vertex u and vertex v.">Edge</a></span>) <span class="tt">flows</span> are interpreted as the probabilities of transitioning an edge.  <br /></td></tr>
<tr class="memitem:aafe267372beefd8b2f4abd8c277375ad" id="r_aafe267372beefd8b2f4abd8c277375ad"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafe267372beefd8b2f4abd8c277375ad">SamplePaths</a> (const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> &amp;source, const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> &amp;target, const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a> &amp;result, const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html">GraphOfConvexSetsOptions</a> &amp;options) const</td></tr>
<tr class="memdesc:aafe267372beefd8b2f4abd8c277375ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples a collection of unique paths from <span class="tt">source</span> to <span class="tt">target</span>, where the flow values (the relaxed binary variables associated with each <span class="tt"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html" title="An edge in the graph connects between vertex u and vertex v.">Edge</a></span>) in <span class="tt">result</span> are interpreted as the probabilities of transitioning an edge.  <br /></td></tr>
<tr class="memitem:a5c50ae80b0c136e138f815b4a83a30d1" id="r_a5c50ae80b0c136e138f815b4a83a30d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c50ae80b0c136e138f815b4a83a30d1">SolveConvexRestriction</a> (const std::vector&lt; const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> * &gt; &amp;active_edges, const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html">GraphOfConvexSetsOptions</a> &amp;options=<a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html">GraphOfConvexSetsOptions</a>(), const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a> *initial_guess=nullptr) const</td></tr>
<tr class="memdesc:a5c50ae80b0c136e138f815b4a83a30d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The non-convexity in a GCS problem comes from the binary variables (phi) associated with the edges being active or inactive in the solution.  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:aee71a4d66e8a29651242b12019c0a30e" id="r_aee71a4d66e8a29651242b12019c0a30e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee71a4d66e8a29651242b12019c0a30e">GraphOfConvexSets</a> (const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html">GraphOfConvexSets</a> &amp;)=delete</td></tr>
<tr class="memitem:aa1fe0a17f0282de0428050aceaa9d2f4" id="r_aa1fe0a17f0282de0428050aceaa9d2f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html">GraphOfConvexSets</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1fe0a17f0282de0428050aceaa9d2f4">operator=</a> (const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html">GraphOfConvexSets</a> &amp;)=delete</td></tr>
<tr class="memitem:ad460ac287eca9cfa4d8fc3e8d8200300" id="r_ad460ac287eca9cfa4d8fc3e8d8200300"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad460ac287eca9cfa4d8fc3e8d8200300">GraphOfConvexSets</a> (<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html">GraphOfConvexSets</a> &amp;&amp;)=delete</td></tr>
<tr class="memitem:a88e1b7bf090eb0d6a87bdd7f6bc408b8" id="r_a88e1b7bf090eb0d6a87bdd7f6bc408b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html">GraphOfConvexSets</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88e1b7bf090eb0d6a87bdd7f6bc408b8">operator=</a> (<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html">GraphOfConvexSets</a> &amp;&amp;)=delete</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-friends" class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa29be4bfd3f94bc063b98bd605ea0893" id="r_aa29be4bfd3f94bc063b98bd605ea0893"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa29be4bfd3f94bc063b98bd605ea0893">PreprocessShortestPathTest</a></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a4df1a3580f1ae7e96903c7b3f7b00974" name="a4df1a3580f1ae7e96903c7b3f7b00974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df1a3580f1ae7e96903c7b3f7b00974">&#9670;&#160;</a></span>EdgeId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4df1a3580f1ae7e96903c7b3f7b00974">EdgeId</a> = <a class="el" href="classdrake_1_1_identifier.html">Identifier</a>&lt;class EdgeTag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a40866c7a0f18b425f096b14788af5301" name="a40866c7a0f18b425f096b14788af5301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40866c7a0f18b425f096b14788af5301">&#9670;&#160;</a></span>VertexId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a40866c7a0f18b425f096b14788af5301">VertexId</a> = <a class="el" href="classdrake_1_1_identifier.html">Identifier</a>&lt;class VertexTag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Member Enumeration Documentation</h2>
<a id="a5b9188d435083bda24dd1cb73a7b5d5b" name="a5b9188d435083bda24dd1cb73a7b5d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9188d435083bda24dd1cb73a7b5d5b">&#9670;&#160;</a></span>Transcription</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a5b9188d435083bda24dd1cb73a7b5d5b">Transcription</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specify the transcription of the optimization problem to which a constraint or cost should be added, or from which they should be retrieved. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5b9188d435083bda24dd1cb73a7b5d5ba058f4d93de65b4c9dd778be760beaa90" name="a5b9188d435083bda24dd1cb73a7b5d5ba058f4d93de65b4c9dd778be760beaa90"></a>kMIP&#160;</td><td class="fielddoc"><p>The mixed integer formulation of the GCS problem. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5b9188d435083bda24dd1cb73a7b5d5baf0eaaa21b3713d009fbdbbcfc1f8b9b8" name="a5b9188d435083bda24dd1cb73a7b5d5baf0eaaa21b3713d009fbdbbcfc1f8b9b8"></a>kRelaxation&#160;</td><td class="fielddoc"><p>The relaxation of the GCS problem. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5b9188d435083bda24dd1cb73a7b5d5bae6e3b13561e5aed0294cf5ca5765dd02" name="a5b9188d435083bda24dd1cb73a7b5d5bae6e3b13561e5aed0294cf5ca5765dd02"></a>kRestriction&#160;</td><td class="fielddoc"><p>The restrction of the GCS problem where the path is fixed. </p>
</td></tr>
</table>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aee71a4d66e8a29651242b12019c0a30e" name="aee71a4d66e8a29651242b12019c0a30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee71a4d66e8a29651242b12019c0a30e">&#9670;&#160;</a></span>GraphOfConvexSets() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html">GraphOfConvexSets</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html">GraphOfConvexSets</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad460ac287eca9cfa4d8fc3e8d8200300" name="ad460ac287eca9cfa4d8fc3e8d8200300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad460ac287eca9cfa4d8fc3e8d8200300">&#9670;&#160;</a></span>GraphOfConvexSets() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html">GraphOfConvexSets</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html">GraphOfConvexSets</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8bcf2497fef00ed8a3fa1bc7458c365" name="ad8bcf2497fef00ed8a3fa1bc7458c365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8bcf2497fef00ed8a3fa1bc7458c365">&#9670;&#160;</a></span>GraphOfConvexSets() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html">GraphOfConvexSets</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty graph. </p>

</div>
</div>
<a id="a2b683685b055f28b9d4eff7e4c191025" name="a2b683685b055f28b9d4eff7e4c191025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b683685b055f28b9d4eff7e4c191025">&#9670;&#160;</a></span>~GraphOfConvexSets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html">GraphOfConvexSets</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a4002f4a460d919a5f8e0281bcdbc76ab" name="a4002f4a460d919a5f8e0281bcdbc76ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4002f4a460d919a5f8e0281bcdbc76ab">&#9670;&#160;</a></span>AddEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> * AddEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> *</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> *</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an edge to the graph from <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html" title="Each vertex in the graph has a corresponding ConvexSet, and a std::string name.">Vertex</a> <code class="param">u</code> to <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html" title="Each vertex in the graph has a corresponding ConvexSet, and a std::string name.">Vertex</a> <code class="param">v</code>. </p>
<p>The vertex references must refer to valid vertices in this graph. If <code class="param">name</code> is empty then a default name will be provided. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">u</span> or <span class="tt">v</span> are not valid vertices in this graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afaf6d7776abab0acb11a8ebd26d9984d" name="afaf6d7776abab0acb11a8ebd26d9984d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf6d7776abab0acb11a8ebd26d9984d">&#9670;&#160;</a></span>AddEdgeFromTemplate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> * AddEdgeFromTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> *</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> *</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>template_edge</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an edge to the graph from <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html" title="Each vertex in the graph has a corresponding ConvexSet, and a std::string name.">Vertex</a> <span class="tt">u</span> to <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html" title="Each vertex in the graph has a corresponding ConvexSet, and a std::string name.">Vertex</a> <span class="tt">v</span> (and assigns a new unique <a class="el" href="#a4df1a3580f1ae7e96903c7b3f7b00974">EdgeId</a>), by taking the name, costs, and constraints from <span class="tt">template_edge</span>. </p>
<p><span class="tt">template_edge</span> does not need to be registered with this GCS instance; this method can be used to effectively copy an <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html" title="An edge in the graph connects between vertex u and vertex v.">Edge</a> from another GCS instance into <span class="tt">this</span>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">u</span> or <span class="tt">v</span> are not valid vertices in this graph. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">u</span> or <span class="tt">v</span> do not match the sizes of the <span class="tt">template_edge.u()</span> and <span class="tt">template_edge.v()</span> vertices. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if edges have slack variables. We can add this support once it's needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a38ae600b614e18dc8b409d1c29de9d" name="a8a38ae600b614e18dc8b409d1c29de9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a38ae600b614e18dc8b409d1c29de9d">&#9670;&#160;</a></span>AddVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> * AddVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>set</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a vertex to the graph. </p>
<p>A copy of <code class="param">set</code> is cloned and stored inside the graph. If <code class="param">name</code> is empty then a default name will be provided. </p>

</div>
</div>
<a id="a5bfa15b2aa6fc1490803df6addd1b5e3" name="a5bfa15b2aa6fc1490803df6addd1b5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bfa15b2aa6fc1490803df6addd1b5e3">&#9670;&#160;</a></span>AddVertexFromTemplate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> * AddVertexFromTemplate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>template_vertex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new vertex to the graph (and assigns a new unique <a class="el" href="#a40866c7a0f18b425f096b14788af5301">VertexId</a>) by taking the name, costs, and constraints (but not any edges) from <span class="tt">template_vertex</span>. </p>
<p><span class="tt">template_vertex</span> does not need to be registered with this GCS instance; this method can be used to effectively copy a <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html" title="Each vertex in the graph has a corresponding ConvexSet, and a std::string name.">Vertex</a> from another GCS instance into <span class="tt">this</span>. </p>

</div>
</div>
<a id="af3d4326967d3460e7a5fd585dbdde489" name="af3d4326967d3460e7a5fd585dbdde489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d4326967d3460e7a5fd585dbdde489">&#9670;&#160;</a></span>ClearAllPhiConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ClearAllPhiConstraints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all constraints added to any edge with AddPhiConstraint. </p>

</div>
</div>
<a id="ae7d6ffac8fecf15e356b5c3fa3f98ea8" name="ae7d6ffac8fecf15e356b5c3fa3f98ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d6ffac8fecf15e356b5c3fa3f98ea8">&#9670;&#160;</a></span>Clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html">GraphOfConvexSets</a> &gt; Clone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a deep copy of this graph. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if edges have slack variables. We can add this support once it's needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acaea4aad6b2d0bbe789f825dae72ac0c" name="acaea4aad6b2d0bbe789f825dae72ac0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaea4aad6b2d0bbe789f825dae72ac0c">&#9670;&#160;</a></span>Edges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> * &gt; Edges </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns mutable pointers to the edges stored in the graph. </p>

</div>
</div>
<a id="af159cff804c67cfedb32e7cc522c6aaf" name="af159cff804c67cfedb32e7cc522c6aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af159cff804c67cfedb32e7cc522c6aaf">&#9670;&#160;</a></span>Edges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> * &gt; Edges </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns pointers to the edges stored in the graph. </p>

</div>
</div>
<a id="a7450bb1cb7e92eea712bc3e45b4b6fe3" name="a7450bb1cb7e92eea712bc3e45b4b6fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7450bb1cb7e92eea712bc3e45b4b6fe3">&#9670;&#160;</a></span>GetEdgeByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> * GetEdgeByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first edge (by the order added to <span class="tt">this</span>) with the given name, or nullptr if no such edge exists. </p>

</div>
</div>
<a id="a83e922bd80ce2192fb2cee1c9b92f63a" name="a83e922bd80ce2192fb2cee1c9b92f63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e922bd80ce2192fb2cee1c9b92f63a">&#9670;&#160;</a></span>GetGraphvizString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string GetGraphvizString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a> *</td>          <td class="paramname"><span class="paramname"><em>result</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_gcs_graphviz_options.html">GcsGraphvizOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_gcs_graphviz_options.html">GcsGraphvizOptions</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>active_path</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a Graphviz string describing the graph vertices and edges. </p>
<p>If <span class="tt">result</span> is supplied, then the graph will be annotated with the solution values, according to <span class="tt">options</span>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the optional result from a solver. </td></tr>
    <tr><td class="paramname">options</td><td>the struct containing various options for visualization. </td></tr>
    <tr><td class="paramname">active_path</td><td>optionally highlights a given path in the graph. The path is displayed as dashed edges in red, displayed in addition to the original graph edges. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f410011b7134f2c68050a7a12ea1131" name="a8f410011b7134f2c68050a7a12ea1131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f410011b7134f2c68050a7a12ea1131">&#9670;&#160;</a></span>GetMutableEdgeByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> * GetMutableEdgeByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first edge (by the order added to <span class="tt">this</span>) with the given name, or nullptr if no such edge exists. </p>

</div>
</div>
<a id="a273abff5531d11c634320c3d5881e00c" name="a273abff5531d11c634320c3d5881e00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273abff5531d11c634320c3d5881e00c">&#9670;&#160;</a></span>GetMutableVertexByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> * GetMutableVertexByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first vertex (by the order added to <span class="tt">this</span>) with the given name, or nullptr if no such vertex exists. </p>

</div>
</div>
<a id="a43692d45e7c821c7512607320ea5db55" name="a43692d45e7c821c7512607320ea5db55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43692d45e7c821c7512607320ea5db55">&#9670;&#160;</a></span>GetSolutionPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> * &gt; GetSolutionPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-3</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a path from <span class="tt">source</span> to <span class="tt">target</span> described by the <span class="tt">result</span> returned by <a class="el" href="#a51f263df76c721f1bbdeb5708bf7df86" title="Formulates and solves the mixed-integer convex formulation of the shortest path problem on the graph,...">SolveShortestPath()</a>, via depth-first search following the largest values of the edge binary variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tolerance</td><td>defines the threshold for checking the integrality conditions of the binary variables for each edge. <span class="tt">tolerance</span> = 0 would demand that the binary variables are exactly 1 for the edges on the path. <span class="tt">tolerance</span> = 1 would allow the binary variables to be any value in [0, 1]. The default value is 1e-3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if !result.is_success() or no path from <span class="tt">source</span> to <span class="tt">target</span> can be found in the solution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac85fd0ac4471b4d8119f0640115de0ee" name="ac85fd0ac4471b4d8119f0640115de0ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85fd0ac4471b4d8119f0640115de0ee">&#9670;&#160;</a></span>GetVertexByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> * GetVertexByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first vertex (by the order added to <span class="tt">this</span>) with the given name, or nullptr if no such vertex exists. </p>

</div>
</div>
<a id="a278d09b44f0001d420492e3898abe7d8" name="a278d09b44f0001d420492e3898abe7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278d09b44f0001d420492e3898abe7d8">&#9670;&#160;</a></span>IsValid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff <span class="tt">e</span> is registered as an edge with <span class="tt">this</span>. </p>

</div>
</div>
<a id="acb3eddbd1a9f658734ada7fd2d3eb1af" name="acb3eddbd1a9f658734ada7fd2d3eb1af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3eddbd1a9f658734ada7fd2d3eb1af">&#9670;&#160;</a></span>IsValid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff <span class="tt">v</span> is registered as a vertex with <span class="tt">this</span>. </p>

</div>
</div>
<a id="a398b8f00a51ced684a0759baaf58eadf" name="a398b8f00a51ced684a0759baaf58eadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398b8f00a51ced684a0759baaf58eadf">&#9670;&#160;</a></span>num_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int num_edges </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a319e621fc359dd8daad48247f95b12fa" name="a319e621fc359dd8daad48247f95b12fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319e621fc359dd8daad48247f95b12fa">&#9670;&#160;</a></span>num_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int num_vertices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1fe0a17f0282de0428050aceaa9d2f4" name="aa1fe0a17f0282de0428050aceaa9d2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1fe0a17f0282de0428050aceaa9d2f4">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html">GraphOfConvexSets</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html">GraphOfConvexSets</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a88e1b7bf090eb0d6a87bdd7f6bc408b8" name="a88e1b7bf090eb0d6a87bdd7f6bc408b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e1b7bf090eb0d6a87bdd7f6bc408b8">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html">GraphOfConvexSets</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html">GraphOfConvexSets</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a8e888889d95b9ad42a70d3eff08801" name="a4a8e888889d95b9ad42a70d3eff08801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8e888889d95b9ad42a70d3eff08801">&#9670;&#160;</a></span>RemoveEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RemoveEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> *</td>          <td class="paramname"><span class="paramname"><em>edge</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes edge <code class="param">edge</code> from the graph. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The edge must be part of the graph. </dd></dl>

</div>
</div>
<a id="a219e082fcdebc032744ff53102dc0e1f" name="a219e082fcdebc032744ff53102dc0e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219e082fcdebc032744ff53102dc0e1f">&#9670;&#160;</a></span>RemoveVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RemoveVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> *</td>          <td class="paramname"><span class="paramname"><em>vertex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes vertex <code class="param">vertex</code> from the graph as well as any edges from or to the vertex. </p>
<p>Runtime is O(nₑ) where nₑ is the number of edges connected to <code class="param">vertex</code> </p><dl class="section pre"><dt>Precondition</dt><dd>The vertex must be part of the graph. </dd></dl>

</div>
</div>
<a id="aafe267372beefd8b2f4abd8c277375ad" name="aafe267372beefd8b2f4abd8c277375ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe267372beefd8b2f4abd8c277375ad">&#9670;&#160;</a></span>SamplePaths() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> * &gt; &gt; SamplePaths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html">GraphOfConvexSetsOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Samples a collection of unique paths from <span class="tt">source</span> to <span class="tt">target</span>, where the flow values (the relaxed binary variables associated with each <span class="tt"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html" title="An edge in the graph connects between vertex u and vertex v.">Edge</a></span>) in <span class="tt">result</span> are interpreted as the probabilities of transitioning an edge. </p>
<p>The returned paths are guaranteed to be unique, and the number of returned paths can be 0 if no paths are found. This function implements the first part of the rounding scheme put forth in Section 4.2 of "Motion Planning around
Obstacles with Convex Optimization": <a href="https://arxiv.org/abs/2205.04422">https://arxiv.org/abs/2205.04422</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>specifies the source vertex. </td></tr>
    <tr><td class="paramname">target</td><td>specifies the target vertex. </td></tr>
    <tr><td class="paramname">options</td><td>include all settings for sampling the paths. Specifically, the behavior of this function is determined through <span class="tt">options.rounding_seed</span>, <span class="tt">options.max_rounded_paths</span>, <span class="tt">options.max_rounding_trials</span>, and <span class="tt">options.flow_tolerance</span>, as described in <span class="tt"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html">GraphOfConvexSetsOptions</a></span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of paths, where each path is a vector of <span class="tt"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html" title="An edge in the graph connects between vertex u and vertex v.">Edge</a></span>s. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if options.max_rounded_path &lt; 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a979984734376fe12bc5a245cfe08a465" name="a979984734376fe12bc5a245cfe08a465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979984734376fe12bc5a245cfe08a465">&#9670;&#160;</a></span>SamplePaths() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> * &gt; &gt; SamplePaths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> *, <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>flows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html">GraphOfConvexSetsOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Samples a collection of unique paths from <span class="tt">source</span> to <span class="tt">target</span>, where the flow values (the relaxed binary variables associated with each <span class="tt"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html" title="An edge in the graph connects between vertex u and vertex v.">Edge</a></span>) <span class="tt">flows</span> are interpreted as the probabilities of transitioning an edge. </p>
<p>The returned paths are guaranteed to be unique, and the number of returned paths can be 0 if no paths are found. This function implements the first part of the rounding scheme put forth in Section 4.2 of "Motion Planning around
Obstacles with Convex Optimization": <a href="https://arxiv.org/abs/2205.04422">https://arxiv.org/abs/2205.04422</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>specifies the source vertex. </td></tr>
    <tr><td class="paramname">target</td><td>specifies the target vertex. </td></tr>
    <tr><td class="paramname">flows</td><td>specifies the edge flows, which are interprested as the probability of transition an edge. <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html" title="An edge in the graph connects between vertex u and vertex v.">Edge</a> flows that are not specified are taken to be zero. </td></tr>
    <tr><td class="paramname">options</td><td>include all settings for sampling the paths. Specifically, the behavior of this function is determined through <span class="tt">options.rounding_seed</span>, <span class="tt">options.max_rounded_paths</span>, <span class="tt">options.max_rounding_trials</span>, and <span class="tt">options.flow_tolerance</span>, as described in <span class="tt"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html">GraphOfConvexSetsOptions</a></span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of paths, where each path is a vector of <span class="tt"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html" title="An edge in the graph connects between vertex u and vertex v.">Edge</a></span>s. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if options.max_rounded_path &lt; 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c50ae80b0c136e138f815b4a83a30d1" name="a5c50ae80b0c136e138f815b4a83a30d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c50ae80b0c136e138f815b4a83a30d1">&#9670;&#160;</a></span>SolveConvexRestriction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a> SolveConvexRestriction </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_edge.html">Edge</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>active_edges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html">GraphOfConvexSetsOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html">GraphOfConvexSetsOptions</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a> *</td>          <td class="paramname"><span class="paramname"><em>initial_guess</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The non-convexity in a GCS problem comes from the binary variables (phi) associated with the edges being active or inactive in the solution. </p>
<p>If those binary variables are fixed, then the problem is convex &ndash; this is a so-called "convex restriction" of the original problem.</p>
<p>The convex restriction can often be solved much more efficiently than solving the full GCS problem with additional constraints to fix the binaries; it can be written using less decision variables, and needs only to include the vertices associated with at least one of the active edges. Decision variables for all other convex sets will be set to NaN.</p>
<p>Note that one can specify additional non-convex constraints, which may be not supported by all solvers. In this case, the provided solver will throw an exception.</p>
<p>If an <code class="param">initial_guess</code> is provided, the solution inside this result will be used to set the initial guess for the convex restriction. Typically, this will be the result obtained by solving the convex relaxation.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code class="param">initial_guess</code> does not contain solutions for the decision variables required in this convex restriction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51f263df76c721f1bbdeb5708bf7df86" name="a51f263df76c721f1bbdeb5708bf7df86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f263df76c721f1bbdeb5708bf7df86">&#9670;&#160;</a></span>SolveShortestPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a> SolveShortestPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html">GraphOfConvexSetsOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html">GraphOfConvexSetsOptions</a>()</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Formulates and solves the mixed-integer convex formulation of the shortest path problem on the graph, as discussed in detail in. </p>
<p>"Shortest Paths in Graphs of Convex Sets" by Tobia Marcucci, Jack Umenberger, Pablo A. Parrilo, Russ Tedrake. <a href="https://arxiv.org/abs/2101.11565">https://arxiv.org/abs/2101.11565</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>specifies the source set. The solver will choose any point in that set; to start at a particular continuous state consider adding a <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_point.html" title="A convex set that contains exactly one element.">Point</a> set to the graph and using that as the source. </td></tr>
    <tr><td class="paramname">target</td><td>specifies the target set. The solver will choose any point in that set. </td></tr>
    <tr><td class="paramname">options</td><td>include all settings for solving the shortest path problem. See <span class="tt"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html">GraphOfConvexSetsOptions</a></span> for further details. The following default options will be used if they are not provided in <span class="tt">options</span>:<ul>
<li><span class="tt">options.convex_relaxation = false</span>,</li>
<li><span class="tt">options.max_rounded_paths = 0</span>,</li>
<li><span class="tt">options.preprocessing = false</span>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if any of the costs or constraints in the graph are incompatible with the shortest path formulation or otherwise unsupported. All costs must be non-negative for all values of the continuous variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a218ed7a0a0d2964a04fafda73458c910" name="a218ed7a0a0d2964a04fafda73458c910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218ed7a0a0d2964a04fafda73458c910">&#9670;&#160;</a></span>Vertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> * &gt; Vertices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns mutable pointers to the vertices stored in the graph. </p>

</div>
</div>
<a id="a7a4adcc6bb5a3aae888409174ff4bc6b" name="a7a4adcc6bb5a3aae888409174ff4bc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4adcc6bb5a3aae888409174ff4bc6b">&#9670;&#160;</a></span>Vertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_1_1_vertex.html">Vertex</a> * &gt; Vertices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns pointers to the vertices stored in the graph. </p>

</div>
</div>
<a name="doc-related-members" id="doc-related-members"></a><h2 id="header-doc-related-members" class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="aa29be4bfd3f94bc063b98bd605ea0893" name="aa29be4bfd3f94bc063b98bd605ea0893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa29be4bfd3f94bc063b98bd605ea0893">&#9670;&#160;</a></span>PreprocessShortestPathTest</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class PreprocessShortestPathTest</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/geometry/optimization/<a class="el" href="graph__of__convex__sets_8h.html">graph_of_convex_sets.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1geometry.html">geometry</a></li><li class="navelem"><a href="namespacedrake_1_1geometry_1_1optimization.html">optimization</a></li><li class="navelem"><a href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html">GraphOfConvexSets</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
