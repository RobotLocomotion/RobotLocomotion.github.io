<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: ScalarInitialValueProblem&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
   <td>
    <div id="DDGSearch">
     <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
      <input type="text" name="q" placeholder="Search C++ API only…" />
      <input type="hidden" name="sites" value="drake.mit.edu/doxygen_cxx" />
     </form>
     <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
      <input type="text" name="q" placeholder="Search all of Drake…" />
      <input type="hidden" name="sites" value="drake.mit.edu" />
     </form>
    </div">
   </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1systems_1_1_scalar_initial_value_problem.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdrake_1_1systems_1_1_scalar_initial_value_problem-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ScalarInitialValueProblem&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::systems::ScalarInitialValueProblem&lt; T &gt;</h3>

<p>A thin wrapper of the <a class="el" href="classdrake_1_1systems_1_1_initial_value_problem.html" title="A general initial value problem (or IVP) representation class, that allows evaluating the 𝐱(t; 𝐤) sol...">InitialValueProblem</a> class to provide a simple interface when solving scalar initial value problems i.e. </p>
<p>when evaluating the x(t; 𝐤) solution function to the given ODE dx/dt = f(t, x; 𝐤), where f : t ⨯ x → ℝ , t ∈ ℝ, x ∈ ℝ, 𝐤 ∈ ℝᵐ, along with an initial condition x(t₀; 𝐤) = x₀. The parameter vector 𝐤 allows for generic IVP definitions, which can later be solved for any instance of said vector.</p>
<p>Note the distinction from general initial value problems where f : t ⨯ 𝐱 → ℝⁿ and 𝐱 ∈ ℝⁿ, addressed by the class being wrapped. While every scalar initial value problem could be written in vector form, this wrapper keeps both problem definition and solution in their scalar form with almost zero overhead, leading to clearer code if applicable. Moreover, this scalar form facilitates single-dimensional quadrature using methods for solving initial value problems.</p>
<p>See <a class="el" href="classdrake_1_1systems_1_1_initial_value_problem.html" title="A general initial value problem (or IVP) representation class, that allows evaluating the 𝐱(t; 𝐤) sol...">InitialValueProblem</a> class documentation for information on caching support and dense output usage for improved efficiency in scalar IVP solving.</p>
<p>For further insight into its use, consider the following examples of scalar IVPs:</p>
<ul>
<li>The population growth of an hypothetical bacteria colony is described by dN/dt = r * N. The colony has N₀ subjects at time t₀. In this context, x ≜ N, x₀ ≜ N₀, 𝐤 ≜ [r], dx/dt = f(t, x; 𝐤) = 𝐤₁ * x.</li>
<li>The charge Q stored in the capacitor of a (potentially equivalent) series RC circuit driven by a time varying voltage source E(t) can be described by dQ/dt = (E(t) - Q / Cs) / Rs, where Rs refers to the resistor's resistance and Cs refers to the capacitor's capacitance. In this context, and assuming an initial stored charge Q₀ at time t₀, x ≜ Q, 𝐤 ≜ [Rs, Cs], x₀ ≜ Q₀, dx/dt = f(t, x; 𝐤) = (E(t) - x / 𝐤₂) / 𝐤₁.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default nonsymbolic scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/systems/analysis/scalar_initial_value_problem.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1systems_1_1_scalar_initial_value_problem_1_1_scalar_ode_context.html">ScalarOdeContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of values i.e.  <a href="structdrake_1_1systems_1_1_scalar_initial_value_problem_1_1_scalar_ode_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a677a34d51ed872e958deb90ce676eec5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#a677a34d51ed872e958deb90ce676eec5">ScalarOdeFunction</a> = std::function&lt; T(const T &amp;t, const T &amp;x, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;k)&gt;</td></tr>
<tr class="memdesc:a677a34d51ed872e958deb90ce676eec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar ODE dx/dt = f(t, x; 𝐤) function type.  <a href="#a677a34d51ed872e958deb90ce676eec5">More...</a><br /></td></tr>
<tr class="separator:a677a34d51ed872e958deb90ce676eec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac7affee024d4f08300eda60f2a60f0d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#ac7affee024d4f08300eda60f2a60f0d2">ScalarInitialValueProblem</a> (const <a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#a677a34d51ed872e958deb90ce676eec5">ScalarOdeFunction</a> &amp;scalar_ode_function, const <a class="el" href="structdrake_1_1systems_1_1_scalar_initial_value_problem_1_1_scalar_ode_context.html">ScalarOdeContext</a> &amp;default_values)</td></tr>
<tr class="memdesc:ac7affee024d4f08300eda60f2a60f0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a scalar IVP described by the given <code>scalar_ode_function</code>, using given <code>default_values.t0</code> and <code>default_values.x0</code> as initial conditions, and parameterized with <code>default_values.k</code> by default.  <a href="#ac7affee024d4f08300eda60f2a60f0d2">More...</a><br /></td></tr>
<tr class="separator:ac7affee024d4f08300eda60f2a60f0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91758ed577d1b8cb29a5d333a9027f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#ac91758ed577d1b8cb29a5d333a9027f1">ScalarInitialValueProblem</a> (const <a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#a677a34d51ed872e958deb90ce676eec5">ScalarOdeFunction</a> &amp;scalar_ode_function, const T &amp;x0, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;k=<a class="el" href="namespacedrake.html#acda0b15d77e4c1701d160b17a2cb2ea8">Vector0</a>&lt; T &gt;{})</td></tr>
<tr class="memdesc:ac91758ed577d1b8cb29a5d333a9027f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a scalar IVP described by the given <code>scalar_ode_function</code>, using given <code>x0</code> as initial conditions, and parameterized with <code>k</code>.  <a href="#ac91758ed577d1b8cb29a5d333a9027f1">More...</a><br /></td></tr>
<tr class="separator:ac91758ed577d1b8cb29a5d333a9027f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bb7ace98119838841607ca5d803730"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#a96bb7ace98119838841607ca5d803730">Solve</a> (const T &amp;tf, const <a class="el" href="structdrake_1_1systems_1_1_scalar_initial_value_problem_1_1_scalar_ode_context.html">ScalarOdeContext</a> &amp;values={}) const</td></tr>
<tr class="memdesc:a96bb7ace98119838841607ca5d803730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the IVP for time <code>tf</code>, using the initial time t₀, initial state x₀ and parameter vector 𝐤 present in <code>values</code>, falling back to the ones given on construction if not given.  <a href="#a96bb7ace98119838841607ca5d803730">More...</a><br /></td></tr>
<tr class="separator:a96bb7ace98119838841607ca5d803730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072b01e07598a528f9ad9ec7d4daeebf"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_scalar_dense_output.html">ScalarDenseOutput</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#a072b01e07598a528f9ad9ec7d4daeebf">DenseSolve</a> (const T &amp;tf, const <a class="el" href="structdrake_1_1systems_1_1_scalar_initial_value_problem_1_1_scalar_ode_context.html">ScalarOdeContext</a> &amp;values={}) const</td></tr>
<tr class="memdesc:a072b01e07598a528f9ad9ec7d4daeebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves and yields an approximation of the IVP solution x(t; 𝐤) for the closed time interval between the initial time t₀ and the given final time <code>tf</code>, using initial state x₀ and parameter vector 𝐤 present in <code>values</code> (falling back to the ones given on construction if not given).  <a href="#a072b01e07598a528f9ad9ec7d4daeebf">More...</a><br /></td></tr>
<tr class="separator:a072b01e07598a528f9ad9ec7d4daeebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacb789e3f8f5b136caef88d063b76e9"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#aeacb789e3f8f5b136caef88d063b76e9">Solve</a> (const T &amp;t0, const T &amp;tf) const</td></tr>
<tr class="memdesc:aeacb789e3f8f5b136caef88d063b76e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the IVP from time <code>t0</code> up to time <code>tf</code>, using the initial state 𝐱₀ and parameter vector 𝐤 provided in the constructor.  <a href="#aeacb789e3f8f5b136caef88d063b76e9">More...</a><br /></td></tr>
<tr class="separator:aeacb789e3f8f5b136caef88d063b76e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd53ccea4f088d7f9ce1b1839847cf7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_scalar_dense_output.html">ScalarDenseOutput</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#a5bd53ccea4f088d7f9ce1b1839847cf7">DenseSolve</a> (const T &amp;t0, const T &amp;tf) const</td></tr>
<tr class="memdesc:a5bd53ccea4f088d7f9ce1b1839847cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves and yields an approximation of the IVP solution x(t; 𝐤) for the closed time interval between the initial time <code>t0</code> and the final time <code>tf</code>, using initial state 𝐱₀ and parameter vector 𝐤 provided in the constructor.  <a href="#a5bd53ccea4f088d7f9ce1b1839847cf7">More...</a><br /></td></tr>
<tr class="separator:a5bd53ccea4f088d7f9ce1b1839847cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf92f89ed3fb6ea7acde795d33645a3c"><td class="memTemplParams" colspan="2">template&lt;typename Integrator , typename... Args&gt; </td></tr>
<tr class="memitem:aaf92f89ed3fb6ea7acde795d33645a3c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_integrator.html">Integrator</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#aaf92f89ed3fb6ea7acde795d33645a3c">reset_integrator</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aaf92f89ed3fb6ea7acde795d33645a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the internal integrator instance by in-place construction of the given integrator type.  <a href="#aaf92f89ed3fb6ea7acde795d33645a3c">More...</a><br /></td></tr>
<tr class="separator:aaf92f89ed3fb6ea7acde795d33645a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc3bf152afe75736c6b8b3ecf8cd65e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#adbc3bf152afe75736c6b8b3ecf8cd65e">get_integrator</a> () const</td></tr>
<tr class="memdesc:adbc3bf152afe75736c6b8b3ecf8cd65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to the internal integrator instance.  <a href="#adbc3bf152afe75736c6b8b3ecf8cd65e">More...</a><br /></td></tr>
<tr class="separator:adbc3bf152afe75736c6b8b3ecf8cd65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c4ee8378a24e575a176dfb7d308ae9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#af7c4ee8378a24e575a176dfb7d308ae9">get_mutable_integrator</a> ()</td></tr>
<tr class="memdesc:af7c4ee8378a24e575a176dfb7d308ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a mutable reference to the internal integrator instance.  <a href="#af7c4ee8378a24e575a176dfb7d308ae9">More...</a><br /></td></tr>
<tr class="separator:af7c4ee8378a24e575a176dfb7d308ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:a9e14d71a4415b5bbeb479c4b42712615"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#a9e14d71a4415b5bbeb479c4b42712615">ScalarInitialValueProblem</a> (const <a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a> &amp;)=delete</td></tr>
<tr class="separator:a9e14d71a4415b5bbeb479c4b42712615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af271bb5896ff93bf00fb74143035279e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#af271bb5896ff93bf00fb74143035279e">operator=</a> (const <a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a> &amp;)=delete</td></tr>
<tr class="separator:af271bb5896ff93bf00fb74143035279e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3039082d5cf5d9b4884c666c2e0dd033"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#a3039082d5cf5d9b4884c666c2e0dd033">ScalarInitialValueProblem</a> (<a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a3039082d5cf5d9b4884c666c2e0dd033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87db2601a897d3578d48ef507b455b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#af87db2601a897d3578d48ef507b455b3">operator=</a> (<a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:af87db2601a897d3578d48ef507b455b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a677a34d51ed872e958deb90ce676eec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677a34d51ed872e958deb90ce676eec5">&#9670;&nbsp;</a></span>ScalarOdeFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#a677a34d51ed872e958deb90ce676eec5">ScalarOdeFunction</a> =  std::function&lt;T(const T&amp; t, const T&amp; x, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt;&amp; k)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scalar ODE dx/dt = f(t, x; 𝐤) function type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The independent variable t ∈ ℝ . </td></tr>
    <tr><td class="paramname">x</td><td>The dependent variable x ∈ ℝ . </td></tr>
    <tr><td class="paramname">k</td><td>The parameter vector 𝐤 ∈ ℝᵐ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The derivative dx/dt ∈ ℝ. </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9e14d71a4415b5bbeb479c4b42712615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e14d71a4415b5bbeb479c4b42712615">&#9670;&nbsp;</a></span>ScalarInitialValueProblem() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3039082d5cf5d9b4884c666c2e0dd033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3039082d5cf5d9b4884c666c2e0dd033">&#9670;&nbsp;</a></span>ScalarInitialValueProblem() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7affee024d4f08300eda60f2a60f0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7affee024d4f08300eda60f2a60f0d2">&#9670;&nbsp;</a></span>ScalarInitialValueProblem() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#a677a34d51ed872e958deb90ce676eec5">ScalarOdeFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar_ode_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1systems_1_1_scalar_initial_value_problem_1_1_scalar_ode_context.html">ScalarOdeContext</a> &amp;&#160;</td>
          <td class="paramname"><em>default_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a scalar IVP described by the given <code>scalar_ode_function</code>, using given <code>default_values.t0</code> and <code>default_values.x0</code> as initial conditions, and parameterized with <code>default_values.k</code> by default. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar_ode_function</td><td>The ODE function f(t, x; 𝐤) that describes the state evolution over time. </td></tr>
    <tr><td class="paramname">default_values</td><td>The values specified by default for this IVP, i.e. default initial time t₀ ∈ ℝ and state x₀ ∈ ℝ, and default parameter vector 𝐤 ∈ ℝᵐ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>An initial time <code>default_values.t0</code> is provided. </dd>
<dd>
An initial state <code>default_values.x0</code> is provided. </dd>
<dd>
An parameter vector <code>default_values.k</code> is provided. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if preconditions are not met. (Deprecated.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>ScalarOdeContext is deprecated. Use the constructor that  takes x0, and k as arguments directly. <br />
 This will be removed from Drake on or after 2022-07-01.</dd></dl>

</div>
</div>
<a id="ac91758ed577d1b8cb29a5d333a9027f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91758ed577d1b8cb29a5d333a9027f1">&#9670;&nbsp;</a></span>ScalarInitialValueProblem() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#a677a34d51ed872e958deb90ce676eec5">ScalarOdeFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar_ode_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>k</em> = <code><a class="el" href="namespacedrake.html#acda0b15d77e4c1701d160b17a2cb2ea8">Vector0</a>&lt;&#160;T&#160;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a scalar IVP described by the given <code>scalar_ode_function</code>, using given <code>x0</code> as initial conditions, and parameterized with <code>k</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar_ode_function</td><td>The ODE function f(t, 𝐱; 𝐤) that describes the state evolution over time.</td></tr>
    <tr><td class="paramname">x0</td><td>The initial state 𝐱₀ ∈ ℝ. </td></tr>
    <tr><td class="paramname">k</td><td>The parameter vector 𝐤 ∈ ℝᵐ. By default m=0 (no parameters). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a072b01e07598a528f9ad9ec7d4daeebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072b01e07598a528f9ad9ec7d4daeebf">&#9670;&nbsp;</a></span>DenseSolve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1systems_1_1_scalar_dense_output.html">ScalarDenseOutput</a>&lt;T&gt; &gt; DenseSolve </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1systems_1_1_scalar_initial_value_problem_1_1_scalar_ode_context.html">ScalarOdeContext</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves and yields an approximation of the IVP solution x(t; 𝐤) for the closed time interval between the initial time t₀ and the given final time <code>tf</code>, using initial state x₀ and parameter vector 𝐤 present in <code>values</code> (falling back to the ones given on construction if not given). </p>
<p>To this end, the wrapped <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html" title="An abstract class for an integrator for ODEs and DAEs as represented by a Drake System.">IntegratorBase</a> instance solves this scalar IVP, advancing time and state from t₀ and x₀ = x(t₀) to <code>tf</code> and x(<code>tf</code>), creating a scalar dense output over that [t₀, <code>tf</code>] interval along the way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tf</td><td>The IVP will be solved up to this time. Usually, t₀ &lt; <code>tf</code> as an empty dense output would result if t₀ = <code>tf</code>. </td></tr>
    <tr><td class="paramname">values</td><td>IVP initial conditions and parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A dense approximation to x(t; 𝐤) with x(t₀; 𝐤) = x₀, defined for t₀ ≤ t ≤ tf. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The larger the given <code>tf</code> value is, the larger the approximated interval will be. See documentation of the specific dense output technique in use for reference on performance impact as this interval grows. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>tf</code> must be larger than or equal to the specified initial time t₀ (either given or default). </dd>
<dd>
If given, the dimension of the initial state vector <code>values.x0</code> must match that of the default initial state vector in the default specified values given on construction. </dd>
<dd>
If given, the dimension of the parameter vector <code>values.k</code> must match that of the parameter vector in the default specified values given on construction. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if any of the preconditions is not met. (Deprecated.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>ScalarOdeContext is deprecated. Use DenseSolve(t0, tf). <br />
 This will be removed from Drake on or after 2022-07-01.</dd></dl>

</div>
</div>
<a id="a5bd53ccea4f088d7f9ce1b1839847cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd53ccea4f088d7f9ce1b1839847cf7">&#9670;&nbsp;</a></span>DenseSolve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1systems_1_1_scalar_dense_output.html">ScalarDenseOutput</a>&lt;T&gt; &gt; DenseSolve </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves and yields an approximation of the IVP solution x(t; 𝐤) for the closed time interval between the initial time <code>t0</code> and the final time <code>tf</code>, using initial state 𝐱₀ and parameter vector 𝐤 provided in the constructor. </p>
<p>To this end, the wrapped <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html" title="An abstract class for an integrator for ODEs and DAEs as represented by a Drake System.">IntegratorBase</a> instance solves this IVP, advancing time and state from t₀ and 𝐱₀ = 𝐱(<code>t0</code>) to <code>tf</code> and 𝐱(<code>tf</code>), creating a dense output over that [<code>t0</code>, <code>tf</code>] interval along the way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tf</td><td>The IVP will be solved up to this time, which must be ≥ <code>t0</code>. Usually, <code>t0</code> &lt; <code>tf</code> as an empty dense output would result if <code>t0</code> = <code>tf</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A dense approximation to 𝐱(t; 𝐤) with 𝐱(t0; 𝐤) = 𝐱₀, defined for t0 ≤ t ≤ tf. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The larger the given <code>tf</code> value is, the larger the approximated interval will be. See documentation of the specific dense output technique in use for reference on performance impact as this interval grows. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if t0 &gt; tf. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbc3bf152afe75736c6b8b3ecf8cd65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc3bf152afe75736c6b8b3ecf8cd65e">&#9670;&nbsp;</a></span>get_integrator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a>&lt;T&gt;&amp; get_integrator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a reference to the internal integrator instance. </p>

</div>
</div>
<a id="af7c4ee8378a24e575a176dfb7d308ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c4ee8378a24e575a176dfb7d308ae9">&#9670;&nbsp;</a></span>get_mutable_integrator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a>&lt;T&gt;&amp; get_mutable_integrator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a mutable reference to the internal integrator instance. </p>

</div>
</div>
<a id="af87db2601a897d3578d48ef507b455b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87db2601a897d3578d48ef507b455b3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af271bb5896ff93bf00fb74143035279e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af271bb5896ff93bf00fb74143035279e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf92f89ed3fb6ea7acde795d33645a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf92f89ed3fb6ea7acde795d33645a3c">&#9670;&nbsp;</a></span>reset_integrator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_integrator.html">Integrator</a>* reset_integrator </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the internal integrator instance by in-place construction of the given integrator type. </p>
<p>A usage example is shown below. </p><div class="fragment"><div class="line">scalar_ivp.reset_integrator&lt;RungeKutta2Integrator&lt;T&gt;&gt;(max_step);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The integrator type-specific arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new integrator instance. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classdrake_1_1systems_1_1_integrator.html" title="An integrator for a continuous vector input.">Integrator</a></td><td>The integrator type, which must be an <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html" title="An abstract class for an integrator for ODEs and DAEs as represented by a Drake System.">IntegratorBase</a> subclass. </td></tr>
    <tr><td class="paramname">Args</td><td>The integrator specific argument types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This operation invalidates pointers returned by <a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#adbc3bf152afe75736c6b8b3ecf8cd65e" title="Gets a reference to the internal integrator instance.">ScalarInitialValueProblem::get_integrator()</a> and <a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html#af7c4ee8378a24e575a176dfb7d308ae9" title="Gets a mutable reference to the internal integrator instance.">ScalarInitialValueProblem::get_mutable_integrator()</a>. </dd></dl>

</div>
</div>
<a id="a96bb7ace98119838841607ca5d803730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96bb7ace98119838841607ca5d803730">&#9670;&nbsp;</a></span>Solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T Solve </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1systems_1_1_scalar_initial_value_problem_1_1_scalar_ode_context.html">ScalarOdeContext</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the IVP for time <code>tf</code>, using the initial time t₀, initial state x₀ and parameter vector 𝐤 present in <code>values</code>, falling back to the ones given on construction if not given. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tf</td><td>The IVP will be solved for this time. </td></tr>
    <tr><td class="paramname">values</td><td>IVP initial conditions and parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The IVP solution x(<code>tf</code>; 𝐤) for x(t₀; 𝐤) = x₀. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Given <code>tf</code> must be larger than or equal to the specified initial time t₀ (either given or default). </dd>
<dd>
If given, the dimension of the parameter vector <code>values.k</code> must match that of the parameter vector in the default specified values given on construction. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if any of the preconditions is not met. (Deprecated.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>ScalarOdeContext is deprecated. Use Solve(t0, tf). <br />
 This will be removed from Drake on or after 2022-07-01.</dd></dl>

</div>
</div>
<a id="aeacb789e3f8f5b136caef88d063b76e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeacb789e3f8f5b136caef88d063b76e9">&#9670;&nbsp;</a></span>Solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T Solve </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>tf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the IVP from time <code>t0</code> up to time <code>tf</code>, using the initial state 𝐱₀ and parameter vector 𝐤 provided in the constructor. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if t0 &gt; tf. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/systems/analysis/<a class="el" href="scalar__initial__value__problem_8h.html">scalar_initial_value_problem.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- footer -->
<div id="nav-path" class="navpath">
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1systems.html">systems</a></li><li class="navelem"><a class="el" href="classdrake_1_1systems_1_1_scalar_initial_value_problem.html">ScalarInitialValueProblem</a></li>
  </ul>
</div>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().value = searchBox.searchLabel;
</script>
</body>
</html>
