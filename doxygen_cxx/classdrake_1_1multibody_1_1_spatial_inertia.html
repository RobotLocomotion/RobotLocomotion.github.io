<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: SpatialInertia&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 </div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1multibody_1_1_spatial_inertia.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classdrake_1_1multibody_1_1_spatial_inertia-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SpatialInertia&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::multibody::SpatialInertia&lt; T &gt;</h3>

<p>This class represents the physical concept of a <em>Spatial Inertia</em>. </p>
<p>A spatial inertia (or spatial mass matrix) encapsulates the mass, center of mass, and rotational inertia of the mass distribution of a body or composite body S, where with "composite body" we mean a collection of bodies welded together containing at least one body (throughout this documentation "body" is many times used instead of "composite body" but the same concepts apply to a collection of bodies as well.) A spatial inertia is an element of ℝ⁶ˣ⁶ that is symmetric, and positive semi-definite. It logically consists of <code>3x3</code> sub-matrices arranged like so, [Jain 2010]: </p><pre>
             Spatial mass matrix
          ------------ ------------
       0 |            |            |
       1 |    I_SP    | m p_PScm×  |
       2 |            |            |
          ------------ ------------
       3 |            |            |
       4 | -m p_PScm× |     m Id   |
       5 |            |            |
          ------------ ------------
               Symbol: M
</pre><p> where, with the monogram notation described in <a class="el" href="group__multibody__spatial__inertia.html">Spatial Mass Matrix (Spatial Inertia)</a>, <code>I_SP</code> is the rotational inertia of body or composite body S computed about a point P, m is the mass of this composite body, <code>p_PScm</code> is the position vector from point P to the center of mass <code>Scm</code> of the composite body S with <code>p_PScm×</code> denoting its skew-symmetric cross product matrix (defined such that <code>a× b = a.cross(b)</code>), and <code>Id</code> is the identity matrix in ℝ³ˣ³. See Section 2.1, p. 17 of [Jain 2010]. The logical arrangement as shown above is chosen to be consistent with our logical arrangement for spatial vectors as documented in <a class="el" href="group__multibody__spatial__algebra.html">Spatial Algebra</a> for which the rotational component comes first followed by the translational component.</p>
<p>In typeset material we use the symbol \( [M^{S/P}]_E \) to represent the spatial inertia of a body or composite body S about point P, expressed in frame E. For this inertia, the monogram notation reads <code>M_SP_E</code>. If the point P is fixed to a body B, we write that point as \( B_P \) which appears in code and comments as <code>Bp</code>. So if the body or composite body is B and the about point is <code>Bp</code>, the monogram notation reads <code>M_BBp_E</code>, which can be abbreviated to <code>M_Bp_E</code> since the about point <code>Bp</code> also identifies the body. Common cases are that the about point is the origin <code>Bo</code> of the body, or it's the center of mass <code>Bcm</code> for which the rotational inertia in monogram notation would read as <code>I_Bo_E</code> and <code>I_Bcm_E</code>, respectively. Given <code>M_BP_E</code> ( \([M^{B/P}]_E\)), the rotational inertia of this spatial inertia is <code>I_BP_E</code> ( \([I^{B/P}]_E\)) and the position vector of the center of mass measured from point P and expressed in E is <code>p_PBcm_E</code> ( \([^Pp^{B_{cm}}]_E\)).</p>
<dl class="section note"><dt>Note</dt><dd>This class does not implement any mechanism to track the frame E in which a spatial inertia is expressed or about what point is computed. Methods and operators on this class have no means to determine frame consistency through operations. It is therefore the responsibility of users of this class to keep track of frames in which operations are performed. We suggest doing that using disciplined notation, as described above.</dd>
<dd>
Several methods in this class throw a std::exception for invalid rotational inertia operations in debug releases only. This provides speed in a release build while facilitating debugging in debug builds. In addition, these validity tests are only performed for scalar types for which <a class="el" href="structdrake_1_1scalar__predicate.html#ab6fdcd06e06c892b3492eb6ea8f15be2" title="Whether type is bool.">drake::scalar_predicate&lt;T&gt;::is_bool</a> is <code>true</code>. For instance, validity checks are not performed when T is <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>.</dd>
<dd>
The methods of this class satisfy the "basic exception guarantee": if an exception is thrown, the program will still be in a valid state. Specifically, no resources are leaked, and all objects' invariants are intact. Be aware that <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia.">SpatialInertia</a> objects may contain invalid inertia data in cases where input checking is skipped. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/language/exceptions">https://en.cppreference.com/w/cpp/language/exceptions</a></dd>
<dd>
To create a spatial inertia of a mesh, see <a class="el" href="namespacedrake_1_1multibody.html#a23055924c0c775334973d978ac3c1f54">CalcSpatialInertia</a>(const geometry::TriangleSurfaceMesh&lt;double&gt;&amp; mesh, double density).</dd>
<dd>
To create spatial inertia from most of <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The abstract base class for all shape specifications.">geometry::Shape</a>, see <a class="el" href="namespacedrake_1_1multibody.html#a23055924c0c775334973d978ac3c1f54">CalcSpatialInertia(const geometry::Shape&amp; shape, double density)</a>.</dd>
<dd>
To create spatial inertia for a set of bodies, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a55fcea70d2b81506b1b1d769f2137bf3">MultibodyPlant::CalcSpatialInertia()</a>.</dd></dl>
<ul>
<li>[Jain 2010] Jain, A., 2010. Robot and multibody dynamics: analysis and algorithms. Springer Science &amp; Business Media.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/multibody/tree/spatial_inertia.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6d7aa4145ca54c5ab8e45728648f7c5b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a6d7aa4145ca54c5ab8e45728648f7c5b">SpatialInertia</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_PScm_E, const <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt; &amp;G_SP_E, const bool skip_validity_check=false)</td></tr>
<tr class="memdesc:a6d7aa4145ca54c5ab8e45728648f7c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a spatial inertia for a physical body or composite body S about a point P from a given mass, center of mass and rotational inertia.  <a href="#a6d7aa4145ca54c5ab8e45728648f7c5b">More...</a><br /></td></tr>
<tr class="separator:a6d7aa4145ca54c5ab8e45728648f7c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751136a22e2d0980679dd41429d54c62"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a751136a22e2d0980679dd41429d54c62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a751136a22e2d0980679dd41429d54c62">cast</a> () const</td></tr>
<tr class="memdesc:a751136a22e2d0980679dd41429d54c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new SpatialInertia object templated on <code>Scalar</code> initialized from the value of <code>this</code> spatial inertia.  <a href="#a751136a22e2d0980679dd41429d54c62">More...</a><br /></td></tr>
<tr class="separator:a751136a22e2d0980679dd41429d54c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1664b38f6c4fad624a7ab777c9642a7e"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a1664b38f6c4fad624a7ab777c9642a7e">get_mass</a> () const</td></tr>
<tr class="memdesc:a1664b38f6c4fad624a7ab777c9642a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a constant reference to the mass of this spatial inertia.  <a href="#a1664b38f6c4fad624a7ab777c9642a7e">More...</a><br /></td></tr>
<tr class="separator:a1664b38f6c4fad624a7ab777c9642a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d857a6e2165c421949804eb2afbe7c7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a1d857a6e2165c421949804eb2afbe7c7">get_com</a> () const</td></tr>
<tr class="memdesc:a1d857a6e2165c421949804eb2afbe7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a constant reference to the position vector <code>p_PScm_E</code> from the <em>about point</em> P to the center of mass <code>Scm</code> of the body or composite body S, expressed in frame E.  <a href="#a1d857a6e2165c421949804eb2afbe7c7">More...</a><br /></td></tr>
<tr class="separator:a1d857a6e2165c421949804eb2afbe7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1c2e2b7b334839c460e022d4686f54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a3a1c2e2b7b334839c460e022d4686f54">CalcComMoment</a> () const</td></tr>
<tr class="memdesc:a3a1c2e2b7b334839c460e022d4686f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the center of mass moment vector <code>mass * p_PScm_E</code> given the position vector <code>p_PScm_E</code> from the <em>about point</em> P to the center of mass <code>Scm</code> of the body or composite body S, expressed in frame E.  <a href="#a3a1c2e2b7b334839c460e022d4686f54">More...</a><br /></td></tr>
<tr class="separator:a3a1c2e2b7b334839c460e022d4686f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fbc3778a7090443b7b5102861ebe9a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#aa7fbc3778a7090443b7b5102861ebe9a">get_unit_inertia</a> () const</td></tr>
<tr class="memdesc:aa7fbc3778a7090443b7b5102861ebe9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a constant reference to the unit inertia <code>G_SP_E</code> of this spatial inertia, computed about point P and expressed in frame E.  <a href="#aa7fbc3778a7090443b7b5102861ebe9a">More...</a><br /></td></tr>
<tr class="separator:aa7fbc3778a7090443b7b5102861ebe9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025a1eb3a6fcfd673edc15b7ba85de9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a025a1eb3a6fcfd673edc15b7ba85de9e">CalcRotationalInertia</a> () const</td></tr>
<tr class="memdesc:a025a1eb3a6fcfd673edc15b7ba85de9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rotational inertia <code>I_SP_E = mass * G_SP_E</code> of this spatial inertia, computed about point P and expressed in frame E.  <a href="#a025a1eb3a6fcfd673edc15b7ba85de9e">More...</a><br /></td></tr>
<tr class="separator:a025a1eb3a6fcfd673edc15b7ba85de9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a73339c4b21bba9c3fa975f7a6c4220"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a1a73339c4b21bba9c3fa975f7a6c4220">IsNaN</a> () const</td></tr>
<tr class="memdesc:a1a73339c4b21bba9c3fa975f7a6c4220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if any of the elements in this spatial inertia is NaN and <code>false</code> otherwise.  <a href="#a1a73339c4b21bba9c3fa975f7a6c4220">More...</a><br /></td></tr>
<tr class="separator:a1a73339c4b21bba9c3fa975f7a6c4220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55630ea16dd7fcd906f2c9d9db36bb66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a55630ea16dd7fcd906f2c9d9db36bb66">IsZero</a> () const</td></tr>
<tr class="memdesc:a55630ea16dd7fcd906f2c9d9db36bb66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if all of the elements in this spatial inertia are zero and <code>false</code> otherwise.  <a href="#a55630ea16dd7fcd906f2c9d9db36bb66">More...</a><br /></td></tr>
<tr class="separator:a55630ea16dd7fcd906f2c9d9db36bb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679852e6738fbcf5751ca37c51d2f084"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a679852e6738fbcf5751ca37c51d2f084">IsPhysicallyValid</a> () const</td></tr>
<tr class="memdesc:a679852e6738fbcf5751ca37c51d2f084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a number of checks to verify that this is a physically valid spatial inertia.  <a href="#a679852e6738fbcf5751ca37c51d2f084">More...</a><br /></td></tr>
<tr class="separator:a679852e6738fbcf5751ca37c51d2f084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413ff91e8caf0498a96e5b1e06da9cd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a11f9aa896d31437a219ed19fa944fe20">Matrix6</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a413ff91e8caf0498a96e5b1e06da9cd1">CopyToFullMatrix6</a> () const</td></tr>
<tr class="memdesc:a413ff91e8caf0498a96e5b1e06da9cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy to a full 6x6 matrix representation.  <a href="#a413ff91e8caf0498a96e5b1e06da9cd1">More...</a><br /></td></tr>
<tr class="separator:a413ff91e8caf0498a96e5b1e06da9cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b2415a4b0787515507518d9c0dd4e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a09b2415a4b0787515507518d9c0dd4e5">SetNaN</a> ()</td></tr>
<tr class="memdesc:a09b2415a4b0787515507518d9c0dd4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>this</code> spatial inertia to have NaN entries.  <a href="#a09b2415a4b0787515507518d9c0dd4e5">More...</a><br /></td></tr>
<tr class="separator:a09b2415a4b0787515507518d9c0dd4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09dd10c733d7fcef47041dc724f31ff9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a09dd10c733d7fcef47041dc724f31ff9">operator+=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt; &amp;M_BP_E)</td></tr>
<tr class="memdesc:a09dd10c733d7fcef47041dc724f31ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds in a spatial inertia to <code>this</code> spatial inertia.  <a href="#a09dd10c733d7fcef47041dc724f31ff9">More...</a><br /></td></tr>
<tr class="separator:a09dd10c733d7fcef47041dc724f31ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af397b4c3403d23ab61a128dbeaa1c3aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#af397b4c3403d23ab61a128dbeaa1c3aa">ReExpressInPlace</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;R_AE)</td></tr>
<tr class="memdesc:af397b4c3403d23ab61a128dbeaa1c3aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <code>this</code> spatial inertia <code>M_SP_E</code> for some body or composite body S, taken about a point P and expressed in frame E, this method computes the same inertia re-expressed in another frame A.  <a href="#af397b4c3403d23ab61a128dbeaa1c3aa">More...</a><br /></td></tr>
<tr class="separator:af397b4c3403d23ab61a128dbeaa1c3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45bbc7d0e5521d0d91579645636b7ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#aa45bbc7d0e5521d0d91579645636b7ed">ReExpress</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;R_AE) const</td></tr>
<tr class="memdesc:aa45bbc7d0e5521d0d91579645636b7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <code>this</code> spatial inertia <code>M_SP_E</code> for some body or composite body S, taken about a point P and expressed in frame E, this method computes the same inertia re-expressed in another frame A.  <a href="#aa45bbc7d0e5521d0d91579645636b7ed">More...</a><br /></td></tr>
<tr class="separator:aa45bbc7d0e5521d0d91579645636b7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c4eb50d113f896c897289fa10c3464"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a99c4eb50d113f896c897289fa10c3464">ShiftInPlace</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_PQ_E)</td></tr>
<tr class="memdesc:a99c4eb50d113f896c897289fa10c3464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <code>this</code> spatial inertia <code>M_SP_E</code> for some body or composite body S, computed about point P, and expressed in frame E, this method uses the <em>Parallel Axis Theorem</em> for spatial inertias to compute the same spatial inertia about a new point Q.  <a href="#a99c4eb50d113f896c897289fa10c3464">More...</a><br /></td></tr>
<tr class="separator:a99c4eb50d113f896c897289fa10c3464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f8142e184c3d2f68a4c7f342a6c549"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#ae7f8142e184c3d2f68a4c7f342a6c549">Shift</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_PQ_E) const</td></tr>
<tr class="memdesc:ae7f8142e184c3d2f68a4c7f342a6c549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <code>this</code> spatial inertia <code>M_SP_E</code> for some body or composite body S, computed about point P, and expressed in frame E, this method uses the <em>Parallel Axis Theorem</em> for spatial inertias to compute the same spatial inertia about a new point Q.  <a href="#ae7f8142e184c3d2f68a4c7f342a6c549">More...</a><br /></td></tr>
<tr class="separator:ae7f8142e184c3d2f68a4c7f342a6c549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0afd330ef98eb2418ae915e3a1b024"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_force.html">SpatialForce</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#acd0afd330ef98eb2418ae915e3a1b024">operator *</a> (const <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt; &amp;A_WB_E) const</td></tr>
<tr class="memdesc:acd0afd330ef98eb2418ae915e3a1b024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <code>this</code> spatial inertia <code>M_Bo_E</code> of a body B about its frame origin <code>Bo</code> by the spatial acceleration of the body frame B in a frame W.  <a href="#acd0afd330ef98eb2418ae915e3a1b024">More...</a><br /></td></tr>
<tr class="separator:acd0afd330ef98eb2418ae915e3a1b024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0efcd599640dacc6ef37cf640143fdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_momentum.html">SpatialMomentum</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#ab0efcd599640dacc6ef37cf640143fdc">operator *</a> (const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;V_WBp_E) const</td></tr>
<tr class="memdesc:ab0efcd599640dacc6ef37cf640143fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <code>this</code> spatial inertia <code>M_BP_E</code> of a body B about a point P by the spatial velocity <code>V_WBp</code>, in a frame W, of the body frame B shifted to point P.  <a href="#ab0efcd599640dacc6ef37cf640143fdc">More...</a><br /></td></tr>
<tr class="separator:ab0efcd599640dacc6ef37cf640143fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3f6e6102f427a8624f86758eb536fd"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:acc3f6e6102f427a8624f86758eb536fd"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, 6, Derived::ColsAtCompileTime, 0, 6, Derived::MaxColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#acc3f6e6102f427a8624f86758eb536fd">operator *</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;Mmatrix) const</td></tr>
<tr class="memdesc:acc3f6e6102f427a8624f86758eb536fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <code>this</code> spatial inertia by a set of spatial vectors in M⁶ stored as columns of input matrix <code>Mmatrix</code>.  <a href="#acc3f6e6102f427a8624f86758eb536fd">More...</a><br /></td></tr>
<tr class="separator:acc3f6e6102f427a8624f86758eb536fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:a8f02d78a11a4fd918699c75b48573520"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a8f02d78a11a4fd918699c75b48573520">SpatialInertia</a> (const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> &amp;)=default</td></tr>
<tr class="separator:a8f02d78a11a4fd918699c75b48573520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43ccc9d77b74b64c25cfcaf3deeaf0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#aa43ccc9d77b74b64c25cfcaf3deeaf0b">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> &amp;)=default</td></tr>
<tr class="separator:aa43ccc9d77b74b64c25cfcaf3deeaf0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423681189f9dd1726b750876f67dafe9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a423681189f9dd1726b750876f67dafe9">SpatialInertia</a> (<a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a423681189f9dd1726b750876f67dafe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d612851b1578071428ec79f7da1047a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a2d612851b1578071428ec79f7da1047a">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a2d612851b1578071428ec79f7da1047a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Spatial inertia equivalent shapes</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="spatial_inertia_equivalent_shapes"></a> Calculates principal semi-diameters (half-lengths), principal axes orientations, and the position of a uniform-density object whose spatial inertia is equal to <code>this</code> spatial inertia. These functions are useful for visualization or physical interpretation of the geometric extents of <code>this</code> spatial inertia for a given shape. These functions return 3 principal semi-diameters (half-lengths) [a b c] sorted in descending order (a ≥ b ≥ c) which are measured from Scm (the center of mass of <code>this</code> spatial inertia). They also return the pose of the uniform density object that represents <code>this</code> spatial inertia.</p>
<p>Example: Consider an oddly-shaped rigid body B with a known spatial inertia M_BBo_B about B's origin Bo, expressed in frame B. These functions return an easily visualized simple shape whose spatial inertial is equal to M_BBo_B. The simple shape is defined by a frame A with origin Ao at Bcm (B's center of mass), has principal dimensions [a b c], and has unit vectors Ax, Ay, Az parallel to the simple shape's principal directions. When the simple shape is a uniform-density solid ellipsoid, proceed as follows to form [a b c], the rotation matrix R_BA describing Ax, Ay, Az, and the position vector p_BoAo_B from Bo to Ao (ellipsoid center of mass). </p><div class="fragment"><div class="line"><span class="keyword">const</span> SpatialInertia&lt;double&gt;&amp; M_BBo_B = B.default_spatial_inertia();</div><div class="line"><span class="keyword">auto</span> [abc, X_BA] =</div><div class="line">  M_BBo_B.CalcPrincipalSemiDiametersAndPoseForSolidEllipsoid();</div></div><!-- fragment --> <dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the elements of <code>this</code> spatial inertia cannot be converted to a real finite double. For example, an exception is thrown if <code>this</code> contains an erroneous NaN or if scalar type T is symbolic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a0e13800a4b7f21903141dbe4c0102720" title="Forms the 3 principal moments of inertia and their 3 associated principal directions for this rotatio...">RotationalInertia::CalcPrincipalMomentsAndAxesOfInertia()</a> to form principal moments of inertia and their associated principal directions. </dd></dl>
</div></td></tr>
<tr class="memitem:aba6d2ff81ae140bb2c4249933a51597c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;, <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">drake::math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#aba6d2ff81ae140bb2c4249933a51597c">CalcPrincipalSemiDiametersAndPoseForSolidEllipsoid</a> () const</td></tr>
<tr class="memdesc:aba6d2ff81ae140bb2c4249933a51597c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 3 principal semi-diameters [lmax lmed lmin] sorted in descending order (lmax ≥ lmed ≥ lmin), orientation, and position of a solid ellipsoid whose spatial inertia is equal to <code>this</code> spatial inertia.  <a href="#aba6d2ff81ae140bb2c4249933a51597c">More...</a><br /></td></tr>
<tr class="separator:aba6d2ff81ae140bb2c4249933a51597c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe13c3fa1bec5373af28bc723de8bd6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;, <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">drake::math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#aefe13c3fa1bec5373af28bc723de8bd6">CalcPrincipalHalfLengthsAndPoseForSolidBox</a> () const</td></tr>
<tr class="memdesc:aefe13c3fa1bec5373af28bc723de8bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns three ½-lengths [lmax lmed lmin] sorted in descending order (lmax ≥ lmed ≥ lmin), orientation, and position of a solid box whose spatial inertia is equal to <code>this</code> spatial inertia.  <a href="#aefe13c3fa1bec5373af28bc723de8bd6">More...</a><br /></td></tr>
<tr class="separator:aefe13c3fa1bec5373af28bc723de8bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2828bb1494dc7329312ad72ee5360b13"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;, <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">drake::math::RigidTransform</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a2828bb1494dc7329312ad72ee5360b13">CalcPrincipalHalfLengthsAndPoseForMinimumBoundingBox</a> () const</td></tr>
<tr class="memdesc:a2828bb1494dc7329312ad72ee5360b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns three ½-lengths [lmax lmed lmin] sorted in descending order (lmax ≥ lmed ≥ lmin), orientation, and position of a box whose mass is concentrated in 8 particles at the box's corners and whose spatial inertia is equal to <code>this</code> spatial inertia.  <a href="#a2828bb1494dc7329312ad72ee5360b13">More...</a><br /></td></tr>
<tr class="separator:a2828bb1494dc7329312ad72ee5360b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e8046a1dd852107b5f6a213b0cf2c5"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#ac8e8046a1dd852107b5f6a213b0cf2c5">CalcMinimumPhysicalLength</a> () const</td></tr>
<tr class="memdesc:ac8e8046a1dd852107b5f6a213b0cf2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum possible length for the physical extent of the massive object that underlies this spatial inertia.  <a href="#ac8e8046a1dd852107b5f6a213b0cf2c5">More...</a><br /></td></tr>
<tr class="separator:ac8e8046a1dd852107b5f6a213b0cf2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a122ea28cb0d9cc88f61b03765076e349"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a122ea28cb0d9cc88f61b03765076e349">MakeFromCentralInertia</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_PScm_E, const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;I_SScm_E)</td></tr>
<tr class="memdesc:a122ea28cb0d9cc88f61b03765076e349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a spatial inertia for a physical body or composite body S about a point P from a given mass, center of mass, and central rotational inertia.  <a href="#a122ea28cb0d9cc88f61b03765076e349">More...</a><br /></td></tr>
<tr class="separator:a122ea28cb0d9cc88f61b03765076e349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f022e7b3f0771715149a808b11343fd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a1f022e7b3f0771715149a808b11343fd">MakeUnitary</a> ()</td></tr>
<tr class="memdesc:a1f022e7b3f0771715149a808b11343fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Creates a spatial inertia whose mass is 1, position vector to center of mass is zero, and whose rotational inertia has moments of inertia of 1 and products of inertia of 0.  <a href="#a1f022e7b3f0771715149a808b11343fd">More...</a><br /></td></tr>
<tr class="separator:a1f022e7b3f0771715149a808b11343fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7153d47fde17ac87697aab19515cf2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a3d7153d47fde17ac87697aab19515cf2">PointMass</a> (const T &amp;mass, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;position)</td></tr>
<tr class="memdesc:a3d7153d47fde17ac87697aab19515cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the spatial inertia for a particle Q of mass m about a point P.  <a href="#a3d7153d47fde17ac87697aab19515cf2">More...</a><br /></td></tr>
<tr class="separator:a3d7153d47fde17ac87697aab19515cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18329f60198911cb11b38659531ae32e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a18329f60198911cb11b38659531ae32e">SolidBoxWithDensity</a> (const T &amp;density, const T &amp;lx, const T &amp;ly, const T &amp;lz)</td></tr>
<tr class="memdesc:a18329f60198911cb11b38659531ae32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a spatial inertia for a uniform density solid box B about its geometric center Bo (which is coincident with B's center of mass Bcm).  <a href="#a18329f60198911cb11b38659531ae32e">More...</a><br /></td></tr>
<tr class="separator:a18329f60198911cb11b38659531ae32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4738509b2128d36324b62b36813dce0d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a4738509b2128d36324b62b36813dce0d">SolidBoxWithMass</a> (const T &amp;mass, const T &amp;lx, const T &amp;ly, const T &amp;lz)</td></tr>
<tr class="memdesc:a4738509b2128d36324b62b36813dce0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a spatial inertia for a uniform density solid box B about its geometric center Bo (which is coincident with B's center of mass Bcm).  <a href="#a4738509b2128d36324b62b36813dce0d">More...</a><br /></td></tr>
<tr class="separator:a4738509b2128d36324b62b36813dce0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4f444418950720dd9b4eef715e40e0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a2c4f444418950720dd9b4eef715e40e0">SolidCubeWithDensity</a> (const T &amp;density, const T &amp;length)</td></tr>
<tr class="memdesc:a2c4f444418950720dd9b4eef715e40e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a spatial inertia for a uniform density solid cube B about its geometric center Bo (which is coincident with B's center of mass Bcm).  <a href="#a2c4f444418950720dd9b4eef715e40e0">More...</a><br /></td></tr>
<tr class="separator:a2c4f444418950720dd9b4eef715e40e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae074df2bf4a9f6f526322361379431f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#aae074df2bf4a9f6f526322361379431f">SolidCubeWithMass</a> (const T &amp;mass, const T &amp;length)</td></tr>
<tr class="memdesc:aae074df2bf4a9f6f526322361379431f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a spatial inertia for a uniform density solid cube B about its geometric center Bo (which is coincident with B's center of mass Bcm).  <a href="#aae074df2bf4a9f6f526322361379431f">More...</a><br /></td></tr>
<tr class="separator:aae074df2bf4a9f6f526322361379431f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c66cd195387d537311d9c6d444ab62"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#ac1c66cd195387d537311d9c6d444ab62">SolidCapsuleWithDensity</a> (const T &amp;density, const T &amp;radius, const T &amp;length, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;unit_vector)</td></tr>
<tr class="memdesc:ac1c66cd195387d537311d9c6d444ab62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a spatial inertia for a uniform density solid capsule B about its geometric center Bo (which is coincident with B's center of mass Bcm).  <a href="#ac1c66cd195387d537311d9c6d444ab62">More...</a><br /></td></tr>
<tr class="separator:ac1c66cd195387d537311d9c6d444ab62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc40e315f8733af98f82560144c1b8e3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#adc40e315f8733af98f82560144c1b8e3">SolidCapsuleWithMass</a> (const T &amp;mass, const T &amp;radius, const T &amp;length, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;unit_vector)</td></tr>
<tr class="memdesc:adc40e315f8733af98f82560144c1b8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a spatial inertia for a uniform density solid capsule B about its geometric center Bo (which is coincident with B's center of mass Bcm).  <a href="#adc40e315f8733af98f82560144c1b8e3">More...</a><br /></td></tr>
<tr class="separator:adc40e315f8733af98f82560144c1b8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb726864b19730f6f1c822670e144b1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a0bb726864b19730f6f1c822670e144b1">SolidCylinderWithDensity</a> (const T &amp;density, const T &amp;radius, const T &amp;length, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;unit_vector)</td></tr>
<tr class="memdesc:a0bb726864b19730f6f1c822670e144b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a spatial inertia for a uniform density solid cylinder B about its geometric center Bo (which is coincident with B's center of mass Bcm).  <a href="#a0bb726864b19730f6f1c822670e144b1">More...</a><br /></td></tr>
<tr class="separator:a0bb726864b19730f6f1c822670e144b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215d901a05f95038a906a1383cedeae2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a215d901a05f95038a906a1383cedeae2">SolidCylinderWithMass</a> (const T &amp;mass, const T &amp;radius, const T &amp;length, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;unit_vector)</td></tr>
<tr class="memdesc:a215d901a05f95038a906a1383cedeae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a spatial inertia for a uniform density solid cylinder B about its geometric center Bo (which is coincident with B's center of mass Bcm).  <a href="#a215d901a05f95038a906a1383cedeae2">More...</a><br /></td></tr>
<tr class="separator:a215d901a05f95038a906a1383cedeae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67b3136ef4e48d788b0419b3e69c56d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#af67b3136ef4e48d788b0419b3e69c56d">SolidCylinderWithDensityAboutEnd</a> (const T &amp;density, const T &amp;radius, const T &amp;length, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;unit_vector)</td></tr>
<tr class="memdesc:af67b3136ef4e48d788b0419b3e69c56d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a spatial inertia for a uniform-density solid cylinder B about an end-point Bp of the cylinder's axis (see below for more about Bp).  <a href="#af67b3136ef4e48d788b0419b3e69c56d">More...</a><br /></td></tr>
<tr class="separator:af67b3136ef4e48d788b0419b3e69c56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb702323ac7052994423f00550f2aff3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#acb702323ac7052994423f00550f2aff3">SolidCylinderWithMassAboutEnd</a> (const T &amp;mass, const T &amp;radius, const T &amp;length, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;unit_vector)</td></tr>
<tr class="memdesc:acb702323ac7052994423f00550f2aff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a spatial inertia for a uniform-density solid cylinder B about an end-point Bp of the cylinder's axis (see below for more about Bp).  <a href="#acb702323ac7052994423f00550f2aff3">More...</a><br /></td></tr>
<tr class="separator:acb702323ac7052994423f00550f2aff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5233380acba42c39c9b741b85660beca"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a5233380acba42c39c9b741b85660beca">ThinRodWithMass</a> (const T &amp;mass, const T &amp;length, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;unit_vector)</td></tr>
<tr class="memdesc:a5233380acba42c39c9b741b85660beca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a spatial inertia for a uniform-density thin rod B about its center of mass Bcm.  <a href="#a5233380acba42c39c9b741b85660beca">More...</a><br /></td></tr>
<tr class="separator:a5233380acba42c39c9b741b85660beca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f17f72011d5c06da34f69245ac69bf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a97f17f72011d5c06da34f69245ac69bf">ThinRodWithMassAboutEnd</a> (const T &amp;mass, const T &amp;length, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;unit_vector)</td></tr>
<tr class="memdesc:a97f17f72011d5c06da34f69245ac69bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a spatial inertia for a uniform-density thin rod B about one of its ends.  <a href="#a97f17f72011d5c06da34f69245ac69bf">More...</a><br /></td></tr>
<tr class="separator:a97f17f72011d5c06da34f69245ac69bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb07d17fd701017f4d67815c17fc80a2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#aeb07d17fd701017f4d67815c17fc80a2">SolidEllipsoidWithDensity</a> (const T &amp;density, const T &amp;a, const T &amp;b, const T &amp;c)</td></tr>
<tr class="memdesc:aeb07d17fd701017f4d67815c17fc80a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a spatial inertia for a uniform density solid ellipsoid B about its geometric center Bo (which is coincident with B's center of mass Bcm).  <a href="#aeb07d17fd701017f4d67815c17fc80a2">More...</a><br /></td></tr>
<tr class="separator:aeb07d17fd701017f4d67815c17fc80a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba5d8b235266f2b5dd38650df184917"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a9ba5d8b235266f2b5dd38650df184917">SolidEllipsoidWithMass</a> (const T &amp;mass, const T &amp;a, const T &amp;b, const T &amp;c)</td></tr>
<tr class="memdesc:a9ba5d8b235266f2b5dd38650df184917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a spatial inertia for a uniform density solid ellipsoid B about its geometric center Bo (which is coincident with B's center of mass Bcm).  <a href="#a9ba5d8b235266f2b5dd38650df184917">More...</a><br /></td></tr>
<tr class="separator:a9ba5d8b235266f2b5dd38650df184917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1354f4723023135536629d866ef5de09"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a1354f4723023135536629d866ef5de09">SolidSphereWithDensity</a> (const T &amp;density, const T &amp;radius)</td></tr>
<tr class="memdesc:a1354f4723023135536629d866ef5de09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a spatial inertia for a uniform density solid sphere B about its geometric center Bo (which is coincident with B's center of mass Bcm).  <a href="#a1354f4723023135536629d866ef5de09">More...</a><br /></td></tr>
<tr class="separator:a1354f4723023135536629d866ef5de09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad207bb84c25f7ac68dcf64ff5763fbee"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#ad207bb84c25f7ac68dcf64ff5763fbee">SolidSphereWithMass</a> (const T &amp;mass, const T &amp;radius)</td></tr>
<tr class="memdesc:ad207bb84c25f7ac68dcf64ff5763fbee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a spatial inertia for a uniform density solid sphere B about its geometric center Bo (which is coincident with B's center of mass Bcm).  <a href="#ad207bb84c25f7ac68dcf64ff5763fbee">More...</a><br /></td></tr>
<tr class="separator:ad207bb84c25f7ac68dcf64ff5763fbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aed08f3640dbf9cdf37d714d12e8846"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a3aed08f3640dbf9cdf37d714d12e8846">HollowSphereWithDensity</a> (const T &amp;area_density, const T &amp;radius)</td></tr>
<tr class="memdesc:a3aed08f3640dbf9cdf37d714d12e8846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a spatial inertia for a uniform density thin hollow sphere B about its geometric center Bo (which is coincident with B's center of mass Bcm).  <a href="#a3aed08f3640dbf9cdf37d714d12e8846">More...</a><br /></td></tr>
<tr class="separator:a3aed08f3640dbf9cdf37d714d12e8846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6970a4978940025cb8fccef2ce0018b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#aa6970a4978940025cb8fccef2ce0018b">HollowSphereWithMass</a> (const T &amp;mass, const T &amp;radius)</td></tr>
<tr class="memdesc:aa6970a4978940025cb8fccef2ce0018b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a spatial inertia for a uniform density hollow sphere B about its geometric center Bo (which is coincident with B's center of mass Bcm).  <a href="#aa6970a4978940025cb8fccef2ce0018b">More...</a><br /></td></tr>
<tr class="separator:aa6970a4978940025cb8fccef2ce0018b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24310926c4f3a0604b4ebb341deca84"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#af24310926c4f3a0604b4ebb341deca84">SolidTetrahedronAboutPointWithDensity</a> (const T &amp;density, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p0, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p1, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p2, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p3)</td></tr>
<tr class="memdesc:af24310926c4f3a0604b4ebb341deca84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a spatial inertia for a uniform density solid tetrahedron B about a point A, from which position vectors to B's 4 vertices B0, B1, B2, B3 are measured (position vectors are all expressed in a common frame E).  <a href="#af24310926c4f3a0604b4ebb341deca84">More...</a><br /></td></tr>
<tr class="separator:af24310926c4f3a0604b4ebb341deca84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0407ec30127d1a3d4fcb355453485c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a8d0407ec30127d1a3d4fcb355453485c">SolidTetrahedronAboutVertexWithDensity</a> (const T &amp;density, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p1, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p2, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p3)</td></tr>
<tr class="memdesc:a8d0407ec30127d1a3d4fcb355453485c"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Creates a spatial inertia for a uniform density solid tetrahedron B about its vertex B0, from which position vectors to B's other 3 vertices B1, B2, B3 are measured (position vectors are all expressed in a common frame E).  <a href="#a8d0407ec30127d1a3d4fcb355453485c">More...</a><br /></td></tr>
<tr class="separator:a8d0407ec30127d1a3d4fcb355453485c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8ac17f8615fe5634f54ad0423c0550"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a4d8ac17f8615fe5634f54ad0423c0550">Zero</a> ()</td></tr>
<tr class="memdesc:a4d8ac17f8615fe5634f54ad0423c0550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes mass, center of mass and rotational inertia to zero.  <a href="#a4d8ac17f8615fe5634f54ad0423c0550">More...</a><br /></td></tr>
<tr class="separator:a4d8ac17f8615fe5634f54ad0423c0550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd853ae2157259d63973818578119f4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a5fd853ae2157259d63973818578119f4">NaN</a> ()</td></tr>
<tr class="memdesc:a5fd853ae2157259d63973818578119f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes mass, center of mass and rotational inertia to invalid NaN's for a quick detection of uninitialized values.  <a href="#a5fd853ae2157259d63973818578119f4">More...</a><br /></td></tr>
<tr class="separator:a5fd853ae2157259d63973818578119f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a3b6fb089613f2cdc65359c65d5a5d504"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b6fb089613f2cdc65359c65d5a5d504"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a3b6fb089613f2cdc65359c65d5a5d504">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt; &amp;M)</td></tr>
<tr class="memdesc:a3b6fb089613f2cdc65359c65d5a5d504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an instance of <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia.">SpatialInertia</a> into a std::ostream.  <a href="#a3b6fb089613f2cdc65359c65d5a5d504">More...</a><br /></td></tr>
<tr class="separator:a3b6fb089613f2cdc65359c65d5a5d504"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8f02d78a11a4fd918699c75b48573520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f02d78a11a4fd918699c75b48573520">&#9670;&nbsp;</a></span>SpatialInertia() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a423681189f9dd1726b750876f67dafe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423681189f9dd1726b750876f67dafe9">&#9670;&nbsp;</a></span>SpatialInertia() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d7aa4145ca54c5ab8e45728648f7c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7aa4145ca54c5ab8e45728648f7c5b">&#9670;&nbsp;</a></span>SpatialInertia() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_PScm_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>G_SP_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>skip_validity_check</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a spatial inertia for a physical body or composite body S about a point P from a given mass, center of mass and rotational inertia. </p>
<p>The center of mass is specified by the position vector <code>p_PScm_E</code> from point P to the center of mass point <code>Scm</code>, expressed in a frame E. The rotational inertia is provided as the <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html" title="This class is used to represent rotational inertias for unit mass bodies.">UnitInertia</a> <code>G_SP_E</code> of the body or composite body S computed about point P and expressed in frame E.</p>
<dl class="section note"><dt>Note</dt><dd>The third argument of this constructor is unusual in that it is an <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html" title="This class is used to represent rotational inertias for unit mass bodies.">UnitInertia</a> (not a traditional <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class describes the mass distribution (inertia properties) of a body or composite body about a p...">RotationalInertia</a>) and its inertia is about the arbitrary point P (not Scm &ndash; S's center of mass). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a122ea28cb0d9cc88f61b03765076e349" title="Creates a spatial inertia for a physical body or composite body S about a point P from a given mass,...">MakeFromCentralInertia</a> a factory method with traditional utility.</dd></dl>
<p>This constructor checks for the physical validity of the resulting SpatialInertia with <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a679852e6738fbcf5751ca37c51d2f084" title="Performs a number of checks to verify that this is a physically valid spatial inertia.">IsPhysicallyValid()</a> and throws a std::runtime_error exception in the event the provided input parameters lead to non-physically viable spatial inertia. Since this check has non-negligable runtime costs, it can be disabled by setting the optional argument <code>skip_validity_check</code> to <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mass</td><td>The mass of the body or composite body S. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_PScm_E</td><td>The position vector from point P to the center of mass of body or composite body S expressed in frame E. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">G_SP_E</td><td><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html" title="This class is used to represent rotational inertias for unit mass bodies.">UnitInertia</a> of the body or composite body S computed about origin point P and expressed in frame E. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">skip_validity_check</td><td>If true, skips the validity check described above. Defaults to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3a1c2e2b7b334839c460e022d4686f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1c2e2b7b334839c460e022d4686f54">&#9670;&nbsp;</a></span>CalcComMoment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt; CalcComMoment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the center of mass moment vector <code>mass * p_PScm_E</code> given the position vector <code>p_PScm_E</code> from the <em>about point</em> P to the center of mass <code>Scm</code> of the body or composite body S, expressed in frame E. </p>
<p>See the documentation of this class for details. </p>

</div>
</div>
<a id="ac8e8046a1dd852107b5f6a213b0cf2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e8046a1dd852107b5f6a213b0cf2c5">&#9670;&nbsp;</a></span>CalcMinimumPhysicalLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T CalcMinimumPhysicalLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the minimum possible length for the physical extent of the massive object that underlies this spatial inertia. </p>
<p>In other words, the underlying physical object must have at least two particles whose distance between each other is greater than or equal to the minimum possible length. </p><dl class="section note"><dt>Note</dt><dd>The minimum possible length is equal to the space-diagonal of the minimum bounding box for <code>this</code> spatial inertia, which happens to be equal to √(2 * trace of the central unit inertia associated with <code>this</code>). </dd>
<dd>
Minimum possible length can be used to detect erroneous inertias associated with absurdly large objects or to detect errors when the minimum possible length is larger than the real physical geometry that underlies <code>this</code> spatial inertia (maybe due to inertia conversion errors, e.g., factor of 10⁷ from kg m² to g cm² or 10⁹ from kg m² to g mm²). To assess whether the minimum possible length is reasonable, it helps to have comparable sizes, e.g., the world's largest aircraft carrier has a space-diagonal ≈ 355 m (length ≈ 337 m, width ≈ 78 m, height ≈ 76 m), the largest land vehicle (Bagger bucket-wheel excavator) is ≈ 224 m long, the largest human object in space (International Space Station) is 109 m long and 75 m wide, the USA space shuttle is ≈ 37 m long and can carry a 15.2 m Canadarm, the world's largest humanoid robot (Mononofu) is ≈ 8.5 m tall. Also, minimum possible length can be compared to known physical geometry (e.g., realistic collision geometry, visual geometry, or physical extents associated with body connectivity data and topology), and this comparison can be used to warn that a spatial inertia may be physically impossible (e.g., underlying geometry is smaller than the minimum possible length). </dd></dl>

</div>
</div>
<a id="a2828bb1494dc7329312ad72ee5360b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2828bb1494dc7329312ad72ee5360b13">&#9670;&nbsp;</a></span>CalcPrincipalHalfLengthsAndPoseForMinimumBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;, <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">drake::math::RigidTransform</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; CalcPrincipalHalfLengthsAndPoseForMinimumBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns three ½-lengths [lmax lmed lmin] sorted in descending order (lmax ≥ lmed ≥ lmin), orientation, and position of a box whose mass is concentrated in 8 particles at the box's corners and whose spatial inertia is equal to <code>this</code> spatial inertia. </p>
<p>The physical geometry of the actual underlying object must be larger than this box, as this box is the minimum bounding box for the actual geometry. See <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#spatial_inertia_equivalent_shapes">Spatial inertia equivalent shapes</a> for more details. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the elements of <code>this</code> spatial inertia cannot be converted to a real finite double. For example, an exception is thrown if <code>this</code> contains an erroneous NaN or if scalar type T is symbolic. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefe13c3fa1bec5373af28bc723de8bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe13c3fa1bec5373af28bc723de8bd6">&#9670;&nbsp;</a></span>CalcPrincipalHalfLengthsAndPoseForSolidBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;, <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">drake::math::RigidTransform</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; CalcPrincipalHalfLengthsAndPoseForSolidBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns three ½-lengths [lmax lmed lmin] sorted in descending order (lmax ≥ lmed ≥ lmin), orientation, and position of a solid box whose spatial inertia is equal to <code>this</code> spatial inertia. </p>
<p>See <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#spatial_inertia_equivalent_shapes">Spatial inertia equivalent shapes</a> for more details. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the elements of <code>this</code> spatial inertia cannot be converted to a real finite double. For example, an exception is thrown if <code>this</code> contains an erroneous NaN or if scalar type T is symbolic. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba6d2ff81ae140bb2c4249933a51597c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6d2ff81ae140bb2c4249933a51597c">&#9670;&nbsp;</a></span>CalcPrincipalSemiDiametersAndPoseForSolidEllipsoid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;, <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">drake::math::RigidTransform</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; CalcPrincipalSemiDiametersAndPoseForSolidEllipsoid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns 3 principal semi-diameters [lmax lmed lmin] sorted in descending order (lmax ≥ lmed ≥ lmin), orientation, and position of a solid ellipsoid whose spatial inertia is equal to <code>this</code> spatial inertia. </p>
<p>See <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#spatial_inertia_equivalent_shapes">Spatial inertia equivalent shapes</a> for more details. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the elements of <code>this</code> spatial inertia cannot be converted to a real finite double. For example, an exception is thrown if <code>this</code> contains an erroneous NaN or if scalar type T is symbolic. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a025a1eb3a6fcfd673edc15b7ba85de9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a025a1eb3a6fcfd673edc15b7ba85de9e">&#9670;&nbsp;</a></span>CalcRotationalInertia()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt;T&gt; CalcRotationalInertia </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the rotational inertia <code>I_SP_E = mass * G_SP_E</code> of this spatial inertia, computed about point P and expressed in frame E. </p>
<p>See the documentation of this class for details. </p>

</div>
</div>
<a id="a751136a22e2d0980679dd41429d54c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751136a22e2d0980679dd41429d54c62">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;Scalar&gt; cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new SpatialInertia object templated on <code>Scalar</code> initialized from the value of <code>this</code> spatial inertia. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type on which the new spatial inertia will be templated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia.">SpatialInertia</a>&lt;From&gt;::cast&lt;To&gt;()</code> creates a new <code><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia.">SpatialInertia</a>&lt;To&gt;</code> from a <code><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia.">SpatialInertia</a>&lt;From&gt;</code> but only if type <code>To</code> is constructible from type <code>From</code>. This cast method works in accordance with Eigen's cast method for Eigen's objects that underlie this SpatialInertia. For example, Eigen currently allows cast from type double to AutoDiffXd, but not vice-versa. </dd></dl>

</div>
</div>
<a id="a413ff91e8caf0498a96e5b1e06da9cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413ff91e8caf0498a96e5b1e06da9cd1">&#9670;&nbsp;</a></span>CopyToFullMatrix6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a11f9aa896d31437a219ed19fa944fe20">Matrix6</a>&lt;T&gt; CopyToFullMatrix6 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy to a full 6x6 matrix representation. </p>

</div>
</div>
<a id="a1d857a6e2165c421949804eb2afbe7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d857a6e2165c421949804eb2afbe7c7">&#9670;&nbsp;</a></span>get_com()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt;&amp; get_com </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a constant reference to the position vector <code>p_PScm_E</code> from the <em>about point</em> P to the center of mass <code>Scm</code> of the body or composite body S, expressed in frame E. </p>
<p>See the documentation of this class for details. </p>

</div>
</div>
<a id="a1664b38f6c4fad624a7ab777c9642a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1664b38f6c4fad624a7ab777c9642a7e">&#9670;&nbsp;</a></span>get_mass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; get_mass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a constant reference to the mass of this spatial inertia. </p>

</div>
</div>
<a id="aa7fbc3778a7090443b7b5102861ebe9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7fbc3778a7090443b7b5102861ebe9a">&#9670;&nbsp;</a></span>get_unit_inertia()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a>&lt;T&gt;&amp; get_unit_inertia </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a constant reference to the unit inertia <code>G_SP_E</code> of this spatial inertia, computed about point P and expressed in frame E. </p>
<p>See the documentation of this class for details. </p>

</div>
</div>
<a id="a3aed08f3640dbf9cdf37d714d12e8846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aed08f3640dbf9cdf37d714d12e8846">&#9670;&nbsp;</a></span>HollowSphereWithDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; HollowSphereWithDensity </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>area_density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a spatial inertia for a uniform density thin hollow sphere B about its geometric center Bo (which is coincident with B's center of mass Bcm). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">area_density</td><td>mass per unit area (kg/m²). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>sphere's radius in meters (the hollow sphere is regarded as an infinitesimally thin shell of uniform density). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_BBo_B</td><td>B's spatial inertia about Bo, expressed in B. Since B's rotational inertia is triaxially symmetric, M_BBo_B = M_BBo_E, i.e., M_BBo expressed in frame B is equal to M_BBo expressed in an arbitrary frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>B's rotational inertia about Bo is triaxially symmetric, meaning B has an equal moment of inertia about any line passing through Bo. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if area_density or radius is not positive and finite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6970a4978940025cb8fccef2ce0018b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6970a4978940025cb8fccef2ce0018b">&#9670;&nbsp;</a></span>HollowSphereWithMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; HollowSphereWithMass </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a spatial inertia for a uniform density hollow sphere B about its geometric center Bo (which is coincident with B's center of mass Bcm). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mass</td><td>mass of the hollow sphere (kg). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>sphere's radius in meters (the hollow sphere is regarded as an infinitesimally thin shell of uniform density). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_BBo</td><td>B's spatial inertia about Bo. Since B's rotational inertia is triaxially symmetric, M_BBo_B = M_BBo_E, i.e., M_BBo expressed in frame B is equal to M_BBo expressed in an arbitrary frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>B's rotational inertia about Bo is triaxially symmetric, meaning B has an equal moment of inertia about any line passing through Bo. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if mass or radius is not positive and finite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a73339c4b21bba9c3fa975f7a6c4220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a73339c4b21bba9c3fa975f7a6c4220">&#9670;&nbsp;</a></span>IsNaN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if any of the elements in this spatial inertia is NaN and <code>false</code> otherwise. </p>

</div>
</div>
<a id="a679852e6738fbcf5751ca37c51d2f084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679852e6738fbcf5751ca37c51d2f084">&#9670;&nbsp;</a></span>IsPhysicallyValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsPhysicallyValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a number of checks to verify that this is a physically valid spatial inertia. </p>
<p>The checks performed are:</p>
<ul>
<li>No NaN entries.</li>
<li>Non-negative mass.</li>
<li>Non-negative principal moments about the center of mass.</li>
<li>Principal moments about the center of mass must satisfy the triangle inequality:<ul>
<li><code>Ixx + Iyy &gt;= Izz</code></li>
<li><code>Ixx + Izz &gt;= Iyy</code></li>
<li><code>Iyy + Izz &gt;= Ixx</code></li>
</ul>
</li>
</ul>
<p>These are the tests performed by <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">RotationalInertia::CouldBePhysicallyValid()</a> which become a sufficient condition when performed on a rotational inertia about a body's center of mass. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html#a03e71eb4bd2a7648a411e1cbaf94812b" title="Performs several necessary checks to verify whether this rotational inertia could be physically valid...">RotationalInertia::CouldBePhysicallyValid()</a>. </dd></dl>

</div>
</div>
<a id="a55630ea16dd7fcd906f2c9d9db36bb66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55630ea16dd7fcd906f2c9d9db36bb66">&#9670;&nbsp;</a></span>IsZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if all of the elements in this spatial inertia are zero and <code>false</code> otherwise. </p>

</div>
</div>
<a id="a122ea28cb0d9cc88f61b03765076e349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122ea28cb0d9cc88f61b03765076e349">&#9670;&nbsp;</a></span>MakeFromCentralInertia()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; MakeFromCentralInertia </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_PScm_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>I_SScm_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a spatial inertia for a physical body or composite body S about a point P from a given mass, center of mass, and central rotational inertia. </p>
<p>For example, this method creates a body's <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia.">SpatialInertia</a> about its body origin Bo from the body's mass, position vector from Bo to the body's center of mass, and rotational inertia about the body's center of mass.</p>
<p>This method checks for the physical validity of the resulting SpatialInertia with <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a679852e6738fbcf5751ca37c51d2f084" title="Performs a number of checks to verify that this is a physically valid spatial inertia.">IsPhysicallyValid()</a> and throws a std::runtime_error exception in the event the provided input parameters lead to a non-physically viable spatial inertia.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mass</td><td>The mass of the body or composite body S. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_PScm_E</td><td>The position vector from point P to point <code>Scm</code> (S's center of mass), expressed in a frame E. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I_SScm_E</td><td>S's <a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html" title="This class describes the mass distribution (inertia properties) of a body or composite body about a p...">RotationalInertia</a> about Scm, expressed in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_SP_E</td><td>S's spatial inertia about point P, expressed in frame E. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f022e7b3f0771715149a808b11343fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f022e7b3f0771715149a808b11343fd">&#9670;&nbsp;</a></span>MakeUnitary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; MakeUnitary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Internal use only) Creates a spatial inertia whose mass is 1, position vector to center of mass is zero, and whose rotational inertia has moments of inertia of 1 and products of inertia of 0. </p>

</div>
</div>
<a id="a5fd853ae2157259d63973818578119f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd853ae2157259d63973818578119f4">&#9670;&nbsp;</a></span>NaN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> NaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes mass, center of mass and rotational inertia to invalid NaN's for a quick detection of uninitialized values. </p>

</div>
</div>
<a id="acd0afd330ef98eb2418ae915e3a1b024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0afd330ef98eb2418ae915e3a1b024">&#9670;&nbsp;</a></span>operator *() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_force.html">SpatialForce</a>&lt;T&gt; operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_WB_E</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies <code>this</code> spatial inertia <code>M_Bo_E</code> of a body B about its frame origin <code>Bo</code> by the spatial acceleration of the body frame B in a frame W. </p>
<p>Mathematically: </p><pre>
  F_Bo_E = M_Bo_E * A_WB_E
</pre><p> or, in terms of its rotational and translational components (see this class's documentation for the block form of a rotational inertia): </p><pre>
  t_Bo = I_Bo * alpha_WB + m * p_BoBcm x a_WBo
  f_Bo = -m * p_BoBcm x alpha_WB + m * a_WBo
</pre><p> where <code>alpha_WB</code> and <code>a_WBo</code> are the rotational and translational components of the spatial acceleration <code>A_WB</code>, respectively.</p>
<dl class="section note"><dt>Note</dt><dd>The term <code>F_Bo_E</code> computed by this operator appears in the equations of motion for a rigid body which, when written about the origin <code>Bo</code> of the body frame B (which does not necessarily need to coincide with the body's center of mass), read as: <pre>
  Ftot_BBo = M_Bo_W * A_WB + b_Bo
</pre> where <code>Ftot_BBo</code> is the total spatial force applied on body B at <code>Bo</code> that corresponds to the body spatial acceleration <code>A_WB</code> and <code>b_Bo</code> contains the velocity dependent gyroscopic terms (see Eq. 2.26, p. 27, in A. Jain's book). </dd></dl>

</div>
</div>
<a id="ab0efcd599640dacc6ef37cf640143fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0efcd599640dacc6ef37cf640143fdc">&#9670;&nbsp;</a></span>operator *() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_momentum.html">SpatialMomentum</a>&lt;T&gt; operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>V_WBp_E</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies <code>this</code> spatial inertia <code>M_BP_E</code> of a body B about a point P by the spatial velocity <code>V_WBp</code>, in a frame W, of the body frame B shifted to point P. </p>
<p>Mathematically: </p><pre>
  L_WBp_E = M_BP_E * V_WBp_E
</pre><p> or, in terms of its rotational and translational components (see this class's documentation for the block form of a rotational inertia): </p><pre>
  h_WB  = I_Bp * w_WB + m * p_BoBcm x v_WP
  l_WBp = -m * p_BoBcm x w_WB + m * v_WP
</pre><p> where <code>w_WB</code> and <code>v_WP</code> are the rotational and translational components of the spatial velocity <code>V_WBp</code>, respectively and, <code>h_WB</code> and <code>l_WBp</code> are the angular and linear components of the spatial momentum <code>L_WBp</code>, respectively.</p>
<dl class="section note"><dt>Note</dt><dd>It is possible to show that <code>M_BP_E.Shift(p_PQ_E) * V_WBp_E.Shift(p_PQ_E)</code> exactly equals <code>L_WBp_E.Shift(p_PQ_E)</code>. </dd></dl>

</div>
</div>
<a id="acc3f6e6102f427a8624f86758eb536fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3f6e6102f427a8624f86758eb536fd">&#9670;&nbsp;</a></span>operator *() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, 6, Derived::ColsAtCompileTime, 0, 6, Derived::MaxColsAtCompileTime&gt; operator * </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>Mmatrix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies <code>this</code> spatial inertia by a set of spatial vectors in M⁶ stored as columns of input matrix <code>Mmatrix</code>. </p>
<p>The top three rows of Mmatrix are expected to store the rotational components while the bottom three rows are expected to store the translational components. The output matrix is of the same size as <code>Mmatrix</code> and each j-th column stores the spatial vector in F⁶ result of multiplying <code>this</code> spatial inertia with the j-th column of <code>Mmatrix</code>. </p>

</div>
</div>
<a id="a09dd10c733d7fcef47041dc724f31ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09dd10c733d7fcef47041dc724f31ff9">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_BP_E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds in a spatial inertia to <code>this</code> spatial inertia. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M_BP_E</td><td>A spatial inertia of some body B to be added to <code>this</code> spatial inertia. It must be defined about the same point P as <code>this</code> inertia, and expressed in the same frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to <code>this</code> spatial inertia, which has been updated to include the given spatial inertia <code>M_BP_E</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Given that the composition of spatial inertias is not well defined for massless bodies, this composition of the spatial inertias performs the arithmetic average of the center of mass position vector (<a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a1d857a6e2165c421949804eb2afbe7c7" title="Get a constant reference to the position vector p_PScm_E from the about point P to the center of mass...">get_com()</a>) and unit inertia (<a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#aa7fbc3778a7090443b7b5102861ebe9a" title="Get a constant reference to the unit inertia G_SP_E of this spatial inertia, computed about point P a...">get_unit_inertia()</a>) when the two spatial inertias have zero mass (<a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a1664b38f6c4fad624a7ab777c9642a7e" title="Get a constant reference to the mass of this spatial inertia.">get_mass()</a>). This is only valid in the limit to zero mass for two bodies with the same mass. This special case allows the composition of spatial inertias in the common case of a kinematic chain of massless bodies.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This operation is only valid if both spatial inertias are computed about the same point P and expressed in the same frame E. Considering <code>this</code> spatial inertia to be <code>M_SP_E</code> for some body or composite body S, about some point P, the supplied spatial inertia <code>M_BP_E</code> must be for some other body or composite body B about the <em>same</em> point P; B's inertia is then included in S. </dd></dl>

</div>
</div>
<a id="a2d612851b1578071428ec79f7da1047a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d612851b1578071428ec79f7da1047a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa43ccc9d77b74b64c25cfcaf3deeaf0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43ccc9d77b74b64c25cfcaf3deeaf0b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d7153d47fde17ac87697aab19515cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7153d47fde17ac87697aab19515cf2">&#9670;&nbsp;</a></span>PointMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; PointMass </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the spatial inertia for a particle Q of mass m about a point P. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mass</td><td>mass of the single particle (units of kg). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>vector from point P to Q, expressed in a frame B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_QP_B</td><td>particle Q's spatial inertia about P, expressed in frame B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if mass is not positive and finite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa45bbc7d0e5521d0d91579645636b7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45bbc7d0e5521d0d91579645636b7ed">&#9670;&nbsp;</a></span>ReExpress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; ReExpress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_AE</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given <code>this</code> spatial inertia <code>M_SP_E</code> for some body or composite body S, taken about a point P and expressed in frame E, this method computes the same inertia re-expressed in another frame A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R_AE</td><td>RotationMatrix relating frames A and E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_SP_A</td><td>The same spatial inertia of S about P but now re-expressed in frame A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#af397b4c3403d23ab61a128dbeaa1c3aa" title="Given this spatial inertia M_SP_E for some body or composite body S, taken about a point P and expres...">ReExpressInPlace()</a> for details. </dd></dl>

</div>
</div>
<a id="af397b4c3403d23ab61a128dbeaa1c3aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af397b4c3403d23ab61a128dbeaa1c3aa">&#9670;&nbsp;</a></span>ReExpressInPlace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReExpressInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_AE</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given <code>this</code> spatial inertia <code>M_SP_E</code> for some body or composite body S, taken about a point P and expressed in frame E, this method computes the same inertia re-expressed in another frame A. </p>
<p>This operation is performed in-place modifying the original object. On return, <code>this</code> is now re-expressed in frame A, that is, <code>M_SP_A</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R_AE</td><td>Rotation matrix from frame E to frame A. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09b2415a4b0787515507518d9c0dd4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b2415a4b0787515507518d9c0dd4e5">&#9670;&nbsp;</a></span>SetNaN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <code>this</code> spatial inertia to have NaN entries. </p>
<p>Typically used for quick detection of uninitialized values. </p>

</div>
</div>
<a id="ae7f8142e184c3d2f68a4c7f342a6c549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f8142e184c3d2f68a4c7f342a6c549">&#9670;&nbsp;</a></span>Shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; Shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_PQ_E</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given <code>this</code> spatial inertia <code>M_SP_E</code> for some body or composite body S, computed about point P, and expressed in frame E, this method uses the <em>Parallel Axis Theorem</em> for spatial inertias to compute the same spatial inertia about a new point Q. </p>
<p>The result still is expressed in frame E. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a99c4eb50d113f896c897289fa10c3464" title="Given this spatial inertia M_SP_E for some body or composite body S, computed about point P,...">ShiftInPlace()</a> for more details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_PQ_E</td><td>Vector from the original about point P to the new about point Q, expressed in the same frame E <code>this</code> spatial inertia is expressed in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_SQ_E</td><td>This same spatial inertia for body or composite body S but computed about a new point Q. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99c4eb50d113f896c897289fa10c3464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c4eb50d113f896c897289fa10c3464">&#9670;&nbsp;</a></span>ShiftInPlace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShiftInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_PQ_E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given <code>this</code> spatial inertia <code>M_SP_E</code> for some body or composite body S, computed about point P, and expressed in frame E, this method uses the <em>Parallel Axis Theorem</em> for spatial inertias to compute the same spatial inertia about a new point Q. </p>
<p>The result still is expressed in frame E. This operation is performed in-place modifying the original object. On return, <code>this</code> is now computed about a new point Q. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#ae7f8142e184c3d2f68a4c7f342a6c549" title="Given this spatial inertia M_SP_E for some body or composite body S, computed about point P,...">Shift()</a> which does not modify this object.</dd></dl>
<p>For details see Section 2.1.2, p. 20 of [Jain 2010].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_PQ_E</td><td>position vector from the original about-point P to the new about-point Q, expressed in the same frame E that <code>this</code> spatial inertia is expressed in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18329f60198911cb11b38659531ae32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18329f60198911cb11b38659531ae32e">&#9670;&nbsp;</a></span>SolidBoxWithDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; SolidBoxWithDensity </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>ly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a spatial inertia for a uniform density solid box B about its geometric center Bo (which is coincident with B's center of mass Bcm). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">density</td><td>mass per volume (kg/m³). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lx</td><td>length of the box in the Bx direction (meters). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ly</td><td>length of the box in the By direction (meters). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lz</td><td>length of the box in the Bz direction (meters). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_BBo_B</td><td>B's spatial inertia about Bo, expressed in B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if density, lx, ly, or lz is not positive and finite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4738509b2128d36324b62b36813dce0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4738509b2128d36324b62b36813dce0d">&#9670;&nbsp;</a></span>SolidBoxWithMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; SolidBoxWithMass </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>ly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a spatial inertia for a uniform density solid box B about its geometric center Bo (which is coincident with B's center of mass Bcm). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mass</td><td>mass of the solid box (kg). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lx</td><td>length of the box in the Bx direction (meters). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ly</td><td>length of the box in the By direction (meters). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lz</td><td>length of the box in the Bz direction (meters). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_BBo_B</td><td>B's spatial inertia about Bo, expressed in B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if mass, lx, ly, or lz is not positive and finite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1c66cd195387d537311d9c6d444ab62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c66cd195387d537311d9c6d444ab62">&#9670;&nbsp;</a></span>SolidCapsuleWithDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; SolidCapsuleWithDensity </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>unit_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a spatial inertia for a uniform density solid capsule B about its geometric center Bo (which is coincident with B's center of mass Bcm). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">density</td><td>mass per volume (kg/m³). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>radius of the cylinder/half-sphere parts of the capsule. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>length of the cylindrical part of the capsule. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unit_vector</td><td>unit vector defining the axial direction of the cylindrical part of the capsule, expressed in B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_BBo_B</td><td>B's spatial inertia about Bo, expressed in B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>B's rotational inertia about Bo is axially symmetric, meaning B has an equal moment of inertia about any line that both passes through Bo and is perpendicular to unit_vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if density, radius, or length is not positive and finite or if ‖unit_vector‖ is not within 1.0E-14 of 1.0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc40e315f8733af98f82560144c1b8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc40e315f8733af98f82560144c1b8e3">&#9670;&nbsp;</a></span>SolidCapsuleWithMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; SolidCapsuleWithMass </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>unit_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a spatial inertia for a uniform density solid capsule B about its geometric center Bo (which is coincident with B's center of mass Bcm). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mass</td><td>mass of the solid capsule (kg). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>radius of the cylinder/half-sphere parts of the capsule. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>length of the cylindrical part of the capsule. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unit_vector</td><td>unit vector defining the axial direction of the cylindrical part of the capsule, expressed in B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_BBo_B</td><td>B's spatial inertia about Bo, expressed in B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>B's rotational inertia about Bo is axially symmetric, meaning B has an equal moment of inertia about any line that both passes through Bo and is perpendicular to unit_vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if mass, radius, or length is not positive and finite or if ‖unit_vector‖ is not within 1.0E-14 of 1.0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c4f444418950720dd9b4eef715e40e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c4f444418950720dd9b4eef715e40e0">&#9670;&nbsp;</a></span>SolidCubeWithDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; SolidCubeWithDensity </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a spatial inertia for a uniform density solid cube B about its geometric center Bo (which is coincident with B's center of mass Bcm). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">density</td><td>mass per volume (kg/m³). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of each of the cube's sides (meters). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_BBo_B</td><td>B's spatial inertia about Bo, expressed in B. Since B's rotational inertia is triaxially symmetric, M_BBo_B = M_BBo_E, i.e., M_BBo expressed in frame B is equal to M_BBo expressed in an arbitrary frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>B's rotational inertia about Bo is triaxially symmetric, meaning B has an equal moment of inertia about any line passing through Bo. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if density or length is not positive and finite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae074df2bf4a9f6f526322361379431f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae074df2bf4a9f6f526322361379431f">&#9670;&nbsp;</a></span>SolidCubeWithMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; SolidCubeWithMass </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a spatial inertia for a uniform density solid cube B about its geometric center Bo (which is coincident with B's center of mass Bcm). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mass</td><td>mass of the solid cube (kg). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of each of the cube's sides (meters). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_BBo_B</td><td>B's spatial inertia about Bo, expressed in B. Since B's rotational inertia is triaxially symmetric, M_BBo_B = M_BBo_E, i.e., M_BBo expressed in frame B is equal to M_BBo expressed in an arbitrary frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>B's rotational inertia about Bo is triaxially symmetric, meaning B has an equal moment of inertia about any line passing through Bo. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if mass or length is not positive and finite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bb726864b19730f6f1c822670e144b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb726864b19730f6f1c822670e144b1">&#9670;&nbsp;</a></span>SolidCylinderWithDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; SolidCylinderWithDensity </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>unit_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a spatial inertia for a uniform density solid cylinder B about its geometric center Bo (which is coincident with B's center of mass Bcm). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">density</td><td>mass per volume (kg/m³). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>radius of the cylinder (meters). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>length of cylinder in unit_vector direction (meters). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unit_vector</td><td>unit vector defining the axial direction of the cylinder, expressed in B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_BBo_B</td><td>B's spatial inertia about Bo, expressed in B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>B's rotational inertia about Bo is axially symmetric, meaning B has an equal moment of inertia about any line that both passes through Bo and is perpendicular to unit_vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if density, radius, or length is not positive and finite or if ‖unit_vector‖ is not within 1.0E-14 of 1.0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#af67b3136ef4e48d788b0419b3e69c56d" title="Creates a spatial inertia for a uniform-density solid cylinder B about an end-point Bp of the cylinde...">SolidCylinderWithDensityAboutEnd()</a> to calculate M_BBp_B, B's spatial inertia about Bp (at the center of one of the cylinder's circular ends). </dd></dl>

</div>
</div>
<a id="af67b3136ef4e48d788b0419b3e69c56d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67b3136ef4e48d788b0419b3e69c56d">&#9670;&nbsp;</a></span>SolidCylinderWithDensityAboutEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; SolidCylinderWithDensityAboutEnd </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>unit_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a spatial inertia for a uniform-density solid cylinder B about an end-point Bp of the cylinder's axis (see below for more about Bp). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">density</td><td>mass per volume (kg/m³). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>radius of cylinder (meters). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>length of cylinder in unit_vector direction (meters). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unit_vector</td><td>unit vector parallel to the axis of the cylinder and directed from Bp to Bcm (B's center of mass), expressed in B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_BBp_B</td><td>B's spatial inertia about Bp, expressed in B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The position from Bp to Bcm is p_BpBcm = length / 2 * unit_vector. </dd>
<dd>
B's rotational inertia about Bp is axially symmetric, meaning B has an equal moment of inertia about any line that both passes through Bp and is perpendicular to unit_vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if density, radius, or length is not positive and finite or if ‖unit_vector‖ is not within 1.0E-14 of 1.0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a0bb726864b19730f6f1c822670e144b1" title="Creates a spatial inertia for a uniform density solid cylinder B about its geometric center Bo (which...">SolidCylinderWithDensity()</a> to calculate M_BBcm_B, B's spatial inertia about Bcm (B's center of mass). </dd></dl>

</div>
</div>
<a id="a215d901a05f95038a906a1383cedeae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215d901a05f95038a906a1383cedeae2">&#9670;&nbsp;</a></span>SolidCylinderWithMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; SolidCylinderWithMass </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>unit_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a spatial inertia for a uniform density solid cylinder B about its geometric center Bo (which is coincident with B's center of mass Bcm). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mass</td><td>mass of the solid cylinder (kg). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>radius of the cylinder (meters). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>length of cylinder in unit_vector direction (meters). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unit_vector</td><td>unit vector defining the axial direction of the cylinder, expressed in B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_BBo_B</td><td>B's spatial inertia about Bo, expressed in B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>B's rotational inertia about Bo is axially symmetric, meaning B has an equal moment of inertia about any line that both passes through Bo and is perpendicular to unit_vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if mass, radius, or length is not positive and finite or if ‖unit_vector‖ is not within 1.0E-14 of 1.0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#acb702323ac7052994423f00550f2aff3" title="Creates a spatial inertia for a uniform-density solid cylinder B about an end-point Bp of the cylinde...">SolidCylinderWithMassAboutEnd()</a> to calculate M_BBp_B, B's spatial inertia about Bp (at the center of one of the cylinder's circular ends). </dd></dl>

</div>
</div>
<a id="acb702323ac7052994423f00550f2aff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb702323ac7052994423f00550f2aff3">&#9670;&nbsp;</a></span>SolidCylinderWithMassAboutEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; SolidCylinderWithMassAboutEnd </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>unit_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a spatial inertia for a uniform-density solid cylinder B about an end-point Bp of the cylinder's axis (see below for more about Bp). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mass</td><td>mass of the solid cylinder (kg). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>radius of cylinder (meters). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>length of cylinder in unit_vector direction (meters). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unit_vector</td><td>unit vector parallel to the axis of the cylinder and directed from Bp to Bcm (B's center of mass), expressed in B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_BBp_B</td><td>B's spatial inertia about Bp, expressed in B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The position from Bp to Bcm is p_BpBcm = length / 2 * unit_vector. </dd>
<dd>
B's rotational inertia about Bp is axially symmetric, meaning B has an equal moment of inertia about any line that both passes through Bp and is perpendicular to unit_vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if density, radius, or length is not positive and finite or if ‖unit_vector‖ is not within 1.0E-14 of 1.0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a215d901a05f95038a906a1383cedeae2" title="Creates a spatial inertia for a uniform density solid cylinder B about its geometric center Bo (which...">SolidCylinderWithMass()</a> to calculate M_BBcm_B, B's spatial inertia about Bcm (B's center of mass). </dd></dl>

</div>
</div>
<a id="aeb07d17fd701017f4d67815c17fc80a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb07d17fd701017f4d67815c17fc80a2">&#9670;&nbsp;</a></span>SolidEllipsoidWithDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; SolidEllipsoidWithDensity </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a spatial inertia for a uniform density solid ellipsoid B about its geometric center Bo (which is coincident with B's center of mass Bcm). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">density</td><td>mass per volume (kg/m³). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>length of ellipsoid semi-axis in the ellipsoid Bx direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>length of ellipsoid semi-axis in the ellipsoid By direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>length of ellipsoid semi-axis in the ellipsoid Bz direction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_BBo_B</td><td>B's spatial inertia about Bo, expressed in B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if density, a, b, or c is not positive and finite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ba5d8b235266f2b5dd38650df184917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba5d8b235266f2b5dd38650df184917">&#9670;&nbsp;</a></span>SolidEllipsoidWithMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; SolidEllipsoidWithMass </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a spatial inertia for a uniform density solid ellipsoid B about its geometric center Bo (which is coincident with B's center of mass Bcm). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mass</td><td>mass of the solid ellipsoid (kg). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>length of ellipsoid semi-axis in the ellipsoid Bx direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>length of ellipsoid semi-axis in the ellipsoid By direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>length of ellipsoid semi-axis in the ellipsoid Bz direction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_BBo_B</td><td>B's spatial inertia about Bo, expressed in B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if mass, a, b, or c is not positive and finite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1354f4723023135536629d866ef5de09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1354f4723023135536629d866ef5de09">&#9670;&nbsp;</a></span>SolidSphereWithDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; SolidSphereWithDensity </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a spatial inertia for a uniform density solid sphere B about its geometric center Bo (which is coincident with B's center of mass Bcm). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">density</td><td>mass per volume (kg/m³). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>sphere's radius (meters). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_BBo</td><td>B's spatial inertia about Bo. Since B's rotational inertia is triaxially symmetric, M_BBo_B = M_BBo_E, i.e., M_BBo expressed in frame B is equal to M_BBo expressed in an arbitrary frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>B's rotational inertia about Bo is triaxially symmetric, meaning B has an equal moment of inertia about any line passing through Bo. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if density or radius is not positive and finite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad207bb84c25f7ac68dcf64ff5763fbee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad207bb84c25f7ac68dcf64ff5763fbee">&#9670;&nbsp;</a></span>SolidSphereWithMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; SolidSphereWithMass </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a spatial inertia for a uniform density solid sphere B about its geometric center Bo (which is coincident with B's center of mass Bcm). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mass</td><td>mass of the solid sphere (kg). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>sphere's radius (meters). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_BBo</td><td>B's spatial inertia about Bo. Since B's rotational inertia is triaxially symmetric, M_BBo_B = M_BBo_E, i.e., M_BBo expressed in frame B is equal to M_BBo expressed in an arbitrary frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>B's rotational inertia about Bo is triaxially symmetric, meaning B has an equal moment of inertia about any line passing through Bo. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if mass or radius is not positive and finite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af24310926c4f3a0604b4ebb341deca84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24310926c4f3a0604b4ebb341deca84">&#9670;&nbsp;</a></span>SolidTetrahedronAboutPointWithDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; SolidTetrahedronAboutPointWithDensity </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a spatial inertia for a uniform density solid tetrahedron B about a point A, from which position vectors to B's 4 vertices B0, B1, B2, B3 are measured (position vectors are all expressed in a common frame E). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">density</td><td>mass per volume (kg/m³). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p0</td><td>position vector p_AB0_E from point A to B0, expressed in E. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>position vector p_AB1_E from point A to B1, expressed in E. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>position vector p_AB2_E from point A to B2, expressed in E. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p3</td><td>position vector p_AB3_E from point A to B3, expressed in E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_BA_E</td><td>B's spatial inertia about point A, expressed in E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In the common case, point A is Eo (the origin of the expressed-in frame E). The example below has point A as Wo (origin of world frame W). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if density is not positive and finite. <div class="fragment"><div class="line"><span class="keywordtype">double</span> density = 1000;</div><div class="line">Vector3&lt;double&gt; p_WoB0_W(1, 0, 0);</div><div class="line">Vector3&lt;double&gt; p_WoB1_W(2, 0, 0);</div><div class="line">Vector3&lt;double&gt; p_WoB2_W(1, 1, 0);</div><div class="line">Vector3&lt;double&gt; p_WoB3_W(1, 0, 1);</div><div class="line">SpatialInertia&lt;double&gt; M_BWo_W =</div><div class="line">    <a class="code" href="classdrake_1_1multibody_1_1_spatial_inertia.html#af24310926c4f3a0604b4ebb341deca84">SpatialInertia&lt;double&gt;::SolidTetrahedronAboutPointWithDensity</a>(</div><div class="line">        density, p_WoB0_W, p_WoB1_W, p_WoB2_W, p_WoB3_W);</div></div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a8d0407ec30127d1a3d4fcb355453485c" title="(Advanced) Creates a spatial inertia for a uniform density solid tetrahedron B about its vertex B0,...">SolidTetrahedronAboutVertexWithDensity()</a> to efficiently calculate a spatial inertia about a vertex of B. </dd></dl>

</div>
</div>
<a id="a8d0407ec30127d1a3d4fcb355453485c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0407ec30127d1a3d4fcb355453485c">&#9670;&nbsp;</a></span>SolidTetrahedronAboutVertexWithDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; SolidTetrahedronAboutVertexWithDensity </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Creates a spatial inertia for a uniform density solid tetrahedron B about its vertex B0, from which position vectors to B's other 3 vertices B1, B2, B3 are measured (position vectors are all expressed in a common frame E). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">density</td><td>mass per volume (kg/m³). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>position vector p_B0B1_E from B0 to B1, expressed in E. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>position vector p_B0B2_E from B0 to B2, expressed in E. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p3</td><td>position vector p_B0B3_E from B0 to B3, expressed in E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_BB0_E</td><td>B's spatial inertia about its vertex B0, expressed in E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if density is not positive and finite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#af24310926c4f3a0604b4ebb341deca84" title="Creates a spatial inertia for a uniform density solid tetrahedron B about a point A,...">SolidTetrahedronAboutPointWithDensity()</a> to calculate a spatial inertia about an arbitrary point. </dd></dl>

</div>
</div>
<a id="a5233380acba42c39c9b741b85660beca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5233380acba42c39c9b741b85660beca">&#9670;&nbsp;</a></span>ThinRodWithMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; ThinRodWithMass </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>unit_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a spatial inertia for a uniform-density thin rod B about its center of mass Bcm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mass</td><td>mass of the rod (units of kg). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>length of the rod (units of meters). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unit_vector</td><td>unit vector defining the rod's axial direction, expressed in B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_BBcm_B</td><td>B's spatial inertia about Bcm, expressed in B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>B's rotational inertia about Bcm is axially symmetric, meaning B has an equal moment of inertia about any line that both passes through Bcm and is perpendicular to unit_vector. B has no (zero) rotational inertia about the line that passes through Bcm and is parallel to unit_vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if mass or length is not positive and finite or if ‖unit_vector‖ is not within 1.0E-14 of 1.0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a97f17f72011d5c06da34f69245ac69bf" title="Creates a spatial inertia for a uniform-density thin rod B about one of its ends.">ThinRodWithMassAboutEnd()</a> to calculate M_BBp_B, B's spatial inertia about Bp (one of the ends of rod B). </dd></dl>

</div>
</div>
<a id="a97f17f72011d5c06da34f69245ac69bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f17f72011d5c06da34f69245ac69bf">&#9670;&nbsp;</a></span>ThinRodWithMassAboutEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt;T&gt; ThinRodWithMassAboutEnd </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>unit_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a spatial inertia for a uniform-density thin rod B about one of its ends. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mass</td><td>mass of the rod (units of kg). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>length of the rod (units of meters). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unit_vector</td><td>unit vector defining the rod's axial direction, expressed in B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">M_BBp_B</td><td>B's spatial inertia about Bp, expressed in B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The position from Bp to Bcm is length / 2 * unit_vector. </dd>
<dd>
B's rotational inertia about Bp is axially symmetric, meaning B has an equal moment of inertia about any line that both passes through Bp and is perpendicular to unit_vector. B has no (zero) rotational inertia about the line that passes through Bp and is parallel to unit_vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if mass or length is not positive and finite or if ‖unit_vector‖ is not within 1.0E-14 of 1.0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html#a5233380acba42c39c9b741b85660beca" title="Creates a spatial inertia for a uniform-density thin rod B about its center of mass Bcm.">ThinRodWithMass()</a> to calculate M_BBcm_B, B's spatial inertia about Bcm (B's center of mass). </dd></dl>

</div>
</div>
<a id="a4d8ac17f8615fe5634f54ad0423c0550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8ac17f8615fe5634f54ad0423c0550">&#9670;&nbsp;</a></span>Zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a> Zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes mass, center of mass and rotational inertia to zero. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a3b6fb089613f2cdc65359c65d5a5d504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6fb089613f2cdc65359c65d5a5d504">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes an instance of <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia.">SpatialInertia</a> into a std::ostream. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/multibody/tree/<a class="el" href="spatial__inertia_8h.html">spatial_inertia.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().value = searchBox.searchLabel;
</script>
</body>
</html>
