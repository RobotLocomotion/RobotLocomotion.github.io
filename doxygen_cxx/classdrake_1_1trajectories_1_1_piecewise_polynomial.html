<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: PiecewisePolynomial&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="https://drake.mit.edu/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="https://drake.mit.edu/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake/tree/master/tutorials">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="sites" value="drake.mit.edu/doxygen_cxx">
  </form>
  <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="sites" value="drake.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 </div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1trajectories_1_1_piecewise_polynomial.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdrake_1_1trajectories_1_1_piecewise_polynomial-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PiecewisePolynomial&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::trajectories::PiecewisePolynomial&lt; T &gt;</h3>

<p>A scalar multi-variate piecewise polynomial. </p>
<p>PiecewisePolynomial represents a list of contiguous segments in a scalar independent variable (typically corresponding to time) with Polynomials defined at each segment. We call the output from evaluating the PiecewisePolynomial at the scalar independent variable "the output", and that output can be either a Eigen MatrixX&lt;T&gt; (if evaluated using <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a19b632df0f98f9aaf224e534fac69ec8" title="Evaluates the PiecewisePolynomial at the given time t.">value()</a>) or a scalar (if evaluated using scalar_value()).</p>
<p>An example of a piecewise polynomial is a function of m segments in time, where a different polynomial is defined for each segment. For a specific example, consider the absolute value function over the interval [-1, 1]. We can define a PiecewisePolynomial over this interval using breaks at t = { -1.0, 0.0, 1.0 }, and "samples" of abs(t).</p>
<div class="fragment"><div class="line"><span class="comment">// Construct the PiecewisePolynomial.</span></div><div class="line"><span class="keyword">const</span> std::vector&lt;double&gt; <a class="code" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a> = { -1.0, 0.0, 1.0 };</div><div class="line">std::vector&lt;Eigen::MatrixXd&gt; samples(3);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; static_cast&lt;int&gt;(<a class="code" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>.size()); ++i) {</div><div class="line">  samples[i].resize(1, 1);</div><div class="line">  samples[i](0, 0) = <a class="code" href="namespacedrake_1_1ad.html#acb7ba0716b6d1d6ee2ee41e0bcf1a134">std::abs</a>(<a class="code" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>[i]);</div><div class="line">}</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> pp =</div><div class="line">     <a class="code" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a6ec39e8128c0da804f03d8fbd17fd843">PiecewisePolynomial&lt;double&gt;::FirstOrderHold</a>(<a class="code" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, samples);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> row = 0, col = 0;</div><div class="line"></div><div class="line"><span class="comment">// Evaluate the PiecewisePolynomial at some values.</span></div><div class="line">std::cout &lt;&lt; pp.value(-.5)(row, col) &lt;&lt; std::endl;    <span class="comment">// Outputs 0.5.</span></div><div class="line">std::cout &lt;&lt; pp.value(0.0)(row, col) &lt;&lt; std::endl;    <span class="comment">// Outputs 0.0;</span></div><div class="line"></div><div class="line"><span class="comment">// Show how we can evaluate the first derivative (outputs -1.0).</span></div><div class="line">std::cout &lt;&lt; pp.derivative(1).value(-.5)(row, col) &lt;&lt; std::endl;</div></div><!-- fragment --><p>A note on terminology. For piecewise-polynomial interpolation, we use <code>breaks</code> to indicate the scalar (e.g. times) which form the boundary of each segment. We use <code>samples</code> to indicate the function value at the <code>breaks</code>, e.g. <code>p(breaks[i]) = samples[i]</code>. The term <code>knot</code> should be reserved for the "(x,y)" coordinate, here <code>knot[i] = (breaks[i], samples[i])</code>, though it is used inconsistently in the interpolation literature (sometimes for <code>breaks</code>, sometimes for <code>samples</code>), so we try to mostly avoid it here.</p>
<p><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html" title="A scalar multi-variate piecewise polynomial.">PiecewisePolynomial</a> objects can be added, subtracted, and multiplied. They cannot be divided because Polynomials are not closed under division.</p>
<dl class="section warning"><dt>Warning</dt><dd>PiecewisePolynomial silently clips input evaluations outside of the range defined by the breaks. So <code>pp.value(-2.0, row, col)</code> in the example above would evaluate to -1.0. See <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a19b632df0f98f9aaf224e534fac69ec8" title="Evaluates the PiecewisePolynomial at the given time t.">value()</a>.</dd></dl>
<p>@tparam_default_scalars </p>
</div>
<p><code>#include &lt;drake/common/trajectories/piecewise_polynomial.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9c5cbf1ba95055937fdb8283769df797"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a></td></tr>
<tr class="separator:a9c5cbf1ba95055937fdb8283769df797"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6a44781cbe3dd6c55234638a1b63d4ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a6a44781cbe3dd6c55234638a1b63d4ef">PiecewisePolynomial</a> ()=default</td></tr>
<tr class="memdesc:a6a44781cbe3dd6c55234638a1b63d4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty piecewise polynomial.  <a href="#a6a44781cbe3dd6c55234638a1b63d4ef">More...</a><br /></td></tr>
<tr class="separator:a6a44781cbe3dd6c55234638a1b63d4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838cb1725eb9ba7896158fa9032ecdcc"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a838cb1725eb9ba7896158fa9032ecdcc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a838cb1725eb9ba7896158fa9032ecdcc">PiecewisePolynomial</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;constant_value)</td></tr>
<tr class="memdesc:a838cb1725eb9ba7896158fa9032ecdcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single segment, constant value constructor over the interval [-∞, ∞].  <a href="#a838cb1725eb9ba7896158fa9032ecdcc">More...</a><br /></td></tr>
<tr class="separator:a838cb1725eb9ba7896158fa9032ecdcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc4d107b331f4e33f2893826c44be27"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a5dc4d107b331f4e33f2893826c44be27">~PiecewisePolynomial</a> () override=default</td></tr>
<tr class="separator:a5dc4d107b331f4e33f2893826c44be27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8743b4bccdaf5d24987b1f76403bbe41"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html">Trajectory</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a8743b4bccdaf5d24987b1f76403bbe41">Clone</a> () const override</td></tr>
<tr class="separator:a8743b4bccdaf5d24987b1f76403bbe41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7f5289922d84e6f35f96bb29ddd09c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a6d7f5289922d84e6f35f96bb29ddd09c">derivative</a> (<a class="el" href="classint.html">int</a> derivative_order=1) const</td></tr>
<tr class="memdesc:a6d7f5289922d84e6f35f96bb29ddd09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a PiecewisePolynomial where each segment is the specified derivative of the corresponding segment in <code>this</code>.  <a href="#a6d7f5289922d84e6f35f96bb29ddd09c">More...</a><br /></td></tr>
<tr class="separator:a6d7f5289922d84e6f35f96bb29ddd09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99a17f5dcb1100c81ee61a088a69db0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#af99a17f5dcb1100c81ee61a088a69db0">integral</a> (const T &amp;value_at_start_time=0.0) const</td></tr>
<tr class="memdesc:af99a17f5dcb1100c81ee61a088a69db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a PiecewisePolynomial that is the indefinite integral of this one.  <a href="#af99a17f5dcb1100c81ee61a088a69db0">More...</a><br /></td></tr>
<tr class="separator:af99a17f5dcb1100c81ee61a088a69db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f629b76cc9d507ef44352c0ca2bfee2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a1f629b76cc9d507ef44352c0ca2bfee2">integral</a> (const Eigen::Ref&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;value_at_start_time) const</td></tr>
<tr class="memdesc:a1f629b76cc9d507ef44352c0ca2bfee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a PiecewisePolynomial that is the indefinite integral of this one.  <a href="#a1f629b76cc9d507ef44352c0ca2bfee2">More...</a><br /></td></tr>
<tr class="separator:a1f629b76cc9d507ef44352c0ca2bfee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644718bb2fb240de962dc3c9a1fdf0dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a644718bb2fb240de962dc3c9a1fdf0dc">empty</a> () const</td></tr>
<tr class="memdesc:a644718bb2fb240de962dc3c9a1fdf0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this trajectory has no breaks/samples/polynomials.  <a href="#a644718bb2fb240de962dc3c9a1fdf0dc">More...</a><br /></td></tr>
<tr class="separator:a644718bb2fb240de962dc3c9a1fdf0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16274d0c316c76ded4b85111b38ece15"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a16274d0c316c76ded4b85111b38ece15">scalarValue</a> (const T &amp;t, Eigen::Index row=0, Eigen::Index col=0) const</td></tr>
<tr class="memdesc:a16274d0c316c76ded4b85111b38ece15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the trajectory at the given time without returning the entire matrix.  <a href="#a16274d0c316c76ded4b85111b38ece15">More...</a><br /></td></tr>
<tr class="separator:a16274d0c316c76ded4b85111b38ece15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b632df0f98f9aaf224e534fac69ec8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a19b632df0f98f9aaf224e534fac69ec8">value</a> (const T &amp;t) const override</td></tr>
<tr class="memdesc:a19b632df0f98f9aaf224e534fac69ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the PiecewisePolynomial at the given time t.  <a href="#a19b632df0f98f9aaf224e534fac69ec8">More...</a><br /></td></tr>
<tr class="separator:a19b632df0f98f9aaf224e534fac69ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069eb195b8a30965d09c68e4ab65f4f4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a069eb195b8a30965d09c68e4ab65f4f4">getPolynomialMatrix</a> (<a class="el" href="classint.html">int</a> segment_index) const</td></tr>
<tr class="memdesc:a069eb195b8a30965d09c68e4ab65f4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the matrix of Polynomials corresponding to the given segment index.  <a href="#a069eb195b8a30965d09c68e4ab65f4f4">More...</a><br /></td></tr>
<tr class="separator:a069eb195b8a30965d09c68e4ab65f4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d300d23d5911b73ccdf36ef9168e5b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#ac5d300d23d5911b73ccdf36ef9168e5b">getPolynomial</a> (<a class="el" href="classint.html">int</a> segment_index, Eigen::Index row=0, Eigen::Index col=0) const</td></tr>
<tr class="memdesc:ac5d300d23d5911b73ccdf36ef9168e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> with the given matrix row and column index that corresponds to the given segment index.  <a href="#ac5d300d23d5911b73ccdf36ef9168e5b">More...</a><br /></td></tr>
<tr class="separator:ac5d300d23d5911b73ccdf36ef9168e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a111a1944f16bb21873433d4b7b31d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#aa5a111a1944f16bb21873433d4b7b31d">getSegmentPolynomialDegree</a> (<a class="el" href="classint.html">int</a> segment_index, Eigen::Index row=0, Eigen::Index col=0) const</td></tr>
<tr class="memdesc:aa5a111a1944f16bb21873433d4b7b31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the degree of the <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> with the given matrix row and column index that corresponds to the given segment index.  <a href="#aa5a111a1944f16bb21873433d4b7b31d">More...</a><br /></td></tr>
<tr class="separator:aa5a111a1944f16bb21873433d4b7b31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa1f1cfff6dcb352d5fbb15a80ee1a9"><td class="memItemLeft" align="right" valign="top">Eigen::Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9aa1f1cfff6dcb352d5fbb15a80ee1a9">rows</a> () const override</td></tr>
<tr class="memdesc:a9aa1f1cfff6dcb352d5fbb15a80ee1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the row count of the output matrices.  <a href="#a9aa1f1cfff6dcb352d5fbb15a80ee1a9">More...</a><br /></td></tr>
<tr class="separator:a9aa1f1cfff6dcb352d5fbb15a80ee1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca8eca2ee324f57170dedfb4b06160b"><td class="memItemLeft" align="right" valign="top">Eigen::Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#adca8eca2ee324f57170dedfb4b06160b">cols</a> () const override</td></tr>
<tr class="memdesc:adca8eca2ee324f57170dedfb4b06160b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the column count of the output matrices.  <a href="#adca8eca2ee324f57170dedfb4b06160b">More...</a><br /></td></tr>
<tr class="separator:adca8eca2ee324f57170dedfb4b06160b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39001029f6f2e13a8890f233254c4709"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a39001029f6f2e13a8890f233254c4709">Reshape</a> (<a class="el" href="classint.html">int</a> <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9aa1f1cfff6dcb352d5fbb15a80ee1a9">rows</a>, <a class="el" href="classint.html">int</a> <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#adca8eca2ee324f57170dedfb4b06160b">cols</a>)</td></tr>
<tr class="memdesc:a39001029f6f2e13a8890f233254c4709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshapes the dimensions of the Eigen::MatrixX&lt;T&gt; returned by <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a19b632df0f98f9aaf224e534fac69ec8" title="Evaluates the PiecewisePolynomial at the given time t.">value()</a>, <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#af2e2fa698b2c37469f44381ec7ae3344" title="Evaluates the derivative of this at the given time t.">EvalDerivative()</a>, etc.  <a href="#a39001029f6f2e13a8890f233254c4709">More...</a><br /></td></tr>
<tr class="separator:a39001029f6f2e13a8890f233254c4709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f4f35bd9afa91ca14283e7c865918f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a59f4f35bd9afa91ca14283e7c865918f">Transpose</a> () const</td></tr>
<tr class="memdesc:a59f4f35bd9afa91ca14283e7c865918f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html" title="A scalar multi-variate piecewise polynomial.">PiecewisePolynomial</a> for which value(t) == this.value(t).transpose().  <a href="#a59f4f35bd9afa91ca14283e7c865918f">More...</a><br /></td></tr>
<tr class="separator:a59f4f35bd9afa91ca14283e7c865918f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45001b70f1a92e1d01778b69bb61adf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a45001b70f1a92e1d01778b69bb61adf3">Block</a> (<a class="el" href="classint.html">int</a> start_row, <a class="el" href="classint.html">int</a> start_col, <a class="el" href="classint.html">int</a> block_rows, <a class="el" href="classint.html">int</a> block_cols) const</td></tr>
<tr class="memdesc:a45001b70f1a92e1d01778b69bb61adf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a trajectory representing a block of size (block_rows, block_cols) starting at (start_row, start_col) from the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html" title="A scalar multi-variate piecewise polynomial.">PiecewisePolynomial</a>.  <a href="#a45001b70f1a92e1d01778b69bb61adf3">More...</a><br /></td></tr>
<tr class="separator:a45001b70f1a92e1d01778b69bb61adf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9607087f0b9ae63e285094756e4ac1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#af9607087f0b9ae63e285094756e4ac1c">operator+=</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;other)</td></tr>
<tr class="memdesc:af9607087f0b9ae63e285094756e4ac1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> to the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code>, storing the result in <code>this</code>.  <a href="#af9607087f0b9ae63e285094756e4ac1c">More...</a><br /></td></tr>
<tr class="separator:af9607087f0b9ae63e285094756e4ac1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d2cefdc8e6443b9710b195b914b680"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a54d2cefdc8e6443b9710b195b914b680">operator-=</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;other)</td></tr>
<tr class="memdesc:a54d2cefdc8e6443b9710b195b914b680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> from the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code>, storing the result in <code>this</code>.  <a href="#a54d2cefdc8e6443b9710b195b914b680">More...</a><br /></td></tr>
<tr class="separator:a54d2cefdc8e6443b9710b195b914b680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f99414ab82e5b4bac51523feb0b711"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a21f99414ab82e5b4bac51523feb0b711">operator *=</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;other)</td></tr>
<tr class="memdesc:a21f99414ab82e5b4bac51523feb0b711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> by the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code> (i.e., a coefficient-wise multiplication), storing the result in <code>this</code>.  <a href="#a21f99414ab82e5b4bac51523feb0b711">More...</a><br /></td></tr>
<tr class="separator:a21f99414ab82e5b4bac51523feb0b711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fce930000d6d534df56d2f94212298"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#ae4fce930000d6d534df56d2f94212298">operator+=</a> (const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;coeff)</td></tr>
<tr class="separator:ae4fce930000d6d534df56d2f94212298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc93abbb14c2b7d6702fadcc72baff6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9fc93abbb14c2b7d6702fadcc72baff6">operator-=</a> (const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;coeff)</td></tr>
<tr class="separator:a9fc93abbb14c2b7d6702fadcc72baff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad838f10606e844eac52b6553ba5acfd0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#ad838f10606e844eac52b6553ba5acfd0">operator+</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;other) const</td></tr>
<tr class="memdesc:ad838f10606e844eac52b6553ba5acfd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> to the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code>.  <a href="#ad838f10606e844eac52b6553ba5acfd0">More...</a><br /></td></tr>
<tr class="separator:ad838f10606e844eac52b6553ba5acfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359271510bcf12db604f2e7572c45839"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a359271510bcf12db604f2e7572c45839">operator-</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;other) const</td></tr>
<tr class="memdesc:a359271510bcf12db604f2e7572c45839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> from the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code>.  <a href="#a359271510bcf12db604f2e7572c45839">More...</a><br /></td></tr>
<tr class="separator:a359271510bcf12db604f2e7572c45839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fb3016c2ae2b3bc37459710539e1fa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#ac3fb3016c2ae2b3bc37459710539e1fa">operator-</a> () const</td></tr>
<tr class="memdesc:ac3fb3016c2ae2b3bc37459710539e1fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements unary minus operator.  <a href="#ac3fb3016c2ae2b3bc37459710539e1fa">More...</a><br /></td></tr>
<tr class="separator:ac3fb3016c2ae2b3bc37459710539e1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547e26c83862bad737713ca1be3d3d84"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a547e26c83862bad737713ca1be3d3d84">operator *</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;other) const</td></tr>
<tr class="memdesc:a547e26c83862bad737713ca1be3d3d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> by the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code> (i.e., a coefficient-wise multiplication).  <a href="#a547e26c83862bad737713ca1be3d3d84">More...</a><br /></td></tr>
<tr class="separator:a547e26c83862bad737713ca1be3d3d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87952ec710e902557114a6d53d39734e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a87952ec710e902557114a6d53d39734e">operator+</a> (const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;coeff) const</td></tr>
<tr class="separator:a87952ec710e902557114a6d53d39734e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd57b84091cef3694aee370fa189735"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9bd57b84091cef3694aee370fa189735">operator-</a> (const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;coeff) const</td></tr>
<tr class="separator:a9bd57b84091cef3694aee370fa189735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7edaa991443e887ca36e0fd20b96c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a5d7edaa991443e887ca36e0fd20b96c7">isApprox</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;other, double tol, const <a class="el" href="namespacedrake.html#af8777bc10296f9d39d52753861110e26">ToleranceType</a> &amp;tol_type=<a class="el" href="namespacedrake.html#af8777bc10296f9d39d52753861110e26af460a96ab20647996c15854794763384">ToleranceType::kRelative</a>) const</td></tr>
<tr class="memdesc:a5d7edaa991443e887ca36e0fd20b96c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a PiecewisePolynomial is approximately equal to this one by calling <a class="el" href="classdrake_1_1_polynomial.html#a11cf4226b2a620c6cbe8d4f953de0891" title="Checks if a Polynomial is approximately equal to this one.">Polynomial&lt;T&gt;::CoefficientsAlmostEqual()</a> on every element of every segment.  <a href="#a5d7edaa991443e887ca36e0fd20b96c7">More...</a><br /></td></tr>
<tr class="separator:a5d7edaa991443e887ca36e0fd20b96c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d7ffe2f4e1a808aaeb76a871f772e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a75d7ffe2f4e1a808aaeb76a871f772e2">ConcatenateInTime</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;other)</td></tr>
<tr class="memdesc:a75d7ffe2f4e1a808aaeb76a871f772e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates <code>other</code> to the end of <code>this</code>.  <a href="#a75d7ffe2f4e1a808aaeb76a871f772e2">More...</a><br /></td></tr>
<tr class="separator:a75d7ffe2f4e1a808aaeb76a871f772e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93013774f250920857c17c083350b57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#ac93013774f250920857c17c083350b57">AppendCubicHermiteSegment</a> (const T &amp;time, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;sample, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;sample_dot)</td></tr>
<tr class="memdesc:ac93013774f250920857c17c083350b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CubicHermite spline construction has a nice property of being incremental (each segment can be solved independently).  <a href="#ac93013774f250920857c17c083350b57">More...</a><br /></td></tr>
<tr class="separator:ac93013774f250920857c17c083350b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603a4e747fb099305c01f8762e8cff23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a603a4e747fb099305c01f8762e8cff23">AppendFirstOrderSegment</a> (const T &amp;time, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;sample)</td></tr>
<tr class="memdesc:a603a4e747fb099305c01f8762e8cff23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a new sample, this method adds one segment to the end of <code>this</code> using a first-order hold, where the start sample is taken as the value at the final break of <code>this</code>.  <a href="#a603a4e747fb099305c01f8762e8cff23">More...</a><br /></td></tr>
<tr class="separator:a603a4e747fb099305c01f8762e8cff23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e900c12b23dd1cb0bccb6d0357db5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a88e900c12b23dd1cb0bccb6d0357db5f">RemoveFinalSegment</a> ()</td></tr>
<tr class="memdesc:a88e900c12b23dd1cb0bccb6d0357db5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the final segment from the trajectory, reducing the number of segments by 1.  <a href="#a88e900c12b23dd1cb0bccb6d0357db5f">More...</a><br /></td></tr>
<tr class="separator:a88e900c12b23dd1cb0bccb6d0357db5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca7568bb098808d681cb14d7fa09f99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#afca7568bb098808d681cb14d7fa09f99">ReverseTime</a> ()</td></tr>
<tr class="memdesc:afca7568bb098808d681cb14d7fa09f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the trajectory so that pp_after(t) = pp_before(-t).  <a href="#afca7568bb098808d681cb14d7fa09f99">More...</a><br /></td></tr>
<tr class="separator:afca7568bb098808d681cb14d7fa09f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923a4ac5ef6f85f444519188d9dbd3e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a923a4ac5ef6f85f444519188d9dbd3e1">ScaleTime</a> (const T &amp;scale)</td></tr>
<tr class="memdesc:a923a4ac5ef6f85f444519188d9dbd3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the time of the trajectory by non-negative <code>scale</code> (use <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#afca7568bb098808d681cb14d7fa09f99" title="Modifies the trajectory so that pp_after(t) = pp_before(-t).">ReverseTime()</a> if you want to also negate time).  <a href="#a923a4ac5ef6f85f444519188d9dbd3e1">More...</a><br /></td></tr>
<tr class="separator:a923a4ac5ef6f85f444519188d9dbd3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728995759fa06a8d1a2b967d313b6d6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a728995759fa06a8d1a2b967d313b6d6b">shiftRight</a> (const T &amp;offset)</td></tr>
<tr class="memdesc:a728995759fa06a8d1a2b967d313b6d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <code>offset</code> to all of the breaks.  <a href="#a728995759fa06a8d1a2b967d313b6d6b">More...</a><br /></td></tr>
<tr class="separator:a728995759fa06a8d1a2b967d313b6d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7863e6bf8a3ccb5335563370305add"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9a7863e6bf8a3ccb5335563370305add">setPolynomialMatrixBlock</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> &amp;replacement, <a class="el" href="classint.html">int</a> segment_index, Eigen::Index row_start=0, Eigen::Index col_start=0)</td></tr>
<tr class="memdesc:a9a7863e6bf8a3ccb5335563370305add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the specified block of the PolynomialMatrix at the given segment index.  <a href="#a9a7863e6bf8a3ccb5335563370305add">More...</a><br /></td></tr>
<tr class="separator:a9a7863e6bf8a3ccb5335563370305add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28dc60d1015ae4d2e946898a2eec5692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a28dc60d1015ae4d2e946898a2eec5692">slice</a> (<a class="el" href="classint.html">int</a> start_segment_index, <a class="el" href="classint.html">int</a> num_segments) const</td></tr>
<tr class="memdesc:a28dc60d1015ae4d2e946898a2eec5692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the PiecewisePolynomial comprising the <code>num_segments</code> segments starting at the specified <code>start_segment_index</code>.  <a href="#a28dc60d1015ae4d2e946898a2eec5692">More...</a><br /></td></tr>
<tr class="separator:a28dc60d1015ae4d2e946898a2eec5692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:acd5823d88e611200dc63daaf05eeb9d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#acd5823d88e611200dc63daaf05eeb9d9">PiecewisePolynomial</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;)=default</td></tr>
<tr class="separator:acd5823d88e611200dc63daaf05eeb9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97030415f23deb1b1244d33b95c1b0fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a97030415f23deb1b1244d33b95c1b0fb">operator=</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;)=default</td></tr>
<tr class="separator:a97030415f23deb1b1244d33b95c1b0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9575eec7fd062e42ed17407a337abc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a8c9575eec7fd062e42ed17407a337abc">PiecewisePolynomial</a> (<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a8c9575eec7fd062e42ed17407a337abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0295b8466f7ead211653b8cddafd8815"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a0295b8466f7ead211653b8cddafd8815">operator=</a> (<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a0295b8466f7ead211653b8cddafd8815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Polynomial-based construction methods.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="polynomial_construction_methods"></a> Various methods for constructing a PiecewisePolynomial using vectors of matrices of polynomials, one for each output dimension. Unlike the coefficient-based methods, the number of polynomials must equal the number of segments, which will be one fewer than the number of breaks.</p>
<p>The following shows how such a PiecewisePolynomial might be constructed and used: </p><div class="fragment"><div class="line"><span class="comment">// Construct the PiecewisePolynomial.</span></div><div class="line"><span class="keyword">const</span> std::vector&lt;double&gt; <a class="code" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a> = { -1.0, 0.0, 1.0 };</div><div class="line"><a class="code" href="namespacedrake.html#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a> t(<span class="stringliteral">&quot;t&quot;</span>);</div><div class="line">std::vector&lt;Polynomiald&gt; polynomials = { -(t*t), (t*t) };</div><div class="line"><span class="keyword">const</span> PiecewisePolynomial&lt;double&gt; pp(polynomials, <a class="code" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>);</div><div class="line"></div><div class="line"><span class="comment">// Evaluate the PiecewisePolynomial at some values.</span></div><div class="line">std::cout &lt;&lt; pp.scalar_value(-1.0) &lt;&lt; std::endl;    <span class="comment">// Outputs -1.0</span></div><div class="line">std::cout &lt;&lt; pp.scalar_value(1.0) &lt;&lt; std::endl;     <span class="comment">// Outputs 1.0</span></div></div><!-- fragment --><p><a class="anchor" id="polynomial_warning"></a><b>WARNING:</b> For robust floating point arithmetic, the polynomial for a segment will be evaluated (using <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a19b632df0f98f9aaf224e534fac69ec8" title="Evaluates the PiecewisePolynomial at the given time t.">value()</a>) by first subtracting the break time from the evaluation time. In other words, when t lies in the half-open interval <code>[breaks[i], breaks[i+1])</code> then: </p><div class="fragment"><div class="line"><a class="code" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a19b632df0f98f9aaf224e534fac69ec8">value</a>(t) == polynomials[i].eval(t - <a class="code" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>[i])</div></div><!-- fragment --><p> meaning that constructing the polynomial like: </p><div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;double&gt; <a class="code" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a> = { 0.0, 1.0, 2.0 };</div><div class="line"><a class="code" href="namespacedrake.html#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a> t(<span class="stringliteral">&quot;t&quot;</span>);</div><div class="line">std::vector&lt;Polynomiald&gt; polynomials = { (t*t), (t*t) };</div><div class="line"><span class="keyword">const</span> PiecewisePolynomial&lt;double&gt; pp(polynomials, <a class="code" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>);</div></div><!-- fragment --><p> would give the following result: </p><div class="fragment"><div class="line"><span class="comment">// Evaluate the PiecewisePolynomial on both sides of a break.</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> row = 0, col = 0;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> eps = 0.5 * std::numeric_limits&lt;double&gt;::epsilon();</div><div class="line">std::cout &lt;&lt; pp.value(1.0-eps)(row, col) &lt;&lt; std::endl;    <span class="comment">// Outputs 1.0</span></div><div class="line">std::cout &lt;&lt; pp.value(1.0+eps)(row, col) &lt;&lt; std::endl;    <span class="comment">// Outputs 1e-32</span></div></div><!-- fragment --><p> because the second polynomial will be evaluated at 1.0+eps minus the break time for that polynomial (1.0), i.e., t=eps. The intended result for the above example can be obtained by shifting the piecewise polynomial like so: </p><div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;double&gt; <a class="code" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a> = { 0.0, 1.0, 2.0 };</div><div class="line"><a class="code" href="namespacedrake.html#ab0a2621977171e1d2d5b64c55141b9b2">Polynomiald</a> t(<span class="stringliteral">&quot;t&quot;</span>);</div><div class="line">std::vector&lt;Polynomiald&gt; polynomials = { (t*t),</div><div class="line">    ((t+<a class="code" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>[1])*(t+<a class="code" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>[1])) };</div><div class="line"><span class="keyword">const</span> PiecewisePolynomial&lt;double&gt; pp(polynomials, <a class="code" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>);</div><div class="line"></div><div class="line"><span class="comment">// Evaluate the PiecewisePolynomial on both sides of a break.</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> eps = 0.5 * std::numeric_limits&lt;double&gt;::epsilon();</div><div class="line">std::cout &lt;&lt; pp.value(1.0-eps)(row, col) &lt;&lt; std::endl;    <span class="comment">// Outputs 1.0</span></div><div class="line">std::cout &lt;&lt; pp.value(1.0+eps)(row, col) &lt;&lt; std::endl;    <span class="comment">// Outputs 1.0</span></div></div><!-- fragment --> </div></td></tr>
<tr class="memitem:a9145f61319cb888cb71fc58cebc8fe38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9145f61319cb888cb71fc58cebc8fe38">PiecewisePolynomial</a> (const std::vector&lt; <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> &gt; &amp;polynomials_matrix, const std::vector&lt; T &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>)</td></tr>
<tr class="memdesc:a9145f61319cb888cb71fc58cebc8fe38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a PiecewisePolynomial using matrix-output Polynomials defined over each segment.  <a href="#a9145f61319cb888cb71fc58cebc8fe38">More...</a><br /></td></tr>
<tr class="separator:a9145f61319cb888cb71fc58cebc8fe38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481736a225b93bd2343445f02c8eafec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a481736a225b93bd2343445f02c8eafec">PiecewisePolynomial</a> (const std::vector&lt; <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt;&gt; &amp;polynomials, const std::vector&lt; T &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>)</td></tr>
<tr class="memdesc:a481736a225b93bd2343445f02c8eafec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a PiecewisePolynomial using scalar-output Polynomials defined over each segment.  <a href="#a481736a225b93bd2343445f02c8eafec">More...</a><br /></td></tr>
<tr class="separator:a481736a225b93bd2343445f02c8eafec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html">PiecewiseTrajectory&lt; T &gt;</a></td></tr>
<tr class="memitem:a80ed62d7a0f2d3eee401cdd29e47d534 inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a80ed62d7a0f2d3eee401cdd29e47d534">~PiecewiseTrajectory</a> () override=default</td></tr>
<tr class="separator:a80ed62d7a0f2d3eee401cdd29e47d534 inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff5241db765b5a4de7c88bb996d39a8 inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4ff5241db765b5a4de7c88bb996d39a8">get_number_of_segments</a> () const</td></tr>
<tr class="separator:a4ff5241db765b5a4de7c88bb996d39a8 inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1019f41dcfe440c98c91029f4b0b0bc0 inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a1019f41dcfe440c98c91029f4b0b0bc0">start_time</a> (<a class="el" href="classint.html">int</a> segment_number) const</td></tr>
<tr class="separator:a1019f41dcfe440c98c91029f4b0b0bc0 inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1604e170d921c073e4fba715622507 inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4c1604e170d921c073e4fba715622507">end_time</a> (<a class="el" href="classint.html">int</a> segment_number) const</td></tr>
<tr class="separator:a4c1604e170d921c073e4fba715622507 inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88c3d4b35f53401069500f721083309 inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#af88c3d4b35f53401069500f721083309">duration</a> (<a class="el" href="classint.html">int</a> segment_number) const</td></tr>
<tr class="separator:af88c3d4b35f53401069500f721083309 inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09cf8e8ad481f69f3cc1969ef491d60 inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#ae09cf8e8ad481f69f3cc1969ef491d60">start_time</a> () const override</td></tr>
<tr class="separator:ae09cf8e8ad481f69f3cc1969ef491d60 inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641bfb18296d6976a000cf31c213dfdf inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a641bfb18296d6976a000cf31c213dfdf">end_time</a> () const override</td></tr>
<tr class="separator:a641bfb18296d6976a000cf31c213dfdf inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854d7d9baf86ffadcceca2620d4b347d inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a854d7d9baf86ffadcceca2620d4b347d">is_time_in_range</a> (const T &amp;t) const</td></tr>
<tr class="memdesc:a854d7d9baf86ffadcceca2620d4b347d inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff <code>t &gt;= getStartTime() &amp;&amp; t &lt;= getEndTime()</code>.  <a href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a854d7d9baf86ffadcceca2620d4b347d">More...</a><br /></td></tr>
<tr class="separator:a854d7d9baf86ffadcceca2620d4b347d inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326ae949f44158da731ef777bba601ec inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a326ae949f44158da731ef777bba601ec">get_segment_index</a> (const T &amp;t) const</td></tr>
<tr class="separator:a326ae949f44158da731ef777bba601ec inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ebde0f5bcaf6df51d6a4d1acc162b5 inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#ae6ebde0f5bcaf6df51d6a4d1acc162b5">get_segment_times</a> () const</td></tr>
<tr class="separator:ae6ebde0f5bcaf6df51d6a4d1acc162b5 inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4ac30a258a47b6ea610f16f4accece inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0a4ac30a258a47b6ea610f16f4accece">segment_number_range_check</a> (<a class="el" href="classint.html">int</a> segment_number) const</td></tr>
<tr class="separator:a0a4ac30a258a47b6ea610f16f4accece inherit pub_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classdrake_1_1trajectories_1_1_trajectory"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdrake_1_1trajectories_1_1_trajectory')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html">Trajectory&lt; T &gt;</a></td></tr>
<tr class="memitem:aec58a75947d06ba435adda6fd990678e inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#aec58a75947d06ba435adda6fd990678e">~Trajectory</a> ()=default</td></tr>
<tr class="separator:aec58a75947d06ba435adda6fd990678e inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7607cc5c56514557ed9441479ae70e71 inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a7607cc5c56514557ed9441479ae70e71">vector_values</a> (const std::vector&lt; T &gt; &amp;t) const</td></tr>
<tr class="memdesc:a7607cc5c56514557ed9441479ae70e71 inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a0e99f338d336c4da23d6d773f4463a52">cols()</a>==1, then evaluates the trajectory at each time <code>t</code>, and returns the results as a Matrix with the ith column corresponding to the ith time.  <a href="classdrake_1_1trajectories_1_1_trajectory.html#a7607cc5c56514557ed9441479ae70e71">More...</a><br /></td></tr>
<tr class="separator:a7607cc5c56514557ed9441479ae70e71 inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9507f1cc6b538dc632d20e3d681bbaba inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a9507f1cc6b538dc632d20e3d681bbaba">has_derivative</a> () const</td></tr>
<tr class="memdesc:a9507f1cc6b538dc632d20e3d681bbaba inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html" title="A Trajectory represents a time-varying matrix, indexed by a single scalar time.">Trajectory</a> provides and implementation for <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#af2e2fa698b2c37469f44381ec7ae3344" title="Evaluates the derivative of this at the given time t.">EvalDerivative()</a> and <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a0a945567d9505ef681194f053ef5a1c2" title="Takes the derivative of this Trajectory.">MakeDerivative()</a>.  <a href="classdrake_1_1trajectories_1_1_trajectory.html#a9507f1cc6b538dc632d20e3d681bbaba">More...</a><br /></td></tr>
<tr class="separator:a9507f1cc6b538dc632d20e3d681bbaba inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e2fa698b2c37469f44381ec7ae3344 inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#af2e2fa698b2c37469f44381ec7ae3344">EvalDerivative</a> (const T &amp;t, <a class="el" href="classint.html">int</a> derivative_order=1) const</td></tr>
<tr class="memdesc:af2e2fa698b2c37469f44381ec7ae3344 inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the derivative of <code>this</code> at the given time <code>t</code>.  <a href="classdrake_1_1trajectories_1_1_trajectory.html#af2e2fa698b2c37469f44381ec7ae3344">More...</a><br /></td></tr>
<tr class="separator:af2e2fa698b2c37469f44381ec7ae3344 inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a945567d9505ef681194f053ef5a1c2 inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html">Trajectory</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a0a945567d9505ef681194f053ef5a1c2">MakeDerivative</a> (<a class="el" href="classint.html">int</a> derivative_order=1) const</td></tr>
<tr class="memdesc:a0a945567d9505ef681194f053ef5a1c2 inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes the derivative of this <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html" title="A Trajectory represents a time-varying matrix, indexed by a single scalar time.">Trajectory</a>.  <a href="classdrake_1_1trajectories_1_1_trajectory.html#a0a945567d9505ef681194f053ef5a1c2">More...</a><br /></td></tr>
<tr class="separator:a0a945567d9505ef681194f053ef5a1c2 inherit pub_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Coefficient-based construction methods.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="coefficient_construction_methods"></a> Various methods for constructing a PiecewisePolynomial using samples of coefficient matrices. Under the hood, PiecewisePolynomial constructs interpolating <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> objects that pass through the sample points. These methods differ by the continuity constraints that they enforce at break points and whether each sample represents a full matrix (versions taking <code>const std::vector&lt;MatrixX&lt;T&gt;&gt;&amp;</code>) or a column vector (versions taking <code>const Eigen::Ref&lt;const MatrixX&lt;T&gt;&gt;&amp;</code>).</p>
<p>These methods will throw <code>std::exception</code> if:</p><ul>
<li>the breaks and samples have different length,</li>
<li>the breaks are not strictly increasing,</li>
<li>the samples have inconsistent dimensions (i.e., the matrices do not all have identical dimensions),</li>
<li>the breaks vector has length smaller than 2. </li>
</ul>
</div></td></tr>
<tr class="memitem:a06278ca4588ba1adb004b84fdfc62f3c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a06278ca4588ba1adb004b84fdfc62f3c">ZeroOrderHold</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples)</td></tr>
<tr class="memdesc:a06278ca4588ba1adb004b84fdfc62f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a piecewise constant PiecewisePolynomial using matrix samples.  <a href="#a06278ca4588ba1adb004b84fdfc62f3c">More...</a><br /></td></tr>
<tr class="separator:a06278ca4588ba1adb004b84fdfc62f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1108c20b0d02730aa202de0115755fb2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a1108c20b0d02730aa202de0115755fb2">ZeroOrderHold</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples)</td></tr>
<tr class="memdesc:a1108c20b0d02730aa202de0115755fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of ZeroOrderHold(breaks, samples) that uses vector samples and Eigen VectorXd/MatrixX&lt;T&gt; arguments.  <a href="#a1108c20b0d02730aa202de0115755fb2">More...</a><br /></td></tr>
<tr class="separator:a1108c20b0d02730aa202de0115755fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec39e8128c0da804f03d8fbd17fd843"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a6ec39e8128c0da804f03d8fbd17fd843">FirstOrderHold</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples)</td></tr>
<tr class="memdesc:a6ec39e8128c0da804f03d8fbd17fd843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a piecewise linear PiecewisePolynomial using matrix samples.  <a href="#a6ec39e8128c0da804f03d8fbd17fd843">More...</a><br /></td></tr>
<tr class="separator:a6ec39e8128c0da804f03d8fbd17fd843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f33ba3caad12ccd64ed6562d3cc33f0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a2f33ba3caad12ccd64ed6562d3cc33f0">FirstOrderHold</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples)</td></tr>
<tr class="memdesc:a2f33ba3caad12ccd64ed6562d3cc33f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of FirstOrderHold(breaks, samples) that uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments.  <a href="#a2f33ba3caad12ccd64ed6562d3cc33f0">More...</a><br /></td></tr>
<tr class="separator:a2f33ba3caad12ccd64ed6562d3cc33f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa360cbd2285db12eb014dc6e34868814"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#aa360cbd2285db12eb014dc6e34868814">CubicShapePreserving</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples, bool zero_end_point_derivatives=false)</td></tr>
<tr class="memdesc:aa360cbd2285db12eb014dc6e34868814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a third order PiecewisePolynomial using vector samples, where each column of <code>samples</code> represents a sample point.  <a href="#aa360cbd2285db12eb014dc6e34868814">More...</a><br /></td></tr>
<tr class="separator:aa360cbd2285db12eb014dc6e34868814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ecdbaf41d941ec12c0b6add7cc32d9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a60ecdbaf41d941ec12c0b6add7cc32d9">CubicShapePreserving</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples, bool zero_end_point_derivatives=false)</td></tr>
<tr class="memdesc:a60ecdbaf41d941ec12c0b6add7cc32d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of CubicShapePreserving(breaks, samples, zero_end_point_derivatives) that uses vector samples and Eigen VectorXd and MatrixX&lt;T&gt; arguments.  <a href="#a60ecdbaf41d941ec12c0b6add7cc32d9">More...</a><br /></td></tr>
<tr class="separator:a60ecdbaf41d941ec12c0b6add7cc32d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3341f2b051ca0d1d376d1da25574b9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#afe3341f2b051ca0d1d376d1da25574b9">CubicWithContinuousSecondDerivatives</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples, const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;sample_dot_at_start, const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;sample_dot_at_end)</td></tr>
<tr class="memdesc:afe3341f2b051ca0d1d376d1da25574b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a third order PiecewisePolynomial using matrix samples.  <a href="#afe3341f2b051ca0d1d376d1da25574b9">More...</a><br /></td></tr>
<tr class="separator:afe3341f2b051ca0d1d376d1da25574b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed61fed2b1bff79c2fb7b083d159a61b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#aed61fed2b1bff79c2fb7b083d159a61b">CubicWithContinuousSecondDerivatives</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;sample_dot_at_start, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;sample_dot_at_end)</td></tr>
<tr class="memdesc:aed61fed2b1bff79c2fb7b083d159a61b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#afe3341f2b051ca0d1d376d1da25574b9" title="Constructs a third order PiecewisePolynomial using matrix samples.">CubicWithContinuousSecondDerivatives()</a> that uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments.  <a href="#aed61fed2b1bff79c2fb7b083d159a61b">More...</a><br /></td></tr>
<tr class="separator:aed61fed2b1bff79c2fb7b083d159a61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5412c17187dde2f8984dcfb3eb67ca1d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a5412c17187dde2f8984dcfb3eb67ca1d">CubicHermite</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples, const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples_dot)</td></tr>
<tr class="memdesc:a5412c17187dde2f8984dcfb3eb67ca1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a third order PiecewisePolynomial using matrix samples and derivatives of samples (<code>samples_dot</code>); each matrix element of <code>samples_dot</code> represents the derivative with respect to the independent variable (e.g., the time derivative) of the corresponding entry in <code>samples</code>.  <a href="#a5412c17187dde2f8984dcfb3eb67ca1d">More...</a><br /></td></tr>
<tr class="separator:a5412c17187dde2f8984dcfb3eb67ca1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77d19bf3de0a1c93d54679d0ba86bef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#aa77d19bf3de0a1c93d54679d0ba86bef">CubicHermite</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples_dot)</td></tr>
<tr class="memdesc:aa77d19bf3de0a1c93d54679d0ba86bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of CubicHermite(breaks, samples, samples_dot) that uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments.  <a href="#aa77d19bf3de0a1c93d54679d0ba86bef">More...</a><br /></td></tr>
<tr class="separator:aa77d19bf3de0a1c93d54679d0ba86bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c09a6d35797ae0eed1de62a97433b9e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a8c09a6d35797ae0eed1de62a97433b9e">CubicWithContinuousSecondDerivatives</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples, bool periodic_end_condition=false)</td></tr>
<tr class="memdesc:a8c09a6d35797ae0eed1de62a97433b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a third order PiecewisePolynomial using matrix samples.  <a href="#a8c09a6d35797ae0eed1de62a97433b9e">More...</a><br /></td></tr>
<tr class="separator:a8c09a6d35797ae0eed1de62a97433b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9172b5dec49b4fdc1a94684a25677d2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#ae9172b5dec49b4fdc1a94684a25677d2">CubicWithContinuousSecondDerivatives</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples, bool periodic_end_condition=false)</td></tr>
<tr class="memdesc:ae9172b5dec49b4fdc1a94684a25677d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of CubicWithContinuousSecondDerivatives(breaks, samples) that uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments.  <a href="#ae9172b5dec49b4fdc1a94684a25677d2">More...</a><br /></td></tr>
<tr class="separator:ae9172b5dec49b4fdc1a94684a25677d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5076a155bf5d04598cd9bf7ec40b0ddf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a5076a155bf5d04598cd9bf7ec40b0ddf">Cubic</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples, bool periodic_end_condition=false)</td></tr>
<tr class="separator:a5076a155bf5d04598cd9bf7ec40b0ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4663545b3fed3eca03235395623d0a2a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a4663545b3fed3eca03235395623d0a2a">LagrangeInterpolatingPolynomial</a> (const std::vector&lt; T &gt; &amp;times, const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples)</td></tr>
<tr class="memdesc:a4663545b3fed3eca03235395623d0a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a polynomial with a <em>single segment</em> of the lowest possible degree that passes through all of the sample points.  <a href="#a4663545b3fed3eca03235395623d0a2a">More...</a><br /></td></tr>
<tr class="separator:a4663545b3fed3eca03235395623d0a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380286fadf3459a3ad22b9704ce134fa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a380286fadf3459a3ad22b9704ce134fa">LagrangeInterpolatingPolynomial</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;times, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;samples)</td></tr>
<tr class="memdesc:a380286fadf3459a3ad22b9704ce134fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of LagrangeInterpolatingPolynomial(times, samples) that uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments.  <a href="#a380286fadf3459a3ad22b9704ce134fa">More...</a><br /></td></tr>
<tr class="separator:a380286fadf3459a3ad22b9704ce134fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html">PiecewiseTrajectory&lt; T &gt;</a></td></tr>
<tr class="memitem:adff893a14b498f0e779c90305602e44d inherit pub_static_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#adff893a14b498f0e779c90305602e44d">RandomSegmentTimes</a> (<a class="el" href="classint.html">int</a> num_segments, std::default_random_engine &amp;generator)</td></tr>
<tr class="separator:adff893a14b498f0e779c90305602e44d inherit pub_static_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_attribs_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classdrake_1_1trajectories_1_1_piecewise_trajectory')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html">PiecewiseTrajectory&lt; T &gt;</a></td></tr>
<tr class="memitem:a0539f01602cd1ab9b25989206d302401 inherit pub_static_attribs_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401">kEpsilonTime</a> = std::numeric_limits&lt;double&gt;::epsilon()</td></tr>
<tr class="memdesc:a0539f01602cd1ab9b25989206d302401 inherit pub_static_attribs_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum delta quantity used for comparing time.  <a href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401">More...</a><br /></td></tr>
<tr class="separator:a0539f01602cd1ab9b25989206d302401 inherit pub_static_attribs_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html">PiecewiseTrajectory&lt; T &gt;</a></td></tr>
<tr class="memitem:a293c775020a0b5f25770dd398ea14f1d inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a293c775020a0b5f25770dd398ea14f1d">PiecewiseTrajectory</a> ()=default</td></tr>
<tr class="separator:a293c775020a0b5f25770dd398ea14f1d inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205b86a6552919d515ba544c185c04c3 inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a205b86a6552919d515ba544c185c04c3">PiecewiseTrajectory</a> (const std::vector&lt; T &gt; &amp;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a>)</td></tr>
<tr class="memdesc:a205b86a6552919d515ba544c185c04c3 inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>breaks</code> increments must be greater or equal to kEpsilonTime.  <a href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a205b86a6552919d515ba544c185c04c3">More...</a><br /></td></tr>
<tr class="separator:a205b86a6552919d515ba544c185c04c3 inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1bc48c32072f8a84aa295528a66440 inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0f1bc48c32072f8a84aa295528a66440">SegmentTimesEqual</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html">PiecewiseTrajectory</a> &amp;b, double tol=<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401">kEpsilonTime</a>) const</td></tr>
<tr class="separator:a0f1bc48c32072f8a84aa295528a66440 inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a71ddfb9ab85211d522ad0e948c426 inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aa1a71ddfb9ab85211d522ad0e948c426">breaks</a> () const</td></tr>
<tr class="separator:aa1a71ddfb9ab85211d522ad0e948c426 inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeabb3c1dcb114550eee132dcebb3a6e inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#aaeabb3c1dcb114550eee132dcebb3a6e">get_mutable_breaks</a> ()</td></tr>
<tr class="separator:aaeabb3c1dcb114550eee132dcebb3a6e inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af360987538c584ed2a7c5ad8e2f3d6e4 inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#af360987538c584ed2a7c5ad8e2f3d6e4">PiecewiseTrajectory</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html">PiecewiseTrajectory</a> &amp;)=default</td></tr>
<tr class="separator:af360987538c584ed2a7c5ad8e2f3d6e4 inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a07ba5dd1adae91520a5c386ee6c1b inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html">PiecewiseTrajectory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a43a07ba5dd1adae91520a5c386ee6c1b">operator=</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html">PiecewiseTrajectory</a> &amp;)=default</td></tr>
<tr class="separator:a43a07ba5dd1adae91520a5c386ee6c1b inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65dc25e24cd2903a0861b9589065c897 inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a65dc25e24cd2903a0861b9589065c897">PiecewiseTrajectory</a> (<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html">PiecewiseTrajectory</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a65dc25e24cd2903a0861b9589065c897 inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3162d0b93cdd9f4259cc7d03b3370e56 inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html">PiecewiseTrajectory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a3162d0b93cdd9f4259cc7d03b3370e56">operator=</a> (<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html">PiecewiseTrajectory</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a3162d0b93cdd9f4259cc7d03b3370e56 inherit pro_methods_classdrake_1_1trajectories_1_1_piecewise_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classdrake_1_1trajectories_1_1_trajectory"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classdrake_1_1trajectories_1_1_trajectory')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html">Trajectory&lt; T &gt;</a></td></tr>
<tr class="memitem:a0d2a23aec55910c9e1102de7ab8c3249 inherit pro_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a0d2a23aec55910c9e1102de7ab8c3249">Trajectory</a> ()=default</td></tr>
<tr class="separator:a0d2a23aec55910c9e1102de7ab8c3249 inherit pro_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b15b4592b800d6cf4d9273f46a2774b inherit pro_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a6b15b4592b800d6cf4d9273f46a2774b">Trajectory</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html">Trajectory</a> &amp;)=default</td></tr>
<tr class="separator:a6b15b4592b800d6cf4d9273f46a2774b inherit pro_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51223614aa5ad65e500cce2625aaf328 inherit pro_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html">Trajectory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a51223614aa5ad65e500cce2625aaf328">operator=</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html">Trajectory</a> &amp;)=default</td></tr>
<tr class="separator:a51223614aa5ad65e500cce2625aaf328 inherit pro_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af752fbd39919690fbbe2110639682be7 inherit pro_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#af752fbd39919690fbbe2110639682be7">Trajectory</a> (<a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html">Trajectory</a> &amp;&amp;)=default</td></tr>
<tr class="separator:af752fbd39919690fbbe2110639682be7 inherit pro_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a03dfabaf0999ebcae4cbf8cde49083 inherit pro_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html">Trajectory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a6a03dfabaf0999ebcae4cbf8cde49083">operator=</a> (<a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html">Trajectory</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a6a03dfabaf0999ebcae4cbf8cde49083 inherit pro_methods_classdrake_1_1trajectories_1_1_trajectory"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9c5cbf1ba95055937fdb8283769df797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5cbf1ba95055937fdb8283769df797">&#9670;&nbsp;</a></span>PolynomialMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt;T&gt; &gt; <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6a44781cbe3dd6c55234638a1b63d4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a44781cbe3dd6c55234638a1b63d4ef">&#9670;&nbsp;</a></span>PiecewisePolynomial() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty piecewise polynomial. </p>

</div>
</div>
<a id="acd5823d88e611200dc63daaf05eeb9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5823d88e611200dc63daaf05eeb9d9">&#9670;&nbsp;</a></span>PiecewisePolynomial() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c9575eec7fd062e42ed17407a337abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9575eec7fd062e42ed17407a337abc">&#9670;&nbsp;</a></span>PiecewisePolynomial() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a838cb1725eb9ba7896158fa9032ecdcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838cb1725eb9ba7896158fa9032ecdcc">&#9670;&nbsp;</a></span>PiecewisePolynomial() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>constant_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Single segment, constant value constructor over the interval [-∞, ∞]. </p>
<p>The constructed PiecewisePolynomial will return <code>constant_value</code> at every evaluated point (i.e., <code>value(t) = constant_value</code> ∀t ∈ [-∞, ∞]). </p>

</div>
</div>
<a id="a9145f61319cb888cb71fc58cebc8fe38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9145f61319cb888cb71fc58cebc8fe38">&#9670;&nbsp;</a></span>PiecewisePolynomial() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polynomials_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a PiecewisePolynomial using matrix-output Polynomials defined over each segment. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>polynomials.size() == breaks.size() - 1</code> </dd></dl>

</div>
</div>
<a id="a481736a225b93bd2343445f02c8eafec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481736a225b93bd2343445f02c8eafec">&#9670;&nbsp;</a></span>PiecewisePolynomial() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>polynomials</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a PiecewisePolynomial using scalar-output Polynomials defined over each segment. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>polynomials.size() == breaks.size() - 1</code> </dd></dl>

</div>
</div>
<a id="a5dc4d107b331f4e33f2893826c44be27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc4d107b331f4e33f2893826c44be27">&#9670;&nbsp;</a></span>~PiecewisePolynomial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac93013774f250920857c17c083350b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93013774f250920857c17c083350b57">&#9670;&nbsp;</a></span>AppendCubicHermiteSegment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AppendCubicHermiteSegment </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sample_dot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The CubicHermite spline construction has a nice property of being incremental (each segment can be solved independently). </p>
<p>Given a new sample and it's derivative, this method adds one segment to the end of <code>this</code> where the start sample and derivative are taken as the value and derivative at the final break of <code>this</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this</code> is not <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a644718bb2fb240de962dc3c9a1fdf0dc" title="Returns true if this trajectory has no breaks/samples/polynomials.">empty()</a> </dd>
<dd>
<code>time</code> &gt; <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4c1604e170d921c073e4fba715622507">end_time()</a> </dd>
<dd>
<code>sample</code> and <code>sample_dot</code> must have size <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9aa1f1cfff6dcb352d5fbb15a80ee1a9" title="Returns the row count of the output matrices.">rows()</a> x <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#adca8eca2ee324f57170dedfb4b06160b" title="Returns the column count of the output matrices.">cols()</a>. </dd></dl>

</div>
</div>
<a id="a603a4e747fb099305c01f8762e8cff23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603a4e747fb099305c01f8762e8cff23">&#9670;&nbsp;</a></span>AppendFirstOrderSegment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AppendFirstOrderSegment </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a new sample, this method adds one segment to the end of <code>this</code> using a first-order hold, where the start sample is taken as the value at the final break of <code>this</code>. </p>

</div>
</div>
<a id="a45001b70f1a92e1d01778b69bb61adf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45001b70f1a92e1d01778b69bb61adf3">&#9670;&nbsp;</a></span>Block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> Block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>start_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>start_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>block_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>block_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a trajectory representing a block of size (block_rows, block_cols) starting at (start_row, start_col) from the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html" title="A scalar multi-variate piecewise polynomial.">PiecewisePolynomial</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html" title="A scalar multi-variate piecewise polynomial.">PiecewisePolynomial</a> such that ret.value(t) = this.value(t).block(i,j,p,q); </dd></dl>

</div>
</div>
<a id="a8743b4bccdaf5d24987b1f76403bbe41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8743b4bccdaf5d24987b1f76403bbe41">&#9670;&nbsp;</a></span>Clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html">Trajectory</a>&lt;T&gt; &gt; Clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A deep copy of this <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html" title="A Trajectory represents a time-varying matrix, indexed by a single scalar time.">Trajectory</a>. </dd></dl>

<p>Implements <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a5921e7a9f7532c682fd111d829f0258e">Trajectory&lt; T &gt;</a>.</p>

</div>
</div>
<a id="adca8eca2ee324f57170dedfb4b06160b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca8eca2ee324f57170dedfb4b06160b">&#9670;&nbsp;</a></span>cols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Index cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the column count of the output matrices. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a644718bb2fb240de962dc3c9a1fdf0dc" title="Returns true if this trajectory has no breaks/samples/polynomials.">empty()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a0e99f338d336c4da23d6d773f4463a52">Trajectory&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a75d7ffe2f4e1a808aaeb76a871f772e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d7ffe2f4e1a808aaeb76a871f772e2">&#9670;&nbsp;</a></span>ConcatenateInTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ConcatenateInTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates <code>other</code> to the end of <code>this</code>. </p>
<dl class="section warning"><dt>Warning</dt><dd>The resulting PiecewisePolynomial will only be continuous to the degree that the first <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> of <code>other</code> is continuous with the last <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> of <code>this</code>. See warning about evaluating discontinuous derivatives at breaks in <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a6d7f5289922d84e6f35f96bb29ddd09c" title="Returns a PiecewisePolynomial where each segment is the specified derivative of the corresponding seg...">derivative()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>PiecewisePolynomial instance to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if trajectories' dimensions do not match each other (either <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9aa1f1cfff6dcb352d5fbb15a80ee1a9" title="Returns the row count of the output matrices.">rows()</a> or <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#adca8eca2ee324f57170dedfb4b06160b" title="Returns the column count of the output matrices.">cols()</a> does not match between this and <code>other</code>). </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <code>this-&gt;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4c1604e170d921c073e4fba715622507">end_time()</a></code> and <code>other-&gt;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a1019f41dcfe440c98c91029f4b0b0bc0">start_time()</a></code> are not within <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401" title="Minimum delta quantity used for comparing time.">PiecewiseTrajectory&lt;T&gt;::kEpsilonTime</a> from each other. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5076a155bf5d04598cd9bf7ec40b0ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5076a155bf5d04598cd9bf7ec40b0ddf">&#9670;&nbsp;</a></span>Cubic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt;T&gt; Cubic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>periodic_end_condition</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5412c17187dde2f8984dcfb3eb67ca1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5412c17187dde2f8984dcfb3eb67ca1d">&#9670;&nbsp;</a></span>CubicHermite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt;T&gt; CubicHermite </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples_dot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a third order PiecewisePolynomial using matrix samples and derivatives of samples (<code>samples_dot</code>); each matrix element of <code>samples_dot</code> represents the derivative with respect to the independent variable (e.g., the time derivative) of the corresponding entry in <code>samples</code>. </p>
<p>Each segment is fully specified by <code>samples</code> and <code>sample_dot</code> at both ends. Second derivatives are not continuous. </p>

</div>
</div>
<a id="aa77d19bf3de0a1c93d54679d0ba86bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa77d19bf3de0a1c93d54679d0ba86bef">&#9670;&nbsp;</a></span>CubicHermite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt;T&gt; CubicHermite </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples_dot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of CubicHermite(breaks, samples, samples_dot) that uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. </p>
<p>Corresponding columns of <code>samples</code> and <code>samples_dot</code> are used as the sample point and independent variable derivative, respectively.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>samples.cols() == samples_dot.cols() == breaks.size()</code>. </dd></dl>

</div>
</div>
<a id="aa360cbd2285db12eb014dc6e34868814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa360cbd2285db12eb014dc6e34868814">&#9670;&nbsp;</a></span>CubicShapePreserving() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt;T&gt; CubicShapePreserving </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zero_end_point_derivatives</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a third order PiecewisePolynomial using vector samples, where each column of <code>samples</code> represents a sample point. </p>
<p>First derivatives are chosen to be "shape preserving", i.e. if <code>samples</code> is monotonic within some interval, the interpolated data will also be monotonic. The second derivative is not guaranteed to be smooth across the entire spline.</p>
<p>MATLAB calls this method "pchip" (short for "Piecewise Cubic Hermite
Interpolating Polynomial"), and provides a nice description in their documentation. <a href="http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf">http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf</a> is also a good reference.</p>
<p>If <code>zero_end_point_derivatives</code> is <code>false</code>, the first and last first derivative is chosen using a non-centered, shape-preserving three-point formulae. See equation (2.10) in the following reference for more details. <a href="http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf">http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf</a> If <code>zero_end_point_derivatives</code> is <code>true</code>, they are set to zeros.</p>
<p>If <code>zero_end_point_derivatives</code> is <code>false</code>, <code>breaks</code> and <code>samples</code> must have at least 3 elements for the algorithm to determine the first derivatives.</p>
<p>If <code>zero_end_point_derivatives</code> is <code>true</code>, <code>breaks</code> and <code>samples</code> may have 2 or more elements. For the 2 elements case, the result is equivalent to computing a cubic polynomial whose values are given by <code>samples</code>, and derivatives set to zero.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if:<ul>
<li><code>breaks</code> has length smaller than 3 and <code>zero_end_point_derivatives</code> is <code>false</code>,</li>
<li><code>breaks</code> has length smaller than 2 and <code>zero_end_point_derivatives</code> is true.</li>
</ul>
</td></tr>
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60ecdbaf41d941ec12c0b6add7cc32d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ecdbaf41d941ec12c0b6add7cc32d9">&#9670;&nbsp;</a></span>CubicShapePreserving() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt;T&gt; CubicShapePreserving </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>zero_end_point_derivatives</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of CubicShapePreserving(breaks, samples, zero_end_point_derivatives) that uses vector samples and Eigen VectorXd and MatrixX&lt;T&gt; arguments. </p>
<p>Each column of <code>samples</code> represents a sample point.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>samples.cols() == breaks.size()</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe3341f2b051ca0d1d376d1da25574b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3341f2b051ca0d1d376d1da25574b9">&#9670;&nbsp;</a></span>CubicWithContinuousSecondDerivatives() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt;T&gt; CubicWithContinuousSecondDerivatives </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sample_dot_at_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sample_dot_at_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a third order PiecewisePolynomial using matrix samples. </p>
<p>The PiecewisePolynomial is constructed such that the interior segments have the same value, first and second derivatives at <code>breaks</code>. <code>sample_dot_at_start</code> and <code>sample_dot_at_end</code> are used for the first and last first derivatives.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>sample_dot_at_start</code> or <code>sample_dot_at_end</code> and <code>samples</code> have inconsistent dimensions. </td></tr>
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed61fed2b1bff79c2fb7b083d159a61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed61fed2b1bff79c2fb7b083d159a61b">&#9670;&nbsp;</a></span>CubicWithContinuousSecondDerivatives() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt;T&gt; CubicWithContinuousSecondDerivatives </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sample_dot_at_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sample_dot_at_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#afe3341f2b051ca0d1d376d1da25574b9" title="Constructs a third order PiecewisePolynomial using matrix samples.">CubicWithContinuousSecondDerivatives()</a> that uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. </p>
<p>Each column of <code>samples</code> represents a sample point.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>samples.cols() == breaks.size()</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c09a6d35797ae0eed1de62a97433b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c09a6d35797ae0eed1de62a97433b9e">&#9670;&nbsp;</a></span>CubicWithContinuousSecondDerivatives() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt;T&gt; CubicWithContinuousSecondDerivatives </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>periodic_end_condition</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a third order PiecewisePolynomial using matrix samples. </p>
<p>The PiecewisePolynomial is constructed such that the interior segments have the same value, first and second derivatives at <code>breaks</code>. If <code>periodic_end_condition</code> is <code>false</code> (default), then the "Not-a-sample" end condition is used here, which means the third derivatives are continuous for the first two and last two segments. If <code>periodic_end_condition</code> is <code>true</code>, then the first and second derivatives between the end of the last segment and the beginning of the first segment will be continuous. Note that the periodic end condition does not require the first and last sample to be collocated, nor does it add an additional sample to connect the first and last segments. Only first and second derivative continuity is enforced. See <a href="https://en.wikipedia.org/wiki/Spline_interpolation">https://en.wikipedia.org/wiki/Spline_interpolation</a> and <a href="https://www.math.uh.edu/~jingqiu/math4364/spline.pdf">https://www.math.uh.edu/~jingqiu/math4364/spline.pdf</a> for more about cubic splines and their end conditions. The MATLAB docs for methods "spline" and "csape" are also good references.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>breaks</code> and <code>samples</code> must have at least 3 elements. If <code>periodic_end_condition</code> is <code>true</code>, then for two samples, it would produce a straight line (use <code>FirstOrderHold</code> for this instead), and if <code>periodic_end_condition</code> is <code>false</code> the problem is ill-defined. </dd></dl>

</div>
</div>
<a id="ae9172b5dec49b4fdc1a94684a25677d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9172b5dec49b4fdc1a94684a25677d2">&#9670;&nbsp;</a></span>CubicWithContinuousSecondDerivatives() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt;T&gt; CubicWithContinuousSecondDerivatives </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>periodic_end_condition</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of CubicWithContinuousSecondDerivatives(breaks, samples) that uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. </p>
<p>Each column of <code>samples</code> represents a sample point.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>samples.cols() == breaks.size()</code>. </dd></dl>

</div>
</div>
<a id="a6d7f5289922d84e6f35f96bb29ddd09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7f5289922d84e6f35f96bb29ddd09c">&#9670;&nbsp;</a></span>derivative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt;T&gt; derivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>derivative_order</em> = <code>1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a PiecewisePolynomial where each segment is the specified derivative of the corresponding segment in <code>this</code>. </p>
<p>Any rules or limitations of Polynomial::derivative() also apply to this function.</p>
<p>Derivatives evaluated at non-differentiable points return the value at the left hand side of the interval. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">derivative_order</td><td>The order of the derivative, namely, if <code>derivative_order</code> = n, the n'th derivative of the polynomial will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>In the event of discontinuous derivatives evaluated at breaks, it is not defined which polynomial (i.e., to the left or right of the break) will be the one that is evaluated at the break. </dd></dl>

</div>
</div>
<a id="a644718bb2fb240de962dc3c9a1fdf0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644718bb2fb240de962dc3c9a1fdf0dc">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this trajectory has no breaks/samples/polynomials. </p>

</div>
</div>
<a id="a6ec39e8128c0da804f03d8fbd17fd843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec39e8128c0da804f03d8fbd17fd843">&#9670;&nbsp;</a></span>FirstOrderHold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt;T&gt; FirstOrderHold </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a piecewise linear PiecewisePolynomial using matrix samples. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f33ba3caad12ccd64ed6562d3cc33f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f33ba3caad12ccd64ed6562d3cc33f0">&#9670;&nbsp;</a></span>FirstOrderHold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt;T&gt; FirstOrderHold </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of FirstOrderHold(breaks, samples) that uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. </p>
<p>Each column of <code>samples</code> represents a sample point.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>samples.cols() == breaks.size()</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5d300d23d5911b73ccdf36ef9168e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d300d23d5911b73ccdf36ef9168e5b">&#9670;&nbsp;</a></span>getPolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt;T&gt;&amp; getPolynomial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>segment_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index&#160;</td>
          <td class="paramname"><em>row</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index&#160;</td>
          <td class="paramname"><em>col</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> with the given matrix row and column index that corresponds to the given segment index. </p>
<p>Equivalent to <code>getPolynomialMatrix(segment_index)(row, col)</code>. </p><dl class="section note"><dt>Note</dt><dd>Calls <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0a4ac30a258a47b6ea610f16f4accece">PiecewiseTrajectory&lt;T&gt;::segment_number_range_check()</a> to validate <code>segment_index</code>. </dd></dl>

</div>
</div>
<a id="a069eb195b8a30965d09c68e4ab65f4f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069eb195b8a30965d09c68e4ab65f4f4">&#9670;&nbsp;</a></span>getPolynomialMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a>&amp; getPolynomialMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>segment_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the matrix of Polynomials corresponding to the given segment index. </p>
<dl class="section warning"><dt>Warning</dt><dd><code>segment_index</code> is not checked for validity. </dd></dl>

</div>
</div>
<a id="aa5a111a1944f16bb21873433d4b7b31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a111a1944f16bb21873433d4b7b31d">&#9670;&nbsp;</a></span>getSegmentPolynomialDegree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> getSegmentPolynomialDegree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>segment_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index&#160;</td>
          <td class="paramname"><em>row</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index&#160;</td>
          <td class="paramname"><em>col</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the degree of the <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> with the given matrix row and column index that corresponds to the given segment index. </p>
<p>Equivalent to <code>getPolynomial(segment_index, row, col).GetDegree()</code>. </p>

</div>
</div>
<a id="af99a17f5dcb1100c81ee61a088a69db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af99a17f5dcb1100c81ee61a088a69db0">&#9670;&nbsp;</a></span>integral() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt;T&gt; integral </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value_at_start_time</em> = <code>0.0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a PiecewisePolynomial that is the indefinite integral of this one. </p>
<p>Any rules or limitations of Polynomial::integral() also apply to this function.</p>
<p>If <code>value_at_start_time</code> is given, it does the following only for the first segment: adds that constant as the constant term (zeroth-order coefficient) of the resulting <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>

</div>
</div>
<a id="a1f629b76cc9d507ef44352c0ca2bfee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f629b76cc9d507ef44352c0ca2bfee2">&#9670;&nbsp;</a></span>integral() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt;T&gt; integral </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>value_at_start_time</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a PiecewisePolynomial that is the indefinite integral of this one. </p>
<p>Any rules or limitations of Polynomial::integral() also apply to this function.</p>
<p>If <code>value_at_start_time</code> is given, it does the following only for the first segment: adds <code>value_at_start_time(row,col)</code> as the constant term (zeroth-order coefficient) of the resulting <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>

</div>
</div>
<a id="a5d7edaa991443e887ca36e0fd20b96c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7edaa991443e887ca36e0fd20b96c7">&#9670;&nbsp;</a></span>isApprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isApprox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#af8777bc10296f9d39d52753861110e26">ToleranceType</a> &amp;&#160;</td>
          <td class="paramname"><em>tol_type</em> = <code><a class="el" href="namespacedrake.html#af8777bc10296f9d39d52753861110e26af460a96ab20647996c15854794763384">ToleranceType::kRelative</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a PiecewisePolynomial is approximately equal to this one by calling <a class="el" href="classdrake_1_1_polynomial.html#a11cf4226b2a620c6cbe8d4f953de0891" title="Checks if a Polynomial is approximately equal to this one.">Polynomial&lt;T&gt;::CoefficientsAlmostEqual()</a> on every element of every segment. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1_polynomial.html#a11cf4226b2a620c6cbe8d4f953de0891" title="Checks if a Polynomial is approximately equal to this one.">Polynomial&lt;T&gt;::CoefficientsAlmostEqual()</a>. </dd></dl>

</div>
</div>
<a id="a4663545b3fed3eca03235395623d0a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4663545b3fed3eca03235395623d0a2a">&#9670;&nbsp;</a></span>LagrangeInterpolatingPolynomial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> LagrangeInterpolatingPolynomial </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a polynomial with a <em>single segment</em> of the lowest possible degree that passes through all of the sample points. </p>
<p>See "polynomial
interpolation" and/or "Lagrange polynomial" on Wikipedia for more information. </p><dl class="section pre"><dt>Precondition</dt><dd><code>times</code> must be monotonically increasing. </dd>
<dd>
<code>samples.size() == times.size()</code>. </dd></dl>

</div>
</div>
<a id="a380286fadf3459a3ad22b9704ce134fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380286fadf3459a3ad22b9704ce134fa">&#9670;&nbsp;</a></span>LagrangeInterpolatingPolynomial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt;T&gt; LagrangeInterpolatingPolynomial </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of LagrangeInterpolatingPolynomial(times, samples) that uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. </p>
<p>Each column of <code>samples</code> represents a sample point.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>samples.cols() == times.size()</code>. </dd></dl>

</div>
</div>
<a id="a547e26c83862bad737713ca1be3d3d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a547e26c83862bad737713ca1be3d3d84">&#9670;&nbsp;</a></span>operator *()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> by the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code> (i.e., a coefficient-wise multiplication). </p>
<p>If <code>this</code> corresponds to t² and <code>other</code> corresponds to t³, <code>this *= other</code> will correspond to t⁵. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if every element of <code>other.get_segment_times()</code> is not within <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401" title="Minimum delta quantity used for comparing time.">PiecewiseTrajectory::kEpsilonTime</a> from `this-&gt;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#ae6ebde0f5bcaf6df51d6a4d1acc162b5">get_segment_times()</a>1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21f99414ab82e5b4bac51523feb0b711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f99414ab82e5b4bac51523feb0b711">&#9670;&nbsp;</a></span>operator *=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&amp; operator *= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> by the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code> (i.e., a coefficient-wise multiplication), storing the result in <code>this</code>. </p>
<p>If <code>this</code> corresponds to t² and <code>other</code> corresponds to t³, <code>this *= other</code> will correspond to t⁵. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if every element of <code>other.get_segment_times()</code> is not within <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401" title="Minimum delta quantity used for comparing time.">PiecewiseTrajectory::kEpsilonTime</a> from `this-&gt;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#ae6ebde0f5bcaf6df51d6a4d1acc162b5">get_segment_times()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad838f10606e844eac52b6553ba5acfd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad838f10606e844eac52b6553ba5acfd0">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> to the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code>. </p>
<p>If <code>this</code> corresponds to t² and <code>other</code> corresponds to t³, <code>this + other</code> will correspond to t³ + t². </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if every element of <code>other.get_segment_times()</code> is not within <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401" title="Minimum delta quantity used for comparing time.">PiecewiseTrajectory::kEpsilonTime</a> from `this-&gt;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#ae6ebde0f5bcaf6df51d6a4d1acc162b5">get_segment_times()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87952ec710e902557114a6d53d39734e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87952ec710e902557114a6d53d39734e">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>coeff</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af9607087f0b9ae63e285094756e4ac1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9607087f0b9ae63e285094756e4ac1c">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> to the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code>, storing the result in <code>this</code>. </p>
<p>If <code>this</code> corresponds to t² and <code>other</code> corresponds to t³, <code>this += other</code> will correspond to t³ + t². </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if every element of <code>other.get_segment_times()</code> is not within <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401" title="Minimum delta quantity used for comparing time.">PiecewiseTrajectory::kEpsilonTime</a> from `this-&gt;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#ae6ebde0f5bcaf6df51d6a4d1acc162b5">get_segment_times()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4fce930000d6d534df56d2f94212298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4fce930000d6d534df56d2f94212298">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>coeff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a359271510bcf12db604f2e7572c45839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359271510bcf12db604f2e7572c45839">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> from the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code>. </p>
<p>If <code>this</code> corresponds to t² and <code>other</code> corresponds to t³, <code>this - other</code> will correspond to t² - t³. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if every element of <code>other.get_segment_times()</code> is not within <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401" title="Minimum delta quantity used for comparing time.">PiecewiseTrajectory::kEpsilonTime</a> from `this-&gt;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#ae6ebde0f5bcaf6df51d6a4d1acc162b5">get_segment_times()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3fb3016c2ae2b3bc37459710539e1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3fb3016c2ae2b3bc37459710539e1fa">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements unary minus operator. </p>
<p>Multiplies each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in <code>this</code> by -1. </p>

</div>
</div>
<a id="a9bd57b84091cef3694aee370fa189735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd57b84091cef3694aee370fa189735">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>coeff</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54d2cefdc8e6443b9710b195b914b680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d2cefdc8e6443b9710b195b914b680">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts each <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>other</code> from the corresponding <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in the PolynomialMatrix of <code>this</code>, storing the result in <code>this</code>. </p>
<p>If <code>this</code> corresponds to t² and <code>other</code> corresponds to t³, <code>this -= other</code> will correspond to t² - t³. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if every element of <code>other.get_segment_times()</code> is not within <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0539f01602cd1ab9b25989206d302401" title="Minimum delta quantity used for comparing time.">PiecewiseTrajectory::kEpsilonTime</a> from `this-&gt;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#ae6ebde0f5bcaf6df51d6a4d1acc162b5">get_segment_times()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fc93abbb14c2b7d6702fadcc72baff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc93abbb14c2b7d6702fadcc72baff6">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>coeff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97030415f23deb1b1244d33b95c1b0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97030415f23deb1b1244d33b95c1b0fb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0295b8466f7ead211653b8cddafd8815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0295b8466f7ead211653b8cddafd8815">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a88e900c12b23dd1cb0bccb6d0357db5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e900c12b23dd1cb0bccb6d0357db5f">&#9670;&nbsp;</a></span>RemoveFinalSegment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RemoveFinalSegment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the final segment from the trajectory, reducing the number of segments by 1. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>this</code> is not <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a644718bb2fb240de962dc3c9a1fdf0dc" title="Returns true if this trajectory has no breaks/samples/polynomials.">empty()</a> </dd></dl>

</div>
</div>
<a id="a39001029f6f2e13a8890f233254c4709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39001029f6f2e13a8890f233254c4709">&#9670;&nbsp;</a></span>Reshape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reshape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reshapes the dimensions of the Eigen::MatrixX&lt;T&gt; returned by <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a19b632df0f98f9aaf224e534fac69ec8" title="Evaluates the PiecewisePolynomial at the given time t.">value()</a>, <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#af2e2fa698b2c37469f44381ec7ae3344" title="Evaluates the derivative of this at the given time t.">EvalDerivative()</a>, etc. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>rows</code> x <code>cols</code> must equal this.rows() * this.cols(). </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Eigen::PlainObjectBase::resize(). </dd></dl>

</div>
</div>
<a id="afca7568bb098808d681cb14d7fa09f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca7568bb098808d681cb14d7fa09f99">&#9670;&nbsp;</a></span>ReverseTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReverseTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the trajectory so that pp_after(t) = pp_before(-t). </p>
<dl class="section note"><dt>Note</dt><dd>The new trajectory will evaluate differently at precisely the break points if the original trajectory was discontinuous at the break points. This is because the segments are defined on the half-open intervals [breaks(i), breaks(i+1)), and the order of the breaks have been reversed. </dd></dl>

</div>
</div>
<a id="a9aa1f1cfff6dcb352d5fbb15a80ee1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa1f1cfff6dcb352d5fbb15a80ee1a9">&#9670;&nbsp;</a></span>rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Index rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the row count of the output matrices. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a644718bb2fb240de962dc3c9a1fdf0dc" title="Returns true if this trajectory has no breaks/samples/polynomials.">empty()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a857db071d9bf847d026ba7046aa9744e">Trajectory&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a16274d0c316c76ded4b85111b38ece15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16274d0c316c76ded4b85111b38ece15">&#9670;&nbsp;</a></span>scalarValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T scalarValue </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index&#160;</td>
          <td class="paramname"><em>row</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index&#160;</td>
          <td class="paramname"><em>col</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the trajectory at the given time without returning the entire matrix. </p>
<p>Equivalent to value(t)(row, col). </p><dl class="section warning"><dt>Warning</dt><dd>See warnings in <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a19b632df0f98f9aaf224e534fac69ec8" title="Evaluates the PiecewisePolynomial at the given time t.">value()</a>. </dd></dl>

</div>
</div>
<a id="a923a4ac5ef6f85f444519188d9dbd3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923a4ac5ef6f85f444519188d9dbd3e1">&#9670;&nbsp;</a></span>ScaleTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ScaleTime </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales the time of the trajectory by non-negative <code>scale</code> (use <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#afca7568bb098808d681cb14d7fa09f99" title="Modifies the trajectory so that pp_after(t) = pp_before(-t).">ReverseTime()</a> if you want to also negate time). </p>
<p>The resulting polynomial evaluates to pp_after(t) = pp_before(t/scale).</p>
<p>As an example, <code>scale</code>=2 will result in a trajectory that is twice as long (<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a1019f41dcfe440c98c91029f4b0b0bc0">start_time()</a> and <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4c1604e170d921c073e4fba715622507">end_time()</a> have both doubled). </p>

</div>
</div>
<a id="a9a7863e6bf8a3ccb5335563370305add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7863e6bf8a3ccb5335563370305add">&#9670;&nbsp;</a></span>setPolynomialMatrixBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setPolynomialMatrixBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#a9c5cbf1ba95055937fdb8283769df797">PolynomialMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>segment_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index&#160;</td>
          <td class="paramname"><em>row_start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Index&#160;</td>
          <td class="paramname"><em>col_start</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the specified block of the PolynomialMatrix at the given segment index. </p>
<dl class="section note"><dt>Note</dt><dd>Calls <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0a4ac30a258a47b6ea610f16f4accece">PiecewiseTrajectory&lt;T&gt;::segment_number_range_check()</a> to validate <code>segment_index</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This code relies upon Eigen to verify that the replacement block is not too large. </dd></dl>

</div>
</div>
<a id="a728995759fa06a8d1a2b967d313b6d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a728995759fa06a8d1a2b967d313b6d6b">&#9670;&nbsp;</a></span>shiftRight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void shiftRight </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds <code>offset</code> to all of the breaks. </p>
<p><code>offset</code> need not be a non-negative number. The resulting polynomial will evaluate to pp_after(t) = pp_before(t-offset).</p>
<p>As an example, <code>offset</code>=2 will result in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a1019f41dcfe440c98c91029f4b0b0bc0">start_time()</a> and <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a4c1604e170d921c073e4fba715622507">end_time()</a> being 2 seconds later. </p>

</div>
</div>
<a id="a28dc60d1015ae4d2e946898a2eec5692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28dc60d1015ae4d2e946898a2eec5692">&#9670;&nbsp;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>start_segment_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_segments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the PiecewisePolynomial comprising the <code>num_segments</code> segments starting at the specified <code>start_segment_index</code>. </p>
<dl class="section note"><dt>Note</dt><dd>Calls <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_trajectory.html#a0a4ac30a258a47b6ea610f16f4accece">PiecewiseTrajectory&lt;T&gt;::segment_number_range_check()</a> to validate <code>segment_index</code>. </dd></dl>

</div>
</div>
<a id="a59f4f35bd9afa91ca14283e7c865918f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f4f35bd9afa91ca14283e7c865918f">&#9670;&nbsp;</a></span>Transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a> Transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html" title="A scalar multi-variate piecewise polynomial.">PiecewisePolynomial</a> for which value(t) == this.value(t).transpose(). </p>

</div>
</div>
<a id="a19b632df0f98f9aaf224e534fac69ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b632df0f98f9aaf224e534fac69ec8">&#9670;&nbsp;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;T&gt; value </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the PiecewisePolynomial at the given time t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The time at which to evaluate the PiecewisePolynomial. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix of evaluated values. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If T == <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>, <code><a class="el" href="namespacedrake_1_1symbolic.html#ae0f809da2a5c679df2b90aadedde5350" title="Checks if e is a constant expression.">t.is_constant()</a></code> must be true.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If t does not lie in the range that the polynomial is defined over, the polynomial will silently be evaluated at the closest point to t. For example, <code>value(-1)</code> will return <code>value(0)</code> for a polynomial defined over [0, 1]. </dd>
<dd>
See warning in the <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#polynomial_warning">constructor overview</a> above. </dd></dl>

<p>Implements <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html#a50929a6273d23c3db2a0ba8d431fa9d9">Trajectory&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a06278ca4588ba1adb004b84fdfc62f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06278ca4588ba1adb004b84fdfc62f3c">&#9670;&nbsp;</a></span>ZeroOrderHold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt;T&gt; ZeroOrderHold </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a piecewise constant PiecewisePolynomial using matrix samples. </p>
<p>Note that constructing a PiecewisePolynomial requires at least two sample points, although in this case, the second sample point's value is ignored, and only its break time is used.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1108c20b0d02730aa202de0115755fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1108c20b0d02730aa202de0115755fb2">&#9670;&nbsp;</a></span>ZeroOrderHold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt;T&gt; ZeroOrderHold </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>breaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of ZeroOrderHold(breaks, samples) that uses vector samples and Eigen VectorXd/MatrixX&lt;T&gt; arguments. </p>
<p>Each column of <code>samples</code> represents a sample point.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>samples.cols() == breaks.size()</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>under the conditions specified under <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html#coefficient_construction_methods">coefficient_construction_methods</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/common/trajectories/<a class="el" href="piecewise__polynomial_8h.html">piecewise_polynomial.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- footer -->
<div id="nav-path" class="navpath">
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1trajectories.html">trajectories</a></li><li class="navelem"><a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a></li>
  </ul>
</div>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().value = searchBox.searchLabel;
</script>
</body>
</html>
