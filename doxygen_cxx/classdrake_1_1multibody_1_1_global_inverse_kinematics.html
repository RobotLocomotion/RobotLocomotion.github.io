<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: GlobalInverseKinematics Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="https://drake.mit.edu/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="https://drake.mit.edu/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake/tree/master/tutorials">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="sites" value="drake.mit.edu/doxygen_cxx">
  </form>
  <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="sites" value="drake.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 </div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1multibody_1_1_global_inverse_kinematics.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdrake_1_1multibody_1_1_global_inverse_kinematics-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GlobalInverseKinematics Class Reference<div class="ingroups"><a class="el" href="group__algorithms.html">Algorithms</a> &raquo; <a class="el" href="group__planning.html">Planning</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Solves the inverse kinematics problem as a mixed integer convex optimization problem. </p>
<p>We use a mixed-integer convex relaxation of the rotation matrix. So if this global inverse kinematics problem says the solution is infeasible, then it is guaranteed that the kinematics constraints are not satisfiable. If the global inverse kinematics returns a solution, the posture should approximately satisfy the kinematics constraints, with some error. The approach is described in Global Inverse Kinematics via Mixed-integer Convex Optimization by Hongkai Dai, Gregory Izatt and Russ Tedrake, International Journal of Robotics Research, 2019. </p>
</div>
<p><code>#include &lt;drake/multibody/inverse_kinematics/global_inverse_kinematics.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1_global_inverse_kinematics_1_1_options.html">Options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1_global_inverse_kinematics_1_1_polytope3_d.html">Polytope3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a polytope in 3D as 𝐀 * 𝐱 ≤ 𝐛 (a set of half-spaces), where 𝐀 ∈ ℝⁿˣ³, 𝐱 ∈ ℝ³, 𝐛 ∈ ℝⁿ.  <a href="structdrake_1_1multibody_1_1_global_inverse_kinematics_1_1_polytope3_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8e8ee200af4c94a38f9612dec018a199"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html#a8e8ee200af4c94a38f9612dec018a199">GlobalInverseKinematics</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; double &gt; &amp;plant, const <a class="el" href="structdrake_1_1multibody_1_1_global_inverse_kinematics_1_1_options.html">Options</a> &amp;options=<a class="el" href="structdrake_1_1multibody_1_1_global_inverse_kinematics_1_1_options.html">Options</a>())</td></tr>
<tr class="memdesc:a8e8ee200af4c94a38f9612dec018a199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the robot kinematics tree.  <a href="#a8e8ee200af4c94a38f9612dec018a199">More...</a><br /></td></tr>
<tr class="separator:a8e8ee200af4c94a38f9612dec018a199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8bc31a4666ec3d2a9cd172b38918e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html#a9b8bc31a4666ec3d2a9cd172b38918e9">~GlobalInverseKinematics</a> ()</td></tr>
<tr class="separator:a9b8bc31a4666ec3d2a9cd172b38918e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc8c6b2091ff4447ee2951bb7907de8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html#afcc8c6b2091ff4447ee2951bb7907de8">prog</a> () const</td></tr>
<tr class="separator:afcc8c6b2091ff4447ee2951bb7907de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafaa0272a0f44b29697141d2d6f7c50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html#aeafaa0272a0f44b29697141d2d6f7c50">get_mutable_prog</a> ()</td></tr>
<tr class="separator:aeafaa0272a0f44b29697141d2d6f7c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b87ef32b6e8aeeb68d6423454c932f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">solvers::MatrixDecisionVariable</a>&lt; 3, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html#a74b87ef32b6e8aeeb68d6423454c932f">body_rotation_matrix</a> (<a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> body_index) const</td></tr>
<tr class="memdesc:a74b87ef32b6e8aeeb68d6423454c932f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the decision variables on the rotation matrix <code>R_WB</code> for a body with the specified index.  <a href="#a74b87ef32b6e8aeeb68d6423454c932f">More...</a><br /></td></tr>
<tr class="separator:a74b87ef32b6e8aeeb68d6423454c932f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cde631adfd94e6c518134b3bde8352b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake_1_1solvers.html#aa20d09ae94d1e722c2961fbaca37f967">solvers::VectorDecisionVariable</a>&lt; 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html#a6cde631adfd94e6c518134b3bde8352b">body_position</a> (<a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> body_index) const</td></tr>
<tr class="memdesc:a6cde631adfd94e6c518134b3bde8352b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the decision variables on the position p_WBo of the body B's origin measured and expressed in the world frame.  <a href="#a6cde631adfd94e6c518134b3bde8352b">More...</a><br /></td></tr>
<tr class="separator:a6cde631adfd94e6c518134b3bde8352b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255f7b346af8cf803c9d48f0258f99ec"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html#a255f7b346af8cf803c9d48f0258f99ec">ReconstructGeneralizedPositionSolution</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a> &amp;result) const</td></tr>
<tr class="memdesc:a255f7b346af8cf803c9d48f0258f99ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">After solving the inverse kinematics problem and finding out the pose of each body, reconstruct the robot generalized position (joint angles, etc) that matches with the body poses.  <a href="#a255f7b346af8cf803c9d48f0258f99ec">More...</a><br /></td></tr>
<tr class="separator:a255f7b346af8cf803c9d48f0258f99ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2daf88842776fe130a504a1232cf0699"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html#a2daf88842776fe130a504a1232cf0699">AddWorldPositionConstraint</a> (<a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> body_idx, const Eigen::Vector3d &amp;p_BQ, const Eigen::Vector3d &amp;box_lb_F, const Eigen::Vector3d &amp;box_ub_F, const Eigen::Isometry3d &amp;X_WF=Eigen::Isometry3d::Identity())</td></tr>
<tr class="memdesc:a2daf88842776fe130a504a1232cf0699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the constraint that the position of a point <code>Q</code> on a body <code>B</code> (whose index is <code>body_idx</code>), is within a box in a specified frame <code>F</code>.  <a href="#a2daf88842776fe130a504a1232cf0699">More...</a><br /></td></tr>
<tr class="separator:a2daf88842776fe130a504a1232cf0699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d62cbf2c661b3cea47221cb6b8d278d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html#a4d62cbf2c661b3cea47221cb6b8d278d">AddWorldOrientationConstraint</a> (<a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> body_idx, const Eigen::Quaterniond &amp;desired_orientation, double angle_tol)</td></tr>
<tr class="memdesc:a4d62cbf2c661b3cea47221cb6b8d278d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constraint that the angle between the body orientation and the desired orientation should not be larger than <code>angle_tol</code>.  <a href="#a4d62cbf2c661b3cea47221cb6b8d278d">More...</a><br /></td></tr>
<tr class="separator:a4d62cbf2c661b3cea47221cb6b8d278d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2375608a204c57fb88fbb70d2e90c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html#a0c2375608a204c57fb88fbb70d2e90c1">AddPostureCost</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;q_desired, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;body_position_cost, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;body_orientation_cost)</td></tr>
<tr class="memdesc:a0c2375608a204c57fb88fbb70d2e90c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Penalizes the deviation to the desired posture.  <a href="#a0c2375608a204c57fb88fbb70d2e90c1">More...</a><br /></td></tr>
<tr class="separator:a0c2375608a204c57fb88fbb70d2e90c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61d225a96cfb8b79c98acf9a94730e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html#af61d225a96cfb8b79c98acf9a94730e9">BodyPointInOneOfRegions</a> (<a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> body_index, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;p_BQ, const std::vector&lt; Eigen::Matrix3Xd &gt; &amp;region_vertices)</td></tr>
<tr class="memdesc:af61d225a96cfb8b79c98acf9a94730e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrain the point <code>Q</code> lying within one of the convex polytopes.  <a href="#af61d225a96cfb8b79c98acf9a94730e9">More...</a><br /></td></tr>
<tr class="separator:af61d225a96cfb8b79c98acf9a94730e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab530c40754d107a67748e49b4ae14551"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html#ab530c40754d107a67748e49b4ae14551">BodySphereInOneOfPolytopes</a> (<a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> body_index, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;p_BQ, double radius, const std::vector&lt; <a class="el" href="structdrake_1_1multibody_1_1_global_inverse_kinematics_1_1_polytope3_d.html">Polytope3D</a> &gt; &amp;polytopes)</td></tr>
<tr class="memdesc:ab530c40754d107a67748e49b4ae14551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the constraint that a sphere rigidly attached to a body has to be within at least one of the given bounded polytopes.  <a href="#ab530c40754d107a67748e49b4ae14551">More...</a><br /></td></tr>
<tr class="separator:ab530c40754d107a67748e49b4ae14551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854976ce4b88d7f58d7f1606f1acf263"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html#a854976ce4b88d7f58d7f1606f1acf263">AddJointLimitConstraint</a> (<a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> body_index, double joint_lower_bound, double joint_upper_bound, bool linear_constraint_approximation=false)</td></tr>
<tr class="memdesc:a854976ce4b88d7f58d7f1606f1acf263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds joint limits on a specified joint.  <a href="#a854976ce4b88d7f58d7f1606f1acf263">More...</a><br /></td></tr>
<tr class="separator:a854976ce4b88d7f58d7f1606f1acf263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:ad324a07c10e5dd4bf42e5c06c99a14ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html#ad324a07c10e5dd4bf42e5c06c99a14ca">GlobalInverseKinematics</a> (const <a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html">GlobalInverseKinematics</a> &amp;)=delete</td></tr>
<tr class="separator:ad324a07c10e5dd4bf42e5c06c99a14ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67674d47fd29a7fb8d4c36d435158a7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html">GlobalInverseKinematics</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html#a67674d47fd29a7fb8d4c36d435158a7e">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html">GlobalInverseKinematics</a> &amp;)=delete</td></tr>
<tr class="separator:a67674d47fd29a7fb8d4c36d435158a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4425aa32fcd5e669dbecb00470a220"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html#a9c4425aa32fcd5e669dbecb00470a220">GlobalInverseKinematics</a> (<a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html">GlobalInverseKinematics</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a9c4425aa32fcd5e669dbecb00470a220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d739ded3e2abec7e0f2443f5459818"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html">GlobalInverseKinematics</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html#ab2d739ded3e2abec7e0f2443f5459818">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html">GlobalInverseKinematics</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ab2d739ded3e2abec7e0f2443f5459818"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad324a07c10e5dd4bf42e5c06c99a14ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad324a07c10e5dd4bf42e5c06c99a14ca">&#9670;&nbsp;</a></span>GlobalInverseKinematics() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html">GlobalInverseKinematics</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html">GlobalInverseKinematics</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c4425aa32fcd5e669dbecb00470a220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c4425aa32fcd5e669dbecb00470a220">&#9670;&nbsp;</a></span>GlobalInverseKinematics() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html">GlobalInverseKinematics</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html">GlobalInverseKinematics</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e8ee200af4c94a38f9612dec018a199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8ee200af4c94a38f9612dec018a199">&#9670;&nbsp;</a></span>GlobalInverseKinematics() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html">GlobalInverseKinematics</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>plant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1multibody_1_1_global_inverse_kinematics_1_1_options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structdrake_1_1multibody_1_1_global_inverse_kinematics_1_1_options.html">Options</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses the robot kinematics tree. </p>
<p>The decision variables include the pose for each body (position/orientation). This constructor loops through each body inside the robot kinematics tree, adds the constraint on each body pose, so that the adjacent bodies are connected correctly by the joint in between the bodies. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plant</td><td>The robot on which the inverse kinematics problem is solved. plant must be alive for as long as this object is around. </td></tr>
    <tr><td class="paramname">options</td><td>The options to relax SO(3) constraint as mixed-integer convex constraints. Refer to MixedIntegerRotationConstraintGenerator for more details on the parameters in options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b8bc31a4666ec3d2a9cd172b38918e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8bc31a4666ec3d2a9cd172b38918e9">&#9670;&nbsp;</a></span>~GlobalInverseKinematics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html">GlobalInverseKinematics</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a854976ce4b88d7f58d7f1606f1acf263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854976ce4b88d7f58d7f1606f1acf263">&#9670;&nbsp;</a></span>AddJointLimitConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddJointLimitConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a>&#160;</td>
          <td class="paramname"><em>body_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>joint_lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>joint_upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>linear_constraint_approximation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds joint limits on a specified joint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_index</td><td>The joint connecting the parent link to this body will be constrained. </td></tr>
    <tr><td class="paramname">joint_lower_bound</td><td>The lower bound for the joint. </td></tr>
    <tr><td class="paramname">joint_upper_bound</td><td>The upper bound for the joint. </td></tr>
    <tr><td class="paramname">linear_constraint_approximation</td><td>If true, joint limits are approximated as linear constraints on parent and child link orientations, otherwise they are imposed as Lorentz cone constraints. With the Lorentz cone formulation, the joint limit constraint would be tight if our mixed-integer constraint on SO(3) were tight. By enforcing the joint limits as linear constraint, the original inverse kinematics problem is further relaxed, on top of SO(3) relaxation, but potentially with faster computation. <br />
 <em>Default:</em> is false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c2375608a204c57fb88fbb70d2e90c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2375608a204c57fb88fbb70d2e90c1">&#9670;&nbsp;</a></span>AddPostureCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddPostureCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>body_position_cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>body_orientation_cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Penalizes the deviation to the desired posture. </p>
<p>For each body (except the world) in the kinematic tree, we add the cost </p><pre class="fragment">∑ᵢ body_position_cost(i) * body_position_error(i) +
body_orientation_cost(i) * body_orientation_error(i)
</pre><p> where <code>body_position_error(i)</code> is computed as the Euclidean distance error |p_WBo(i) - p_WBo_desired(i)| where</p><ul>
<li>p_WBo(i) : position of body i'th origin <code>Bo</code> in the world frame <code>W</code>.</li>
<li>p_WBo_desired(i): position of body i'th origin <code>Bo</code> in the world frame <code>W</code>, computed from the desired posture <code>q_desired</code>.</li>
</ul>
<p>body_orientation_error(i) is computed as (1 - cos(θ)), where θ is the angle between the orientation of body i'th frame and body i'th frame using the desired posture. Notice that 1 - cos(θ) = θ²/2 + O(θ⁴), so this cost is on the square of θ, when θ is small. Notice that since body 0 is the world, the cost on that body is always 0, no matter what value <code>body_position_cost(0)</code> and <code>body_orientation_cost(0)</code> take. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_desired</td><td>The desired posture. </td></tr>
    <tr><td class="paramname">body_position_cost</td><td>The cost for each body's position error. Unit is [1/m] (one over meters). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ol type="1">
<li>body_position_cost.rows() == plant.num_bodies(), where <code>plant</code> is the input argument in the constructor of the class.</li>
<li>body_position_cost(i) is non-negative. </li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the precondition is not satisfied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_orientation_cost</td><td>The cost for each body's orientation error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ol type="1">
<li>body_orientation_cost.rows() == plant.num_bodies() , where <code>plant</code> is the input argument in the constructor of the class.</li>
<li>body_position_cost(i) is non-negative. </li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the precondition is not satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d62cbf2c661b3cea47221cb6b8d278d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d62cbf2c661b3cea47221cb6b8d278d">&#9670;&nbsp;</a></span>AddWorldOrientationConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a>&gt; AddWorldOrientationConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a>&#160;</td>
          <td class="paramname"><em>body_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Quaterniond &amp;&#160;</td>
          <td class="paramname"><em>desired_orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a constraint that the angle between the body orientation and the desired orientation should not be larger than <code>angle_tol</code>. </p>
<p>If we denote the angle between two rotation matrices <code>R1</code> and <code>R2</code> as <code>θ</code>, i.e. θ is the angle of the angle-axis representation of the rotation matrix <code>R1ᵀ * R2</code>, we then know </p><pre class="fragment">trace(R1ᵀ * R2) = 2 * cos(θ) + 1
</pre><p> as in <a href="http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/">http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/</a> To constraint <code>θ &lt; angle_tol</code>, we can impose the following constraint </p><pre class="fragment">2 * cos(angle_tol) + 1 &lt;= trace(R1ᵀ * R2) &lt;= 3
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_idx</td><td>The index of the body whose orientation will be constrained. </td></tr>
    <tr><td class="paramname">desired_orientation</td><td>The desired orientation of the body. </td></tr>
    <tr><td class="paramname">angle_tol</td><td>The tolerance on the angle between the body orientation and the desired orientation. Unit is radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">binding</td><td>The newly added constraint, together with the bound variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2daf88842776fe130a504a1232cf0699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2daf88842776fe130a504a1232cf0699">&#9670;&nbsp;</a></span>AddWorldPositionConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">solvers::LinearConstraint</a>&gt; AddWorldPositionConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a>&#160;</td>
          <td class="paramname"><em>body_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>p_BQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>box_lb_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>box_ub_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Isometry3d &amp;&#160;</td>
          <td class="paramname"><em>X_WF</em> = <code>Eigen::Isometry3d::Identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the constraint that the position of a point <code>Q</code> on a body <code>B</code> (whose index is <code>body_idx</code>), is within a box in a specified frame <code>F</code>. </p>
<p>The constraint is that the point <code>Q</code>'s position should lie within a bounding box in the frame <code>F</code>. Namely</p>
<p>box_lb_F &lt;= p_FQ &lt;= box_ub_F</p>
<p>where p_FQ is the position of the point Q measured and expressed in the <code>F</code>, computed as</p>
<p>p_FQ = X_FW * (p_WBo + R_WB * p_BQ)</p>
<p>hence this is a linear constraint on the decision variables p_WBo and R_WB. The inequality is imposed elementwise.</p>
<dl class="section note"><dt>Note</dt><dd>since the rotation matrix <code>R_WB</code> does not lie exactly on the SO(3), due to the McCormick envelope relaxation, this constraint is subject to the accumulated error from the root of the kinematics tree.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_idx</td><td>The index of the body on which the position of a point is constrained. </td></tr>
    <tr><td class="paramname">p_BQ</td><td>The position of the point Q measured and expressed in the body frame B. </td></tr>
    <tr><td class="paramname">box_lb_F</td><td>The lower bound of the box in frame <code>F</code>. </td></tr>
    <tr><td class="paramname">box_ub_F</td><td>The upper bound of the box in frame <code>F</code>. </td></tr>
    <tr><td class="paramname">X_WF.</td><td>The frame in which the box is specified. This frame is represented by an isometry transform X_WF, the transform from the constraint frame F to the world frame W. Namely if the position of the point <code>Q</code> in the world frame is <code>p_WQ</code>, then the constraint is <pre class="fragment">box_lb_F &lt;= R_FW * (p_WQ-p_WFo) &lt;= box_ub_F
</pre> where<ul>
<li>R_FW is the rotation matrix of frame <code>W</code> expressed and measured in frame <code>F</code>. <code>R_FW = X_WF.linear().transpose()</code>.</li>
<li>p_WFo is the position of frame <code>F</code>'s origin, expressed and measured in frame <code>W</code>. <code>p_WFo = X_WF.translation()</code>. <br />
 <em>Default:</em> is the identity transform. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">binding</td><td>The newly added constraint, together with the bound variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cde631adfd94e6c518134b3bde8352b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cde631adfd94e6c518134b3bde8352b">&#9670;&nbsp;</a></span>body_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake_1_1solvers.html#aa20d09ae94d1e722c2961fbaca37f967">solvers::VectorDecisionVariable</a>&lt;3&gt;&amp; body_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a>&#160;</td>
          <td class="paramname"><em>body_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the decision variables on the position p_WBo of the body B's origin measured and expressed in the world frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_index</td><td>The index of the queried body. Notice that body 0 is the world, and thus not a decision variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the index is smaller than 1, or greater than or equal to the total number of bodies in the robot. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74b87ef32b6e8aeeb68d6423454c932f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b87ef32b6e8aeeb68d6423454c932f">&#9670;&nbsp;</a></span>body_rotation_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">solvers::MatrixDecisionVariable</a>&lt;3, 3&gt;&amp; body_rotation_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a>&#160;</td>
          <td class="paramname"><em>body_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the decision variables on the rotation matrix <code>R_WB</code> for a body with the specified index. </p>
<p>This is the orientation of body i's frame measured and expressed in the world frame. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_index</td><td>The index of the queried body. Notice that body 0 is the world, and thus not a decision variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the index is smaller than 1, or greater than or equal to the total number of bodies in the robot. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af61d225a96cfb8b79c98acf9a94730e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61d225a96cfb8b79c98acf9a94730e9">&#9670;&nbsp;</a></span>BodyPointInOneOfRegions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> BodyPointInOneOfRegions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a>&#160;</td>
          <td class="paramname"><em>body_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Matrix3Xd &gt; &amp;&#160;</td>
          <td class="paramname"><em>region_vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constrain the point <code>Q</code> lying within one of the convex polytopes. </p>
<p>Each convex polytope Pᵢ is represented by its vertices as Pᵢ = ConvexHull(v_i1, v_i2, ... v_in). Mathematically we want to impose the constraint that the p_WQ, i.e., the position of point <code>Q</code> in world frame <code>W</code>, satisfies </p><pre class="fragment">p_WQ ∈ Pᵢ for one i.
</pre><p> To impose this constraint, we consider to introduce binary variable zᵢ, and continuous variables w_i1, w_i2, ..., w_in for each vertex of Pᵢ, with the following constraints </p><pre class="fragment">p_WQ = sum_i (w_i1 * v_i1 + w_i2 * v_i2 + ... + w_in * v_in)
w_ij &gt;= 0, ∀i,j
w_i1 + w_i2 + ... + w_in = zᵢ
sum_i zᵢ = 1
zᵢ ∈ {0, 1}
</pre><p> Notice that if zᵢ = 0, then w_i1 * v_i1 + w_i2 * v_i2 + ... + w_in * v_in is just 0. This function can be used for collision avoidance, where each region Pᵢ is a free space region. It can also be used for grasping, where each region Pᵢ is a surface patch on the grasped object. Note this approach also works if the region Pᵢ overlaps with each other. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_index</td><td>The index of the body to on which point <code>Q</code> is attached. </td></tr>
    <tr><td class="paramname">p_BQ</td><td>The position of point <code>Q</code> in the body frame <code>B</code>. </td></tr>
    <tr><td class="paramname">region_vertices</td><td>region_vertices[i] is the vertices for the i'th region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">z</td><td>The newly added binary variables. If point <code>Q</code> is in the i'th region, z(i) = 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>region_vertices[i] has at least 3 columns. Throw a std::runtime_error if the precondition is not satisfied. </dd></dl>

</div>
</div>
<a id="ab530c40754d107a67748e49b4ae14551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab530c40754d107a67748e49b4ae14551">&#9670;&nbsp;</a></span>BodySphereInOneOfPolytopes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> BodySphereInOneOfPolytopes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a>&#160;</td>
          <td class="paramname"><em>body_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structdrake_1_1multibody_1_1_global_inverse_kinematics_1_1_polytope3_d.html">Polytope3D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polytopes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the constraint that a sphere rigidly attached to a body has to be within at least one of the given bounded polytopes. </p>
<p>If the polytopes don't intersect, then the sphere is in one and only one polytope. Otherwise the sphere is in at least one of the polytopes (could be in the intersection of multiple polytopes.) If the i'th polytope is described as </p><pre class="fragment">Aᵢ * x ≤ bᵢ
</pre><p> where Aᵢ ∈ ℝⁿ ˣ ³, bᵢ ∈ ℝⁿ. Then a sphere with center position p_WQ and radius r is within the i'th polytope, if </p><pre class="fragment">Aᵢ * p_WQ ≤ bᵢ - aᵢr
</pre><p> where aᵢ(j) = Aᵢ.row(j).norm() To constrain that the sphere is in one of the n polytopes, we introduce the binary variable z ∈{0, 1}ⁿ, together with continuous variables yᵢ ∈ ℝ³, i = 1, ..., n, such that p_WQ = y₁ + ... + yₙ Aᵢ * yᵢ ≤ (bᵢ - aᵢr)zᵢ z₁ + ... +zₙ = 1 Notice that when zᵢ = 0, Aᵢ * yᵢ ≤ 0 implies that yᵢ = 0. This is due to the boundedness of the polytope. If Aᵢ * yᵢ ≤ 0 has a non-zero solution y̅, that y̅ ≠ 0 and Aᵢ * y̅ ≤ 0. Then for any point x̂ in the polytope satisfying Aᵢ * x̂ ≤ bᵢ, we know the ray x̂ + ty̅, ∀ t ≥ 0 also satisfies Aᵢ * (x̂ + ty̅) ≤ bᵢ, thus the ray is within the polytope, violating the boundedness assumption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body_index</td><td>The index of the body to which the sphere is attached. </td></tr>
    <tr><td class="paramname">p_BQ</td><td>The position of the sphere center in the body frame B. </td></tr>
    <tr><td class="paramname">radius</td><td>The radius of the sphere. </td></tr>
    <tr><td class="paramname">polytopes.</td><td>polytopes[i] = (Aᵢ, bᵢ). We assume that Aᵢx≤ bᵢ is a bounded polytope. It is the user's responsibility to guarantee the boundedness. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">z</td><td>The newly added binary variables. If z(i) = 1, then the sphere is in the i'th polytope. If two or more polytopes are intersecting, and the sphere is in the intersection region, then it is up to the solver to choose one of z(i) to be 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeafaa0272a0f44b29697141d2d6f7c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeafaa0272a0f44b29697141d2d6f7c50">&#9670;&nbsp;</a></span>get_mutable_prog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a>* get_mutable_prog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67674d47fd29a7fb8d4c36d435158a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67674d47fd29a7fb8d4c36d435158a7e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html">GlobalInverseKinematics</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html">GlobalInverseKinematics</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2d739ded3e2abec7e0f2443f5459818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d739ded3e2abec7e0f2443f5459818">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html">GlobalInverseKinematics</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html">GlobalInverseKinematics</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afcc8c6b2091ff4447ee2951bb7907de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc8c6b2091ff4447ee2951bb7907de8">&#9670;&nbsp;</a></span>prog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a>&amp; prog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a255f7b346af8cf803c9d48f0258f99ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255f7b346af8cf803c9d48f0258f99ec">&#9670;&nbsp;</a></span>ReconstructGeneralizedPositionSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd ReconstructGeneralizedPositionSolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">solvers::MathematicalProgramResult</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>After solving the inverse kinematics problem and finding out the pose of each body, reconstruct the robot generalized position (joint angles, etc) that matches with the body poses. </p>
<p>Notice that since the rotation matrix is approximated, that the solution of body_rotmat() might not be on SO(3) exactly, the reconstructed body posture might not match with the body poses exactly, and the kinematics constraint might not be satisfied exactly with this reconstructed posture. </p><dl class="section warning"><dt>Warning</dt><dd>Do not call this method if the problem is not solved successfully! The returned value can be NaN or meaningless number if the problem is not solved. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">q</td><td>The reconstructed posture of the robot of the generalized coordinates, corresponding to the RigidBodyTree on which the inverse kinematics problem is solved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/multibody/inverse_kinematics/<a class="el" href="global__inverse__kinematics_8h.html">global_inverse_kinematics.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- footer -->
<div id="nav-path" class="navpath">
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a class="el" href="classdrake_1_1multibody_1_1_global_inverse_kinematics.html">GlobalInverseKinematics</a></li>
  </ul>
</div>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().value = searchBox.searchLabel;
</script>
</body>
</html>
