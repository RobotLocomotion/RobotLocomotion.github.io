<!-- HTML header for doxygen 1.14.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: CartesianProduct Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html','','classdrake_1_1geometry_1_1optimization_1_1_cartesian_product-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">CartesianProduct Class Reference<span class="mlabels"><span class="mlabel final">final</span></span><div class="ingroups"><a class="el" href="group__geometry.html">Geometric Representations</a> &#124; <a class="el" href="group__solvers.html">Formulating and Solving Optimization Problems</a> &raquo; <a class="el" href="group__geometry__optimization.html">Geometry Optimization</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Cartesian product of convex sets is a convex set: S = X₁ × X₂ × ⋯ × Xₙ = {(x₁, x₂, ..., xₙ) | x₁ ∈ X₁, x₂ ∈ X₂, ..., xₙ ∈ Xₙ}. </p>
<p>This class also supports a generalization of this concept in which the coordinates are transformed by the linear map, {x | y = Ax + b, y ∈ Y₁ × Y₂ × ⋯ × Yₙ}, with the default values set to the identity map. This concept is required for reasoning about cylinders in arbitrary poses as cartesian products, and more generally for describing any affine transform of a <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html" title="The Cartesian product of convex sets is a convex set: S = X₁ × X₂ × ⋯ × Xₙ = {(x₁,...">CartesianProduct</a>.</p>
<p>Special behavior for IsEmpty: If there are no sets in the product, returns nonempty by convention. See: <a href="https://en.wikipedia.org/wiki/Empty_product#Nullary_Cartesian_product">https://en.wikipedia.org/wiki/Empty_product#Nullary_Cartesian_product</a> Otherwise, if any set in the cartesian product is empty, the whole product is empty. </p>
</div>
<p><code>#include &lt;drake/geometry/optimization/cartesian_product.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa265781415ff88df19224c143628305d" id="r_aa265781415ff88df19224c143628305d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa265781415ff88df19224c143628305d">CartesianProduct</a> ()</td></tr>
<tr class="memdesc:aa265781415ff88df19224c143628305d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a default (zero-dimensional, nonempty) set.  <br /></td></tr>
<tr class="memitem:aecd6b9669e7f9270c679c9354f2381f6" id="r_aecd6b9669e7f9270c679c9354f2381f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecd6b9669e7f9270c679c9354f2381f6">CartesianProduct</a> (const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;sets)</td></tr>
<tr class="memdesc:aecd6b9669e7f9270c679c9354f2381f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the product from a vector of convex sets.  <br /></td></tr>
<tr class="memitem:afcef64d3a17bf3547696e5fbb31612e5" id="r_afcef64d3a17bf3547696e5fbb31612e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcef64d3a17bf3547696e5fbb31612e5">CartesianProduct</a> (const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a> &amp;setA, const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a> &amp;setB)</td></tr>
<tr class="memdesc:afcef64d3a17bf3547696e5fbb31612e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the product from a pair of convex sets.  <br /></td></tr>
<tr class="memitem:a251de6c17a4bc0152b26a4ad55ddf98b" id="r_a251de6c17a4bc0152b26a4ad55ddf98b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a251de6c17a4bc0152b26a4ad55ddf98b">CartesianProduct</a> (const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;sets, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;<a class="el" href="#a84933d19edd42d3541cda5b10c054de4">A</a>, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;<a class="el" href="#afee461a999f5cf1682a4d819c9410dd5">b</a>)</td></tr>
<tr class="memdesc:a251de6c17a4bc0152b26a4ad55ddf98b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the product of convex sets in the transformed coordinates: {x | y = Ax + b, y ∈ Y₁ × Y₂ × ⋯ × Yₙ}.  <br /></td></tr>
<tr class="memitem:a8ab1489323311a9aaecb36b81d6af500" id="r_a8ab1489323311a9aaecb36b81d6af500"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ab1489323311a9aaecb36b81d6af500">CartesianProduct</a> (const <a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;query_object, <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> geometry_id, std::optional&lt; <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> &gt; reference_frame=std::nullopt)</td></tr>
<tr class="memdesc:a8ab1489323311a9aaecb36b81d6af500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html" title="The Cartesian product of convex sets is a convex set: S = X₁ × X₂ × ⋯ × Xₙ = {(x₁,...">CartesianProduct</a> from a <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> geometry and pose in the <span class="tt">reference_frame</span> frame, obtained via the <a class="el" href="classdrake_1_1geometry_1_1_query_object.html" title="The QueryObject serves as a mechanism to perform geometry queries on the world&#39;s geometry.">QueryObject</a>.  <br /></td></tr>
<tr class="memitem:af8787c96bea07898c336a5a934e0975e" id="r_af8787c96bea07898c336a5a934e0975e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8787c96bea07898c336a5a934e0975e">~CartesianProduct</a> () final</td></tr>
<tr class="memitem:a27ef18eef844167c096ed08fbceeeb1a" id="r_a27ef18eef844167c096ed08fbceeeb1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27ef18eef844167c096ed08fbceeeb1a">num_factors</a> () const</td></tr>
<tr class="memdesc:a27ef18eef844167c096ed08fbceeeb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of factors (or sets) used in the product.  <br /></td></tr>
<tr class="memitem:a47d1882872043b7d66dd4fb1437f6ac2" id="r_a47d1882872043b7d66dd4fb1437f6ac2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47d1882872043b7d66dd4fb1437f6ac2">factor</a> (int i) const</td></tr>
<tr class="memdesc:a47d1882872043b7d66dd4fb1437f6ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html" title="Abstract base class for defining a convex set.">ConvexSet</a> defining the <span class="tt">index</span> factor in the product.  <br /></td></tr>
<tr class="memitem:a84933d19edd42d3541cda5b10c054de4" id="r_a84933d19edd42d3541cda5b10c054de4"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84933d19edd42d3541cda5b10c054de4">A</a> () const</td></tr>
<tr class="memdesc:a84933d19edd42d3541cda5b10c054de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the matrix A if it has been set, or nullopt otherwise.  <br /></td></tr>
<tr class="memitem:afee461a999f5cf1682a4d819c9410dd5" id="r_afee461a999f5cf1682a4d819c9410dd5"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Eigen::VectorXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afee461a999f5cf1682a4d819c9410dd5">b</a> () const</td></tr>
<tr class="memdesc:afee461a999f5cf1682a4d819c9410dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the vector b if it has been set, or nullopt otherwise.  <br /></td></tr>
<tr class="memitem:aa7a4d7c125954dfde3c15238c852eeed" id="r_aa7a4d7c125954dfde3c15238c852eeed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7a4d7c125954dfde3c15238c852eeed">PointInSet</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;<a class="el" href="light__parameter_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, <a class="el" href="classdouble.html">double</a> tol=0) const</td></tr>
<tr class="memdesc:aa7a4d7c125954dfde3c15238c852eeed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if each subvector is in its corresponding set with tolerance <span class="tt">tol</span>.  <br /></td></tr>
<tr class="memitem:a7a2847efc4f87e996464d9d71159e27b" id="r_a7a2847efc4f87e996464d9d71159e27b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a2847efc4f87e996464d9d71159e27b">CalcVolume</a> () const</td></tr>
<tr class="memitem:a92797706c9c2adb6329f1dce4c672d59" id="r_a92797706c9c2adb6329f1dce4c672d59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92797706c9c2adb6329f1dce4c672d59">IsBounded</a> (<a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a> parallelism=<a class="el" href="classdrake_1_1_parallelism.html#a7eba2010dfc9482ef2ae0bb0539a3083">Parallelism::None</a>()) const</td></tr>
<tr class="memdesc:a92797706c9c2adb6329f1dce4c672d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html" title="The Cartesian product of convex sets is a convex set: S = X₁ × X₂ × ⋯ × Xₙ = {(x₁,...">CartesianProduct</a> is bounded if and only if each constituent set is bounded.  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:a3e4b08dc563560e2186dc7c35b92fff3" id="r_a3e4b08dc563560e2186dc7c35b92fff3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e4b08dc563560e2186dc7c35b92fff3">CartesianProduct</a> (const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html">CartesianProduct</a> &amp;)=default</td></tr>
<tr class="memitem:a627f9d88dccb1a7d1ce42485241ed4bc" id="r_a627f9d88dccb1a7d1ce42485241ed4bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html">CartesianProduct</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a627f9d88dccb1a7d1ce42485241ed4bc">operator=</a> (const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html">CartesianProduct</a> &amp;)=default</td></tr>
<tr class="memitem:a2c90e1984608b11e2445e216c3617723" id="r_a2c90e1984608b11e2445e216c3617723"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c90e1984608b11e2445e216c3617723">CartesianProduct</a> (<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html">CartesianProduct</a> &amp;&amp;)=default</td></tr>
<tr class="memitem:adc7ff9a25b1b87827a1c548d24661bba" id="r_adc7ff9a25b1b87827a1c548d24661bba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html">CartesianProduct</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc7ff9a25b1b87827a1c548d24661bba">operator=</a> (<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html">CartesianProduct</a> &amp;&amp;)=default</td></tr>
<tr class="inherit_header pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Member Functions inherited from <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a></td></tr>
<tr class="memitem:aa19f9770fdca8fc14ee1dec1cec39710 inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_aa19f9770fdca8fc14ee1dec1cec39710"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#aa19f9770fdca8fc14ee1dec1cec39710">~ConvexSet</a> ()</td></tr>
<tr class="memitem:a0c8001a825e23ebda81c7029a2b40c1a inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_a0c8001a825e23ebda81c7029a2b40c1a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#a0c8001a825e23ebda81c7029a2b40c1a">Clone</a> () const</td></tr>
<tr class="memdesc:a0c8001a825e23ebda81c7029a2b40c1a inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a unique deep copy of this set.  <br /></td></tr>
<tr class="memitem:a79ab6fe34900a8391301b23abd29e10e inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_a79ab6fe34900a8391301b23abd29e10e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#a79ab6fe34900a8391301b23abd29e10e">ambient_dimension</a> () const</td></tr>
<tr class="memdesc:a79ab6fe34900a8391301b23abd29e10e inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dimension of the vector space in which the elements of this set are evaluated.  <br /></td></tr>
<tr class="memitem:a9cf0f6eaece284fabedbab39956a0938 inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_a9cf0f6eaece284fabedbab39956a0938"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#a9cf0f6eaece284fabedbab39956a0938">IntersectsWith</a> (const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a> &amp;other) const</td></tr>
<tr class="memdesc:a9cf0f6eaece284fabedbab39956a0938 inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the intersection between <span class="tt">this</span> and <span class="tt">other</span> is non-empty.  <br /></td></tr>
<tr class="memitem:a92797706c9c2adb6329f1dce4c672d59 inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_a92797706c9c2adb6329f1dce4c672d59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#a92797706c9c2adb6329f1dce4c672d59">IsBounded</a> (<a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a> parallelism=<a class="el" href="classdrake_1_1_parallelism.html#a7eba2010dfc9482ef2ae0bb0539a3083">Parallelism::None</a>()) const</td></tr>
<tr class="memdesc:a92797706c9c2adb6329f1dce4c672d59 inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the set is bounded, e.g., there exists an element-wise finite lower and upper bound for the set.  <br /></td></tr>
<tr class="memitem:a8e12342fc420701fbffd97025421575a inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_a8e12342fc420701fbffd97025421575a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#a8e12342fc420701fbffd97025421575a">IsEmpty</a> () const</td></tr>
<tr class="memdesc:a8e12342fc420701fbffd97025421575a inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the set is empty.  <br /></td></tr>
<tr class="memitem:afe62eaea48eff2737aef1398313791d8 inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_afe62eaea48eff2737aef1398313791d8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Eigen::VectorXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#afe62eaea48eff2737aef1398313791d8">MaybeGetPoint</a> () const</td></tr>
<tr class="memdesc:afe62eaea48eff2737aef1398313791d8 inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this set trivially contains exactly one point, returns the value of that point.  <br /></td></tr>
<tr class="memitem:ad2b8b78a4d4110e17a7fd071d8964d33 inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_ad2b8b78a4d4110e17a7fd071d8964d33"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Eigen::VectorXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#ad2b8b78a4d4110e17a7fd071d8964d33">MaybeGetFeasiblePoint</a> () const</td></tr>
<tr class="memdesc:ad2b8b78a4d4110e17a7fd071d8964d33 inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a feasible point within this convex set if it is nonempty, and nullopt otherwise.  <br /></td></tr>
<tr class="memitem:aa7a4d7c125954dfde3c15238c852eeed inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_aa7a4d7c125954dfde3c15238c852eeed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#aa7a4d7c125954dfde3c15238c852eeed">PointInSet</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;<a class="el" href="light__parameter_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, <a class="el" href="classdouble.html">double</a> tol=0) const</td></tr>
<tr class="memdesc:aa7a4d7c125954dfde3c15238c852eeed inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the point x is contained in the set.  <br /></td></tr>
<tr class="memitem:a3c7e182d43bdc26c55ca29fc53ae1dcc inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_a3c7e182d43bdc26c55ca29fc53ae1dcc"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#a3c7e182d43bdc26c55ca29fc53ae1dcc">AddPointInSetConstraints</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> &gt; &amp;vars) const</td></tr>
<tr class="memdesc:a3c7e182d43bdc26c55ca29fc53ae1dcc inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constraint to an existing MathematicalProgram enforcing that the point defined by vars is inside the set.  <br /></td></tr>
<tr class="memitem:a0acc463e9f56ac02e6098de8168b873e inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_a0acc463e9f56ac02e6098de8168b873e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#a0acc463e9f56ac02e6098de8168b873e">AddPointInNonnegativeScalingConstraints</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="light__parameter_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;t) const</td></tr>
<tr class="memdesc:a0acc463e9f56ac02e6098de8168b873e inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let S be this convex set.  <br /></td></tr>
<tr class="memitem:a84dfeae30f7a0543e87962568748d0f3 inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_a84dfeae30f7a0543e87962568748d0f3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#a84dfeae30f7a0543e87962568748d0f3">AddPointInNonnegativeScalingConstraints</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *prog, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;c, <a class="el" href="classdouble.html">double</a> d, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="light__parameter_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> &gt; &amp;t) const</td></tr>
<tr class="memdesc:a84dfeae30f7a0543e87962568748d0f3 inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let S be this convex set.  <br /></td></tr>
<tr class="memitem:abe00cd8bd17ed5a5d7cd0cf2f3366237 inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_abe00cd8bd17ed5a5d7cd0cf2f3366237"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_shape.html">Shape</a> &gt;, math::RigidTransformd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#abe00cd8bd17ed5a5d7cd0cf2f3366237">ToShapeWithPose</a> () const</td></tr>
<tr class="memdesc:abe00cd8bd17ed5a5d7cd0cf2f3366237 inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The abstract base class for all shape specifications.">Shape</a> and a pose of the set in the world frame for use in the <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> geometry ecosystem.  <br /></td></tr>
<tr class="memitem:a7a2847efc4f87e996464d9d71159e27b inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_a7a2847efc4f87e996464d9d71159e27b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#a7a2847efc4f87e996464d9d71159e27b">CalcVolume</a> () const</td></tr>
<tr class="memdesc:a7a2847efc4f87e996464d9d71159e27b inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exact volume for the convex set.  <br /></td></tr>
<tr class="memitem:aea6ff00adfe03e87223d06bd4627d5f8 inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_aea6ff00adfe03e87223d06bd4627d5f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_sampled_volume.html">SampledVolume</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#aea6ff00adfe03e87223d06bd4627d5f8">CalcVolumeViaSampling</a> (<a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *generator, const <a class="el" href="classdouble.html">double</a> desired_rel_accuracy=1e-2, const int max_num_samples=1e4) const</td></tr>
<tr class="memdesc:aea6ff00adfe03e87223d06bd4627d5f8 inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an estimate of the volume of the convex set using sampling and performing Monte Carlo integration.  <br /></td></tr>
<tr class="memitem:a992509c1275c106b7dcff56139321ea5 inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_a992509c1275c106b7dcff56139321ea5"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::pair&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;, Eigen::MatrixXd &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#a992509c1275c106b7dcff56139321ea5">Projection</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;points) const</td></tr>
<tr class="memdesc:a992509c1275c106b7dcff56139321ea5 inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes in the L₂ norm the distance and the nearest point in this convex set to every column of <code class="param">points</code>.  <br /></td></tr>
<tr class="memitem:a7d9beaa673ec9f46fcf52eb4c49b62bd inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_a7d9beaa673ec9f46fcf52eb4c49b62bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#a7d9beaa673ec9f46fcf52eb4c49b62bd">has_exact_volume</a> () const</td></tr>
<tr class="memdesc:a7d9beaa673ec9f46fcf52eb4c49b62bd inherit pub_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the exact volume can be computed for this convex set instance.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-inherited" class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Protected Member Functions inherited from <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a></td></tr>
<tr class="memitem:a54c93f7f5c38bfb4996d8ef9fedf0ba8 inherit pro_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_a54c93f7f5c38bfb4996d8ef9fedf0ba8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#a54c93f7f5c38bfb4996d8ef9fedf0ba8">ConvexSet</a> (int <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#a79ab6fe34900a8391301b23abd29e10e">ambient_dimension</a>, bool <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#a7d9beaa673ec9f46fcf52eb4c49b62bd">has_exact_volume</a>)</td></tr>
<tr class="memdesc:a54c93f7f5c38bfb4996d8ef9fedf0ba8 inherit pro_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use by derived classes to construct a ConvexSet.  <br /></td></tr>
<tr class="memitem:a8e8824802dedfbc36776227f7482b6bc inherit pro_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_a8e8824802dedfbc36776227f7482b6bc"><td class="memTemplParams" colspan="2">template&lt;typename Archive&gt; </td></tr>
<tr class="memitem:a8e8824802dedfbc36776227f7482b6bc inherit pro_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#a8e8824802dedfbc36776227f7482b6bc">Serialize</a> (Archive *a)</td></tr>
<tr class="memdesc:a8e8824802dedfbc36776227f7482b6bc inherit pro_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements non-virtual base class serialization.  <br /></td></tr>
<tr class="memitem:a7f61a5972585d2ebae8ff570f2c2d6b7 inherit pro_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_a7f61a5972585d2ebae8ff570f2c2d6b7"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#a7f61a5972585d2ebae8ff570f2c2d6b7">DoIsBoundedShortcut</a> () const</td></tr>
<tr class="memdesc:a7f61a5972585d2ebae8ff570f2c2d6b7 inherit pro_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-virtual interface implementation for <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#a7f61a5972585d2ebae8ff570f2c2d6b7" title="Non-virtual interface implementation for DoIsBoundedShortcut().">DoIsBoundedShortcut()</a>.  <br /></td></tr>
<tr class="memitem:a2eb84f94ab56b462a9031741aea9e8a9 inherit pro_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_a2eb84f94ab56b462a9031741aea9e8a9"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#a2eb84f94ab56b462a9031741aea9e8a9">DoProjectionShortcut</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;points, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::MatrixXd &gt; projected_points) const</td></tr>
<tr class="memdesc:a2eb84f94ab56b462a9031741aea9e8a9 inherit pro_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-virtual interface implementation for <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#a2eb84f94ab56b462a9031741aea9e8a9" title="Non-virtual interface implementation for DoProjectionShortcut().">DoProjectionShortcut()</a>.  <br /></td></tr>
<tr class="memitem:ae697f7efd2857bf107ccf02be0cac137 inherit pro_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_ae697f7efd2857bf107ccf02be0cac137"><td class="memItemLeft" align="right" valign="top">virtual std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#ae697f7efd2857bf107ccf02be0cac137">DoPointInSetShortcut</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;<a class="el" href="light__parameter_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, <a class="el" href="classdouble.html">double</a> tol) const</td></tr>
<tr class="memdesc:ae697f7efd2857bf107ccf02be0cac137 inherit pro_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-virtual interface implementation for <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#aa7a4d7c125954dfde3c15238c852eeed" title="Returns true iff the point x is contained in the set.">PointInSet()</a> that should be used when the <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#aa7a4d7c125954dfde3c15238c852eeed" title="Returns true iff the point x is contained in the set.">PointInSet()</a> can be computed more efficiently than solving a convex program.  <br /></td></tr>
<tr class="memitem:a2bc2f3f2d619431c1a0f9e281b274335 inherit pro_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_a2bc2f3f2d619431c1a0f9e281b274335"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#a2bc2f3f2d619431c1a0f9e281b274335">HandleZeroAmbientDimensionConstraints</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *prog, const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a> &amp;set, std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt; &gt; *constraints) const</td></tr>
<tr class="memdesc:a2bc2f3f2d619431c1a0f9e281b274335 inherit pro_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instances of subclasses such as <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html" title="The Cartesian product of convex sets is a convex set: S = X₁ × X₂ × ⋯ × Xₙ = {(x₁,...">CartesianProduct</a> and <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_minkowski_sum.html" title="A convex set that represents the Minkowski sum of multiple sets: S = X₁ ⨁ X₂ ⨁ ......">MinkowskiSum</a> can have constituent sets with zero ambient dimension, which much be handled in a special manner when calling methods such as DoAddPointInSetConstraints.  <br /></td></tr>
<tr class="memitem:aee74f49fab7ccaabd8661e516c7a8d9f inherit pro_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_aee74f49fab7ccaabd8661e516c7a8d9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#aee74f49fab7ccaabd8661e516c7a8d9f">ConvexSet</a> (const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a> &amp;)=default</td></tr>
<tr class="memitem:a2db1c4b2b4afbab4ae3b3dbcc2a464ad inherit pro_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_a2db1c4b2b4afbab4ae3b3dbcc2a464ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#a2db1c4b2b4afbab4ae3b3dbcc2a464ad">operator=</a> (const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a> &amp;)=default</td></tr>
<tr class="memitem:a8070665ccaa5579890f30fa70c1d8137 inherit pro_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_a8070665ccaa5579890f30fa70c1d8137"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#a8070665ccaa5579890f30fa70c1d8137">ConvexSet</a> (<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a> &amp;&amp;)=default</td></tr>
<tr class="memitem:ad8c4b75a7ea468d9ae9c053f314c0f03 inherit pro_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_ad8c4b75a7ea468d9ae9c053f314c0f03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#ad8c4b75a7ea468d9ae9c053f314c0f03">operator=</a> (<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a> &amp;&amp;)=default</td></tr>
<tr class="inherit_header pro_static_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_static_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Static Protected Member Functions inherited from <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a></td></tr>
<tr class="memitem:aefbe21ab5956cf9f0ab32f7dd635ff82 inherit pro_static_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set" id="r_aefbe21ab5956cf9f0ab32f7dd635ff82"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#aefbe21ab5956cf9f0ab32f7dd635ff82">AffineHullShortcut</a> (const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a> &amp;self, std::optional&lt; <a class="el" href="classdouble.html">double</a> &gt; tol)</td></tr>
<tr class="memdesc:aefbe21ab5956cf9f0ab32f7dd635ff82 inherit pro_static_methods_classdrake_1_1geometry_1_1optimization_1_1_convex_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">When there is a more efficient strategy to compute the affine hull of this set, returns affine hull as an <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_affine_subspace.html" title="An affine subspace (also known as a &quot;flat&quot;, a &quot;linear variety&quot;, or a &quot;linearmanifold&quot;) is a vector su...">AffineSubspace</a>.  <br /></td></tr>
</table>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3e4b08dc563560e2186dc7c35b92fff3" name="a3e4b08dc563560e2186dc7c35b92fff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4b08dc563560e2186dc7c35b92fff3">&#9670;&#160;</a></span>CartesianProduct() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html">CartesianProduct</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html">CartesianProduct</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c90e1984608b11e2445e216c3617723" name="a2c90e1984608b11e2445e216c3617723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c90e1984608b11e2445e216c3617723">&#9670;&#160;</a></span>CartesianProduct() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html">CartesianProduct</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html">CartesianProduct</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa265781415ff88df19224c143628305d" name="aa265781415ff88df19224c143628305d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa265781415ff88df19224c143628305d">&#9670;&#160;</a></span>CartesianProduct() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html">CartesianProduct</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a default (zero-dimensional, nonempty) set. </p>

</div>
</div>
<a id="aecd6b9669e7f9270c679c9354f2381f6" name="aecd6b9669e7f9270c679c9354f2381f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd6b9669e7f9270c679c9354f2381f6">&#9670;&#160;</a></span>CartesianProduct() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html">CartesianProduct</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sets</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the product from a vector of convex sets. </p>

</div>
</div>
<a id="afcef64d3a17bf3547696e5fbb31612e5" name="afcef64d3a17bf3547696e5fbb31612e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcef64d3a17bf3547696e5fbb31612e5">&#9670;&#160;</a></span>CartesianProduct() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html">CartesianProduct</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>setA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>setB</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the product from a pair of convex sets. </p>

</div>
</div>
<a id="a251de6c17a4bc0152b26a4ad55ddf98b" name="a251de6c17a4bc0152b26a4ad55ddf98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251de6c17a4bc0152b26a4ad55ddf98b">&#9670;&#160;</a></span>CartesianProduct() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html">CartesianProduct</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the product of convex sets in the transformed coordinates: {x | y = Ax + b, y ∈ Y₁ × Y₂ × ⋯ × Yₙ}. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>when <span class="tt">A</span> is not full column rank. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ab1489323311a9aaecb36b81d6af500" name="a8ab1489323311a9aaecb36b81d6af500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab1489323311a9aaecb36b81d6af500">&#9670;&#160;</a></span>CartesianProduct() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html">CartesianProduct</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>query_object</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a></td>          <td class="paramname"><span class="paramname"><em>geometry_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>reference_frame</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html" title="The Cartesian product of convex sets is a convex set: S = X₁ × X₂ × ⋯ × Xₙ = {(x₁,...">CartesianProduct</a> from a <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> geometry and pose in the <span class="tt">reference_frame</span> frame, obtained via the <a class="el" href="classdrake_1_1geometry_1_1_query_object.html" title="The QueryObject serves as a mechanism to perform geometry queries on the world&#39;s geometry.">QueryObject</a>. </p>
<p>If <span class="tt">reference_frame</span> frame is std::nullopt, then it will be expressed in the world frame.</p>
<p>Although any geometry that can be used as a <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html" title="Abstract base class for defining a convex set.">ConvexSet</a> could also be a (trivial) <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html" title="The Cartesian product of convex sets is a convex set: S = X₁ × X₂ × ⋯ × Xₙ = {(x₁,...">CartesianProduct</a>, we restrict this constructor to handling <a class="el" href="classdrake_1_1geometry_1_1_cylinder.html" title="Definition of a cylinder.">Cylinder</a> geometry, which constructs the (non-trivial) Cartesian product of a HyperEllipsoid and an <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html" title="Implements a polyhedral convex set using the half-space representation: {x| A x ≤ b}...">HPolyhedron</a>. Most other <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> geometry types are supported by at least one of the <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html" title="Abstract base class for defining a convex set.">ConvexSet</a> class constructors.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if geometry_id does not correspond to a <a class="el" href="classdrake_1_1geometry_1_1_cylinder.html" title="Definition of a cylinder.">Cylinder</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8787c96bea07898c336a5a934e0975e" name="af8787c96bea07898c336a5a934e0975e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8787c96bea07898c336a5a934e0975e">&#9670;&#160;</a></span>~CartesianProduct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html">CartesianProduct</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel final">final</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a84933d19edd42d3541cda5b10c054de4" name="a84933d19edd42d3541cda5b10c054de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84933d19edd42d3541cda5b10c054de4">&#9670;&#160;</a></span>A()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; Eigen::MatrixXd &gt; A </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of the matrix A if it has been set, or nullopt otherwise. </p>

</div>
</div>
<a id="afee461a999f5cf1682a4d819c9410dd5" name="afee461a999f5cf1682a4d819c9410dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee461a999f5cf1682a4d819c9410dd5">&#9670;&#160;</a></span>b()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; Eigen::VectorXd &gt; b </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of the vector b if it has been set, or nullopt otherwise. </p>

</div>
</div>
<a id="a7a2847efc4f87e996464d9d71159e27b" name="a7a2847efc4f87e996464d9d71159e27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2847efc4f87e996464d9d71159e27b">&#9670;&#160;</a></span>CalcVolume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> CalcVolume </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td><span class="tt">set.has_exact_volume() == false</span> for any of the sets in the product. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47d1882872043b7d66dd4fb1437f6ac2" name="a47d1882872043b7d66dd4fb1437f6ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d1882872043b7d66dd4fb1437f6ac2">&#9670;&#160;</a></span>factor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a> &amp; factor </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html" title="Abstract base class for defining a convex set.">ConvexSet</a> defining the <span class="tt">index</span> factor in the product. </p>

</div>
</div>
<a id="a92797706c9c2adb6329f1dce4c672d59" name="a92797706c9c2adb6329f1dce4c672d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92797706c9c2adb6329f1dce4c672d59">&#9670;&#160;</a></span>IsBounded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsBounded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a></td>          <td class="paramname"><span class="paramname"><em>parallelism</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1_parallelism.html#a7eba2010dfc9482ef2ae0bb0539a3083">Parallelism::None</a>()</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html" title="The Cartesian product of convex sets is a convex set: S = X₁ × X₂ × ⋯ × Xₙ = {(x₁,...">CartesianProduct</a> is bounded if and only if each constituent set is bounded. </p>
<p>This class honors requests for parallelism only so far as its constituent sets do. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parallelism</td><td>The maximum number of threads to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>See <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#a92797706c9c2adb6329f1dce4c672d59">parent class's documentation</a> for more details. </dd></dl>

</div>
</div>
<a id="a27ef18eef844167c096ed08fbceeeb1a" name="a27ef18eef844167c096ed08fbceeeb1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ef18eef844167c096ed08fbceeeb1a">&#9670;&#160;</a></span>num_factors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int num_factors </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of factors (or sets) used in the product. </p>

</div>
</div>
<a id="adc7ff9a25b1b87827a1c548d24661bba" name="adc7ff9a25b1b87827a1c548d24661bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7ff9a25b1b87827a1c548d24661bba">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html">CartesianProduct</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html">CartesianProduct</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a627f9d88dccb1a7d1ce42485241ed4bc" name="a627f9d88dccb1a7d1ce42485241ed4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627f9d88dccb1a7d1ce42485241ed4bc">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html">CartesianProduct</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html">CartesianProduct</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7a4d7c125954dfde3c15238c852eeed" name="aa7a4d7c125954dfde3c15238c852eeed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a4d7c125954dfde3c15238c852eeed">&#9670;&#160;</a></span>PointInSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PointInSet </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if each subvector is in its corresponding set with tolerance <span class="tt">tol</span>. </p>
<p>Note: Tolerance support for this query varies in the different convex set implementations. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/geometry/optimization/<a class="el" href="cartesian__product_8h.html">cartesian_product.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1geometry.html">geometry</a></li><li class="navelem"><a href="namespacedrake_1_1geometry_1_1optimization.html">optimization</a></li><li class="navelem"><a href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html">CartesianProduct</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
