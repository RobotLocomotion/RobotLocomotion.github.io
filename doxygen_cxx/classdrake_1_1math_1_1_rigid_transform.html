<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: RigidTransform&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1math_1_1_rigid_transform.html','','classdrake_1_1math_1_1_rigid_transform-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">RigidTransform&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class drake::math::RigidTransform&lt; T &gt;</div><p>This class represents a proper rigid transform between two frames which can be regarded in two ways. </p>
<p>A rigid transform describes the "pose" between two frames A and B (i.e., the relative orientation and position of A to B). Alternately, it can be regarded as a distance-preserving operator that can rotate and/or translate a rigid body without changing its shape or size (rigid) and without mirroring/reflecting the body (proper), e.g., it can add one position vector to another and express the result in a particular basis as <span class="tt">p_AoQ_A = X_AB * p_BoQ_B</span> (Q is any point). In many ways, this rigid transform class is conceptually similar to using a homogeneous matrix as a linear operator. See operator* documentation for an exception.</p>
<p>The class stores a <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> that relates right-handed orthogonal unit vectors Ax, Ay, Az fixed in frame A to right-handed orthogonal unit vectors Bx, By, Bz fixed in frame B. The class also stores a position vector from Ao (the origin of frame A) to Bo (the origin of frame B). The position vector is expressed in frame A. The monogram notation for the transform relating frame A to B is <span class="tt">X_AB</span>. The monogram notation for the rotation matrix relating A to B is <span class="tt">R_AB</span>. The monogram notation for the position vector from Ao to Bo is <span class="tt">p_AoBo_A</span>. See <a class="el" href="group__multibody__quantities.html">Multibody Quantities</a> for monogram notation for dynamics.</p>
<dl class="section note"><dt>Note</dt><dd>This class does not store the frames associated with the transform and cannot enforce correct usage of this class. For example, it makes sense to multiply RigidTransforms as <span class="tt">X_AB * X_BC</span>, but not <span class="tt">X_AB * X_CB</span>.</dd>
<dd>
This class is not a 4x4 transformation matrix &ndash; even though its <a class="el" href="#a2ee60ab7e7a5bb203c791aa003891bc1" title="Multiplies this RigidTransform X_AB by the other RigidTransform X_BC and returns the RigidTransform X...">operator*()</a> methods act mostly like 4x4 matrix multiplication. Instead, this class contains a 3x3 rotation matrix class and a 3x1 position vector. To convert this to a 3x4 matrix, use <a class="el" href="#acd6d54bbf91b49cbe466b99b28144ebe" title="Returns the 3x4 matrix associated with this RigidTransform, i.e., X_AB.">GetAsMatrix34()</a>. To convert this to a 4x4 matrix, use <a class="el" href="#a47dd6fe4ba8495b64354431a9a03ba1a" title="Returns the 4x4 matrix associated with this RigidTransform, i.e., X_AB.">GetAsMatrix4()</a>. To convert this to an Eigen::Isometry, use GetAsIsometry().</dd>
<dd>
An isometry is sometimes regarded as synonymous with rigid transform. The RigidTransform class has important advantages over Eigen::Isometry.<ul>
<li>RigidTransform is built on an underlying rigorous 3x3 <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> class that has significant functionality for 3D orientation.</li>
<li>In Debug builds, RigidTransform requires a valid 3x3 rotation matrix and a valid (non-NAN) position vector. Eigen::Isometry does not.</li>
<li>RigidTransform catches bugs that are undetected by Eigen::Isometry.</li>
<li>RigidTransform has additional functionality and ease-of-use, resulting in shorter, easier to write, and easier to read code.</li>
<li>The name Isometry is unfamiliar to many roboticists and dynamicists and for them Isometry.linear() is (for example) a counter-intuitive method name to return a rotation matrix.</li>
</ul>
</dd>
<dd>
One of the constructors in this class provides an implicit conversion from an Eigen Translation to RigidTransform.</dd></dl>
<dl class="section author"><dt>Authors</dt><dd>Paul Mitiguy (2018) Original author. </dd>
<dd>
Drake team (see <a href="https://drake.mit.edu/credits">https://drake.mit.edu/credits</a>).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/math/rigid_transform.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaa71b78707a3d79cbcb1a8f3cc854bee" id="r_aaa71b78707a3d79cbcb1a8f3cc854bee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa71b78707a3d79cbcb1a8f3cc854bee">RigidTransform</a> ()</td></tr>
<tr class="memdesc:aaa71b78707a3d79cbcb1a8f3cc854bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the RigidTransform that corresponds to aligning the two frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is coincident with Bo.  <br /></td></tr>
<tr class="memitem:a079ca01bad5c04328237cfc47c73f7c6" id="r_a079ca01bad5c04328237cfc47c73f7c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a079ca01bad5c04328237cfc47c73f7c6">RigidTransform</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;R, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a079ca01bad5c04328237cfc47c73f7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform from a rotation matrix and a position vector.  <br /></td></tr>
<tr class="memitem:aadac43ad1559a232d321b36e501605fe" id="r_aadac43ad1559a232d321b36e501605fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadac43ad1559a232d321b36e501605fe">RigidTransform</a> (const <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html">RollPitchYaw</a>&lt; T &gt; &amp;rpy, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:aadac43ad1559a232d321b36e501605fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform from a <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html" title="This class represents the orientation between two arbitrary frames A and D associated with a Space-fi...">RollPitchYaw</a> and a position vector.  <br /></td></tr>
<tr class="memitem:a391249f5a5f48f189c7ff6572d6e3a19" id="r_a391249f5a5f48f189c7ff6572d6e3a19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a391249f5a5f48f189c7ff6572d6e3a19">RigidTransform</a> (const Eigen::Quaternion&lt; T &gt; &amp;quaternion, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a391249f5a5f48f189c7ff6572d6e3a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform from a <a class="el" href="namespacedrake.html#a4156bf453a5b323356d7cc784dfdf084" title="A quaternion templated on scalar type.">Quaternion</a> and a position vector.  <br /></td></tr>
<tr class="memitem:a0780a9ce724867fa65c009f0fbf82dc5" id="r_a0780a9ce724867fa65c009f0fbf82dc5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0780a9ce724867fa65c009f0fbf82dc5">RigidTransform</a> (const Eigen::AngleAxis&lt; T &gt; &amp;theta_lambda, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a0780a9ce724867fa65c009f0fbf82dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform from an <a class="el" href="namespacedrake.html#a90d91e75997a81a48adea1e83caddde4" title="An AngleAxis templated on scalar type.">AngleAxis</a> and a position vector.  <br /></td></tr>
<tr class="memitem:ab8d99e85efd9f05d378ea0ecb922fcfa" id="r_ab8d99e85efd9f05d378ea0ecb922fcfa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8d99e85efd9f05d378ea0ecb922fcfa">RigidTransform</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;R)</td></tr>
<tr class="memdesc:ab8d99e85efd9f05d378ea0ecb922fcfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform with a given <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and a zero position vector.  <br /></td></tr>
<tr class="memitem:afbab39c825ec784b6162682de5e4cdf1" id="r_afbab39c825ec784b6162682de5e4cdf1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbab39c825ec784b6162682de5e4cdf1">RigidTransform</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:afbab39c825ec784b6162682de5e4cdf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform that contains an identity <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and a given position vector <span class="tt">p</span>.  <br /></td></tr>
<tr class="memitem:aae328b72ac0f21f3bcdd7abe9cc19144" id="r_aae328b72ac0f21f3bcdd7abe9cc19144"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae328b72ac0f21f3bcdd7abe9cc19144">RigidTransform</a> (const Eigen::Translation&lt; T, 3 &gt; &amp;<a class="el" href="#ae78c4bbe06336087e6d603a70337eb7a">translation</a>)</td></tr>
<tr class="memdesc:aae328b72ac0f21f3bcdd7abe9cc19144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform that contains an identity <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and the position vector underlying the given <span class="tt"><a class="el" href="#ae78c4bbe06336087e6d603a70337eb7a" title="Returns p_AoBo_A, the position vector portion of this RigidTransform, i.e., position vector from Ao (...">translation</a></span>.  <br /></td></tr>
<tr class="memitem:aa36e94d338e3be24e9fde24f1d58a4fb" id="r_aa36e94d338e3be24e9fde24f1d58a4fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa36e94d338e3be24e9fde24f1d58a4fb">RigidTransform</a> (const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;pose)</td></tr>
<tr class="memdesc:aa36e94d338e3be24e9fde24f1d58a4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform from an Eigen <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa" title="An Isometry templated on scalar type.">Isometry3</a>.  <br /></td></tr>
<tr class="memitem:aca9bb867abe5a56d1f4f9ae9c62df07b" id="r_aca9bb867abe5a56d1f4f9ae9c62df07b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca9bb867abe5a56d1f4f9ae9c62df07b">RigidTransform</a> (const Eigen::Matrix&lt; T, 3, 4 &gt; &amp;pose)</td></tr>
<tr class="memdesc:aca9bb867abe5a56d1f4f9ae9c62df07b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform from a 3x4 matrix whose structure is below.  <br /></td></tr>
<tr class="memitem:a5d2232216392f2045d6907a99fa0b423" id="r_a5d2232216392f2045d6907a99fa0b423"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d2232216392f2045d6907a99fa0b423">RigidTransform</a> (const <a class="el" href="namespacedrake.html#ae74155a11dfcdaad0adc0349f0956148">Matrix4</a>&lt; T &gt; &amp;pose)</td></tr>
<tr class="memdesc:a5d2232216392f2045d6907a99fa0b423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform from a 4x4 matrix whose structure is below.  <br /></td></tr>
<tr class="memitem:ac7b8a89a54006ff4502298b5907f7e28" id="r_ac7b8a89a54006ff4502298b5907f7e28"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:ac7b8a89a54006ff4502298b5907f7e28 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7b8a89a54006ff4502298b5907f7e28">RigidTransform</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;pose)</td></tr>
<tr class="memdesc:ac7b8a89a54006ff4502298b5907f7e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform from an appropriate Eigen <b>expression</b>.  <br /></td></tr>
<tr class="memitem:ae31756c2694bacdfdf6b0c75602d498b" id="r_ae31756c2694bacdfdf6b0c75602d498b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae31756c2694bacdfdf6b0c75602d498b">set</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;R, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:ae31756c2694bacdfdf6b0c75602d498b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <span class="tt">this</span> RigidTransform from a <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and a position vector.  <br /></td></tr>
<tr class="memitem:a6e77b1e5fde8184fd5d18a62d00297bf" id="r_a6e77b1e5fde8184fd5d18a62d00297bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e77b1e5fde8184fd5d18a62d00297bf">SetFromIsometry3</a> (const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;pose)</td></tr>
<tr class="memdesc:a6e77b1e5fde8184fd5d18a62d00297bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <span class="tt">this</span> RigidTransform from an Eigen <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa" title="An Isometry templated on scalar type.">Isometry3</a>.  <br /></td></tr>
<tr class="memitem:a68bb6beace34c38645176116f321a653" id="r_a68bb6beace34c38645176116f321a653"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; <br />
requires <a class="el" href="group__default__scalars.html#gaf140364db7046208e67d85327722d34a">is_default_scalar</a>&lt;U&gt;</td></tr>
<tr class="memitem:a68bb6beace34c38645176116f321a653 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; U &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68bb6beace34c38645176116f321a653">cast</a> () const</td></tr>
<tr class="memdesc:a68bb6beace34c38645176116f321a653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a RigidTransform templatized on a scalar type U from a RigidTransform templatized on scalar type T.  <br /></td></tr>
<tr class="memitem:a808b88b9f515bbda1728a9cdc1a09b48" id="r_a808b88b9f515bbda1728a9cdc1a09b48"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a808b88b9f515bbda1728a9cdc1a09b48">rotation</a> () const</td></tr>
<tr class="memdesc:a808b88b9f515bbda1728a9cdc1a09b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns R_AB, the rotation matrix portion of <span class="tt">this</span> RigidTransform.  <br /></td></tr>
<tr class="memitem:a3e953a8287f40248d4d2c1030ef72cef" id="r_a3e953a8287f40248d4d2c1030ef72cef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e953a8287f40248d4d2c1030ef72cef">set_rotation</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;R)</td></tr>
<tr class="memdesc:a3e953a8287f40248d4d2c1030ef72cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the RotationMatrix portion of <span class="tt">this</span> RigidTransform.  <br /></td></tr>
<tr class="memitem:ab3c9f6da94bb9af6ec8426b32bbb5da3" id="r_ab3c9f6da94bb9af6ec8426b32bbb5da3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3c9f6da94bb9af6ec8426b32bbb5da3">set_rotation</a> (const <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html">RollPitchYaw</a>&lt; T &gt; &amp;rpy)</td></tr>
<tr class="memdesc:ab3c9f6da94bb9af6ec8426b32bbb5da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the rotation part of <span class="tt">this</span> RigidTransform from a <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html" title="This class represents the orientation between two arbitrary frames A and D associated with a Space-fi...">RollPitchYaw</a>.  <br /></td></tr>
<tr class="memitem:a9e5d6e6cb699351acd9c562fa2cfe139" id="r_a9e5d6e6cb699351acd9c562fa2cfe139"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e5d6e6cb699351acd9c562fa2cfe139">set_rotation</a> (const Eigen::Quaternion&lt; T &gt; &amp;quaternion)</td></tr>
<tr class="memdesc:a9e5d6e6cb699351acd9c562fa2cfe139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the rotation part of <span class="tt">this</span> RigidTransform from a <a class="el" href="namespacedrake.html#a4156bf453a5b323356d7cc784dfdf084" title="A quaternion templated on scalar type.">Quaternion</a>.  <br /></td></tr>
<tr class="memitem:a08c8cdccdeb018584d05a3d7557bf42c" id="r_a08c8cdccdeb018584d05a3d7557bf42c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08c8cdccdeb018584d05a3d7557bf42c">set_rotation</a> (const Eigen::AngleAxis&lt; T &gt; &amp;theta_lambda)</td></tr>
<tr class="memdesc:a08c8cdccdeb018584d05a3d7557bf42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the rotation part of <span class="tt">this</span> RigidTransform from an <a class="el" href="namespacedrake.html#a90d91e75997a81a48adea1e83caddde4" title="An AngleAxis templated on scalar type.">AngleAxis</a>.  <br /></td></tr>
<tr class="memitem:ae78c4bbe06336087e6d603a70337eb7a" id="r_ae78c4bbe06336087e6d603a70337eb7a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae78c4bbe06336087e6d603a70337eb7a">translation</a> () const</td></tr>
<tr class="memdesc:ae78c4bbe06336087e6d603a70337eb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">p_AoBo_A</span>, the position vector portion of <span class="tt">this</span> RigidTransform, i.e., position vector from Ao (frame A's origin) to Bo (frame B's origin).  <br /></td></tr>
<tr class="memitem:a1fe4dc36c56c493ac1e956ec185bdfea" id="r_a1fe4dc36c56c493ac1e956ec185bdfea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fe4dc36c56c493ac1e956ec185bdfea">set_translation</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a1fe4dc36c56c493ac1e956ec185bdfea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the position vector portion of <span class="tt">this</span> RigidTransform.  <br /></td></tr>
<tr class="memitem:a47dd6fe4ba8495b64354431a9a03ba1a" id="r_a47dd6fe4ba8495b64354431a9a03ba1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#ae74155a11dfcdaad0adc0349f0956148">Matrix4</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47dd6fe4ba8495b64354431a9a03ba1a">GetAsMatrix4</a> () const</td></tr>
<tr class="memdesc:a47dd6fe4ba8495b64354431a9a03ba1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 4x4 matrix associated with this RigidTransform, i.e., X_AB.  <br /></td></tr>
<tr class="memitem:acd6d54bbf91b49cbe466b99b28144ebe" id="r_acd6d54bbf91b49cbe466b99b28144ebe"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, 3, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd6d54bbf91b49cbe466b99b28144ebe">GetAsMatrix34</a> () const</td></tr>
<tr class="memdesc:acd6d54bbf91b49cbe466b99b28144ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 3x4 matrix associated with this RigidTransform, i.e., X_AB.  <br /></td></tr>
<tr class="memitem:ae3b91a3244e1920c0c97dd2abdea9614" id="r_ae3b91a3244e1920c0c97dd2abdea9614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3b91a3244e1920c0c97dd2abdea9614">GetAsIsometry3</a> () const</td></tr>
<tr class="memdesc:ae3b91a3244e1920c0c97dd2abdea9614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the isometry in ℜ³ that is equivalent to a RigidTransform.  <br /></td></tr>
<tr class="memitem:a02cd44da09fff8b8c44b00467d024882" id="r_a02cd44da09fff8b8c44b00467d024882"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02cd44da09fff8b8c44b00467d024882">SetIdentity</a> ()</td></tr>
<tr class="memdesc:a02cd44da09fff8b8c44b00467d024882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <span class="tt">this</span> RigidTransform so it corresponds to aligning the two frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is coincident with Bo.  <br /></td></tr>
<tr class="memitem:a99591d203623b6dfeca5973e9bfea77a" id="r_a99591d203623b6dfeca5973e9bfea77a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99591d203623b6dfeca5973e9bfea77a">IsExactlyIdentity</a> () const</td></tr>
<tr class="memdesc:a99591d203623b6dfeca5973e9bfea77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="tt">true</span> if <span class="tt">this</span> is exactly the identity RigidTransform.  <br /></td></tr>
<tr class="memitem:a712beef150db360b92f8c9fcb8fdcbd1" id="r_a712beef150db360b92f8c9fcb8fdcbd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a712beef150db360b92f8c9fcb8fdcbd1">IsNearlyIdentity</a> (double translation_tolerance) const</td></tr>
<tr class="memdesc:a712beef150db360b92f8c9fcb8fdcbd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <span class="tt">this</span> is within tolerance of the identity <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways.">RigidTransform</a>.  <br /></td></tr>
<tr class="memitem:ab6fa18f242cc0f43c410004bc84b74ef" id="r_ab6fa18f242cc0f43c410004bc84b74ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6fa18f242cc0f43c410004bc84b74ef">IsExactlyEqualTo</a> (const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:ab6fa18f242cc0f43c410004bc84b74ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <span class="tt">this</span> is exactly equal to <span class="tt">other</span>.  <br /></td></tr>
<tr class="memitem:a3edbf268e2c0e88bc0fa4af8e17ebc8a" id="r_a3edbf268e2c0e88bc0fa4af8e17ebc8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3edbf268e2c0e88bc0fa4af8e17ebc8a">IsNearlyEqualTo</a> (const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;other, double tolerance) const</td></tr>
<tr class="memdesc:a3edbf268e2c0e88bc0fa4af8e17ebc8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares each element of <span class="tt">this</span> to the corresponding element of <span class="tt">other</span> to check if they are the same to within a specified <span class="tt">tolerance</span>.  <br /></td></tr>
<tr class="memitem:a23359b06d3989e0a5f529fe7bae5bd0e" id="r_a23359b06d3989e0a5f529fe7bae5bd0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23359b06d3989e0a5f529fe7bae5bd0e">inverse</a> () const</td></tr>
<tr class="memdesc:a23359b06d3989e0a5f529fe7bae5bd0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns X_BA = X_AB⁻¹, the inverse of <span class="tt">this</span> RigidTransform.  <br /></td></tr>
<tr class="memitem:a72ea7ff40692f01b8454c9204be2d40d" id="r_a72ea7ff40692f01b8454c9204be2d40d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72ea7ff40692f01b8454c9204be2d40d">InvertAndCompose</a> (const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:a72ea7ff40692f01b8454c9204be2d40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the product of <span class="tt">this</span> inverted and another RigidTransform.  <br /></td></tr>
<tr class="memitem:aa6d583e730b5dd2193c7ff9f1293fcde" id="r_aa6d583e730b5dd2193c7ff9f1293fcde"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6d583e730b5dd2193c7ff9f1293fcde">GetMaximumAbsoluteDifference</a> (const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:aa6d583e730b5dd2193c7ff9f1293fcde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the infinity norm of <span class="tt">this</span> - <span class="tt">other</span> (i.e., the maximum absolute value of the difference between the elements of <span class="tt">this</span> and <span class="tt">other</span>).  <br /></td></tr>
<tr class="memitem:aa8b1205e300a07901a70079bbbd1e566" id="r_aa8b1205e300a07901a70079bbbd1e566"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8b1205e300a07901a70079bbbd1e566">GetMaximumAbsoluteTranslationDifference</a> (const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:aa8b1205e300a07901a70079bbbd1e566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum absolute value of the difference in the position vectors (translation) in <span class="tt">this</span> and <span class="tt">other</span>.  <br /></td></tr>
<tr class="memitem:ad4bfba92d9099ae059d7e99a999e8439" id="r_ad4bfba92d9099ae059d7e99a999e8439"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4bfba92d9099ae059d7e99a999e8439">operator*=</a> (const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:ad4bfba92d9099ae059d7e99a999e8439"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place multiply of <span class="tt">this</span> RigidTransform <span class="tt">X_AB</span> by <span class="tt">other</span> RigidTransform <span class="tt">X_BC</span>.  <br /></td></tr>
<tr class="memitem:a2ee60ab7e7a5bb203c791aa003891bc1" id="r_a2ee60ab7e7a5bb203c791aa003891bc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ee60ab7e7a5bb203c791aa003891bc1">operator*</a> (const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:a2ee60ab7e7a5bb203c791aa003891bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <span class="tt">this</span> RigidTransform <span class="tt">X_AB</span> by the <span class="tt">other</span> RigidTransform <span class="tt">X_BC</span> and returns the RigidTransform <span class="tt">X_AC = X_AB * X_BC</span>.  <br /></td></tr>
<tr class="memitem:a3f3e923539961bf94a0d7d36f8826f74" id="r_a3f3e923539961bf94a0d7d36f8826f74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f3e923539961bf94a0d7d36f8826f74">operator*</a> (const Eigen::Translation&lt; T, 3 &gt; &amp;X_BBq) const</td></tr>
<tr class="memdesc:a3f3e923539961bf94a0d7d36f8826f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <span class="tt">this</span> RigidTransform <span class="tt">X_AB</span> by the translation-only transform <span class="tt">X_BBq</span> and returns the RigidTransform <span class="tt">X_ABq = X_AB * X_BBq</span>.  <br /></td></tr>
<tr class="memitem:a8d73fccd3bc42d6556adc3f4ce0fbfed" id="r_a8d73fccd3bc42d6556adc3f4ce0fbfed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d73fccd3bc42d6556adc3f4ce0fbfed">operator*</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_BoQ_B) const</td></tr>
<tr class="memdesc:a8d73fccd3bc42d6556adc3f4ce0fbfed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <span class="tt">this</span> RigidTransform <span class="tt">X_AB</span> by the position vector <span class="tt">p_BoQ_B</span> which is from Bo (B's origin) to an arbitrary point Q.  <br /></td></tr>
<tr class="memitem:a8986e29d44179f1246bca20bbf0c47b5" id="r_a8986e29d44179f1246bca20bbf0c47b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8986e29d44179f1246bca20bbf0c47b5">operator*</a> (const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;vec_B) const</td></tr>
<tr class="memdesc:a8986e29d44179f1246bca20bbf0c47b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <span class="tt">this</span> RigidTransform <span class="tt">X_AB</span> by the 4-element vector <span class="tt">vec_B</span>, equivalent to <span class="tt">X_AB.GetAsMatrix4() * vec_B</span>.  <br /></td></tr>
<tr class="memitem:a431ac07f83c36c96f7d0b5a8ca328bb8" id="r_a431ac07f83c36c96f7d0b5a8ca328bb8"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a431ac07f83c36c96f7d0b5a8ca328bb8 template"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename Derived::Scalar, 3, Derived::ColsAtCompileTime &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a431ac07f83c36c96f7d0b5a8ca328bb8">operator*</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;p_BoQ_B) const</td></tr>
<tr class="memdesc:a431ac07f83c36c96f7d0b5a8ca328bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <span class="tt">this</span> RigidTransform <span class="tt">X_AB</span> by the n position vectors <span class="tt">p_BoQ1_B</span> ... <span class="tt">p_BoQn_B</span>, where <span class="tt">p_BoQi_B</span> is the iᵗʰ position vector from Bo (frame B's origin) to an arbitrary point Qi, expressed in frame B.  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:aaac6934d2979499ff35457a8583ce60a" id="r_aaac6934d2979499ff35457a8583ce60a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaac6934d2979499ff35457a8583ce60a">RigidTransform</a> (const RigidTransform &amp;)=default</td></tr>
<tr class="memitem:a6ea2138ca60a1fdf5189f5991241ee69" id="r_a6ea2138ca60a1fdf5189f5991241ee69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ea2138ca60a1fdf5189f5991241ee69">operator=</a> (const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a> &amp;)=default</td></tr>
<tr class="memitem:ada1d92575e2e4beb3bfa036983c33923" id="r_ada1d92575e2e4beb3bfa036983c33923"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada1d92575e2e4beb3bfa036983c33923">RigidTransform</a> (RigidTransform &amp;&amp;)=default</td></tr>
<tr class="memitem:a6896cbac677538de6908e05a42effe64" id="r_a6896cbac677538de6908e05a42effe64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6896cbac677538de6908e05a42effe64">operator=</a> (<a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a> &amp;&amp;)=default</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:adbc14bc43f7b74bdb7df327cc7606c75" id="r_adbc14bc43f7b74bdb7df327cc7606c75"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbc14bc43f7b74bdb7df327cc7606c75">MakeUnchecked</a> (const Eigen::Matrix&lt; T, 3, 4 &gt; &amp;pose)</td></tr>
<tr class="memdesc:adbc14bc43f7b74bdb7df327cc7606c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Constructs a RigidTransform from a 3x4 matrix, without any validity checks nor orthogonalization.  <br /></td></tr>
<tr class="memitem:a27f53c682e6c5d3d8a78b3eb71aa7852" id="r_a27f53c682e6c5d3d8a78b3eb71aa7852"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27f53c682e6c5d3d8a78b3eb71aa7852">Identity</a> ()</td></tr>
<tr class="memdesc:a27f53c682e6c5d3d8a78b3eb71aa7852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the identity RigidTransform (corresponds to coincident frames).  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-friends" class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8bedd8c483aaf5bc48587d10d7a3d485" id="r_a8bedd8c483aaf5bc48587d10d7a3d485"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:a8bedd8c483aaf5bc48587d10d7a3d485 template"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a></td></tr>
<tr class="memitem:aad69746f802afc1ffbbebecb31445648" id="r_aad69746f802afc1ffbbebecb31445648"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad69746f802afc1ffbbebecb31445648">operator*</a> (const Eigen::Translation&lt; T, 3 &gt; &amp;X_AAq, const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;X_AqB)</td></tr>
<tr class="memdesc:aad69746f802afc1ffbbebecb31445648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the translation-only transform <span class="tt">X_AAq</span> by the RigidTransform <span class="tt">X_AqB</span> and returns the RigidTransform <span class="tt">X_AB = X_AAq * X_AqB</span>.  <br /></td></tr>
<tr class="memitem:acd2efdeddc4b64780058383e5c96c1a1" id="r_acd2efdeddc4b64780058383e5c96c1a1"><td class="memTemplParams" colspan="2">template&lt;class HashAlgorithm&gt; </td></tr>
<tr class="memitem:acd2efdeddc4b64780058383e5c96c1a1 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd2efdeddc4b64780058383e5c96c1a1">hash_append</a> (HashAlgorithm &amp;hasher, const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a> &amp;X) noexcept</td></tr>
<tr class="memdesc:acd2efdeddc4b64780058383e5c96c1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the <a class="el" href="group__hash__append.html">hash_append generic hashing</a> concept.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-related" class="groupheader"><a id="related" name="related"></a>
Related Symbols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member symbols.) </p>
</td></tr>
<tr class="memitem:afdc48b2f77bba9b5873dc56ec1b7248d" id="r_afdc48b2f77bba9b5873dc56ec1b7248d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdc48b2f77bba9b5873dc56ec1b7248d">RigidTransformd</a> = <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt;double&gt;</td></tr>
<tr class="memdesc:afdc48b2f77bba9b5873dc56ec1b7248d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation (alias/typedef) for a <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways.">RigidTransform</a> double scalar type.  <br /></td></tr>
<tr class="memitem:a25d3e276d5e4e1fad974214851ce0b46" id="r_a25d3e276d5e4e1fad974214851ce0b46"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a25d3e276d5e4e1fad974214851ce0b46 template"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25d3e276d5e4e1fad974214851ce0b46">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;X)</td></tr>
<tr class="memdesc:a25d3e276d5e4e1fad974214851ce0b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream insertion operator to write an instance of <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways.">RigidTransform</a> into a <span class="tt">std::ostream</span>.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
(Internal use only) methods for specialized transforms</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="special_xform_def"></a> (Internal use only) If we have foreknowledge that a RigidTransform has some particular simplifications, we can exploit that knowledge to reduce the amount of computation required to form it and use it. The simplifications and associated notations for the rigid transform X_BC are:</p><ul>
<li>a "rotation transform" that contains a <em>general</em> rotation and zero (identity) translation (rX_BC),</li>
<li>a "translation transform" that contains a <em>general</em> translation and an <em>identity</em> rotation (tX_BC), and</li>
<li>an "axial rotation transform" that contains an <em>axial</em> rotation (see below) and zero translation (arX_BC), and</li>
<li>an "axial translation transform" that contains an <em>axial</em> translation and an <em>identity</em> rotation (atX_BC).</li>
</ul>
<p>See <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#axial_rotation_def">Axial rotations</a> for a definition. Similarly, an axial translation transform is a RigidTransform containing only a translation along one of the basis vectors (coordinate axes) +x, +y, +z. Notation: we use "a" for a general axis but substitute "x", "y", or "z" if we know the particular axis, e.g. zrX_BC (ztX_BC) would be an axial rotation (translation) transform containing a rotation about the z axis.</p>
<p>Specialized transforms have the property that of the twelve elements in their matrix representation some are "inactive", meaning that they have known values and never change during a simulation. For best performance, the algorithms in this section are permitted to <em>assume</em> those values without looking. However, those elements are still required to have the expected values, which are the values they would have in an identity transform (that is, 1 on the diagonal and 0 elsewhere). (Even when T is <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>, we insist that the inactive elements have the correct numerical values and don't require an Environment for evaluation.) This ensures that general purpose (non-specialized) code can still use the resulting transforms.</p>
<p>With <em>general</em> transforms (twelve active elements), transforming a vector takes 18 floating point operations, composing two transforms takes 63, and updating requires writing all twelve elements. The methods in this section take advantage of the specialized structures to reduce the number of operations required. Axial methods are templatized by the axis number 0, 1, or 2 (+x, +y, or +z axis, respectively). The number of operations required is documented with each method.</p>
<dl class="section warning"><dt>Warning</dt><dd>We depend on the caller's promise that specialized transform arguments actually have the indicated specialized structure; for performance reasons we do not verify that in Release builds although we may verify in Debug builds.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There are no Python bindings for these methods since there is nothing to be gained by using them in Python. Use the general equivalent RigidTransform methods instead. </dd></dl>
</td></tr>
<tr class="memitem:a914d49d7ec488c1637a61aa5a0ac623b" id="r_a914d49d7ec488c1637a61aa5a0ac623b"><td class="memTemplParams" colspan="2">template&lt;int axis&gt; </td></tr>
<tr class="memitem:a914d49d7ec488c1637a61aa5a0ac623b template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a914d49d7ec488c1637a61aa5a0ac623b">PostMultiplyByAxialRotation</a> (const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;arX_BC, <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; *X_AC) const</td></tr>
<tr class="memdesc:a914d49d7ec488c1637a61aa5a0ac623b"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) With <span class="tt">this</span> a general transform X_AB, and given an axial rotation transform arX_BC, efficiently calculates <span class="tt">X_AC = X_AB * arX_BC</span>.  <br /></td></tr>
<tr class="memitem:a6f42cce0628ab0cf42adf9f3986b3aa4" id="r_a6f42cce0628ab0cf42adf9f3986b3aa4"><td class="memTemplParams" colspan="2">template&lt;int axis&gt; </td></tr>
<tr class="memitem:a6f42cce0628ab0cf42adf9f3986b3aa4 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f42cce0628ab0cf42adf9f3986b3aa4">PreMultiplyByAxialRotation</a> (const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;arX_AB, <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; *X_AC) const</td></tr>
<tr class="memdesc:a6f42cce0628ab0cf42adf9f3986b3aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) With <span class="tt">this</span> a general transform X_BC, and given an axial rotation transform arX_AB, efficiently calculates <span class="tt">X_AC = arX_AB * X_BC</span>.  <br /></td></tr>
<tr class="memitem:a1799ba24af4042082a90b0d741bc0ee9" id="r_a1799ba24af4042082a90b0d741bc0ee9"><td class="memTemplParams" colspan="2">template&lt;int axis&gt; </td></tr>
<tr class="memitem:a1799ba24af4042082a90b0d741bc0ee9 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1799ba24af4042082a90b0d741bc0ee9">PostMultiplyByAxialTranslation</a> (const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;atX_BC, <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; *X_AC) const</td></tr>
<tr class="memdesc:a1799ba24af4042082a90b0d741bc0ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Composes <span class="tt">this</span> general transform X_AB with a given axial translation transform atX_BC to efficiently calculate <span class="tt">X_AC = X_AB * atX_BC</span>.  <br /></td></tr>
<tr class="memitem:a9cd0afeafec4e9996e417de29a8d1674" id="r_a9cd0afeafec4e9996e417de29a8d1674"><td class="memTemplParams" colspan="2">template&lt;int axis&gt; </td></tr>
<tr class="memitem:a9cd0afeafec4e9996e417de29a8d1674 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cd0afeafec4e9996e417de29a8d1674">PreMultiplyByAxialTranslation</a> (const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;atX_AB, <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; *X_AC) const</td></tr>
<tr class="memdesc:a9cd0afeafec4e9996e417de29a8d1674"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) With <span class="tt">this</span> a general transform X_BC, and given an axial translation transform atX_AB, efficiently calculates <span class="tt">X_AC = atX_AB * X_BC</span>.  <br /></td></tr>
<tr class="memitem:a40dd27d818f056170dd9bf9a694667a2" id="r_a40dd27d818f056170dd9bf9a694667a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40dd27d818f056170dd9bf9a694667a2">PostMultiplyByRotation</a> (const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;rX_BC, <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; *X_AC) const</td></tr>
<tr class="memdesc:a40dd27d818f056170dd9bf9a694667a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Composes <span class="tt">this</span> general transform X_AB with a given rotation-only transform rX_BC to efficiently calculate <span class="tt">X_AC = X_AB * rX_BC</span>.  <br /></td></tr>
<tr class="memitem:a0f648e42c9a51ab62f0547d250e2dcd1" id="r_a0f648e42c9a51ab62f0547d250e2dcd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f648e42c9a51ab62f0547d250e2dcd1">PostMultiplyByTranslation</a> (const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;tX_BC, <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; *X_AC) const</td></tr>
<tr class="memdesc:a0f648e42c9a51ab62f0547d250e2dcd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Composes <span class="tt">this</span> general transform X_AB with a given translation-only transform tX_BC to efficiently calculate <span class="tt">X_AC = X_AB * tX_BC</span>.  <br /></td></tr>
<tr class="memitem:a462450368f704c7e68d7768c60f55eed" id="r_a462450368f704c7e68d7768c60f55eed"><td class="memTemplParams" colspan="2">template&lt;int axis&gt; </td></tr>
<tr class="memitem:a462450368f704c7e68d7768c60f55eed template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a462450368f704c7e68d7768c60f55eed">MakeAxialRotation</a> (const T &amp;theta)</td></tr>
<tr class="memdesc:a462450368f704c7e68d7768c60f55eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Creates an axial rotation transform arX_AB consisting of only an axial rotation of <span class="tt">theta</span> radians about x, y, or z and no translation.  <br /></td></tr>
<tr class="memitem:abe4a4cdeb9a3dd8dafb6713b2360f78b" id="r_abe4a4cdeb9a3dd8dafb6713b2360f78b"><td class="memTemplParams" colspan="2">template&lt;int axis&gt; </td></tr>
<tr class="memitem:abe4a4cdeb9a3dd8dafb6713b2360f78b template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe4a4cdeb9a3dd8dafb6713b2360f78b">ApplyAxialRotation</a> (const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;arX_BC, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_C)</td></tr>
<tr class="memdesc:abe4a4cdeb9a3dd8dafb6713b2360f78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Given an axial rotation transform arX_BC (just an axial rotation and no translation), uses it to efficiently re-express a given vector.  <br /></td></tr>
<tr class="memitem:aaa0be3fe8c9ba4dffff8ade1c2070857" id="r_aaa0be3fe8c9ba4dffff8ade1c2070857"><td class="memTemplParams" colspan="2">template&lt;int axis&gt; </td></tr>
<tr class="memitem:aaa0be3fe8c9ba4dffff8ade1c2070857 template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa0be3fe8c9ba4dffff8ade1c2070857">UpdateAxialRotation</a> (const T &amp;theta, <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; *arX_BC)</td></tr>
<tr class="memdesc:aaa0be3fe8c9ba4dffff8ade1c2070857"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Given a new rotation angle θ, updates the axial rotation transform arX_BC to represent the new rotation angle.  <br /></td></tr>
<tr class="memitem:ad58984dbf6d96e27a1dc25062a768069" id="r_ad58984dbf6d96e27a1dc25062a768069"><td class="memTemplParams" colspan="2">template&lt;int axis&gt; </td></tr>
<tr class="memitem:ad58984dbf6d96e27a1dc25062a768069 template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad58984dbf6d96e27a1dc25062a768069">UpdateAxialRotation</a> (const T &amp;sin_theta, const T &amp;cos_theta, <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; *arX_BC)</td></tr>
<tr class="memdesc:ad58984dbf6d96e27a1dc25062a768069"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Given sin(θ) and cos(θ), where θ is a new rotation angle, updates the axial rotation transform arX_BC to represent the new rotation angle.  <br /></td></tr>
<tr class="memitem:a8c756da482eb99973ba0754ad3d53ea6" id="r_a8c756da482eb99973ba0754ad3d53ea6"><td class="memTemplParams" colspan="2">template&lt;int axis&gt; </td></tr>
<tr class="memitem:a8c756da482eb99973ba0754ad3d53ea6 template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c756da482eb99973ba0754ad3d53ea6">UpdateAxialTranslation</a> (const T &amp;distance, <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; *atX_BC)</td></tr>
<tr class="memdesc:a8c756da482eb99973ba0754ad3d53ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Given a new <span class="tt">distance</span>, updates the axial translation transform atX_BC to represent the new translation by that amount.  <br /></td></tr>
</table>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaac6934d2979499ff35457a8583ce60a" name="aaac6934d2979499ff35457a8583ce60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac6934d2979499ff35457a8583ce60a">&#9670;&#160;</a></span>RigidTransform() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RigidTransform </td>
          <td>(</td>
          <td class="paramtype">const RigidTransform&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ada1d92575e2e4beb3bfa036983c33923" name="ada1d92575e2e4beb3bfa036983c33923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1d92575e2e4beb3bfa036983c33923">&#9670;&#160;</a></span>RigidTransform() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RigidTransform </td>
          <td>(</td>
          <td class="paramtype">RigidTransform&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa71b78707a3d79cbcb1a8f3cc854bee" name="aaa71b78707a3d79cbcb1a8f3cc854bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa71b78707a3d79cbcb1a8f3cc854bee">&#9670;&#160;</a></span>RigidTransform() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RigidTransform </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the RigidTransform that corresponds to aligning the two frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is coincident with Bo. </p>
<p>Hence, the constructed RigidTransform contains an identity <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and a zero position vector. </p>

</div>
</div>
<a id="a079ca01bad5c04328237cfc47c73f7c6" name="a079ca01bad5c04328237cfc47c73f7c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079ca01bad5c04328237cfc47c73f7c6">&#9670;&#160;</a></span>RigidTransform() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RigidTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a RigidTransform from a rotation matrix and a position vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>rotation matrix relating frames A and B (e.g., <span class="tt">R_AB</span>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>position vector from frame A's origin to frame B's origin, expressed in frame A. In monogram notation p is denoted <span class="tt">p_AoBo_A</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadac43ad1559a232d321b36e501605fe" name="aadac43ad1559a232d321b36e501605fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadac43ad1559a232d321b36e501605fe">&#9670;&#160;</a></span>RigidTransform() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RigidTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html">RollPitchYaw</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rpy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a RigidTransform from a <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html" title="This class represents the orientation between two arbitrary frames A and D associated with a Space-fi...">RollPitchYaw</a> and a position vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rpy</td><td>a RollPitchYaw which is a Space-fixed (extrinsic) X-Y-Z rotation with "roll-pitch-yaw" angles <span class="tt">[r, p, y]</span> or equivalently a Body- fixed (intrinsic) Z-Y-X rotation with "yaw-pitch-roll" angles <span class="tt">[y, p, r]</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a05183386f55111df27e380877a9f11b2" title="Constructs a RotationMatrix from an RollPitchYaw.">RotationMatrix::RotationMatrix(const RollPitchYaw&lt;T&gt;&amp;)</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>position vector from frame A's origin to frame B's origin, expressed in frame A. In monogram notation p is denoted <span class="tt">p_AoBo_A</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a391249f5a5f48f189c7ff6572d6e3a19" name="a391249f5a5f48f189c7ff6572d6e3a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391249f5a5f48f189c7ff6572d6e3a19">&#9670;&#160;</a></span>RigidTransform() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RigidTransform </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quaternion</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a RigidTransform from a <a class="el" href="namespacedrake.html#a4156bf453a5b323356d7cc784dfdf084" title="A quaternion templated on scalar type.">Quaternion</a> and a position vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">quaternion</td><td>a non-zero, finite quaternion which may or may not have unit length [i.e., <span class="tt">quaternion.norm()</span> does not have to be 1]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>position vector from frame A's origin to frame B's origin, expressed in frame A. In monogram notation p is denoted <span class="tt">p_AoBo_A</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>in debug builds if the rotation matrix that is built from <span class="tt">quaternion</span> is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a7f6eb5993bd83412f92e82aa49873ae6" title="Constructs a RotationMatrix from an Eigen::Quaternion.">RotationMatrix::RotationMatrix(const Eigen::Quaternion&lt;T&gt;&amp;)</a> </dd></dl>

</div>
</div>
<a id="a0780a9ce724867fa65c009f0fbf82dc5" name="a0780a9ce724867fa65c009f0fbf82dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0780a9ce724867fa65c009f0fbf82dc5">&#9670;&#160;</a></span>RigidTransform() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RigidTransform </td>
          <td>(</td>
          <td class="paramtype">const Eigen::AngleAxis&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>theta_lambda</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a RigidTransform from an <a class="el" href="namespacedrake.html#a90d91e75997a81a48adea1e83caddde4" title="An AngleAxis templated on scalar type.">AngleAxis</a> and a position vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta_lambda</td><td>an Eigen::AngleAxis whose associated axis (vector direction herein called <span class="tt">lambda</span>) is non-zero and finite, but which may or may not have unit length [i.e., <span class="tt">lambda.norm()</span> does not have to be 1]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>position vector from frame A's origin to frame B's origin, expressed in frame A. In monogram notation p is denoted <span class="tt">p_AoBo_A</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>in debug builds if the rotation matrix that is built from <span class="tt">theta_lambda</span> is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#aeb8205e6418bc644739b23879344135b" title="Constructs a RotationMatrix from an Eigen::AngleAxis.">RotationMatrix::RotationMatrix(const Eigen::AngleAxis&lt;T&gt;&amp;)</a> </dd></dl>

</div>
</div>
<a id="ab8d99e85efd9f05d378ea0ecb922fcfa" name="ab8d99e85efd9f05d378ea0ecb922fcfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d99e85efd9f05d378ea0ecb922fcfa">&#9670;&#160;</a></span>RigidTransform() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RigidTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a RigidTransform with a given <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and a zero position vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>rotation matrix relating frames A and B (e.g., <span class="tt">R_AB</span>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbab39c825ec784b6162682de5e4cdf1" name="afbab39c825ec784b6162682de5e4cdf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbab39c825ec784b6162682de5e4cdf1">&#9670;&#160;</a></span>RigidTransform() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RigidTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a RigidTransform that contains an identity <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and a given position vector <span class="tt">p</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>position vector from frame A's origin to frame B's origin, expressed in frame A. In monogram notation p is denoted <span class="tt">p_AoBo_A</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae328b72ac0f21f3bcdd7abe9cc19144" name="aae328b72ac0f21f3bcdd7abe9cc19144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae328b72ac0f21f3bcdd7abe9cc19144">&#9670;&#160;</a></span>RigidTransform() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RigidTransform </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Translation&lt; T, 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>translation</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a RigidTransform that contains an identity <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and the position vector underlying the given <span class="tt"><a class="el" href="#ae78c4bbe06336087e6d603a70337eb7a" title="Returns p_AoBo_A, the position vector portion of this RigidTransform, i.e., position vector from Ao (...">translation</a></span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">translation</td><td>translation-only transform that stores p_AoQ_A, the position vector from frame A's origin to a point Q, expressed in frame A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The constructed RigidTransform <span class="tt">X_AAq</span> relates frame A to a frame Aq whose basis unit vectors are aligned with Ax, Ay, Az and whose origin position is located at point Q. </dd>
<dd>
This constructor provides an implicit conversion from Translation to RigidTransform. </dd></dl>

</div>
</div>
<a id="aa36e94d338e3be24e9fde24f1d58a4fb" name="aa36e94d338e3be24e9fde24f1d58a4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa36e94d338e3be24e9fde24f1d58a4fb">&#9670;&#160;</a></span>RigidTransform() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RigidTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pose</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a RigidTransform from an Eigen <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa" title="An Isometry templated on scalar type.">Isometry3</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pose</td><td><a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa" title="An Isometry templated on scalar type.">Isometry3</a> that contains an allegedly valid rotation matrix <span class="tt">R_AB</span> and also contains a position vector <span class="tt">p_AoBo_A</span> from frame A's origin to frame B's origin. <span class="tt">p_AoBo_A</span> must be expressed in frame A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>in debug builds if R_AB is not a proper orthonormal 3x3 rotation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>No attempt is made to orthogonalize the 3x3 rotation matrix part of <span class="tt">pose</span>. As needed, use <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a6d56a12637b832c1f89dde9c6b849925" title="Given an approximate rotation matrix M, finds the RotationMatrix R closest to M.">RotationMatrix::ProjectToRotationMatrix()</a>. </dd></dl>

</div>
</div>
<a id="aca9bb867abe5a56d1f4f9ae9c62df07b" name="aca9bb867abe5a56d1f4f9ae9c62df07b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9bb867abe5a56d1f4f9ae9c62df07b">&#9670;&#160;</a></span>RigidTransform() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RigidTransform </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pose</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a RigidTransform from a 3x4 matrix whose structure is below. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pose</td><td>3x4 matrix that contains an allegedly valid 3x3 rotation matrix <span class="tt">R_AB</span> and also a 3x1 position vector <span class="tt">p_AoBo_A</span> (the position vector from frame A's origin to frame B's origin, expressed in frame A). <pre>
 ┌                ┐
 │ R_AB  p_AoBo_A │
 └                ┘
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>in debug builds if the <span class="tt">R_AB</span> part of <span class="tt">pose</span> is not a proper orthonormal 3x3 rotation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>No attempt is made to orthogonalize the 3x3 rotation matrix part of <span class="tt">pose</span>. As needed, use <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a6d56a12637b832c1f89dde9c6b849925" title="Given an approximate rotation matrix M, finds the RotationMatrix R closest to M.">RotationMatrix::ProjectToRotationMatrix()</a>. </dd></dl>

</div>
</div>
<a id="a5d2232216392f2045d6907a99fa0b423" name="a5d2232216392f2045d6907a99fa0b423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2232216392f2045d6907a99fa0b423">&#9670;&#160;</a></span>RigidTransform() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RigidTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#ae74155a11dfcdaad0adc0349f0956148">Matrix4</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pose</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a RigidTransform from a 4x4 matrix whose structure is below. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pose</td><td>4x4 matrix that contains an allegedly valid 3x3 rotation matrix <span class="tt">R_AB</span> and also a 3x1 position vector <span class="tt">p_AoBo_A</span> (the position vector from frame A's origin to frame B's origin, expressed in frame A). <pre>
 ┌                ┐
 │ R_AB  p_AoBo_A │
 │                │
 │   0      1     │
 └                ┘
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>in debug builds if the <span class="tt">R_AB</span> part of <span class="tt">pose</span> is not a proper orthonormal 3x3 rotation matrix or if <span class="tt">pose</span> is a 4x4 matrix whose final row is not <span class="tt">[0, 0, 0, 1]</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>No attempt is made to orthogonalize the 3x3 rotation matrix part of <span class="tt">pose</span>. As needed, use <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a6d56a12637b832c1f89dde9c6b849925" title="Given an approximate rotation matrix M, finds the RotationMatrix R closest to M.">RotationMatrix::ProjectToRotationMatrix()</a>. </dd></dl>

</div>
</div>
<a id="ac7b8a89a54006ff4502298b5907f7e28" name="ac7b8a89a54006ff4502298b5907f7e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b8a89a54006ff4502298b5907f7e28">&#9670;&#160;</a></span>RigidTransform() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RigidTransform </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pose</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a RigidTransform from an appropriate Eigen <b>expression</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pose</td><td>Generic Eigen matrix <b>expression</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the Eigen <b>expression</b> in pose does not resolve to a <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2" title="A column vector of size 3, templated on scalar type.">Vector3</a> or 3x4 matrix or 4x4 matrix or if the rotational part of <span class="tt">pose</span> is not a proper orthonormal 3x3 rotation matrix or if <span class="tt">pose</span> is a 4x4 matrix whose final row is not <span class="tt">[0, 0, 0, 1]</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>No attempt is made to orthogonalize the 3x3 rotation matrix part of <span class="tt">pose</span>. As needed, use <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a6d56a12637b832c1f89dde9c6b849925" title="Given an approximate rotation matrix M, finds the RotationMatrix R closest to M.">RotationMatrix::ProjectToRotationMatrix()</a>. </dd>
<dd>
This constructor prevents ambiguity that would otherwise exist for a RigidTransform constructor whose argument is an Eigen <b>expression</b>. <div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_typedef" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3&lt;double&gt;</a> position(4, 5, 6);</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_friend" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform&lt;double&gt;</a> X1(3 * position);</div>
<div class="line">----------------------------------------------</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix&lt;double&gt;</a> R(<a class="code hl_class" href="classdrake_1_1math_1_1_roll_pitch_yaw.html">RollPitchYaw&lt;double&gt;</a>(1, 2, 3));</div>
<div class="line">Eigen::Matrix&lt;double, 3, 4&gt; pose34;</div>
<div class="line">pose34 &lt;&lt; R.matrix(), position;</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_friend" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform&lt;double&gt;</a> X2(1.0 * pose34);</div>
<div class="line">----------------------------------------------</div>
<div class="line">Eigen::Matrix&lt;double, 4, 4&gt; pose4;</div>
<div class="line">pose4 &lt;&lt; R.matrix(), position,</div>
<div class="line">         0, 0, 0, 1;</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_friend" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform&lt;double&gt;</a> X3(pose4 * pose4);</div>
<div class="ttc" id="aclassdrake_1_1math_1_1_rigid_transform_html_a8bedd8c483aaf5bc48587d10d7a3d485"><div class="ttname"><a href="#a8bedd8c483aaf5bc48587d10d7a3d485">drake::math::RigidTransform::RigidTransform</a></div><div class="ttdeci">friend class RigidTransform</div><div class="ttdef"><b>Definition</b> rigid_transform.h:941</div></div>
<div class="ttc" id="aclassdrake_1_1math_1_1_roll_pitch_yaw_html"><div class="ttname"><a href="classdrake_1_1math_1_1_roll_pitch_yaw.html">drake::math::RollPitchYaw</a></div><div class="ttdoc">This class represents the orientation between two arbitrary frames A and D associated with a Space-fi...</div><div class="ttdef"><b>Definition</b> roll_pitch_yaw.h:61</div></div>
<div class="ttc" id="aclassdrake_1_1math_1_1_rotation_matrix_html"><div class="ttname"><a href="classdrake_1_1math_1_1_rotation_matrix.html">drake::math::RotationMatrix</a></div><div class="ttdoc">This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...</div><div class="ttdef"><b>Definition</b> rotation_matrix.h:57</div></div>
<div class="ttc" id="anamespacedrake_html_a0ad29daab565ce347c4d1c5aae6a76c2"><div class="ttname"><a href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">drake::Vector3</a></div><div class="ttdeci">Eigen::Matrix&lt; Scalar, 3, 1 &gt; Vector3</div><div class="ttdoc">A column vector of size 3, templated on scalar type.</div><div class="ttdef"><b>Definition</b> eigen_types.h:48</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="abe4a4cdeb9a3dd8dafb6713b2360f78b" name="abe4a4cdeb9a3dd8dafb6713b2360f78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4a4cdeb9a3dd8dafb6713b2360f78b">&#9670;&#160;</a></span>ApplyAxialRotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;int axis&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; ApplyAxialRotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arX_BC</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_C</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Internal use only) Given an axial rotation transform arX_BC (just an axial rotation and no translation), uses it to efficiently re-express a given vector. </p>
<p>This takes only 6 floating point operations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arX_BC</td><td>the axial transform to be applied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_C</td><td>a position vector expressed in frame C, to be re-expressed in frame B since there is zero translation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">p_B</td><td>the input position vector p_C, now re-expressed in frame B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">axis</td><td>0, 1, or 2 corresponding to +x, +y, or +z rotation axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>arX_BC is an <a class="el" href="#special_xform_def">Axial rotation transform</a>. </dd></dl>

</div>
</div>
<a id="a68bb6beace34c38645176116f321a653" name="a68bb6beace34c38645176116f321a653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bb6beace34c38645176116f321a653">&#9670;&#160;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; <br />
requires <a class="el" href="group__default__scalars.html#gaf140364db7046208e67d85327722d34a">is_default_scalar</a>&lt;U&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; U &gt; cast </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a RigidTransform templatized on a scalar type U from a RigidTransform templatized on scalar type T. </p>
<p>For example, </p><div class="fragment"><div class="line"><a class="code hl_friend" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform&lt;double&gt;</a> source = <a class="code hl_function" href="#a27f53c682e6c5d3d8a78b3eb71aa7852">RigidTransform&lt;double&gt;::Identity</a>();</div>
<div class="line"><a class="code hl_friend" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform&lt;AutoDiffXd&gt;</a> foo = source.<a class="code hl_function" href="#a68bb6beace34c38645176116f321a653">cast</a>&lt;<a class="code hl_typedef" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854">AutoDiffXd</a>&gt;();</div>
<div class="ttc" id="aclassdrake_1_1math_1_1_rigid_transform_html_a27f53c682e6c5d3d8a78b3eb71aa7852"><div class="ttname"><a href="#a27f53c682e6c5d3d8a78b3eb71aa7852">drake::math::RigidTransform::Identity</a></div><div class="ttdeci">static const RigidTransform&lt; T &gt; &amp; Identity()</div><div class="ttdoc">Returns the identity RigidTransform (corresponds to coincident frames).</div><div class="ttdef"><b>Definition</b> rigid_transform.h:599</div></div>
<div class="ttc" id="aclassdrake_1_1math_1_1_rigid_transform_html_a68bb6beace34c38645176116f321a653"><div class="ttname"><a href="#a68bb6beace34c38645176116f321a653">drake::math::RigidTransform::cast</a></div><div class="ttdeci">RigidTransform&lt; U &gt; cast() const</div><div class="ttdoc">Creates a RigidTransform templatized on a scalar type U from a RigidTransform templatized on scalar t...</div><div class="ttdef"><b>Definition</b> rigid_transform.h:586</div></div>
<div class="ttc" id="anamespacedrake_html_a3d6302a0051e9403c9df3ed6808f3854"><div class="ttname"><a href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854">drake::AutoDiffXd</a></div><div class="ttdeci">drake::ad::AutoDiff AutoDiffXd</div><div class="ttdoc">A scalar type that performs automatic differentiation.</div><div class="ttdef"><b>Definition</b> autodiff.h:20</div></div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>Scalar type on which the returned RigidTransform is templated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><span class="tt"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways.">RigidTransform</a>&lt;From&gt;::<a class="el" href="#a68bb6beace34c38645176116f321a653" title="Creates a RigidTransform templatized on a scalar type U from a RigidTransform templatized on scalar t...">cast</a>&lt;To&gt;()</span> creates a new <span class="tt"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways.">RigidTransform</a>&lt;To&gt;</span> from a <span class="tt"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways.">RigidTransform</a>&lt;From&gt;</span> but only if type <span class="tt">To</span> is constructible from type <span class="tt">From</span>. This cast method works in accordance with Eigen's cast method for Eigen's objects that underlie this RigidTransform. For example, Eigen currently allows cast from type double to <a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854" title="A scalar type that performs automatic differentiation.">AutoDiffXd</a>, but not vice-versa. </dd></dl>

</div>
</div>
<a id="ae3b91a3244e1920c0c97dd2abdea9614" name="ae3b91a3244e1920c0c97dd2abdea9614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b91a3244e1920c0c97dd2abdea9614">&#9670;&#160;</a></span>GetAsIsometry3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; GetAsIsometry3 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the isometry in ℜ³ that is equivalent to a RigidTransform. </p>

</div>
</div>
<a id="acd6d54bbf91b49cbe466b99b28144ebe" name="acd6d54bbf91b49cbe466b99b28144ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6d54bbf91b49cbe466b99b28144ebe">&#9670;&#160;</a></span>GetAsMatrix34()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; T, 3, 4 &gt; GetAsMatrix34 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 3x4 matrix associated with this RigidTransform, i.e., X_AB. </p>
<pre>
 ┌                ┐
 │ R_AB  p_AoBo_A │
 └                ┘
</pre> 
</div>
</div>
<a id="a47dd6fe4ba8495b64354431a9a03ba1a" name="a47dd6fe4ba8495b64354431a9a03ba1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47dd6fe4ba8495b64354431a9a03ba1a">&#9670;&#160;</a></span>GetAsMatrix4()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#ae74155a11dfcdaad0adc0349f0956148">Matrix4</a>&lt; T &gt; GetAsMatrix4 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 4x4 matrix associated with this RigidTransform, i.e., X_AB. </p>
<pre>
 ┌                ┐
 │ R_AB  p_AoBo_A │
 │                │
 │   0      1     │
 └                ┘
</pre> 
</div>
</div>
<a id="aa6d583e730b5dd2193c7ff9f1293fcde" name="aa6d583e730b5dd2193c7ff9f1293fcde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d583e730b5dd2193c7ff9f1293fcde">&#9670;&#160;</a></span>GetMaximumAbsoluteDifference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T GetMaximumAbsoluteDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the infinity norm of <span class="tt">this</span> - <span class="tt">other</span> (i.e., the maximum absolute value of the difference between the elements of <span class="tt">this</span> and <span class="tt">other</span>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>RigidTransform to subtract from <span class="tt">this</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>‖<span class="tt">this</span> - <span class="tt">other</span>‖∞ </dd></dl>

</div>
</div>
<a id="aa8b1205e300a07901a70079bbbd1e566" name="aa8b1205e300a07901a70079bbbd1e566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b1205e300a07901a70079bbbd1e566">&#9670;&#160;</a></span>GetMaximumAbsoluteTranslationDifference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T GetMaximumAbsoluteTranslationDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum absolute value of the difference in the position vectors (translation) in <span class="tt">this</span> and <span class="tt">other</span>. </p>
<p>In other words, returns the infinity norm of the difference in the position vectors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>RigidTransform whose position vector is subtracted from the position vector in <span class="tt">this</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27f53c682e6c5d3d8a78b3eb71aa7852" name="a27f53c682e6c5d3d8a78b3eb71aa7852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f53c682e6c5d3d8a78b3eb71aa7852">&#9670;&#160;</a></span>Identity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp; Identity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the identity RigidTransform (corresponds to coincident frames). </p>
<dl class="section return"><dt>Returns</dt><dd>the RigidTransform that corresponds to aligning the two frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is coincident with Bo. Hence, the returned RigidTransform contains a 3x3 identity matrix and a zero position vector. </dd></dl>

</div>
</div>
<a id="a23359b06d3989e0a5f529fe7bae5bd0e" name="a23359b06d3989e0a5f529fe7bae5bd0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23359b06d3989e0a5f529fe7bae5bd0e">&#9670;&#160;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; inverse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns X_BA = X_AB⁻¹, the inverse of <span class="tt">this</span> RigidTransform. </p>
<dl class="section note"><dt>Note</dt><dd>The inverse of RigidTransform X_AB is X_BA, which contains the rotation matrix R_BA = R_AB⁻¹ = R_ABᵀ and the position vector <span class="tt">p_BoAo_B_</span> (position from B's origin Bo to A's origin Ao, expressed in frame B). </dd>
<dd>
: The square-root of a RigidTransform's condition number is roughly the magnitude of the position vector. The accuracy of the calculation for the inverse of a RigidTransform drops off with the sqrt condition number. </dd></dl>

</div>
</div>
<a id="a72ea7ff40692f01b8454c9204be2d40d" name="a72ea7ff40692f01b8454c9204be2d40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ea7ff40692f01b8454c9204be2d40d">&#9670;&#160;</a></span>InvertAndCompose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; InvertAndCompose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the product of <span class="tt">this</span> inverted and another RigidTransform. </p>
<p>If you consider <span class="tt">this</span> to be the transform X_AB, and <span class="tt">other</span> to be X_AC, then this method returns X_BC = X_AB⁻¹ * X_AC. For T==double, this method can be <em>much</em> faster than inverting first and then performing the composition, because it can take advantage of the special structure of a rigid transform to avoid unnecessary memory and floating point operations. On some platforms it can use SIMD instructions for further speedups. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>RigidTransform that post-multiplies <span class="tt">this</span> inverted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">X_BC</td><td>where X_BC = this⁻¹ * other. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is possible (albeit improbable) to create an invalid rigid transform by accumulating round-off error with a large number of multiplies. </dd></dl>

</div>
</div>
<a id="ab6fa18f242cc0f43c410004bc84b74ef" name="ab6fa18f242cc0f43c410004bc84b74ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6fa18f242cc0f43c410004bc84b74ef">&#9670;&#160;</a></span>IsExactlyEqualTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt; IsExactlyEqualTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <span class="tt">this</span> is exactly equal to <span class="tt">other</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>RigidTransform to compare to <span class="tt">this</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if each element of <span class="tt">this</span> is exactly equal to the corresponding element of <span class="tt">other</span>. </dd></dl>

</div>
</div>
<a id="a99591d203623b6dfeca5973e9bfea77a" name="a99591d203623b6dfeca5973e9bfea77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99591d203623b6dfeca5973e9bfea77a">&#9670;&#160;</a></span>IsExactlyIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt; IsExactlyIdentity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="tt">true</span> if <span class="tt">this</span> is exactly the identity RigidTransform. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a712beef150db360b92f8c9fcb8fdcbd1" title="Returns true if this is within tolerance of the identity RigidTransform.">IsNearlyIdentity()</a>. </dd></dl>

</div>
</div>
<a id="a3edbf268e2c0e88bc0fa4af8e17ebc8a" name="a3edbf268e2c0e88bc0fa4af8e17ebc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3edbf268e2c0e88bc0fa4af8e17ebc8a">&#9670;&#160;</a></span>IsNearlyEqualTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt; IsNearlyEqualTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares each element of <span class="tt">this</span> to the corresponding element of <span class="tt">other</span> to check if they are the same to within a specified <span class="tt">tolerance</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>RigidTransform to compare to <span class="tt">this</span>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>maximum allowable absolute difference between the elements in <span class="tt">this</span> and <span class="tt">other</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if <span class="tt">‖this.matrix() - other.matrix()‖∞ &lt;= tolerance</span>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Consider scaling tolerance with the largest of magA and magB, where magA and magB denoted the magnitudes of <span class="tt">this</span> position vector and <span class="tt">other</span> position vectors, respectively. </dd></dl>

</div>
</div>
<a id="a712beef150db360b92f8c9fcb8fdcbd1" name="a712beef150db360b92f8c9fcb8fdcbd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712beef150db360b92f8c9fcb8fdcbd1">&#9670;&#160;</a></span>IsNearlyIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt; IsNearlyIdentity </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>translation_tolerance</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <span class="tt">this</span> is within tolerance of the identity <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways.">RigidTransform</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">translation_tolerance</td><td>a non-negative number. One way to choose <span class="tt">translation_tolerance</span> is to multiply a characteristic length (e.g., the magnitude of a characteristic position vector) by an epsilon (e.g., <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a2013671d440f9093574739914d147280" title="Returns an internal tolerance that checks rotation matrix orthonormality.">RotationMatrix::get_internal_tolerance_for_orthonormality()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> portion of <span class="tt">this</span> satisfies <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a4354b4928f8e10dc8a7443f248de5ba2" title="Returns true if this is within tolerance of the identity RigidTransform.">RotationMatrix::IsNearlyIdentity()</a> and if the position vector portion of <span class="tt">this</span> is equal to zero vector within <span class="tt">translation_tolerance</span>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a99591d203623b6dfeca5973e9bfea77a" title="Returns true if this is exactly the identity RigidTransform.">IsExactlyIdentity()</a>. </dd></dl>

</div>
</div>
<a id="a462450368f704c7e68d7768c60f55eed" name="a462450368f704c7e68d7768c60f55eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462450368f704c7e68d7768c60f55eed">&#9670;&#160;</a></span>MakeAxialRotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;int axis&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; MakeAxialRotation </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>theta</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Internal use only) Creates an axial rotation transform arX_AB consisting of only an axial rotation of <span class="tt">theta</span> radians about x, y, or z and no translation. </p>
<p>Of the 12 entries in the transform matrix, only 4 are active; the rest will be set to 0 or 1. This structure can be exploited for efficient updating and operating with this transform. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>the rotation angle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">arX_BC</td><td>the axial transform (also known as X_BC(theta)). </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">axis</td><td>0, 1, or 2 corresponding to +x, +y, or +z rotation axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#special_xform_def">Specialized transforms</a>. </dd></dl>

</div>
</div>
<a id="adbc14bc43f7b74bdb7df327cc7606c75" name="adbc14bc43f7b74bdb7df327cc7606c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc14bc43f7b74bdb7df327cc7606c75">&#9670;&#160;</a></span>MakeUnchecked()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; MakeUnchecked </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pose</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Advanced) Constructs a RigidTransform from a 3x4 matrix, without any validity checks nor orthogonalization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pose</td><td>3x4 matrix that contains a 3x3 rotation matrix <span class="tt">R_AB</span> and also a 3x1 position vector <span class="tt">p_AoBo_A</span> (the position vector from frame A's origin to frame B's origin, expressed in frame A). <pre>
 ┌                ┐
 │ R_AB  p_AoBo_A │
 └                ┘
</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a431ac07f83c36c96f7d0b5a8ca328bb8" name="a431ac07f83c36c96f7d0b5a8ca328bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431ac07f83c36c96f7d0b5a8ca328bb8">&#9670;&#160;</a></span>operator*() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; typename Derived::Scalar, 3, Derived::ColsAtCompileTime &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_BoQ_B</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies <span class="tt">this</span> RigidTransform <span class="tt">X_AB</span> by the n position vectors <span class="tt">p_BoQ1_B</span> ... <span class="tt">p_BoQn_B</span>, where <span class="tt">p_BoQi_B</span> is the iᵗʰ position vector from Bo (frame B's origin) to an arbitrary point Qi, expressed in frame B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BoQ_B</td><td><span class="tt">3 x n</span> matrix with n position vectors <span class="tt">p_BoQi_B</span> or an expression that resolves to a <span class="tt">3 x n</span> matrix of position vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">p_AoQ_A</td><td><span class="tt">3 x n</span> matrix with n position vectors <span class="tt">p_AoQi_A</span>, i.e., n position vectors from Ao (frame A's origin) to Qi, expressed in frame A. Specifically, this operator* is defined so that <span class="tt">X_AB * p_BoQ_B</span> returns <span class="tt">p_AoQ_A = p_AoBo_A + R_AB * p_BoQ_B</span>, where <span class="tt">p_AoBo_A</span> is the position vector from Ao to Bo expressed in A and <span class="tt">R_AB</span> is the rotation matrix relating the orientation of frames A and B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>As needed, use parentheses. This operator* is not associative. To see this, let <span class="tt">p = p_AoBo_A</span>, <span class="tt">q = p_BoQ_B</span> and note (X_AB * q) * 7 = (p + R_AB * q) * 7 ≠ X_AB * (q * 7) = p + R_AB * (q * 7). <div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classdrake_1_1math_1_1_roll_pitch_yaw.html">RollPitchYaw&lt;double&gt;</a> rpy(0.1, 0.2, 0.3);</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_friend" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform&lt;double&gt;</a> X_AB(rpy, Vector3d(1, 2, 3));</div>
<div class="line">Eigen::Matrix&lt;double, 3, 2&gt; p_BoQ_B;</div>
<div class="line">p_BoQ_B.col(0) = Vector3d(4, 5, 6);</div>
<div class="line">p_BoQ_B.col(1) = Vector3d(9, 8, 7);</div>
<div class="line"><span class="keyword">const</span> Eigen::Matrix&lt;double, 3, 2&gt; p_AoQ_A = X_AB * p_BoQ_B;</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a3f3e923539961bf94a0d7d36f8826f74" name="a3f3e923539961bf94a0d7d36f8826f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3e923539961bf94a0d7d36f8826f74">&#9670;&#160;</a></span>operator*() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Translation&lt; T, 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_BBq</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies <span class="tt">this</span> RigidTransform <span class="tt">X_AB</span> by the translation-only transform <span class="tt">X_BBq</span> and returns the RigidTransform <span class="tt">X_ABq = X_AB * X_BBq</span>. </p>
<dl class="section note"><dt>Note</dt><dd>The rotation matrix in the returned RigidTransform <span class="tt">X_ABq</span> is equal to the rotation matrix in <span class="tt">X_AB</span>. <span class="tt">X_ABq</span> and <span class="tt">X_AB</span> only differ by origin location. </dd></dl>

</div>
</div>
<a id="a2ee60ab7e7a5bb203c791aa003891bc1" name="a2ee60ab7e7a5bb203c791aa003891bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee60ab7e7a5bb203c791aa003891bc1">&#9670;&#160;</a></span>operator*() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies <span class="tt">this</span> RigidTransform <span class="tt">X_AB</span> by the <span class="tt">other</span> RigidTransform <span class="tt">X_BC</span> and returns the RigidTransform <span class="tt">X_AC = X_AB * X_BC</span>. </p>

</div>
</div>
<a id="a8d73fccd3bc42d6556adc3f4ce0fbfed" name="a8d73fccd3bc42d6556adc3f4ce0fbfed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d73fccd3bc42d6556adc3f4ce0fbfed">&#9670;&#160;</a></span>operator*() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p_BoQ_B</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies <span class="tt">this</span> RigidTransform <span class="tt">X_AB</span> by the position vector <span class="tt">p_BoQ_B</span> which is from Bo (B's origin) to an arbitrary point Q. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BoQ_B</td><td>position vector from Bo to Q, expressed in frame B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">p_AoQ_A</td><td>position vector from Ao to Q, expressed in frame A. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8986e29d44179f1246bca20bbf0c47b5" name="a8986e29d44179f1246bca20bbf0c47b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8986e29d44179f1246bca20bbf0c47b5">&#9670;&#160;</a></span>operator*() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec_B</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies <span class="tt">this</span> RigidTransform <span class="tt">X_AB</span> by the 4-element vector <span class="tt">vec_B</span>, equivalent to <span class="tt">X_AB.GetAsMatrix4() * vec_B</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec_B</td><td>4-element vector whose first 3 elements are the position vector p_BoQ_B from Bo (frame B's origin) to an arbitrary point Q, expressed in frame B and whose 4ᵗʰ element is 1 𝐨𝐫 whose first 3 elements are a vector (maybe unrelated to Bo or Q) and whose 4ᵗʰ element is 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">vec_A</td><td>4-element vector whose first 3 elements are the position vector p_AoQ_A from Ao (frame A's origin) to Q, expressed in frame A and whose 4ᵗʰ element is 1 𝐨𝐫 whose first 3 elements are a vector (maybe unrelated to Bo and Q) and whose 4ᵗʰ element is 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the 4ᵗʰ element of vec_B is not 0 or 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4bfba92d9099ae059d7e99a999e8439" name="ad4bfba92d9099ae059d7e99a999e8439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4bfba92d9099ae059d7e99a999e8439">&#9670;&#160;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In-place multiply of <span class="tt">this</span> RigidTransform <span class="tt">X_AB</span> by <span class="tt">other</span> RigidTransform <span class="tt">X_BC</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>RigidTransform that post-multiplies <span class="tt">this</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">this</span> RigidTransform which has been multiplied by <span class="tt">other</span>. On return, <span class="tt">this = X_AC</span>, where <span class="tt">X_AC = X_AB * X_BC</span>. </dd></dl>

</div>
</div>
<a id="a6ea2138ca60a1fdf5189f5991241ee69" name="a6ea2138ca60a1fdf5189f5991241ee69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea2138ca60a1fdf5189f5991241ee69">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6896cbac677538de6908e05a42effe64" name="a6896cbac677538de6908e05a42effe64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6896cbac677538de6908e05a42effe64">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a914d49d7ec488c1637a61aa5a0ac623b" name="a914d49d7ec488c1637a61aa5a0ac623b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a914d49d7ec488c1637a61aa5a0ac623b">&#9670;&#160;</a></span>PostMultiplyByAxialRotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;int axis&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void PostMultiplyByAxialRotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arX_BC</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>X_AC</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) With <span class="tt">this</span> a general transform X_AB, and given an axial rotation transform arX_BC, efficiently calculates <span class="tt">X_AC = X_AB * arX_BC</span>. </p>
<p>This requires only 18 floating point operations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arX_BC</td><td>An axial rotation transform about the indicated <span class="tt">axis</span>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X_AC</td><td>Preallocated space for the result, which will be a general transform. Must not overlap with <span class="tt">this</span> in memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">axis</td><td>0, 1, or 2 corresponding to +x, +y, or +z rotation axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>arX_BC is an <a class="el" href="#special_xform_def">Axial rotation transform</a> </dd>
<dd>
X_AC does not overlap with <span class="tt">this</span> in memory. </dd></dl>

</div>
</div>
<a id="a1799ba24af4042082a90b0d741bc0ee9" name="a1799ba24af4042082a90b0d741bc0ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1799ba24af4042082a90b0d741bc0ee9">&#9670;&#160;</a></span>PostMultiplyByAxialTranslation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;int axis&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void PostMultiplyByAxialTranslation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>atX_BC</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>X_AC</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Composes <span class="tt">this</span> general transform X_AB with a given axial translation transform atX_BC to efficiently calculate <span class="tt">X_AC = X_AB * atX_BC</span>. </p>
<p>This requires only 6 floating point operations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">atX_BC</td><td>An axial translation transform about the indicated <span class="tt">axis</span>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X_AC</td><td>Preallocated space for the result, which will be a general transform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">axis</td><td>0, 1, or 2 corresponding to +x, +y, or +z rotation axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>atX_BC is an <a class="el" href="#special_xform_def">Axial translation transform</a>. </dd></dl>

</div>
</div>
<a id="a40dd27d818f056170dd9bf9a694667a2" name="a40dd27d818f056170dd9bf9a694667a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40dd27d818f056170dd9bf9a694667a2">&#9670;&#160;</a></span>PostMultiplyByRotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void PostMultiplyByRotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rX_BC</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>X_AC</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Composes <span class="tt">this</span> general transform X_AB with a given rotation-only transform rX_BC to efficiently calculate <span class="tt">X_AC = X_AB * rX_BC</span>. </p>
<p>This requires 45 floating point operations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rX_BC</td><td>the rotation-only transform. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X_AC</td><td>Preallocated space for the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>rX_BC is a <a class="el" href="#special_xform_def">Rotation transform</a>. </dd></dl>

</div>
</div>
<a id="a0f648e42c9a51ab62f0547d250e2dcd1" name="a0f648e42c9a51ab62f0547d250e2dcd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f648e42c9a51ab62f0547d250e2dcd1">&#9670;&#160;</a></span>PostMultiplyByTranslation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void PostMultiplyByTranslation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tX_BC</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>X_AC</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) Composes <span class="tt">this</span> general transform X_AB with a given translation-only transform tX_BC to efficiently calculate <span class="tt">X_AC = X_AB * tX_BC</span>. </p>
<p>This requires only 18 floating point operations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tX_BC</td><td>the translation-only transform. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X_AC</td><td>preallocated space for the result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>tX_BC is a <a class="el" href="#special_xform_def">Translation transform</a>. </dd></dl>

</div>
</div>
<a id="a6f42cce0628ab0cf42adf9f3986b3aa4" name="a6f42cce0628ab0cf42adf9f3986b3aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f42cce0628ab0cf42adf9f3986b3aa4">&#9670;&#160;</a></span>PreMultiplyByAxialRotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;int axis&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void PreMultiplyByAxialRotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arX_AB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>X_AC</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) With <span class="tt">this</span> a general transform X_BC, and given an axial rotation transform arX_AB, efficiently calculates <span class="tt">X_AC = arX_AB * X_BC</span>. </p>
<p>This requires only 24 floating point operations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arX_AB</td><td>An axial rotation transform about the indicated <span class="tt">axis</span>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X_AC</td><td>Preallocated space for the result, which will be a general transform. Must not overlap with arX_BC or <span class="tt">this</span> in memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">axis</td><td>0, 1, or 2 corresponding to +x, +y, or +z rotation axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>arX_AB is an <a class="el" href="#special_xform_def">Axial rotation transform</a> </dd>
<dd>
X_AC does not overlap with arX_AB or <span class="tt">this</span> in memory. </dd></dl>

</div>
</div>
<a id="a9cd0afeafec4e9996e417de29a8d1674" name="a9cd0afeafec4e9996e417de29a8d1674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd0afeafec4e9996e417de29a8d1674">&#9670;&#160;</a></span>PreMultiplyByAxialTranslation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;int axis&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void PreMultiplyByAxialTranslation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>atX_AB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>X_AC</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Internal use only) With <span class="tt">this</span> a general transform X_BC, and given an axial translation transform atX_AB, efficiently calculates <span class="tt">X_AC = atX_AB * X_BC</span>. </p>
<p>This requires just 1 floating point operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">atX_AB</td><td>An axial translation transform along the indicated <span class="tt">axis</span>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X_AC</td><td>Preallocated space for the result, which will be a general transform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">axis</td><td>0, 1, or 2 corresponding to +x, +y, or +z translation axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>atX_AB is an <a class="el" href="#special_xform_def">Axial translation transform</a> </dd></dl>

</div>
</div>
<a id="a808b88b9f515bbda1728a9cdc1a09b48" name="a808b88b9f515bbda1728a9cdc1a09b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808b88b9f515bbda1728a9cdc1a09b48">&#9670;&#160;</a></span>rotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp; rotation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns R_AB, the rotation matrix portion of <span class="tt">this</span> RigidTransform. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">R_AB</td><td>the rotation matrix portion of <span class="tt">this</span> RigidTransform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae31756c2694bacdfdf6b0c75602d498b" name="ae31756c2694bacdfdf6b0c75602d498b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31756c2694bacdfdf6b0c75602d498b">&#9670;&#160;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <span class="tt">this</span> RigidTransform from a <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and a position vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>rotation matrix relating frames A and B (e.g., <span class="tt">R_AB</span>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>position vector from frame A's origin to frame B's origin, expressed in frame A. In monogram notation p is denoted <span class="tt">p_AoBo_A</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08c8cdccdeb018584d05a3d7557bf42c" name="a08c8cdccdeb018584d05a3d7557bf42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c8cdccdeb018584d05a3d7557bf42c">&#9670;&#160;</a></span>set_rotation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_rotation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::AngleAxis&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>theta_lambda</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the rotation part of <span class="tt">this</span> RigidTransform from an <a class="el" href="namespacedrake.html#a90d91e75997a81a48adea1e83caddde4" title="An AngleAxis templated on scalar type.">AngleAxis</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta_lambda</td><td>an angle <span class="tt">theta</span> (in radians) and vector <span class="tt">lambda</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#aeb8205e6418bc644739b23879344135b" title="Constructs a RotationMatrix from an Eigen::AngleAxis.">RotationMatrix::RotationMatrix(const Eigen::AngleAxis&lt;T&gt;&amp;)</a> which describes the parameter, preconditions, exception conditions, etc. </dd></dl>

</div>
</div>
<a id="a9e5d6e6cb699351acd9c562fa2cfe139" name="a9e5d6e6cb699351acd9c562fa2cfe139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5d6e6cb699351acd9c562fa2cfe139">&#9670;&#160;</a></span>set_rotation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_rotation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quaternion</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the rotation part of <span class="tt">this</span> RigidTransform from a <a class="el" href="namespacedrake.html#a4156bf453a5b323356d7cc784dfdf084" title="A quaternion templated on scalar type.">Quaternion</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">quaternion</td><td>a quaternion which may or may not have unit length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a7f6eb5993bd83412f92e82aa49873ae6" title="Constructs a RotationMatrix from an Eigen::Quaternion.">RotationMatrix::RotationMatrix(const Eigen::Quaternion&lt;T&gt;&amp;)</a> which describes the parameter, preconditions, exception conditions, etc. </dd></dl>

</div>
</div>
<a id="ab3c9f6da94bb9af6ec8426b32bbb5da3" name="ab3c9f6da94bb9af6ec8426b32bbb5da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c9f6da94bb9af6ec8426b32bbb5da3">&#9670;&#160;</a></span>set_rotation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_rotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html">RollPitchYaw</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rpy</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the rotation part of <span class="tt">this</span> RigidTransform from a <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html" title="This class represents the orientation between two arbitrary frames A and D associated with a Space-fi...">RollPitchYaw</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rpy</td><td>"roll-pitch-yaw" angles. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a05183386f55111df27e380877a9f11b2" title="Constructs a RotationMatrix from an RollPitchYaw.">RotationMatrix::RotationMatrix(const RollPitchYaw&lt;T&gt;&amp;)</a> which describes the parameter, preconditions, etc. </dd></dl>

</div>
</div>
<a id="a3e953a8287f40248d4d2c1030ef72cef" name="a3e953a8287f40248d4d2c1030ef72cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e953a8287f40248d4d2c1030ef72cef">&#9670;&#160;</a></span>set_rotation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_rotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the RotationMatrix portion of <span class="tt">this</span> RigidTransform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>rotation matrix relating frames A and B (e.g., <span class="tt">R_AB</span>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fe4dc36c56c493ac1e956ec185bdfea" name="a1fe4dc36c56c493ac1e956ec185bdfea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe4dc36c56c493ac1e956ec185bdfea">&#9670;&#160;</a></span>set_translation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_translation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the position vector portion of <span class="tt">this</span> RigidTransform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>position vector from Ao (frame A's origin) to Bo (frame B's origin) expressed in frame A. In monogram notation p is denoted p_AoBo_A. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e77b1e5fde8184fd5d18a62d00297bf" name="a6e77b1e5fde8184fd5d18a62d00297bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e77b1e5fde8184fd5d18a62d00297bf">&#9670;&#160;</a></span>SetFromIsometry3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SetFromIsometry3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pose</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <span class="tt">this</span> RigidTransform from an Eigen <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa" title="An Isometry templated on scalar type.">Isometry3</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pose</td><td><a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa" title="An Isometry templated on scalar type.">Isometry3</a> that contains an allegedly valid rotation matrix <span class="tt">R_AB</span> and also contains a position vector <span class="tt">p_AoBo_A</span> from frame A's origin to frame B's origin. <span class="tt">p_AoBo_A</span> must be expressed in frame A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>in debug builds if R_AB is not a proper orthonormal 3x3 rotation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>No attempt is made to orthogonalize the 3x3 rotation matrix part of <span class="tt">pose</span>. As needed, use <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a6d56a12637b832c1f89dde9c6b849925" title="Given an approximate rotation matrix M, finds the RotationMatrix R closest to M.">RotationMatrix::ProjectToRotationMatrix()</a>. </dd></dl>

</div>
</div>
<a id="a02cd44da09fff8b8c44b00467d024882" name="a02cd44da09fff8b8c44b00467d024882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02cd44da09fff8b8c44b00467d024882">&#9670;&#160;</a></span>SetIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp; SetIdentity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <span class="tt">this</span> RigidTransform so it corresponds to aligning the two frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is coincident with Bo. </p>
<p>Hence, <span class="tt">this</span> RigidTransform contains a 3x3 identity matrix and a zero position vector. </p>

</div>
</div>
<a id="ae78c4bbe06336087e6d603a70337eb7a" name="ae78c4bbe06336087e6d603a70337eb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78c4bbe06336087e6d603a70337eb7a">&#9670;&#160;</a></span>translation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp; translation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="tt">p_AoBo_A</span>, the position vector portion of <span class="tt">this</span> RigidTransform, i.e., position vector from Ao (frame A's origin) to Bo (frame B's origin). </p>

</div>
</div>
<a id="ad58984dbf6d96e27a1dc25062a768069" name="ad58984dbf6d96e27a1dc25062a768069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58984dbf6d96e27a1dc25062a768069">&#9670;&#160;</a></span>UpdateAxialRotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;int axis&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UpdateAxialRotation </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>sin_theta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>cos_theta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>arX_BC</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Internal use only) Given sin(θ) and cos(θ), where θ is a new rotation angle, updates the axial rotation transform arX_BC to represent the new rotation angle. </p>
<p>We expect that arX_BC was already such a transform (about the given x, y, or z axis). Only the 4 active elements are modified; the other 8 remain unchanged. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sin_theta</td><td>sin(θ), where θ is the new rotation angle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cos_theta</td><td>cos(θ), where θ is the new rotation angle. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">arX_BC</td><td>the axial rotation transform matrix to be updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">axis</td><td>0, 1, or 2 corresponding to +x, +y, or +z rotation axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>the overloaded signature if you just have the angle θ. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>arX_BC is an <a class="el" href="#special_xform_def">Axial rotation transform</a>. </dd>
<dd>
<span class="tt">sin_theta</span> and <span class="tt">cos_theta</span> are sine and cosine of the same angle. </dd></dl>

</div>
</div>
<a id="aaa0be3fe8c9ba4dffff8ade1c2070857" name="aaa0be3fe8c9ba4dffff8ade1c2070857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0be3fe8c9ba4dffff8ade1c2070857">&#9670;&#160;</a></span>UpdateAxialRotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;int axis&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UpdateAxialRotation </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>theta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>arX_BC</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Internal use only) Given a new rotation angle θ, updates the axial rotation transform arX_BC to represent the new rotation angle. </p>
<p>We expect that arX_BC was already such a transform (about the given x, y, or z axis). Only the 4 active elements are modified; the other 8 remain unchanged. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>the new rotation angle in radians. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">arX_BC</td><td>the axial rotation transform matrix to be updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">axis</td><td>0, 1, or 2 corresponding to +x, +y, or +z rotation axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>the overloaded signature if you already have sin(θ) and cos(θ). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>arX_BC is an <a class="el" href="#special_xform_def">Axial rotation transform</a>. </dd></dl>

</div>
</div>
<a id="a8c756da482eb99973ba0754ad3d53ea6" name="a8c756da482eb99973ba0754ad3d53ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c756da482eb99973ba0754ad3d53ea6">&#9670;&#160;</a></span>UpdateAxialTranslation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;int axis&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UpdateAxialTranslation </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>distance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; *</td>          <td class="paramname"><span class="paramname"><em>atX_BC</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Internal use only) Given a new <span class="tt">distance</span>, updates the axial translation transform atX_BC to represent the new translation by that amount. </p>
<p>We expect that atX_BC was already such a transform (about the given x, y, or z axis). Only the 1 active element is modified; the other 11 remain unchanged. No floating point operations are needed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>the component of p_BC along the <span class="tt">axis</span> direction. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">atX_BC</td><td>the axial translation transform matrix to be updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">axis</td><td>0, 1, or 2 corresponding to +x, +y, or +z translation axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>atX_BC is an <a class="el" href="#special_xform_def">Axial translation transform</a>. </dd></dl>

</div>
</div>
<a name="doc-related-members" id="doc-related-members"></a><h2 id="header-doc-related-members" class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="acd2efdeddc4b64780058383e5c96c1a1" name="acd2efdeddc4b64780058383e5c96c1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2efdeddc4b64780058383e5c96c1a1">&#9670;&#160;</a></span>hash_append</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class HashAlgorithm&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hash_append </td>
          <td>(</td>
          <td class="paramtype">HashAlgorithm &amp;</td>          <td class="paramname"><span class="paramname"><em>hasher</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the <a class="el" href="group__hash__append.html">hash_append generic hashing</a> concept. </p>
<dl class="section pre"><dt>Precondition</dt><dd>T implements the hash_append concept. </dd></dl>

</div>
</div>
<a id="aad69746f802afc1ffbbebecb31445648" name="aad69746f802afc1ffbbebecb31445648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad69746f802afc1ffbbebecb31445648">&#9670;&#160;</a></span>operator*</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Translation&lt; T, 3 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_AAq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X_AqB</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the translation-only transform <span class="tt">X_AAq</span> by the RigidTransform <span class="tt">X_AqB</span> and returns the RigidTransform <span class="tt">X_AB = X_AAq * X_AqB</span>. </p>
<dl class="section note"><dt>Note</dt><dd>The rotation matrix in the returned RigidTransform <span class="tt">X_AB</span> is equal to the rotation matrix in <span class="tt">X_AqB</span>. <span class="tt">X_AB</span> and <span class="tt">X_AqB</span> only differ by origin location. </dd></dl>

</div>
</div>
<a id="a25d3e276d5e4e1fad974214851ce0b46" name="a25d3e276d5e4e1fad974214851ce0b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d3e276d5e4e1fad974214851ce0b46">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>X</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel related">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream insertion operator to write an instance of <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways.">RigidTransform</a> into a <span class="tt">std::ostream</span>. </p>
<p>Especially useful for debugging. (Deprecated.) </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000024">Deprecated</a></b></dt><dd>Use fmt functions instead (e.g., fmt::format(), fmt::to_string(),  fmt::print()). Refer to GitHub issue #17742 for more information. <br  />
 This will be removed from Drake on or after 2026-06-01. </dd></dl>

</div>
</div>
<a id="a8bedd8c483aaf5bc48587d10d7a3d485" name="a8bedd8c483aaf5bc48587d10d7a3d485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bedd8c483aaf5bc48587d10d7a3d485">&#9670;&#160;</a></span>RigidTransform</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class RigidTransform</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afdc48b2f77bba9b5873dc56ec1b7248d" name="afdc48b2f77bba9b5873dc56ec1b7248d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc48b2f77bba9b5873dc56ec1b7248d">&#9670;&#160;</a></span>RigidTransformd</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#afdc48b2f77bba9b5873dc56ec1b7248d">RigidTransformd</a> = <a class="el" href="#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>&lt;double&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel related">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Abbreviation (alias/typedef) for a <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways.">RigidTransform</a> double scalar type. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/math/<a class="el" href="rigid__transform_8h.html">rigid_transform.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1math.html">math</a></li><li class="navelem"><a href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="https://accessibility.mit.edu/" class="site-menu-item">Accessibility</a>
        </li>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
