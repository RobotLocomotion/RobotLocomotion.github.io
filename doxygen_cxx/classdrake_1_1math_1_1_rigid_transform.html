<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: RigidTransform&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
   <td>
    <div id="DDGSearch">
     <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
      <input type="text" name="q" placeholder="Search C++ API only…" />
      <input type="hidden" name="sites" value="drake.mit.edu/doxygen_cxx" />
     </form>
     <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
      <input type="text" name="q" placeholder="Search all of Drake…" />
      <input type="hidden" name="sites" value="drake.mit.edu" />
     </form>
    </div">
   </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1math_1_1_rigid_transform.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classdrake_1_1math_1_1_rigid_transform-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RigidTransform&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::math::RigidTransform&lt; T &gt;</h3>

<p>This class represents a proper rigid transform between two frames which can be regarded in two ways. </p>
<p>A rigid transform describes the "pose" between two frames A and B (i.e., the relative orientation and position of A to B). Alternately, it can be regarded as a distance-preserving operator that can rotate and/or translate a rigid body without changing its shape or size (rigid) and without mirroring/reflecting the body (proper), e.g., it can add one position vector to another and express the result in a particular basis as <code>p_AoQ_A = X_AB * p_BoQ_B</code> (Q is any point). In many ways, this rigid transform class is conceptually similar to using a homogeneous matrix as a linear operator. See operator* documentation for an exception.</p>
<p>The class stores a <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> that relates right-handed orthogonal unit vectors Ax, Ay, Az fixed in frame A to right-handed orthogonal unit vectors Bx, By, Bz fixed in frame B. The class also stores a position vector from Ao (the origin of frame A) to Bo (the origin of frame B). The position vector is expressed in frame A. The monogram notation for the transform relating frame A to B is <code>X_AB</code>. The monogram notation for the rotation matrix relating A to B is <code>R_AB</code>. The monogram notation for the position vector from Ao to Bo is <code>p_AoBo_A</code>. See <a class="el" href="group__multibody__quantities.html">Multibody Quantities</a> for monogram notation for dynamics.</p>
<dl class="section note"><dt>Note</dt><dd>This class does not store the frames associated with the transform and cannot enforce correct usage of this class. For example, it makes sense to multiply RigidTransforms as <code>X_AB * X_BC</code>, but not <code>X_AB * X_CB</code>.</dd>
<dd>
This class is not a 4x4 transformation matrix &ndash; even though its <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#af5ba8ece1175e9cb229649a048096e79" title="Multiplies this RigidTransform X_AB by the other RigidTransform X_BC and returns the RigidTransform X...">operator*()</a> methods act mostly like 4x4 matrix multiplication. Instead, this class contains a 3x3 rotation matrix class and a 3x1 position vector. To convert this to a 3x4 matrix, use <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a89d3b170a7e3621ad02fe72ee7218a10" title="Returns the 3x4 matrix associated with this RigidTransform, i.e., X_AB.">GetAsMatrix34()</a>. To convert this to a 4x4 matrix, use <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a605ec47e36e257f4661d7c86a7f2ac8c" title="Returns the 4x4 matrix associated with this RigidTransform, i.e., X_AB.">GetAsMatrix4()</a>. To convert this to an Eigen::Isometry, use GetAsIsometry().</dd>
<dd>
An isometry is sometimes regarded as synonymous with rigid transform. The RigidTransform class has important advantages over Eigen::Isometry.<ul>
<li>RigidTransform is built on an underlying rigorous 3x3 <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> class that has significant functionality for 3D orientation.</li>
<li>In Debug builds, RigidTransform requires a valid 3x3 rotation matrix and a valid (non-NAN) position vector. Eigen::Isometry does not.</li>
<li>RigidTransform catches bugs that are undetected by Eigen::Isometry.</li>
<li>RigidTransform has additional functionality and ease-of-use, resulting in shorter, easier to write, and easier to read code.</li>
<li>The name Isometry is unfamiliar to many roboticists and dynamicists and for them Isometry.linear() is (for example) a counter-intuitive method name to return a rotation matrix.</li>
</ul>
</dd>
<dd>
One of the constructors in this class provides an implicit conversion from an Eigen Translation to RigidTransform.</dd></dl>
<dl class="section author"><dt>Authors</dt><dd>Paul Mitiguy (2018) Original author. </dd>
<dd>
Drake team (see <a href="https://drake.mit.edu/credits">https://drake.mit.edu/credits</a>).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/math/rigid_transform.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaa71b78707a3d79cbcb1a8f3cc854bee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#aaa71b78707a3d79cbcb1a8f3cc854bee">RigidTransform</a> ()</td></tr>
<tr class="memdesc:aaa71b78707a3d79cbcb1a8f3cc854bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the RigidTransform that corresponds to aligning the two frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is coincident with Bo.  <a href="#aaa71b78707a3d79cbcb1a8f3cc854bee">More...</a><br /></td></tr>
<tr class="separator:aaa71b78707a3d79cbcb1a8f3cc854bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079ca01bad5c04328237cfc47c73f7c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a079ca01bad5c04328237cfc47c73f7c6">RigidTransform</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;R, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a079ca01bad5c04328237cfc47c73f7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform from a rotation matrix and a position vector.  <a href="#a079ca01bad5c04328237cfc47c73f7c6">More...</a><br /></td></tr>
<tr class="separator:a079ca01bad5c04328237cfc47c73f7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadac43ad1559a232d321b36e501605fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#aadac43ad1559a232d321b36e501605fe">RigidTransform</a> (const <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html">RollPitchYaw</a>&lt; T &gt; &amp;rpy, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:aadac43ad1559a232d321b36e501605fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform from a <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html" title="This class represents the orientation between two arbitrary frames A and D associated with a Space-fi...">RollPitchYaw</a> and a position vector.  <a href="#aadac43ad1559a232d321b36e501605fe">More...</a><br /></td></tr>
<tr class="separator:aadac43ad1559a232d321b36e501605fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391249f5a5f48f189c7ff6572d6e3a19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a391249f5a5f48f189c7ff6572d6e3a19">RigidTransform</a> (const Eigen::Quaternion&lt; T &gt; &amp;quaternion, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a391249f5a5f48f189c7ff6572d6e3a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform from a Quaternion and a position vector.  <a href="#a391249f5a5f48f189c7ff6572d6e3a19">More...</a><br /></td></tr>
<tr class="separator:a391249f5a5f48f189c7ff6572d6e3a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0780a9ce724867fa65c009f0fbf82dc5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a0780a9ce724867fa65c009f0fbf82dc5">RigidTransform</a> (const Eigen::AngleAxis&lt; T &gt; &amp;theta_lambda, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a0780a9ce724867fa65c009f0fbf82dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform from an AngleAxis and a position vector.  <a href="#a0780a9ce724867fa65c009f0fbf82dc5">More...</a><br /></td></tr>
<tr class="separator:a0780a9ce724867fa65c009f0fbf82dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d99e85efd9f05d378ea0ecb922fcfa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#ab8d99e85efd9f05d378ea0ecb922fcfa">RigidTransform</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;R)</td></tr>
<tr class="memdesc:ab8d99e85efd9f05d378ea0ecb922fcfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform with a given <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and a zero position vector.  <a href="#ab8d99e85efd9f05d378ea0ecb922fcfa">More...</a><br /></td></tr>
<tr class="separator:ab8d99e85efd9f05d378ea0ecb922fcfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbab39c825ec784b6162682de5e4cdf1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#afbab39c825ec784b6162682de5e4cdf1">RigidTransform</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:afbab39c825ec784b6162682de5e4cdf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform that contains an identity <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and a given position vector <code>p</code>.  <a href="#afbab39c825ec784b6162682de5e4cdf1">More...</a><br /></td></tr>
<tr class="separator:afbab39c825ec784b6162682de5e4cdf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae328b72ac0f21f3bcdd7abe9cc19144"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#aae328b72ac0f21f3bcdd7abe9cc19144">RigidTransform</a> (const Eigen::Translation&lt; T, 3 &gt; &amp;<a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a3ee702d4bdc143681fe2b84270e609f2">translation</a>)</td></tr>
<tr class="memdesc:aae328b72ac0f21f3bcdd7abe9cc19144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform that contains an identity <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and the position vector underlying the given <code>translation</code>.  <a href="#aae328b72ac0f21f3bcdd7abe9cc19144">More...</a><br /></td></tr>
<tr class="separator:aae328b72ac0f21f3bcdd7abe9cc19144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36e94d338e3be24e9fde24f1d58a4fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#aa36e94d338e3be24e9fde24f1d58a4fb">RigidTransform</a> (const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;pose)</td></tr>
<tr class="memdesc:aa36e94d338e3be24e9fde24f1d58a4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform from an Eigen Isometry3.  <a href="#aa36e94d338e3be24e9fde24f1d58a4fb">More...</a><br /></td></tr>
<tr class="separator:aa36e94d338e3be24e9fde24f1d58a4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b71809f27af855296a40b46d8f0a83"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#ab8b71809f27af855296a40b46d8f0a83">RigidTransform</a> (const Eigen::Matrix&lt; T, 3, 4 &gt; pose)</td></tr>
<tr class="memdesc:ab8b71809f27af855296a40b46d8f0a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform from a 3x4 matrix whose structure is below.  <a href="#ab8b71809f27af855296a40b46d8f0a83">More...</a><br /></td></tr>
<tr class="separator:ab8b71809f27af855296a40b46d8f0a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2232216392f2045d6907a99fa0b423"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a5d2232216392f2045d6907a99fa0b423">RigidTransform</a> (const <a class="el" href="namespacedrake.html#ae74155a11dfcdaad0adc0349f0956148">Matrix4</a>&lt; T &gt; &amp;pose)</td></tr>
<tr class="memdesc:a5d2232216392f2045d6907a99fa0b423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform from a 4x4 matrix whose structure is below.  <a href="#a5d2232216392f2045d6907a99fa0b423">More...</a><br /></td></tr>
<tr class="separator:a5d2232216392f2045d6907a99fa0b423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b8a89a54006ff4502298b5907f7e28"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ac7b8a89a54006ff4502298b5907f7e28"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#ac7b8a89a54006ff4502298b5907f7e28">RigidTransform</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;pose)</td></tr>
<tr class="memdesc:ac7b8a89a54006ff4502298b5907f7e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a RigidTransform from an appropriate Eigen <b>expression</b>.  <a href="#ac7b8a89a54006ff4502298b5907f7e28">More...</a><br /></td></tr>
<tr class="separator:ac7b8a89a54006ff4502298b5907f7e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31756c2694bacdfdf6b0c75602d498b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#ae31756c2694bacdfdf6b0c75602d498b">set</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;R, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:ae31756c2694bacdfdf6b0c75602d498b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>this</code> RigidTransform from a <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and a position vector.  <a href="#ae31756c2694bacdfdf6b0c75602d498b">More...</a><br /></td></tr>
<tr class="separator:ae31756c2694bacdfdf6b0c75602d498b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e77b1e5fde8184fd5d18a62d00297bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a6e77b1e5fde8184fd5d18a62d00297bf">SetFromIsometry3</a> (const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;pose)</td></tr>
<tr class="memdesc:a6e77b1e5fde8184fd5d18a62d00297bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>this</code> RigidTransform from an Eigen Isometry3.  <a href="#a6e77b1e5fde8184fd5d18a62d00297bf">More...</a><br /></td></tr>
<tr class="separator:a6e77b1e5fde8184fd5d18a62d00297bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc2d96e26802c52ea92f21a40540681"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a1bc2d96e26802c52ea92f21a40540681"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a1bc2d96e26802c52ea92f21a40540681">cast</a> () const</td></tr>
<tr class="memdesc:a1bc2d96e26802c52ea92f21a40540681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a RigidTransform templatized on a scalar type U from a RigidTransform templatized on scalar type T.  <a href="#a1bc2d96e26802c52ea92f21a40540681">More...</a><br /></td></tr>
<tr class="separator:a1bc2d96e26802c52ea92f21a40540681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb70b2d5e20b8e9a4ffe2e21c7bf8fd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#acbb70b2d5e20b8e9a4ffe2e21c7bf8fd">rotation</a> () const</td></tr>
<tr class="memdesc:acbb70b2d5e20b8e9a4ffe2e21c7bf8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns R_AB, the rotation matrix portion of <code>this</code> RigidTransform.  <a href="#acbb70b2d5e20b8e9a4ffe2e21c7bf8fd">More...</a><br /></td></tr>
<tr class="separator:acbb70b2d5e20b8e9a4ffe2e21c7bf8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e953a8287f40248d4d2c1030ef72cef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a3e953a8287f40248d4d2c1030ef72cef">set_rotation</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;R)</td></tr>
<tr class="memdesc:a3e953a8287f40248d4d2c1030ef72cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the RotationMatrix portion of <code>this</code> RigidTransform.  <a href="#a3e953a8287f40248d4d2c1030ef72cef">More...</a><br /></td></tr>
<tr class="separator:a3e953a8287f40248d4d2c1030ef72cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c9f6da94bb9af6ec8426b32bbb5da3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#ab3c9f6da94bb9af6ec8426b32bbb5da3">set_rotation</a> (const <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html">RollPitchYaw</a>&lt; T &gt; &amp;rpy)</td></tr>
<tr class="memdesc:ab3c9f6da94bb9af6ec8426b32bbb5da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the rotation part of <code>this</code> RigidTransform from a <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html" title="This class represents the orientation between two arbitrary frames A and D associated with a Space-fi...">RollPitchYaw</a>.  <a href="#ab3c9f6da94bb9af6ec8426b32bbb5da3">More...</a><br /></td></tr>
<tr class="separator:ab3c9f6da94bb9af6ec8426b32bbb5da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5d6e6cb699351acd9c562fa2cfe139"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a9e5d6e6cb699351acd9c562fa2cfe139">set_rotation</a> (const Eigen::Quaternion&lt; T &gt; &amp;quaternion)</td></tr>
<tr class="memdesc:a9e5d6e6cb699351acd9c562fa2cfe139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the rotation part of <code>this</code> RigidTransform from a Quaternion.  <a href="#a9e5d6e6cb699351acd9c562fa2cfe139">More...</a><br /></td></tr>
<tr class="separator:a9e5d6e6cb699351acd9c562fa2cfe139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c8cdccdeb018584d05a3d7557bf42c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a08c8cdccdeb018584d05a3d7557bf42c">set_rotation</a> (const Eigen::AngleAxis&lt; T &gt; &amp;theta_lambda)</td></tr>
<tr class="memdesc:a08c8cdccdeb018584d05a3d7557bf42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the rotation part of <code>this</code> RigidTransform from an AngleAxis.  <a href="#a08c8cdccdeb018584d05a3d7557bf42c">More...</a><br /></td></tr>
<tr class="separator:a08c8cdccdeb018584d05a3d7557bf42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee702d4bdc143681fe2b84270e609f2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a3ee702d4bdc143681fe2b84270e609f2">translation</a> () const</td></tr>
<tr class="memdesc:a3ee702d4bdc143681fe2b84270e609f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>p_AoBo_A</code>, the position vector portion of <code>this</code> RigidTransform, i.e., position vector from Ao (frame A's origin) to Bo (frame B's origin).  <a href="#a3ee702d4bdc143681fe2b84270e609f2">More...</a><br /></td></tr>
<tr class="separator:a3ee702d4bdc143681fe2b84270e609f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe4dc36c56c493ac1e956ec185bdfea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a1fe4dc36c56c493ac1e956ec185bdfea">set_translation</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a1fe4dc36c56c493ac1e956ec185bdfea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the position vector portion of <code>this</code> RigidTransform.  <a href="#a1fe4dc36c56c493ac1e956ec185bdfea">More...</a><br /></td></tr>
<tr class="separator:a1fe4dc36c56c493ac1e956ec185bdfea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605ec47e36e257f4661d7c86a7f2ac8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#ae74155a11dfcdaad0adc0349f0956148">Matrix4</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a605ec47e36e257f4661d7c86a7f2ac8c">GetAsMatrix4</a> () const</td></tr>
<tr class="memdesc:a605ec47e36e257f4661d7c86a7f2ac8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 4x4 matrix associated with this RigidTransform, i.e., X_AB.  <a href="#a605ec47e36e257f4661d7c86a7f2ac8c">More...</a><br /></td></tr>
<tr class="separator:a605ec47e36e257f4661d7c86a7f2ac8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d3b170a7e3621ad02fe72ee7218a10"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, 3, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a89d3b170a7e3621ad02fe72ee7218a10">GetAsMatrix34</a> () const</td></tr>
<tr class="memdesc:a89d3b170a7e3621ad02fe72ee7218a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 3x4 matrix associated with this RigidTransform, i.e., X_AB.  <a href="#a89d3b170a7e3621ad02fe72ee7218a10">More...</a><br /></td></tr>
<tr class="separator:a89d3b170a7e3621ad02fe72ee7218a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58717dcdc71536116684f6dc53bab9b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a58717dcdc71536116684f6dc53bab9b9">GetAsIsometry3</a> () const</td></tr>
<tr class="memdesc:a58717dcdc71536116684f6dc53bab9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the isometry in ℜ³ that is equivalent to a RigidTransform.  <a href="#a58717dcdc71536116684f6dc53bab9b9">More...</a><br /></td></tr>
<tr class="separator:a58717dcdc71536116684f6dc53bab9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd964513cdca714478e29210f7e9cf31"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#abd964513cdca714478e29210f7e9cf31">SetIdentity</a> ()</td></tr>
<tr class="memdesc:abd964513cdca714478e29210f7e9cf31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>this</code> RigidTransform so it corresponds to aligning the two frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is coincident with Bo.  <a href="#abd964513cdca714478e29210f7e9cf31">More...</a><br /></td></tr>
<tr class="separator:abd964513cdca714478e29210f7e9cf31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac804feef1db1925cdb41771475381a17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#ac804feef1db1925cdb41771475381a17">IsExactlyIdentity</a> () const</td></tr>
<tr class="memdesc:ac804feef1db1925cdb41771475381a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <code>this</code> is exactly the identity RigidTransform.  <a href="#ac804feef1db1925cdb41771475381a17">More...</a><br /></td></tr>
<tr class="separator:ac804feef1db1925cdb41771475381a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e39a200466c08cbbe985741fb3b9964"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a3e39a200466c08cbbe985741fb3b9964">IsNearlyIdentity</a> (double translation_tolerance) const</td></tr>
<tr class="memdesc:a3e39a200466c08cbbe985741fb3b9964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>this</code> is within tolerance of the identity <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways.">RigidTransform</a>.  <a href="#a3e39a200466c08cbbe985741fb3b9964">More...</a><br /></td></tr>
<tr class="separator:a3e39a200466c08cbbe985741fb3b9964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c29dcfbeeb594af24ae82cff87f35f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#ae4c29dcfbeeb594af24ae82cff87f35f">IsIdentityToEpsilon</a> (double translation_tolerance) const</td></tr>
<tr class="memdesc:ae4c29dcfbeeb594af24ae82cff87f35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <a href="#ae4c29dcfbeeb594af24ae82cff87f35f">More...</a><br /></td></tr>
<tr class="separator:ae4c29dcfbeeb594af24ae82cff87f35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adbc50055d9a59126602077013cf04e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a5adbc50055d9a59126602077013cf04e">inverse</a> () const</td></tr>
<tr class="memdesc:a5adbc50055d9a59126602077013cf04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns X_BA = X_AB⁻¹, the inverse of <code>this</code> RigidTransform.  <a href="#a5adbc50055d9a59126602077013cf04e">More...</a><br /></td></tr>
<tr class="separator:a5adbc50055d9a59126602077013cf04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40da2f0f20579d4730f4ba7968fe4a53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a40da2f0f20579d4730f4ba7968fe4a53">operator *=</a> (const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a40da2f0f20579d4730f4ba7968fe4a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place multiply of <code>this</code> RigidTransform <code>X_AB</code> by <code>other</code> RigidTransform <code>X_BC</code>.  <a href="#a40da2f0f20579d4730f4ba7968fe4a53">More...</a><br /></td></tr>
<tr class="separator:a40da2f0f20579d4730f4ba7968fe4a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ba8ece1175e9cb229649a048096e79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#af5ba8ece1175e9cb229649a048096e79">operator *</a> (const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:af5ba8ece1175e9cb229649a048096e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <code>this</code> RigidTransform <code>X_AB</code> by the <code>other</code> RigidTransform <code>X_BC</code> and returns the RigidTransform <code>X_AC = X_AB * X_BC</code>.  <a href="#af5ba8ece1175e9cb229649a048096e79">More...</a><br /></td></tr>
<tr class="separator:af5ba8ece1175e9cb229649a048096e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a1dbbf28ce938bb2ff6e2672f61ead"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a99a1dbbf28ce938bb2ff6e2672f61ead">InvertAndCompose</a> (const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:a99a1dbbf28ce938bb2ff6e2672f61ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the product of <code>this</code> inverted and another RigidTransform.  <a href="#a99a1dbbf28ce938bb2ff6e2672f61ead">More...</a><br /></td></tr>
<tr class="separator:a99a1dbbf28ce938bb2ff6e2672f61ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7408076cfba12eda75c0c354d70c6a96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a7408076cfba12eda75c0c354d70c6a96">operator *</a> (const Eigen::Translation&lt; T, 3 &gt; &amp;X_BBq) const</td></tr>
<tr class="memdesc:a7408076cfba12eda75c0c354d70c6a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <code>this</code> RigidTransform <code>X_AB</code> by the translation-only transform <code>X_BBq</code> and returns the RigidTransform <code>X_ABq = X_AB * X_BBq</code>.  <a href="#a7408076cfba12eda75c0c354d70c6a96">More...</a><br /></td></tr>
<tr class="separator:a7408076cfba12eda75c0c354d70c6a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9832cec727611df141fdd479838b3c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#aa9832cec727611df141fdd479838b3c7">operator *</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_BoQ_B) const</td></tr>
<tr class="memdesc:aa9832cec727611df141fdd479838b3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <code>this</code> RigidTransform <code>X_AB</code> by the position vector <code>p_BoQ_B</code> which is from Bo (B's origin) to an arbitrary point Q.  <a href="#aa9832cec727611df141fdd479838b3c7">More...</a><br /></td></tr>
<tr class="separator:aa9832cec727611df141fdd479838b3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22020b0567a392bfc275031a868657f"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:af22020b0567a392bfc275031a868657f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; typename Derived::Scalar, 3, Derived::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#af22020b0567a392bfc275031a868657f">operator *</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;p_BoQ_B) const</td></tr>
<tr class="memdesc:af22020b0567a392bfc275031a868657f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies <code>this</code> RigidTransform <code>X_AB</code> by the n position vectors <code>p_BoQ1_B</code> ...  <a href="#af22020b0567a392bfc275031a868657f">More...</a><br /></td></tr>
<tr class="separator:af22020b0567a392bfc275031a868657f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5015553d30ad4312a6b0cbb56c4d1d4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a5015553d30ad4312a6b0cbb56c4d1d4c">IsNearlyEqualTo</a> (const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;other, double tolerance) const</td></tr>
<tr class="memdesc:a5015553d30ad4312a6b0cbb56c4d1d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares each element of <code>this</code> to the corresponding element of <code>other</code> to check if they are the same to within a specified <code>tolerance</code>.  <a href="#a5015553d30ad4312a6b0cbb56c4d1d4c">More...</a><br /></td></tr>
<tr class="separator:a5015553d30ad4312a6b0cbb56c4d1d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff306c43d124f530d5dfbf6793a3741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a2ff306c43d124f530d5dfbf6793a3741">IsExactlyEqualTo</a> (const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:a2ff306c43d124f530d5dfbf6793a3741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>this</code> is exactly equal to <code>other</code>.  <a href="#a2ff306c43d124f530d5dfbf6793a3741">More...</a><br /></td></tr>
<tr class="separator:a2ff306c43d124f530d5dfbf6793a3741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d583e730b5dd2193c7ff9f1293fcde"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#aa6d583e730b5dd2193c7ff9f1293fcde">GetMaximumAbsoluteDifference</a> (const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:aa6d583e730b5dd2193c7ff9f1293fcde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the infinity norm of <code>this</code> - <code>other</code> (i.e., the maximum absolute value of the difference between the elements of <code>this</code> and <code>other</code>).  <a href="#aa6d583e730b5dd2193c7ff9f1293fcde">More...</a><br /></td></tr>
<tr class="separator:aa6d583e730b5dd2193c7ff9f1293fcde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b1205e300a07901a70079bbbd1e566"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#aa8b1205e300a07901a70079bbbd1e566">GetMaximumAbsoluteTranslationDifference</a> (const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:aa8b1205e300a07901a70079bbbd1e566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum absolute value of the difference in the position vectors (translation) in <code>this</code> and <code>other</code>.  <a href="#aa8b1205e300a07901a70079bbbd1e566">More...</a><br /></td></tr>
<tr class="separator:aa8b1205e300a07901a70079bbbd1e566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:aaac6934d2979499ff35457a8583ce60a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#aaac6934d2979499ff35457a8583ce60a">RigidTransform</a> (const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> &amp;)=default</td></tr>
<tr class="separator:aaac6934d2979499ff35457a8583ce60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814b6772b29ffd1c2bbc34befae3667d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a814b6772b29ffd1c2bbc34befae3667d">operator=</a> (const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> &amp;)=default</td></tr>
<tr class="separator:a814b6772b29ffd1c2bbc34befae3667d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1d92575e2e4beb3bfa036983c33923"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#ada1d92575e2e4beb3bfa036983c33923">RigidTransform</a> (<a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ada1d92575e2e4beb3bfa036983c33923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257f755b0f58f8958f8827b0651e205c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a257f755b0f58f8958f8827b0651e205c">operator=</a> (<a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a257f755b0f58f8958f8827b0651e205c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9af123d3a901431db4b446e542b55b98"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a9af123d3a901431db4b446e542b55b98">Identity</a> ()</td></tr>
<tr class="memdesc:a9af123d3a901431db4b446e542b55b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the identity RigidTransform (corresponds to coincident frames).  <a href="#a9af123d3a901431db4b446e542b55b98">More...</a><br /></td></tr>
<tr class="separator:a9af123d3a901431db4b446e542b55b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8bedd8c483aaf5bc48587d10d7a3d485"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a8bedd8c483aaf5bc48587d10d7a3d485"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a></td></tr>
<tr class="separator:a8bedd8c483aaf5bc48587d10d7a3d485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a6bee63e97e5697d2f4dac49cde380"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a10a6bee63e97e5697d2f4dac49cde380">operator *</a> (const Eigen::Translation&lt; T, 3 &gt; &amp;X_AAq, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;X_AqB)</td></tr>
<tr class="memdesc:a10a6bee63e97e5697d2f4dac49cde380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the translation-only transform <code>X_AAq</code> by the RigidTransform <code>X_AqB</code> and returns the RigidTransform <code>X_AB = X_AAq * X_AqB</code>.  <a href="#a10a6bee63e97e5697d2f4dac49cde380">More...</a><br /></td></tr>
<tr class="separator:a10a6bee63e97e5697d2f4dac49cde380"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:afdc48b2f77bba9b5873dc56ec1b7248d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#afdc48b2f77bba9b5873dc56ec1b7248d">RigidTransformd</a> = <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; double &gt;</td></tr>
<tr class="memdesc:afdc48b2f77bba9b5873dc56ec1b7248d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation (alias/typedef) for a <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways.">RigidTransform</a> double scalar type.  <a href="#afdc48b2f77bba9b5873dc56ec1b7248d">More...</a><br /></td></tr>
<tr class="separator:afdc48b2f77bba9b5873dc56ec1b7248d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d3e276d5e4e1fad974214851ce0b46"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a25d3e276d5e4e1fad974214851ce0b46"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a25d3e276d5e4e1fad974214851ce0b46">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;X)</td></tr>
<tr class="memdesc:a25d3e276d5e4e1fad974214851ce0b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream insertion operator to write an instance of <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways.">RigidTransform</a> into a <code>std::ostream</code>.  <a href="#a25d3e276d5e4e1fad974214851ce0b46">More...</a><br /></td></tr>
<tr class="separator:a25d3e276d5e4e1fad974214851ce0b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaac6934d2979499ff35457a8583ce60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac6934d2979499ff35457a8583ce60a">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ada1d92575e2e4beb3bfa036983c33923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1d92575e2e4beb3bfa036983c33923">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa71b78707a3d79cbcb1a8f3cc854bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa71b78707a3d79cbcb1a8f3cc854bee">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the RigidTransform that corresponds to aligning the two frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is coincident with Bo. </p>
<p>Hence, the constructed RigidTransform contains an identity <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and a zero position vector. </p>

</div>
</div>
<a id="a079ca01bad5c04328237cfc47c73f7c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079ca01bad5c04328237cfc47c73f7c6">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a RigidTransform from a rotation matrix and a position vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>rotation matrix relating frames A and B (e.g., <code>R_AB</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>position vector from frame A's origin to frame B's origin, expressed in frame A. In monogram notation p is denoted <code>p_AoBo_A</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadac43ad1559a232d321b36e501605fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadac43ad1559a232d321b36e501605fe">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html">RollPitchYaw</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rpy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a RigidTransform from a <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html" title="This class represents the orientation between two arbitrary frames A and D associated with a Space-fi...">RollPitchYaw</a> and a position vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rpy</td><td>a RollPitchYaw which is a Space-fixed (extrinsic) X-Y-Z rotation with "roll-pitch-yaw" angles <code>[r, p, y]</code> or equivalently a Body- fixed (intrinsic) Z-Y-X rotation with "yaw-pitch-roll" angles <code>[y, p, r]</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a05183386f55111df27e380877a9f11b2" title="Constructs a RotationMatrix from an RollPitchYaw.">RotationMatrix::RotationMatrix(const RollPitchYaw&lt;T&gt;&amp;)</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>position vector from frame A's origin to frame B's origin, expressed in frame A. In monogram notation p is denoted <code>p_AoBo_A</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a391249f5a5f48f189c7ff6572d6e3a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391249f5a5f48f189c7ff6572d6e3a19">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quaternion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a RigidTransform from a Quaternion and a position vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">quaternion</td><td>a non-zero, finite quaternion which may or may not have unit length [i.e., <code>quaternion.norm()</code> does not have to be 1]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>position vector from frame A's origin to frame B's origin, expressed in frame A. In monogram notation p is denoted <code>p_AoBo_A</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>in debug builds if the rotation matrix that is built from <code>quaternion</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a7f6eb5993bd83412f92e82aa49873ae6" title="Constructs a RotationMatrix from an Eigen::Quaternion.">RotationMatrix::RotationMatrix(const Eigen::Quaternion&lt;T&gt;&amp;)</a> </dd></dl>

</div>
</div>
<a id="a0780a9ce724867fa65c009f0fbf82dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0780a9ce724867fa65c009f0fbf82dc5">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const Eigen::AngleAxis&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta_lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a RigidTransform from an AngleAxis and a position vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta_lambda</td><td>an Eigen::AngleAxis whose associated axis (vector direction herein called <code>lambda</code>) is non-zero and finite, but which may or may not have unit length [i.e., <code>lambda.norm()</code> does not have to be 1]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>position vector from frame A's origin to frame B's origin, expressed in frame A. In monogram notation p is denoted `p_AoBo_A </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>in debug builds if the rotation matrix that is built from <code>theta_lambda</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#aeb8205e6418bc644739b23879344135b" title="Constructs a RotationMatrix from an Eigen::AngleAxis.">RotationMatrix::RotationMatrix(const Eigen::AngleAxis&lt;T&gt;&amp;)</a> </dd></dl>

</div>
</div>
<a id="ab8d99e85efd9f05d378ea0ecb922fcfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d99e85efd9f05d378ea0ecb922fcfa">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a RigidTransform with a given <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and a zero position vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>rotation matrix relating frames A and B (e.g., <code>R_AB</code>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbab39c825ec784b6162682de5e4cdf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbab39c825ec784b6162682de5e4cdf1">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a RigidTransform that contains an identity <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and a given position vector <code>p</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>position vector from frame A's origin to frame B's origin, expressed in frame A. In monogram notation p is denoted <code>p_AoBo_A</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae328b72ac0f21f3bcdd7abe9cc19144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae328b72ac0f21f3bcdd7abe9cc19144">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Translation&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>translation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a RigidTransform that contains an identity <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and the position vector underlying the given <code>translation</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">translation</td><td>translation-only transform that stores p_AoQ_A, the position vector from frame A's origin to a point Q, expressed in frame A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The constructed RigidTransform <code>X_AAq</code> relates frame A to a frame Aq whose basis unit vectors are aligned with Ax, Ay, Az and whose origin position is located at point Q. </dd>
<dd>
This constructor provides an implicit conversion from Translation to RigidTransform. </dd></dl>

</div>
</div>
<a id="aa36e94d338e3be24e9fde24f1d58a4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa36e94d338e3be24e9fde24f1d58a4fb">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a RigidTransform from an Eigen Isometry3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pose</td><td>Isometry3 that contains an allegedly valid rotation matrix <code>R_AB</code> and also contains a position vector <code>p_AoBo_A</code> from frame A's origin to frame B's origin. <code>p_AoBo_A</code> must be expressed in frame A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>in debug builds if R_AB is not a proper orthonormal 3x3 rotation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>No attempt is made to orthogonalize the 3x3 rotation matrix part of <code>pose</code>. As needed, use <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a7d51dc7c0ba0f0cf4747d47e9203255f" title="Given an approximate rotation matrix M, finds the RotationMatrix R closest to M.">RotationMatrix::ProjectToRotationMatrix()</a>. </dd></dl>

</div>
</div>
<a id="ab8b71809f27af855296a40b46d8f0a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b71809f27af855296a40b46d8f0a83">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 4 &gt;&#160;</td>
          <td class="paramname"><em>pose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a RigidTransform from a 3x4 matrix whose structure is below. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pose</td><td>3x4 matrix that contains an allegedly valid 3x3 rotation matrix <code>R_AB</code> and also a 3x1 position vector <code>p_AoBo_A</code> (the position vector from frame A's origin to frame B's origin, expressed in frame A). <pre>
 ┌                ┐
 │ R_AB  p_AoBo_A │
 └                ┘
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>in debug builds if the <code>R_AB</code> part of <code>pose</code> is not a proper orthonormal 3x3 rotation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>No attempt is made to orthogonalize the 3x3 rotation matrix part of <code>pose</code>. As needed, use <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a7d51dc7c0ba0f0cf4747d47e9203255f" title="Given an approximate rotation matrix M, finds the RotationMatrix R closest to M.">RotationMatrix::ProjectToRotationMatrix()</a>. </dd></dl>

</div>
</div>
<a id="a5d2232216392f2045d6907a99fa0b423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2232216392f2045d6907a99fa0b423">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#ae74155a11dfcdaad0adc0349f0956148">Matrix4</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a RigidTransform from a 4x4 matrix whose structure is below. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pose</td><td>4x4 matrix that contains an allegedly valid 3x3 rotation matrix <code>R_AB</code> and also a 3x1 position vector <code>p_AoBo_A</code> (the position vector from frame A's origin to frame B's origin, expressed in frame A). <pre>
 ┌                ┐
 │ R_AB  p_AoBo_A │
 │                │
 │   0      1     │
 └                ┘
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>in debug builds if the <code>R_AB</code> part of <code>pose</code> is not a proper orthonormal 3x3 rotation matrix or if <code>pose</code> is a 4x4 matrix whose final row is not <code>[0, 0, 0, 1]</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>No attempt is made to orthogonalize the 3x3 rotation matrix part of <code>pose</code>. As needed, use <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a7d51dc7c0ba0f0cf4747d47e9203255f" title="Given an approximate rotation matrix M, finds the RotationMatrix R closest to M.">RotationMatrix::ProjectToRotationMatrix()</a>. </dd></dl>

</div>
</div>
<a id="ac7b8a89a54006ff4502298b5907f7e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b8a89a54006ff4502298b5907f7e28">&#9670;&nbsp;</a></span>RigidTransform() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>pose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a RigidTransform from an appropriate Eigen <b>expression</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pose</td><td>Generic Eigen matrix <b>expression</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the Eigen <b>expression</b> in pose does not resolve to a Vector3 or 3x4 matrix or 4x4 matrix or if the rotational part of <code>pose</code> is not a proper orthonormal 3x3 rotation matrix or if <code>pose</code> is a 4x4 matrix whose final row is not <code>[0, 0, 0, 1]</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>No attempt is made to orthogonalize the 3x3 rotation matrix part of <code>pose</code>. As needed, use <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a7d51dc7c0ba0f0cf4747d47e9203255f" title="Given an approximate rotation matrix M, finds the RotationMatrix R closest to M.">RotationMatrix::ProjectToRotationMatrix()</a>. </dd>
<dd>
This constructor prevents ambiguity that would otherwise exist for a RigidTransform constructor whose argument is an Eigen <b>expression</b>. <div class="fragment"><div class="line"><span class="keyword">const</span> Vector3&lt;double&gt; position(4, 5, 6);</div><div class="line"><span class="keyword">const</span> RigidTransform&lt;double&gt; X1(3 * position);</div><div class="line">----------------------------------------------</div><div class="line"><span class="keyword">const</span> RotationMatrix&lt;double&gt; R(RollPitchYaw&lt;double&gt;(1, 2, 3));</div><div class="line">Eigen::Matrix&lt;double, 3, 4&gt; pose34;</div><div class="line">pose34 &lt;&lt; R.matrix(), position;</div><div class="line"><span class="keyword">const</span> RigidTransform&lt;double&gt; X2(1.0 * pose34);</div><div class="line">----------------------------------------------</div><div class="line">Eigen::Matrix&lt;double, 4, 4&gt; pose4;</div><div class="line">pose4 &lt;&lt; R.matrix(), position,</div><div class="line">         0, 0, 0, 1;</div><div class="line"><span class="keyword">const</span> RigidTransform&lt;double&gt; X3(pose4 * pose4);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1bc2d96e26802c52ea92f21a40540681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc2d96e26802c52ea92f21a40540681">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt;U&gt; cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a RigidTransform templatized on a scalar type U from a RigidTransform templatized on scalar type T. </p>
<p>For example, </p><div class="fragment"><div class="line">RigidTransform&lt;double&gt; source = <a class="code" href="classdrake_1_1math_1_1_rigid_transform.html#a9af123d3a901431db4b446e542b55b98">RigidTransform&lt;double&gt;::Identity</a>();</div><div class="line">RigidTransform&lt;AutoDiffXd&gt; foo = source.cast&lt;<a class="code" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a>&gt;();</div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>Scalar type on which the returned RigidTransform is templated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways.">RigidTransform</a>&lt;From&gt;::cast&lt;To&gt;()</code> creates a new <code><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways.">RigidTransform</a>&lt;To&gt;</code> from a <code><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways.">RigidTransform</a>&lt;From&gt;</code> but only if type <code>To</code> is constructible from type <code>From</code>. This cast method works in accordance with Eigen's cast method for Eigen's objects that underlie this RigidTransform. For example, Eigen currently allows cast from type double to AutoDiffXd, but not vice-versa. </dd></dl>

</div>
</div>
<a id="a58717dcdc71536116684f6dc53bab9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58717dcdc71536116684f6dc53bab9b9">&#9670;&nbsp;</a></span>GetAsIsometry3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt;T&gt; GetAsIsometry3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the isometry in ℜ³ that is equivalent to a RigidTransform. </p>

</div>
</div>
<a id="a89d3b170a7e3621ad02fe72ee7218a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d3b170a7e3621ad02fe72ee7218a10">&#9670;&nbsp;</a></span>GetAsMatrix34()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, 3, 4&gt; GetAsMatrix34 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 3x4 matrix associated with this RigidTransform, i.e., X_AB. </p>
<pre>
 ┌                ┐
 │ R_AB  p_AoBo_A │
 └                ┘
</pre> 
</div>
</div>
<a id="a605ec47e36e257f4661d7c86a7f2ac8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605ec47e36e257f4661d7c86a7f2ac8c">&#9670;&nbsp;</a></span>GetAsMatrix4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#ae74155a11dfcdaad0adc0349f0956148">Matrix4</a>&lt;T&gt; GetAsMatrix4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 4x4 matrix associated with this RigidTransform, i.e., X_AB. </p>
<pre>
 ┌                ┐
 │ R_AB  p_AoBo_A │
 │                │
 │   0      1     │
 └                ┘
</pre> 
</div>
</div>
<a id="aa6d583e730b5dd2193c7ff9f1293fcde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d583e730b5dd2193c7ff9f1293fcde">&#9670;&nbsp;</a></span>GetMaximumAbsoluteDifference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T GetMaximumAbsoluteDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the infinity norm of <code>this</code> - <code>other</code> (i.e., the maximum absolute value of the difference between the elements of <code>this</code> and <code>other</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>RigidTransform to subtract from <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>‖<code>this</code> - <code>other</code>‖∞ </dd></dl>

</div>
</div>
<a id="aa8b1205e300a07901a70079bbbd1e566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b1205e300a07901a70079bbbd1e566">&#9670;&nbsp;</a></span>GetMaximumAbsoluteTranslationDifference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T GetMaximumAbsoluteTranslationDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum absolute value of the difference in the position vectors (translation) in <code>this</code> and <code>other</code>. </p>
<p>In other words, returns the infinity norm of the difference in the position vectors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>RigidTransform whose position vector is subtracted from the position vector in <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9af123d3a901431db4b446e542b55b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af123d3a901431db4b446e542b55b98">&#9670;&nbsp;</a></span>Identity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt;T&gt;&amp; Identity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the identity RigidTransform (corresponds to coincident frames). </p>
<dl class="section return"><dt>Returns</dt><dd>the RigidTransform that corresponds to aligning the two frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is coincident with Bo. Hence, the returned RigidTransform contains a 3x3 identity matrix and a zero position vector. </dd></dl>

</div>
</div>
<a id="a5adbc50055d9a59126602077013cf04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5adbc50055d9a59126602077013cf04e">&#9670;&nbsp;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt;T&gt; inverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns X_BA = X_AB⁻¹, the inverse of <code>this</code> RigidTransform. </p>
<dl class="section note"><dt>Note</dt><dd>The inverse of RigidTransform X_AB is X_BA, which contains the rotation matrix R_BA = R_AB⁻¹ = R_ABᵀ and the position vector <code>p_BoAo_B_</code> (position from B's origin Bo to A's origin Ao, expressed in frame B). </dd>
<dd>
: The square-root of a RigidTransform's condition number is roughly the magnitude of the position vector. The accuracy of the calculation for the inverse of a RigidTransform drops off with the sqrt condition number. </dd></dl>

</div>
</div>
<a id="a99a1dbbf28ce938bb2ff6e2672f61ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a1dbbf28ce938bb2ff6e2672f61ead">&#9670;&nbsp;</a></span>InvertAndCompose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt;T&gt; InvertAndCompose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the product of <code>this</code> inverted and another RigidTransform. </p>
<p>If you consider <code>this</code> to be the transform X_AB, and <code>other</code> to be X_AC, then this method returns X_BC = X_AB⁻¹ * X_AC. For T==double, this method can be <em>much</em> faster than inverting first and then performing the composition, because it can take advantage of the special structure of a rigid transform to avoid unnecessary memory and floating point operations. On some platforms it can use SIMD instructions for further speedups. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>RigidTransform that post-multiplies <code>this</code> inverted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">X_BC</td><td>where X_BC = this⁻¹ * other. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is possible (albeit improbable) to create an invalid rigid transform by accumulating round-off error with a large number of multiplies. </dd></dl>

</div>
</div>
<a id="a2ff306c43d124f530d5dfbf6793a3741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff306c43d124f530d5dfbf6793a3741">&#9670;&nbsp;</a></span>IsExactlyEqualTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsExactlyEqualTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>this</code> is exactly equal to <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>RigidTransform to compare to <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if each element of <code>this</code> is exactly equal to the corresponding element of <code>other</code>. </dd></dl>

</div>
</div>
<a id="ac804feef1db1925cdb41771475381a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac804feef1db1925cdb41771475381a17">&#9670;&nbsp;</a></span>IsExactlyIdentity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsExactlyIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <code>this</code> is exactly the identity RigidTransform. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a3e39a200466c08cbbe985741fb3b9964" title="Returns true if this is within tolerance of the identity RigidTransform.">IsNearlyIdentity()</a>. </dd></dl>

</div>
</div>
<a id="ae4c29dcfbeeb594af24ae82cff87f35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c29dcfbeeb594af24ae82cff87f35f">&#9670;&nbsp;</a></span>IsIdentityToEpsilon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsIdentityToEpsilon </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>translation_tolerance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Use RigidTransform::IsNearlyIdentity() <br />
 This will be removed from Drake on or after 2022-06-01.</dd></dl>

</div>
</div>
<a id="a5015553d30ad4312a6b0cbb56c4d1d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5015553d30ad4312a6b0cbb56c4d1d4c">&#9670;&nbsp;</a></span>IsNearlyEqualTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsNearlyEqualTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares each element of <code>this</code> to the corresponding element of <code>other</code> to check if they are the same to within a specified <code>tolerance</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>RigidTransform to compare to <code>this</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>maximum allowable absolute difference between the elements in <code>this</code> and <code>other</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>‖this.matrix() - other.matrix()‖∞ &lt;= tolerance</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Consider scaling tolerance with the largest of magA and magB, where magA and magB denoted the magnitudes of <code>this</code> position vector and <code>other</code> position vectors, respectively. </dd></dl>

</div>
</div>
<a id="a3e39a200466c08cbbe985741fb3b9964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e39a200466c08cbbe985741fb3b9964">&#9670;&nbsp;</a></span>IsNearlyIdentity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; IsNearlyIdentity </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>translation_tolerance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>this</code> is within tolerance of the identity <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways.">RigidTransform</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">translation_tolerance</td><td>a non-negative number. One way to choose <code>translation_tolerance</code> is to multiply a characteristic length (e.g., the magnitude of a characteristic position vector) by an epsilon (e.g., <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a2013671d440f9093574739914d147280" title="Returns an internal tolerance that checks rotation matrix orthonormality.">RotationMatrix::get_internal_tolerance_for_orthonormality()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> portion of <code>this</code> satisfies <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a4cc6cdc7e3174f2af399d7cc2a156b7b" title="Returns true if this is within tolerance of the identity RigidTransform.">RotationMatrix::IsNearlyIdentity()</a> and if the position vector portion of <code>this</code> is equal to zero vector within <code>translation_tolerance</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#ac804feef1db1925cdb41771475381a17" title="Returns true if this is exactly the identity RigidTransform.">IsExactlyIdentity()</a>. </dd></dl>

</div>
</div>
<a id="af5ba8ece1175e9cb229649a048096e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ba8ece1175e9cb229649a048096e79">&#9670;&nbsp;</a></span>operator *() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt;T&gt; operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies <code>this</code> RigidTransform <code>X_AB</code> by the <code>other</code> RigidTransform <code>X_BC</code> and returns the RigidTransform <code>X_AC = X_AB * X_BC</code>. </p>

</div>
</div>
<a id="a7408076cfba12eda75c0c354d70c6a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7408076cfba12eda75c0c354d70c6a96">&#9670;&nbsp;</a></span>operator *() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt;T&gt; operator * </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Translation&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_BBq</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies <code>this</code> RigidTransform <code>X_AB</code> by the translation-only transform <code>X_BBq</code> and returns the RigidTransform <code>X_ABq = X_AB * X_BBq</code>. </p>
<dl class="section note"><dt>Note</dt><dd>The rotation matrix in the returned RigidTransform <code>X_ABq</code> is equal to the rotation matrix in <code>X_AB</code>. <code>X_ABq</code> and <code>X_AB</code> only differ by origin location. </dd></dl>

</div>
</div>
<a id="aa9832cec727611df141fdd479838b3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9832cec727611df141fdd479838b3c7">&#9670;&nbsp;</a></span>operator *() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt; operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BoQ_B</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies <code>this</code> RigidTransform <code>X_AB</code> by the position vector <code>p_BoQ_B</code> which is from Bo (B's origin) to an arbitrary point Q. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BoQ_B</td><td>position vector from Bo to Q, expressed in frame B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">p_AoQ_A</td><td>position vector from Ao to Q, expressed in frame A. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af22020b0567a392bfc275031a868657f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22020b0567a392bfc275031a868657f">&#9670;&nbsp;</a></span>operator *() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;typename Derived::Scalar, 3, Derived::ColsAtCompileTime&gt; operator * </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BoQ_B</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies <code>this</code> RigidTransform <code>X_AB</code> by the n position vectors <code>p_BoQ1_B</code> ... </p>
<p><code>p_BoQn_B</code>, where <code>p_BoQi_B</code> is the iᵗʰ position vector from Bo (frame B's origin) to an arbitrary point Qi, expressed in frame B. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BoQ_B</td><td><code>3 x n</code> matrix with n position vectors <code>p_BoQi_B</code> or an expression that resolves to a <code>3 x n</code> matrix of position vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">p_AoQ_A</td><td><code>3 x n</code> matrix with n position vectors <code>p_AoQi_A</code>, i.e., n position vectors from Ao (frame A's origin) to Qi, expressed in frame A. Specifically, this operator* is defined so that <code>X_AB * p_BoQ_B</code> returns <code>p_AoQ_A = p_AoBo_A + R_AB * p_BoQ_B</code>, where <code>p_AoBo_A</code> is the position vector from Ao to Bo expressed in A and <code>R_AB</code> is the rotation matrix relating the orientation of frames A and B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>As needed, use parentheses. This operator* is not associative. To see this, let <code>p = p_AoBo_A</code>, <code>q = p_BoQ_B</code> and note (X_AB * q) * 7 = (p + R_AB * q) * 7 ≠ X_AB * (q * 7) = p + R_AB * (q * 7). <div class="fragment"><div class="line"><span class="keyword">const</span> RollPitchYaw&lt;double&gt; rpy(0.1, 0.2, 0.3);</div><div class="line"><span class="keyword">const</span> RigidTransform&lt;double&gt; X_AB(rpy, Vector3d(1, 2, 3));</div><div class="line">Eigen::Matrix&lt;double, 3, 2&gt; p_BoQ_B;</div><div class="line">p_BoQ_B.col(0) = Vector3d(4, 5, 6);</div><div class="line">p_BoQ_B.col(1) = Vector3d(9, 8, 7);</div><div class="line"><span class="keyword">const</span> Eigen::Matrix&lt;double, 3, 2&gt; p_AoQ_A = X_AB * p_BoQ_B;</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a40da2f0f20579d4730f4ba7968fe4a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40da2f0f20579d4730f4ba7968fe4a53">&#9670;&nbsp;</a></span>operator *=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt;T&gt;&amp; operator *= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In-place multiply of <code>this</code> RigidTransform <code>X_AB</code> by <code>other</code> RigidTransform <code>X_BC</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>RigidTransform that post-multiplies <code>this</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>this</code> RigidTransform which has been multiplied by <code>other</code>. On return, <code>this = X_AC</code>, where <code>X_AC = X_AB * X_BC</code>. </dd></dl>

</div>
</div>
<a id="a257f755b0f58f8958f8827b0651e205c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257f755b0f58f8958f8827b0651e205c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a814b6772b29ffd1c2bbc34befae3667d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a814b6772b29ffd1c2bbc34befae3667d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acbb70b2d5e20b8e9a4ffe2e21c7bf8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb70b2d5e20b8e9a4ffe2e21c7bf8fd">&#9670;&nbsp;</a></span>rotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt;T&gt;&amp; rotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns R_AB, the rotation matrix portion of <code>this</code> RigidTransform. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">R_AB</td><td>the rotation matrix portion of <code>this</code> RigidTransform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae31756c2694bacdfdf6b0c75602d498b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31756c2694bacdfdf6b0c75602d498b">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <code>this</code> RigidTransform from a <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html" title="This class represents a 3x3 rotation matrix between two arbitrary frames A and B and helps ensure use...">RotationMatrix</a> and a position vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>rotation matrix relating frames A and B (e.g., <code>R_AB</code>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>position vector from frame A's origin to frame B's origin, expressed in frame A. In monogram notation p is denoted <code>p_AoBo_A</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e953a8287f40248d4d2c1030ef72cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e953a8287f40248d4d2c1030ef72cef">&#9670;&nbsp;</a></span>set_rotation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_rotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the RotationMatrix portion of <code>this</code> RigidTransform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>rotation matrix relating frames A and B (e.g., <code>R_AB</code>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3c9f6da94bb9af6ec8426b32bbb5da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c9f6da94bb9af6ec8426b32bbb5da3">&#9670;&nbsp;</a></span>set_rotation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_rotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html">RollPitchYaw</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rpy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the rotation part of <code>this</code> RigidTransform from a <a class="el" href="classdrake_1_1math_1_1_roll_pitch_yaw.html" title="This class represents the orientation between two arbitrary frames A and D associated with a Space-fi...">RollPitchYaw</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rpy</td><td>"roll-pitch-yaw" angles. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a05183386f55111df27e380877a9f11b2" title="Constructs a RotationMatrix from an RollPitchYaw.">RotationMatrix::RotationMatrix(const RollPitchYaw&lt;T&gt;&amp;)</a> which describes the parameter, preconditions, etc. </dd></dl>

</div>
</div>
<a id="a9e5d6e6cb699351acd9c562fa2cfe139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5d6e6cb699351acd9c562fa2cfe139">&#9670;&nbsp;</a></span>set_rotation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_rotation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>quaternion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the rotation part of <code>this</code> RigidTransform from a Quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">quaternion</td><td>a quaternion which may or may not have unit length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a7f6eb5993bd83412f92e82aa49873ae6" title="Constructs a RotationMatrix from an Eigen::Quaternion.">RotationMatrix::RotationMatrix(const Eigen::Quaternion&lt;T&gt;&amp;)</a> which describes the parameter, preconditions, exception conditions, etc. </dd></dl>

</div>
</div>
<a id="a08c8cdccdeb018584d05a3d7557bf42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c8cdccdeb018584d05a3d7557bf42c">&#9670;&nbsp;</a></span>set_rotation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_rotation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::AngleAxis&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta_lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the rotation part of <code>this</code> RigidTransform from an AngleAxis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta_lambda</td><td>an angle <code>theta</code> (in radians) and vector <code>lambda</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#aeb8205e6418bc644739b23879344135b" title="Constructs a RotationMatrix from an Eigen::AngleAxis.">RotationMatrix::RotationMatrix(const Eigen::AngleAxis&lt;T&gt;&amp;)</a> which describes the parameter, preconditions, exception conditions, etc. </dd></dl>

</div>
</div>
<a id="a1fe4dc36c56c493ac1e956ec185bdfea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe4dc36c56c493ac1e956ec185bdfea">&#9670;&nbsp;</a></span>set_translation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_translation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the position vector portion of <code>this</code> RigidTransform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>position vector from Ao (frame A's origin) to Bo (frame B's origin) expressed in frame A. In monogram notation p is denoted p_AoBo_A. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e77b1e5fde8184fd5d18a62d00297bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e77b1e5fde8184fd5d18a62d00297bf">&#9670;&nbsp;</a></span>SetFromIsometry3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetFromIsometry3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a9eb383d64a842ca9002f66b2e10254aa">Isometry3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>pose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <code>this</code> RigidTransform from an Eigen Isometry3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pose</td><td>Isometry3 that contains an allegedly valid rotation matrix <code>R_AB</code> and also contains a position vector <code>p_AoBo_A</code> from frame A's origin to frame B's origin. <code>p_AoBo_A</code> must be expressed in frame A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>in debug builds if R_AB is not a proper orthonormal 3x3 rotation matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>No attempt is made to orthogonalize the 3x3 rotation matrix part of <code>pose</code>. As needed, use <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html#a7d51dc7c0ba0f0cf4747d47e9203255f" title="Given an approximate rotation matrix M, finds the RotationMatrix R closest to M.">RotationMatrix::ProjectToRotationMatrix()</a>. </dd></dl>

</div>
</div>
<a id="abd964513cdca714478e29210f7e9cf31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd964513cdca714478e29210f7e9cf31">&#9670;&nbsp;</a></span>SetIdentity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt;T&gt;&amp; SetIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <code>this</code> RigidTransform so it corresponds to aligning the two frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is coincident with Bo. </p>
<p>Hence, <code>this</code> RigidTransform contains a 3x3 identity matrix and a zero position vector. </p>

</div>
</div>
<a id="a3ee702d4bdc143681fe2b84270e609f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee702d4bdc143681fe2b84270e609f2">&#9670;&nbsp;</a></span>translation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt;&amp; translation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>p_AoBo_A</code>, the position vector portion of <code>this</code> RigidTransform, i.e., position vector from Ao (frame A's origin) to Bo (frame B's origin). </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a10a6bee63e97e5697d2f4dac49cde380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a6bee63e97e5697d2f4dac49cde380">&#9670;&nbsp;</a></span>operator *</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt;T&gt; operator * </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Translation&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_AAq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_AqB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the translation-only transform <code>X_AAq</code> by the RigidTransform <code>X_AqB</code> and returns the RigidTransform <code>X_AB = X_AAq * X_AqB</code>. </p>
<dl class="section note"><dt>Note</dt><dd>The rotation matrix in the returned RigidTransform <code>X_AB</code> is equal to the rotation matrix in <code>X_AqB</code>. <code>X_AB</code> and <code>X_AqB</code> only differ by origin location. </dd></dl>

</div>
</div>
<a id="a25d3e276d5e4e1fad974214851ce0b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d3e276d5e4e1fad974214851ce0b46">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream insertion operator to write an instance of <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways.">RigidTransform</a> into a <code>std::ostream</code>. </p>
<p>Especially useful for debugging.</p>

</div>
</div>
<a id="a8bedd8c483aaf5bc48587d10d7a3d485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bedd8c483aaf5bc48587d10d7a3d485">&#9670;&nbsp;</a></span>RigidTransform</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afdc48b2f77bba9b5873dc56ec1b7248d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc48b2f77bba9b5873dc56ec1b7248d">&#9670;&nbsp;</a></span>RigidTransformd</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#afdc48b2f77bba9b5873dc56ec1b7248d">RigidTransformd</a> =  <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a>&lt;double&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Abbreviation (alias/typedef) for a <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html" title="This class represents a proper rigid transform between two frames which can be regarded in two ways.">RigidTransform</a> double scalar type. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>drake/math/<a class="el" href="fast__pose__composition__functions_8h.html">fast_pose_composition_functions.h</a></li>
<li>drake/math/<a class="el" href="rigid__transform_8h.html">rigid_transform.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- footer -->
<div id="nav-path" class="navpath">
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1math.html">math</a></li><li class="navelem"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform</a></li>
  </ul>
</div>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().value = searchBox.searchLabel;
</script>
</body>
</html>
