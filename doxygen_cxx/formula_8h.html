<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake/common/symbolic/expression/formula.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('formula_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">formula.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;functional&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;ostream&gt;</code><br />
<code>#include &lt;set&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;Eigen/Core&gt;</code><br />
<code>#include &quot;<a class="el" href="drake__assert_8h.html">drake/common/drake_assert.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="drake__bool_8h.html">drake/common/drake_bool.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="drake__copyable_8h.html">drake/common/drake_copyable.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="eigen__types_8h.html">drake/common/eigen_types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fmt_8h.html">drake/common/fmt.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="hash_8h.html">drake/common/hash.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="random_8h.html">drake/common/random.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for formula.h:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="formula_8h__incl.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="formula_8h__dep__incl.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:Formula" id="r_Formula"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a symbolic form of a first-order logic formula.  <a href="classdrake_1_1symbolic_1_1_formula.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConditionTraits_3C_20symbolic_3A_3AFormula_20_3E" id="r_ConditionTraits_3C_20symbolic_3A_3AFormula_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1assert_1_1_condition_traits_3_01symbolic_1_1_formula_01_4.html">ConditionTraits&lt; symbolic::Formula &gt;</a></td></tr>
<tr class="memitem:hash_3C_20drake_3A_3Asymbolic_3A_3AFormula_20_3E" id="r_hash_3C_20drake_3A_3Asymbolic_3A_3AFormula_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1hash_3_01drake_1_1symbolic_1_1_formula_01_4.html">hash&lt; drake::symbolic::Formula &gt;</a></td></tr>
<tr class="memitem:less_3C_20drake_3A_3Asymbolic_3A_3AFormula_20_3E" id="r_less_3C_20drake_3A_3Asymbolic_3A_3AFormula_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1less_3_01drake_1_1symbolic_1_1_formula_01_4.html">less&lt; drake::symbolic::Formula &gt;</a></td></tr>
<tr class="memitem:equal_5Fto_3C_20drake_3A_3Asymbolic_3A_3AFormula_20_3E" id="r_equal_5Fto_3C_20drake_3A_3Asymbolic_3A_3AFormula_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1equal__to_3_01drake_1_1symbolic_1_1_formula_01_4.html">equal_to&lt; drake::symbolic::Formula &gt;</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:drake" id="r_drake"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake.html">drake</a></td></tr>
<tr class="memitem:drake_3A_3Asymbolic" id="r_drake_3A_3Asymbolic"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html">drake::symbolic</a></td></tr>
<tr class="memitem:drake_3A_3Aassert" id="r_drake_3A_3Aassert"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1assert.html">drake::assert</a></td></tr>
<tr class="memitem:std" id="r_std"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestd.html">std</a></td></tr>
<tr class="memdesc:namespacestd"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL namespace. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6869e7044dd90be5d972ee7dd4e821b6" id="r_a6869e7044dd90be5d972ee7dd4e821b6"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a> { <br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6af8320b26d30ab433c5a54546d21f414c">False</a>
, <a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6af827cf462f62848df37c5e1e94a4da74">True</a>
, <a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a5a92344ee95acf10c31901b36418be77">Var</a>
, <a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a3718b5ecf60aa0dba49e150e96cb1fc3">Eq</a>
, <br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6ae4ecc5da3c6dbb4448f25990dc609727">Neq</a>
, <a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a086cb8308e5a36e7c4ed1f8873ad801f">Gt</a>
, <a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a5dabfebb89e6e45a8cf8573d92746ed3">Geq</a>
, <a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a50033c15af7795cd6617f117b29d6922">Lt</a>
, <br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6abe5721bf93d718a79358217ec9b88176">Leq</a>
, <a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6ac33315685a0cba3ce53be378b3c7874b">And</a>
, <a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a3a2d5fe857d8f9541136a124c2edec6c">Or</a>
, <a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6aa74c05d080620f087c4e523977230666">Not</a>
, <br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a43cfe3c750a08acb91df1e3384548078">Forall</a>
, <a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6afd116e3418522ffc34d7423bc601510d">Isnan</a>
, <a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a1fbc164d3e50b7fd20690a21f1b7b2f2">PositiveSemidefinite</a>
<br />
 }</td></tr>
<tr class="memdesc:a6869e7044dd90be5d972ee7dd4e821b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kinds of symbolic formulas.  <a href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5206a4972567789a21f4c05dbbca1bc7" id="r_a5206a4972567789a21f4c05dbbca1bc7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5206a4972567789a21f4c05dbbca1bc7">operator&lt;</a> (<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a> k1, <a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a> k2)</td></tr>
<tr class="memitem:a7d13fc861c980e5cca95449bb11cbe01" id="r_a7d13fc861c980e5cca95449bb11cbe01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7d13fc861c980e5cca95449bb11cbe01">forall</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a7d13fc861c980e5cca95449bb11cbe01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a formula <code class="param">f</code>, universally quantified by variables <code class="param">vars</code>.  <br /></td></tr>
<tr class="memitem:ad928a3acb97d0b15191fdda370098cec" id="r_ad928a3acb97d0b15191fdda370098cec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad928a3acb97d0b15191fdda370098cec">make_conjunction</a> (const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp;formulas)</td></tr>
<tr class="memdesc:ad928a3acb97d0b15191fdda370098cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a conjunction of <code class="param">formulas</code>.  <br /></td></tr>
<tr class="memitem:afa29726cabd0dc09fe4fb61ffe80ad02" id="r_afa29726cabd0dc09fe4fb61ffe80ad02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#afa29726cabd0dc09fe4fb61ffe80ad02">operator&amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f1, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f2)</td></tr>
<tr class="memitem:ae4af14e85b9784db6c9f6374e7d7ae67" id="r_ae4af14e85b9784db6c9f6374e7d7ae67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae4af14e85b9784db6c9f6374e7d7ae67">operator&amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memitem:a3b513c43cd0d555b75ce08e18241e920" id="r_a3b513c43cd0d555b75ce08e18241e920"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3b513c43cd0d555b75ce08e18241e920">operator&amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="memitem:a47ad638c3929268d643623b21901e11a" id="r_a47ad638c3929268d643623b21901e11a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a47ad638c3929268d643623b21901e11a">operator&amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v1, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v2)</td></tr>
<tr class="memitem:a10a756a422ebc5e372bb1ecc5ccab5be" id="r_a10a756a422ebc5e372bb1ecc5ccab5be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a10a756a422ebc5e372bb1ecc5ccab5be">make_disjunction</a> (const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp;formulas)</td></tr>
<tr class="memdesc:a10a756a422ebc5e372bb1ecc5ccab5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a disjunction of <code class="param">formulas</code>.  <br /></td></tr>
<tr class="memitem:afd02ba28125fcb30762312b0361e0790" id="r_afd02ba28125fcb30762312b0361e0790"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#afd02ba28125fcb30762312b0361e0790">operator||</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f1, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f2)</td></tr>
<tr class="memitem:a1b37f14ce7a17532970ad74b4182267d" id="r_a1b37f14ce7a17532970ad74b4182267d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1b37f14ce7a17532970ad74b4182267d">operator||</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memitem:af301dd903e8b79a8584fa3ed0fb3708a" id="r_af301dd903e8b79a8584fa3ed0fb3708a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af301dd903e8b79a8584fa3ed0fb3708a">operator||</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="memitem:a09c7a845583db868b2d30a66c2616397" id="r_a09c7a845583db868b2d30a66c2616397"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a09c7a845583db868b2d30a66c2616397">operator||</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v1, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v2)</td></tr>
<tr class="memitem:a49edb4821b05df85a60fe3d96adf4f70" id="r_a49edb4821b05df85a60fe3d96adf4f70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a49edb4821b05df85a60fe3d96adf4f70">operator!</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memitem:a9175736ad1ead8240b9bbc1bd8d4f37f" id="r_a9175736ad1ead8240b9bbc1bd8d4f37f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9175736ad1ead8240b9bbc1bd8d4f37f">operator!</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="memitem:ae28c71d4bee52bfa5e4928605a4ee87d" id="r_ae28c71d4bee52bfa5e4928605a4ee87d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae28c71d4bee52bfa5e4928605a4ee87d">operator==</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="memitem:acf2a23baf604198889aab8eea8620601" id="r_acf2a23baf604198889aab8eea8620601"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acf2a23baf604198889aab8eea8620601">operator!=</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="memitem:aea9d6243717b5f82e19ace8a5d88f450" id="r_aea9d6243717b5f82e19ace8a5d88f450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aea9d6243717b5f82e19ace8a5d88f450">operator&lt;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="memitem:ad91873fce901342b010a449f7952d290" id="r_ad91873fce901342b010a449f7952d290"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad91873fce901342b010a449f7952d290">operator&lt;=</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="memitem:a047255afbaefd1684cccb967c2ceb1b7" id="r_a047255afbaefd1684cccb967c2ceb1b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a047255afbaefd1684cccb967c2ceb1b7">operator&gt;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="memitem:ac8f5b0df2a3fecea9d23b24475c7fdca" id="r_ac8f5b0df2a3fecea9d23b24475c7fdca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac8f5b0df2a3fecea9d23b24475c7fdca">operator&gt;=</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="memitem:aee7da5a29fea63347ec7c9fddce7f022" id="r_aee7da5a29fea63347ec7c9fddce7f022"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aee7da5a29fea63347ec7c9fddce7f022">isnan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aee7da5a29fea63347ec7c9fddce7f022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a> for the predicate isnan(e) to the given expression.  <br /></td></tr>
<tr class="memitem:a566d62c9e145df5946146f1a53c12a96" id="r_a566d62c9e145df5946146f1a53c12a96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a566d62c9e145df5946146f1a53c12a96">isinf</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a566d62c9e145df5946146f1a53c12a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a> determining if the given expression <code class="param">e</code> is a positive or negative infinity.  <br /></td></tr>
<tr class="memitem:ae2e386e89865ff1db9ac93f7a3e79586" id="r_ae2e386e89865ff1db9ac93f7a3e79586"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae2e386e89865ff1db9ac93f7a3e79586">isfinite</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ae2e386e89865ff1db9ac93f7a3e79586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a> determining if the given expression <code class="param">e</code> has a finite value.  <br /></td></tr>
<tr class="memitem:a525eb4ca416c6055765da5ba992b1c9c" id="r_a525eb4ca416c6055765da5ba992b1c9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a525eb4ca416c6055765da5ba992b1c9c">positive_semidefinite</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &gt; &amp;m)</td></tr>
<tr class="memdesc:a525eb4ca416c6055765da5ba992b1c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula constraining <code class="param">m</code> to be a positive-semidefinite matrix.  <br /></td></tr>
<tr class="memitem:ab7294a6a837aa476fe079c9d5596f373" id="r_ab7294a6a837aa476fe079c9d5596f373"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab7294a6a837aa476fe079c9d5596f373">positive_semidefinite</a> (const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;m, Eigen::UpLoType mode)</td></tr>
<tr class="memdesc:ab7294a6a837aa476fe079c9d5596f373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a symbolic positive-semidefinite formula from <code class="param">m</code>.  <br /></td></tr>
<tr class="memitem:a073573483e330bf1779f5079b2e88d8c" id="r_a073573483e330bf1779f5079b2e88d8c"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a073573483e330bf1779f5079b2e88d8c template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a073573483e330bf1779f5079b2e88d8c">positive_semidefinite</a> (const Eigen::TriangularView&lt; Derived, Eigen::Lower &gt; &amp;l)</td></tr>
<tr class="memdesc:a073573483e330bf1779f5079b2e88d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a symbolic positive-semidefinite formula from a lower triangular-view <code class="param">l</code>.  <br /></td></tr>
<tr class="memitem:a79e5b283a437914a863d9f4cde2d8fdd" id="r_a79e5b283a437914a863d9f4cde2d8fdd"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a79e5b283a437914a863d9f4cde2d8fdd template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a79e5b283a437914a863d9f4cde2d8fdd">positive_semidefinite</a> (const Eigen::TriangularView&lt; Derived, Eigen::Upper &gt; &amp;u)</td></tr>
<tr class="memdesc:a79e5b283a437914a863d9f4cde2d8fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a symbolic positive-semidefinite formula from an upper triangular-view <code class="param">u</code>.  <br /></td></tr>
<tr class="memitem:a96c90655d4fb45b63c8e1bde735e6c47" id="r_a96c90655d4fb45b63c8e1bde735e6c47"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a96c90655d4fb45b63c8e1bde735e6c47">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memitem:aea6545b9866491ab6406d9141903d204" id="r_aea6545b9866491ab6406d9141903d204"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aea6545b9866491ab6406d9141903d204">is_false</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:aea6545b9866491ab6406d9141903d204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is structurally equal to False formula.  <br /></td></tr>
<tr class="memitem:ac015488f4fe334717bbe5a47e1f1da87" id="r_ac015488f4fe334717bbe5a47e1f1da87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac015488f4fe334717bbe5a47e1f1da87">is_true</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:ac015488f4fe334717bbe5a47e1f1da87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is structurally equal to True formula.  <br /></td></tr>
<tr class="memitem:aebdc9659eb8cc2eb735925fc4f2828ac" id="r_aebdc9659eb8cc2eb735925fc4f2828ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aebdc9659eb8cc2eb735925fc4f2828ac">is_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:aebdc9659eb8cc2eb735925fc4f2828ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a variable formula.  <br /></td></tr>
<tr class="memitem:aa44a7661fef44d4031441019512ef82d" id="r_aa44a7661fef44d4031441019512ef82d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa44a7661fef44d4031441019512ef82d">is_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:aa44a7661fef44d4031441019512ef82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a formula representing equality (==).  <br /></td></tr>
<tr class="memitem:a7b22d6f9b90847ce4b84be2a5afd1c30" id="r_a7b22d6f9b90847ce4b84be2a5afd1c30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7b22d6f9b90847ce4b84be2a5afd1c30">is_not_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a7b22d6f9b90847ce4b84be2a5afd1c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a formula representing disequality (!=).  <br /></td></tr>
<tr class="memitem:a25bef67cdba7a3575080ee23c4a49c24" id="r_a25bef67cdba7a3575080ee23c4a49c24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a25bef67cdba7a3575080ee23c4a49c24">is_greater_than</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a25bef67cdba7a3575080ee23c4a49c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a formula representing greater-than (&gt;).  <br /></td></tr>
<tr class="memitem:aa6bd435704910ee83eec832dec9e0ebe" id="r_aa6bd435704910ee83eec832dec9e0ebe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa6bd435704910ee83eec832dec9e0ebe">is_greater_than_or_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:aa6bd435704910ee83eec832dec9e0ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a formula representing greater-than-or-equal-to (&gt;=).  <br /></td></tr>
<tr class="memitem:a9754658b6efb430a95a6ef060573970e" id="r_a9754658b6efb430a95a6ef060573970e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9754658b6efb430a95a6ef060573970e">is_less_than</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a9754658b6efb430a95a6ef060573970e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a formula representing less-than (&lt;).  <br /></td></tr>
<tr class="memitem:af1861c52cf99c60f758c0f4bd642ecf9" id="r_af1861c52cf99c60f758c0f4bd642ecf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af1861c52cf99c60f758c0f4bd642ecf9">is_less_than_or_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:af1861c52cf99c60f758c0f4bd642ecf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a formula representing less-than-or-equal-to (&lt;=).  <br /></td></tr>
<tr class="memitem:ab48c893fbcf425253c444573d100c3f2" id="r_ab48c893fbcf425253c444573d100c3f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab48c893fbcf425253c444573d100c3f2">is_relational</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:ab48c893fbcf425253c444573d100c3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a relational formula ({==, !=, &gt;, &gt;=, &lt;, &lt;=}).  <br /></td></tr>
<tr class="memitem:a70fdb6bef6734fc34b5215e5c7b661df" id="r_a70fdb6bef6734fc34b5215e5c7b661df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a70fdb6bef6734fc34b5215e5c7b661df">is_conjunction</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a70fdb6bef6734fc34b5215e5c7b661df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a conjunction (∧).  <br /></td></tr>
<tr class="memitem:a307cee89f5417dd1c19ba16bb273fb25" id="r_a307cee89f5417dd1c19ba16bb273fb25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a307cee89f5417dd1c19ba16bb273fb25">is_disjunction</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a307cee89f5417dd1c19ba16bb273fb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a disjunction (∨).  <br /></td></tr>
<tr class="memitem:a63d76102c00828325b11b21db606b5a0" id="r_a63d76102c00828325b11b21db606b5a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a63d76102c00828325b11b21db606b5a0">is_nary</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a63d76102c00828325b11b21db606b5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a n-ary formula ({∧, ∨}).  <br /></td></tr>
<tr class="memitem:afbbcd3f16b91bba700239675e5826a81" id="r_afbbcd3f16b91bba700239675e5826a81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#afbbcd3f16b91bba700239675e5826a81">is_negation</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:afbbcd3f16b91bba700239675e5826a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a negation (¬).  <br /></td></tr>
<tr class="memitem:a1860e7373cbab3826845de76f4c6fc6a" id="r_a1860e7373cbab3826845de76f4c6fc6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1860e7373cbab3826845de76f4c6fc6a">is_forall</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a1860e7373cbab3826845de76f4c6fc6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a Forall formula (∀).  <br /></td></tr>
<tr class="memitem:a75b1751d953407c394e5643f2d1d3f27" id="r_a75b1751d953407c394e5643f2d1d3f27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a75b1751d953407c394e5643f2d1d3f27">is_isnan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a75b1751d953407c394e5643f2d1d3f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is an isnan formula.  <br /></td></tr>
<tr class="memitem:a31788a703bff17b148b3107beefbc585" id="r_a31788a703bff17b148b3107beefbc585"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a31788a703bff17b148b3107beefbc585">is_positive_semidefinite</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a31788a703bff17b148b3107beefbc585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code class="param">f</code> is a positive-semidefinite formula.  <br /></td></tr>
<tr class="memitem:a85376535fc0a875d116702f9186d8f99" id="r_a85376535fc0a875d116702f9186d8f99"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a85376535fc0a875d116702f9186d8f99">get_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a85376535fc0a875d116702f9186d8f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the embedded variable in the variable formula <code class="param">f</code>.  <br /></td></tr>
<tr class="memitem:a77f3d349554a28bfa3f1107bb4adaab6" id="r_a77f3d349554a28bfa3f1107bb4adaab6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a77f3d349554a28bfa3f1107bb4adaab6">get_lhs_expression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a77f3d349554a28bfa3f1107bb4adaab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lhs-argument of a relational formula <code class="param">f</code>.  <br /></td></tr>
<tr class="memitem:af855c0227ec69f59da11988c82ae4ce2" id="r_af855c0227ec69f59da11988c82ae4ce2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af855c0227ec69f59da11988c82ae4ce2">get_rhs_expression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:af855c0227ec69f59da11988c82ae4ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rhs-argument of a relational formula <code class="param">f</code>.  <br /></td></tr>
<tr class="memitem:a4ce6eacfc51cea8af6b9c1e0e963807a" id="r_a4ce6eacfc51cea8af6b9c1e0e963807a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4ce6eacfc51cea8af6b9c1e0e963807a">get_unary_expression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a4ce6eacfc51cea8af6b9c1e0e963807a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the expression in a unary expression formula <code class="param">f</code>.  <br /></td></tr>
<tr class="memitem:a5a51076f5f4ab9497965268ceb34e82c" id="r_a5a51076f5f4ab9497965268ceb34e82c"><td class="memItemLeft" align="right" valign="top">const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5a51076f5f4ab9497965268ceb34e82c">get_operands</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a5a51076f5f4ab9497965268ceb34e82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of formulas in a n-ary formula <code class="param">f</code>.  <br /></td></tr>
<tr class="memitem:a4d6409b69e4049b282edaaea65fe1b43" id="r_a4d6409b69e4049b282edaaea65fe1b43"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4d6409b69e4049b282edaaea65fe1b43">get_operand</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a4d6409b69e4049b282edaaea65fe1b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the formula in a negation formula <code class="param">f</code>.  <br /></td></tr>
<tr class="memitem:a637fea2c6cfc60b582df81b7b1187e94" id="r_a637fea2c6cfc60b582df81b7b1187e94"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a637fea2c6cfc60b582df81b7b1187e94">get_quantified_variables</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a637fea2c6cfc60b582df81b7b1187e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the quantified variables in a forall formula <code class="param">f</code>.  <br /></td></tr>
<tr class="memitem:a6d5aa689465b2522a75c7dc12fcf1b60" id="r_a6d5aa689465b2522a75c7dc12fcf1b60"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6d5aa689465b2522a75c7dc12fcf1b60">get_quantified_formula</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a6d5aa689465b2522a75c7dc12fcf1b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the quantified formula in a forall formula <code class="param">f</code>.  <br /></td></tr>
<tr class="memitem:ab77026017746534a08312bf9eb2d4a99" id="r_ab77026017746534a08312bf9eb2d4a99"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab77026017746534a08312bf9eb2d4a99">get_matrix_in_positive_semidefinite</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:ab77026017746534a08312bf9eb2d4a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the matrix in a positive-semidefinite formula <code class="param">f</code>.  <br /></td></tr>
<tr class="memitem:a993b173875967c3a3d57757f554dfab4" id="r_a993b173875967c3a3d57757f554dfab4"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a993b173875967c3a3d57757f554dfab4 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()==typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a993b173875967c3a3d57757f554dfab4">operator==</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a993b173875967c3a3d57757f554dfab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise symbolic-equality of two arrays <code class="param">m1</code> and <code class="param">m2</code>.  <br /></td></tr>
<tr class="memitem:a4656598caa852c1ad39ea6513e8aeff6" id="r_a4656598caa852c1ad39ea6513e8aeff6"><td class="memTemplParams" colspan="2">template&lt;typename Derived, typename ScalarType&gt; </td></tr>
<tr class="memitem:a4656598caa852c1ad39ea6513e8aeff6 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar()==ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4656598caa852c1ad39ea6513e8aeff6">operator==</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:a4656598caa852c1ad39ea6513e8aeff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code class="param">a</code> and a scalar <code class="param">v</code> using equal-to operator (==).  <br /></td></tr>
<tr class="memitem:ac5764ce1fcaf60cd695e106397ea7bb7" id="r_ac5764ce1fcaf60cd695e106397ea7bb7"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType, typename Derived&gt; </td></tr>
<tr class="memitem:ac5764ce1fcaf60cd695e106397ea7bb7 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType()==typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac5764ce1fcaf60cd695e106397ea7bb7">operator==</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:ac5764ce1fcaf60cd695e106397ea7bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code class="param">v</code> and an array <code class="param">using</code> equal-to operator (==).  <br /></td></tr>
<tr class="memitem:a00e6a5930a86434ef7dd224f001a282b" id="r_a00e6a5930a86434ef7dd224f001a282b"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a00e6a5930a86434ef7dd224f001a282b template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()&lt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a00e6a5930a86434ef7dd224f001a282b">operator&lt;=</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a00e6a5930a86434ef7dd224f001a282b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code class="param">a1</code> and <code class="param">a2</code> using less-than-or-equal operator (&lt;=).  <br /></td></tr>
<tr class="memitem:a74f6eeef08887be237dd99f50e3efeb8" id="r_a74f6eeef08887be237dd99f50e3efeb8"><td class="memTemplParams" colspan="2">template&lt;typename Derived, typename ScalarType&gt; </td></tr>
<tr class="memitem:a74f6eeef08887be237dd99f50e3efeb8 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar()&lt;=ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a74f6eeef08887be237dd99f50e3efeb8">operator&lt;=</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:a74f6eeef08887be237dd99f50e3efeb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code class="param">a</code> and a scalar <code class="param">v</code> using less-than-or-equal operator (&lt;=).  <br /></td></tr>
<tr class="memitem:a1546fbcbc705d680d1ae89a5dd5e9c1b" id="r_a1546fbcbc705d680d1ae89a5dd5e9c1b"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType, typename Derived&gt; </td></tr>
<tr class="memitem:a1546fbcbc705d680d1ae89a5dd5e9c1b template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType()&lt;=typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1546fbcbc705d680d1ae89a5dd5e9c1b">operator&lt;=</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a1546fbcbc705d680d1ae89a5dd5e9c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code class="param">v</code> and an array <code class="param">using</code> less-than-or-equal operator (&lt;=).  <br /></td></tr>
<tr class="memitem:a2a7547f207b1d32989acd9629fba4994" id="r_a2a7547f207b1d32989acd9629fba4994"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a2a7547f207b1d32989acd9629fba4994 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()&lt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2a7547f207b1d32989acd9629fba4994">operator&lt;</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a2a7547f207b1d32989acd9629fba4994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code class="param">a1</code> and <code class="param">a2</code> using less-than operator (&lt;).  <br /></td></tr>
<tr class="memitem:afd43f36981591cbe9f45910e46c041a9" id="r_afd43f36981591cbe9f45910e46c041a9"><td class="memTemplParams" colspan="2">template&lt;typename Derived, typename ScalarType&gt; </td></tr>
<tr class="memitem:afd43f36981591cbe9f45910e46c041a9 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar()&lt; ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#afd43f36981591cbe9f45910e46c041a9">operator&lt;</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:afd43f36981591cbe9f45910e46c041a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code class="param">a</code> and a scalar <code class="param">v</code> using less-than operator (&lt;).  <br /></td></tr>
<tr class="memitem:a08bfc1af3d18b12aa8a994d31a2643f7" id="r_a08bfc1af3d18b12aa8a994d31a2643f7"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType, typename Derived&gt; </td></tr>
<tr class="memitem:a08bfc1af3d18b12aa8a994d31a2643f7 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType()&lt; typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a08bfc1af3d18b12aa8a994d31a2643f7">operator&lt;</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a08bfc1af3d18b12aa8a994d31a2643f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code class="param">v</code> and an array <code class="param">using</code> less-than operator (&lt;).  <br /></td></tr>
<tr class="memitem:a2fd72f8875df01ff36fdedd9371e8db0" id="r_a2fd72f8875df01ff36fdedd9371e8db0"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a2fd72f8875df01ff36fdedd9371e8db0 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() &gt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2fd72f8875df01ff36fdedd9371e8db0">operator&gt;=</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a2fd72f8875df01ff36fdedd9371e8db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code class="param">a1</code> and <code class="param">a2</code> using greater-than-or-equal operator (&gt;=).  <br /></td></tr>
<tr class="memitem:ac9c625401bc6fa407a54cb6004b8299f" id="r_ac9c625401bc6fa407a54cb6004b8299f"><td class="memTemplParams" colspan="2">template&lt;typename Derived, typename ScalarType&gt; </td></tr>
<tr class="memitem:ac9c625401bc6fa407a54cb6004b8299f template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar() &gt;=ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac9c625401bc6fa407a54cb6004b8299f">operator&gt;=</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:ac9c625401bc6fa407a54cb6004b8299f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code class="param">a</code> and a scalar <code class="param">v</code> using greater-than-or-equal operator (&gt;=).  <br /></td></tr>
<tr class="memitem:a6f190c2b8351007ad0ebf41a52d03472" id="r_a6f190c2b8351007ad0ebf41a52d03472"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType, typename Derived&gt; </td></tr>
<tr class="memitem:a6f190c2b8351007ad0ebf41a52d03472 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType() &gt;=typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6f190c2b8351007ad0ebf41a52d03472">operator&gt;=</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a6f190c2b8351007ad0ebf41a52d03472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code class="param">v</code> and an array <code class="param">using</code> less-than-or-equal operator (&lt;=) instead of greater-than-or-equal operator (&gt;=).  <br /></td></tr>
<tr class="memitem:add8009d78d933826d765faf7ae3d112f" id="r_add8009d78d933826d765faf7ae3d112f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:add8009d78d933826d765faf7ae3d112f template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() &gt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#add8009d78d933826d765faf7ae3d112f">operator&gt;</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:add8009d78d933826d765faf7ae3d112f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code class="param">a1</code> and <code class="param">a2</code> using greater-than operator (&gt;).  <br /></td></tr>
<tr class="memitem:a39121e92f332d2ca0dc6e42e6f9344a0" id="r_a39121e92f332d2ca0dc6e42e6f9344a0"><td class="memTemplParams" colspan="2">template&lt;typename Derived, typename ScalarType&gt; </td></tr>
<tr class="memitem:a39121e92f332d2ca0dc6e42e6f9344a0 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar() &gt; ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a39121e92f332d2ca0dc6e42e6f9344a0">operator&gt;</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:a39121e92f332d2ca0dc6e42e6f9344a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code class="param">a</code> and a scalar <code class="param">v</code> using greater-than operator (&gt;).  <br /></td></tr>
<tr class="memitem:a7d51445b9c7e7e2292fcfebd038b1738" id="r_a7d51445b9c7e7e2292fcfebd038b1738"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType, typename Derived&gt; </td></tr>
<tr class="memitem:a7d51445b9c7e7e2292fcfebd038b1738 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType() &gt; typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7d51445b9c7e7e2292fcfebd038b1738">operator&gt;</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a7d51445b9c7e7e2292fcfebd038b1738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code class="param">v</code> and an array <code class="param">using</code> less-than operator (&lt;) instead of greater-than operator (&gt;).  <br /></td></tr>
<tr class="memitem:a8e2230c401a3cf25909b4b25cac536be" id="r_a8e2230c401a3cf25909b4b25cac536be"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a8e2230c401a3cf25909b4b25cac536be template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() !=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8e2230c401a3cf25909b4b25cac536be">operator!=</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a8e2230c401a3cf25909b4b25cac536be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code class="param">a1</code> and <code class="param">a2</code> using not-equal operator (!=).  <br /></td></tr>
<tr class="memitem:a417bf2fd4f030f7aa2d3ac779bf4c099" id="r_a417bf2fd4f030f7aa2d3ac779bf4c099"><td class="memTemplParams" colspan="2">template&lt;typename Derived, typename ScalarType&gt; </td></tr>
<tr class="memitem:a417bf2fd4f030f7aa2d3ac779bf4c099 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename Derived::Scalar() !=ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a417bf2fd4f030f7aa2d3ac779bf4c099">operator!=</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:a417bf2fd4f030f7aa2d3ac779bf4c099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code class="param">a</code> and a scalar <code class="param">v</code> using not-equal operator (!=).  <br /></td></tr>
<tr class="memitem:a0e08ccfd1038cd9ee942d2c32d9db1d6" id="r_a0e08ccfd1038cd9ee942d2c32d9db1d6"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType, typename Derived&gt; </td></tr>
<tr class="memitem:a0e08ccfd1038cd9ee942d2c32d9db1d6 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(ScalarType() !=typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0e08ccfd1038cd9ee942d2c32d9db1d6">operator!=</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a0e08ccfd1038cd9ee942d2c32d9db1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code class="param">v</code> and an array <code class="param">using</code> not-equal operator (!=).  <br /></td></tr>
<tr class="memitem:a5baf7e7e983ace79d366f506103a06db" id="r_a5baf7e7e983ace79d366f506103a06db"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a5baf7e7e983ace79d366f506103a06db template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()==typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5baf7e7e983ace79d366f506103a06db">operator==</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:a5baf7e7e983ace79d366f506103a06db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula checking if two matrices <code class="param">m1</code> and <code class="param">m2</code> are equal.  <br /></td></tr>
<tr class="memitem:a092d073efe77947ba617bc41cf166308" id="r_a092d073efe77947ba617bc41cf166308"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a092d073efe77947ba617bc41cf166308 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() !=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a092d073efe77947ba617bc41cf166308">operator!=</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:a092d073efe77947ba617bc41cf166308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing the condition whether <code class="param">m1</code> and <code class="param">m2</code> are not the same.  <br /></td></tr>
<tr class="memitem:ac3ae1c03a9f8e4a5dc7b4131e5a60294" id="r_ac3ae1c03a9f8e4a5dc7b4131e5a60294"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:ac3ae1c03a9f8e4a5dc7b4131e5a60294 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()&lt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac3ae1c03a9f8e4a5dc7b4131e5a60294">operator&lt;</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:ac3ae1c03a9f8e4a5dc7b4131e5a60294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing element-wise comparison between two matrices <code class="param">m1</code> and <code class="param">m2</code> using less-than (&lt;) operator.  <br /></td></tr>
<tr class="memitem:a29be67079f48ecf9ed0420b7e92de59f" id="r_a29be67079f48ecf9ed0420b7e92de59f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a29be67079f48ecf9ed0420b7e92de59f template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar()&lt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a29be67079f48ecf9ed0420b7e92de59f">operator&lt;=</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:a29be67079f48ecf9ed0420b7e92de59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing element-wise comparison between two matrices <code class="param">m1</code> and <code class="param">m2</code> using less-than-or-equal operator (&lt;=).  <br /></td></tr>
<tr class="memitem:ae9dbd563dfe489f43f1f0754c4a04e27" id="r_ae9dbd563dfe489f43f1f0754c4a04e27"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:ae9dbd563dfe489f43f1f0754c4a04e27 template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() &gt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae9dbd563dfe489f43f1f0754c4a04e27">operator&gt;</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:ae9dbd563dfe489f43f1f0754c4a04e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing element-wise comparison between two matrices <code class="param">m1</code> and <code class="param">m2</code> using greater-than operator (&gt;).  <br /></td></tr>
<tr class="memitem:a59b73c7509dfecd799346d10b030bedd" id="r_a59b73c7509dfecd799346d10b030bedd"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA, typename DerivedB&gt; </td></tr>
<tr class="memitem:a59b73c7509dfecd799346d10b030bedd template"><td class="memItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt; &amp;&amp;std::is_same_v&lt; decltype(typename DerivedA::Scalar() &gt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a59b73c7509dfecd799346d10b030bedd">operator&gt;=</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:a59b73c7509dfecd799346d10b030bedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing element-wise comparison between two matrices <code class="param">m1</code> and <code class="param">m2</code> using greater-than-or-equal operator (&gt;=).  <br /></td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="dir_f1666844dc41ec91c14125b680b7be1b.html">drake</a></li><li class="navelem"><a href="dir_a36da230f0956f48b11c85f7d599788f.html">common</a></li><li class="navelem"><a href="dir_66d630ac47407fe11bcb76d9e7e25510.html">symbolic</a></li><li class="navelem"><a href="dir_38bb68bb9a9977cf78f44d487961d9ec.html">expression</a></li><li class="navelem"><a href="formula_8h.html">formula.h</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
