<!-- HTML header for doxygen 1.14.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: ContactSurface&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only‚Ä¶">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake‚Ä¶">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1geometry_1_1_contact_surface.html','','classdrake_1_1geometry_1_1_contact_surface-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">ContactSurface&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class drake::geometry::ContactSurface&lt; T &gt;</div><p>The ContactSurface characterizes the intersection of two geometries M and N as a contact surface with a scalar field and a vector field, whose purpose is to support the hydroelastic pressure field contact model as described in: </p>
<pre class="fragment">R. Elandt, E. Drumwright, M. Sherman, and A. Ruina. A pressure
field model for fast, robust approximation of net contact force
and moment between nominally rigid objects. IROS 2019: 8238-8245.
</pre><h2>Mathematical Concepts </h2>
<p>In this section, we give motivation for the concept of contact surface from the hydroelastic pressure field contact model. Here the mathematical discussion is coordinate-free (treatment of the topic without reference to any particular coordinate system); however, our implementation heavily relies on coordinate frames. We borrow terminology from differential geometry.</p>
<p>In this section, the mathematical term <em>compact set</em> (a subset of Euclidean space that is closed and bounded) corresponds to the term <em>geometry</em> (or the space occupied by the geometry) in <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>.</p>
<p>We describe the contact surface ùïä‚Çò‚Çô between two intersecting compact subsets ùïÑ and ‚Ñï of ‚Ñù¬≥ with the scalar fields e‚Çò and e‚Çô defined on ùïÑ ‚äÇ ‚Ñù¬≥ and ‚Ñï ‚äÇ ‚Ñù¬≥ respectively: </p><pre class="fragment">           e‚Çò : ùïÑ ‚Üí ‚Ñù,
           e‚Çô : ‚Ñï ‚Üí ‚Ñù.
</pre><p>The <em>contact surface</em> ùïä‚Çò‚Çô is the surface of equilibrium e‚Çò = e‚Çô. It is the locus of points Q where e‚Çò(Q) equals e‚Çô(Q): </p><pre class="fragment">         ùïä‚Çò‚Çô = { Q ‚àà ùïÑ ‚à© ‚Ñï : e‚Çò(Q) = e‚Çô(Q) }.
</pre><p>We can define the scalar field e‚Çò‚Çô on the surface ùïä‚Çò‚Çô as a scalar function that assigns Q ‚àà ùïä‚Çò‚Çô the value of e‚Çò(Q), which is the same as e‚Çô(Q): </p><pre class="fragment">         e‚Çò‚Çô : ùïä‚Çò‚Çô ‚Üí ‚Ñù,
         e‚Çò‚Çô(Q) = e‚Çò(Q) = e‚Çô(Q).
</pre><p>We can also define the scalar field h‚Çò‚Çô on ùïÑ ‚à© ‚Ñï as the difference between e‚Çò and e‚Çô: </p><pre class="fragment">         h‚Çò‚Çô : ùïÑ ‚à© ‚Ñï ‚Üí ‚Ñù,
         h‚Çò‚Çô(Q) = e‚Çò(Q) - e‚Çô(Q).
</pre><p>It follows that the gradient vector field ‚àáh‚Çò‚Çô on ùïÑ ‚à© ‚Ñï equals the difference between the gradient vector fields ‚àáe‚Çò and ‚àáe‚Çô: </p><pre class="fragment">         ‚àáh‚Çò‚Çô : ùïÑ ‚à© ‚Ñï ‚Üí ‚Ñù¬≥,
         ‚àáh‚Çò‚Çô(Q) = ‚àáe‚Çò(Q) - ‚àáe‚Çô(Q).
</pre><p>By construction, Q ‚àà ùïä‚Çò‚Çô if and only if h‚Çò‚Çô(Q) = 0. In other words, ùïä‚Çò‚Çô is the zero level set of h‚Çò‚Çô. It follows that, for Q ‚àà ùïä‚Çò‚Çô, ‚àáh‚Çò‚Çô(Q) is orthogonal to the surface ùïä‚Çò‚Çô at Q in the direction of increasing e‚Çò - e‚Çô.            </p>
<p>Notice that the domain of e‚Çò‚Çô is the two-dimensional surface ùïä‚Çò‚Çô, while the domain of ‚àáh‚Çò‚Çô is the three-dimensional compact set ùïÑ ‚à© ‚Ñï. Even though e‚Çò‚Çô and ‚àáh‚Çò‚Çô are defined on different domains (ùïä‚Çò‚Çô and ùïÑ ‚à© ‚Ñï), our implementation only represents them on their common domain, i.e., ùïä‚Çò‚Çô.</p>
<p><a class="anchor" id="contact_surface_discrete_representation"></a></p><h2>Discrete Representation </h2>
<p>In practice, hydroelastic geometries themselves have a discrete representation: either a triangular surface mesh for rigid geometries or a tetrahedral volume mesh for compliant geometry. This discretization leads to contact surfaces that are likewise discrete.</p>
<p>Intersection between triangles and tetrahedra (or tetrahedra and tetrahedra) can produce polygons with up to eight sides. A ContactSurface can represent the resulting surface as a mesh of such polygons, or as a mesh of tessellated triangles. The domains of the two representations are identical. The triangular version admits for simple, high-order integration over the domain. Every element is a triangle, and triangles will only disappear and reappear as their areas go to zero. However, this increases the total number of faces in the mesh by more than a factor of three over the polygonal mesh. The polygonal representation produces fewer faces, but high order integration over polygons is problematic. We recommend choosing the cheapest representation that nevertheless supports your required fidelity (see <a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a5f3ed3fb982c7a42090728675389d1d6" title="Reports pairwise intersections and characterizes each non-empty intersection as a ContactSurface for ...">QueryObject::ComputeContactSurfaces()</a>).</p>
<p>The representation of any ContactSurface instance can be reported by calling <a class="el" href="#a96d488ade2f4cdc251cfb36601fa8652" title="Reports the representation mode of this contact surface.">representation()</a>. If it returns <a class="el" href="namespacedrake_1_1geometry.html#a227f80cb57c9c87f6ecc4e839e364979a3a53496ffe96227ef579995d332425c1">HydroelasticContactRepresentation::kTriangle</a>, then the mesh and pressure field can be accessed via <a class="el" href="#a8a9b01c40d03fb0ac838f4b4b8f3f5df" title="Returns a reference to the triangular surface mesh whose vertex positions are measured and expressed ...">tri_mesh_W()</a> and <a class="el" href="#a3ce6dff23938e9e43de4095f038af23c" title="Returns a reference to the scalar field e‚Çò‚Çô for the triangle mesh.">tri_e_MN()</a>, respectively. If it returns <a class="el" href="namespacedrake_1_1geometry.html#a227f80cb57c9c87f6ecc4e839e364979a64edd70c85c6854f380a0cbbc3db3cbb">HydroelasticContactRepresentation::kPolygon</a>, then use <a class="el" href="#a36ab81fd5b668ce60927ce6d482307fa" title="Returns a reference to the polygonal surface mesh whose vertex positions are measured and expressed i...">poly_mesh_W()</a> and <a class="el" href="#a4bd0c0566825dce1706c62d4b40d53c6" title="Returns a reference to the scalar field e‚Çò‚Çô for the polygonal mesh.">poly_e_MN()</a>.</p>
<p>Regardless of representation (polygon or triangle), the normal for each mesh face is guaranteed to point "out of" N and "into" M. They can be accessed via the mesh, e.g., <span class="tt"><a class="el" href="#a8a9b01c40d03fb0ac838f4b4b8f3f5df" title="Returns a reference to the triangular surface mesh whose vertex positions are measured and expressed ...">tri_mesh_W()</a>.face_normal(face_index)</span>. By definition, the normals of the mesh are discontinuous at triangle boundaries.</p>
<p>The pressure values on the contact surface are represented as a continuous, piecewise-linear function, accessed via <a class="el" href="#a3ce6dff23938e9e43de4095f038af23c" title="Returns a reference to the scalar field e‚Çò‚Çô for the triangle mesh.">tri_e_MN()</a> or <a class="el" href="#a4bd0c0566825dce1706c62d4b40d53c6" title="Returns a reference to the scalar field e‚Çò‚Çô for the polygonal mesh.">poly_e_MN()</a>.</p>
<p>When available, the values of ‚àáe‚Çò and ‚àáe‚Çô are represented as a discontinuous, piecewise-constant function over the faces &ndash; one gradient vector per face. These quantities are accessed via <a class="el" href="#a78aab44760701f947aac12725e755ca4" title="Returns the value of ‚àáe‚Çò for the face with index index.">EvaluateGradE_M_W()</a> and <a class="el" href="#a412209f94f6ccf19216775c95a2876ce" title="Returns the value of ‚àáe‚Çô for the face with index index.">EvaluateGradE_N_W()</a>, respectively.</p>
<h2>Barycentric Coordinates </h2>
<p>For Point Q on the surface mesh of the contact surface between Geometry M and Geometry N, r_WQ = (x,y,z) is the displacement vector from the origin of the world frame to Q expressed in the coordinate frame of W. We also have the <em>barycentric coordinates</em> (b0, b1, b2) on a triangle of the surface mesh that contains Q. With vertices of the triangle labeled as v‚ÇÄ, v‚ÇÅ, v‚ÇÇ, we can map (b0, b1, b2) to r_WQ by: </p><pre class="fragment">         r_WQ = b0 * r_Wv‚ÇÄ + b1 * r_Wv‚ÇÅ + b2 * r_Wv‚ÇÇ,
         b0 + b1 + b2 = 1, b·µ¢ ‚àà [0,1],
</pre><p>where r_Wv·µ¢ is the displacement vector of the vertex labeled as v·µ¢ from the origin of the world frame, expressed in the world frame.</p>
<p>We use the barycentric coordinates to evaluate the field values.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default nonsymbolic scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/geometry/query_results/contact_surface.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:a995bbea49dd6633a4fcf02a47b1c670c" id="r_a995bbea49dd6633a4fcf02a47b1c670c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a995bbea49dd6633a4fcf02a47b1c670c">ContactSurface</a> (const <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a> &amp;)</td></tr>
<tr class="memitem:a5b56bc615794676c482fea38c685d81d" id="r_a5b56bc615794676c482fea38c685d81d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b56bc615794676c482fea38c685d81d">operator=</a> (const <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a> &amp;)</td></tr>
<tr class="memitem:a4a0ce4b6954481f1c7300e4bc6efb0bf" id="r_a4a0ce4b6954481f1c7300e4bc6efb0bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a0ce4b6954481f1c7300e4bc6efb0bf">ContactSurface</a> (<a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a> &amp;&amp;)</td></tr>
<tr class="memitem:a509acfd07499b9e5a8f74d6fc9119144" id="r_a509acfd07499b9e5a8f74d6fc9119144"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a509acfd07499b9e5a8f74d6fc9119144">operator=</a> (<a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a> &amp;&amp;)</td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>The ContactSurface can be constructed with either a polygon or triangle mesh representation.</p>
<p>The constructor invoked determines the representation.</p>
<p>The general shape of each constructor is identical. They take the unique identifiers for the two geometries in contact, a mesh representation, a field representation, and (optional) gradients of the contacting geometries' pressure fields.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id_M</td><td>The id of the first geometry M. </td></tr>
    <tr><td class="paramname">id_N</td><td>The id of the second geometry N. </td></tr>
    <tr><td class="paramname">mesh_W</td><td>The surface mesh of the contact surface ùïä‚Çò‚Çô between M and N. The mesh vertices are defined in the world frame. </td></tr>
    <tr><td class="paramname">e_MN</td><td>Represents the scalar field e‚Çò‚Çô on the surface mesh. </td></tr>
    <tr><td class="paramname">grad_eM_W</td><td>‚àáe‚Çò sampled once per face, expressed in the world frame. </td></tr>
    <tr><td class="paramname">grad_eN_W</td><td>‚àáe‚Çô sampled once per face, expressed in the world frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The face normals in <span class="tt">mesh_W</span> point <em>out of</em> geometry N and <em>into</em> M. </dd>
<dd>
If given, <span class="tt">grad_eM_W</span> and <span class="tt">grad_eN_W</span> must have as many entries as <span class="tt">mesh_W</span> has faces and the ith entry in each should correspond to the ith face in <span class="tt">mesh_W</span>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <span class="tt">id_M &gt; id_N</span>, the labels will be swapped and the normals of the mesh reversed (to maintain the documented invariants). Comparing the input parameters with the members of the resulting ContactSurface will reveal if such a swap has occurred. </dd></dl>
</div></td></tr>
<tr class="memitem:a6670cc73319c241b1460dd3a48fc6855" id="r_a6670cc73319c241b1460dd3a48fc6855"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6670cc73319c241b1460dd3a48fc6855">ContactSurface</a> (<a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> <a class="el" href="#a9d19415980a599e76803d1c2ac6954cd">id_M</a>, <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> <a class="el" href="#a643bdff7b47f07604755e0a7e0707fee">id_N</a>, std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_triangle_surface_mesh.html">TriangleSurfaceMesh</a>&lt; T &gt; &gt; mesh_W, std::unique_ptr&lt; <a class="el" href="namespacedrake_1_1geometry.html#afb1cea0cef695099b2d920680d24050f">TriangleSurfaceMeshFieldLinear</a>&lt; T, T &gt; &gt; e_MN, std::unique_ptr&lt; std::vector&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &gt; &gt; grad_eM_W=nullptr, std::unique_ptr&lt; std::vector&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &gt; &gt; grad_eN_W=nullptr)</td></tr>
<tr class="memdesc:a6670cc73319c241b1460dd3a48fc6855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a ContactSurface with a triangle mesh representation.  <br /></td></tr>
<tr class="memitem:aacda6fc802acbf64e18720b2ac5ed303" id="r_aacda6fc802acbf64e18720b2ac5ed303"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacda6fc802acbf64e18720b2ac5ed303">ContactSurface</a> (<a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> <a class="el" href="#a9d19415980a599e76803d1c2ac6954cd">id_M</a>, <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> <a class="el" href="#a643bdff7b47f07604755e0a7e0707fee">id_N</a>, std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a>&lt; T &gt; &gt; mesh_W, std::unique_ptr&lt; <a class="el" href="namespacedrake_1_1geometry.html#a70187c16ea14553f92a3bec4402ae490">PolygonSurfaceMeshFieldLinear</a>&lt; T, T &gt; &gt; e_MN, std::unique_ptr&lt; std::vector&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &gt; &gt; grad_eM_W=nullptr, std::unique_ptr&lt; std::vector&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &gt; &gt; grad_eN_W=nullptr)</td></tr>
<tr class="memdesc:aacda6fc802acbf64e18720b2ac5ed303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a ContactSurface with a polygonal mesh representation.  <br /></td></tr>
<tr class="memitem:a2f11e433d81423d8cf64b7f314fc06d7" id="r_a2f11e433d81423d8cf64b7f314fc06d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f11e433d81423d8cf64b7f314fc06d7">~ContactSurface</a> ()</td></tr>
<tr class="memitem:a9d19415980a599e76803d1c2ac6954cd" id="r_a9d19415980a599e76803d1c2ac6954cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d19415980a599e76803d1c2ac6954cd">id_M</a> () const</td></tr>
<tr class="memdesc:a9d19415980a599e76803d1c2ac6954cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the geometry id of Geometry M.  <br /></td></tr>
<tr class="memitem:a643bdff7b47f07604755e0a7e0707fee" id="r_a643bdff7b47f07604755e0a7e0707fee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a643bdff7b47f07604755e0a7e0707fee">id_N</a> () const</td></tr>
<tr class="memdesc:a643bdff7b47f07604755e0a7e0707fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the geometry id of Geometry N.  <br /></td></tr>
<tr id="pub-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Representation-independent API</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>These methods represent sugar which masks the details of the mesh representation.</p>
<p>They facilitate querying various mesh quantities that are common to the two representations, so that code can access the properties without worrying about the representation. If necessary, the actual meshes and fields can be accessed directly via the representation-dependent APIs below. </p>
</div></td></tr>
<tr class="memitem:a132d1bbcbcc1ac76319da744805bd865" id="r_a132d1bbcbcc1ac76319da744805bd865"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a132d1bbcbcc1ac76319da744805bd865">num_faces</a> () const</td></tr>
<tr class="memitem:a319e621fc359dd8daad48247f95b12fa" id="r_a319e621fc359dd8daad48247f95b12fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a319e621fc359dd8daad48247f95b12fa">num_vertices</a> () const</td></tr>
<tr class="memitem:a3cbee02880449dd0437777333068674b" id="r_a3cbee02880449dd0437777333068674b"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cbee02880449dd0437777333068674b">area</a> (int face_index) const</td></tr>
<tr class="memitem:a2308d95ee36082f222b032f3abbbf7d6" id="r_a2308d95ee36082f222b032f3abbbf7d6"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2308d95ee36082f222b032f3abbbf7d6">total_area</a> () const</td></tr>
<tr class="memitem:aa88b332c2bde7f75281aaab0ebdf4a08" id="r_aa88b332c2bde7f75281aaab0ebdf4a08"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa88b332c2bde7f75281aaab0ebdf4a08">face_normal</a> (int face_index) const</td></tr>
<tr class="memitem:ae8aa79499e296b294b6fc89a7accf897" id="r_ae8aa79499e296b294b6fc89a7accf897"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8aa79499e296b294b6fc89a7accf897">centroid</a> (int face_index) const</td></tr>
<tr class="memitem:a3c4c114c452d2aecee2b06bc801b5f7c" id="r_a3c4c114c452d2aecee2b06bc801b5f7c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c4c114c452d2aecee2b06bc801b5f7c">centroid</a> () const</td></tr>
<tr id="pub-methods-3" class="groupHeader"><td colspan="2"><div class="groupHeader">Representation-dependent API</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>These functions provide insight into what representation the ContactSurface instance uses, and provide access to the representation-dependent quantities: mesh and field. </p>
</div></td></tr>
<tr class="memitem:ac1777d06cb15879ee1356176db3c77f1" id="r_ac1777d06cb15879ee1356176db3c77f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1777d06cb15879ee1356176db3c77f1">is_triangle</a> () const</td></tr>
<tr class="memdesc:ac1777d06cb15879ee1356176db3c77f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply reports if this contact surface's mesh representation is triangle.  <br /></td></tr>
<tr class="memitem:a96d488ade2f4cdc251cfb36601fa8652" id="r_a96d488ade2f4cdc251cfb36601fa8652"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1geometry.html#a227f80cb57c9c87f6ecc4e839e364979">HydroelasticContactRepresentation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96d488ade2f4cdc251cfb36601fa8652">representation</a> () const</td></tr>
<tr class="memdesc:a96d488ade2f4cdc251cfb36601fa8652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the representation mode of this contact surface.  <br /></td></tr>
<tr class="memitem:a8a9b01c40d03fb0ac838f4b4b8f3f5df" id="r_a8a9b01c40d03fb0ac838f4b4b8f3f5df"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1geometry_1_1_triangle_surface_mesh.html">TriangleSurfaceMesh</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a9b01c40d03fb0ac838f4b4b8f3f5df">tri_mesh_W</a> () const</td></tr>
<tr class="memdesc:a8a9b01c40d03fb0ac838f4b4b8f3f5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the <em>triangular</em> surface mesh whose vertex positions are measured and expressed in the world frame.  <br /></td></tr>
<tr class="memitem:a3ce6dff23938e9e43de4095f038af23c" id="r_a3ce6dff23938e9e43de4095f038af23c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake_1_1geometry.html#afb1cea0cef695099b2d920680d24050f">TriangleSurfaceMeshFieldLinear</a>&lt; T, T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ce6dff23938e9e43de4095f038af23c">tri_e_MN</a> () const</td></tr>
<tr class="memdesc:a3ce6dff23938e9e43de4095f038af23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the scalar field e‚Çò‚Çô for the <em>triangle</em> mesh.  <br /></td></tr>
<tr class="memitem:a36ab81fd5b668ce60927ce6d482307fa" id="r_a36ab81fd5b668ce60927ce6d482307fa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36ab81fd5b668ce60927ce6d482307fa">poly_mesh_W</a> () const</td></tr>
<tr class="memdesc:a36ab81fd5b668ce60927ce6d482307fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the <em>polygonal</em> surface mesh whose vertex positions are measured and expressed in the world frame.  <br /></td></tr>
<tr class="memitem:a4bd0c0566825dce1706c62d4b40d53c6" id="r_a4bd0c0566825dce1706c62d4b40d53c6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake_1_1geometry.html#a70187c16ea14553f92a3bec4402ae490">PolygonSurfaceMeshFieldLinear</a>&lt; T, T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bd0c0566825dce1706c62d4b40d53c6">poly_e_MN</a> () const</td></tr>
<tr class="memdesc:a4bd0c0566825dce1706c62d4b40d53c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the scalar field e‚Çò‚Çô for the <em>polygonal</em> mesh.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Evaluation of constituent pressure fields</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The ContactSurface <em>provisionally</em> includes the gradients of the constituent pressure fields (‚àáe‚Çò and ‚àáe‚Çô) sampled on the contact surface.</p>
<p>In order for these values to be included in an instance, the gradient for the corresponding mesh must be well defined. For example a rigid mesh will not have a well-defined pressure gradient; as stiffness goes to infinity, the geometry becomes rigid and the gradient <em>direction</em> converges to the direction of the rigid mesh's surface normals, but the magnitude goes to infinity, producing a pressure gradient that would be some variant of <span class="tt">&lt;‚àû, ‚àû, ‚àû&gt;</span>.</p>
<p>Accessing the gradient values must be pre-conditioned on a test that the particular instance of ContactSurface actually contains the gradient data. The presence of gradient data for each geometry must be confirmed separately.</p>
<p>The values ‚àáe‚Çò and ‚àáe‚Çò are piecewise constant over the ContactSurface and can only be evaluate on a per-face basis. </p>
</td></tr>
<tr class="memitem:a4e24704419c5448aa572060e183dde80" id="r_a4e24704419c5448aa572060e183dde80"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:a4e24704419c5448aa572060e183dde80 template"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e24704419c5448aa572060e183dde80">ContactSurfaceTester</a></td></tr>
<tr class="memitem:a9e133d23830a9b6ffaa3652b26c417d3" id="r_a9e133d23830a9b6ffaa3652b26c417d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e133d23830a9b6ffaa3652b26c417d3">HasGradE_M</a> () const</td></tr>
<tr class="memitem:a127d93d3788af836f8fbded056377db2" id="r_a127d93d3788af836f8fbded056377db2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a127d93d3788af836f8fbded056377db2">HasGradE_N</a> () const</td></tr>
<tr class="memitem:a78aab44760701f947aac12725e755ca4" id="r_a78aab44760701f947aac12725e755ca4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78aab44760701f947aac12725e755ca4">EvaluateGradE_M_W</a> (int index) const</td></tr>
<tr class="memdesc:a78aab44760701f947aac12725e755ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of ‚àáe‚Çò for the face with index <span class="tt">index</span>.  <br /></td></tr>
<tr class="memitem:a412209f94f6ccf19216775c95a2876ce" id="r_a412209f94f6ccf19216775c95a2876ce"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a412209f94f6ccf19216775c95a2876ce">EvaluateGradE_N_W</a> (int index) const</td></tr>
<tr class="memdesc:a412209f94f6ccf19216775c95a2876ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of ‚àáe‚Çô for the face with index <span class="tt">index</span>.  <br /></td></tr>
<tr class="memitem:a162b2f40894082b5057435796adf2c04" id="r_a162b2f40894082b5057435796adf2c04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a162b2f40894082b5057435796adf2c04">Equal</a> (const <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a>&lt; T &gt; &amp;surface) const</td></tr>
<tr class="memdesc:a162b2f40894082b5057435796adf2c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see whether the given <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html" title="The ContactSurface characterizes the intersection of two geometries M and N as a contact surface with...">ContactSurface</a> object is equal via deep exact comparison.  <br /></td></tr>
</table>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a995bbea49dd6633a4fcf02a47b1c670c" name="a995bbea49dd6633a4fcf02a47b1c670c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995bbea49dd6633a4fcf02a47b1c670c">&#9670;&#160;</a></span>ContactSurface() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a0ce4b6954481f1c7300e4bc6efb0bf" name="a4a0ce4b6954481f1c7300e4bc6efb0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0ce4b6954481f1c7300e4bc6efb0bf">&#9670;&#160;</a></span>ContactSurface() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6670cc73319c241b1460dd3a48fc6855" name="a6670cc73319c241b1460dd3a48fc6855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6670cc73319c241b1460dd3a48fc6855">&#9670;&#160;</a></span>ContactSurface() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a></td>          <td class="paramname"><span class="paramname"><em>id_M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a></td>          <td class="paramname"><span class="paramname"><em>id_N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_triangle_surface_mesh.html">TriangleSurfaceMesh</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>mesh_W</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="namespacedrake_1_1geometry.html#afb1cea0cef695099b2d920680d24050f">TriangleSurfaceMeshFieldLinear</a>&lt; T, T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>e_MN</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; std::vector&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>grad_eM_W</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; std::vector&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>grad_eN_W</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a ContactSurface with a triangle mesh representation. </p>

</div>
</div>
<a id="aacda6fc802acbf64e18720b2ac5ed303" name="aacda6fc802acbf64e18720b2ac5ed303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacda6fc802acbf64e18720b2ac5ed303">&#9670;&#160;</a></span>ContactSurface() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a></td>          <td class="paramname"><span class="paramname"><em>id_M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a></td>          <td class="paramname"><span class="paramname"><em>id_N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a>&lt; T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>mesh_W</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="namespacedrake_1_1geometry.html#a70187c16ea14553f92a3bec4402ae490">PolygonSurfaceMeshFieldLinear</a>&lt; T, T &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>e_MN</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; std::vector&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>grad_eM_W</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; std::vector&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>grad_eN_W</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a ContactSurface with a polygonal mesh representation. </p>

</div>
</div>
<a id="a2f11e433d81423d8cf64b7f314fc06d7" name="a2f11e433d81423d8cf64b7f314fc06d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f11e433d81423d8cf64b7f314fc06d7">&#9670;&#160;</a></span>~ContactSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a3cbee02880449dd0437777333068674b" name="a3cbee02880449dd0437777333068674b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cbee02880449dd0437777333068674b">&#9670;&#160;</a></span>area()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; area </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>face_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c4c114c452d2aecee2b06bc801b5f7c" name="a3c4c114c452d2aecee2b06bc801b5f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4c114c452d2aecee2b06bc801b5f7c">&#9670;&#160;</a></span>centroid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp; centroid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8aa79499e296b294b6fc89a7accf897" name="ae8aa79499e296b294b6fc89a7accf897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8aa79499e296b294b6fc89a7accf897">&#9670;&#160;</a></span>centroid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; centroid </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>face_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a162b2f40894082b5057435796adf2c04" name="a162b2f40894082b5057435796adf2c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162b2f40894082b5057435796adf2c04">&#9670;&#160;</a></span>Equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>surface</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see whether the given <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html" title="The ContactSurface characterizes the intersection of two geometries M and N as a contact surface with...">ContactSurface</a> object is equal via deep exact comparison. </p>
<p>NaNs are treated as not equal as per the IEEE standard.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>The contact surface for comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the given contact surface is equal. </dd></dl>

</div>
</div>
<a id="a78aab44760701f947aac12725e755ca4" name="a78aab44760701f947aac12725e755ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78aab44760701f947aac12725e755ca4">&#9670;&#160;</a></span>EvaluateGradE_M_W()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp; EvaluateGradE_M_W </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of ‚àáe‚Çò for the face with index <span class="tt">index</span>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="#a9e133d23830a9b6ffaa3652b26c417d3">HasGradE_M()</a> returns false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">index ‚àà [0, mesh().<a class="el" href="#a132d1bbcbcc1ac76319da744805bd865">num_faces()</a>)</span>. </dd></dl>

</div>
</div>
<a id="a412209f94f6ccf19216775c95a2876ce" name="a412209f94f6ccf19216775c95a2876ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412209f94f6ccf19216775c95a2876ce">&#9670;&#160;</a></span>EvaluateGradE_N_W()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp; EvaluateGradE_N_W </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of ‚àáe‚Çô for the face with index <span class="tt">index</span>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="#a127d93d3788af836f8fbded056377db2">HasGradE_N()</a> returns false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt">index ‚àà [0, mesh().<a class="el" href="#a132d1bbcbcc1ac76319da744805bd865">num_faces()</a>)</span>. </dd></dl>

</div>
</div>
<a id="aa88b332c2bde7f75281aaab0ebdf4a08" name="aa88b332c2bde7f75281aaab0ebdf4a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88b332c2bde7f75281aaab0ebdf4a08">&#9670;&#160;</a></span>face_normal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp; face_normal </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>face_index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e133d23830a9b6ffaa3652b26c417d3" name="a9e133d23830a9b6ffaa3652b26c417d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e133d23830a9b6ffaa3652b26c417d3">&#9670;&#160;</a></span>HasGradE_M()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool HasGradE_M </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if <span class="tt">this</span> contains values for ‚àáe‚Çò. </dd></dl>

</div>
</div>
<a id="a127d93d3788af836f8fbded056377db2" name="a127d93d3788af836f8fbded056377db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127d93d3788af836f8fbded056377db2">&#9670;&#160;</a></span>HasGradE_N()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool HasGradE_N </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if <span class="tt">this</span> contains values for ‚àáe‚Çô. </dd></dl>

</div>
</div>
<a id="a9d19415980a599e76803d1c2ac6954cd" name="a9d19415980a599e76803d1c2ac6954cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d19415980a599e76803d1c2ac6954cd">&#9670;&#160;</a></span>id_M()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> id_M </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the geometry id of Geometry M. </p>

</div>
</div>
<a id="a643bdff7b47f07604755e0a7e0707fee" name="a643bdff7b47f07604755e0a7e0707fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643bdff7b47f07604755e0a7e0707fee">&#9670;&#160;</a></span>id_N()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> id_N </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the geometry id of Geometry N. </p>

</div>
</div>
<a id="ac1777d06cb15879ee1356176db3c77f1" name="ac1777d06cb15879ee1356176db3c77f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1777d06cb15879ee1356176db3c77f1">&#9670;&#160;</a></span>is_triangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_triangle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simply reports if this contact surface's mesh representation is triangle. </p>
<p>Equivalent to: </p><pre class="fragment">representation() == HydroelasticContactRepresentation::kTriangle
</pre><p>and offered as convenient sugar. </p>

</div>
</div>
<a id="a132d1bbcbcc1ac76319da744805bd865" name="a132d1bbcbcc1ac76319da744805bd865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132d1bbcbcc1ac76319da744805bd865">&#9670;&#160;</a></span>num_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_faces </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a319e621fc359dd8daad48247f95b12fa" name="a319e621fc359dd8daad48247f95b12fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319e621fc359dd8daad48247f95b12fa">&#9670;&#160;</a></span>num_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int num_vertices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b56bc615794676c482fea38c685d81d" name="a5b56bc615794676c482fea38c685d81d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b56bc615794676c482fea38c685d81d">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a509acfd07499b9e5a8f74d6fc9119144" name="a509acfd07499b9e5a8f74d6fc9119144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509acfd07499b9e5a8f74d6fc9119144">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a>&lt; T &gt; &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bd0c0566825dce1706c62d4b40d53c6" name="a4bd0c0566825dce1706c62d4b40d53c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd0c0566825dce1706c62d4b40d53c6">&#9670;&#160;</a></span>poly_e_MN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake_1_1geometry.html#a70187c16ea14553f92a3bec4402ae490">PolygonSurfaceMeshFieldLinear</a>&lt; T, T &gt; &amp; poly_e_MN </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the scalar field e‚Çò‚Çô for the <em>polygonal</em> mesh. </p>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="#ac1777d06cb15879ee1356176db3c77f1" title="Simply reports if this contact surface&#39;s mesh representation is triangle.">is_triangle()</a></span> returns <span class="tt">false</span>. </dd></dl>

</div>
</div>
<a id="a36ab81fd5b668ce60927ce6d482307fa" name="a36ab81fd5b668ce60927ce6d482307fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ab81fd5b668ce60927ce6d482307fa">&#9670;&#160;</a></span>poly_mesh_W()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1geometry_1_1_polygon_surface_mesh.html">PolygonSurfaceMesh</a>&lt; T &gt; &amp; poly_mesh_W </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the <em>polygonal</em> surface mesh whose vertex positions are measured and expressed in the world frame. </p>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="#ac1777d06cb15879ee1356176db3c77f1" title="Simply reports if this contact surface&#39;s mesh representation is triangle.">is_triangle()</a></span> returns <span class="tt">false</span>. </dd></dl>

</div>
</div>
<a id="a96d488ade2f4cdc251cfb36601fa8652" name="a96d488ade2f4cdc251cfb36601fa8652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d488ade2f4cdc251cfb36601fa8652">&#9670;&#160;</a></span>representation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1geometry.html#a227f80cb57c9c87f6ecc4e839e364979">HydroelasticContactRepresentation</a> representation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the representation mode of this contact surface. </p>
<p>If accessing the mesh or field directly, the APIs that can be successfully exercised are related to this methods return value. See below. </p>

</div>
</div>
<a id="a2308d95ee36082f222b032f3abbbf7d6" name="a2308d95ee36082f222b032f3abbbf7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2308d95ee36082f222b032f3abbbf7d6">&#9670;&#160;</a></span>total_area()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; total_area </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ce6dff23938e9e43de4095f038af23c" name="a3ce6dff23938e9e43de4095f038af23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce6dff23938e9e43de4095f038af23c">&#9670;&#160;</a></span>tri_e_MN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake_1_1geometry.html#afb1cea0cef695099b2d920680d24050f">TriangleSurfaceMeshFieldLinear</a>&lt; T, T &gt; &amp; tri_e_MN </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the scalar field e‚Çò‚Çô for the <em>triangle</em> mesh. </p>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="#ac1777d06cb15879ee1356176db3c77f1" title="Simply reports if this contact surface&#39;s mesh representation is triangle.">is_triangle()</a></span> returns <span class="tt">true</span>. </dd></dl>

</div>
</div>
<a id="a8a9b01c40d03fb0ac838f4b4b8f3f5df" name="a8a9b01c40d03fb0ac838f4b4b8f3f5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9b01c40d03fb0ac838f4b4b8f3f5df">&#9670;&#160;</a></span>tri_mesh_W()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1geometry_1_1_triangle_surface_mesh.html">TriangleSurfaceMesh</a>&lt; T &gt; &amp; tri_mesh_W </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the <em>triangular</em> surface mesh whose vertex positions are measured and expressed in the world frame. </p>
<dl class="section pre"><dt>Precondition</dt><dd><span class="tt"><a class="el" href="#ac1777d06cb15879ee1356176db3c77f1" title="Simply reports if this contact surface&#39;s mesh representation is triangle.">is_triangle()</a></span> returns <span class="tt">true</span>. </dd></dl>

</div>
</div>
<a name="doc-related-members" id="doc-related-members"></a><h2 id="header-doc-related-members" class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a4e24704419c5448aa572060e183dde80" name="a4e24704419c5448aa572060e183dde80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e24704419c5448aa572060e183dde80">&#9670;&#160;</a></span>ContactSurfaceTester</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ContactSurfaceTester</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/geometry/query_results/<a class="el" href="contact__surface_8h.html">contact_surface.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1geometry.html">geometry</a></li><li class="navelem"><a href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name‚Ä¶';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
