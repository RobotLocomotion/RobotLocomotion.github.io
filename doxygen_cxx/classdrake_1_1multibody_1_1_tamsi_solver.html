<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: TamsiSolver&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1multibody_1_1_tamsi_solver.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdrake_1_1multibody_1_1_tamsi_solver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TamsiSolver&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::multibody::TamsiSolver&lt; T &gt;</h3>

<p><a class="anchor" id="tamsi_class_intro"></a>TamsiSolver uses the Transition-Aware Modified Semi-Implicit (TAMSI) method, <a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#castro_etal_2019">[Castro et al., 2019]</a>, to solve the equations below for mechanical systems in contact with regularized friction: </p><pre class="fragment">            q̇ = N(q) v
  (1)  M(q) v̇ = τ + Jₙᵀ(q) fₙ(q, v) + Jₜᵀ(q) fₜ(q, v)
</pre><p> where <code>v ∈ ℝⁿᵛ</code> is the vector of generalized velocities, <code>M(q) ∈ ℝⁿᵛˣⁿᵛ</code> is the mass matrix, <code>Jₙ(q) ∈ ℝⁿᶜˣⁿᵛ</code> is the Jacobian of normal separation velocities, <code>Jₜ(q) ∈ ℝ²ⁿᶜˣⁿᵛ</code> is the Jacobian of tangent velocities, <code>fₙ ∈ ℝⁿᶜ</code> is the vector of normal contact forces, <code>fₜ ∈ ℝ²ⁿᶜ</code> is the vector of tangent friction forces and τ ∈ ℝⁿᵛ is a vector of generalized forces containing all other applied forces (e.g., Coriolis, gyroscopic terms, actuator forces, etc.) but contact forces. This solver assumes a compliant law for the normal forces <code>fₙ(q, v)</code> and therefore the functional dependence of <code>fₙ(q, v)</code> with q and v is stated explicitly.</p>
<p>Since TamsiSolver uses regularized friction, we explicitly emphasize the functional dependence of <code>fₜ(q, v)</code> with the generalized velocities. The functional dependence of <code>fₜ(q, v)</code> with the generalized positions stems from its direct dependence with the normal forces <code>fₙ(q, v)</code>.</p>
<p>TamsiSolver implements two different schemes. A "one-way
coupling scheme" which solves for the friction forces given the normal forces are known. That is, normal forces affect the computation of the friction forces however, the normal forces are kept constant during the solution procedure.</p>
<p>A "two-way coupling scheme" treats both the normal and friction forces implicitly in the generalized velocities resulting in a numerical strategy in which normal forces affect friction forces and, conversely, friction forces couple back to the computation of the normal forces.</p>
<p>The two-way coupled scheme provides a more stable and therefore robust solution to the problem stated in Eq. (1) with just a small increase of the computational cost compared to the one-way coupled scheme. The one-way coupled scheme is however very useful for testing and analysis of the solver.</p>
<p><a class="anchor" id="one_way_coupling_scheme"></a></p><h2>One-Way Coupling Scheme</h2>
<p>Equation (1) is discretized in time using a variation of the first order semi-implicit Euler scheme from step s to step s+1 with time step <code>δt</code> as: </p><pre class="fragment">             qˢ⁺¹ = qˢ + δt N(qˢ) vˢ⁺¹
  (2)  M(qˢ) vˢ⁺¹ =
         M(qˢ) vˢ + δt [τˢ + Jₙᵀ(qˢ) fₙ(qˢ,vˢ) + Jₜᵀ(qˢ) fₜ(qˢ,vˢ⁺¹)]
</pre><p> (We are using s for step counter rather than n to avoid Unicode-induced confusion with the "normal direction" subscript n.)</p>
<p>Please see details in the <a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#one_way_coupling_derivation">Derivation of the one-way coupling scheme</a> section. The equation for the generalized velocities in Eq. (2) is rewritten as: </p><pre class="fragment">  (3)  M vˢ⁺¹ = p* + δt [Jₙᵀ fₙ + Jₜᵀ fₜ(vˢ⁺¹)]
</pre><p> where <code>p* = M vˢ + δt τˢ</code> is the generalized momentum that the system would have in the absence of contact forces and, for simplicity, we have only kept the functional dependencies in generalized velocities. Notice that TamsiSolver uses a precomputed value of the normal forces. These normal forces could be available for instance if using a compliant contact approach, for which normal forces are a function of the state.</p>
<p><a class="anchor" id="two_way_coupling_scheme"></a></p><h2>Two-Way Coupling Scheme</h2>
<p>Equation (1) is discretized in time using a variation on the semi-implicit Euler scheme with time step <code>δt</code> as: </p><pre class="fragment">             qˢ⁺¹ = qˢ + δt N(qˢ) vˢ⁺¹
  (4)  M(qˢ) vˢ⁺¹ = M(qˢ) vˢ +
          δt [τˢ + Jₙᵀ(qˢ) fₙˢ⁺¹ + Jₜᵀ(qˢ) fₜ(fₙˢ⁺¹,vₜˢ⁺¹)]
</pre><p> This implicit scheme variation evaluates Jacobian matrices Jₙ and Jₜ as well as the kinematic mapping N(q) at the previous time step. In Eq. (4) we have fₙˢ⁺¹ = fₙ(xˢ⁺¹, vₙˢ⁺¹) with xˢ⁺¹ = x(qˢ⁺¹), the signed <em>penetration</em> distance (defined positive when bodies overlap) between contact point pairs and the <em>separation</em> velocities vₙˢ⁺¹ = Jₙ(qˢ) vˢ⁺¹ (= −ẋˢ⁺¹). Also the functional dependence of fₜ with fₙ and vₜ is highlighted in Eq. (4). More precisely, the two-way coupling scheme uses a normal force law for each contact pair of the form: </p><pre class="fragment">  (5)  fₙ(x, vₙ) = k(vₙ)₊ x₊
  (6)      k(vₙ) = k (1 − d vₙ)₊
</pre><p> where <code>x₊</code> is the positive part of x (x₊ = x if x ≥ 0 and x₊ = 0 otherwise) and <code>k</code> and d are the stiffness and dissipation coefficients for a given contact point, respectively.</p>
<p>The two-way coupling scheme uses a first order approximation to the signed distance functions vector: </p><pre class="fragment">  (7)  xˢ⁺¹ ≈ xˢ − δt vₙˢ⁺¹ =  xˢ − δt Jₙ(qˢ) vˢ⁺¹
</pre><p> where the minus sign is needed given that ẋ = dx/dt = −vₙ. This approximation is used in Eq. (5) to obtain a numerical scheme that implicitly couples normal forces through their functional dependence on the signed penetration distance. Notice that, according to Eq. (5), normal forces at each contact point are decoupled from each other. However their values are coupled given the choice of a common variable, the generalized velocity v.</p>
<p>Equation (7) is used into Eq. (5) to obtain an expression of the normal force in terms of the generalized velocity vˢ⁺¹ at the next time step: </p><pre class="fragment">  (8) fₙ(xˢ⁺¹, vₙˢ⁺¹) = k (1 − d vₙˢ⁺¹)₊ xˢ⁺¹₊
                      = k (1 − d Jₙ(qˢ) vˢ⁺¹)₊ (xˢ − δt Jₙ(qˢ) vˢ⁺¹)₊
                      = fₙ(vˢ⁺¹)
</pre><p> Similarly, the friction forces fₜ can be written in terms of the next time step generalized velocities using vₜˢ⁺¹ = Jₜ(qˢ) vˢ⁺¹ and using Eq. (8) to substitute an expression for the normal force in terms of vˢ⁺¹. This allows to re-write the tangential forces as a function of the generalized velocities as: </p><pre class="fragment">  (9)  fₜ(fₙˢ⁺¹, vₜˢ⁺¹) = fₜ(fₙ(x(vˢ⁺¹), vₙ(vˢ⁺¹)), vₜ((vˢ⁺¹)))
                        = fₜ(vˢ⁺¹)
</pre><p> where we write x(vˢ⁺¹) = xˢ − δt Jₙ(qˢ) vˢ⁺¹. Finally, Eqs. (8) and (9) are used into Eq. (4) to obtain an expression in vˢ⁺¹: </p><pre class="fragment">  (10)  M(qˢ) vˢ⁺¹ = p* + δt [Jₙᵀ(qˢ) fₙ(vˢ⁺¹) + Jₜᵀ(qˢ) fₜ(vˢ⁺¹)]
</pre><p> with p* = <code>p* = M vˢ + δt τˢ</code> the generalized momentum that the system would have in the absence of contact forces.</p>
<p>TamsiSolver uses a Newton-Raphson strategy to solve Eq. (10) in the generalized velocities, limiting the iteration update with the scheme described in <a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#iteration_limiter">iteration_limiter</a>.</p>
<p><a class="anchor" id="iteration_limiter"></a></p><h2>Limits in the Iteration Updates</h2>
<p>TamsiSolver solves for the generalized velocity at the next time step <code>vˢ⁺¹</code> with either a one-way or two-way coupled scheme as described in the previous sections. The solver uses a Newton-Raphson iteration to compute an update <code>Δvᵏ</code> at the k-th Newton-Raphson iteration. Once <code>Δvᵏ</code> is computed, the solver limits the change in the tangential velocities <code>Δvₜᵏ = Jₜᵀ Δvᵏ</code> using the approach described in <a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#uchida_etal_2015">[Uchida et al., 2015]</a>. This approach limits the maximum angle change θ between two successive iterations in the tangential velocity. Details of our implementation are provided in <a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#castro_etal_2019">[Castro et al., 2019]</a>.</p>
<p><a class="anchor" id="one_way_coupling_derivation"></a></p><h2>Derivation of the one-way coupling scheme</h2>
<p>In this section we provide a detailed derivation of the first order time stepping approach in Eq. (2). We start from the continuous Eq. (1): </p><pre class="fragment">  (1)  M(q) v̇ = τ + Jₙᵀ(q) fₙ(q,v) + Jₜᵀ(q) fₜ(q,v)
</pre><p> we can discretize Eq. (1) in time using a first order semi-implicit Euler scheme in velocities: </p><pre class="fragment">  (11)  M(qˢ) vˢ⁺¹ = M(qˢ) vˢ +
          δt [τˢ⁺¹ + Jₙᵀ(qˢ) fₙ(qˢ,vˢ⁺¹) + Jₜᵀ(qˢ) fₜ(vˢ⁺¹)] + O₁(δt²)
</pre><p> where the equality holds strictly since we included the leading terms in <code>O(δt²)</code>. We use <code>τˢ⁺¹ = τ(tˢ, qˢ, vˢ⁺¹)</code> for brevity in Eq. (11). When moving from the continuous Eq. (1) to the discrete version Eq. (11), we lost the nice property that our compliant normal forces are decoupled from the friction forces (both depend on the same unknown vˢ⁺¹ in Eq (11)). The reason is that Eq. (11) includes an integration over a small interval of size δt. To solve the discrete system in Eq. (11), we'd like to decouple the normal forces from the tangential forces again, which will require a new (though still valid) approximation. To do so we will expand in Taylor series the term <code>fₙ(qˢ, vˢ⁺¹)</code>: </p><pre class="fragment">  (12)  fₙ(qˢ, vˢ⁺¹) = fₙ(qˢ,vˢ) + ∇ᵥfₙ(qˢ,vˢ) (vˢ⁺¹ − vˢ) + O₂(‖vˢ⁺¹ − vˢ‖²)
</pre><p> The difference between <code>vˢ</code> and <code>vˢ⁺¹</code> can be written as: </p><pre class="fragment">  (13)  vˢ⁺¹ − vˢ = δtv̇ˢ + δtO₃(δt²) = O₄(δt)
</pre><p> Substituting <code>vˢ⁺¹ − vˢ</code> from Eq. (13) into Eq. (12) we arrive to: </p><pre class="fragment">  (14)  fₙ(qˢ, vˢ⁺¹) = fₙ(qˢ,vˢ) + ∇ᵥfₙ(qˢ,vˢ) O₄(δt) + O₅(δt²)
                    = fₙ(qˢ,vˢ) + O₆(δt)
</pre><p> where <code>O₅(δt²) = O₂(‖vˢ⁺¹ − vˢ‖²) = O₂(‖O₄(δt)‖²)</code>. A similar argument for τˢ⁺¹ shows it also differs in O(δt) from τˢ = τ(tˢ, qˢ, vˢ). We can now use Eq. (14) into Eq. (11) to arrive to: </p><pre class="fragment">  (15)  M(qˢ) vˢ⁺¹ = M(qˢ) vˢ +
        δt [τˢ + Jₙᵀ(qˢ) (fₙ(qˢ,vˢ) + O₆(δt)] + Jₜᵀ(qˢ) fₜ(vˢ⁺¹)) +
        O₁(δt²)
</pre><p> which we can rewrite as: </p><pre class="fragment">  (16)  M(qˢ) vˢ⁺¹ = M(qˢ) vˢ +
      δt [τˢ + Jₙᵀ(qˢ) fₙ(qˢ, vˢ) + Jₜᵀ(qˢ) fₜ(vˢ⁺¹)] + O₇(δt²)
</pre><p> with <code>O₇(δt²) = δt Jₙᵀ(qˢ) O₆(δt) + O₁(δt²)</code>. That is, Eq. (16) introduces the same order of approximation as in the semi-implicit method in Eq. (11). Up to this point we have made no approximations but we instead propagated the <code>O(⋅)</code> leading terms. Therefore the equalities in the equations above are exact. To obtain an approximate time stepping scheme, we drop <code>O₇(δt²)</code> (we neglect it) in Eq. (16) to arrive to a first order scheme: </p><pre class="fragment">  (17)  M(qˢ) vˢ⁺¹ = M(qˢ) vˢ +
                     δt [τˢ + Jₙᵀ(qˢ) fₙ(qˢ,vˢ) + Jₜᵀ(qˢ) fₜ(vˢ⁺¹)]
</pre><p> Therefore, with the scheme in Eq. (17) we are able to decouple the computation of (compliant) normal forces from that of friction forces. A very important feature of this scheme however, is the explicit nature (in the velocities v) of the term associated with the normal forces (usually including dissipation in the normal direction), which will become unstable for a sufficiently large time step. However, for most applications in practice, the stability of the scheme is mostly determined by the explicit update of normal forces with positions, that is, Eq. (17) is explicit in positions through the normal forces <code>fₙ(qˢ, vˢ)</code>. For many common applications, the explicit dependence of <code>τˢ(tˢ, qˢ, vˢ)</code> on the previous time step velocities <code>vˢ</code> determines the overall stability of the scheme, since this term can include velocity dependent contributions such as control forces and dampers. Notice that Eq. (12) introduces an expansion of <code>fₙ</code> with an order of approximation consistent with the first order scheme as needed. Therefore, it propagates into a <code>O(δt²)</code> term exactly as needed in Eq. (16).</p>
<h2>References</h2>
<ul>
<li><a class="anchor" id="castro_etal_2019"></a>[Castro et al., 2019] Castro, A.M, Qu, A., Kuppuswamy, N., Alspach, A., Sherman, M.A., 2019. A Transition-Aware Method for the Simulation of Compliant Contact with Regularized Friction. arXiv:1909.05700 [cs.RO].</li>
<li><a class="anchor" id="uchida_etal_2015"></a>Uchida, T.K., Sherman, M.A. and Delp, S.L., 2015. Making a meaningful impact: modelling simultaneous frictional collisions in spatial multibody systems. Proc. R. Soc. A, 471(2177), p.20140859.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Authors</dt><dd>Alejandro Castro (2018) Original author. </dd>
<dd>
Michael Sherman, Evan Drumwright (2018) Original PR #8925 reviewers. </dd>
<dd>
Drake team (see <a href="https://drake.mit.edu/credits">https://drake.mit.edu/credits</a>). </dd></dl>
</div>
<p><code>#include &lt;drake/multibody/plant/tamsi_solver.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8c6125a41db505a5d9caf8b5d93c591e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#a8c6125a41db505a5d9caf8b5d93c591e">TamsiSolver</a> (<a class="el" href="classint.html">int</a> nv)</td></tr>
<tr class="memdesc:a8c6125a41db505a5d9caf8b5d93c591e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates a solver for a problem with <code>nv</code> generalized velocities.  <a href="#a8c6125a41db505a5d9caf8b5d93c591e">More...</a><br /></td></tr>
<tr class="separator:a8c6125a41db505a5d9caf8b5d93c591e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c880a38bb3a6c5cddfe5f258db8ca7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#ac9c880a38bb3a6c5cddfe5f258db8ca7">SetOneWayCoupledProblemData</a> (<a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; M, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; Jn, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; Jt, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; p_star, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; fn, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; mu)</td></tr>
<tr class="memdesc:ac9c880a38bb3a6c5cddfe5f258db8ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets data for the problem to be solved as outlined by Eq.  <a href="#ac9c880a38bb3a6c5cddfe5f258db8ca7">More...</a><br /></td></tr>
<tr class="separator:ac9c880a38bb3a6c5cddfe5f258db8ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0dd5fb64de38e8f5fde32e1b19f862"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#a2f0dd5fb64de38e8f5fde32e1b19f862">SetTwoWayCoupledProblemData</a> (<a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; M, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; Jn, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; Jt, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; p_star, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; fn0, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; stiffness, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; dissipation, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; mu)</td></tr>
<tr class="memdesc:a2f0dd5fb64de38e8f5fde32e1b19f862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the problem data to solve the problem outlined in Eq.  <a href="#a2f0dd5fb64de38e8f5fde32e1b19f862">More...</a><br /></td></tr>
<tr class="separator:a2f0dd5fb64de38e8f5fde32e1b19f862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032d564905879232190e6b62afd0b8d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#a6144c2c8d4494bcb283f3f9e5841bfd2">TamsiSolverResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#a032d564905879232190e6b62afd0b8d0">SolveWithGuess</a> (double dt, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;v_guess) const</td></tr>
<tr class="memdesc:a032d564905879232190e6b62afd0b8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an initial guess <code>v_guess</code>, this method uses a Newton-Raphson iteration to find a solution for the generalized velocities satisfying either Eq.  <a href="#a032d564905879232190e6b62afd0b8d0">More...</a><br /></td></tr>
<tr class="separator:a032d564905879232190e6b62afd0b8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa382d32efc92d697a3eed91e4846d5de"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdrake_1_1multibody_1_1_tamsi_solver_iteration_stats.html">TamsiSolverIterationStats</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#aa382d32efc92d697a3eed91e4846d5de">get_iteration_statistics</a> () const</td></tr>
<tr class="memdesc:aa382d32efc92d697a3eed91e4846d5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns statistics recorded during the last call to <a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#a032d564905879232190e6b62afd0b8d0" title="Given an initial guess v_guess, this method uses a Newton-Raphson iteration to find a solution for th...">SolveWithGuess()</a>.  <a href="#aa382d32efc92d697a3eed91e4846d5de">More...</a><br /></td></tr>
<tr class="separator:aa382d32efc92d697a3eed91e4846d5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0757e26068ec7a7431656263668124"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdrake_1_1multibody_1_1_tamsi_solver_parameters.html">TamsiSolverParameters</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#a2b0757e26068ec7a7431656263668124">get_solver_parameters</a> () const</td></tr>
<tr class="memdesc:a2b0757e26068ec7a7431656263668124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current set of parameters controlling the iteration process.  <a href="#a2b0757e26068ec7a7431656263668124">More...</a><br /></td></tr>
<tr class="separator:a2b0757e26068ec7a7431656263668124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72660d4b210220b673a299c606992f00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#a72660d4b210220b673a299c606992f00">set_solver_parameters</a> (const <a class="el" href="structdrake_1_1multibody_1_1_tamsi_solver_parameters.html">TamsiSolverParameters</a> &amp;parameters)</td></tr>
<tr class="memdesc:a72660d4b210220b673a299c606992f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the parameters to be used by the solver.  <a href="#a72660d4b210220b673a299c606992f00">More...</a><br /></td></tr>
<tr class="separator:a72660d4b210220b673a299c606992f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:ad5d558d0bc7ccbe0202ccd40e1929815"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#ad5d558d0bc7ccbe0202ccd40e1929815">TamsiSolver</a> (const <a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html">TamsiSolver</a> &amp;)=delete</td></tr>
<tr class="separator:ad5d558d0bc7ccbe0202ccd40e1929815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac71c044c74b654a651fdae15c82c20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html">TamsiSolver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#a2ac71c044c74b654a651fdae15c82c20">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html">TamsiSolver</a> &amp;)=delete</td></tr>
<tr class="separator:a2ac71c044c74b654a651fdae15c82c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3d2411402ef5b22576cabf83a2072d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#a3b3d2411402ef5b22576cabf83a2072d">TamsiSolver</a> (<a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html">TamsiSolver</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a3b3d2411402ef5b22576cabf83a2072d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341180b650aeddec340037d98a48e2cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html">TamsiSolver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#a341180b650aeddec340037d98a48e2cf">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html">TamsiSolver</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a341180b650aeddec340037d98a48e2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Retrieving the solution</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="retrieving_the_solution"></a> This methods allow to retrieve the solution stored in the solver after the last call to <a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#a032d564905879232190e6b62afd0b8d0" title="Given an initial guess v_guess, this method uses a Newton-Raphson iteration to find a solution for th...">SolveWithGuess()</a>. </p>
</div></td></tr>
<tr class="memitem:ae94664023bc80f10ce6466de6beff7f4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#ae94664023bc80f10ce6466de6beff7f4">get_generalized_friction_forces</a> () const</td></tr>
<tr class="memdesc:ae94664023bc80f10ce6466de6beff7f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the most recent vector of generalized friction forces.  <a href="#ae94664023bc80f10ce6466de6beff7f4">More...</a><br /></td></tr>
<tr class="separator:ae94664023bc80f10ce6466de6beff7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d05c18f9cacfd93b5318d46ee85ff06"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#a9d05c18f9cacfd93b5318d46ee85ff06">get_normal_velocities</a> () const</td></tr>
<tr class="memdesc:a9d05c18f9cacfd93b5318d46ee85ff06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the most recent solution vector for normal separation velocities.  <a href="#a9d05c18f9cacfd93b5318d46ee85ff06">More...</a><br /></td></tr>
<tr class="separator:a9d05c18f9cacfd93b5318d46ee85ff06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2fca834884c6abf9c0351c74730787"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#aed2fca834884c6abf9c0351c74730787">get_generalized_contact_forces</a> () const</td></tr>
<tr class="memdesc:aed2fca834884c6abf9c0351c74730787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the most recent vector of generalized contact forces, including both friction and normal forces.  <a href="#aed2fca834884c6abf9c0351c74730787">More...</a><br /></td></tr>
<tr class="separator:aed2fca834884c6abf9c0351c74730787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac196523cef3bf653c3c198614dd05f50"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#ac196523cef3bf653c3c198614dd05f50">get_tangential_velocities</a> () const</td></tr>
<tr class="memdesc:ac196523cef3bf653c3c198614dd05f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the most recent vector of tangential forces.  <a href="#ac196523cef3bf653c3c198614dd05f50">More...</a><br /></td></tr>
<tr class="separator:ac196523cef3bf653c3c198614dd05f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc28db7866462019de30bcc4b7c2508"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#a2fc28db7866462019de30bcc4b7c2508">get_generalized_velocities</a> () const</td></tr>
<tr class="memdesc:a2fc28db7866462019de30bcc4b7c2508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the most recent vector of generalized velocities.  <a href="#a2fc28db7866462019de30bcc4b7c2508">More...</a><br /></td></tr>
<tr class="separator:a2fc28db7866462019de30bcc4b7c2508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980a0a0b6cdcae51a11d2d8b6e4fc2af"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#a980a0a0b6cdcae51a11d2d8b6e4fc2af">get_normal_forces</a> () const</td></tr>
<tr class="memdesc:a980a0a0b6cdcae51a11d2d8b6e4fc2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the most recent vector of (repulsive) forces in the normal direction.  <a href="#a980a0a0b6cdcae51a11d2d8b6e4fc2af">More...</a><br /></td></tr>
<tr class="separator:a980a0a0b6cdcae51a11d2d8b6e4fc2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf39c5d5444717701cd76801700fe812"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#adf39c5d5444717701cd76801700fe812">get_friction_forces</a> () const</td></tr>
<tr class="memdesc:adf39c5d5444717701cd76801700fe812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the most recent vector of friction forces.  <a href="#adf39c5d5444717701cd76801700fe812">More...</a><br /></td></tr>
<tr class="separator:adf39c5d5444717701cd76801700fe812"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a4be23a2b9c291aeb80deed52cf42ba6d"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#a4be23a2b9c291aeb80deed52cf42ba6d">TamsiSolverTester</a></td></tr>
<tr class="separator:a4be23a2b9c291aeb80deed52cf42ba6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad5d558d0bc7ccbe0202ccd40e1929815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d558d0bc7ccbe0202ccd40e1929815">&#9670;&nbsp;</a></span>TamsiSolver() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html">TamsiSolver</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html">TamsiSolver</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b3d2411402ef5b22576cabf83a2072d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b3d2411402ef5b22576cabf83a2072d">&#9670;&nbsp;</a></span>TamsiSolver() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html">TamsiSolver</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html">TamsiSolver</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c6125a41db505a5d9caf8b5d93c591e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6125a41db505a5d9caf8b5d93c591e">&#9670;&nbsp;</a></span>TamsiSolver() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html">TamsiSolver</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>nv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instantiates a solver for a problem with <code>nv</code> generalized velocities. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if nv is non-positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adf39c5d5444717701cd76801700fe812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf39c5d5444717701cd76801700fe812">&#9670;&nbsp;</a></span>get_friction_forces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; get_friction_forces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the most recent vector of friction forces. </p>
<p>These friction forces are defined in accordance to the tangential velocities Jacobian Jₜ as documented in <a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#tamsi_class_intro">this class's documentation</a>. </p>

</div>
</div>
<a id="aed2fca834884c6abf9c0351c74730787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2fca834884c6abf9c0351c74730787">&#9670;&nbsp;</a></span>get_generalized_contact_forces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt;&amp; get_generalized_contact_forces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the most recent vector of generalized contact forces, including both friction and normal forces. </p>

</div>
</div>
<a id="ae94664023bc80f10ce6466de6beff7f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94664023bc80f10ce6466de6beff7f4">&#9670;&nbsp;</a></span>get_generalized_friction_forces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt;&amp; get_generalized_friction_forces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the most recent vector of generalized friction forces. </p>

</div>
</div>
<a id="a2fc28db7866462019de30bcc4b7c2508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc28db7866462019de30bcc4b7c2508">&#9670;&nbsp;</a></span>get_generalized_velocities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt;&amp; get_generalized_velocities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the most recent vector of generalized velocities. </p>

</div>
</div>
<a id="aa382d32efc92d697a3eed91e4846d5de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa382d32efc92d697a3eed91e4846d5de">&#9670;&nbsp;</a></span>get_iteration_statistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdrake_1_1multibody_1_1_tamsi_solver_iteration_stats.html">TamsiSolverIterationStats</a>&amp; get_iteration_statistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns statistics recorded during the last call to <a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#a032d564905879232190e6b62afd0b8d0" title="Given an initial guess v_guess, this method uses a Newton-Raphson iteration to find a solution for th...">SolveWithGuess()</a>. </p>
<p>See IterationStats for details. </p>

</div>
</div>
<a id="a980a0a0b6cdcae51a11d2d8b6e4fc2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980a0a0b6cdcae51a11d2d8b6e4fc2af">&#9670;&nbsp;</a></span>get_normal_forces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; get_normal_forces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the most recent vector of (repulsive) forces in the normal direction. </p>
<p>That is, the normal force is positive when the bodies push each other apart. Otherwise the normal force is zero, since contact forces can only be repulsive. </p>

</div>
</div>
<a id="a9d05c18f9cacfd93b5318d46ee85ff06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d05c18f9cacfd93b5318d46ee85ff06">&#9670;&nbsp;</a></span>get_normal_velocities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; get_normal_velocities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the most recent solution vector for normal separation velocities. </p>
<p>This method returns an <code>Eigen::VectorBlock</code> referencing a vector of size <code>nc</code>. </p>

</div>
</div>
<a id="a2b0757e26068ec7a7431656263668124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0757e26068ec7a7431656263668124">&#9670;&nbsp;</a></span>get_solver_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdrake_1_1multibody_1_1_tamsi_solver_parameters.html">TamsiSolverParameters</a>&amp; get_solver_parameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current set of parameters controlling the iteration process. </p>
<p>See Parameters for details. </p>

</div>
</div>
<a id="ac196523cef3bf653c3c198614dd05f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac196523cef3bf653c3c198614dd05f50">&#9670;&nbsp;</a></span>get_tangential_velocities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; get_tangential_velocities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the most recent vector of tangential forces. </p>
<p>This method returns an <code>Eigen::VectorBlock</code> referencing a vector of size <code>nc</code>. </p>

</div>
</div>
<a id="a341180b650aeddec340037d98a48e2cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341180b650aeddec340037d98a48e2cf">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html">TamsiSolver</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html">TamsiSolver</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ac71c044c74b654a651fdae15c82c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac71c044c74b654a651fdae15c82c20">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html">TamsiSolver</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html">TamsiSolver</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a72660d4b210220b673a299c606992f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72660d4b210220b673a299c606992f00">&#9670;&nbsp;</a></span>set_solver_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_solver_parameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1multibody_1_1_tamsi_solver_parameters.html">TamsiSolverParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the parameters to be used by the solver. </p>
<p>See Parameters for details. </p>

</div>
</div>
<a id="ac9c880a38bb3a6c5cddfe5f258db8ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c880a38bb3a6c5cddfe5f258db8ca7">&#9670;&nbsp;</a></span>SetOneWayCoupledProblemData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetOneWayCoupledProblemData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Jn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Jt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>p_star</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets data for the problem to be solved as outlined by Eq. </p>
<p>(3) in this class's documentation: </p><pre>
  (3)  M v = p* + δt Jₙᵀ fₙ +  δt Jₜᵀ fₜ(v)
</pre><p> Refer to this class's documentation for further details on the structure of the problem and the solution strategy. In the documented parameters below, <code>nv</code> is the number of generalized velocities and <code>nc</code> is the number of contact points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>The mass matrix of the system, of size <code>nv x nv</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Jn</td><td>The normal separation velocities Jacobian, of size <code>nc x nv</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Jt</td><td>The tangential velocities Jacobian, of size <code>2nc x nv</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_star</td><td>The generalized momentum the system would have at <code>s + 1</code> if contact forces were zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>A vector of size <code>nc</code> containing the normal force at each contact point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mu</td><td>A vector of size <code>nc</code> containing the friction coefficient at each contact point. The solver makes no distinction between static and dynamic coefficients of friction or, similarly, the solver assumes the static and dynamic coefficients of friction are the same.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This method stores constant references to the matrices and vectors passed as arguments. Therefore<ol type="1">
<li>they must outlive this class and,</li>
<li>changes to the problem data invalidate any solution performed by this solver. In such a case, <a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#ac9c880a38bb3a6c5cddfe5f258db8ca7" title="Sets data for the problem to be solved as outlined by Eq.">SetOneWayCoupledProblemData()</a> and <a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#a032d564905879232190e6b62afd0b8d0" title="Given an initial guess v_guess, this method uses a Newton-Raphson iteration to find a solution for th...">SolveWithGuess()</a> must be invoked again.</li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if any of the data pointers are nullptr. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the problem data sizes are not consistent as described above. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#a2f0dd5fb64de38e8f5fde32e1b19f862" title="Sets the problem data to solve the problem outlined in Eq.">SetTwoWayCoupledProblemData()</a> was ever called on <code>this</code> solver. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f0dd5fb64de38e8f5fde32e1b19f862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0dd5fb64de38e8f5fde32e1b19f862">&#9670;&nbsp;</a></span>SetTwoWayCoupledProblemData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetTwoWayCoupledProblemData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Jn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Jt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>p_star</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>fn0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>stiffness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>dissipation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the problem data to solve the problem outlined in Eq. </p>
<p>(10) in this class's documentation using a two-way coupled approach: </p><pre>
  (10)  M(qˢ) vˢ⁺¹ = p* + δt [Jₙᵀ(qˢ) fₙ(vˢ⁺¹) + Jₜᵀ(qˢ) fₜ(vˢ⁺¹)]
</pre><p> Refer to this class's documentation for further details on the structure of the problem and the solution strategy. In the documented parameters below, <code>nv</code> is the number of generalized velocities and <code>nc</code> is the number of contact points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>The mass matrix of the system, of size <code>nv x nv</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Jn</td><td>The normal separation velocities Jacobian, of size <code>nc x nv</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Jt</td><td>The tangential velocities Jacobian, of size <code>2nc x nv</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_star</td><td>The generalized momentum the system would have at <code>n + 1</code> if contact forces were zero. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn0</td><td>Normal force at the previous time step. Always positive since bodies cannot attract each other. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stiffness</td><td>A vector of size <code>nc</code> storing at each ith entry the stiffness coefficient for the ith contact pair. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dissipation</td><td>A vector of size <code>nc</code> storing at each ith entry the dissipation coefficient for the ith contact pair. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mu</td><td>A vector of size <code>nc</code> containing the friction coefficient at each contact point. The solver makes no distinction between static and dynamic coefficients of friction or, similarly, the solver assumes the static and dynamic coefficients of friction are the same.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This method stores constant references to the matrices and vectors passed as arguments. Therefore<ol type="1">
<li>they must outlive this class and,</li>
<li>changes to the problem data invalidate any solution performed by this solver. In such a case, <a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#ac9c880a38bb3a6c5cddfe5f258db8ca7" title="Sets data for the problem to be solved as outlined by Eq.">SetOneWayCoupledProblemData()</a> and <a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#a032d564905879232190e6b62afd0b8d0" title="Given an initial guess v_guess, this method uses a Newton-Raphson iteration to find a solution for th...">SolveWithGuess()</a> must be invoked again.</li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if any of the data pointers are nullptr. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the problem data sizes are not consistent as described above. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#ac9c880a38bb3a6c5cddfe5f258db8ca7" title="Sets data for the problem to be solved as outlined by Eq.">SetOneWayCoupledProblemData()</a> was ever called on <code>this</code> solver. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a032d564905879232190e6b62afd0b8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032d564905879232190e6b62afd0b8d0">&#9670;&nbsp;</a></span>SolveWithGuess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#a6144c2c8d4494bcb283f3f9e5841bfd2">TamsiSolverResult</a> SolveWithGuess </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v_guess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an initial guess <code>v_guess</code>, this method uses a Newton-Raphson iteration to find a solution for the generalized velocities satisfying either Eq. </p>
<p>(3) when one-way coupling is used or Eq. (10) when two-way coupling is used. See this class's documentation for further details. To retrieve the solution, please refer to <a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#retrieving_the_solution">retrieving_the_solution</a>. </p><dl class="section return"><dt>Returns</dt><dd>kSuccess if the iteration converges. All other values of TamsiSolverResult report different failure modes. Uses <code>this</code> solver accessors to retrieve the last computed solution. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Always verify that the return value indicates success before retrieving the computed solution.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>The time step used advance the solution in time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v_guess</td><td>The initial guess used in by the Newton-Raphson iteration. Typically, the previous time step velocities.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <code>v_guess</code> is not of size <code>nv</code>, the number of generalized velocities specified at construction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a4be23a2b9c291aeb80deed52cf42ba6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be23a2b9c291aeb80deed52cf42ba6d">&#9670;&nbsp;</a></span>TamsiSolverTester</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class TamsiSolverTester</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/multibody/plant/<a class="el" href="tamsi__solver_8h.html">tamsi_solver.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html">TamsiSolver</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
