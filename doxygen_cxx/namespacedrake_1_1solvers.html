<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake::solvers Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespacedrake_1_1solvers.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">drake::solvers Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:AddRotationMatrixBoxSphereIntersectionReturn" id="r_AddRotationMatrixBoxSphereIntersectionReturn"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_add_rotation_matrix_box_sphere_intersection_return.html">AddRotationMatrixBoxSphereIntersectionReturn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some of the newly added variables in function AddRotationMatrixBoxSphereIntersectionMilpConstraints.  <a href="structdrake_1_1solvers_1_1_add_rotation_matrix_box_sphere_intersection_return.html#details">More...</a><br /></td></tr>
<tr class="memitem:AugmentedLagrangianNonsmooth" id="r_AugmentedLagrangianNonsmooth"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_augmented_lagrangian_nonsmooth.html">AugmentedLagrangianNonsmooth</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the augmented Lagrangian (AL) of a given mathematical program.  <a href="classdrake_1_1solvers_1_1_augmented_lagrangian_nonsmooth.html#details">More...</a><br /></td></tr>
<tr class="memitem:AugmentedLagrangianSmooth" id="r_AugmentedLagrangianSmooth"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_augmented_lagrangian_smooth.html">AugmentedLagrangianSmooth</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the augmented Lagrangian (AL) of a given mathematical program.  <a href="classdrake_1_1solvers_1_1_augmented_lagrangian_smooth.html#details">More...</a><br /></td></tr>
<tr class="memitem:Binding" id="r_Binding"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A binding on constraint type C is a mapping of the decision variables onto the inputs of C.  <a href="classdrake_1_1solvers_1_1_binding.html#details">More...</a><br /></td></tr>
<tr class="memitem:Bound" id="r_Bound"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_bound.html">Bound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the lower and upper bound of a variable.  <a href="structdrake_1_1solvers_1_1_bound.html#details">More...</a><br /></td></tr>
<tr class="memitem:BoundingBoxConstraint" id="r_BoundingBoxConstraint"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a constraint of the form \( lb &lt;= x &lt;= ub \).  <a href="classdrake_1_1solvers_1_1_bounding_box_constraint.html#details">More...</a><br /></td></tr>
<tr class="memitem:ClarabelSolver" id="r_ClarabelSolver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_clarabel_solver.html">ClarabelSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface to wrap Clarabel <a href="https://github.com/oxfordcontrol/Clarabel.cpp">https://github.com/oxfordcontrol/Clarabel.cpp</a>.  <a href="classdrake_1_1solvers_1_1_clarabel_solver.html#details">More...</a><br /></td></tr>
<tr class="memitem:ClarabelSolverDetails" id="r_ClarabelSolverDetails"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_clarabel_solver_details.html">ClarabelSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Clarabel solver details after calling the <a class="el" href="#ae34d0e7febfca6328561574df6ce91d5" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_clarabel_solver_details.html#details">More...</a><br /></td></tr>
<tr class="memitem:ClpSolver" id="r_ClpSolver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_clp_solver.html">ClpSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper to call CLP using Drake's <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <a href="classdrake_1_1solvers_1_1_clp_solver.html#details">More...</a><br /></td></tr>
<tr class="memitem:ClpSolverDetails" id="r_ClpSolverDetails"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_clp_solver_details.html">ClpSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CLP solver details after calling <a class="el" href="#ae34d0e7febfca6328561574df6ce91d5" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_clp_solver_details.html#details">More...</a><br /></td></tr>
<tr class="memitem:Constraint" id="r_Constraint"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constraint is a function + lower and upper bounds.  <a href="classdrake_1_1solvers_1_1_constraint.html#details">More...</a><br /></td></tr>
<tr class="memitem:Cost" id="r_Cost"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an abstract base for all costs.  <a href="classdrake_1_1solvers_1_1_cost.html#details">More...</a><br /></td></tr>
<tr class="memitem:CsdpSolver" id="r_CsdpSolver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_csdp_solver.html">CsdpSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap CSDP solver such that it can solve a <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">drake::solvers::MathematicalProgram</a>.  <a href="classdrake_1_1solvers_1_1_csdp_solver.html#details">More...</a><br /></td></tr>
<tr class="memitem:CsdpSolverDetails" id="r_CsdpSolverDetails"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_csdp_solver_details.html">CsdpSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CSDP solver details after calling <a class="el" href="#ae34d0e7febfca6328561574df6ce91d5" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_csdp_solver_details.html#details">More...</a><br /></td></tr>
<tr class="memitem:EqualityConstrainedQPSolver" id="r_EqualityConstrainedQPSolver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_equality_constrained_q_p_solver.html">EqualityConstrainedQPSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a quadratic program with equality constraint.  <a href="classdrake_1_1solvers_1_1_equality_constrained_q_p_solver.html#details">More...</a><br /></td></tr>
<tr class="memitem:EvaluatorBase" id="r_EvaluatorBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_evaluator_base.html">EvaluatorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an abstract interface to represent an expression, mapping a fixed or dynamic number of inputs to a fixed number of outputs, that may be evaluated on a scalar type of double or <a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854" title="A scalar type that performs automatic differentiation.">AutoDiffXd</a>.  <a href="classdrake_1_1solvers_1_1_evaluator_base.html#details">More...</a><br /></td></tr>
<tr class="memitem:EvaluatorConstraint" id="r_EvaluatorConstraint"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_evaluator_constraint.html">EvaluatorConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constraint that may be specified using another (potentially nonlinear) evaluator.  <a href="classdrake_1_1solvers_1_1_evaluator_constraint.html#details">More...</a><br /></td></tr>
<tr class="memitem:EvaluatorCost" id="r_EvaluatorCost"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_evaluator_cost.html">EvaluatorCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cost that may be specified using another (potentially nonlinear) evaluator.  <a href="classdrake_1_1solvers_1_1_evaluator_cost.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExponentialConeConstraint" id="r_ExponentialConeConstraint"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html">ExponentialConeConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exponential cone constraint is a special type of convex cone constraint.  <a href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionConstraint" id="r_ExpressionConstraint"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_expression_constraint.html">ExpressionConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a generic (potentially nonlinear) constraint represented as a vector of symbolic Expression.  <a href="classdrake_1_1solvers_1_1_expression_constraint.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpressionCost" id="r_ExpressionCost"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_expression_cost.html">ExpressionCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a generic (potentially nonlinear) cost represented as a symbolic Expression.  <a href="classdrake_1_1solvers_1_1_expression_cost.html#details">More...</a><br /></td></tr>
<tr class="memitem:FunctionEvaluator" id="r_FunctionEvaluator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_function_evaluator.html">FunctionEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An evaluator that may be specified using a callable object.  <a href="classdrake_1_1solvers_1_1_function_evaluator.html#details">More...</a><br /></td></tr>
<tr class="memitem:GurobiSolver" id="r_GurobiSolver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_gurobi_solver.html">GurobiSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html" title="Interface used by implementations of individual solvers.">SolverInterface</a> for the commercially-licensed Gurobi solver (<a href="https://www.gurobi.com/">https://www.gurobi.com/</a>).  <a href="classdrake_1_1solvers_1_1_gurobi_solver.html#details">More...</a><br /></td></tr>
<tr class="memitem:GurobiSolverDetails" id="r_GurobiSolverDetails"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_gurobi_solver_details.html">GurobiSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Gurobi solver details after calling <a class="el" href="#ae34d0e7febfca6328561574df6ce91d5" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_gurobi_solver_details.html#details">More...</a><br /></td></tr>
<tr class="memitem:IpoptSolver" id="r_IpoptSolver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_ipopt_solver.html">IpoptSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper to call <a href="https://coin-or.github.io/Ipopt/">Ipopt</a> using Drake's <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <a href="classdrake_1_1solvers_1_1_ipopt_solver.html#details">More...</a><br /></td></tr>
<tr class="memitem:IpoptSolverDetails" id="r_IpoptSolverDetails"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_ipopt_solver_details.html">IpoptSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Ipopt solver details after calling <a class="el" href="#ae34d0e7febfca6328561574df6ce91d5" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_ipopt_solver_details.html#details">More...</a><br /></td></tr>
<tr class="memitem:L1NormCost" id="r_L1NormCost"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_l1_norm_cost.html">L1NormCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a cost of the form ‖Ax + b‖₁.  <a href="classdrake_1_1solvers_1_1_l1_norm_cost.html#details">More...</a><br /></td></tr>
<tr class="memitem:L2NormCost" id="r_L2NormCost"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a cost of the form ‖Ax + b‖₂.  <a href="classdrake_1_1solvers_1_1_l2_norm_cost.html#details">More...</a><br /></td></tr>
<tr class="memitem:LinearComplementarityConstraint" id="r_LinearComplementarityConstraint"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a constraint of the form:  <a href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html#details">More...</a><br /></td></tr>
<tr class="memitem:LinearConstraint" id="r_LinearConstraint"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a constraint of the form \( lb &lt;= Ax &lt;= ub \).  <a href="classdrake_1_1solvers_1_1_linear_constraint.html#details">More...</a><br /></td></tr>
<tr class="memitem:LinearCost" id="r_LinearCost"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a cost of the form.  <a href="classdrake_1_1solvers_1_1_linear_cost.html#details">More...</a><br /></td></tr>
<tr class="memitem:LinearEqualityConstraint" id="r_LinearEqualityConstraint"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a constraint of the form \( Ax = b \).  <a href="classdrake_1_1solvers_1_1_linear_equality_constraint.html#details">More...</a><br /></td></tr>
<tr class="memitem:LinearMatrixInequalityConstraint" id="r_LinearMatrixInequalityConstraint"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose the matrix inequality constraint on variable x  .  <a href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html#details">More...</a><br /></td></tr>
<tr class="memitem:LinearSystemSolver" id="r_LinearSystemSolver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_linear_system_solver.html">LinearSystemSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the least-square solution to the linear system A * x = b.  <a href="classdrake_1_1solvers_1_1_linear_system_solver.html#details">More...</a><br /></td></tr>
<tr class="memitem:LInfNormCost" id="r_LInfNormCost"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_l_inf_norm_cost.html">LInfNormCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a cost of the form ‖Ax + b‖∞.  <a href="classdrake_1_1solvers_1_1_l_inf_norm_cost.html#details">More...</a><br /></td></tr>
<tr class="memitem:LogarithmicSos2NewBinaryVariables" id="r_LogarithmicSos2NewBinaryVariables"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_logarithmic_sos2_new_binary_variables.html">LogarithmicSos2NewBinaryVariables</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the new binary variables in the compile time, for Special Ordered Set of type 2 (SOS2) constraint.  <a href="structdrake_1_1solvers_1_1_logarithmic_sos2_new_binary_variables.html#details">More...</a><br /></td></tr>
<tr class="memitem:LogarithmicSos2NewBinaryVariables_3C_20Eigen_3A_3ADynamic_20_3E" id="r_LogarithmicSos2NewBinaryVariables_3C_20Eigen_3A_3ADynamic_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>LogarithmicSos2NewBinaryVariables&lt; Eigen::Dynamic &gt;</b></td></tr>
<tr class="memitem:LorentzConeConstraint" id="r_LorentzConeConstraint"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraining the linear expression \( z=Ax+b \) lies within the Lorentz cone.  <a href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#details">More...</a><br /></td></tr>
<tr class="memitem:MathematicalProgram" id="r_MathematicalProgram"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> stores the decision variables, the constraints and costs of an optimization problem.  <a href="classdrake_1_1solvers_1_1_mathematical_program.html#details">More...</a><br /></td></tr>
<tr class="memitem:MathematicalProgramResult" id="r_MathematicalProgramResult"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result returned by MathematicalProgram::Solve().  <a href="classdrake_1_1solvers_1_1_mathematical_program_result.html#details">More...</a><br /></td></tr>
<tr class="memitem:MinimumValueLowerBoundConstraint" id="r_MinimumValueLowerBoundConstraint"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_minimum_value_lower_bound_constraint.html">MinimumValueLowerBoundConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrain min(v) &gt;= lb where v=f(x).  <a href="classdrake_1_1solvers_1_1_minimum_value_lower_bound_constraint.html#details">More...</a><br /></td></tr>
<tr class="memitem:MinimumValueUpperBoundConstraint" id="r_MinimumValueUpperBoundConstraint"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_minimum_value_upper_bound_constraint.html">MinimumValueUpperBoundConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrain min(v) &lt;= ub where v=f(x).  <a href="classdrake_1_1solvers_1_1_minimum_value_upper_bound_constraint.html#details">More...</a><br /></td></tr>
<tr class="memitem:MixedIntegerBranchAndBound" id="r_MixedIntegerBranchAndBound"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_branch_and_bound.html">MixedIntegerBranchAndBound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a mixed-integer optimization problem (MIP) (or more accurately, mixed binary problem), solve this problem through branch-and-bound process.  <a href="classdrake_1_1solvers_1_1_mixed_integer_branch_and_bound.html#details">More...</a><br /></td></tr>
<tr class="memitem:MixedIntegerBranchAndBoundNode" id="r_MixedIntegerBranchAndBoundNode"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_branch_and_bound_node.html">MixedIntegerBranchAndBoundNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node in the branch-and-bound (bnb) tree.  <a href="classdrake_1_1solvers_1_1_mixed_integer_branch_and_bound_node.html#details">More...</a><br /></td></tr>
<tr class="memitem:MixedIntegerRotationConstraintGenerator" id="r_MixedIntegerRotationConstraintGenerator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_rotation_constraint_generator.html">MixedIntegerRotationConstraintGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">We relax the non-convex SO(3) constraint on rotation matrix R to mixed-integer linear constraints.  <a href="classdrake_1_1solvers_1_1_mixed_integer_rotation_constraint_generator.html#details">More...</a><br /></td></tr>
<tr class="memitem:MobyLcpSolver" id="r_MobyLcpSolver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_lcp_solver.html">MobyLcpSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for solving Linear Complementarity Problems (LCPs).  <a href="classdrake_1_1solvers_1_1_moby_lcp_solver.html#details">More...</a><br /></td></tr>
<tr class="memitem:MobyLcpSolverId" id="r_MobyLcpSolverId"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_lcp_solver_id.html">MobyLcpSolverId</a></td></tr>
<tr class="memitem:MosekSolver" id="r_MosekSolver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mosek_solver.html">MosekSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html" title="Interface used by implementations of individual solvers.">SolverInterface</a> for the commercially-licensed MOSEK (TM) solver (<a href="https://www.mosek.com/">https://www.mosek.com/</a>).  <a href="classdrake_1_1solvers_1_1_mosek_solver.html#details">More...</a><br /></td></tr>
<tr class="memitem:MosekSolverDetails" id="r_MosekSolverDetails"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_mosek_solver_details.html">MosekSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MOSEK<a href="/tm.html">™</a> solver details after calling <a class="el" href="#ae34d0e7febfca6328561574df6ce91d5" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_mosek_solver_details.html#details">More...</a><br /></td></tr>
<tr class="memitem:NewSymmetricVariableNames" id="r_NewSymmetricVariableNames"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_new_symmetric_variable_names.html">NewSymmetricVariableNames</a></td></tr>
<tr class="memitem:NewVariableNames" id="r_NewVariableNames"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_new_variable_names.html">NewVariableNames</a></td></tr>
<tr class="memitem:NewVariableNames_3C_20Eigen_3A_3ADynamic_20_3E" id="r_NewVariableNames_3C_20Eigen_3A_3ADynamic_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>NewVariableNames&lt; Eigen::Dynamic &gt;</b></td></tr>
<tr class="memitem:NewVariableNames_3C_20Rows_2C_20Cols_20_3E" id="r_NewVariableNames_3C_20Rows_2C_20Cols_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_new_variable_names_3_01_rows_00_01_cols_01_4.html">NewVariableNames&lt; Rows, Cols &gt;</a></td></tr>
<tr class="memitem:NewVariableNames_3C_20Size_20_3E" id="r_NewVariableNames_3C_20Size_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_new_variable_names_3_01_size_01_4.html">NewVariableNames&lt; Size &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the names for the newly added variables.  <a href="structdrake_1_1solvers_1_1_new_variable_names_3_01_size_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:NloptSolver" id="r_NloptSolver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_nlopt_solver.html">NloptSolver</a></td></tr>
<tr class="memitem:NloptSolverDetails" id="r_NloptSolverDetails"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_nlopt_solver_details.html">NloptSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The NLopt solver details after calling <a class="el" href="#ae34d0e7febfca6328561574df6ce91d5" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_nlopt_solver_details.html#details">More...</a><br /></td></tr>
<tr class="memitem:OsqpSolver" id="r_OsqpSolver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_osqp_solver.html">OsqpSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper to call <a href="https://osqp.org/">OSQP</a> using Drake's <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <a href="classdrake_1_1solvers_1_1_osqp_solver.html#details">More...</a><br /></td></tr>
<tr class="memitem:OsqpSolverDetails" id="r_OsqpSolverDetails"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_osqp_solver_details.html">OsqpSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The OSQP solver details after calling <a class="el" href="#ae34d0e7febfca6328561574df6ce91d5" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_osqp_solver_details.html#details">More...</a><br /></td></tr>
<tr class="memitem:PerspectiveQuadraticCost" id="r_PerspectiveQuadraticCost"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_perspective_quadratic_cost.html">PerspectiveQuadraticCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If \( z = Ax + b,\) implements a cost of the form:  <a href="classdrake_1_1solvers_1_1_perspective_quadratic_cost.html#details">More...</a><br /></td></tr>
<tr class="memitem:PolynomialConstraint" id="r_PolynomialConstraint"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_polynomial_constraint.html">PolynomialConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constraint on the values of multivariate polynomials.  <a href="classdrake_1_1solvers_1_1_polynomial_constraint.html#details">More...</a><br /></td></tr>
<tr class="memitem:PolynomialCost" id="r_PolynomialCost"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_polynomial_cost.html">PolynomialCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a cost of the form P(x, y...) where P is a multivariate polynomial in x, y, ...  <a href="classdrake_1_1solvers_1_1_polynomial_cost.html#details">More...</a><br /></td></tr>
<tr class="memitem:PolynomialEvaluator" id="r_PolynomialEvaluator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_polynomial_evaluator.html">PolynomialEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements an evaluator of the form P(x, y...) where P is a multivariate polynomial in x, y, ...  <a href="classdrake_1_1solvers_1_1_polynomial_evaluator.html#details">More...</a><br /></td></tr>
<tr class="memitem:PositiveSemidefiniteConstraint" id="r_PositiveSemidefiniteConstraint"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a positive semidefinite constraint on a symmetric matrix S.  <a href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html#details">More...</a><br /></td></tr>
<tr class="memitem:ProjectedGradientDescentSolver" id="r_ProjectedGradientDescentSolver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_projected_gradient_descent_solver.html">ProjectedGradientDescentSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a nonlinear program via the projected gradient descent algorithm.  <a href="classdrake_1_1solvers_1_1_projected_gradient_descent_solver.html#details">More...</a><br /></td></tr>
<tr class="memitem:QuadraticConstraint" id="r_QuadraticConstraint"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_quadratic_constraint.html">QuadraticConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">lb ≤ .5 xᵀQx + bᵀx ≤ ub Without loss of generality, the class stores a symmetric matrix Q.  <a href="classdrake_1_1solvers_1_1_quadratic_constraint.html#details">More...</a><br /></td></tr>
<tr class="memitem:QuadraticCost" id="r_QuadraticCost"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a cost of the form.  <a href="classdrake_1_1solvers_1_1_quadratic_cost.html#details">More...</a><br /></td></tr>
<tr class="memitem:RotatedLorentzConeConstraint" id="r_RotatedLorentzConeConstraint"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraining that the linear expression \( z=Ax+b \) lies within rotated Lorentz cone.  <a href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html#details">More...</a><br /></td></tr>
<tr class="memitem:ScsSolver" id="r_ScsSolver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_scs_solver.html">ScsSolver</a></td></tr>
<tr class="memitem:ScsSolverDetails" id="r_ScsSolverDetails"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_scs_solver_details.html">ScsSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SCS solver details after calling <a class="el" href="#ae34d0e7febfca6328561574df6ce91d5" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_scs_solver_details.html#details">More...</a><br /></td></tr>
<tr class="memitem:SemidefiniteRelaxationOptions" id="r_SemidefiniteRelaxationOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_semidefinite_relaxation_options.html">SemidefiniteRelaxationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration options for the MakeSemidefiniteRelaxation.  <a href="structdrake_1_1solvers_1_1_semidefinite_relaxation_options.html#details">More...</a><br /></td></tr>
<tr class="memitem:SnoptSolver" id="r_SnoptSolver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_snopt_solver.html">SnoptSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html" title="Interface used by implementations of individual solvers.">SolverInterface</a> for the commercially-licensed SNOPT solver (<a href="https://ccom.ucsd.edu/~optimizers/solvers/snopt/">https://ccom.ucsd.edu/~optimizers/solvers/snopt/</a>).  <a href="classdrake_1_1solvers_1_1_snopt_solver.html#details">More...</a><br /></td></tr>
<tr class="memitem:SnoptSolverDetails" id="r_SnoptSolverDetails"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_snopt_solver_details.html">SnoptSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SNOPT solver details after calling <a class="el" href="#ae34d0e7febfca6328561574df6ce91d5" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_snopt_solver_details.html#details">More...</a><br /></td></tr>
<tr class="memitem:SolverBase" id="r_SolverBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_base.html">SolverBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class used by implementations of individual solvers.  <a href="classdrake_1_1solvers_1_1_solver_base.html#details">More...</a><br /></td></tr>
<tr class="memitem:SolverId" id="r_SolverId"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies a <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html" title="Interface used by implementations of individual solvers.">SolverInterface</a> implementation.  <a href="classdrake_1_1solvers_1_1_solver_id.html#details">More...</a><br /></td></tr>
<tr class="memitem:SolverInterface" id="r_SolverInterface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">SolverInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface used by implementations of individual solvers.  <a href="classdrake_1_1solvers_1_1_solver_interface.html#details">More...</a><br /></td></tr>
<tr class="memitem:SolverOptions" id="r_SolverOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores options for multiple solvers.  <a href="structdrake_1_1solvers_1_1_solver_options.html#details">More...</a><br /></td></tr>
<tr class="memitem:SolverTypeConverter" id="r_SolverTypeConverter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_type_converter.html">SolverTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts between <a class="el" href="#a8b06041d7c1fb05f379714f4312306ec" title="This type only exists for backwards compatibility, and should not be used in new code.">SolverType</a> and <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html" title="Identifies a SolverInterface implementation.">SolverId</a>.  <a href="classdrake_1_1solvers_1_1_solver_type_converter.html#details">More...</a><br /></td></tr>
<tr class="memitem:UnrevisedLemkeSolver" id="r_UnrevisedLemkeSolver"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_unrevised_lemke_solver.html">UnrevisedLemkeSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for the Unrevised Implementation of Lemke Algorithm's for solving Linear Complementarity Problems (LCPs).  <a href="classdrake_1_1solvers_1_1_unrevised_lemke_solver.html#details">More...</a><br /></td></tr>
<tr class="memitem:UnrevisedLemkeSolverId" id="r_UnrevisedLemkeSolverId"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_unrevised_lemke_solver_id.html">UnrevisedLemkeSolverId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-template class for <a class="el" href="classdrake_1_1solvers_1_1_unrevised_lemke_solver.html" title="A class for the Unrevised Implementation of Lemke Algorithm&#39;s for solving Linear Complementarity Prob...">UnrevisedLemkeSolver&lt;T&gt;</a> constants.  <a href="classdrake_1_1solvers_1_1_unrevised_lemke_solver_id.html#details">More...</a><br /></td></tr>
<tr class="memitem:VisualizationCallback" id="r_VisualizationCallback"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html">VisualizationCallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a simple evaluator with no outputs that takes a callback function pointer.  <a href="classdrake_1_1solvers_1_1_visualization_callback.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa708f80d971209e3d46c1e41f05c1393" id="r_aa708f80d971209e3d46c1e41f05c1393"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa708f80d971209e3d46c1e41f05c1393">DecisionVariable</a> = <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a></td></tr>
<tr class="memitem:acf84184cb10b49233b007295d1880e17" id="r_acf84184cb10b49233b007295d1880e17"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:acf84184cb10b49233b007295d1880e17 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a> = Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>, rows, cols&gt;</td></tr>
<tr class="memitem:aa20d09ae94d1e722c2961fbaca37f967" id="r_aa20d09ae94d1e722c2961fbaca37f967"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:aa20d09ae94d1e722c2961fbaca37f967 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a> = <a class="el" href="#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt;rows, 1&gt;</td></tr>
<tr class="memitem:a85b6a5d80d5e24442bca8472b116c22a" id="r_a85b6a5d80d5e24442bca8472b116c22a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a></td></tr>
<tr class="memitem:aca924499b3b011a50d3bd9d051295efa" id="r_aca924499b3b011a50d3bd9d051295efa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> = <a class="el" href="#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a>&lt;Eigen::Dynamic&gt;</td></tr>
<tr class="memitem:a81ee3f72946092b0f97d9cb4753a91f0" id="r_a81ee3f72946092b0f97d9cb4753a91f0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> = std::list&lt;Eigen::Ref&lt;const <a class="el" href="#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a>&gt;&gt;</td></tr>
<tr class="memitem:a0f19da4730aeebddf6a1d14f51f0b7ec" id="r_a0f19da4730aeebddf6a1d14f51f0b7ec"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:a0f19da4730aeebddf6a1d14f51f0b7ec template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a> = Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>, rows, cols&gt;</td></tr>
<tr class="memdesc:a0f19da4730aeebddf6a1d14f51f0b7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#a0f19da4730aeebddf6a1d14f51f0b7ec" title="MatrixIndeterminate&lt;int, int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable,...">MatrixIndeterminate&lt;int, int&gt;</a> is used as an alias for Eigen::Matrix&lt;symbolic::Variable, int, int&gt;.  <br /></td></tr>
<tr class="memitem:ac0943cc7cf2cc9bf7db6facfe53a8568" id="r_ac0943cc7cf2cc9bf7db6facfe53a8568"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:ac0943cc7cf2cc9bf7db6facfe53a8568 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a> = <a class="el" href="#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a>&lt;rows, 1&gt;</td></tr>
<tr class="memdesc:ac0943cc7cf2cc9bf7db6facfe53a8568"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#ac0943cc7cf2cc9bf7db6facfe53a8568" title="VectorIndeterminate&lt;int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable,...">VectorIndeterminate&lt;int&gt;</a> is used as an alias for Eigen::Matrix&lt;symbolic::Variable, int, 1&gt;.  <br /></td></tr>
<tr class="memitem:a7ab45e84bec7fad9608e19ae3441b0bf" id="r_a7ab45e84bec7fad9608e19ae3441b0bf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ab45e84bec7fad9608e19ae3441b0bf">MatrixXIndeterminate</a></td></tr>
<tr class="memdesc:a7ab45e84bec7fad9608e19ae3441b0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#a7ab45e84bec7fad9608e19ae3441b0bf" title="MatrixXIndeterminate is used as an alias for Eigen::Matrix&lt;symbolic::Variable, Eigen::Dynamic,...">MatrixXIndeterminate</a> is used as an alias for Eigen::Matrix&lt;symbolic::Variable, Eigen::Dynamic, Eigen::Dynamic&gt;.  <br /></td></tr>
<tr class="memitem:a91ed74a4ca04549f64c547dfba0724d5" id="r_a91ed74a4ca04549f64c547dfba0724d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a> = <a class="el" href="#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a>&lt;Eigen::Dynamic&gt;</td></tr>
<tr class="memdesc:a91ed74a4ca04549f64c547dfba0724d5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#a91ed74a4ca04549f64c547dfba0724d5" title="VectorXIndeterminate is used as an alias for Eigen::Matrix&lt;symbolic::Variable, Eigen::Dynamic,...">VectorXIndeterminate</a> is used as an alias for Eigen::Matrix&lt;symbolic::Variable, Eigen::Dynamic, 1&gt;.  <br /></td></tr>
<tr class="memitem:a07f638392fbe039dbe92d324303292a4" id="r_a07f638392fbe039dbe92d324303292a4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07f638392fbe039dbe92d324303292a4">IndeterminatesRefList</a> = std::list&lt;Eigen::Ref&lt;const <a class="el" href="#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a>&gt;&gt;</td></tr>
<tr class="memitem:a75a09ceb9ebb76373204d56f5a39c93a" id="r_a75a09ceb9ebb76373204d56f5a39c93a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75a09ceb9ebb76373204d56f5a39c93a">MinimumValuePenaltyFunction</a></td></tr>
<tr class="memdesc:a75a09ceb9ebb76373204d56f5a39c93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the penalty function φ(x) and its derivatives dφ(x)/dx.  <br /></td></tr>
<tr class="memitem:a5617ec1dc3b70cd1683d8850fe69585d" id="r_a5617ec1dc3b70cd1683d8850fe69585d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> = std::unordered_set&lt;<a class="el" href="#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a>, <a class="el" href="namespacedrake.html#a323dc8b0cc629c61d4da8feeaa8cd4f5">DefaultHash</a>&gt;</td></tr>
<tr class="memitem:a55b1b3c88fe94fd28d7564b90f50a00f" id="r_a55b1b3c88fe94fd28d7564b90f50a00f"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55b1b3c88fe94fd28d7564b90f50a00f">RollPitchYawLimits</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae07229124cd16e9d8b62fe359c7d0b40" id="r_ae07229124cd16e9d8b62fe359c7d0b40"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae07229124cd16e9d8b62fe359c7d0b40">CommonSolverOption</a> { <a class="el" href="#ae07229124cd16e9d8b62fe359c7d0b40a222307df6fb67d2a524cade7227ca4f8">kPrintFileName</a>
, <a class="el" href="#ae07229124cd16e9d8b62fe359c7d0b40aca5719f05d0aceacc42e256644394100">kPrintToConsole</a>
, <a class="el" href="#ae07229124cd16e9d8b62fe359c7d0b40a88b173449afee96caef8bf2715f31380">kStandaloneReproductionFileName</a>
, <a class="el" href="#ae07229124cd16e9d8b62fe359c7d0b40af1d12898262fdbf42df381627646ee00">kMaxThreads</a>
 }</td></tr>
<tr class="memdesc:ae07229124cd16e9d8b62fe359c7d0b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some options can be applied to not one solver, but many solvers (for example, many solvers support printing out the progress in each iteration).  <a href="#ae07229124cd16e9d8b62fe359c7d0b40">More...</a><br /></td></tr>
<tr class="memitem:a6297509967536d29159910e5c51fd285" id="r_a6297509967536d29159910e5c51fd285"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6297509967536d29159910e5c51fd285">IntervalBinning</a> { <a class="el" href="#a6297509967536d29159910e5c51fd285a5bff8e60dc42878e194fb2d87460ed29">kLogarithmic</a>
, <a class="el" href="#a6297509967536d29159910e5c51fd285aac97f0008bcf7c7fe4f2ff94160e1385">kLinear</a>
 }</td></tr>
<tr class="memdesc:a6297509967536d29159910e5c51fd285"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a continuous variable whose range is cut into small intervals, we will use binary variables to represent which interval the continuous variable is in.  <a href="#a6297509967536d29159910e5c51fd285">More...</a><br /></td></tr>
<tr class="memitem:a115b732b5de5502e59437ee38babe95f" id="r_a115b732b5de5502e59437ee38babe95f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a> { <br />
&#160;&#160;<a class="el" href="#a115b732b5de5502e59437ee38babe95fa597a3cf4953daab8ab5e6ffebeff44d0">kGenericCost</a>
, <a class="el" href="#a115b732b5de5502e59437ee38babe95fad7bf05f9b17385b6e8aa383fc67fc83f">kGenericConstraint</a>
, <a class="el" href="#a115b732b5de5502e59437ee38babe95fa29122b5334de24190e886ea289d14a2a">kQuadraticCost</a>
, <a class="el" href="#a115b732b5de5502e59437ee38babe95fae8503f9b8b6fbe23f14ac068f665c9c0">kQuadraticConstraint</a>
, <br />
&#160;&#160;<a class="el" href="#a115b732b5de5502e59437ee38babe95fa302b09f3d249d023c8aaad1097b50edb">kLinearCost</a>
, <a class="el" href="#a115b732b5de5502e59437ee38babe95fa42f1335762da576901b57e5b118858e9">kLinearConstraint</a>
, <a class="el" href="#a115b732b5de5502e59437ee38babe95fa48d237e8d01c95129ecc34be15f4b789">kLinearEqualityConstraint</a>
, <a class="el" href="#a115b732b5de5502e59437ee38babe95fa8c8fa060b46a40b2fd97509493514f33">kLinearComplementarityConstraint</a>
, <br />
&#160;&#160;<a class="el" href="#a115b732b5de5502e59437ee38babe95faa19344b8110a4be1b5581a25f612713f">kLorentzConeConstraint</a>
, <a class="el" href="#a115b732b5de5502e59437ee38babe95fa9e8364decaab78121a0ceaabb57c72cc">kRotatedLorentzConeConstraint</a>
, <a class="el" href="#a115b732b5de5502e59437ee38babe95fa59e241294144c7cdf7ea7c8e64b361aa">kPositiveSemidefiniteConstraint</a>
, <a class="el" href="#a115b732b5de5502e59437ee38babe95fa6186f6ad8f4222b61ec29ea48a046299">kExponentialConeConstraint</a>
, <br />
&#160;&#160;<a class="el" href="#a115b732b5de5502e59437ee38babe95fa2b988d83ab42142c09d442f5b42904f3">kL2NormCost</a>
, <a class="el" href="#a115b732b5de5502e59437ee38babe95fa12a1034a77cf500ebcff46f8e493bb10">kBinaryVariable</a>
, <a class="el" href="#a115b732b5de5502e59437ee38babe95fa288767e402655671f06cd5313e8bada9">kCallback</a>
<br />
 }</td></tr>
<tr class="memitem:ab09ca5e1afe9e5a4e8744ecb27839b15" id="r_ab09ca5e1afe9e5a4e8744ecb27839b15"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15">ProgramType</a> { <br />
&#160;&#160;<a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15a3e3af9259f19c76c1a21cacdbd5afd4a">kLP</a>
, <a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15a9ac21b2be50204074e59ceb63526fae6">kQP</a>
, <a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15a7cd173b34793fe6598118c124401da00">kSOCP</a>
, <a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15aeb3825da90413e715ee32c3463428d84">kSDP</a>
, <br />
&#160;&#160;<a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15a7ae933ebedf558cd02d3d45f0a1236cf">kGP</a>
, <a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15a85d8a1af1f3ab3fb37aaef44ee44a436">kCGP</a>
, <a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15a41adb3a46194a70e097f15c9848b2c97">kMILP</a>
, <a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15aa1029d46d3092d1662ee6baccbd926f8">kMIQP</a>
, <br />
&#160;&#160;<a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15af91d74856b95694eb9624142e4317bb4">kMISOCP</a>
, <a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15aea23768965b758e81bdb3e2fb62476c8">kMISDP</a>
, <a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15a914035c5bf9d877dbd17b8c476ab48a6">kQuadraticCostConicConstraint</a>
, <a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15aced0324bc370cd8712746abd28ac3844">kNLP</a>
, <br />
&#160;&#160;<a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15aad18a51c134b9ac1c2af4f45766761cf">kLCP</a>
, <a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15a25c2dc47991b3df171ed5192bcf70390">kUnknown</a>
<br />
 }</td></tr>
<tr class="memdesc:ab09ca5e1afe9e5a4e8744ecb27839b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">A coarse categorization of the optimization problem based on the type of constraints/costs/variables.  <a href="#ab09ca5e1afe9e5a4e8744ecb27839b15">More...</a><br /></td></tr>
<tr class="memitem:a1949f5edc628077e2d780c150de88d74" id="r_a1949f5edc628077e2d780c150de88d74"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1949f5edc628077e2d780c150de88d74">RollPitchYawLimitOptions</a> { <br />
&#160;&#160;<a class="el" href="#a1949f5edc628077e2d780c150de88d74a34bbac4b028a742de1b931cc2694dcea">kNoLimits</a> = 0
, <a class="el" href="#a1949f5edc628077e2d780c150de88d74af029ec457c6dc0bdc5bee0edc2baf12d">kRPYError</a> = 1 &lt;&lt; 0
, <a class="el" href="#a1949f5edc628077e2d780c150de88d74af69f0d7bda8d330fcf89df333412794d">kRoll_NegPI_2_to_PI_2</a> = 1 &lt;&lt; 1
, <a class="el" href="#a1949f5edc628077e2d780c150de88d74a6973c9c90ce92aa52ce62a6e0fc4664d">kRoll_0_to_PI</a> = 1 &lt;&lt; 2
, <br />
&#160;&#160;<a class="el" href="#a1949f5edc628077e2d780c150de88d74adb2b51a6cdf2edf29dc2bfdcefef6ce0">kPitch_NegPI_2_to_PI_2</a> = 1 &lt;&lt; 3
, <a class="el" href="#a1949f5edc628077e2d780c150de88d74a56192ce118646021d72474e9520a804a">kPitch_0_to_PI</a> = 1 &lt;&lt; 4
, <a class="el" href="#a1949f5edc628077e2d780c150de88d74aa059fc525d6d174e5e070c7261ff8e43">kYaw_NegPI_2_to_PI_2</a> = 1 &lt;&lt; 5
, <a class="el" href="#a1949f5edc628077e2d780c150de88d74aca450e45c136c14aabb606a09e0775a8">kYaw_0_to_PI</a> = 1 &lt;&lt; 6
, <br />
&#160;&#160;<a class="el" href="#a1949f5edc628077e2d780c150de88d74a27402335e74462e03adf2c79e903705e">kRoll_0_to_PI_2</a> = (1 &lt;&lt; 1) | (1 &lt;&lt; 2)
, <a class="el" href="#a1949f5edc628077e2d780c150de88d74af031fdd95c7b0bd771a160bf2905eaae">kPitch_0_to_PI_2</a> = (1 &lt;&lt; 3) | (1 &lt;&lt; 4)
, <a class="el" href="#a1949f5edc628077e2d780c150de88d74aae2b1591bba5a77450b0df77a207be8f">kYaw_0_to_PI_2</a> = (1 &lt;&lt; 5) | (1 &lt;&lt; 6)
<br />
 }</td></tr>
<tr class="memitem:a121673ddbdadd10b2e3ceab52a93f5d3" id="r_a121673ddbdadd10b2e3ceab52a93f5d3"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a121673ddbdadd10b2e3ceab52a93f5d3">RemoveFreeVariableMethod</a> { <a class="el" href="#a121673ddbdadd10b2e3ceab52a93f5d3a268e3bfe4e48f70785a46a8d3552e552">kTwoSlackVariables</a> = 1
, <a class="el" href="#a121673ddbdadd10b2e3ceab52a93f5d3a54b9d7601ece96fc42e2ffd67aae2690">kNullspace</a> = 2
, <a class="el" href="#a121673ddbdadd10b2e3ceab52a93f5d3a2992c87df2428b480924bf6c6509edec">kLorentzConeSlack</a> = 3
 }</td></tr>
<tr class="memdesc:a121673ddbdadd10b2e3ceab52a93f5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDPA format doesn't accept free variables, namely the problem it solves is in this form P1.  <a href="#a121673ddbdadd10b2e3ceab52a93f5d3">More...</a><br /></td></tr>
<tr class="memitem:a331f41a3139a87d16e1422bc818c136f" id="r_a331f41a3139a87d16e1422bc818c136f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a> { <br />
&#160;&#160;<a class="el" href="#a331f41a3139a87d16e1422bc818c136fa15e1c4845b9467d880999c78de6afe45">kSolutionFound</a> = 0
, <a class="el" href="#a331f41a3139a87d16e1422bc818c136fa78cb430cc349315a2ba0f3602ef64b6d">kInvalidInput</a> = -1
, <a class="el" href="#a331f41a3139a87d16e1422bc818c136fa4f17cb26e989bf3f8c2990cd51fcede9">kInfeasibleConstraints</a> = -2
, <a class="el" href="#a331f41a3139a87d16e1422bc818c136fa4b9de95ee3087851acd98262e09f0be8">kUnbounded</a> = -3
, <br />
&#160;&#160;<a class="el" href="#a331f41a3139a87d16e1422bc818c136fa84d10e8dce3328bfb1f6761d194857f2">kSolverSpecificError</a> = -4
, <a class="el" href="#a331f41a3139a87d16e1422bc818c136fa2bfbc12cb546f78bd0080b8df5b26520">kInfeasibleOrUnbounded</a> = -5
, <a class="el" href="#a331f41a3139a87d16e1422bc818c136fa97600ae7efdb5c8fecf91e99463ef4ef">kIterationLimit</a> = -6
, <a class="el" href="#a331f41a3139a87d16e1422bc818c136fae1f645d6b81b09a506f807a18d5e1d4b">kDualInfeasible</a> = -7
, <br />
&#160;&#160;<a class="el" href="#a331f41a3139a87d16e1422bc818c136fab42685181d035fb42e3da3462b4c0b55">kSolutionResultNotSet</a> = -8
<br />
 }</td></tr>
<tr class="memitem:a8b06041d7c1fb05f379714f4312306ec" id="r_a8b06041d7c1fb05f379714f4312306ec"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b06041d7c1fb05f379714f4312306ec">SolverType</a> { <br />
&#160;&#160;<a class="el" href="#a8b06041d7c1fb05f379714f4312306ecaa71a8c0a25fe7a3d777fc06d50bada13">kClp</a>
, <a class="el" href="#a8b06041d7c1fb05f379714f4312306ecae654b0ad8f79045aff33844a0c3cdf81">kCsdp</a>
, <a class="el" href="#a8b06041d7c1fb05f379714f4312306eca71cedba88b736e372f499099329d5173">kEqualityConstrainedQP</a>
, <a class="el" href="#a8b06041d7c1fb05f379714f4312306ecabc8ddfb8a00bb405e68545ce187ac238">kGurobi</a>
, <br />
&#160;&#160;<a class="el" href="#a8b06041d7c1fb05f379714f4312306ecaa1f0780f88b19c3a73710b47fc57d795">kIpopt</a>
, <a class="el" href="#a8b06041d7c1fb05f379714f4312306ecaebb0e280cb0e7da8a3868247749a4d9d">kLinearSystem</a>
, <a class="el" href="#a8b06041d7c1fb05f379714f4312306ecabd0a61a2cf9acec23fccd41c7402ef56">kMobyLCP</a>
, <a class="el" href="#a8b06041d7c1fb05f379714f4312306eca18bc9cbd9bb764958e636263b1b53a9d">kMosek</a>
, <br />
&#160;&#160;<a class="el" href="#a8b06041d7c1fb05f379714f4312306eca64e0ff0ce277a08ed59a9fe9140a8fd7">kNlopt</a>
, <a class="el" href="#a8b06041d7c1fb05f379714f4312306eca6e645ae8d30d672d9800a422f4be4c9d">kOsqp</a>
, <a class="el" href="#a8b06041d7c1fb05f379714f4312306eca6619293bd01e7ea8efb3682f16bf55c4">kSnopt</a>
, <a class="el" href="#a8b06041d7c1fb05f379714f4312306ecad1ddb13aaaf649f197e0f6549596571c">kScs</a>
, <br />
&#160;&#160;<a class="el" href="#a8b06041d7c1fb05f379714f4312306eca045139748552611db2ba18934b6f89f6">kUnrevisedLemke</a>
<br />
 }</td></tr>
<tr class="memdesc:a8b06041d7c1fb05f379714f4312306ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type only exists for backwards compatibility, and should not be used in new code.  <a href="#a8b06041d7c1fb05f379714f4312306ec">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a327c1374c023a7401092ae0b6e4b83f8" id="r_a327c1374c023a7401092ae0b6e4b83f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a327c1374c023a7401092ae0b6e4b83f8">AggregateLinearCosts</a> (const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; &gt; &amp;linear_costs, Eigen::SparseVector&lt; double &gt; *linear_coeff, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; *vars, double *constant_cost)</td></tr>
<tr class="memdesc:a327c1374c023a7401092ae0b6e4b83f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given many linear costs, aggregate them into.  <br /></td></tr>
<tr class="memitem:acc7a90e544994241a62e70e433acba6b" id="r_acc7a90e544994241a62e70e433acba6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc7a90e544994241a62e70e433acba6b">AggregateQuadraticAndLinearCosts</a> (const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; &gt; &amp;quadratic_costs, const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; &gt; &amp;linear_costs, Eigen::SparseMatrix&lt; double &gt; *Q_lower, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; *quadratic_vars, Eigen::SparseVector&lt; double &gt; *linear_coeff, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; *linear_vars, double *constant_cost)</td></tr>
<tr class="memdesc:acc7a90e544994241a62e70e433acba6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given many linear and quadratic costs, aggregate them into.  <br /></td></tr>
<tr class="memitem:acdb6bda41a9c96928ceba8fa56b37e94" id="r_acdb6bda41a9c96928ceba8fa56b37e94"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>, <a class="el" href="structdrake_1_1solvers_1_1_bound.html">Bound</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdb6bda41a9c96928ceba8fa56b37e94">AggregateBoundingBoxConstraints</a> (const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; &gt; &amp;bounding_box_constraints)</td></tr>
<tr class="memdesc:acdb6bda41a9c96928ceba8fa56b37e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregates many bounding box constraints, returns the intersection (the tightest bounds) of these constraints.  <br /></td></tr>
<tr class="memitem:a886abb8ddadab85980c4cb7d687cf1e9" id="r_a886abb8ddadab85980c4cb7d687cf1e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a886abb8ddadab85980c4cb7d687cf1e9">AggregateBoundingBoxConstraints</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog, Eigen::VectorXd *lower, Eigen::VectorXd *upper)</td></tr>
<tr class="memdesc:a886abb8ddadab85980c4cb7d687cf1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregates all the BoundingBoxConstraints inside <code class="param">prog</code>, returns the intersection of the bounding box constraints as the lower and upper bound for each variable in <code class="param">prog</code>.  <br /></td></tr>
<tr class="memitem:a68b12677c76a5bb950270a506601d3d3" id="r_a68b12677c76a5bb950270a506601d3d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68b12677c76a5bb950270a506601d3d3">AggregateBoundingBoxConstraints</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog, std::vector&lt; double &gt; *lower, std::vector&lt; double &gt; *upper)</td></tr>
<tr class="memdesc:a68b12677c76a5bb950270a506601d3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads AggregateBoundingBoxConstraints, but the type of lower and upper are std::vector&lt;double&gt;.  <br /></td></tr>
<tr class="memitem:ae47924d35c8e0ca9af2c5e12d1d2f217" id="r_ae47924d35c8e0ca9af2c5e12d1d2f217"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae47924d35c8e0ca9af2c5e12d1d2f217">AggregateDuplicateVariables</a> (const Eigen::SparseMatrix&lt; double &gt; &amp;A, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &amp;vars, Eigen::SparseMatrix&lt; double &gt; *A_new, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; *vars_new)</td></tr>
<tr class="memdesc:ae47924d35c8e0ca9af2c5e12d1d2f217"><td class="mdescLeft">&#160;</td><td class="mdescRight">For linear expression A * vars where <span class="tt">vars</span> might contain duplicated entries, rewrite this linear expression as A_new * vars_new where vars_new doesn't contain duplicated entries.  <br /></td></tr>
<tr class="memitem:a920a5d85d90c2100b5e6a74f6a1f0067" id="r_a920a5d85d90c2100b5e6a74f6a1f0067"><td class="memTemplParams" colspan="2">template&lt;typename C&gt; </td></tr>
<tr class="memitem:a920a5d85d90c2100b5e6a74f6a1f0067 template"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a920a5d85d90c2100b5e6a74f6a1f0067">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;binding)</td></tr>
<tr class="memdesc:a920a5d85d90c2100b5e6a74f6a1f0067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the <a class="el" href="classdrake_1_1solvers_1_1_binding.html" title="A binding on constraint type C is a mapping of the decision variables onto the inputs of C.">Binding</a>.  <br /></td></tr>
<tr class="memitem:a5ad49ccf0a41d8b2ee1ecb197479356e" id="r_a5ad49ccf0a41d8b2ee1ecb197479356e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ad49ccf0a41d8b2ee1ecb197479356e">ChooseBestSolver</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog)</td></tr>
<tr class="memdesc:a5ad49ccf0a41d8b2ee1ecb197479356e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose the best solver given the formulation in the optimization program and the availability of the solvers.  <br /></td></tr>
<tr class="memitem:ac96894b2d363452c15d82857102ac460" id="r_ac96894b2d363452c15d82857102ac460"><td class="memItemLeft" align="right" valign="top">const std::set&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac96894b2d363452c15d82857102ac460">GetKnownSolvers</a> ()</td></tr>
<tr class="memdesc:ac96894b2d363452c15d82857102ac460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of solvers known to ChooseBestSolver.  <br /></td></tr>
<tr class="memitem:a0ce0059feaa7226606a4f0dd51d82696" id="r_a0ce0059feaa7226606a4f0dd51d82696"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">SolverInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ce0059feaa7226606a4f0dd51d82696">MakeSolver</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;id)</td></tr>
<tr class="memdesc:a0ce0059feaa7226606a4f0dd51d82696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the solver ID, create the solver with the matching ID.  <br /></td></tr>
<tr class="memitem:af70d41b17760217e0926be91e74c7516" id="r_af70d41b17760217e0926be91e74c7516"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">SolverInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af70d41b17760217e0926be91e74c7516">MakeFirstAvailableSolver</a> (const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &gt; &amp;solver_ids)</td></tr>
<tr class="memdesc:af70d41b17760217e0926be91e74c7516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the first available and enabled solver.  <br /></td></tr>
<tr class="memitem:ad0239a4e08f44cc440b9b87b673cc1ca" id="r_ad0239a4e08f44cc440b9b87b673cc1ca"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0239a4e08f44cc440b9b87b673cc1ca">GetAvailableSolvers</a> (<a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15">ProgramType</a> prog_type)</td></tr>
<tr class="memdesc:ad0239a4e08f44cc440b9b87b673cc1ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of available and enabled solvers that definitely accept all programs of the given program type.  <br /></td></tr>
<tr class="memitem:a9ed92e0fe48d891de05ce122684f9564" id="r_a9ed92e0fe48d891de05ce122684f9564"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ed92e0fe48d891de05ce122684f9564">to_string</a> (<a class="el" href="#ae07229124cd16e9d8b62fe359c7d0b40">CommonSolverOption</a>)</td></tr>
<tr class="memdesc:a9ed92e0fe48d891de05ce122684f9564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the short, unadorned name of the option, e.g., <span class="tt">kPrintFileName</span>.  <br /></td></tr>
<tr class="memitem:ga550bb2427b2f65e82328e646dd5fa003" id="r_ga550bb2427b2f65e82328e646dd5fa003"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__solver__evaluators.html#ga550bb2427b2f65e82328e646dd5fa003">MakeQuadraticErrorCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;x_desired)</td></tr>
<tr class="memdesc:ga550bb2427b2f65e82328e646dd5fa003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a cost term of the form (x-x_desired)'<em>Q</em>(x-x_desired).  <br /></td></tr>
<tr class="memitem:ga0bac8cf60cad8f30eabe23d54048bd58" id="r_ga0bac8cf60cad8f30eabe23d54048bd58"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__solver__evaluators.html#ga0bac8cf60cad8f30eabe23d54048bd58">Make2NormSquaredCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b)</td></tr>
<tr class="memdesc:ga0bac8cf60cad8f30eabe23d54048bd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a quadratic cost of the form |Ax-b|²=(Ax-b)ᵀ(Ax-b).  <br /></td></tr>
<tr class="memitem:ga587e8c4ae9c19f68312ad50b36418278" id="r_ga587e8c4ae9c19f68312ad50b36418278"><td class="memTemplParams" colspan="2">template&lt;typename FF&gt; </td></tr>
<tr class="memitem:ga587e8c4ae9c19f68312ad50b36418278 template"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__solver__evaluators.html#ga587e8c4ae9c19f68312ad50b36418278">MakeFunctionCost</a> (FF &amp;&amp;f)</td></tr>
<tr class="memdesc:ga587e8c4ae9c19f68312ad50b36418278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an input of type <code class="param">F</code> to a nonlinear cost.  <br /></td></tr>
<tr class="memitem:a68452fe0431657d5c5473a7267377181" id="r_a68452fe0431657d5c5473a7267377181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68452fe0431657d5c5473a7267377181">ConcatenateVariableRefList</a> (const <a class="el" href="#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;var_list)</td></tr>
<tr class="memdesc:a68452fe0431657d5c5473a7267377181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates each element in <code class="param">var_list</code> into a single Eigen vector of decision variables, returns this concatenated vector.  <br /></td></tr>
<tr class="memitem:ae3d5c08300fbf29a9a60fda82f641f8c" id="r_ae3d5c08300fbf29a9a60fda82f641f8c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3d5c08300fbf29a9a60fda82f641f8c">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1solvers_1_1_evaluator_base.html">EvaluatorBase</a> &amp;e)</td></tr>
<tr class="memdesc:ae3d5c08300fbf29a9a60fda82f641f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the evaluator.  <br /></td></tr>
<tr class="memitem:a3ccbbc5523e1562a301d0e0e7a7beb52" id="r_a3ccbbc5523e1562a301d0e0e7a7beb52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15">ProgramType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ccbbc5523e1562a301d0e0e7a7beb52">GetProgramType</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog)</td></tr>
<tr class="memdesc:a3ccbbc5523e1562a301d0e0e7a7beb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of the optimization program (LP, QP, etc), based on the properties of its cost/constraints/variables.  <br /></td></tr>
<tr class="memitem:af625a7985e13112d4eb9c0ec49c15fa2" id="r_af625a7985e13112d4eb9c0ec49c15fa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af625a7985e13112d4eb9c0ec49c15fa2">ConcatenateIndeterminatesRefList</a> (const <a class="el" href="#a07f638392fbe039dbe92d324303292a4">IndeterminatesRefList</a> &amp;var_list)</td></tr>
<tr class="memdesc:af625a7985e13112d4eb9c0ec49c15fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates each element in <code class="param">var_list</code> into a single Eigen vector of indeterminates, returns this concatenated vector.  <br /></td></tr>
<tr class="memitem:a1842dff572de2f867c53c0c8d272ae80" id="r_a1842dff572de2f867c53c0c8d272ae80"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; int, -1, -1, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1842dff572de2f867c53c0c8d272ae80">EnumerateIntegerSolutions</a> (const Eigen::Ref&lt; const Eigen::MatrixXi &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;b, const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;lower_bound, const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;upper_bound)</td></tr>
<tr class="memdesc:a1842dff572de2f867c53c0c8d272ae80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all integer solutions x to the linear inequalities.  <br /></td></tr>
<tr class="memitem:aebc1de9951001044e9fbbae8e2eb715f" id="r_aebc1de9951001044e9fbbae8e2eb715f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebc1de9951001044e9fbbae8e2eb715f">CreateLogicalAndConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b2, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b1_and_b2)</td></tr>
<tr class="memdesc:aebc1de9951001044e9fbbae8e2eb715f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear constraints, such that when b1, b2, b1_and_b2 satisfy the constraints, and b1, b2 take binary values, it is guaranteed that b1_and_b2 = b1 ∧ b2 (b1 and b2).  <br /></td></tr>
<tr class="memitem:aa6a4bae896f4f776721c48ad4222eddb" id="r_aa6a4bae896f4f776721c48ad4222eddb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6a4bae896f4f776721c48ad4222eddb">CreateLogicalOrConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b2, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b1_or_b2)</td></tr>
<tr class="memdesc:aa6a4bae896f4f776721c48ad4222eddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear constraints, such that when b1, b2, b1_or_b2 satisfy the constraints, and b1, b2 take binary values, it is guaranteed that b1_or_b2 = b1 ∨ b2 (b1 or b2).  <br /></td></tr>
<tr class="memitem:a95e1c79a22de687bad6ec057223e334b" id="r_a95e1c79a22de687bad6ec057223e334b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95e1c79a22de687bad6ec057223e334b">CreateLogicalXorConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b2, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b1_xor_b2)</td></tr>
<tr class="memdesc:a95e1c79a22de687bad6ec057223e334b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add linear constraints, such that when b1, b2, b1_xor_b2 satisfy the constraints, and b1, b2 take binary values, it is guaranteed that b1_xor_b2 = b1 ⊕ b2 (b1 exclusive xor b2).  <br /></td></tr>
<tr class="memitem:aa9ade4e3ddb4bb380d8a732f462f3988" id="r_aa9ade4e3ddb4bb380d8a732f462f3988"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9ade4e3ddb4bb380d8a732f462f3988">CreateBinaryCodeMatchConstraint</a> (const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &amp;code, const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;expected, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;match)</td></tr>
<tr class="memdesc:aa9ade4e3ddb4bb380d8a732f462f3988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create linear constraints such that, when these constraints are satisfied, match = 1 if and only if code == expected, otherwise match = 0.  <br /></td></tr>
<tr class="memitem:ac5414006478cdb2f8d7381a774314746" id="r_ac5414006478cdb2f8d7381a774314746"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5414006478cdb2f8d7381a774314746">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog)</td></tr>
<tr class="memitem:a42c918b5a6318c3cd1f04cf2904a12aa" id="r_a42c918b5a6318c3cd1f04cf2904a12aa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42c918b5a6318c3cd1f04cf2904a12aa">GetVariableValue</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;var, const std::optional&lt; std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, int &gt; &gt; &amp;variable_index, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;variable_values)</td></tr>
<tr class="memdesc:a42c918b5a6318c3cd1f04cf2904a12aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the value of a single variable <code class="param">var</code> from <code class="param">variable_values</code>.  <br /></td></tr>
<tr class="memitem:a6659fb507e1cc8a0d0d78648c09c5993" id="r_a6659fb507e1cc8a0d0d78648c09c5993"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; <br />
requires (std::is_same_v&lt;typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&gt;)</td></tr>
<tr class="memitem:a6659fb507e1cc8a0d0d78648c09c5993 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; double, Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6659fb507e1cc8a0d0d78648c09c5993">GetVariableValue</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;var, const std::optional&lt; std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, int &gt; &gt; &amp;variable_index, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;variable_values)</td></tr>
<tr class="memdesc:a6659fb507e1cc8a0d0d78648c09c5993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload <a class="el" href="#a42c918b5a6318c3cd1f04cf2904a12aa" title="Retrieve the value of a single variable var from variable_values.">GetVariableValue()</a> function, but for an Eigen matrix of decision variables.  <br /></td></tr>
<tr class="memitem:af82f700d069a4e17f3413cb7d135d031" id="r_af82f700d069a4e17f3413cb7d135d031"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af82f700d069a4e17f3413cb7d135d031">ExponentiallySmoothedHingeLoss</a> (double x, double *penalty, double *dpenalty_dx)</td></tr>
<tr class="memdesc:af82f700d069a4e17f3413cb7d135d031"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hinge loss function smoothed by exponential function.  <br /></td></tr>
<tr class="memitem:af9613bd8bc67af65c0d77241a1581875" id="r_af9613bd8bc67af65c0d77241a1581875"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9613bd8bc67af65c0d77241a1581875">QuadraticallySmoothedHingeLoss</a> (double x, double *penalty, double *dpenalty_dx)</td></tr>
<tr class="memdesc:af9613bd8bc67af65c0d77241a1581875"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear hinge loss, smoothed with a quadratic loss near the origin.  <br /></td></tr>
<tr class="memitem:a394e6ba5988e7a7f9f5800798ecf47c8" id="r_a394e6ba5988e7a7f9f5800798ecf47c8"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a394e6ba5988e7a7f9f5800798ecf47c8">CeilLog2</a> (int n)</td></tr>
<tr class="memdesc:a394e6ba5988e7a7f9f5800798ecf47c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return ⌈log₂(n)⌉, namely the minimal integer no smaller than log₂(n), with base 2.  <br /></td></tr>
<tr class="memitem:a7842718f7d87ab0164e182757e6ab2c9" id="r_a7842718f7d87ab0164e182757e6ab2c9"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; <br />
requires (<a class="el" href="structdrake_1_1is__eigen__vector__of.html">drake::is_eigen_vector_of</a>&lt;Derived, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt;::value)</td></tr>
<tr class="memitem:a7842718f7d87ab0164e182757e6ab2c9 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7842718f7d87ab0164e182757e6ab2c9">AddLogarithmicSos2Constraint</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::MatrixBase&lt; Derived &gt; &amp;lambda, const std::string &amp;binary_variable_name=&quot;y&quot;) -&gt; typename <a class="el" href="structdrake_1_1solvers_1_1_logarithmic_sos2_new_binary_variables.html">LogarithmicSos2NewBinaryVariables</a>&lt; Derived::RowsAtCompileTime &gt;::type</td></tr>
<tr class="memdesc:a7842718f7d87ab0164e182757e6ab2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the special ordered set 2 (SOS2) constraint,.  <br /></td></tr>
<tr class="memitem:a5ff27667ee8e19ab9af9f4134a5213bd" id="r_a5ff27667ee8e19ab9af9f4134a5213bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ff27667ee8e19ab9af9f4134a5213bd">AddLogarithmicSos2Constraint</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;lambda, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;y)</td></tr>
<tr class="memdesc:a5ff27667ee8e19ab9af9f4134a5213bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the special ordered set 2 (SOS2) constraint,.  <br /></td></tr>
<tr class="memitem:ada666e00bb20bccef0f87e0a56712c57" id="r_ada666e00bb20bccef0f87e0a56712c57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada666e00bb20bccef0f87e0a56712c57">AddSos2Constraint</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;lambda, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;y)</td></tr>
<tr class="memdesc:ada666e00bb20bccef0f87e0a56712c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the special ordered set 2 (SOS2) constraint.  <br /></td></tr>
<tr class="memitem:a1eb095f3eb55a66d0625b746c6e2ff54" id="r_a1eb095f3eb55a66d0625b746c6e2ff54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1eb095f3eb55a66d0625b746c6e2ff54">AddLogarithmicSos1Constraint</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;lambda, const Eigen::Ref&lt; const <a class="el" href="#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;y, const Eigen::Ref&lt; const Eigen::MatrixXi &gt; &amp;binary_encoding)</td></tr>
<tr class="memdesc:a1eb095f3eb55a66d0625b746c6e2ff54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the special ordered set of type 1 (SOS1) constraint.  <br /></td></tr>
<tr class="memitem:aa27ae5b43e2b6b52817d2b2cf05cb980" id="r_aa27ae5b43e2b6b52817d2b2cf05cb980"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa27ae5b43e2b6b52817d2b2cf05cb980">AddLogarithmicSos1Constraint</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, int num_lambda) -&gt; std::pair&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt;</td></tr>
<tr class="memdesc:aa27ae5b43e2b6b52817d2b2cf05cb980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the special ordered set of type 1 (SOS1) constraint.  <br /></td></tr>
<tr class="memitem:a77cbff4245bea6ae4ca666c62547ff28" id="r_a77cbff4245bea6ae4ca666c62547ff28"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77cbff4245bea6ae4ca666c62547ff28">to_string</a> (<a class="el" href="#a6297509967536d29159910e5c51fd285">IntervalBinning</a> interval_binning)</td></tr>
<tr class="memitem:a7471708f3def1afd274533854146795e" id="r_a7471708f3def1afd274533854146795e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7471708f3def1afd274533854146795e">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="#a6297509967536d29159910e5c51fd285">IntervalBinning</a> &amp;binning)</td></tr>
<tr class="memitem:a3e4a0b93fcb60733633a5187469ecaa2" id="r_a3e4a0b93fcb60733633a5187469ecaa2"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPhiX, typename DerivedPhiY, typename DerivedBx, typename DerivedBy&gt; <br />
requires (<a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt;DerivedPhiX, double&gt;::value &amp;&amp; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt;DerivedPhiY, double&gt;::value &amp;&amp; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt;DerivedBx, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt;::value &amp;&amp; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt;DerivedBy, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt;::value)</td></tr>
<tr class="memitem:a3e4a0b93fcb60733633a5187469ecaa2 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e4a0b93fcb60733633a5187469ecaa2">AddBilinearProductMcCormickEnvelopeSos2</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;x, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;y, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;w, const DerivedPhiX &amp;phi_x, const DerivedPhiY &amp;phi_y, const DerivedBx &amp;Bx, const DerivedBy &amp;By, <a class="el" href="#a6297509967536d29159910e5c51fd285">IntervalBinning</a> binning) -&gt; <a class="el" href="#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; DerivedPhiX::RowsAtCompileTime, DerivedPhiY::RowsAtCompileTime &gt;</td></tr>
<tr class="memdesc:a3e4a0b93fcb60733633a5187469ecaa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add constraints to the optimization program, such that the bilinear product x * y is approximated by w, using Special Ordered Set of Type 2 (sos2) constraint.  <br /></td></tr>
<tr class="memitem:ae57ef09daad0923021d5b9441b2e4c74" id="r_ae57ef09daad0923021d5b9441b2e4c74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae57ef09daad0923021d5b9441b2e4c74">AddBilinearProductMcCormickEnvelopeMultipleChoice</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;x, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;y, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;w, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;phi_x, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;phi_y, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;Bx, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;By)</td></tr>
<tr class="memdesc:ae57ef09daad0923021d5b9441b2e4c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add constraints to the optimization program, such that the bilinear product x * y is approximated by w, using Mixed Integer constraint with "Multiple
   Choice" model.  <br /></td></tr>
<tr class="memitem:acefb8a09d0ea27761bdca23e9ea9f682" id="r_acefb8a09d0ea27761bdca23e9ea9f682"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acefb8a09d0ea27761bdca23e9ea9f682">to_string</a> (<a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_rotation_constraint_generator.html#a50cc1069474becb0998889b417d7b4ff">MixedIntegerRotationConstraintGenerator::Approach</a> type)</td></tr>
<tr class="memitem:ad5fd73626a6f4a64e9dad21f9a66ea6c" id="r_ad5fd73626a6f4a64e9dad21f9a66ea6c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5fd73626a6f4a64e9dad21f9a66ea6c">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_rotation_constraint_generator.html#a50cc1069474becb0998889b417d7b4ff">MixedIntegerRotationConstraintGenerator::Approach</a> &amp;type)</td></tr>
<tr class="memitem:aada9e5deeaf832076592970c0ccc1676" id="r_aada9e5deeaf832076592970c0ccc1676"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1solvers_1_1_add_rotation_matrix_box_sphere_intersection_return.html">AddRotationMatrixBoxSphereIntersectionReturn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aada9e5deeaf832076592970c0ccc1676">AddRotationMatrixBoxSphereIntersectionMilpConstraints</a> (const Eigen::Ref&lt; const <a class="el" href="#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt; &gt; &amp;R, int num_intervals_per_half_axis, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog)</td></tr>
<tr class="memdesc:aada9e5deeaf832076592970c0ccc1676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds binary variables that constrain the value of the column <em>and</em> row vectors of R, in order to add the following (in some cases non-convex) constraints as an MILP.  <br /></td></tr>
<tr class="memitem:a0a5158190138557c3a90f95ef426c308" id="r_a0a5158190138557c3a90f95ef426c308"><td class="memItemLeft" align="right" valign="top">std::pair&lt; Eigen::MatrixXd, Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a5158190138557c3a90f95ef426c308">DecomposeNonConvexQuadraticForm</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q)</td></tr>
<tr class="memdesc:a0a5158190138557c3a90f95ef426c308"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a non-convex homogeneous quadratic form xᵀQx, where Q is not necessarily a positive semidefinite matrix, we decompose it as a difference between two convex homogeneous quadratic forms xᵀQx = xᵀQ₁x - xᵀQ₂x, Q₁, Q₂ are positive semidefinite.  <br /></td></tr>
<tr class="memitem:ga70dab8652a66b1411ea56edef4b0b995" id="r_ga70dab8652a66b1411ea56edef4b0b995"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__solver__evaluators.html#ga70dab8652a66b1411ea56edef4b0b995">AddRelaxNonConvexQuadraticConstraintInTrustRegion</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;x, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q1, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q2, const Eigen::Ref&lt; const <a class="el" href="#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;y, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;p, double lower_bound, double upper_bound, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;linearization_point, double trust_region_gap) -&gt; std::tuple&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;, std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; &gt;, <a class="el" href="#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt;</td></tr>
<tr class="memdesc:ga70dab8652a66b1411ea56edef4b0b995"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a non-convex quadratic constraint lb ≤ xᵀQ₁x - xᵀQ₂x + pᵀy ≤ ub where Q₁, Q₂ are both positive semidefinite matrices.  <br /></td></tr>
<tr class="memitem:a6fec9540703ed86e335009f64d963f16" id="r_a6fec9540703ed86e335009f64d963f16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fec9540703ed86e335009f64d963f16">AreRequiredAttributesSupported</a> (const <a class="el" href="#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;required, const <a class="el" href="#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;supported, std::string *unsupported_message=nullptr)</td></tr>
<tr class="memdesc:a6fec9540703ed86e335009f64d963f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff <code class="param">required</code> is a subset of <code class="param">supported</code>.  <br /></td></tr>
<tr class="memitem:af903ad969496826b0f656bf335658130" id="r_af903ad969496826b0f656bf335658130"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af903ad969496826b0f656bf335658130">to_string</a> (const <a class="el" href="#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a> &amp;)</td></tr>
<tr class="memitem:ae6bec4adfa5ced08c9ac41bea152ebb0" id="r_ae6bec4adfa5ced08c9ac41bea152ebb0"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6bec4adfa5ced08c9ac41bea152ebb0">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a> &amp;)</td></tr>
<tr class="memdesc:ae6bec4adfa5ced08c9ac41bea152ebb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr class="memitem:a6c64a075d3d1fe62ad756b11008d821a" id="r_a6c64a075d3d1fe62ad756b11008d821a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c64a075d3d1fe62ad756b11008d821a">to_string</a> (const <a class="el" href="#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;)</td></tr>
<tr class="memitem:accd7f1cdf664f15fcf2457b23606ca66" id="r_accd7f1cdf664f15fcf2457b23606ca66"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accd7f1cdf664f15fcf2457b23606ca66">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;)</td></tr>
<tr class="memdesc:accd7f1cdf664f15fcf2457b23606ca66"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr class="memitem:aa3b2cde12caa7fc0dc9c4addadfea54c" id="r_aa3b2cde12caa7fc0dc9c4addadfea54c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3b2cde12caa7fc0dc9c4addadfea54c">to_string</a> (const <a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15">ProgramType</a> &amp;)</td></tr>
<tr class="memitem:aad4e89db1879b0982cc770f6f88ca32a" id="r_aad4e89db1879b0982cc770f6f88ca32a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad4e89db1879b0982cc770f6f88ca32a">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15">ProgramType</a> &amp;)</td></tr>
<tr class="memdesc:aad4e89db1879b0982cc770f6f88ca32a"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <br /></td></tr>
<tr class="memitem:a01ecc846aa3939d1a4d166cfe0455a4e" id="r_a01ecc846aa3939d1a4d166cfe0455a4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01ecc846aa3939d1a4d166cfe0455a4e">NewRotationMatrixVars</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const std::string &amp;name=&quot;R&quot;)</td></tr>
<tr class="memdesc:a01ecc846aa3939d1a4d166cfe0455a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a 3x3 matrix of decision variables with the trivial bounding box constraint ensuring all elements are [-1,1], and the linear constraint imposing -1 &lt;= trace(R) &lt;= 3.  <br /></td></tr>
<tr class="memitem:aa188246c79aee1c77a289927b5518266" id="r_aa188246c79aee1c77a289927b5518266"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa188246c79aee1c77a289927b5518266">AddBoundingBoxConstraintsImpliedByRollPitchYawLimits</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt; &gt; &amp;R, <a class="el" href="#a55b1b3c88fe94fd28d7564b90f50a00f">RollPitchYawLimits</a> limits=<a class="el" href="#a1949f5edc628077e2d780c150de88d74a34bbac4b028a742de1b931cc2694dcea">kNoLimits</a>)</td></tr>
<tr class="memdesc:aa188246c79aee1c77a289927b5518266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies <em>very conservative</em> limits on the entries of R for the cases when rotations can be limited (for instance, if you want to search over rotations, but there is an obvious symmetry in the problem so that e.g.  <br /></td></tr>
<tr class="memitem:a83559ace7ba26c28b6a7dc536e8b6de0" id="r_a83559ace7ba26c28b6a7dc536e8b6de0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83559ace7ba26c28b6a7dc536e8b6de0">AddRotationMatrixSpectrahedralSdpConstraint</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt; &gt; &amp;R)</td></tr>
<tr class="memdesc:a83559ace7ba26c28b6a7dc536e8b6de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraint (10) from <a href="https://arxiv.org/pdf/1403.4914.pdf">https://arxiv.org/pdf/1403.4914.pdf</a> , which exactly represents the convex hull of all rotation matrices in 3D.  <br /></td></tr>
<tr class="memitem:a173bf985ebdce58dcea4df5885490dc8" id="r_a173bf985ebdce58dcea4df5885490dc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a173bf985ebdce58dcea4df5885490dc8">AddRotationMatrixOrthonormalSocpConstraint</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt; &gt; &amp;R)</td></tr>
<tr class="memdesc:a173bf985ebdce58dcea4df5885490dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a set of convex constraints which approximate the set of orthogonal matrices, O(3).  <br /></td></tr>
<tr class="memitem:ac4e7fbc0ff51a6176bdfbdaefe1db3e9" id="r_ac4e7fbc0ff51a6176bdfbdaefe1db3e9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4e7fbc0ff51a6176bdfbdaefe1db3e9">to_string</a> (const <a class="el" href="#a121673ddbdadd10b2e3ceab52a93f5d3">RemoveFreeVariableMethod</a> &amp;)</td></tr>
<tr class="memitem:afb682968b9ebcdeebdc42676227af765" id="r_afb682968b9ebcdeebdc42676227af765"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb682968b9ebcdeebdc42676227af765">GenerateSDPA</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog, const std::string &amp;file_name, <a class="el" href="#a121673ddbdadd10b2e3ceab52a93f5d3">RemoveFreeVariableMethod</a> method=<a class="el" href="#a121673ddbdadd10b2e3ceab52a93f5d3a54b9d7601ece96fc42e2ffd67aae2690">RemoveFreeVariableMethod::kNullspace</a>)</td></tr>
<tr class="memdesc:afb682968b9ebcdeebdc42676227af765"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDPA is a format to record an SDP problem.  <br /></td></tr>
<tr class="memitem:a00a0c7751190c2af67a99e49b5049eb0" id="r_a00a0c7751190c2af67a99e49b5049eb0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00a0c7751190c2af67a99e49b5049eb0">MakeSemidefiniteRelaxation</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog, const <a class="el" href="structdrake_1_1solvers_1_1_semidefinite_relaxation_options.html">SemidefiniteRelaxationOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:a00a0c7751190c2af67a99e49b5049eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> which represents the semidefinite programming convex relaxation of the (likely nonconvex) program <span class="tt">prog</span>.  <br /></td></tr>
<tr class="memitem:a167049ac9ec0cd87f0eb86ffdf5a656b" id="r_a167049ac9ec0cd87f0eb86ffdf5a656b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a167049ac9ec0cd87f0eb86ffdf5a656b">MakeSemidefiniteRelaxation</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog, const std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &gt; &amp;variable_groups, const <a class="el" href="structdrake_1_1solvers_1_1_semidefinite_relaxation_options.html">SemidefiniteRelaxationOptions</a> &amp;options={})</td></tr>
<tr class="memdesc:a167049ac9ec0cd87f0eb86ffdf5a656b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version of MakeSemidefiniteRelaxation that allows for specifying the sparsity of the relaxation.  <br /></td></tr>
<tr class="memitem:a8e3f2d56e890db7a38d31875b08f6db3" id="r_a8e3f2d56e890db7a38d31875b08f6db3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e3f2d56e890db7a38d31875b08f6db3">to_string</a> (<a class="el" href="#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a> solution_result)</td></tr>
<tr class="memitem:a06b3e1d1807426668e3b27fb536af4a4" id="r_a06b3e1d1807426668e3b27fb536af4a4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06b3e1d1807426668e3b27fb536af4a4">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a> solution_result)</td></tr>
<tr class="memitem:ae34d0e7febfca6328561574df6ce91d5" id="r_ae34d0e7febfca6328561574df6ce91d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae34d0e7febfca6328561574df6ce91d5">Solve</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog, const std::optional&lt; Eigen::VectorXd &gt; &amp;initial_guess, const std::optional&lt; <a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &gt; &amp;solver_options)</td></tr>
<tr class="memdesc:ae34d0e7febfca6328561574df6ce91d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves an optimization program, with optional initial guess and solver options.  <br /></td></tr>
<tr class="memitem:a527dd0ffa6bbc4d4d42edb944045294f" id="r_a527dd0ffa6bbc4d4d42edb944045294f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a527dd0ffa6bbc4d4d42edb944045294f">Solve</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;initial_guess)</td></tr>
<tr class="memdesc:a527dd0ffa6bbc4d4d42edb944045294f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves an optimization program with a given initial guess.  <br /></td></tr>
<tr class="memitem:a01ce4ccbfe64bbdae5e26927307a1f5a" id="r_a01ce4ccbfe64bbdae5e26927307a1f5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01ce4ccbfe64bbdae5e26927307a1f5a">Solve</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog)</td></tr>
<tr class="memitem:a6a70d99e086147ad2791bb41aa71d5c5" id="r_a6a70d99e086147ad2791bb41aa71d5c5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a70d99e086147ad2791bb41aa71d5c5">SolveInParallel</a> (const std::vector&lt; const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> * &gt; &amp;progs, const std::vector&lt; const Eigen::VectorXd * &gt; *initial_guesses, const std::vector&lt; const <a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> * &gt; *solver_options, const std::vector&lt; std::optional&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &gt; &gt; *solver_ids, <a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a> parallelism=<a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>(), bool dynamic_schedule=false)</td></tr>
<tr class="memdesc:a6a70d99e086147ad2791bb41aa71d5c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves progs[i] into result[i], optionally using initial_guess[i] and solver_options[i] if given, by invoking the solver at solver_ids[i] if provided.  <br /></td></tr>
<tr class="memitem:a25590160567b442e480c55b7fd98fc92" id="r_a25590160567b442e480c55b7fd98fc92"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25590160567b442e480c55b7fd98fc92">SolveInParallel</a> (const std::vector&lt; const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> * &gt; &amp;progs, const std::vector&lt; const Eigen::VectorXd * &gt; *initial_guesses=nullptr, const <a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> *solver_options=nullptr, const std::optional&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &gt; &amp;solver_id=std::nullopt, <a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a> parallelism=<a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>(), bool dynamic_schedule=false)</td></tr>
<tr class="memdesc:a25590160567b442e480c55b7fd98fc92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the same functionality as SolveInParallel, but allows for specifying a single solver id and solver option that is used when solving all programs.  <br /></td></tr>
<tr class="memitem:ac374be9093bcfabc8fba4b2697b11ad2" id="r_ac374be9093bcfabc8fba4b2697b11ad2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac374be9093bcfabc8fba4b2697b11ad2">operator==</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;, const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;)</td></tr>
<tr class="memitem:ac86287c7a75cb7c4762de3cb7b214d64" id="r_ac86287c7a75cb7c4762de3cb7b214d64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac86287c7a75cb7c4762de3cb7b214d64">operator!=</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;, const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;)</td></tr>
<tr class="memitem:aa563e1d6e3e15b8f4cb35bfe48d68600" id="r_aa563e1d6e3e15b8f4cb35bfe48d68600"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa563e1d6e3e15b8f4cb35bfe48d68600">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;)</td></tr>
<tr class="memitem:a59990839e673f511a23b540f9067a93b" id="r_a59990839e673f511a23b540f9067a93b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">drake::VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59990839e673f511a23b540f9067a93b">ConstructMonomialBasis</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">drake::symbolic::Polynomial</a> &amp;p)</td></tr>
<tr class="memdesc:a59990839e673f511a23b540f9067a93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given input polynomial p, outputs a set M of monomials with the following guarantee: if p = f1*f1 + f2*f2 + ... + fn*fn for some (unknown) polynomials f1, f2, ..., fn, then the span of M contains f1, f2, ..., fn, Given M, one can then find the polynomials fi using semidefinite programming; see, e.g., Chapter 3 of Semidefinite Optimization and Convex Algebraic Geometry by G.  <br /></td></tr>
<tr class="memitem:a178d19e5bc9f02ff074623de63d2b4ff" id="r_a178d19e5bc9f02ff074623de63d2b4ff"><td class="memTemplParams" colspan="2">template&lt;typename FF&gt; </td></tr>
<tr class="memitem:a178d19e5bc9f02ff074623de63d2b4ff template"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_evaluator_base.html">EvaluatorBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_function_evaluator.html#a178d19e5bc9f02ff074623de63d2b4ff">MakeFunctionEvaluator</a> (FF &amp;&amp;f)</td></tr>
<tr class="memdesc:a178d19e5bc9f02ff074623de63d2b4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classdrake_1_1solvers_1_1_function_evaluator.html" title="An evaluator that may be specified using a callable object.">FunctionEvaluator</a> instance bound to a given callable object.  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="aa708f80d971209e3d46c1e41f05c1393" name="aa708f80d971209e3d46c1e41f05c1393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa708f80d971209e3d46c1e41f05c1393">&#9670;&#160;</a></span>DecisionVariable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aa708f80d971209e3d46c1e41f05c1393">DecisionVariable</a> = <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a07f638392fbe039dbe92d324303292a4" name="a07f638392fbe039dbe92d324303292a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f638392fbe039dbe92d324303292a4">&#9670;&#160;</a></span>IndeterminatesRefList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a07f638392fbe039dbe92d324303292a4">IndeterminatesRefList</a> = std::list&lt;Eigen::Ref&lt;const <a class="el" href="#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf84184cb10b49233b007295d1880e17" name="acf84184cb10b49233b007295d1880e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf84184cb10b49233b007295d1880e17">&#9670;&#160;</a></span>MatrixDecisionVariable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rows, int cols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a> = Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>, rows, cols&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f19da4730aeebddf6a1d14f51f0b7ec" name="a0f19da4730aeebddf6a1d14f51f0b7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f19da4730aeebddf6a1d14f51f0b7ec">&#9670;&#160;</a></span>MatrixIndeterminate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rows, int cols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a> = Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>, rows, cols&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#a0f19da4730aeebddf6a1d14f51f0b7ec" title="MatrixIndeterminate&lt;int, int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable,...">MatrixIndeterminate&lt;int, int&gt;</a> is used as an alias for Eigen::Matrix&lt;symbolic::Variable, int, int&gt;. </p>
<p>After resolving aliases, a compiler does not distinguish between these two. All indeterminates are a variable of type <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479ab1fa9dd3af034b3ef4291579aa673c07" title="A CONTINUOUS variable takes a double value.">symbolic::Variable::Type::CONTINUOUS</a> (by default). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix containing indeterminates. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns in the new matrix containing indeterminates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85b6a5d80d5e24442bca8472b116c22a" name="a85b6a5d80d5e24442bca8472b116c22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b6a5d80d5e24442bca8472b116c22a">&#9670;&#160;</a></span>MatrixXDecisionVariable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a85b6a5d80d5e24442bca8472b116c22a">MatrixXDecisionVariable</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable&lt;Eigen::Dynamic, Eigen::Dynamic&gt;</a></div>
<div class="ttc" id="anamespacedrake_1_1solvers_html_acf84184cb10b49233b007295d1880e17"><div class="ttname"><a href="#acf84184cb10b49233b007295d1880e17">drake::solvers::MatrixDecisionVariable</a></div><div class="ttdeci">Eigen::Matrix&lt; symbolic::Variable, rows, cols &gt; MatrixDecisionVariable</div><div class="ttdef"><b>Definition</b> decision_variable.h:15</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7ab45e84bec7fad9608e19ae3441b0bf" name="a7ab45e84bec7fad9608e19ae3441b0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab45e84bec7fad9608e19ae3441b0bf">&#9670;&#160;</a></span>MatrixXIndeterminate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7ab45e84bec7fad9608e19ae3441b0bf">MatrixXIndeterminate</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate&lt;Eigen::Dynamic, Eigen::Dynamic&gt;</a></div>
<div class="ttc" id="anamespacedrake_1_1solvers_html_a0f19da4730aeebddf6a1d14f51f0b7ec"><div class="ttname"><a href="#a0f19da4730aeebddf6a1d14f51f0b7ec">drake::solvers::MatrixIndeterminate</a></div><div class="ttdeci">Eigen::Matrix&lt; symbolic::Variable, rows, cols &gt; MatrixIndeterminate</div><div class="ttdoc">MatrixIndeterminate&lt;int, int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable,...</div><div class="ttdef"><b>Definition</b> indeterminate.h:21</div></div>
</div><!-- fragment -->
<p><a class="el" href="#a7ab45e84bec7fad9608e19ae3441b0bf" title="MatrixXIndeterminate is used as an alias for Eigen::Matrix&lt;symbolic::Variable, Eigen::Dynamic,...">MatrixXIndeterminate</a> is used as an alias for Eigen::Matrix&lt;symbolic::Variable, Eigen::Dynamic, Eigen::Dynamic&gt;. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0f19da4730aeebddf6a1d14f51f0b7ec" title="MatrixIndeterminate&lt;int, int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable,...">MatrixIndeterminate&lt;int, int&gt;</a> </dd></dl>

</div>
</div>
<a id="a75a09ceb9ebb76373204d56f5a39c93a" name="a75a09ceb9ebb76373204d56f5a39c93a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a09ceb9ebb76373204d56f5a39c93a">&#9670;&#160;</a></span>MinimumValuePenaltyFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a75a09ceb9ebb76373204d56f5a39c93a">MinimumValuePenaltyFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::function&lt;void(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span>* penalty, <span class="keywordtype">double</span>* dpenalty_dx)&gt;</div>
</div><!-- fragment -->
<p>Computes the penalty function φ(x) and its derivatives dφ(x)/dx. </p>
<p>Valid penalty functions must meet the following criteria:</p>
<ol type="1">
<li>φ(x) ≥ 0 ∀ x ∈ ℝ.</li>
<li>dφ(x)/dx ≤ 0 ∀ x ∈ ℝ.</li>
<li>φ(x) = 0 ∀ x ≥ 0.</li>
<li>dφ(x)/dx &lt; 0 ∀ x &lt; 0.</li>
</ol>
<p>If <span class="tt">dpenalty_dx</span> is nullptr, the function should only compute φ(x). </p>

</div>
</div>
<a id="a5617ec1dc3b70cd1683d8850fe69585d" name="a5617ec1dc3b70cd1683d8850fe69585d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5617ec1dc3b70cd1683d8850fe69585d">&#9670;&#160;</a></span>ProgramAttributes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> = std::unordered_set&lt;<a class="el" href="#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a>, <a class="el" href="namespacedrake.html#a323dc8b0cc629c61d4da8feeaa8cd4f5">DefaultHash</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a55b1b3c88fe94fd28d7564b90f50a00f" name="a55b1b3c88fe94fd28d7564b90f50a00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b1b3c88fe94fd28d7564b90f50a00f">&#9670;&#160;</a></span>RollPitchYawLimits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="#a55b1b3c88fe94fd28d7564b90f50a00f">RollPitchYawLimits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81ee3f72946092b0f97d9cb4753a91f0" name="a81ee3f72946092b0f97d9cb4753a91f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ee3f72946092b0f97d9cb4753a91f0">&#9670;&#160;</a></span>VariableRefList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> = std::list&lt;Eigen::Ref&lt;const <a class="el" href="#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a>&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa20d09ae94d1e722c2961fbaca37f967" name="aa20d09ae94d1e722c2961fbaca37f967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20d09ae94d1e722c2961fbaca37f967">&#9670;&#160;</a></span>VectorDecisionVariable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rows&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a> = <a class="el" href="#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt;rows, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0943cc7cf2cc9bf7db6facfe53a8568" name="ac0943cc7cf2cc9bf7db6facfe53a8568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0943cc7cf2cc9bf7db6facfe53a8568">&#9670;&#160;</a></span>VectorIndeterminate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rows&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a> = <a class="el" href="#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a>&lt;rows, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#ac0943cc7cf2cc9bf7db6facfe53a8568" title="VectorIndeterminate&lt;int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable,...">VectorIndeterminate&lt;int&gt;</a> is used as an alias for Eigen::Matrix&lt;symbolic::Variable, int, 1&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix containing indeterminates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0f19da4730aeebddf6a1d14f51f0b7ec" title="MatrixIndeterminate&lt;int, int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable,...">MatrixIndeterminate&lt;int, int&gt;</a> </dd></dl>

</div>
</div>
<a id="aca924499b3b011a50d3bd9d051295efa" name="aca924499b3b011a50d3bd9d051295efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca924499b3b011a50d3bd9d051295efa">&#9670;&#160;</a></span>VectorXDecisionVariable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> = <a class="el" href="#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a>&lt;Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91ed74a4ca04549f64c547dfba0724d5" name="a91ed74a4ca04549f64c547dfba0724d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ed74a4ca04549f64c547dfba0724d5">&#9670;&#160;</a></span>VectorXIndeterminate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a> = <a class="el" href="#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a>&lt;Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#a91ed74a4ca04549f64c547dfba0724d5" title="VectorXIndeterminate is used as an alias for Eigen::Matrix&lt;symbolic::Variable, Eigen::Dynamic,...">VectorXIndeterminate</a> is used as an alias for Eigen::Matrix&lt;symbolic::Variable, Eigen::Dynamic, 1&gt;. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0f19da4730aeebddf6a1d14f51f0b7ec" title="MatrixIndeterminate&lt;int, int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable,...">MatrixIndeterminate&lt;int, int&gt;</a> </dd></dl>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="ae07229124cd16e9d8b62fe359c7d0b40" name="ae07229124cd16e9d8b62fe359c7d0b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07229124cd16e9d8b62fe359c7d0b40">&#9670;&#160;</a></span>CommonSolverOption</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ae07229124cd16e9d8b62fe359c7d0b40">CommonSolverOption</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Some options can be applied to not one solver, but many solvers (for example, many solvers support printing out the progress in each iteration). </p>
<p><a class="el" href="#ae07229124cd16e9d8b62fe359c7d0b40" title="Some options can be applied to not one solver, but many solvers (for example, many solvers support pr...">CommonSolverOption</a> contain the names of these supported options. The user can use these options as "key" in SolverOption::SetOption(). If the solver doesn't support the option, the option is ignored. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae07229124cd16e9d8b62fe359c7d0b40a222307df6fb67d2a524cade7227ca4f8" name="ae07229124cd16e9d8b62fe359c7d0b40a222307df6fb67d2a524cade7227ca4f8"></a>kPrintFileName&#160;</td><td class="fielddoc"><p>Many solvers support printing the progress of each iteration to a file. </p>
<p>The user can call <a class="el" href="structdrake_1_1solvers_1_1_solver_options.html#af4c4c08922e737f18d2f1960f4f93e02" title="Sets a solver option for a specific solver.">SolverOptions::SetOption</a>(kPrintFileName, "filename.log") to enable this. To disable, set the option to the empty string <span class="tt">""</span>, which indicates that no file should be written. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae07229124cd16e9d8b62fe359c7d0b40aca5719f05d0aceacc42e256644394100" name="ae07229124cd16e9d8b62fe359c7d0b40aca5719f05d0aceacc42e256644394100"></a>kPrintToConsole&#160;</td><td class="fielddoc"><p>Many solvers support printing the progress of each iteration to the console. </p>
<p>The user can call <span class="tt">SolverOptions::SetOption(kPrintToConsole, 1)</span> to enable this, or use <span class="tt">0</span> to turn off printing to the console. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae07229124cd16e9d8b62fe359c7d0b40a88b173449afee96caef8bf2715f31380" name="ae07229124cd16e9d8b62fe359c7d0b40a88b173449afee96caef8bf2715f31380"></a>kStandaloneReproductionFileName&#160;</td><td class="fielddoc"><p>Some solvers support writing a standalone (e.g., it does not depend on Drake) minimal reproduction of the problem to a file. </p>
<p>This is especially useful for sending bug reports upstream to the developers of the solver. The user can call <span class="tt"><a class="el" href="structdrake_1_1solvers_1_1_solver_options.html#af4c4c08922e737f18d2f1960f4f93e02" title="Sets a solver option for a specific solver.">SolverOptions::SetOption</a>(kStandaloneReproductionFileName, "filename.txt")</span> to enable this. To disable, set the option to the empty string <span class="tt">""</span>, which indicates that no file should be written. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae07229124cd16e9d8b62fe359c7d0b40af1d12898262fdbf42df381627646ee00" name="ae07229124cd16e9d8b62fe359c7d0b40af1d12898262fdbf42df381627646ee00"></a>kMaxThreads&#160;</td><td class="fielddoc"><p>Some solvers are multi-threaded. </p>
<p>The user can request the maximum number of threads used by the solver with this <span class="tt">int</span> option. When not set, the value defaults to <a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819" title="Constructs a Parallelism with the maximum number of threads.">Parallelism.Max()</a>.num_threads(), which can be controlled via the <a class="el" href="classdrake_1_1_parallelism.html">DRAKE_NUM_THREADS</a> environment variable. </p><dl class="section pre"><dt>Precondition</dt><dd>The number of threads must be greater than 0. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Setting this value higher than the actual hardware concurrency may result in a degraded performance. It is recommended to set this value lower than or equal to <a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819" title="Constructs a Parallelism with the maximum number of threads.">Parallelism.Max()</a>.num_threads(). </dd>
<dd>
A solver may choose to use fewer threads than the value specified. </dd>
<dd>
This options does NOT disable multi-threading in BLAS/LAPACK which is used by many solvers under the hood. Therefore, some internal operations of the solvers may still be multi-core. </dd></dl>
</td></tr>
</table>

</div>
</div>
<a id="a6297509967536d29159910e5c51fd285" name="a6297509967536d29159910e5c51fd285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6297509967536d29159910e5c51fd285">&#9670;&#160;</a></span>IntervalBinning</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a6297509967536d29159910e5c51fd285">IntervalBinning</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a continuous variable whose range is cut into small intervals, we will use binary variables to represent which interval the continuous variable is in. </p>
<p>We support two representations, either using logarithmic number of binary variables, or linear number of binary variables. For more details, </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7842718f7d87ab0164e182757e6ab2c9" title="Adds the special ordered set 2 (SOS2) constraint,.">AddLogarithmicSos2Constraint</a> and <a class="el" href="#ada666e00bb20bccef0f87e0a56712c57" title="Adds the special ordered set 2 (SOS2) constraint.">AddSos2Constraint</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6297509967536d29159910e5c51fd285a5bff8e60dc42878e194fb2d87460ed29" name="a6297509967536d29159910e5c51fd285a5bff8e60dc42878e194fb2d87460ed29"></a>kLogarithmic&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6297509967536d29159910e5c51fd285aac97f0008bcf7c7fe4f2ff94160e1385" name="a6297509967536d29159910e5c51fd285aac97f0008bcf7c7fe4f2ff94160e1385"></a>kLinear&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a115b732b5de5502e59437ee38babe95f" name="a115b732b5de5502e59437ee38babe95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115b732b5de5502e59437ee38babe95f">&#9670;&#160;</a></span>ProgramAttribute</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa597a3cf4953daab8ab5e6ffebeff44d0" name="a115b732b5de5502e59437ee38babe95fa597a3cf4953daab8ab5e6ffebeff44d0"></a>kGenericCost&#160;</td><td class="fielddoc"><p>A generic cost, doesn't belong to any specific cost type below. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fad7bf05f9b17385b6e8aa383fc67fc83f" name="a115b732b5de5502e59437ee38babe95fad7bf05f9b17385b6e8aa383fc67fc83f"></a>kGenericConstraint&#160;</td><td class="fielddoc"><p>A generic constraint, doesn't belong to any specific constraint type below. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa29122b5334de24190e886ea289d14a2a" name="a115b732b5de5502e59437ee38babe95fa29122b5334de24190e886ea289d14a2a"></a>kQuadraticCost&#160;</td><td class="fielddoc"><p>A quadratic function as the cost. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fae8503f9b8b6fbe23f14ac068f665c9c0" name="a115b732b5de5502e59437ee38babe95fae8503f9b8b6fbe23f14ac068f665c9c0"></a>kQuadraticConstraint&#160;</td><td class="fielddoc"><p>A constraint on a quadratic function. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa302b09f3d249d023c8aaad1097b50edb" name="a115b732b5de5502e59437ee38babe95fa302b09f3d249d023c8aaad1097b50edb"></a>kLinearCost&#160;</td><td class="fielddoc"><p>A linear function as the cost. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa42f1335762da576901b57e5b118858e9" name="a115b732b5de5502e59437ee38babe95fa42f1335762da576901b57e5b118858e9"></a>kLinearConstraint&#160;</td><td class="fielddoc"><p>A constraint on a linear function. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa48d237e8d01c95129ecc34be15f4b789" name="a115b732b5de5502e59437ee38babe95fa48d237e8d01c95129ecc34be15f4b789"></a>kLinearEqualityConstraint&#160;</td><td class="fielddoc"><p>An equality constraint on a linear function. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa8c8fa060b46a40b2fd97509493514f33" name="a115b732b5de5502e59437ee38babe95fa8c8fa060b46a40b2fd97509493514f33"></a>kLinearComplementarityConstraint&#160;</td><td class="fielddoc"><p>A linear complementarity constraint in the form 0 ≤ z ⊥ Mz+q ≥ 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95faa19344b8110a4be1b5581a25f612713f" name="a115b732b5de5502e59437ee38babe95faa19344b8110a4be1b5581a25f612713f"></a>kLorentzConeConstraint&#160;</td><td class="fielddoc"><p>A Lorentz cone constraint. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa9e8364decaab78121a0ceaabb57c72cc" name="a115b732b5de5502e59437ee38babe95fa9e8364decaab78121a0ceaabb57c72cc"></a>kRotatedLorentzConeConstraint&#160;</td><td class="fielddoc"><p>A rotated Lorentz cone constraint. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa59e241294144c7cdf7ea7c8e64b361aa" name="a115b732b5de5502e59437ee38babe95fa59e241294144c7cdf7ea7c8e64b361aa"></a>kPositiveSemidefiniteConstraint&#160;</td><td class="fielddoc"><p>A positive semidefinite constraint. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa6186f6ad8f4222b61ec29ea48a046299" name="a115b732b5de5502e59437ee38babe95fa6186f6ad8f4222b61ec29ea48a046299"></a>kExponentialConeConstraint&#160;</td><td class="fielddoc"><p>An exponential cone constraint. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa2b988d83ab42142c09d442f5b42904f3" name="a115b732b5de5502e59437ee38babe95fa2b988d83ab42142c09d442f5b42904f3"></a>kL2NormCost&#160;</td><td class="fielddoc"><p>An L2 norm |Ax+b|. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa12a1034a77cf500ebcff46f8e493bb10" name="a115b732b5de5502e59437ee38babe95fa12a1034a77cf500ebcff46f8e493bb10"></a>kBinaryVariable&#160;</td><td class="fielddoc"><p>Variable taking binary value {0, 1}. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa288767e402655671f06cd5313e8bada9" name="a115b732b5de5502e59437ee38babe95fa288767e402655671f06cd5313e8bada9"></a>kCallback&#160;</td><td class="fielddoc"><p>Supports callback during solving the problem. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab09ca5e1afe9e5a4e8744ecb27839b15" name="ab09ca5e1afe9e5a4e8744ecb27839b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09ca5e1afe9e5a4e8744ecb27839b15">&#9670;&#160;</a></span>ProgramType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15">ProgramType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A coarse categorization of the optimization problem based on the type of constraints/costs/variables. </p>
<p>Notice that Drake chooses the solver based on a finer category; for example we have a specific solver for equality-constrained convex QP. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15a3e3af9259f19c76c1a21cacdbd5afd4a" name="ab09ca5e1afe9e5a4e8744ecb27839b15a3e3af9259f19c76c1a21cacdbd5afd4a"></a>kLP&#160;</td><td class="fielddoc"><p>Linear Programming, with a linear cost and linear constraints. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15a9ac21b2be50204074e59ceb63526fae6" name="ab09ca5e1afe9e5a4e8744ecb27839b15a9ac21b2be50204074e59ceb63526fae6"></a>kQP&#160;</td><td class="fielddoc"><p>Quadratic Programming, with a convex quadratic cost and linear constraints. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15a7cd173b34793fe6598118c124401da00" name="ab09ca5e1afe9e5a4e8744ecb27839b15a7cd173b34793fe6598118c124401da00"></a>kSOCP&#160;</td><td class="fielddoc"><p>Second-order Cone Programming, with a linear cost and second-order cone constraints. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15aeb3825da90413e715ee32c3463428d84" name="ab09ca5e1afe9e5a4e8744ecb27839b15aeb3825da90413e715ee32c3463428d84"></a>kSDP&#160;</td><td class="fielddoc"><p>Semidefinite Programming, with a linear cost and positive semidefinite matrix constraints. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15a7ae933ebedf558cd02d3d45f0a1236cf" name="ab09ca5e1afe9e5a4e8744ecb27839b15a7ae933ebedf558cd02d3d45f0a1236cf"></a>kGP&#160;</td><td class="fielddoc"><p>Geometric Programming, with a linear cost and exponential cone constraints. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15a85d8a1af1f3ab3fb37aaef44ee44a436" name="ab09ca5e1afe9e5a4e8744ecb27839b15a85d8a1af1f3ab3fb37aaef44ee44a436"></a>kCGP&#160;</td><td class="fielddoc"><p>Conic Geometric Programming, this is a superset that unifies GP and SDP. </p>
<p>Refer to <a href="http://people.lids.mit.edu/pari/cgp_preprint.pdf">http://people.lids.mit.edu/pari/cgp_preprint.pdf</a> for more details. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15a41adb3a46194a70e097f15c9848b2c97" name="ab09ca5e1afe9e5a4e8744ecb27839b15a41adb3a46194a70e097f15c9848b2c97"></a>kMILP&#160;</td><td class="fielddoc"><p>Mixed-integer Linear Programming. </p>
<p>LP with some variables taking binary values. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15aa1029d46d3092d1662ee6baccbd926f8" name="ab09ca5e1afe9e5a4e8744ecb27839b15aa1029d46d3092d1662ee6baccbd926f8"></a>kMIQP&#160;</td><td class="fielddoc"><p>Mixed-integer Quadratic Programming. </p>
<p>QP with some variables taking binary values. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15af91d74856b95694eb9624142e4317bb4" name="ab09ca5e1afe9e5a4e8744ecb27839b15af91d74856b95694eb9624142e4317bb4"></a>kMISOCP&#160;</td><td class="fielddoc"><p>Mixed-integer Second-order Cone Programming. </p>
<p>SOCP with some variables taking binary values. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15aea23768965b758e81bdb3e2fb62476c8" name="ab09ca5e1afe9e5a4e8744ecb27839b15aea23768965b758e81bdb3e2fb62476c8"></a>kMISDP&#160;</td><td class="fielddoc"><p>Mixed-integer Semidefinite Programming. </p>
<p>SDP with some variables taking binary values. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15a914035c5bf9d877dbd17b8c476ab48a6" name="ab09ca5e1afe9e5a4e8744ecb27839b15a914035c5bf9d877dbd17b8c476ab48a6"></a>kQuadraticCostConicConstraint&#160;</td><td class="fielddoc"><p>convex quadratic cost with nonlinear conic constraints. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15aced0324bc370cd8712746abd28ac3844" name="ab09ca5e1afe9e5a4e8744ecb27839b15aced0324bc370cd8712746abd28ac3844"></a>kNLP&#160;</td><td class="fielddoc"><p>nonlinear programming. </p>
<p>Programs with generic costs or constraints. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15aad18a51c134b9ac1c2af4f45766761cf" name="ab09ca5e1afe9e5a4e8744ecb27839b15aad18a51c134b9ac1c2af4f45766761cf"></a>kLCP&#160;</td><td class="fielddoc"><p>Linear Complementarity Programs. </p>
<p>Programs with linear complementary constraints and no cost. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15a25c2dc47991b3df171ed5192bcf70390" name="ab09ca5e1afe9e5a4e8744ecb27839b15a25c2dc47991b3df171ed5192bcf70390"></a>kUnknown&#160;</td><td class="fielddoc"><p>Does not fall into any of the types above. </p>
</td></tr>
</table>

</div>
</div>
<a id="a121673ddbdadd10b2e3ceab52a93f5d3" name="a121673ddbdadd10b2e3ceab52a93f5d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121673ddbdadd10b2e3ceab52a93f5d3">&#9670;&#160;</a></span>RemoveFreeVariableMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a121673ddbdadd10b2e3ceab52a93f5d3">RemoveFreeVariableMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SDPA format doesn't accept free variables, namely the problem it solves is in this form P1. </p>
<pre class="fragment">max tr(C * X)
s.t tr(Aᵢ*X) = aᵢ
    X ≽ 0.
</pre><p>Notice that the decision variable X has to be in the proper cone X ≽ 0, and it doesn't accept free variable (without the conic constraint). On the other hand, most real-world applications require free variables, namely problems in this form P2 </p><pre class="fragment">max tr(C * X) + dᵀs
s.t tr(Aᵢ*X) + bᵢᵀs = aᵢ
    X ≽ 0
    s is free.
</pre><p>In order to remove the free variables, we consider three approaches.</p><ol type="1">
<li>Replace a free variable s with two variables s = p - q, p ≥ 0, q ≥ 0.</li>
<li><p class="startli">First write the dual of the problem P2 as D2 </p><pre class="fragment">min aᵀy
s.t ∑ᵢ yᵢAᵢ - C = Z
    Z ≽ 0
    Bᵀ * y = d,
</pre><p class="startli">where bᵢᵀ is the i'th row of B. The last constraint Bᵀ * y = d means y = ŷ + Nt, where Bᵀ * ŷ = d, and N is the null space of Bᵀ. Hence, D2 is equivalent to the following problem, D3 </p><pre class="fragment">min aᵀNt + aᵀŷ
s.t ∑ᵢ tᵢFᵢ - (C -∑ᵢ ŷᵢAᵢ) = Z
    Z ≽ 0,
</pre><p class="startli">where Fᵢ = ∑ⱼ NⱼᵢAⱼ. D3 is the dual of the following primal problem P3 without free variables </p><pre class="fragment">max tr((C-∑ᵢ ŷᵢAᵢ)*X̂) + aᵀŷ
s.t tr(FᵢX̂) = (Nᵀa)(i)
    X̂ ≽ 0.
</pre><p class="startli">Then (X, s) = (X̂, B⁻¹(a - tr(Aᵢ X̂))) is the solution to the original problem P2.</p>
</li>
<li>Add a slack variable t, with the Lorentz cone constraint t ≥ sqrt(sᵀs). </li>
</ol>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a121673ddbdadd10b2e3ceab52a93f5d3a268e3bfe4e48f70785a46a8d3552e552" name="a121673ddbdadd10b2e3ceab52a93f5d3a268e3bfe4e48f70785a46a8d3552e552"></a>kTwoSlackVariables&#160;</td><td class="fielddoc"><p>Approach 1, replace a free variable s as s = y⁺ - y⁻, y⁺ ≥ 0, y⁻ ≥ 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="a121673ddbdadd10b2e3ceab52a93f5d3a54b9d7601ece96fc42e2ffd67aae2690" name="a121673ddbdadd10b2e3ceab52a93f5d3a54b9d7601ece96fc42e2ffd67aae2690"></a>kNullspace&#160;</td><td class="fielddoc"><p>Approach 2, reformulate the dual problem by considering the nullspace of the linear constraint in the dual. </p>
</td></tr>
<tr><td class="fieldname"><a id="a121673ddbdadd10b2e3ceab52a93f5d3a2992c87df2428b480924bf6c6509edec" name="a121673ddbdadd10b2e3ceab52a93f5d3a2992c87df2428b480924bf6c6509edec"></a>kLorentzConeSlack&#160;</td><td class="fielddoc"><p>Approach 3, add a slack variable t with the lorentz cone constraint t ≥ sqrt(sᵀs). </p>
</td></tr>
</table>

</div>
</div>
<a id="a1949f5edc628077e2d780c150de88d74" name="a1949f5edc628077e2d780c150de88d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1949f5edc628077e2d780c150de88d74">&#9670;&#160;</a></span>RollPitchYawLimitOptions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a1949f5edc628077e2d780c150de88d74">RollPitchYawLimitOptions</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74a34bbac4b028a742de1b931cc2694dcea" name="a1949f5edc628077e2d780c150de88d74a34bbac4b028a742de1b931cc2694dcea"></a>kNoLimits&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74af029ec457c6dc0bdc5bee0edc2baf12d" name="a1949f5edc628077e2d780c150de88d74af029ec457c6dc0bdc5bee0edc2baf12d"></a>kRPYError&#160;</td><td class="fielddoc"><p>Do not use, to avoid &amp; vs. &amp;&amp; typos. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74af69f0d7bda8d330fcf89df333412794d" name="a1949f5edc628077e2d780c150de88d74af69f0d7bda8d330fcf89df333412794d"></a>kRoll_NegPI_2_to_PI_2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74a6973c9c90ce92aa52ce62a6e0fc4664d" name="a1949f5edc628077e2d780c150de88d74a6973c9c90ce92aa52ce62a6e0fc4664d"></a>kRoll_0_to_PI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74adb2b51a6cdf2edf29dc2bfdcefef6ce0" name="a1949f5edc628077e2d780c150de88d74adb2b51a6cdf2edf29dc2bfdcefef6ce0"></a>kPitch_NegPI_2_to_PI_2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74a56192ce118646021d72474e9520a804a" name="a1949f5edc628077e2d780c150de88d74a56192ce118646021d72474e9520a804a"></a>kPitch_0_to_PI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74aa059fc525d6d174e5e070c7261ff8e43" name="a1949f5edc628077e2d780c150de88d74aa059fc525d6d174e5e070c7261ff8e43"></a>kYaw_NegPI_2_to_PI_2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74aca450e45c136c14aabb606a09e0775a8" name="a1949f5edc628077e2d780c150de88d74aca450e45c136c14aabb606a09e0775a8"></a>kYaw_0_to_PI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74a27402335e74462e03adf2c79e903705e" name="a1949f5edc628077e2d780c150de88d74a27402335e74462e03adf2c79e903705e"></a>kRoll_0_to_PI_2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74af031fdd95c7b0bd771a160bf2905eaae" name="a1949f5edc628077e2d780c150de88d74af031fdd95c7b0bd771a160bf2905eaae"></a>kPitch_0_to_PI_2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74aae2b1591bba5a77450b0df77a207be8f" name="a1949f5edc628077e2d780c150de88d74aae2b1591bba5a77450b0df77a207be8f"></a>kYaw_0_to_PI_2&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a331f41a3139a87d16e1422bc818c136f" name="a331f41a3139a87d16e1422bc818c136f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331f41a3139a87d16e1422bc818c136f">&#9670;&#160;</a></span>SolutionResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fa15e1c4845b9467d880999c78de6afe45" name="a331f41a3139a87d16e1422bc818c136fa15e1c4845b9467d880999c78de6afe45"></a>kSolutionFound&#160;</td><td class="fielddoc"><p>Found the optimal solution. </p>
</td></tr>
<tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fa78cb430cc349315a2ba0f3602ef64b6d" name="a331f41a3139a87d16e1422bc818c136fa78cb430cc349315a2ba0f3602ef64b6d"></a>kInvalidInput&#160;</td><td class="fielddoc"><p>Invalid input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fa4f17cb26e989bf3f8c2990cd51fcede9" name="a331f41a3139a87d16e1422bc818c136fa4f17cb26e989bf3f8c2990cd51fcede9"></a>kInfeasibleConstraints&#160;</td><td class="fielddoc"><p>The primal is infeasible. </p>
</td></tr>
<tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fa4b9de95ee3087851acd98262e09f0be8" name="a331f41a3139a87d16e1422bc818c136fa4b9de95ee3087851acd98262e09f0be8"></a>kUnbounded&#160;</td><td class="fielddoc"><p>The primal is unbounded. </p>
</td></tr>
<tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fa84d10e8dce3328bfb1f6761d194857f2" name="a331f41a3139a87d16e1422bc818c136fa84d10e8dce3328bfb1f6761d194857f2"></a>kSolverSpecificError&#160;</td><td class="fielddoc"><p>Solver-specific error. </p>
<p>(Try <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html#accb663202a090d9ef76d04bda3433c03" title="Gets the solver details for the Solver that solved the program.">MathematicalProgramResult::get_solver_details()</a> or enabling verbose solver output.) </p>
</td></tr>
<tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fa2bfbc12cb546f78bd0080b8df5b26520" name="a331f41a3139a87d16e1422bc818c136fa2bfbc12cb546f78bd0080b8df5b26520"></a>kInfeasibleOrUnbounded&#160;</td><td class="fielddoc"><p>The primal is either infeasible or unbounded. </p>
</td></tr>
<tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fa97600ae7efdb5c8fecf91e99463ef4ef" name="a331f41a3139a87d16e1422bc818c136fa97600ae7efdb5c8fecf91e99463ef4ef"></a>kIterationLimit&#160;</td><td class="fielddoc"><p>Reaches the iteration limits. </p>
</td></tr>
<tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fae1f645d6b81b09a506f807a18d5e1d4b" name="a331f41a3139a87d16e1422bc818c136fae1f645d6b81b09a506f807a18d5e1d4b"></a>kDualInfeasible&#160;</td><td class="fielddoc"><p>Dual problem is infeasible. </p>
<p>In this case we cannot infer the status of the primal problem. </p>
</td></tr>
<tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fab42685181d035fb42e3da3462b4c0b55" name="a331f41a3139a87d16e1422bc818c136fab42685181d035fb42e3da3462b4c0b55"></a>kSolutionResultNotSet&#160;</td><td class="fielddoc"><p>The initial (invalid) solution result. </p>
<p>This value should be overwritten by the solver during <a class="el" href="#ae34d0e7febfca6328561574df6ce91d5" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a>. </p>
</td></tr>
</table>

</div>
</div>
<a id="a8b06041d7c1fb05f379714f4312306ec" name="a8b06041d7c1fb05f379714f4312306ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b06041d7c1fb05f379714f4312306ec">&#9670;&#160;</a></span>SolverType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a8b06041d7c1fb05f379714f4312306ec">SolverType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This type only exists for backwards compatibility, and should not be used in new code. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306ecaa71a8c0a25fe7a3d777fc06d50bada13" name="a8b06041d7c1fb05f379714f4312306ecaa71a8c0a25fe7a3d777fc06d50bada13"></a>kClp&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306ecae654b0ad8f79045aff33844a0c3cdf81" name="a8b06041d7c1fb05f379714f4312306ecae654b0ad8f79045aff33844a0c3cdf81"></a>kCsdp&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306eca71cedba88b736e372f499099329d5173" name="a8b06041d7c1fb05f379714f4312306eca71cedba88b736e372f499099329d5173"></a>kEqualityConstrainedQP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306ecabc8ddfb8a00bb405e68545ce187ac238" name="a8b06041d7c1fb05f379714f4312306ecabc8ddfb8a00bb405e68545ce187ac238"></a>kGurobi&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306ecaa1f0780f88b19c3a73710b47fc57d795" name="a8b06041d7c1fb05f379714f4312306ecaa1f0780f88b19c3a73710b47fc57d795"></a>kIpopt&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306ecaebb0e280cb0e7da8a3868247749a4d9d" name="a8b06041d7c1fb05f379714f4312306ecaebb0e280cb0e7da8a3868247749a4d9d"></a>kLinearSystem&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306ecabd0a61a2cf9acec23fccd41c7402ef56" name="a8b06041d7c1fb05f379714f4312306ecabd0a61a2cf9acec23fccd41c7402ef56"></a>kMobyLCP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306eca18bc9cbd9bb764958e636263b1b53a9d" name="a8b06041d7c1fb05f379714f4312306eca18bc9cbd9bb764958e636263b1b53a9d"></a>kMosek&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306eca64e0ff0ce277a08ed59a9fe9140a8fd7" name="a8b06041d7c1fb05f379714f4312306eca64e0ff0ce277a08ed59a9fe9140a8fd7"></a>kNlopt&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306eca6e645ae8d30d672d9800a422f4be4c9d" name="a8b06041d7c1fb05f379714f4312306eca6e645ae8d30d672d9800a422f4be4c9d"></a>kOsqp&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306eca6619293bd01e7ea8efb3682f16bf55c4" name="a8b06041d7c1fb05f379714f4312306eca6619293bd01e7ea8efb3682f16bf55c4"></a>kSnopt&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306ecad1ddb13aaaf649f197e0f6549596571c" name="a8b06041d7c1fb05f379714f4312306ecad1ddb13aaaf649f197e0f6549596571c"></a>kScs&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306eca045139748552611db2ba18934b6f89f6" name="a8b06041d7c1fb05f379714f4312306eca045139748552611db2ba18934b6f89f6"></a>kUnrevisedLemke&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ae57ef09daad0923021d5b9441b2e4c74" name="ae57ef09daad0923021d5b9441b2e4c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57ef09daad0923021d5b9441b2e4c74">&#9670;&#160;</a></span>AddBilinearProductMcCormickEnvelopeMultipleChoice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddBilinearProductMcCormickEnvelopeMultipleChoice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>phi_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>phi_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Bx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>By</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add constraints to the optimization program, such that the bilinear product x * y is approximated by w, using Mixed Integer constraint with "Multiple
   Choice" model. </p>
<p>To do so, we assume that the range of x is [x_min, x_max], and the range of y is [y_min, y_max]. We first consider two arrays φˣ, φʸ, satisfying </p><div class="fragment"><div class="line">x_min = φˣ₀ &lt; φˣ₁ &lt; ... &lt; φˣₘ = x_max</div>
<div class="line">y_min = φʸ₀ &lt; φʸ₁ &lt; ... &lt; φʸₙ = y_max</div>
</div><!-- fragment --><p> , and divide the range of x into intervals [φˣ₀, φˣ₁], [φˣ₁, φˣ₂], ... , [φˣₘ₋₁, φˣₘ] and the range of y into intervals [φʸ₀, φʸ₁], [φʸ₁, φʸ₂], ... , [φʸₙ₋₁, φʸₙ]. The xy plane is thus cut into rectangles, with each rectangle as [φˣᵢ, φˣᵢ₊₁] x [φʸⱼ, φʸⱼ₊₁]. The convex hull of the surface z = x * y for x, y in each rectangle is a tetrahedron. We then approximate the bilinear product x * y with w, such that (x, y, w) is in one of the tetrahedrons. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>The optimization problem to which the constraints will be added. </td></tr>
    <tr><td class="paramname">x</td><td>A variable in the bilinear product. </td></tr>
    <tr><td class="paramname">y</td><td>A variable in the bilinear product. </td></tr>
    <tr><td class="paramname">w</td><td>The expression that approximates the bilinear product x * y. </td></tr>
    <tr><td class="paramname">phi_x</td><td>φˣ in the documentation above. Will be used to cut the range of x into small intervals. </td></tr>
    <tr><td class="paramname">phi_y</td><td>φʸ in the documentation above. Will be used to cut the range of y into small intervals. </td></tr>
    <tr><td class="paramname">Bx</td><td>The binary-valued expression indicating which interval x is in. Bx(i) = 1 =&gt; φˣᵢ ≤ x ≤ φˣᵢ₊₁. </td></tr>
    <tr><td class="paramname">By</td><td>The binary-valued expression indicating which interval y is in. By(i) = 1 =&gt; φʸⱼ ≤ y ≤ φʸⱼ₊₁.</td></tr>
  </table>
  </dd>
</dl>
<p>One formulation of the constraint is </p><div class="fragment"><div class="line">x = ∑ᵢⱼ x̂ᵢⱼ</div>
<div class="line">y = ∑ᵢⱼ ŷᵢⱼ</div>
<div class="line">Bˣʸᵢⱼ = Bˣᵢ ∧ Bʸⱼ</div>
<div class="line">∑ᵢⱼ Bˣʸᵢⱼ = 1</div>
<div class="line">φˣᵢ Bˣʸᵢⱼ ≤ x̂ᵢⱼ ≤ φˣᵢ₊₁ Bˣʸᵢⱼ</div>
<div class="line">φʸⱼ Bˣʸᵢⱼ ≤ ŷᵢⱼ ≤ φʸⱼ₊₁ Bˣʸᵢⱼ</div>
<div class="line">w ≥ ∑ᵢⱼ (x̂ᵢⱼ φʸⱼ   + φˣᵢ   ŷᵢⱼ - φˣᵢ  φʸⱼ   Bˣʸᵢⱼ)</div>
<div class="line">w ≥ ∑ᵢⱼ (x̂ᵢⱼ φʸⱼ₊₁ + φˣᵢ₊₁ ŷᵢⱼ - φˣᵢ₊₁ φʸⱼ₊₁ Bˣʸᵢⱼ)</div>
<div class="line">w ≤ ∑ᵢⱼ (x̂ᵢⱼ φʸⱼ   + φˣᵢ₊₁ ŷᵢⱼ - φˣᵢ₊₁ φʸⱼ   Bˣʸᵢⱼ)</div>
<div class="line">w ≤ ∑ᵢⱼ (x̂ᵢⱼ φʸⱼ₊₁ + φˣᵢ   ŷᵢⱼ - φˣᵢ   φʸⱼ₊₁ Bˣʸᵢⱼ)</div>
</div><!-- fragment --><p>The "logical and" constraint Bˣʸᵢⱼ = Bˣᵢ ∧ Bʸⱼ can be imposed as </p><div class="fragment"><div class="line">Bˣʸᵢⱼ ≥ Bˣᵢ + Bʸⱼ - 1</div>
<div class="line">Bˣʸᵢⱼ ≤ Bˣᵢ</div>
<div class="line">Bˣʸᵢⱼ ≤ Bʸⱼ</div>
<div class="line">0 ≤ Bˣʸᵢⱼ ≤ 1</div>
</div><!-- fragment --><p> This formulation will introduce slack variables x̂, ŷ and Bˣʸ, in total 3 * m * n variables.</p>
<p>In order to reduce the number of slack variables, we can further simplify these constraints, by defining two vectors <span class="tt">x̅ ∈ ℝⁿ</span>, <span class="tt">y̅ ∈ ℝᵐ</span> as </p><div class="fragment"><div class="line">x̅ⱼ = ∑ᵢ x̂ᵢⱼ</div>
<div class="line">y̅ᵢ = ∑ⱼ ŷᵢⱼ</div>
</div><!-- fragment --><p> and the constraints above can be re-formulated using <span class="tt">x̅</span> and <span class="tt">y̅</span> as </p><div class="fragment"><div class="line">x = ∑ⱼ x̅ⱼ</div>
<div class="line">y = ∑ᵢ y̅ᵢ</div>
<div class="line">Bˣʸᵢⱼ = Bˣᵢ ∧ Bʸⱼ</div>
<div class="line">∑ᵢⱼ Bˣʸᵢⱼ = 1</div>
<div class="line">∑ᵢ φˣᵢ Bˣʸᵢⱼ ≤ x̅ⱼ ≤ ∑ᵢ φˣᵢ₊₁ Bˣʸᵢⱼ</div>
<div class="line">∑ⱼ φʸⱼ Bˣʸᵢⱼ ≤ y̅ᵢ ≤ ∑ⱼ φʸⱼ₊₁ Bˣʸᵢⱼ</div>
<div class="line">w ≥ ∑ⱼ( x̅ⱼ φʸⱼ   ) + ∑ᵢ( φˣᵢ   y̅ᵢ ) - ∑ᵢⱼ( φˣᵢ   φʸⱼ   Bˣʸᵢⱼ )</div>
<div class="line">w ≥ ∑ⱼ( x̅ⱼ φʸⱼ₊₁ ) + ∑ᵢ( φˣᵢ₊₁ y̅ᵢ ) - ∑ᵢⱼ( φˣᵢ₊₁ φʸⱼ₊₁ Bˣʸᵢⱼ )</div>
<div class="line">w ≤ ∑ⱼ( x̅ⱼ φʸⱼ   ) + ∑ᵢ( φˣᵢ₊₁ y̅ⱼ ) - ∑ᵢⱼ( φˣᵢ₊₁ φʸⱼ   Bˣʸᵢⱼ )</div>
<div class="line">w ≤ ∑ⱼ( x̅ⱼ φʸⱼ₊₁ ) + ∑ᵢ( φˣᵢ   y̅ᵢ ) - ∑ᵢⱼ( φˣᵢ   φʸⱼ₊₁ Bˣʸᵢⱼ ).</div>
</div><!-- fragment --><p> In this formulation, we introduce new continuous variables <span class="tt">x̅</span>, <span class="tt">y̅</span>, <span class="tt">Bˣʸ</span>. The total number of new variables is m + n + m * n.</p>
<p>In section 3.3 of Mixed-Integer Models for Nonseparable Piecewise Linear Optimization: Unifying Framework and Extensions by Juan P Vielma, Shabbir Ahmed and George Nemhauser, this formulation is called "Multiple Choice
   Model".</p>
<dl class="section note"><dt>Note</dt><dd>We DO NOT add the constraint Bx(i) ∈ {0, 1}, By(j) ∈ {0, 1} in this function. It is the user's responsibility to ensure that these binary constraints are enforced. The users can also add cutting planes ∑ᵢBx(i) = 1, ∑ⱼBy(j) = 1. Without these two cutting planes, (x, y, w) is still in the McCormick envelope of z = x * y, but these two cutting planes "might" improve the computation speed in the mixed-integer solver. </dd></dl>

</div>
</div>
<a id="a3e4a0b93fcb60733633a5187469ecaa2" name="a3e4a0b93fcb60733633a5187469ecaa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4a0b93fcb60733633a5187469ecaa2">&#9670;&#160;</a></span>AddBilinearProductMcCormickEnvelopeSos2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedPhiX, typename DerivedPhiY, typename DerivedBx, typename DerivedBy&gt; <br />
requires (<a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt;DerivedPhiX, double&gt;::value &amp;&amp; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt;DerivedPhiY, double&gt;::value &amp;&amp; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt;DerivedBx, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt;::value &amp;&amp; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt;DerivedBy, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt;::value)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto AddBilinearProductMcCormickEnvelopeSos2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedPhiX &amp;</td>          <td class="paramname"><span class="paramname"><em>phi_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedPhiY &amp;</td>          <td class="paramname"><span class="paramname"><em>phi_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedBx &amp;</td>          <td class="paramname"><span class="paramname"><em>Bx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedBy &amp;</td>          <td class="paramname"><span class="paramname"><em>By</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6297509967536d29159910e5c51fd285">IntervalBinning</a></td>          <td class="paramname"><span class="paramname"><em>binning</em></span>&#160;)-&gt;<a class="el" href="#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; DerivedPhiX::RowsAtCompileTime, DerivedPhiY::RowsAtCompileTime &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add constraints to the optimization program, such that the bilinear product x * y is approximated by w, using Special Ordered Set of Type 2 (sos2) constraint. </p>
<p>To do so, we assume that the range of x is [x_min, x_max], and the range of y is [y_min, y_max]. We first consider two arrays φˣ, φʸ, satisfying </p><div class="fragment"><div class="line">x_min = φˣ₀ &lt; φˣ₁ &lt; ... &lt; φˣₘ = x_max</div>
<div class="line">y_min = φʸ₀ &lt; φʸ₁ &lt; ... &lt; φʸₙ = y_max</div>
</div><!-- fragment --><p> , and divide the range of x into intervals [φˣ₀, φˣ₁], [φˣ₁, φˣ₂], ... , [φˣₘ₋₁, φˣₘ] and the range of y into intervals [φʸ₀, φʸ₁], [φʸ₁, φʸ₂], ... , [φʸₙ₋₁, φʸₙ]. The xy plane is thus cut into rectangles, with each rectangle as [φˣᵢ, φˣᵢ₊₁] x [φʸⱼ, φʸⱼ₊₁]. The convex hull of the surface z = x * y for x, y in each rectangle is a tetrahedron. We then approximate the bilinear product x * y with w, such that (x, y, w) is in one of the tetrahedrons.</p>
<p>We use two different encoding schemes on the binary variables, to determine which interval is active. We can choose either linear or logarithmic binning. When using linear binning, for a variable with N intervals, we use N binary variables, and B(i) = 1 indicates the variable is in the i'th interval. When using logarithmic binning, we use ⌈log₂(N)⌉ binary variables. If these binary variables represent integer M in the reflected Gray code, then the continuous variable is in the M'th interval. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>The program to which the bilinear product constraint is added </td></tr>
    <tr><td class="paramname">x</td><td>The decision variable. </td></tr>
    <tr><td class="paramname">y</td><td>The decision variable. </td></tr>
    <tr><td class="paramname">w</td><td>The expression to approximate x * y </td></tr>
    <tr><td class="paramname">phi_x</td><td>The end points of the intervals for <span class="tt">x</span>. </td></tr>
    <tr><td class="paramname">phi_y</td><td>The end points of the intervals for <span class="tt">y</span>. </td></tr>
    <tr><td class="paramname">Bx</td><td>The binary variables for the interval in which x stays encoded as described above. </td></tr>
    <tr><td class="paramname">By</td><td>The binary variables for the interval in which y stays encoded as described above. </td></tr>
    <tr><td class="paramname">binning</td><td>Determine whether to use linear binning or logarithmic binning. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lambda The auxiliary continuous variables.</dd></dl>
<p>The constraints we impose are </p><div class="fragment"><div class="line">x = (φˣ)ᵀ * ∑ⱼ λᵢⱼ</div>
<div class="line">y = (φʸ)ᵀ * ∑ᵢ λᵢⱼ</div>
<div class="line">w = ∑ᵢⱼ φˣᵢ * φʸⱼ * λᵢⱼ</div>
<div class="line">Both ∑ⱼ λᵢⱼ = λ.rowwise().sum() and ∑ᵢ λᵢⱼ = λ.colwise().sum() satisfy SOS2</div>
<div class="line">constraint.</div>
</div><!-- fragment --><p>If x ∈ [φx(M), φx(M+1)] and y ∈ [φy(N), φy(N+1)], then only λ(M, N), λ(M + 1, N), λ(M, N + 1) and λ(M+1, N+1) can be strictly positive, all other λ(i, j) are zero.</p>
<dl class="section note"><dt>Note</dt><dd>We DO NOT add the constraint Bx(i) ∈ {0, 1}, By(j) ∈ {0, 1} in this function. It is the user's responsibility to ensure that these constraints are enforced. </dd></dl>

</div>
</div>
<a id="aa188246c79aee1c77a289927b5518266" name="aa188246c79aee1c77a289927b5518266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa188246c79aee1c77a289927b5518266">&#9670;&#160;</a></span>AddBoundingBoxConstraintsImpliedByRollPitchYawLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddBoundingBoxConstraintsImpliedByRollPitchYawLimits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a55b1b3c88fe94fd28d7564b90f50a00f">RollPitchYawLimits</a></td>          <td class="paramname"><span class="paramname"><em>limits</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a1949f5edc628077e2d780c150de88d74a34bbac4b028a742de1b931cc2694dcea">kNoLimits</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies <em>very conservative</em> limits on the entries of R for the cases when rotations can be limited (for instance, if you want to search over rotations, but there is an obvious symmetry in the problem so that e.g. </p>
<p>0 &lt; pitch &lt; PI need not be considered). A matrix so constrained may still contain rotations outside of this envelope. Note: For simple rotational symmetry over PI, prefer kPitch_NegPI_2_to_PI_2 (over 0_to_PI) because it adds one more constraint (when combined with constraints on roll and yaw). Note: The Roll-Pitch-Yaw angles follow the convention in RollPitchYaw, namely extrinsic rotations about Space-fixed x-y-z axes, respectively. </p>

</div>
</div>
<a id="a1eb095f3eb55a66d0625b746c6e2ff54" name="a1eb095f3eb55a66d0625b746c6e2ff54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb095f3eb55a66d0625b746c6e2ff54">&#9670;&#160;</a></span>AddLogarithmicSos1Constraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddLogarithmicSos1Constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lambda</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXi &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binary_encoding</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the special ordered set of type 1 (SOS1) constraint. </p>
<p>Namely </p><pre>
  λ(0) + ... + λ(n-1) = 1
  λ(i) ≥ 0 ∀i
  ∃ j ∈ {0, 1, ..., n-1}, s.t λ(j) = 1
</pre><p> where one and only one of λ(i) is 1, all other λ(j) are 0. We will need to add ⌈log₂(n)⌉ binary variables, where n is the number of rows in λ. For more information, please refer to Modeling Disjunctive Constraints with a Logarithmic Number of Binary Variables and Constraints by J. Vielma and G. Nemhauser, 2011. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>The program to which the SOS1 constraint is added. </td></tr>
    <tr><td class="paramname">lambda</td><td>lambda is in SOS1. </td></tr>
    <tr><td class="paramname">y</td><td>The binary variables indicating which λ is positive. For a given assignment on the binary variable <span class="tt">y</span>, if (y(0), ..., y(⌈log₂(n)⌉) represents integer M in <span class="tt">binary_encoding</span>, then only λ(M) is positive. Namely, if (y(0), ..., y(⌈log₂(n)⌉) equals to binary_encoding.row(M), then λ(M) = 1 </td></tr>
    <tr><td class="paramname">binary_encoding</td><td>A n x ⌈log₂(n)⌉ matrix. binary_encoding.row(i) represents integer i. No two rows of <span class="tt">binary_encoding</span> can be the same. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code class="param">binary_encoding</code> has a non-binary entry (0, 1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa27ae5b43e2b6b52817d2b2cf05cb980" name="aa27ae5b43e2b6b52817d2b2cf05cb980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa27ae5b43e2b6b52817d2b2cf05cb980">&#9670;&#160;</a></span>AddLogarithmicSos1Constraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto AddLogarithmicSos1Constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_lambda</em></span>&#160;)-&gt;std::pair&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the special ordered set of type 1 (SOS1) constraint. </p>
<p>Namely </p><pre>
  λ(0) + ... + λ(n-1) = 1
  λ(i) ≥ 0 ∀i
  ∃ j ∈ {0, 1, ..., n-1}, s.t λ(j) = 1
</pre><p> where one and only one of λ(i) is 1, all other λ(j) are 0. We will need to add ⌈log₂(n)⌉ binary variables, where n is the number of rows in λ. For more information, please refer to Modeling Disjunctive Constraints with a Logarithmic Number of Binary Variables and Constraints by J. Vielma and G. Nemhauser, 2011. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>The program to which the SOS1 constraint is added. </td></tr>
    <tr><td class="paramname">num_lambda</td><td>n in the documentation above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(lambda, y) lambda is λ in the documentation above. Notice that λ are declared as continuous variables, but they only admit binary solutions. y are binary variables of size ⌈log₂(n)⌉. When this sos1 constraint is satisfied, suppose that λ(i)=1 and λ(j)=0 ∀ j≠i, then y is the Reflected Gray code of i. For example, suppose n = 8, i = 5, then y is a vector of size ⌈log₂(n)⌉ = 3, and the value of y is (1, 1, 0) which equals to 5 according to reflected Gray code. </dd></dl>

</div>
</div>
<a id="a7842718f7d87ab0164e182757e6ab2c9" name="a7842718f7d87ab0164e182757e6ab2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7842718f7d87ab0164e182757e6ab2c9">&#9670;&#160;</a></span>AddLogarithmicSos2Constraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; <br />
requires (<a class="el" href="structdrake_1_1is__eigen__vector__of.html">drake::is_eigen_vector_of</a>&lt;Derived, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt;::value)</div>
      <table class="memname">
        <tr>
          <td class="memname">auto AddLogarithmicSos2Constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lambda</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>binary_variable_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;y&quot;</span>&#160;)-&gt;typenameLogarithmicSos2NewBinaryVariables&lt; Derived::RowsAtCompileTime &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the special ordered set 2 (SOS2) constraint,. </p>
<pre>
  λ(0) + ... + λ(n) = 1
  ∀i. λ(i) ≥ 0
  ∃ j ∈ {0, 1, ..., n-1}, s.t λ(i) = 0 if i ≠ j and i ≠ j + 1
</pre><p> Namely at most two entries in λ can be strictly positive, and these two entries have to be adjacent. All other λ should be zero. Moreover, the non-zero λ satisfies λ(j) + λ(j + 1) = 1. We will need to add ⌈log₂(n - 1)⌉ binary variables, where n is the number of rows in λ. For more information, please refer to Modeling Disjunctive Constraints with a Logarithmic Number of Binary Variables and Constraints by J. Vielma and G. Nemhauser, 2011. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>Add the SOS2 constraint to this mathematical program. </td></tr>
    <tr><td class="paramname">lambda</td><td>At most two entries in λ can be strictly positive, and these two entries have to be adjacent. All other entries are zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>y The newly added binary variables. The assignment of the binary variable y implies which two λ can be strictly positive. With a binary assignment on y, and suppose the integer M corresponds to (y(0), y(1), ..., y(⌈log₂(n - 1)⌉)) in Gray code, then only λ(M) and λ(M + 1) can be non-zero. For example, if the assignment of y = (1, 1), in Gray code, (1, 1) represents integer 2, so only λ(2) and λ(3) can be strictly positive. </dd></dl>

</div>
</div>
<a id="a5ff27667ee8e19ab9af9f4134a5213bd" name="a5ff27667ee8e19ab9af9f4134a5213bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff27667ee8e19ab9af9f4134a5213bd">&#9670;&#160;</a></span>AddLogarithmicSos2Constraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddLogarithmicSos2Constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lambda</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the special ordered set 2 (SOS2) constraint,. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7842718f7d87ab0164e182757e6ab2c9" title="Adds the special ordered set 2 (SOS2) constraint,.">AddLogarithmicSos2Constraint</a>. </dd></dl>

</div>
</div>
<a id="aada9e5deeaf832076592970c0ccc1676" name="aada9e5deeaf832076592970c0ccc1676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada9e5deeaf832076592970c0ccc1676">&#9670;&#160;</a></span>AddRotationMatrixBoxSphereIntersectionMilpConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1solvers_1_1_add_rotation_matrix_box_sphere_intersection_return.html">AddRotationMatrixBoxSphereIntersectionReturn</a> AddRotationMatrixBoxSphereIntersectionMilpConstraints </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_intervals_per_half_axis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds binary variables that constrain the value of the column <em>and</em> row vectors of R, in order to add the following (in some cases non-convex) constraints as an MILP. </p>
<p>Specifically, for column vectors Ri, we constrain:</p>
<ul>
<li>forall i, |Ri| = 1 ± envelope,</li>
<li>forall i,j. i ≠ j, Ri.dot(Rj) = 0 ± envelope,</li>
<li>R2 = R0.cross(R1) ± envelope, and again for R0=R1.cross(R2), and R1=R2.cross(R0).</li>
</ul>
<p>Then all of the same constraints are also added to R^T. The size of the envelope decreases quickly as num_binary_variables_per_half_axis is is increased.</p>
<dl class="section note"><dt>Note</dt><dd>Creates <span class="tt">9*2*num_binary_variables_per_half_axis binary</span> variables named "BRpos*(*,*)" and "BRneg*(*,*)", and the same number of continuous variables named "CRpos*(*,*)" and "CRneg*(*,*)".</dd>
<dd>
The particular representation/algorithm here was developed in an attempt:<ul>
<li>to enable efficient reuse of the variables between the constraints between multiple rows/columns (e.g. the constraints on Rᵀ use the same variables as the constraints on R), and</li>
<li>to facilitate branch-and-bound solution techniques &ndash; binary regions are layered so that constraining one region establishes constraints on large portions of SO(3), and confers hopefully "useful" constraints the on other binary variables. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>The rotation matrix </td></tr>
    <tr><td class="paramname">num_intervals_per_half_axis</td><td>number of intervals for a half axis. </td></tr>
    <tr><td class="paramname">prog</td><td>The mathematical program to which the constraints are added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method uses the same approach as <a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_rotation_constraint_generator.html" title="We relax the non-convex SO(3) constraint on rotation matrix R to mixed-integer linear constraints.">MixedIntegerRotationConstraintGenerator</a> with kBoxSphereIntersection, namely the feasible sets to both relaxation are the same. But they use different sets of binary variables, and thus the computation speed can be different inside optimization solvers. </dd></dl>

</div>
</div>
<a id="a173bf985ebdce58dcea4df5885490dc8" name="a173bf985ebdce58dcea4df5885490dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173bf985ebdce58dcea4df5885490dc8">&#9670;&#160;</a></span>AddRotationMatrixOrthonormalSocpConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddRotationMatrixOrthonormalSocpConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a set of convex constraints which approximate the set of orthogonal matrices, O(3). </p>
<p>Adds the bilinear constraints that the each column Ri has length &lt;= 1 and that Ri'Rj approx 0 via -2 + |Ri|^2 + |Rj|^2 &lt;= 2Ri'Rj &lt;= 2 - |Ri|^2 - |Rj|^2 (for all i!=j), using a second-order-cone relaxation. Additionally, the same constraints are applied to all of the rows. </p>

</div>
</div>
<a id="a83559ace7ba26c28b6a7dc536e8b6de0" name="a83559ace7ba26c28b6a7dc536e8b6de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83559ace7ba26c28b6a7dc536e8b6de0">&#9670;&#160;</a></span>AddRotationMatrixSpectrahedralSdpConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddRotationMatrixSpectrahedralSdpConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>R</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraint (10) from <a href="https://arxiv.org/pdf/1403.4914.pdf">https://arxiv.org/pdf/1403.4914.pdf</a> , which exactly represents the convex hull of all rotation matrices in 3D. </p>

</div>
</div>
<a id="ada666e00bb20bccef0f87e0a56712c57" name="ada666e00bb20bccef0f87e0a56712c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada666e00bb20bccef0f87e0a56712c57">&#9670;&#160;</a></span>AddSos2Constraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AddSos2Constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lambda</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the special ordered set 2 (SOS2) constraint. </p>
<p>y(i) takes binary values (either 0 or 1). </p><pre>
  y(i) = 1 =&gt; λ(i) + λ(i + 1) = 1.
</pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7842718f7d87ab0164e182757e6ab2c9" title="Adds the special ordered set 2 (SOS2) constraint,.">AddLogarithmicSos2Constraint</a> for a complete explanation on SOS2 constraint. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>The optimization program to which the SOS2 constraint is added. </td></tr>
    <tr><td class="paramname">lambda</td><td>At most two entries in λ can be strictly positive, and these two entries have to be adjacent. All other entries are zero. Moreover, these two entries should sum up to 1. </td></tr>
    <tr><td class="paramname">y</td><td>y(i) takes binary value, and determines which two entries in λ can be strictly positive. Throw a runtime error if y.rows() != lambda.rows() - 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a886abb8ddadab85980c4cb7d687cf1e9" name="a886abb8ddadab85980c4cb7d687cf1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886abb8ddadab85980c4cb7d687cf1e9">&#9670;&#160;</a></span>AggregateBoundingBoxConstraints() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AggregateBoundingBoxConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd *</td>          <td class="paramname"><span class="paramname"><em>lower</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd *</td>          <td class="paramname"><span class="paramname"><em>upper</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aggregates all the BoundingBoxConstraints inside <code class="param">prog</code>, returns the intersection of the bounding box constraints as the lower and upper bound for each variable in <code class="param">prog</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">prog</td><td>The optimization program containing decision variables and BoundingBoxConstraints. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lower</td><td>(*lower)[i] is the lower bound of prog.decision_variable(i). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">upper</td><td>(*upper)[i] is the upper bound of prog.decision_variable(i). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68b12677c76a5bb950270a506601d3d3" name="a68b12677c76a5bb950270a506601d3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b12677c76a5bb950270a506601d3d3">&#9670;&#160;</a></span>AggregateBoundingBoxConstraints() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AggregateBoundingBoxConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; *</td>          <td class="paramname"><span class="paramname"><em>lower</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; *</td>          <td class="paramname"><span class="paramname"><em>upper</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads AggregateBoundingBoxConstraints, but the type of lower and upper are std::vector&lt;double&gt;. </p>

</div>
</div>
<a id="acdb6bda41a9c96928ceba8fa56b37e94" name="acdb6bda41a9c96928ceba8fa56b37e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb6bda41a9c96928ceba8fa56b37e94">&#9670;&#160;</a></span>AggregateBoundingBoxConstraints() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>, <a class="el" href="structdrake_1_1solvers_1_1_bound.html">Bound</a> &gt; AggregateBoundingBoxConstraints </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bounding_box_constraints</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aggregates many bounding box constraints, returns the intersection (the tightest bounds) of these constraints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bounding_box_constraints</td><td>The constraints to be aggregated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">aggregated_bounds</td><td>aggregated_bounds[var.get_id()] returns the (lower, upper) bounds of that variable as the tightest bounds of <code class="param">bounding_box_constraints</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae47924d35c8e0ca9af2c5e12d1d2f217" name="ae47924d35c8e0ca9af2c5e12d1d2f217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47924d35c8e0ca9af2c5e12d1d2f217">&#9670;&#160;</a></span>AggregateDuplicateVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AggregateDuplicateVariables </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; double &gt; *</td>          <td class="paramname"><span class="paramname"><em>A_new</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>vars_new</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For linear expression A * vars where <span class="tt">vars</span> might contain duplicated entries, rewrite this linear expression as A_new * vars_new where vars_new doesn't contain duplicated entries. </p>

</div>
</div>
<a id="a327c1374c023a7401092ae0b6e4b83f8" name="a327c1374c023a7401092ae0b6e4b83f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327c1374c023a7401092ae0b6e4b83f8">&#9670;&#160;</a></span>AggregateLinearCosts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AggregateLinearCosts </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>linear_costs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseVector&lt; double &gt; *</td>          <td class="paramname"><span class="paramname"><em>linear_coeff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>constant_cost</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given many linear costs, aggregate them into. </p>
<p>aᵀ*x + b, </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">linear_costs</td><td>the linear costs to be aggregated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">linear_coeff</td><td>a in the documentation above. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vars</td><td>x in the documentation above. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">constant_cost</td><td>b in the documentation above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc7a90e544994241a62e70e433acba6b" name="acc7a90e544994241a62e70e433acba6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7a90e544994241a62e70e433acba6b">&#9670;&#160;</a></span>AggregateQuadraticAndLinearCosts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AggregateQuadraticAndLinearCosts </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quadratic_costs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>linear_costs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; double &gt; *</td>          <td class="paramname"><span class="paramname"><em>Q_lower</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>quadratic_vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseVector&lt; double &gt; *</td>          <td class="paramname"><span class="paramname"><em>linear_coeff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>linear_vars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>constant_cost</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given many linear and quadratic costs, aggregate them into. </p>
<p>0.5*x₁ᵀQx₁ + bᵀx₂ + c where x₁ and x₂ don't need to be the same. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">quadratic_costs</td><td>The quadratic costs to be aggregated. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">linear_costs</td><td>The linear costs to be aggregated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q_lower</td><td>The lower triangular part of the matrix Q. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">quadratic_vars</td><td>x₁ in the documentation above. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">linear_coeff</td><td>b in the documentation above. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">linear_vars</td><td>x₂ in the documentation above. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">constant_cost</td><td>c in the documentation above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fec9540703ed86e335009f64d963f16" name="a6fec9540703ed86e335009f64d963f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fec9540703ed86e335009f64d963f16">&#9670;&#160;</a></span>AreRequiredAttributesSupported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AreRequiredAttributesSupported </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>required</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>supported</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>unsupported_message</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff <code class="param">required</code> is a subset of <code class="param">supported</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">unsupported_message</td><td>(Optional) When provided, if this function returns false, the message will be set to a phrase describing the unsupported attributes; or if this function returns true, the message will be set to the empty string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a394e6ba5988e7a7f9f5800798ecf47c8" name="a394e6ba5988e7a7f9f5800798ecf47c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394e6ba5988e7a7f9f5800798ecf47c8">&#9670;&#160;</a></span>CeilLog2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CeilLog2 </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return ⌈log₂(n)⌉, namely the minimal integer no smaller than log₂(n), with base 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A positive integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimal integer no smaller than log₂(n). </dd></dl>

</div>
</div>
<a id="a5ad49ccf0a41d8b2ee1ecb197479356e" name="a5ad49ccf0a41d8b2ee1ecb197479356e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad49ccf0a41d8b2ee1ecb197479356e">&#9670;&#160;</a></span>ChooseBestSolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> ChooseBestSolver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>prog</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Choose the best solver given the formulation in the optimization program and the availability of the solvers. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there is no available solver for <code class="param">prog</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af625a7985e13112d4eb9c0ec49c15fa2" name="af625a7985e13112d4eb9c0ec49c15fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af625a7985e13112d4eb9c0ec49c15fa2">&#9670;&#160;</a></span>ConcatenateIndeterminatesRefList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a> ConcatenateIndeterminatesRefList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a07f638392fbe039dbe92d324303292a4">IndeterminatesRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var_list</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates each element in <code class="param">var_list</code> into a single Eigen vector of indeterminates, returns this concatenated vector. </p>

</div>
</div>
<a id="a68452fe0431657d5c5473a7267377181" name="a68452fe0431657d5c5473a7267377181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68452fe0431657d5c5473a7267377181">&#9670;&#160;</a></span>ConcatenateVariableRefList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> ConcatenateVariableRefList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a81ee3f72946092b0f97d9cb4753a91f0">VariableRefList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var_list</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates each element in <code class="param">var_list</code> into a single Eigen vector of decision variables, returns this concatenated vector. </p>

</div>
</div>
<a id="a59990839e673f511a23b540f9067a93b" name="a59990839e673f511a23b540f9067a93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59990839e673f511a23b540f9067a93b">&#9670;&#160;</a></span>ConstructMonomialBasis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">drake::VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt; ConstructMonomialBasis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">drake::symbolic::Polynomial</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given input polynomial p, outputs a set M of monomials with the following guarantee: if p = f1*f1 + f2*f2 + ... + fn*fn for some (unknown) polynomials f1, f2, ..., fn, then the span of M contains f1, f2, ..., fn, Given M, one can then find the polynomials fi using semidefinite programming; see, e.g., Chapter 3 of Semidefinite Optimization and Convex Algebraic Geometry by G. </p>
<p>Blekherman, P. Parrilo, R. Thomas. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector whose entries are the elements of M </dd></dl>

</div>
</div>
<a id="aa9ade4e3ddb4bb380d8a732f462f3988" name="aa9ade4e3ddb4bb380d8a732f462f3988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ade4e3ddb4bb380d8a732f462f3988">&#9670;&#160;</a></span>CreateBinaryCodeMatchConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; CreateBinaryCodeMatchConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>expected</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>match</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create linear constraints such that, when these constraints are satisfied, match = 1 if and only if code == expected, otherwise match = 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>code(i) should only take binary values. </td></tr>
    <tr><td class="paramname">expected</td><td>The expected matched value for code. </td></tr>
    <tr><td class="paramname">match</td><td>an expression that takes binary value, representing if code == expected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the linear constraints.</dd></dl>
<p>This function is useful integer optimization, for example, if we have a constraint match = ((b1 == 0) &amp;&amp; (b2 == 1) &amp;&amp; (b3 == 1)), we can call the function CreateBinaryCodeMatchConstraint({b1, b2, b3}, {0, 1, 1}, match) to create the constraint. </p>

</div>
</div>
<a id="aebc1de9951001044e9fbbae8e2eb715f" name="aebc1de9951001044e9fbbae8e2eb715f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc1de9951001044e9fbbae8e2eb715f">&#9670;&#160;</a></span>CreateLogicalAndConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; CreateLogicalAndConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b1_and_b2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds linear constraints, such that when b1, b2, b1_and_b2 satisfy the constraints, and b1, b2 take binary values, it is guaranteed that b1_and_b2 = b1 ∧ b2 (b1 and b2). </p>
<p>The constraints are </p><pre>
  b1_and_b2 &gt;= b1 + b2 - 1
  b1_and_b2 &lt;= b1
  b1_and_b2 &lt;= b2
  0 &lt;= b1_and_b2 &lt;= 1
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b1</td><td>An expression that should only take a binary value. </td></tr>
    <tr><td class="paramname">b2</td><td>An expression that should only take a binary value. </td></tr>
    <tr><td class="paramname">b1_and_b2</td><td>Should be the logical and between <span class="tt">b1</span> and <span class="tt">b2</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added constraints, such that when b1, b2, b1_and_b2 satisfy the constraints, it is guaranteed that b1_and_b2 = b1 ∧ b2. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>b1, b2, b1_and_b2 are all linear expressions. </dd></dl>

</div>
</div>
<a id="aa6a4bae896f4f776721c48ad4222eddb" name="aa6a4bae896f4f776721c48ad4222eddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a4bae896f4f776721c48ad4222eddb">&#9670;&#160;</a></span>CreateLogicalOrConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; CreateLogicalOrConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b1_or_b2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds linear constraints, such that when b1, b2, b1_or_b2 satisfy the constraints, and b1, b2 take binary values, it is guaranteed that b1_or_b2 = b1 ∨ b2 (b1 or b2). </p>
<p>The constraints are </p><pre>
  b1_or_b2 &lt;= b1 + b2
  b1_or_b2 &gt;= b1
  b1_or_b2 &gt;= b2
  0 &lt;= b1_or_b2 &lt;= 1
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b1</td><td>An expression that should only take a binary value. </td></tr>
    <tr><td class="paramname">b2</td><td>An expression that should only take a binary value. </td></tr>
    <tr><td class="paramname">b1_or_b2</td><td>Should be the logical or between <span class="tt">b1</span> and <span class="tt">b2</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added constraints, such that when b1, b2, b1_or_b2 satisfy the constraints, it is guaranteed that b1_or_b2 = b1 ∨ b2. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>b1, b2, b1_or_b2 are all linear expressions. </dd></dl>

</div>
</div>
<a id="a95e1c79a22de687bad6ec057223e334b" name="a95e1c79a22de687bad6ec057223e334b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e1c79a22de687bad6ec057223e334b">&#9670;&#160;</a></span>CreateLogicalXorConstraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; CreateLogicalXorConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b1_xor_b2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add linear constraints, such that when b1, b2, b1_xor_b2 satisfy the constraints, and b1, b2 take binary values, it is guaranteed that b1_xor_b2 = b1 ⊕ b2 (b1 exclusive xor b2). </p>
<p>The constraints are </p><pre>
  b1_xor_b2 &lt;= b1 + b2
  b1_xor_b2 &gt;= b1 - b2
  b1_xor_b2 &gt;= b2 - b1
  b1_xor_b2 &lt;= 2 - b1 - b2
  0 &lt;= b1_xor_b2 &lt;= 1
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b1</td><td>An expression that should only take a binary value. </td></tr>
    <tr><td class="paramname">b2</td><td>An expression that should only take a binary value. </td></tr>
    <tr><td class="paramname">b1_xor_b2</td><td>Should be the logical exclusive or between <span class="tt">b1</span> and <span class="tt">b2</span>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added constraints, such that when b1, b2, b1_xor_b2 satisfy the constraints, it is guaranteed that b1_xor_b2 = b1 ⊕ b2. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>b1, b2, b1_xor_b2 are all linear expressions. </dd></dl>

</div>
</div>
<a id="a0a5158190138557c3a90f95ef426c308" name="a0a5158190138557c3a90f95ef426c308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5158190138557c3a90f95ef426c308">&#9670;&#160;</a></span>DecomposeNonConvexQuadraticForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; Eigen::MatrixXd, Eigen::MatrixXd &gt; DecomposeNonConvexQuadraticForm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a non-convex homogeneous quadratic form xᵀQx, where Q is not necessarily a positive semidefinite matrix, we decompose it as a difference between two convex homogeneous quadratic forms xᵀQx = xᵀQ₁x - xᵀQ₂x, Q₁, Q₂ are positive semidefinite. </p>
<p>To find the optimal Q₁ and Q₂, we solve the following semidefinite programming problem min s s.t s &gt;= trace(Q₁) s &gt;= trace(Q₂) Q₁ - Q₂ = (Q + Qᵀ) / 2 Q₁, Q₂ are positive semidefinite The decomposition Q = Q₁ - Q₂ can be used later, to solve the non-convex optimization problem involving a quadratic form xᵀQx. For more information, please refer to the papers on difference of convex decomposition, for example Undominated d.c Decompositions of Quadratic Functions and Applications to Branch-and-Bound Approaches By I.M.Bomze and M. Locatelli Computational Optimization and Applications, 2004 DC Decomposition of Nonconvex Polynomials with Algebraic Techniques By A. A. Ahmadi and G. Hall Mathematical Programming, 2015 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td>A square matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if Q is not square. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The optimal decomposition (Q₁, Q₂) </dd></dl>

</div>
</div>
<a id="a1842dff572de2f867c53c0c8d272ae80" name="a1842dff572de2f867c53c0c8d272ae80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1842dff572de2f867c53c0c8d272ae80">&#9670;&#160;</a></span>EnumerateIntegerSolutions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; int, -1, -1, Eigen::RowMajor &gt; EnumerateIntegerSolutions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXi &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lower_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all integer solutions x to the linear inequalities. </p>
<pre>
                   Ax &lt;= b,
                   x &lt;= upper_bound,
                   x &gt;= lower_bound.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>An (m x n) integer matrix. </td></tr>
    <tr><td class="paramname">b</td><td>An (m x 1) integer vector. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>A (n x 1) integer vector. </td></tr>
    <tr><td class="paramname">lower_bound</td><td>A (n x 1) integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A (p x n) matrix whose rows are the solutions. </dd></dl>

</div>
</div>
<a id="af82f700d069a4e17f3413cb7d135d031" name="af82f700d069a4e17f3413cb7d135d031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82f700d069a4e17f3413cb7d135d031">&#9670;&#160;</a></span>ExponentiallySmoothedHingeLoss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ExponentiallySmoothedHingeLoss </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>penalty</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>dpenalty_dx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A hinge loss function smoothed by exponential function. </p>
<p>This loss function is differentiable everywhere. The formulation is described in section II.C of [2]. The penalty is </p><pre class="unicode-art">
       ⎧ 0            if x ≥ 0
φ(x) = ⎨
       ⎩ -x exp(1/x)  if x &lt; 0.
</pre><p> [2] "Whole-body Motion Planning with Centroidal Dynamics and Full
Kinematics" by Hongkai Dai, Andres Valenzuela and Russ Tedrake, IEEE-RAS International Conference on Humanoid Robots, 2014. </p>

</div>
</div>
<a id="afb682968b9ebcdeebdc42676227af765" name="afb682968b9ebcdeebdc42676227af765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb682968b9ebcdeebdc42676227af765">&#9670;&#160;</a></span>GenerateSDPA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GenerateSDPA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>file_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a121673ddbdadd10b2e3ceab52a93f5d3">RemoveFreeVariableMethod</a></td>          <td class="paramname"><span class="paramname"><em>method</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a121673ddbdadd10b2e3ceab52a93f5d3a54b9d7601ece96fc42e2ffd67aae2690">RemoveFreeVariableMethod::kNullspace</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SDPA is a format to record an SDP problem. </p>
<pre class="fragment">max tr(C*X)
s.t tr(Aᵢ*X) = gᵢ
    X ≽ 0
</pre><p>or the dual of the problem </p><pre class="fragment">min gᵀy
s.t ∑ᵢ yᵢAᵢ - C ≽ 0
</pre><p>where X is a symmetric block diagonal matrix. The format is described in <a href="http://plato.asu.edu/ftp/sdpa_format.txt">http://plato.asu.edu/ftp/sdpa_format.txt</a>. Many solvers, such as CSDP, DSDP, SDPA, sedumi and SDPT3, accept an SDPA format file as the input. This function reads a <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> that can be formulated as above, and write an SDPA file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>a program that contains an optimization program. </td></tr>
    <tr><td class="paramname">file_name</td><td>The name of the file, note that the extension will be added automatically. </td></tr>
    <tr><td class="paramname">method</td><td>If <code class="param">prog</code> contains free variables (i.e., variables without bounds), then we need to remove these free variables to write the program in the SDPA format. Please refer to <a class="el" href="#a121673ddbdadd10b2e3ceab52a93f5d3" title="SDPA format doesn&#39;t accept free variables, namely the problem it solves is in this form P1.">RemoveFreeVariableMethod</a> for details on how to remove the free variables. <br  />
 <em class="arg">Default:</em> is <a class="el" href="#a121673ddbdadd10b2e3ceab52a93f5d3a54b9d7601ece96fc42e2ffd67aae2690" title="Approach 2, reformulate the dual problem by considering the nullspace of the linear constraint in the...">RemoveFreeVariableMethod::kNullspace</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">is_success.</td><td>Returns true if we can generate the SDPA file. The failure could be<ol type="1">
<li><code class="param">prog</code> cannot be captured by the formulation above.</li>
<li><code class="param">prog</code> cannot create a file with the given name, etc. </li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0239a4e08f44cc440b9b87b673cc1ca" name="ad0239a4e08f44cc440b9b87b673cc1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0239a4e08f44cc440b9b87b673cc1ca">&#9670;&#160;</a></span>GetAvailableSolvers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &gt; GetAvailableSolvers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15">ProgramType</a></td>          <td class="paramname"><span class="paramname"><em>prog_type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the list of available and enabled solvers that definitely accept all programs of the given program type. </p>
<p>The order of the returned SolverIds reflects an approximate order of preference, from most preferred (front) to least preferred (back). Because we are analyzing only based on the program type rather than a specific program, it's possible that solvers later in the list would perform better in certain situations. To obtain the truly best solver, using <a class="el" href="#a5ad49ccf0a41d8b2ee1ecb197479356e" title="Choose the best solver given the formulation in the optimization program and the availability of the ...">ChooseBestSolver()</a> instead. </p><dl class="section note"><dt>Note</dt><dd>If a solver only accepts a subset of the program type, then that solver is not included in the returned results. For example <a class="el" href="classdrake_1_1solvers_1_1_equality_constrained_q_p_solver.html" title="Solves a quadratic program with equality constraint.">EqualityConstrainedQPSolver</a> doesn't accept programs with inequality linear constraints, so it doesn't show up in the return of GetAvailableSolvers(ProgramType::kQP). </dd></dl>

</div>
</div>
<a id="ac96894b2d363452c15d82857102ac460" name="ac96894b2d363452c15d82857102ac460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96894b2d363452c15d82857102ac460">&#9670;&#160;</a></span>GetKnownSolvers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &gt; &amp; GetKnownSolvers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of solvers known to ChooseBestSolver. </p>

</div>
</div>
<a id="a3ccbbc5523e1562a301d0e0e7a7beb52" name="a3ccbbc5523e1562a301d0e0e7a7beb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ccbbc5523e1562a301d0e0e7a7beb52">&#9670;&#160;</a></span>GetProgramType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15">ProgramType</a> GetProgramType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>prog</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type of the optimization program (LP, QP, etc), based on the properties of its cost/constraints/variables. </p>
<p>Each mathematical program should be characterized by a unique type. If a program can be characterized as either type A or type B (for example, a program with linear constraint and linear costs can be characterized as either an LP or an SDP), then we choose the type corresponding to a smaller set of programs (LP in this case). </p>

</div>
</div>
<a id="a6659fb507e1cc8a0d0d78648c09c5993" name="a6659fb507e1cc8a0d0d78648c09c5993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6659fb507e1cc8a0d0d78648c09c5993">&#9670;&#160;</a></span>GetVariableValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; <br />
requires (std::is_same_v&lt;typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#aae413ce2f94f0ecb301727a6781b69ff">MatrixLikewise</a>&lt; double, Derived &gt; GetVariableValue </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>variable_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>variable_values</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload <a class="el" href="#a42c918b5a6318c3cd1f04cf2904a12aa" title="Retrieve the value of a single variable var from variable_values.">GetVariableValue()</a> function, but for an Eigen matrix of decision variables. </p>

</div>
</div>
<a id="a42c918b5a6318c3cd1f04cf2904a12aa" name="a42c918b5a6318c3cd1f04cf2904a12aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c918b5a6318c3cd1f04cf2904a12aa">&#9670;&#160;</a></span>GetVariableValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GetVariableValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>variable_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>variable_values</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the value of a single variable <code class="param">var</code> from <code class="param">variable_values</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The variable whose value is going to be retrieved. <code class="param">var.get_id()</code> must be a key in <code class="param">variable_index</code>. </td></tr>
    <tr><td class="paramname">variable_index</td><td>maps the variable ID to its index in <code class="param">variable_values</code>. </td></tr>
    <tr><td class="paramname">variable_values</td><td>The values of all variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variable_values(variable_index[var.get_id()]) if var.get_id() is a valid key of <code class="param">variable_index</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if var.get_id() is not a valid key of <code class="param">variable_index</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All the mapped value in variable_index is in the range [0, variable_values.rows()) </dd></dl>

</div>
</div>
<a id="af70d41b17760217e0926be91e74c7516" name="af70d41b17760217e0926be91e74c7516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70d41b17760217e0926be91e74c7516">&#9670;&#160;</a></span>MakeFirstAvailableSolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">SolverInterface</a> &gt; MakeFirstAvailableSolver </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>solver_ids</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the first available and enabled solver. </p>
<p>If no solvers are available, throws a std::exception. </p>

</div>
</div>
<a id="a00a0c7751190c2af67a99e49b5049eb0" name="a00a0c7751190c2af67a99e49b5049eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a0c7751190c2af67a99e49b5049eb0">&#9670;&#160;</a></span>MakeSemidefiniteRelaxation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &gt; MakeSemidefiniteRelaxation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1solvers_1_1_semidefinite_relaxation_options.html">SemidefiniteRelaxationOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> which represents the semidefinite programming convex relaxation of the (likely nonconvex) program <span class="tt">prog</span>. </p>
<p>This method currently supports only linear and quadratic costs and constraints, but may be extended in the future with broader support.</p>
<p>See <a href="https://underactuated.mit.edu/optimization.html#sdp_relaxation">https://underactuated.mit.edu/optimization.html#sdp_relaxation</a> for references and examples.</p>
<p>Note: Currently, programs using <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html" title="Implements a constraint of the form .">LinearEqualityConstraint</a> will give tighter relaxations than programs using <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html" title="Implements a constraint of the form .">LinearConstraint</a> or <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html" title="Implements a constraint of the form .">BoundingBoxConstraint</a>, even if lower_bound == upper_bound. Prefer <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html" title="Implements a constraint of the form .">LinearEqualityConstraint</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">prog</span> has costs and constraints which are not linear nor quadratic. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a167049ac9ec0cd87f0eb86ffdf5a656b" name="a167049ac9ec0cd87f0eb86ffdf5a656b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167049ac9ec0cd87f0eb86ffdf5a656b">&#9670;&#160;</a></span>MakeSemidefiniteRelaxation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &gt; MakeSemidefiniteRelaxation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>variable_groups</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1solvers_1_1_semidefinite_relaxation_options.html">SemidefiniteRelaxationOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A version of MakeSemidefiniteRelaxation that allows for specifying the sparsity of the relaxation. </p>
<p>For each group in <code class="param">variable_groups</code>, the costs and constraints whose variables are a subset of the group will be jointly relaxed into a single, dense semidefinite program in the same manner as MakeSemidefiniteRelaxation(prog).</p>
<p>Each of these semidefinite relaxations are aggregated into a single program, and their semidefinite variables are made to agree where the variable groups overlap.</p>
<p>The returned program will always have the same number of PSD variables as variable groups.</p>
<p>Costs and constraints whose variables are not a subset of any of the groups are not relaxed and are simply added to the aggregated program. If these costs and constraints are non-convex, then this method will throw.</p>
<p>As an example, consider the following program. min x₂ᵀ * Q * x₂ subject to x₁ + x₂ ≤ 1 x₂ + x₃ ≤ 2 x₁ + x₃ ≤ 3</p>
<p>And suppose we call MakeSemidefiniteRelaxation(prog, std::vector&lt;Variables&gt;{{x₁, x₂}, {x₂,x₃}}).</p>
<p>The resulting relaxation would have two semidefinite variables, namely: [U₁, U₂, x₁] [W₁, W₂, x₂] [U₂, U₃, x₂], [W₂, W₃, x₃] [x₁ᵀ, x₂ᵀ, 1] [x₂ᵀ, x₃ᵀ, 1]</p>
<p>The first semidefinite variable would be associated to the semidefinite relaxation of the subprogram: min x₁ᵀ * Q * x₁ subject to x₁ + x₂ ≤ 1 And the implied constraints from x₁ + x₂ ≤ 1 would be added to the first semidefinite variable. These implied constraints are additional constraints that can be placed on the matrix [U₁, U₂, x₁] [U₂, U₃, x₂] [x₁ᵀ, x₂ᵀ, 1] which are redundant in the non-convex program, but are not redundant in the semidefinite relaxation. See <a href="https://underactuated.mit.edu/optimization.html#sdp_relaxation">https://underactuated.mit.edu/optimization.html#sdp_relaxation</a> for references and examples.</p>
<p>The second semidefinite variable would be associated to the semidefinite relaxation of the subprogram: min x₂ᵀ * Q * x₂ subject to x₂ + x₃ ≤ 2 And the implied constraints from x₂ + x₃ ≤ 2 would be added to the second semidefinite variable.</p>
<p>Since the constraint x₁ + x₃ ≤ 3 is not a subset of any of the variable groups, it will be added to the overall relaxation, but will not be used to generate implied constraints on any semidefinite variable.</p>
<p>The total relaxation would also include an equality constraint that U₃ == W₁ so that the quadratic relaxation of x₂ is consistent between the two semidefinite variables.</p>
<p>Note: 1) Costs are only associated to a single variable group, so that the resulting aggregated program has a relaxed cost with the same scaling. 2) The homogenization variable "1" is re-used in every semidefinite variable.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there is a non-convex cost or constraint whose variables do not intersect with any of the variable groups. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ce0059feaa7226606a4f0dd51d82696" name="a0ce0059feaa7226606a4f0dd51d82696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce0059feaa7226606a4f0dd51d82696">&#9670;&#160;</a></span>MakeSolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">SolverInterface</a> &gt; MakeSolver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the solver ID, create the solver with the matching ID. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there is no matching solver. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01ecc846aa3939d1a4d166cfe0455a4e" name="a01ecc846aa3939d1a4d166cfe0455a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ecc846aa3939d1a4d166cfe0455a4e">&#9670;&#160;</a></span>NewRotationMatrixVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt; NewRotationMatrixVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;R&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a 3x3 matrix of decision variables with the trivial bounding box constraint ensuring all elements are [-1,1], and the linear constraint imposing -1 &lt;= trace(R) &lt;= 3. </p>

</div>
</div>
<a id="ac86287c7a75cb7c4762de3cb7b214d64" name="ac86287c7a75cb7c4762de3cb7b214d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86287c7a75cb7c4762de3cb7b214d64">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6bec4adfa5ced08c9ac41bea152ebb0" name="ae6bec4adfa5ced08c9ac41bea152ebb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6bec4adfa5ced08c9ac41bea152ebb0">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000040">Deprecated</a></b></dt><dd>Use fmt functions instead (e.g., fmt::format(), fmt::to_string(),  fmt::print()). Refer to GitHub issue #17742 for more information. <br  />
 This will be removed from Drake on or after 2026-06-01. </dd></dl>

</div>
</div>
<a id="accd7f1cdf664f15fcf2457b23606ca66" name="accd7f1cdf664f15fcf2457b23606ca66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd7f1cdf664f15fcf2457b23606ca66">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000041">Deprecated</a></b></dt><dd>Use fmt functions instead (e.g., fmt::format(), fmt::to_string(),  fmt::print()). Refer to GitHub issue #17742 for more information. <br  />
 This will be removed from Drake on or after 2026-06-01. </dd></dl>

</div>
</div>
<a id="aad4e89db1879b0982cc770f6f88ca32a" name="aad4e89db1879b0982cc770f6f88ca32a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4e89db1879b0982cc770f6f88ca32a">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15">ProgramType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000042">Deprecated</a></b></dt><dd>Use fmt functions instead (e.g., fmt::format(), fmt::to_string(),  fmt::print()). Refer to GitHub issue #17742 for more information. <br  />
 This will be removed from Drake on or after 2026-06-01. </dd></dl>

</div>
</div>
<a id="aa563e1d6e3e15b8f4cb35bfe48d68600" name="aa563e1d6e3e15b8f4cb35bfe48d68600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa563e1d6e3e15b8f4cb35bfe48d68600">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a920a5d85d90c2100b5e6a74f6a1f0067" name="a920a5d85d90c2100b5e6a74f6a1f0067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920a5d85d90c2100b5e6a74f6a1f0067">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binding</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out the <a class="el" href="classdrake_1_1solvers_1_1_binding.html" title="A binding on constraint type C is a mapping of the decision variables onto the inputs of C.">Binding</a>. </p>

</div>
</div>
<a id="ae3d5c08300fbf29a9a60fda82f641f8c" name="ae3d5c08300fbf29a9a60fda82f641f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3d5c08300fbf29a9a60fda82f641f8c">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_evaluator_base.html">EvaluatorBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out the evaluator. </p>

</div>
</div>
<a id="a7471708f3def1afd274533854146795e" name="a7471708f3def1afd274533854146795e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7471708f3def1afd274533854146795e">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a6297509967536d29159910e5c51fd285">IntervalBinning</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>binning</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5414006478cdb2f8d7381a774314746" name="ac5414006478cdb2f8d7381a774314746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5414006478cdb2f8d7381a774314746">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5fd73626a6f4a64e9dad21f9a66ea6c" name="ad5fd73626a6f4a64e9dad21f9a66ea6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fd73626a6f4a64e9dad21f9a66ea6c">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_rotation_constraint_generator.html#a50cc1069474becb0998889b417d7b4ff">MixedIntegerRotationConstraintGenerator::Approach</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a06b3e1d1807426668e3b27fb536af4a4" name="a06b3e1d1807426668e3b27fb536af4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b3e1d1807426668e3b27fb536af4a4">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a></td>          <td class="paramname"><span class="paramname"><em>solution_result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac374be9093bcfabc8fba4b2697b11ad2" name="ac374be9093bcfabc8fba4b2697b11ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac374be9093bcfabc8fba4b2697b11ad2">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af9613bd8bc67af65c0d77241a1581875" name="af9613bd8bc67af65c0d77241a1581875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9613bd8bc67af65c0d77241a1581875">&#9670;&#160;</a></span>QuadraticallySmoothedHingeLoss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QuadraticallySmoothedHingeLoss </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>penalty</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>dpenalty_dx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A linear hinge loss, smoothed with a quadratic loss near the origin. </p>
<p>The formulation is in equation (6) of [1]. The penalty is </p><pre class="unicode-art">
       ⎧  0        if x ≥ 0
φ(x) = ⎨  x²/2     if -1 &lt; x &lt; 0
       ⎩  -0.5 - x if x ≤ -1.
</pre><p> [1] "Loss Functions for Preference Levels: Regression with Discrete Ordered
Labels." by Jason Rennie and Nathan Srebro, Proceedings of IJCAI multidisciplinary workshop on Advances in Preference Handling. </p>

</div>
</div>
<a id="a01ce4ccbfe64bbdae5e26927307a1f5a" name="a01ce4ccbfe64bbdae5e26927307a1f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ce4ccbfe64bbdae5e26927307a1f5a">&#9670;&#160;</a></span>Solve() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> Solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>prog</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a527dd0ffa6bbc4d4d42edb944045294f" name="a527dd0ffa6bbc4d4d42edb944045294f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527dd0ffa6bbc4d4d42edb944045294f">&#9670;&#160;</a></span>Solve() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> Solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>initial_guess</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves an optimization program with a given initial guess. </p>

</div>
</div>
<a id="ae34d0e7febfca6328561574df6ce91d5" name="ae34d0e7febfca6328561574df6ce91d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34d0e7febfca6328561574df6ce91d5">&#9670;&#160;</a></span>Solve() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> Solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>initial_guess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>solver_options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves an optimization program, with optional initial guess and solver options. </p>
<p>This function first chooses the best solver depending on the availability of the solver and the program formulation; it then constructs that solver and call the Solve function of that solver. The optimization result is stored in the return argument. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>Contains the formulation of the program, and possibly solver options. </td></tr>
    <tr><td class="paramname">initial_guess</td><td>The initial guess for the decision variables. If an <code class="param">initial_guess</code> is provided, then the solver uses <code class="param">initial_guess</code> and ignores the initial guess stored in <code class="param">prog</code>. </td></tr>
    <tr><td class="paramname">solver_options</td><td>The options in addition to those stored in <code class="param">prog</code>. For each option entry (like print out), there are 4 ways to set that option, and the priority given to the solver options is as follows (from lowest / least, to highest / most):<ol type="1">
<li>common option set on the <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> itself</li>
<li>common option passed as an argument to Solve</li>
<li>solver-specific option set on the <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> itself</li>
<li>solver-specific option passed as an argument to Solve </li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result The result of solving the program through the solver. </dd></dl>

</div>
</div>
<a id="a6a70d99e086147ad2791bb41aa71d5c5" name="a6a70d99e086147ad2791bb41aa71d5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a70d99e086147ad2791bb41aa71d5c5">&#9670;&#160;</a></span>SolveInParallel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> &gt; SolveInParallel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>progs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const Eigen::VectorXd * &gt; *</td>          <td class="paramname"><span class="paramname"><em>initial_guesses</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>solver_options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::optional&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>solver_ids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a></td>          <td class="paramname"><span class="paramname"><em>parallelism</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>dynamic_schedule</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves progs[i] into result[i], optionally using initial_guess[i] and solver_options[i] if given, by invoking the solver at solver_ids[i] if provided. </p>
<p>If solver_ids[i] is nullopt then the best available solver is selected for progs[i] depending on the availability of the solver and the problem formulation. If solver_ids == nullptr then this is done for every progs[i].</p>
<p>Uses at most parallelism cores, with static scheduling by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dynamic_schedule</td><td>If dynamic_schedule is false then static scheduling is used and so each core will solve approximately 1/parallelism of the programs. This is most efficient when all the programs take approximately the same amount of time to solve. If dynamic_schedule is true, then dynamic scheduling is used and all the programs are queued into a single pool and each core will take the next program off the queue when it becomes available. This is best when each program takes a dramatically different amount of time to solve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When using a proprietary solver (e.g. Mosek) your organization may have limited license seats. It is recommended that the number of parallel solves does not exceed the total number of license seats.</dd>
<dd>
Only programs which are thread safe are solved concurrently. Programs that are not thread safe will be solved sequentially in a thread safe manner.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if initial_guess and solver_options are provided and not the same size as progs.</td></tr>
    <tr><td class="paramname">std::exception</td><td>if any of the progs are nullptr.</td></tr>
    <tr><td class="paramname">std::exception</td><td>if any of the programs cannot be solved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25590160567b442e480c55b7fd98fc92" name="a25590160567b442e480c55b7fd98fc92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25590160567b442e480c55b7fd98fc92">&#9670;&#160;</a></span>SolveInParallel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> &gt; SolveInParallel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>progs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const Eigen::VectorXd * &gt; *</td>          <td class="paramname"><span class="paramname"><em>initial_guesses</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> *</td>          <td class="paramname"><span class="paramname"><em>solver_options</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>solver_id</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a></td>          <td class="paramname"><span class="paramname"><em>parallelism</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>dynamic_schedule</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the same functionality as SolveInParallel, but allows for specifying a single solver id and solver option that is used when solving all programs. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the provided solver cannot solve all of progs.</td></tr>
    <tr><td class="paramname">std::exception</td><td>if initial_guesses are provided and not the same size as progs.</td></tr>
    <tr><td class="paramname">std::exception</td><td>if any of the progs are nullptr. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ed92e0fe48d891de05ce122684f9564" name="a9ed92e0fe48d891de05ce122684f9564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed92e0fe48d891de05ce122684f9564">&#9670;&#160;</a></span>to_string() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae07229124cd16e9d8b62fe359c7d0b40">CommonSolverOption</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the short, unadorned name of the option, e.g., <span class="tt">kPrintFileName</span>. </p>

</div>
</div>
<a id="af903ad969496826b0f656bf335658130" name="af903ad969496826b0f656bf335658130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af903ad969496826b0f656bf335658130">&#9670;&#160;</a></span>to_string() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c64a075d3d1fe62ad756b11008d821a" name="a6c64a075d3d1fe62ad756b11008d821a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c64a075d3d1fe62ad756b11008d821a">&#9670;&#160;</a></span>to_string() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3b2cde12caa7fc0dc9c4addadfea54c" name="aa3b2cde12caa7fc0dc9c4addadfea54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b2cde12caa7fc0dc9c4addadfea54c">&#9670;&#160;</a></span>to_string() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ab09ca5e1afe9e5a4e8744ecb27839b15">ProgramType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4e7fbc0ff51a6176bdfbdaefe1db3e9" name="ac4e7fbc0ff51a6176bdfbdaefe1db3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e7fbc0ff51a6176bdfbdaefe1db3e9">&#9670;&#160;</a></span>to_string() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a121673ddbdadd10b2e3ceab52a93f5d3">RemoveFreeVariableMethod</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77cbff4245bea6ae4ca666c62547ff28" name="a77cbff4245bea6ae4ca666c62547ff28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77cbff4245bea6ae4ca666c62547ff28">&#9670;&#160;</a></span>to_string() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a6297509967536d29159910e5c51fd285">IntervalBinning</a></td>          <td class="paramname"><span class="paramname"><em>interval_binning</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acefb8a09d0ea27761bdca23e9ea9f682" name="acefb8a09d0ea27761bdca23e9ea9f682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acefb8a09d0ea27761bdca23e9ea9f682">&#9670;&#160;</a></span>to_string() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_rotation_constraint_generator.html#a50cc1069474becb0998889b417d7b4ff">MixedIntegerRotationConstraintGenerator::Approach</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e3f2d56e890db7a38d31875b08f6db3" name="a8e3f2d56e890db7a38d31875b08f6db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3f2d56e890db7a38d31875b08f6db3">&#9670;&#160;</a></span>to_string() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a></td>          <td class="paramname"><span class="paramname"><em>solution_result</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1solvers.html">solvers</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
