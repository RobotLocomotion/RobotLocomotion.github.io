<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake::solvers Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 </div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacedrake_1_1solvers.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">drake::solvers Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedrake_1_1solvers_1_1test"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers_1_1test.html">test</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_add_rotation_matrix_box_sphere_intersection_return.html">AddRotationMatrixBoxSphereIntersectionReturn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some of the newly added variables in function AddRotationMatrixBoxSphereIntersectionMilpConstraints.  <a href="structdrake_1_1solvers_1_1_add_rotation_matrix_box_sphere_intersection_return.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_augmented_lagrangian_nonsmooth.html">AugmentedLagrangianNonsmooth</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the augmented Lagrangian (AL) of a given mathematical program.  <a href="classdrake_1_1solvers_1_1_augmented_lagrangian_nonsmooth.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_augmented_lagrangian_smooth.html">AugmentedLagrangianSmooth</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the augmented Lagrangian (AL) of a given mathematical program.  <a href="classdrake_1_1solvers_1_1_augmented_lagrangian_smooth.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A binding on constraint type C is a mapping of the decision variables onto the inputs of C.  <a href="classdrake_1_1solvers_1_1_binding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_bound.html">Bound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the lower and upper bound of a variable.  <a href="structdrake_1_1solvers_1_1_bound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a constraint of the form \( lb &lt;= x &lt;= ub \).  <a href="classdrake_1_1solvers_1_1_bounding_box_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_clarabel_solver.html">ClarabelSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface to wrap Clarabel <a href="https://github.com/oxfordcontrol/Clarabel.cpp">https://github.com/oxfordcontrol/Clarabel.cpp</a>.  <a href="classdrake_1_1solvers_1_1_clarabel_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_clarabel_solver_details.html">ClarabelSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Clarabel solver details after calling the <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_clarabel_solver_details.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_clp_solver.html">ClpSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper to call CLP using Drake's <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <a href="classdrake_1_1solvers_1_1_clp_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_clp_solver_details.html">ClpSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CLP solver details after calling <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_clp_solver_details.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constraint is a function + lower and upper bounds.  <a href="classdrake_1_1solvers_1_1_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an abstract base for all costs.  <a href="classdrake_1_1solvers_1_1_cost.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_csdp_solver.html">CsdpSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap CSDP solver such that it can solve a <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">drake::solvers::MathematicalProgram</a>.  <a href="classdrake_1_1solvers_1_1_csdp_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_csdp_solver_details.html">CsdpSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CSDP solver details after calling <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_csdp_solver_details.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_equality_constrained_q_p_solver.html">EqualityConstrainedQPSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a quadratic program with equality constraint.  <a href="classdrake_1_1solvers_1_1_equality_constrained_q_p_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_evaluator_base.html">EvaluatorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an abstract interface to represent an expression, mapping a fixed or dynamic number of inputs to a fixed number of outputs, that may be evaluated on a scalar type of double or AutoDiffXd.  <a href="classdrake_1_1solvers_1_1_evaluator_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_evaluator_constraint.html">EvaluatorConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constraint that may be specified using another (potentially nonlinear) evaluator.  <a href="classdrake_1_1solvers_1_1_evaluator_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_evaluator_cost.html">EvaluatorCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cost that may be specified using another (potentially nonlinear) evaluator.  <a href="classdrake_1_1solvers_1_1_evaluator_cost.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html">ExponentialConeConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exponential cone constraint is a special type of convex cone constraint.  <a href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_expression_constraint.html">ExpressionConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a generic (potentially nonlinear) constraint represented as a vector of symbolic Expression.  <a href="classdrake_1_1solvers_1_1_expression_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_expression_cost.html">ExpressionCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a generic (potentially nonlinear) cost represented as a symbolic Expression.  <a href="classdrake_1_1solvers_1_1_expression_cost.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_function_evaluator.html">FunctionEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An evaluator that may be specified using a callable object.  <a href="classdrake_1_1solvers_1_1_function_evaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_gurobi_solver.html">GurobiSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html" title="Interface used by implementations of individual solvers.">SolverInterface</a> for the commercially-licensed Gurobi solver (<a href="https://www.gurobi.com/">https://www.gurobi.com/</a>).  <a href="classdrake_1_1solvers_1_1_gurobi_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_gurobi_solver_details.html">GurobiSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Gurobi solver details after calling <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_gurobi_solver_details.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_ipopt_solver.html">IpoptSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_ipopt_solver_details.html">IpoptSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Ipopt solver details after calling <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_ipopt_solver_details.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_l1_norm_cost.html">L1NormCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a cost of the form ‖Ax + b‖₁.  <a href="classdrake_1_1solvers_1_1_l1_norm_cost.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_l2_norm_cost.html">L2NormCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a cost of the form ‖Ax + b‖₂.  <a href="classdrake_1_1solvers_1_1_l2_norm_cost.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a constraint of the form:  <a href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a constraint of the form \( lb &lt;= Ax &lt;= ub \).  <a href="classdrake_1_1solvers_1_1_linear_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a cost of the form </p><p class="formulaDsp">
\[ a&#39;x + b \]
</p>
<p>.  <a href="classdrake_1_1solvers_1_1_linear_cost.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a constraint of the form \( Ax = b \).  <a href="classdrake_1_1solvers_1_1_linear_equality_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose the matrix inequality constraint on variable x<p class="formulaDsp">
\[ F_0 + x_1 F_1 + ... + x_n F_n \text{ is p.s.d} \]
</p>
<p> where p.s.d stands for positive semidefinite.  <a href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_linear_system_solver.html">LinearSystemSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the least-square solution to the linear system A * x = b.  <a href="classdrake_1_1solvers_1_1_linear_system_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_l_inf_norm_cost.html">LInfNormCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a cost of the form ‖Ax + b‖∞.  <a href="classdrake_1_1solvers_1_1_l_inf_norm_cost.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_logarithmic_sos2_new_binary_variables.html">LogarithmicSos2NewBinaryVariables</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the new binary variables in the compile time, for Special Ordered Set of type 2 (SOS2) constraint.  <a href="structdrake_1_1solvers_1_1_logarithmic_sos2_new_binary_variables.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>LogarithmicSos2NewBinaryVariables&lt; Eigen::Dynamic &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraining the linear expression \( z=Ax+b \) lies within the Lorentz cone.  <a href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> stores the decision variables, the constraints and costs of an optimization problem.  <a href="classdrake_1_1solvers_1_1_mathematical_program.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result returned by <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">MathematicalProgram::Solve()</a>.  <a href="classdrake_1_1solvers_1_1_mathematical_program_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_minimum_value_lower_bound_constraint.html">MinimumValueLowerBoundConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrain min(v) &gt;= lb where v=f(x).  <a href="classdrake_1_1solvers_1_1_minimum_value_lower_bound_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_minimum_value_upper_bound_constraint.html">MinimumValueUpperBoundConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrain min(v) &lt;= ub where v=f(x).  <a href="classdrake_1_1solvers_1_1_minimum_value_upper_bound_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_branch_and_bound.html">MixedIntegerBranchAndBound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a mixed-integer optimization problem (MIP) (or more accurately, mixed binary problem), solve this problem through branch-and-bound process.  <a href="classdrake_1_1solvers_1_1_mixed_integer_branch_and_bound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_branch_and_bound_node.html">MixedIntegerBranchAndBoundNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node in the branch-and-bound (bnb) tree.  <a href="classdrake_1_1solvers_1_1_mixed_integer_branch_and_bound_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_rotation_constraint_generator.html">MixedIntegerRotationConstraintGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">We relax the non-convex SO(3) constraint on rotation matrix R to mixed-integer linear constraints.  <a href="classdrake_1_1solvers_1_1_mixed_integer_rotation_constraint_generator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html">MobyLCPSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for solving Linear Complementarity Problems (LCPs).  <a href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_lcp_solver_id.html">MobyLcpSolverId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-template class for MobyLcpSolver&lt;T&gt; constants.  <a href="classdrake_1_1solvers_1_1_moby_lcp_solver_id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mosek_solver.html">MosekSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html" title="Interface used by implementations of individual solvers.">SolverInterface</a> for the commercially-licensed MOSEK (TM) solver (<a href="https://www.mosek.com/">https://www.mosek.com/</a>).  <a href="classdrake_1_1solvers_1_1_mosek_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_mosek_solver_details.html">MosekSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MOSEK<a href="/tm.html">™</a> solver details after calling <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_mosek_solver_details.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_new_symmetric_variable_names.html">NewSymmetricVariableNames</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_new_variable_names.html">NewVariableNames</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>NewVariableNames&lt; Eigen::Dynamic &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_new_variable_names_3_01_rows_00_01_cols_01_4.html">NewVariableNames&lt; Rows, Cols &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_new_variable_names_3_01_size_01_4.html">NewVariableNames&lt; Size &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the names for the newly added variables.  <a href="structdrake_1_1solvers_1_1_new_variable_names_3_01_size_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_nlopt_solver.html">NloptSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_nlopt_solver_details.html">NloptSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The NLopt solver details after calling <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_nlopt_solver_details.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_osqp_solver.html">OsqpSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper to call <a href="https://osqp.org/">OSQP</a> using Drake's <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a>.  <a href="classdrake_1_1solvers_1_1_osqp_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_osqp_solver_details.html">OsqpSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The OSQP solver details after calling <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_osqp_solver_details.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_perspective_quadratic_cost.html">PerspectiveQuadraticCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If \( z = Ax + b,\) implements a cost of the form: </p><p class="formulaDsp">
\[ (z_1^2 + z_2^2 + ... + z_{n-1}^2) / z_0. \]
</p>
<p> Note that this cost is convex when we additionally constrain z_0 &gt; 0.  <a href="classdrake_1_1solvers_1_1_perspective_quadratic_cost.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_polynomial_constraint.html">PolynomialConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constraint on the values of multivariate polynomials.  <a href="classdrake_1_1solvers_1_1_polynomial_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_polynomial_cost.html">PolynomialCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a cost of the form P(x, y...) where P is a multivariate polynomial in x, y, ...  <a href="classdrake_1_1solvers_1_1_polynomial_cost.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_polynomial_evaluator.html">PolynomialEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements an evaluator of the form P(x, y...) where P is a multivariate polynomial in x, y, ...  <a href="classdrake_1_1solvers_1_1_polynomial_evaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a positive semidefinite constraint on a symmetric matrix S </p><p class="formulaDsp">
\[\text{ S is p.s.d }\]
</p>
<p> namely, all eigen values of S are non-negative.  <a href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_quadratic_constraint.html">QuadraticConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">lb ≤ .5 xᵀQx + bᵀx ≤ ub Without loss of generality, the class stores a symmetric matrix Q.  <a href="classdrake_1_1solvers_1_1_quadratic_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a cost of the form </p><p class="formulaDsp">
\[ .5 x&#39;Qx + b&#39;x + c \]
</p>
<p>.  <a href="classdrake_1_1solvers_1_1_quadratic_cost.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraining that the linear expression \( z=Ax+b \) lies within rotated Lorentz cone.  <a href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_scs_solver.html">ScsSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_scs_solver_details.html">ScsSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SCS solver details after calling <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_scs_solver_details.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_snopt_solver.html">SnoptSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html" title="Interface used by implementations of individual solvers.">SolverInterface</a> for the commercially-licensed SNOPT solver (<a href="https://ccom.ucsd.edu/~optimizers/solvers/snopt/">https://ccom.ucsd.edu/~optimizers/solvers/snopt/</a>).  <a href="classdrake_1_1solvers_1_1_snopt_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_snopt_solver_details.html">SnoptSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SNOPT solver details after calling <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_snopt_solver_details.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_base.html">SolverBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class used by implementations of individual solvers.  <a href="classdrake_1_1solvers_1_1_solver_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies a <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html" title="Interface used by implementations of individual solvers.">SolverInterface</a> implementation.  <a href="classdrake_1_1solvers_1_1_solver_id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">SolverInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface used by implementations of individual solvers.  <a href="classdrake_1_1solvers_1_1_solver_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores options for multiple solvers.  <a href="classdrake_1_1solvers_1_1_solver_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_type_converter.html">SolverTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts between SolverType and <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html" title="Identifies a SolverInterface implementation.">SolverId</a>.  <a href="classdrake_1_1solvers_1_1_solver_type_converter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_unrevised_lemke_solver.html">UnrevisedLemkeSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for the Unrevised Implementation of Lemke Algorithm's for solving Linear Complementarity Problems (LCPs).  <a href="classdrake_1_1solvers_1_1_unrevised_lemke_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_unrevised_lemke_solver_id.html">UnrevisedLemkeSolverId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-template class for UnrevisedLemkeSolver&lt;T&gt; constants.  <a href="classdrake_1_1solvers_1_1_unrevised_lemke_solver_id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html">VisualizationCallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a simple evaluator with no outputs that takes a callback function pointer.  <a href="classdrake_1_1solvers_1_1_visualization_callback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa708f80d971209e3d46c1e41f05c1393"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#aa708f80d971209e3d46c1e41f05c1393">DecisionVariable</a> = <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a></td></tr>
<tr class="separator:aa708f80d971209e3d46c1e41f05c1393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf84184cb10b49233b007295d1880e17"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:acf84184cb10b49233b007295d1880e17"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a> = Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>, rows, cols &gt;</td></tr>
<tr class="separator:acf84184cb10b49233b007295d1880e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20d09ae94d1e722c2961fbaca37f967"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:aa20d09ae94d1e722c2961fbaca37f967"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a> = <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; rows, 1 &gt;</td></tr>
<tr class="separator:aa20d09ae94d1e722c2961fbaca37f967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04cfbe6b8d63ecb463fc087385ce061"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> = <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:ac04cfbe6b8d63ecb463fc087385ce061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca924499b3b011a50d3bd9d051295efa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> = <a class="el" href="namespacedrake_1_1solvers.html#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a>&lt; Eigen::Dynamic &gt;</td></tr>
<tr class="separator:aca924499b3b011a50d3bd9d051295efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062b182db5c52f5a71221a4c5958ea0b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> = std::list&lt; Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &gt;</td></tr>
<tr class="separator:a062b182db5c52f5a71221a4c5958ea0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f19da4730aeebddf6a1d14f51f0b7ec"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:a0f19da4730aeebddf6a1d14f51f0b7ec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a> = Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>, rows, cols &gt;</td></tr>
<tr class="memdesc:a0f19da4730aeebddf6a1d14f51f0b7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">MatrixIndeterminate&lt;int, int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable, int, int&gt;.  <a href="#a0f19da4730aeebddf6a1d14f51f0b7ec">More...</a><br /></td></tr>
<tr class="separator:a0f19da4730aeebddf6a1d14f51f0b7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0943cc7cf2cc9bf7db6facfe53a8568"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:ac0943cc7cf2cc9bf7db6facfe53a8568"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a> = <a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a>&lt; rows, 1 &gt;</td></tr>
<tr class="memdesc:ac0943cc7cf2cc9bf7db6facfe53a8568"><td class="mdescLeft">&#160;</td><td class="mdescRight">VectorIndeterminate&lt;int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable, int, 1&gt;.  <a href="#ac0943cc7cf2cc9bf7db6facfe53a8568">More...</a><br /></td></tr>
<tr class="separator:ac0943cc7cf2cc9bf7db6facfe53a8568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e13290a9b854b4fee070764f978d22"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a60e13290a9b854b4fee070764f978d22">MatrixXIndeterminate</a> = <a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a>&lt; Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a60e13290a9b854b4fee070764f978d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">MatrixXIndeterminate is used as an alias for Eigen::Matrix&lt;symbolic::Variable, Eigen::Dynamic, Eigen::Dynamic&gt;.  <a href="#a60e13290a9b854b4fee070764f978d22">More...</a><br /></td></tr>
<tr class="separator:a60e13290a9b854b4fee070764f978d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ed74a4ca04549f64c547dfba0724d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a> = <a class="el" href="namespacedrake_1_1solvers.html#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a>&lt; Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a91ed74a4ca04549f64c547dfba0724d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">VectorXIndeterminate is used as an alias for Eigen::Matrix&lt;symbolic::Variable, Eigen::Dynamic, 1&gt;.  <a href="#a91ed74a4ca04549f64c547dfba0724d5">More...</a><br /></td></tr>
<tr class="separator:a91ed74a4ca04549f64c547dfba0724d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27bca68509bbb001ab8073089b48031"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ac27bca68509bbb001ab8073089b48031">IndeterminatesRefList</a> = std::list&lt; Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a> &gt; &gt;</td></tr>
<tr class="separator:ac27bca68509bbb001ab8073089b48031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2a57e87ae4e4088e12967a25a7c229"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#adc2a57e87ae4e4088e12967a25a7c229">MinimumValuePenaltyFunction</a> = std::function&lt; void(<a class="el" href="classdouble.html">double</a> <a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, <a class="el" href="classdouble.html">double</a> *penalty, <a class="el" href="classdouble.html">double</a> *dpenalty_dx)&gt;</td></tr>
<tr class="memdesc:adc2a57e87ae4e4088e12967a25a7c229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the penalty function φ(x) and its derivatives dφ(x)/dx.  <a href="#adc2a57e87ae4e4088e12967a25a7c229">More...</a><br /></td></tr>
<tr class="separator:adc2a57e87ae4e4088e12967a25a7c229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5617ec1dc3b70cd1683d8850fe69585d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> = std::unordered_set&lt; <a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a>, <a class="el" href="namespacedrake.html#a323dc8b0cc629c61d4da8feeaa8cd4f5">DefaultHash</a> &gt;</td></tr>
<tr class="separator:a5617ec1dc3b70cd1683d8850fe69585d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b1b3c88fe94fd28d7564b90f50a00f"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a55b1b3c88fe94fd28d7564b90f50a00f">RollPitchYawLimits</a></td></tr>
<tr class="separator:a55b1b3c88fe94fd28d7564b90f50a00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae07229124cd16e9d8b62fe359c7d0b40"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ae07229124cd16e9d8b62fe359c7d0b40">CommonSolverOption</a> { <a class="el" href="namespacedrake_1_1solvers.html#ae07229124cd16e9d8b62fe359c7d0b40a222307df6fb67d2a524cade7227ca4f8">kPrintFileName</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#ae07229124cd16e9d8b62fe359c7d0b40aca5719f05d0aceacc42e256644394100">kPrintToConsole</a>
 }</td></tr>
<tr class="memdesc:ae07229124cd16e9d8b62fe359c7d0b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some options can be applied to not one solver, but many solvers (for example, many solvers support printing out the progress in each iteration).  <a href="namespacedrake_1_1solvers.html#ae07229124cd16e9d8b62fe359c7d0b40">More...</a><br /></td></tr>
<tr class="separator:ae07229124cd16e9d8b62fe359c7d0b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6297509967536d29159910e5c51fd285"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a6297509967536d29159910e5c51fd285">IntervalBinning</a> { <a class="el" href="namespacedrake_1_1solvers.html#a6297509967536d29159910e5c51fd285a5bff8e60dc42878e194fb2d87460ed29">kLogarithmic</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a6297509967536d29159910e5c51fd285aac97f0008bcf7c7fe4f2ff94160e1385">kLinear</a>
 }</td></tr>
<tr class="memdesc:a6297509967536d29159910e5c51fd285"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a continuous variable whose range is cut into small intervals, we will use binary variables to represent which interval the continuous variable is in.  <a href="namespacedrake_1_1solvers.html#a6297509967536d29159910e5c51fd285">More...</a><br /></td></tr>
<tr class="separator:a6297509967536d29159910e5c51fd285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115b732b5de5502e59437ee38babe95f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a> { <br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fa597a3cf4953daab8ab5e6ffebeff44d0">kGenericCost</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fad7bf05f9b17385b6e8aa383fc67fc83f">kGenericConstraint</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fa29122b5334de24190e886ea289d14a2a">kQuadraticCost</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fae8503f9b8b6fbe23f14ac068f665c9c0">kQuadraticConstraint</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fa302b09f3d249d023c8aaad1097b50edb">kLinearCost</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fa42f1335762da576901b57e5b118858e9">kLinearConstraint</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fa48d237e8d01c95129ecc34be15f4b789">kLinearEqualityConstraint</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fa8c8fa060b46a40b2fd97509493514f33">kLinearComplementarityConstraint</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95faa19344b8110a4be1b5581a25f612713f">kLorentzConeConstraint</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fa9e8364decaab78121a0ceaabb57c72cc">kRotatedLorentzConeConstraint</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fa59e241294144c7cdf7ea7c8e64b361aa">kPositiveSemidefiniteConstraint</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fa6186f6ad8f4222b61ec29ea48a046299">kExponentialConeConstraint</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fa2b988d83ab42142c09d442f5b42904f3">kL2NormCost</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fa12a1034a77cf500ebcff46f8e493bb10">kBinaryVariable</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fa288767e402655671f06cd5313e8bada9">kCallback</a>
<br />
 }</td></tr>
<tr class="separator:a115b732b5de5502e59437ee38babe95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09ca5e1afe9e5a4e8744ecb27839b15"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15">ProgramType</a> { <br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15a3e3af9259f19c76c1a21cacdbd5afd4a">kLP</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15a9ac21b2be50204074e59ceb63526fae6">kQP</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15a7cd173b34793fe6598118c124401da00">kSOCP</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15aeb3825da90413e715ee32c3463428d84">kSDP</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15a7ae933ebedf558cd02d3d45f0a1236cf">kGP</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15a85d8a1af1f3ab3fb37aaef44ee44a436">kCGP</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15a41adb3a46194a70e097f15c9848b2c97">kMILP</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15aa1029d46d3092d1662ee6baccbd926f8">kMIQP</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15af91d74856b95694eb9624142e4317bb4">kMISOCP</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15aea23768965b758e81bdb3e2fb62476c8">kMISDP</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15a914035c5bf9d877dbd17b8c476ab48a6">kQuadraticCostConicConstraint</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15aced0324bc370cd8712746abd28ac3844">kNLP</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15aad18a51c134b9ac1c2af4f45766761cf">kLCP</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15a25c2dc47991b3df171ed5192bcf70390">kUnknown</a>
<br />
 }</td></tr>
<tr class="memdesc:ab09ca5e1afe9e5a4e8744ecb27839b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">A coarse categorization of the optimization problem based on the type of constraints/costs/variables.  <a href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15">More...</a><br /></td></tr>
<tr class="separator:ab09ca5e1afe9e5a4e8744ecb27839b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1949f5edc628077e2d780c150de88d74"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74">RollPitchYawLimitOptions</a> { <br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74a34bbac4b028a742de1b931cc2694dcea">kNoLimits</a> = 0, 
<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74af029ec457c6dc0bdc5bee0edc2baf12d">kRPYError</a> = 1 &lt;&lt; 0, 
<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74af69f0d7bda8d330fcf89df333412794d">kRoll_NegPI_2_to_PI_2</a> = 1 &lt;&lt; 1, 
<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74a6973c9c90ce92aa52ce62a6e0fc4664d">kRoll_0_to_PI</a> = 1 &lt;&lt; 2, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74adb2b51a6cdf2edf29dc2bfdcefef6ce0">kPitch_NegPI_2_to_PI_2</a> = 1 &lt;&lt; 3, 
<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74a56192ce118646021d72474e9520a804a">kPitch_0_to_PI</a> = 1 &lt;&lt; 4, 
<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74aa059fc525d6d174e5e070c7261ff8e43">kYaw_NegPI_2_to_PI_2</a> = 1 &lt;&lt; 5, 
<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74aca450e45c136c14aabb606a09e0775a8">kYaw_0_to_PI</a> = 1 &lt;&lt; 6, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74a27402335e74462e03adf2c79e903705e">kRoll_0_to_PI_2</a> = (1 &lt;&lt; 1) | (1 &lt;&lt; 2), 
<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74af031fdd95c7b0bd771a160bf2905eaae">kPitch_0_to_PI_2</a> = (1 &lt;&lt; 3) | (1 &lt;&lt; 4), 
<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74aae2b1591bba5a77450b0df77a207be8f">kYaw_0_to_PI_2</a> = (1 &lt;&lt; 5) | (1 &lt;&lt; 6)
<br />
 }</td></tr>
<tr class="separator:a1949f5edc628077e2d780c150de88d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121673ddbdadd10b2e3ceab52a93f5d3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3">RemoveFreeVariableMethod</a> { <a class="el" href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3a268e3bfe4e48f70785a46a8d3552e552">kTwoSlackVariables</a> = 1, 
<a class="el" href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3a54b9d7601ece96fc42e2ffd67aae2690">kNullspace</a> = 2, 
<a class="el" href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3a2992c87df2428b480924bf6c6509edec">kLorentzConeSlack</a> = 3
 }</td></tr>
<tr class="memdesc:a121673ddbdadd10b2e3ceab52a93f5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDPA format doesn't accept free variables, namely the problem it solves is in this form P1.  <a href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3">More...</a><br /></td></tr>
<tr class="separator:a121673ddbdadd10b2e3ceab52a93f5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331f41a3139a87d16e1422bc818c136f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a> { <br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136fa15e1c4845b9467d880999c78de6afe45">kSolutionFound</a> = 0, 
<a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136fa78cb430cc349315a2ba0f3602ef64b6d">kInvalidInput</a> = -1, 
<a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136fa4f17cb26e989bf3f8c2990cd51fcede9">kInfeasibleConstraints</a> = -2, 
<a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136fa4b9de95ee3087851acd98262e09f0be8">kUnbounded</a> = -3, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136fa84d10e8dce3328bfb1f6761d194857f2">kSolverSpecificError</a> = -4, 
<a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136fa2bfbc12cb546f78bd0080b8df5b26520">kInfeasibleOrUnbounded</a> = -5, 
<a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136fa97600ae7efdb5c8fecf91e99463ef4ef">kIterationLimit</a> = -6, 
<a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136fae1f645d6b81b09a506f807a18d5e1d4b">kDualInfeasible</a> = -7, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136fab42685181d035fb42e3da3462b4c0b55">kSolutionResultNotSet</a> = -8
<br />
 }</td></tr>
<tr class="separator:a331f41a3139a87d16e1422bc818c136f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b06041d7c1fb05f379714f4312306ec"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306ec">SolverType</a> { <br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306ecaa71a8c0a25fe7a3d777fc06d50bada13">kClp</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306ecae654b0ad8f79045aff33844a0c3cdf81">kCsdp</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306eca71cedba88b736e372f499099329d5173">kEqualityConstrainedQP</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306ecabc8ddfb8a00bb405e68545ce187ac238">kGurobi</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306ecaa1f0780f88b19c3a73710b47fc57d795">kIpopt</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306ecaebb0e280cb0e7da8a3868247749a4d9d">kLinearSystem</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306ecabd0a61a2cf9acec23fccd41c7402ef56">kMobyLCP</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306eca18bc9cbd9bb764958e636263b1b53a9d">kMosek</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306eca64e0ff0ce277a08ed59a9fe9140a8fd7">kNlopt</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306eca6e645ae8d30d672d9800a422f4be4c9d">kOsqp</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306eca6619293bd01e7ea8efb3682f16bf55c4">kSnopt</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306ecad1ddb13aaaf649f197e0f6549596571c">kScs</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306eca045139748552611db2ba18934b6f89f6">kUnrevisedLemke</a>
<br />
 }</td></tr>
<tr class="memdesc:a8b06041d7c1fb05f379714f4312306ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This type only exists for backwards compatibility, and should not be used in new code.  <a href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306ec">More...</a><br /></td></tr>
<tr class="separator:a8b06041d7c1fb05f379714f4312306ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a38b2721b2175272485def57c7a8b9c6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a38b2721b2175272485def57c7a8b9c6a">AggregateLinearCosts</a> (const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;&gt; &amp;linear_costs, Eigen::SparseVector&lt; <a class="el" href="classdouble.html">double</a> &gt; *linear_coeff, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; *vars, <a class="el" href="classdouble.html">double</a> *constant_cost)</td></tr>
<tr class="memdesc:a38b2721b2175272485def57c7a8b9c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given many linear costs, aggregate them into.  <a href="#a38b2721b2175272485def57c7a8b9c6a">More...</a><br /></td></tr>
<tr class="separator:a38b2721b2175272485def57c7a8b9c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9e7d960a7e287ea283ffa9aee89d41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#afd9e7d960a7e287ea283ffa9aee89d41">AggregateQuadraticAndLinearCosts</a> (const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&gt; &amp;quadratic_costs, const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;&gt; &amp;linear_costs, Eigen::SparseMatrix&lt; <a class="el" href="classdouble.html">double</a> &gt; *Q_lower, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; *quadratic_vars, Eigen::SparseVector&lt; <a class="el" href="classdouble.html">double</a> &gt; *linear_coeff, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; *linear_vars, <a class="el" href="classdouble.html">double</a> *constant_cost)</td></tr>
<tr class="memdesc:afd9e7d960a7e287ea283ffa9aee89d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given many linear and quadratic costs, aggregate them into.  <a href="#afd9e7d960a7e287ea283ffa9aee89d41">More...</a><br /></td></tr>
<tr class="separator:afd9e7d960a7e287ea283ffa9aee89d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc36100fe5dc287d0c0c41a65c31c21"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>, <a class="el" href="structdrake_1_1solvers_1_1_bound.html">Bound</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#aebc36100fe5dc287d0c0c41a65c31c21">AggregateBoundingBoxConstraints</a> (const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt;&gt; &amp;bounding_box_constraints)</td></tr>
<tr class="memdesc:aebc36100fe5dc287d0c0c41a65c31c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregates many bounding box constraints, returns the intersection (the tightest bounds) of these constraints.  <a href="#aebc36100fe5dc287d0c0c41a65c31c21">More...</a><br /></td></tr>
<tr class="separator:aebc36100fe5dc287d0c0c41a65c31c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43caa3a499b973de17213d63a006b0ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a43caa3a499b973de17213d63a006b0ea">AggregateBoundingBoxConstraints</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog, Eigen::VectorXd *lower, Eigen::VectorXd *upper)</td></tr>
<tr class="memdesc:a43caa3a499b973de17213d63a006b0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregates all the BoundingBoxConstraints inside <code>prog</code>, returns the intersection of the bounding box constraints as the lower and upper bound for each variable in <code>prog</code>.  <a href="#a43caa3a499b973de17213d63a006b0ea">More...</a><br /></td></tr>
<tr class="separator:a43caa3a499b973de17213d63a006b0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb331e49dcccbb8d9d0e63a2190685f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#acb331e49dcccbb8d9d0e63a2190685f2">AggregateBoundingBoxConstraints</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog, std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; *lower, std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; *upper)</td></tr>
<tr class="memdesc:acb331e49dcccbb8d9d0e63a2190685f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads AggregateBoundingBoxConstraints, but the type of lower and upper are std::vector&lt;double&gt;.  <a href="#acb331e49dcccbb8d9d0e63a2190685f2">More...</a><br /></td></tr>
<tr class="separator:acb331e49dcccbb8d9d0e63a2190685f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5999ff5df38e426f3e6c4a69aeec4305"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a5999ff5df38e426f3e6c4a69aeec4305">AggregateDuplicateVariables</a> (const Eigen::SparseMatrix&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;A, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &amp;vars, Eigen::SparseMatrix&lt; <a class="el" href="classdouble.html">double</a> &gt; *A_new, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; *vars_new)</td></tr>
<tr class="memdesc:a5999ff5df38e426f3e6c4a69aeec4305"><td class="mdescLeft">&#160;</td><td class="mdescRight">For linear expression A * vars where <code>vars</code> might contain duplicated entries, rewrite this linear expression as A_new * vars_new where vars_new doesn't contain duplicated entries.  <a href="#a5999ff5df38e426f3e6c4a69aeec4305">More...</a><br /></td></tr>
<tr class="separator:a5999ff5df38e426f3e6c4a69aeec4305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab097e2ddc8c73cd83a8ae0e801b9071"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:aab097e2ddc8c73cd83a8ae0e801b9071"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#aab097e2ddc8c73cd83a8ae0e801b9071">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;binding)</td></tr>
<tr class="memdesc:aab097e2ddc8c73cd83a8ae0e801b9071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the <a class="el" href="classdrake_1_1solvers_1_1_binding.html" title="A binding on constraint type C is a mapping of the decision variables onto the inputs of C.">Binding</a>.  <a href="#aab097e2ddc8c73cd83a8ae0e801b9071">More...</a><br /></td></tr>
<tr class="separator:aab097e2ddc8c73cd83a8ae0e801b9071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e1d0462e0e3506873f993879d48898"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#af2e1d0462e0e3506873f993879d48898">ChooseBestSolver</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog)</td></tr>
<tr class="memdesc:af2e1d0462e0e3506873f993879d48898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose the best solver given the formulation in the optimization program and the availability of the solvers.  <a href="#af2e1d0462e0e3506873f993879d48898">More...</a><br /></td></tr>
<tr class="separator:af2e1d0462e0e3506873f993879d48898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b69ef16f17a627abcbe62dde1d4807"><td class="memItemLeft" align="right" valign="top">const std::set&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a55b69ef16f17a627abcbe62dde1d4807">GetKnownSolvers</a> ()</td></tr>
<tr class="memdesc:a55b69ef16f17a627abcbe62dde1d4807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of solvers known to ChooseBestSolver.  <a href="#a55b69ef16f17a627abcbe62dde1d4807">More...</a><br /></td></tr>
<tr class="separator:a55b69ef16f17a627abcbe62dde1d4807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a32aadfdc1241e4e39f206479b6000"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">SolverInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ac0a32aadfdc1241e4e39f206479b6000">MakeSolver</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;id)</td></tr>
<tr class="memdesc:ac0a32aadfdc1241e4e39f206479b6000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the solver ID, create the solver with the matching ID.  <a href="#ac0a32aadfdc1241e4e39f206479b6000">More...</a><br /></td></tr>
<tr class="separator:ac0a32aadfdc1241e4e39f206479b6000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ce5167dfbdc1a1f84e2e7cc52cba4e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">SolverInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a99ce5167dfbdc1a1f84e2e7cc52cba4e">MakeFirstAvailableSolver</a> (const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &gt; &amp;solver_ids)</td></tr>
<tr class="memdesc:a99ce5167dfbdc1a1f84e2e7cc52cba4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the first available and enabled solver.  <a href="#a99ce5167dfbdc1a1f84e2e7cc52cba4e">More...</a><br /></td></tr>
<tr class="separator:a99ce5167dfbdc1a1f84e2e7cc52cba4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add46c9926ac1085abe828a7cc987cad1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#add46c9926ac1085abe828a7cc987cad1">GetAvailableSolvers</a> (<a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15">ProgramType</a> prog_type)</td></tr>
<tr class="memdesc:add46c9926ac1085abe828a7cc987cad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of available and enabled solvers that definitely accept all programs of the given program type.  <a href="#add46c9926ac1085abe828a7cc987cad1">More...</a><br /></td></tr>
<tr class="separator:add46c9926ac1085abe828a7cc987cad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed794af38e7da9270528fd2185861862"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#aed794af38e7da9270528fd2185861862">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="namespacedrake_1_1solvers.html#ae07229124cd16e9d8b62fe359c7d0b40">CommonSolverOption</a> common_solver_option)</td></tr>
<tr class="separator:aed794af38e7da9270528fd2185861862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f972e77c40a9afab91907620c621e11"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__solver__evaluators.html#ga5f972e77c40a9afab91907620c621e11">MakeQuadraticErrorCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;x_desired)</td></tr>
<tr class="memdesc:ga5f972e77c40a9afab91907620c621e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a cost term of the form (x-x_desired)'<em>Q</em>(x-x_desired).  <a href="group__solver__evaluators.html#ga5f972e77c40a9afab91907620c621e11">More...</a><br /></td></tr>
<tr class="separator:ga5f972e77c40a9afab91907620c621e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62744a5e355fa26fa97169acfc946128"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__solver__evaluators.html#ga62744a5e355fa26fa97169acfc946128">Make2NormSquaredCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b)</td></tr>
<tr class="memdesc:ga62744a5e355fa26fa97169acfc946128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a quadratic cost of the form |Ax-b|²=(Ax-b)ᵀ(Ax-b)  <a href="group__solver__evaluators.html#ga62744a5e355fa26fa97169acfc946128">More...</a><br /></td></tr>
<tr class="separator:ga62744a5e355fa26fa97169acfc946128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d268ea8150fb094f1499a958c50defb"><td class="memTemplParams" colspan="2">template&lt;typename FF &gt; </td></tr>
<tr class="memitem:ga9d268ea8150fb094f1499a958c50defb"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__solver__evaluators.html#ga9d268ea8150fb094f1499a958c50defb">MakeFunctionCost</a> (FF &amp;&amp;f)</td></tr>
<tr class="memdesc:ga9d268ea8150fb094f1499a958c50defb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an input of type <code>F</code> to a nonlinear cost.  <a href="group__solver__evaluators.html#ga9d268ea8150fb094f1499a958c50defb">More...</a><br /></td></tr>
<tr class="separator:ga9d268ea8150fb094f1499a958c50defb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f304c33d467b0bf0ad02e25a2ced143"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a8f304c33d467b0bf0ad02e25a2ced143">ConcatenateVariableRefList</a> (const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;var_list)</td></tr>
<tr class="memdesc:a8f304c33d467b0bf0ad02e25a2ced143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates each element in <code>var_list</code> into a single Eigen vector of decision variables, returns this concatenated vector.  <a href="#a8f304c33d467b0bf0ad02e25a2ced143">More...</a><br /></td></tr>
<tr class="separator:a8f304c33d467b0bf0ad02e25a2ced143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dddde3ce550bdc321a2240ab12cec0"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a82dddde3ce550bdc321a2240ab12cec0">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1solvers_1_1_evaluator_base.html">EvaluatorBase</a> &amp;e)</td></tr>
<tr class="memdesc:a82dddde3ce550bdc321a2240ab12cec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the evaluator.  <a href="#a82dddde3ce550bdc321a2240ab12cec0">More...</a><br /></td></tr>
<tr class="separator:a82dddde3ce550bdc321a2240ab12cec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5fa6010c00dad4d5867183f35a2f70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15">ProgramType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#acb5fa6010c00dad4d5867183f35a2f70">GetProgramType</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog)</td></tr>
<tr class="memdesc:acb5fa6010c00dad4d5867183f35a2f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of the optimization program (LP, QP, etc), based on the properties of its cost/constraints/variables.  <a href="#acb5fa6010c00dad4d5867183f35a2f70">More...</a><br /></td></tr>
<tr class="separator:acb5fa6010c00dad4d5867183f35a2f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca547471b139de0956139286cbfe5f10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#aca547471b139de0956139286cbfe5f10">ConcatenateIndeterminatesRefList</a> (const <a class="el" href="namespacedrake_1_1solvers.html#ac27bca68509bbb001ab8073089b48031">IndeterminatesRefList</a> &amp;var_list)</td></tr>
<tr class="memdesc:aca547471b139de0956139286cbfe5f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates each element in <code>var_list</code> into a single Eigen vector of indeterminates, returns this concatenated vector.  <a href="#aca547471b139de0956139286cbfe5f10">More...</a><br /></td></tr>
<tr class="separator:aca547471b139de0956139286cbfe5f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897158ddd3d5fd975edd151850ecc639"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classint.html">int</a>, -1, -1, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a897158ddd3d5fd975edd151850ecc639">EnumerateIntegerSolutions</a> (const Eigen::Ref&lt; const Eigen::MatrixXi &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;b, const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;lower_bound, const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;upper_bound)</td></tr>
<tr class="memdesc:a897158ddd3d5fd975edd151850ecc639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all integer solutions x to the linear inequalities.  <a href="#a897158ddd3d5fd975edd151850ecc639">More...</a><br /></td></tr>
<tr class="separator:a897158ddd3d5fd975edd151850ecc639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ba521ece6e61a25713f11610b01d97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ab3ba521ece6e61a25713f11610b01d97">CreateLogicalAndConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b2, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b1_and_b2)</td></tr>
<tr class="memdesc:ab3ba521ece6e61a25713f11610b01d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear constraints, such that when b1, b2, b1_and_b2 satisfy the constraints, and b1, b2 take binary values, it is guaranteed that b1_and_b2 = b1 ∧ b2 (b1 and b2).  <a href="#ab3ba521ece6e61a25713f11610b01d97">More...</a><br /></td></tr>
<tr class="separator:ab3ba521ece6e61a25713f11610b01d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3cfbf9597820039fe2d6c3f175731b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ada3cfbf9597820039fe2d6c3f175731b">CreateLogicalOrConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b2, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b1_or_b2)</td></tr>
<tr class="memdesc:ada3cfbf9597820039fe2d6c3f175731b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear constraints, such that when b1, b2, b1_or_b2 satisfy the constraints, and b1, b2 take binary values, it is guaranteed that b1_or_b2 = b1 ∨ b2 (b1 or b2).  <a href="#ada3cfbf9597820039fe2d6c3f175731b">More...</a><br /></td></tr>
<tr class="separator:ada3cfbf9597820039fe2d6c3f175731b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a863c255da14a1441e3ac58d082472"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#aa7a863c255da14a1441e3ac58d082472">CreateLogicalXorConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b2, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b1_xor_b2)</td></tr>
<tr class="memdesc:aa7a863c255da14a1441e3ac58d082472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add linear constraints, such that when b1, b2, b1_xor_b2 satisfy the constraints, and b1, b2 take binary values, it is guaranteed that b1_xor_b2 = b1 ⊕ b2 (b1 exclusive xor b2).  <a href="#aa7a863c255da14a1441e3ac58d082472">More...</a><br /></td></tr>
<tr class="separator:aa7a863c255da14a1441e3ac58d082472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1460b4c245321e57b234a724d774fc50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a1460b4c245321e57b234a724d774fc50">CreateBinaryCodeMatchConstraint</a> (const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &amp;code, const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;expected, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;match)</td></tr>
<tr class="memdesc:a1460b4c245321e57b234a724d774fc50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create linear constraints such that, when these constraints are satisfied, match = 1 if and only if code == expected, otherwise match = 0.  <a href="#a1460b4c245321e57b234a724d774fc50">More...</a><br /></td></tr>
<tr class="separator:a1460b4c245321e57b234a724d774fc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0cd38a406880348f0c7fda298c66c2"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#abf0cd38a406880348f0c7fda298c66c2">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog)</td></tr>
<tr class="separator:abf0cd38a406880348f0c7fda298c66c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014d2838aa5fae12520da4ebf46005ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a014d2838aa5fae12520da4ebf46005ca">GetVariableValue</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;var, const std::optional&lt; std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, <a class="el" href="classint.html">int</a> &gt;&gt; &amp;variable_index, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;variable_values)</td></tr>
<tr class="memdesc:a014d2838aa5fae12520da4ebf46005ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the value of a single variable <code>var</code> from <code>variable_values</code>.  <a href="#a014d2838aa5fae12520da4ebf46005ca">More...</a><br /></td></tr>
<tr class="separator:a014d2838aa5fae12520da4ebf46005ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8c88bd4238ccc189020ed7d99b1792"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:afd8c88bd4238ccc189020ed7d99b1792"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, <a class="el" href="namespacedrake.html#aaadcdc21cc0c381e5879b1b7f023d82d">MatrixLikewise</a>&lt; <a class="el" href="classdouble.html">double</a>, Derived &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#afd8c88bd4238ccc189020ed7d99b1792">GetVariableValue</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;var, const std::optional&lt; std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, <a class="el" href="classint.html">int</a> &gt;&gt; &amp;variable_index, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;variable_values)</td></tr>
<tr class="memdesc:afd8c88bd4238ccc189020ed7d99b1792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload <a class="el" href="namespacedrake_1_1solvers.html#a014d2838aa5fae12520da4ebf46005ca" title="Retrieve the value of a single variable var from variable_values.">GetVariableValue()</a> function, but for an Eigen matrix of decision variables.  <a href="#afd8c88bd4238ccc189020ed7d99b1792">More...</a><br /></td></tr>
<tr class="separator:afd8c88bd4238ccc189020ed7d99b1792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d06c693e90f6849f70d4b549f015e1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a0d06c693e90f6849f70d4b549f015e1e">ExponentiallySmoothedHingeLoss</a> (<a class="el" href="classdouble.html">double</a> <a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, <a class="el" href="classdouble.html">double</a> *penalty, <a class="el" href="classdouble.html">double</a> *dpenalty_dx)</td></tr>
<tr class="memdesc:a0d06c693e90f6849f70d4b549f015e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hinge loss function smoothed by exponential function.  <a href="#a0d06c693e90f6849f70d4b549f015e1e">More...</a><br /></td></tr>
<tr class="separator:a0d06c693e90f6849f70d4b549f015e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c445985c8e0f84a2f88f2e70c8f9983"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a5c445985c8e0f84a2f88f2e70c8f9983">QuadraticallySmoothedHingeLoss</a> (<a class="el" href="classdouble.html">double</a> <a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, <a class="el" href="classdouble.html">double</a> *penalty, <a class="el" href="classdouble.html">double</a> *dpenalty_dx)</td></tr>
<tr class="memdesc:a5c445985c8e0f84a2f88f2e70c8f9983"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear hinge loss, smoothed with a quadratic loss near the origin.  <a href="#a5c445985c8e0f84a2f88f2e70c8f9983">More...</a><br /></td></tr>
<tr class="separator:a5c445985c8e0f84a2f88f2e70c8f9983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7d6f23d494612f72e8efc99b87143c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a2f7d6f23d494612f72e8efc99b87143c">CeilLog2</a> (<a class="el" href="classint.html">int</a> n)</td></tr>
<tr class="memdesc:a2f7d6f23d494612f72e8efc99b87143c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return ⌈log₂(n)⌉, namely the minimal integer no smaller than log₂(n), with base 2.  <a href="#a2f7d6f23d494612f72e8efc99b87143c">More...</a><br /></td></tr>
<tr class="separator:a2f7d6f23d494612f72e8efc99b87143c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbd203e51076aa08e497620f11187b4"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a5cbd203e51076aa08e497620f11187b4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">drake::is_eigen_vector_of</a>&lt; Derived, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;::value, typename <a class="el" href="structdrake_1_1solvers_1_1_logarithmic_sos2_new_binary_variables.html">LogarithmicSos2NewBinaryVariables</a>&lt; Derived::RowsAtCompileTime &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a5cbd203e51076aa08e497620f11187b4">AddLogarithmicSos2Constraint</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::MatrixBase&lt; Derived &gt; &amp;lambda, const std::string &amp;binary_variable_name=&quot;y&quot;)</td></tr>
<tr class="memdesc:a5cbd203e51076aa08e497620f11187b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the special ordered set 2 (SOS2) constraint,.  <a href="#a5cbd203e51076aa08e497620f11187b4">More...</a><br /></td></tr>
<tr class="separator:a5cbd203e51076aa08e497620f11187b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49d99f80f15d8e6bdd6a6c2d2fdcc23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#af49d99f80f15d8e6bdd6a6c2d2fdcc23">AddLogarithmicSos2Constraint</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;lambda, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;y)</td></tr>
<tr class="memdesc:af49d99f80f15d8e6bdd6a6c2d2fdcc23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the special ordered set 2 (SOS2) constraint,.  <a href="#af49d99f80f15d8e6bdd6a6c2d2fdcc23">More...</a><br /></td></tr>
<tr class="separator:af49d99f80f15d8e6bdd6a6c2d2fdcc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46c83406ebd077e9c93b5ea05946ee2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ab46c83406ebd077e9c93b5ea05946ee2">AddSos2Constraint</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;lambda, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;y)</td></tr>
<tr class="memdesc:ab46c83406ebd077e9c93b5ea05946ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the special ordered set 2 (SOS2) constraint.  <a href="#ab46c83406ebd077e9c93b5ea05946ee2">More...</a><br /></td></tr>
<tr class="separator:ab46c83406ebd077e9c93b5ea05946ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3dd262dc400586c539cd57b1bb311ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ab3dd262dc400586c539cd57b1bb311ed">AddLogarithmicSos1Constraint</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;lambda, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;y, const Eigen::Ref&lt; const Eigen::MatrixXi &gt; &amp;binary_encoding)</td></tr>
<tr class="memdesc:ab3dd262dc400586c539cd57b1bb311ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the special ordered set of type 1 (SOS1) constraint.  <a href="#ab3dd262dc400586c539cd57b1bb311ed">More...</a><br /></td></tr>
<tr class="separator:ab3dd262dc400586c539cd57b1bb311ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8dc4e6bf90d7180583c31a7c06381b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a6a8dc4e6bf90d7180583c31a7c06381b">AddLogarithmicSos1Constraint</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, <a class="el" href="classint.html">int</a> num_lambda)</td></tr>
<tr class="memdesc:a6a8dc4e6bf90d7180583c31a7c06381b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the special ordered set of type 1 (SOS1) constraint.  <a href="#a6a8dc4e6bf90d7180583c31a7c06381b">More...</a><br /></td></tr>
<tr class="separator:a6a8dc4e6bf90d7180583c31a7c06381b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc62e1bcb70d02de2cb87f7bea20bc77"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#afc62e1bcb70d02de2cb87f7bea20bc77">to_string</a> (<a class="el" href="namespacedrake_1_1solvers.html#a6297509967536d29159910e5c51fd285">IntervalBinning</a> interval_binning)</td></tr>
<tr class="separator:afc62e1bcb70d02de2cb87f7bea20bc77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c59daf7e576403f76128d2063303e9b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a6c59daf7e576403f76128d2063303e9b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="namespacedrake_1_1solvers.html#a6297509967536d29159910e5c51fd285">IntervalBinning</a> &amp;binning)</td></tr>
<tr class="separator:a6c59daf7e576403f76128d2063303e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2dee1da65ed555024f9d2f7ba82141"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPhiX , typename DerivedPhiY , typename DerivedBx , typename DerivedBy &gt; </td></tr>
<tr class="memitem:a1c2dee1da65ed555024f9d2f7ba82141"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt; DerivedPhiX, <a class="el" href="classdouble.html">double</a> &gt;::value &amp;&amp;<a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt; DerivedPhiY, <a class="el" href="classdouble.html">double</a> &gt;::value &amp;&amp;<a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt; DerivedBx, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;::value &amp;&amp;<a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt; DerivedBy, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;::value, <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; DerivedPhiX::RowsAtCompileTime, DerivedPhiY::RowsAtCompileTime &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a1c2dee1da65ed555024f9d2f7ba82141">AddBilinearProductMcCormickEnvelopeSos2</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;<a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;y, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;w, const DerivedPhiX &amp;phi_x, const DerivedPhiY &amp;phi_y, const DerivedBx &amp;Bx, const DerivedBy &amp;By, <a class="el" href="namespacedrake_1_1solvers.html#a6297509967536d29159910e5c51fd285">IntervalBinning</a> binning)</td></tr>
<tr class="memdesc:a1c2dee1da65ed555024f9d2f7ba82141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add constraints to the optimization program, such that the bilinear product x * y is approximated by w, using Special Ordered Set of Type 2 (sos2) constraint.  <a href="#a1c2dee1da65ed555024f9d2f7ba82141">More...</a><br /></td></tr>
<tr class="separator:a1c2dee1da65ed555024f9d2f7ba82141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f7d44186352e1090de1343d468cad2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a81f7d44186352e1090de1343d468cad2">AddBilinearProductMcCormickEnvelopeMultipleChoice</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;<a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;y, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;w, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;phi_x, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;phi_y, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;Bx, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;By)</td></tr>
<tr class="memdesc:a81f7d44186352e1090de1343d468cad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add constraints to the optimization program, such that the bilinear product x * y is approximated by w, using Mixed Integer constraint with "Multiple
Choice" model.  <a href="#a81f7d44186352e1090de1343d468cad2">More...</a><br /></td></tr>
<tr class="separator:a81f7d44186352e1090de1343d468cad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1311acfcf14624ea4089d19783d824"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#abd1311acfcf14624ea4089d19783d824">to_string</a> (<a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_rotation_constraint_generator.html#a50cc1069474becb0998889b417d7b4ff">MixedIntegerRotationConstraintGenerator::Approach</a> type)</td></tr>
<tr class="separator:abd1311acfcf14624ea4089d19783d824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bfa8de91e5e18137f387121fb80933"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ac9bfa8de91e5e18137f387121fb80933">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_rotation_constraint_generator.html#a50cc1069474becb0998889b417d7b4ff">MixedIntegerRotationConstraintGenerator::Approach</a> &amp;type)</td></tr>
<tr class="separator:ac9bfa8de91e5e18137f387121fb80933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86dd14a5111afdacac8ccbbd0fafc9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1solvers_1_1_add_rotation_matrix_box_sphere_intersection_return.html">AddRotationMatrixBoxSphereIntersectionReturn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#af86dd14a5111afdacac8ccbbd0fafc9a">AddRotationMatrixBoxSphereIntersectionMilpConstraints</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt;&gt; &amp;R, <a class="el" href="classint.html">int</a> num_intervals_per_half_axis, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog)</td></tr>
<tr class="memdesc:af86dd14a5111afdacac8ccbbd0fafc9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds binary variables that constrain the value of the column <em>and</em> row vectors of R, in order to add the following (in some cases non-convex) constraints as an MILP.  <a href="#af86dd14a5111afdacac8ccbbd0fafc9a">More...</a><br /></td></tr>
<tr class="separator:af86dd14a5111afdacac8ccbbd0fafc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b2d302506a6a2fe144c79bd2598131"><td class="memItemLeft" align="right" valign="top">std::pair&lt; Eigen::MatrixXd, Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#af6b2d302506a6a2fe144c79bd2598131">DecomposeNonConvexQuadraticForm</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q)</td></tr>
<tr class="memdesc:af6b2d302506a6a2fe144c79bd2598131"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a non-convex homogeneous quadratic form xᵀQx, where Q is not necessarily a positive semidefinite matrix, we decompose it as a difference between two convex homogeneous quadratic forms xᵀQx = xᵀQ₁x - xᵀQ₂x, Q₁, Q₂ are positive semidefinite.  <a href="#af6b2d302506a6a2fe144c79bd2598131">More...</a><br /></td></tr>
<tr class="separator:af6b2d302506a6a2fe144c79bd2598131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea88a3c59172c77e8537633348a057a9"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;, std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; &gt;, <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__solver__evaluators.html#gaea88a3c59172c77e8537633348a057a9">AddRelaxNonConvexQuadraticConstraintInTrustRegion</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;<a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q1, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q2, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;y, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;p, <a class="el" href="classdouble.html">double</a> lower_bound, <a class="el" href="classdouble.html">double</a> upper_bound, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;linearization_point, <a class="el" href="classdouble.html">double</a> trust_region_gap)</td></tr>
<tr class="memdesc:gaea88a3c59172c77e8537633348a057a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a non-convex quadratic constraint lb ≤ xᵀQ₁x - xᵀQ₂x + pᵀy ≤ ub where Q₁, Q₂ are both positive semidefinite matrices.  <a href="group__solver__evaluators.html#gaea88a3c59172c77e8537633348a057a9">More...</a><br /></td></tr>
<tr class="separator:gaea88a3c59172c77e8537633348a057a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9345a87a13b6c67ee3f98a0910b133c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a9345a87a13b6c67ee3f98a0910b133c9">AreRequiredAttributesSupported</a> (const <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;required, const <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;supported, std::string *unsupported_message=nullptr)</td></tr>
<tr class="memdesc:a9345a87a13b6c67ee3f98a0910b133c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff <code>required</code> is a subset of <code>supported</code>.  <a href="#a9345a87a13b6c67ee3f98a0910b133c9">More...</a><br /></td></tr>
<tr class="separator:a9345a87a13b6c67ee3f98a0910b133c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb26b995d486732f1b2867751dbbee7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#adfb26b995d486732f1b2867751dbbee7">to_string</a> (const <a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a> &amp;)</td></tr>
<tr class="separator:adfb26b995d486732f1b2867751dbbee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa3414cee7c7ef46d8549673b42e344"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a5fa3414cee7c7ef46d8549673b42e344">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a> &amp;)</td></tr>
<tr class="separator:a5fa3414cee7c7ef46d8549673b42e344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3eb74236fcb577dba315f884034169"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#aab3eb74236fcb577dba315f884034169">to_string</a> (const <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;)</td></tr>
<tr class="separator:aab3eb74236fcb577dba315f884034169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9c2c72528e25a82932f03228d9c867"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a3d9c2c72528e25a82932f03228d9c867">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;)</td></tr>
<tr class="separator:a3d9c2c72528e25a82932f03228d9c867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1c2ddcf985a67cb331f1a797143081"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a1b1c2ddcf985a67cb331f1a797143081">to_string</a> (const <a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15">ProgramType</a> &amp;)</td></tr>
<tr class="separator:a1b1c2ddcf985a67cb331f1a797143081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd6047c1efdb345f4761a04b3764c90"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#adbd6047c1efdb345f4761a04b3764c90">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15">ProgramType</a> &amp;)</td></tr>
<tr class="separator:adbd6047c1efdb345f4761a04b3764c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfb56c6154dc071912945d08ee6833b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a8cfb56c6154dc071912945d08ee6833b">NewRotationMatrixVars</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const std::string &amp;name=&quot;R&quot;)</td></tr>
<tr class="memdesc:a8cfb56c6154dc071912945d08ee6833b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a 3x3 matrix of decision variables with the trivial bounding box constraint ensuring all elements are [-1,1], and the linear constraint imposing -1 &lt;= trace(R) &lt;= 3.  <a href="#a8cfb56c6154dc071912945d08ee6833b">More...</a><br /></td></tr>
<tr class="separator:a8cfb56c6154dc071912945d08ee6833b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7466e7ce1b8db6de94ad0524f8106d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a0c7466e7ce1b8db6de94ad0524f8106d">AddBoundingBoxConstraintsImpliedByRollPitchYawLimits</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt;&gt; &amp;R, <a class="el" href="namespacedrake_1_1solvers.html#a55b1b3c88fe94fd28d7564b90f50a00f">RollPitchYawLimits</a> limits=<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74a34bbac4b028a742de1b931cc2694dcea">kNoLimits</a>)</td></tr>
<tr class="memdesc:a0c7466e7ce1b8db6de94ad0524f8106d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies <em>very conservative</em> limits on the entries of R for the cases when rotations can be limited (for instance, if you want to search over rotations, but there is an obvious symmetry in the problem so that e.g.  <a href="#a0c7466e7ce1b8db6de94ad0524f8106d">More...</a><br /></td></tr>
<tr class="separator:a0c7466e7ce1b8db6de94ad0524f8106d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9202a27d1c86559e9496ec01fde853e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a9202a27d1c86559e9496ec01fde853e9">AddRotationMatrixSpectrahedralSdpConstraint</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt;&gt; &amp;R)</td></tr>
<tr class="memdesc:a9202a27d1c86559e9496ec01fde853e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraint (10) from <a href="https://arxiv.org/pdf/1403.4914.pdf">https://arxiv.org/pdf/1403.4914.pdf</a> , which exactly represents the convex hull of all rotation matrices in 3D.  <a href="#a9202a27d1c86559e9496ec01fde853e9">More...</a><br /></td></tr>
<tr class="separator:a9202a27d1c86559e9496ec01fde853e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6304aed086cdd57240ad1f57b66a7986"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a6304aed086cdd57240ad1f57b66a7986">AddRotationMatrixOrthonormalSocpConstraint</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt;&gt; &amp;R)</td></tr>
<tr class="memdesc:a6304aed086cdd57240ad1f57b66a7986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a set of convex constraints which approximate the set of orthogonal matrices, O(3).  <a href="#a6304aed086cdd57240ad1f57b66a7986">More...</a><br /></td></tr>
<tr class="separator:a6304aed086cdd57240ad1f57b66a7986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2294ac3fe1dc938852cfa11db48ba1c9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a2294ac3fe1dc938852cfa11db48ba1c9">to_string</a> (const <a class="el" href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3">RemoveFreeVariableMethod</a> &amp;)</td></tr>
<tr class="separator:a2294ac3fe1dc938852cfa11db48ba1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2470f8cacd8e5f5a473b10d0acf6cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#aeb2470f8cacd8e5f5a473b10d0acf6cc">GenerateSDPA</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog, const std::string &amp;file_name, <a class="el" href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3">RemoveFreeVariableMethod</a> method=<a class="el" href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3a54b9d7601ece96fc42e2ffd67aae2690">RemoveFreeVariableMethod::kNullspace</a>)</td></tr>
<tr class="memdesc:aeb2470f8cacd8e5f5a473b10d0acf6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDPA is a format to record an SDP problem.  <a href="#aeb2470f8cacd8e5f5a473b10d0acf6cc">More...</a><br /></td></tr>
<tr class="separator:aeb2470f8cacd8e5f5a473b10d0acf6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6da6d265dcd5e959082b17d3a94258b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#af6da6d265dcd5e959082b17d3a94258b">MakeSemidefiniteRelaxation</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog)</td></tr>
<tr class="memdesc:af6da6d265dcd5e959082b17d3a94258b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> which represents the semidefinite programming convex relaxation of the (likely nonconvex) program <code>prog</code>.  <a href="#af6da6d265dcd5e959082b17d3a94258b">More...</a><br /></td></tr>
<tr class="separator:af6da6d265dcd5e959082b17d3a94258b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56eb3fcc2f03d972f06486730916cbf0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a56eb3fcc2f03d972f06486730916cbf0">MakeSemidefiniteRelaxation</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog, const std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &gt; &amp;variable_groups)</td></tr>
<tr class="memdesc:a56eb3fcc2f03d972f06486730916cbf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version of MakeSemidefiniteRelaxation that allows for specifying the sparsity of the relaxation.  <a href="#a56eb3fcc2f03d972f06486730916cbf0">More...</a><br /></td></tr>
<tr class="separator:a56eb3fcc2f03d972f06486730916cbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1201a087105dc635e2bd748486171c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#acb1201a087105dc635e2bd748486171c">to_string</a> (<a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a> solution_result)</td></tr>
<tr class="separator:acb1201a087105dc635e2bd748486171c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269b7066a168f80390ed6c496829ffcd"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a269b7066a168f80390ed6c496829ffcd">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a> solution_result)</td></tr>
<tr class="separator:a269b7066a168f80390ed6c496829ffcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bf1722e3e347d7878ae44be98b4b92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92">Solve</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog, const std::optional&lt; Eigen::VectorXd &gt; &amp;initial_guess, const std::optional&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &gt; &amp;solver_options)</td></tr>
<tr class="memdesc:a07bf1722e3e347d7878ae44be98b4b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves an optimization program, with optional initial guess and solver options.  <a href="#a07bf1722e3e347d7878ae44be98b4b92">More...</a><br /></td></tr>
<tr class="separator:a07bf1722e3e347d7878ae44be98b4b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78328b8267370289c8c653bc67efde5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a78328b8267370289c8c653bc67efde5e">Solve</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;initial_guess)</td></tr>
<tr class="memdesc:a78328b8267370289c8c653bc67efde5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves an optimization program with a given initial guess.  <a href="#a78328b8267370289c8c653bc67efde5e">More...</a><br /></td></tr>
<tr class="separator:a78328b8267370289c8c653bc67efde5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8160cf69cc8a3cd41dfec1fb08a8fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a6f8160cf69cc8a3cd41dfec1fb08a8fa">Solve</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog)</td></tr>
<tr class="separator:a6f8160cf69cc8a3cd41dfec1fb08a8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8463238715a273b4709959e9bf23b9af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a8463238715a273b4709959e9bf23b9af">operator==</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;, const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;)</td></tr>
<tr class="separator:a8463238715a273b4709959e9bf23b9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710dbb02b7a2ce05760b1534cd7b32d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a710dbb02b7a2ce05760b1534cd7b32d9">operator!=</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;, const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;)</td></tr>
<tr class="separator:a710dbb02b7a2ce05760b1534cd7b32d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22da0124afc42f58ae6e42e1a97b724"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#af22da0124afc42f58ae6e42e1a97b724">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;)</td></tr>
<tr class="separator:af22da0124afc42f58ae6e42e1a97b724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16445fc3b260d8c58ea9082a3594f85f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a16445fc3b260d8c58ea9082a3594f85f">to_string</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &amp;)</td></tr>
<tr class="separator:a16445fc3b260d8c58ea9082a3594f85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58cede9876421e050ac44deee7804ff"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ad58cede9876421e050ac44deee7804ff">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &amp;)</td></tr>
<tr class="separator:ad58cede9876421e050ac44deee7804ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6703c1f6f99f3e06a86f6a54e7dbd63d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">drake::VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a6703c1f6f99f3e06a86f6a54e7dbd63d">ConstructMonomialBasis</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">drake::symbolic::Polynomial</a> &amp;p)</td></tr>
<tr class="memdesc:a6703c1f6f99f3e06a86f6a54e7dbd63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given input polynomial p, outputs a set M of monomials with the following guarantee: if p = f1*f1 + f2*f2 + ...  <a href="#a6703c1f6f99f3e06a86f6a54e7dbd63d">More...</a><br /></td></tr>
<tr class="separator:a6703c1f6f99f3e06a86f6a54e7dbd63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aa708f80d971209e3d46c1e41f05c1393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa708f80d971209e3d46c1e41f05c1393">&#9670;&nbsp;</a></span>DecisionVariable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#aa708f80d971209e3d46c1e41f05c1393">DecisionVariable</a> =  <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac27bca68509bbb001ab8073089b48031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac27bca68509bbb001ab8073089b48031">&#9670;&nbsp;</a></span>IndeterminatesRefList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#ac27bca68509bbb001ab8073089b48031">IndeterminatesRefList</a> =  std::list&lt;Eigen::Ref&lt;const <a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf84184cb10b49233b007295d1880e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf84184cb10b49233b007295d1880e17">&#9670;&nbsp;</a></span>MatrixDecisionVariable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a> =  Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>, rows, cols&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f19da4730aeebddf6a1d14f51f0b7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f19da4730aeebddf6a1d14f51f0b7ec">&#9670;&nbsp;</a></span>MatrixIndeterminate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a> =  Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>, rows, cols&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MatrixIndeterminate&lt;int, int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable, int, int&gt;. </p>
<p>After resolving aliases, a compiler does not distinguish between these two. All indeterminates are a variable of type <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a5f787df9cdf370248382504196841479ab1fa9dd3af034b3ef4291579aa673c07" title="A CONTINUOUS variable takes a double value.">symbolic::Variable::Type::CONTINUOUS</a> (by default). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix containing indeterminates. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns in the new matrix containing indeterminates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac04cfbe6b8d63ecb463fc087385ce061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04cfbe6b8d63ecb463fc087385ce061">&#9670;&nbsp;</a></span>MatrixXDecisionVariable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> =  <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt;Eigen::Dynamic, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a60e13290a9b854b4fee070764f978d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e13290a9b854b4fee070764f978d22">&#9670;&nbsp;</a></span>MatrixXIndeterminate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#a60e13290a9b854b4fee070764f978d22">MatrixXIndeterminate</a> =  <a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a>&lt;Eigen::Dynamic, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MatrixXIndeterminate is used as an alias for Eigen::Matrix&lt;symbolic::Variable, Eigen::Dynamic, Eigen::Dynamic&gt;. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec" title="MatrixIndeterminate&lt;int, int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable,...">MatrixIndeterminate&lt;int, int&gt;</a> </dd></dl>

</div>
</div>
<a id="adc2a57e87ae4e4088e12967a25a7c229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2a57e87ae4e4088e12967a25a7c229">&#9670;&nbsp;</a></span>MinimumValuePenaltyFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#adc2a57e87ae4e4088e12967a25a7c229">MinimumValuePenaltyFunction</a> =  std::function&lt;void(<a class="el" href="classdouble.html">double</a> <a class="el" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, <a class="el" href="classdouble.html">double</a>* penalty, <a class="el" href="classdouble.html">double</a>* dpenalty_dx)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the penalty function φ(x) and its derivatives dφ(x)/dx. </p>
<p>Valid penalty functions must meet the following criteria:</p>
<ol type="1">
<li>φ(x) ≥ 0 ∀ x ∈ ℝ.</li>
<li>dφ(x)/dx ≤ 0 ∀ x ∈ ℝ.</li>
<li>φ(x) = 0 ∀ x ≥ 0.</li>
<li>dφ(x)/dx &lt; 0 ∀ x &lt; 0.</li>
</ol>
<p>If <code>dpenalty_dx</code> is nullptr, the function should only compute φ(x). </p>

</div>
</div>
<a id="a5617ec1dc3b70cd1683d8850fe69585d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5617ec1dc3b70cd1683d8850fe69585d">&#9670;&nbsp;</a></span>ProgramAttributes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> =  std::unordered_set&lt;<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a>, <a class="el" href="namespacedrake.html#a323dc8b0cc629c61d4da8feeaa8cd4f5">DefaultHash</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a55b1b3c88fe94fd28d7564b90f50a00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b1b3c88fe94fd28d7564b90f50a00f">&#9670;&nbsp;</a></span>RollPitchYawLimits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="namespacedrake_1_1solvers.html#a55b1b3c88fe94fd28d7564b90f50a00f">RollPitchYawLimits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a062b182db5c52f5a71221a4c5958ea0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062b182db5c52f5a71221a4c5958ea0b">&#9670;&nbsp;</a></span>VariableRefList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> =  std::list&lt;Eigen::Ref&lt;const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa20d09ae94d1e722c2961fbaca37f967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20d09ae94d1e722c2961fbaca37f967">&#9670;&nbsp;</a></span>VectorDecisionVariable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a> =  <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt;rows, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0943cc7cf2cc9bf7db6facfe53a8568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0943cc7cf2cc9bf7db6facfe53a8568">&#9670;&nbsp;</a></span>VectorIndeterminate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a> =  <a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a>&lt;rows, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VectorIndeterminate&lt;int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable, int, 1&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix containing indeterminates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec" title="MatrixIndeterminate&lt;int, int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable,...">MatrixIndeterminate&lt;int, int&gt;</a> </dd></dl>

</div>
</div>
<a id="aca924499b3b011a50d3bd9d051295efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca924499b3b011a50d3bd9d051295efa">&#9670;&nbsp;</a></span>VectorXDecisionVariable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> =  <a class="el" href="namespacedrake_1_1solvers.html#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a>&lt;Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91ed74a4ca04549f64c547dfba0724d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ed74a4ca04549f64c547dfba0724d5">&#9670;&nbsp;</a></span>VectorXIndeterminate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a> =  <a class="el" href="namespacedrake_1_1solvers.html#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a>&lt;Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VectorXIndeterminate is used as an alias for Eigen::Matrix&lt;symbolic::Variable, Eigen::Dynamic, 1&gt;. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec" title="MatrixIndeterminate&lt;int, int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable,...">MatrixIndeterminate&lt;int, int&gt;</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ae07229124cd16e9d8b62fe359c7d0b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07229124cd16e9d8b62fe359c7d0b40">&#9670;&nbsp;</a></span>CommonSolverOption</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1solvers.html#ae07229124cd16e9d8b62fe359c7d0b40">CommonSolverOption</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Some options can be applied to not one solver, but many solvers (for example, many solvers support printing out the progress in each iteration). </p>
<p>CommonSolverOption contain the names of these supported options. The user can use these options as "key" in SolverOption::SetOption(). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae07229124cd16e9d8b62fe359c7d0b40a222307df6fb67d2a524cade7227ca4f8"></a>kPrintFileName&#160;</td><td class="fielddoc"><p>Many solvers support printing the progress of each iteration to a file. </p>
<p>The user can call SolverOptions::SetOption(kPrintFileName, file_name) where file_name is a string. If the user doesn't want to print to a file, then use <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html#a64f5a75df2c33b77454e88fae4d08047" title="Sets a double-valued solver option for a specific solver.">SolverOptions::SetOption</a>(kPrintFileName, ""), where the empty string "" indicates no print. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae07229124cd16e9d8b62fe359c7d0b40aca5719f05d0aceacc42e256644394100"></a>kPrintToConsole&#160;</td><td class="fielddoc"><p>Many solvers support printing the progress of each iteration to the console, the user can call SolverOptions::SetOption(kPrintToConsole, 1) to turn on printing to the console, or SolverOptions::SetOption(kPrintToConsole, 0) to turn off printing to the console. </p>
</td></tr>
</table>

</div>
</div>
<a id="a6297509967536d29159910e5c51fd285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6297509967536d29159910e5c51fd285">&#9670;&nbsp;</a></span>IntervalBinning</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1solvers.html#a6297509967536d29159910e5c51fd285">IntervalBinning</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a continuous variable whose range is cut into small intervals, we will use binary variables to represent which interval the continuous variable is in. </p>
<p>We support two representations, either using logarithmic number of binary variables, or linear number of binary variables. For more details, </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1solvers.html#a5cbd203e51076aa08e497620f11187b4" title="Adds the special ordered set 2 (SOS2) constraint,.">AddLogarithmicSos2Constraint</a> and <a class="el" href="namespacedrake_1_1solvers.html#ab46c83406ebd077e9c93b5ea05946ee2" title="Adds the special ordered set 2 (SOS2) constraint.">AddSos2Constraint</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6297509967536d29159910e5c51fd285a5bff8e60dc42878e194fb2d87460ed29"></a>kLogarithmic&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6297509967536d29159910e5c51fd285aac97f0008bcf7c7fe4f2ff94160e1385"></a>kLinear&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a115b732b5de5502e59437ee38babe95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115b732b5de5502e59437ee38babe95f">&#9670;&nbsp;</a></span>ProgramAttribute</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa597a3cf4953daab8ab5e6ffebeff44d0"></a>kGenericCost&#160;</td><td class="fielddoc"><p>A generic cost, doesn't belong to any specific cost type below. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fad7bf05f9b17385b6e8aa383fc67fc83f"></a>kGenericConstraint&#160;</td><td class="fielddoc"><p>A generic constraint, doesn't belong to any specific constraint type below. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa29122b5334de24190e886ea289d14a2a"></a>kQuadraticCost&#160;</td><td class="fielddoc"><p>A quadratic function as the cost. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fae8503f9b8b6fbe23f14ac068f665c9c0"></a>kQuadraticConstraint&#160;</td><td class="fielddoc"><p>A constraint on a quadratic function. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa302b09f3d249d023c8aaad1097b50edb"></a>kLinearCost&#160;</td><td class="fielddoc"><p>A linear function as the cost. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa42f1335762da576901b57e5b118858e9"></a>kLinearConstraint&#160;</td><td class="fielddoc"><p>A constraint on a linear function. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa48d237e8d01c95129ecc34be15f4b789"></a>kLinearEqualityConstraint&#160;</td><td class="fielddoc"><p>An equality constraint on a linear function. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa8c8fa060b46a40b2fd97509493514f33"></a>kLinearComplementarityConstraint&#160;</td><td class="fielddoc"><p>A linear complementarity constraint in the form 0 ≤ z ⊥ Mz+q ≥ 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95faa19344b8110a4be1b5581a25f612713f"></a>kLorentzConeConstraint&#160;</td><td class="fielddoc"><p>A Lorentz cone constraint. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa9e8364decaab78121a0ceaabb57c72cc"></a>kRotatedLorentzConeConstraint&#160;</td><td class="fielddoc"><p>A rotated Lorentz cone constraint. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa59e241294144c7cdf7ea7c8e64b361aa"></a>kPositiveSemidefiniteConstraint&#160;</td><td class="fielddoc"><p>A positive semidefinite constraint. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa6186f6ad8f4222b61ec29ea48a046299"></a>kExponentialConeConstraint&#160;</td><td class="fielddoc"><p>An exponential cone constraint. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa2b988d83ab42142c09d442f5b42904f3"></a>kL2NormCost&#160;</td><td class="fielddoc"><p>An L2 norm |Ax+b|. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa12a1034a77cf500ebcff46f8e493bb10"></a>kBinaryVariable&#160;</td><td class="fielddoc"><p>Variable taking binary value {0, 1}. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa288767e402655671f06cd5313e8bada9"></a>kCallback&#160;</td><td class="fielddoc"><p>Supports callback during solving the problem. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab09ca5e1afe9e5a4e8744ecb27839b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09ca5e1afe9e5a4e8744ecb27839b15">&#9670;&nbsp;</a></span>ProgramType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15">ProgramType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A coarse categorization of the optimization problem based on the type of constraints/costs/variables. </p>
<p>Notice that Drake chooses the solver based on a finer category; for example we have a specific solver for equality-constrained convex QP. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15a3e3af9259f19c76c1a21cacdbd5afd4a"></a>kLP&#160;</td><td class="fielddoc"><p>Linear Programming, with a linear cost and linear constraints. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15a9ac21b2be50204074e59ceb63526fae6"></a>kQP&#160;</td><td class="fielddoc"><p>Quadratic Programming, with a convex quadratic cost and linear constraints. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15a7cd173b34793fe6598118c124401da00"></a>kSOCP&#160;</td><td class="fielddoc"><p>Second-order Cone Programming, with a linear cost and second-order cone constraints. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15aeb3825da90413e715ee32c3463428d84"></a>kSDP&#160;</td><td class="fielddoc"><p>Semidefinite Programming, with a linear cost and positive semidefinite matrix constraints. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15a7ae933ebedf558cd02d3d45f0a1236cf"></a>kGP&#160;</td><td class="fielddoc"><p>Geometric Programming, with a linear cost and exponential cone constraints. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15a85d8a1af1f3ab3fb37aaef44ee44a436"></a>kCGP&#160;</td><td class="fielddoc"><p>Conic Geometric Programming, this is a superset that unifies GP and SDP. </p>
<p>Refer to <a href="http://people.lids.mit.edu/pari/cgp_preprint.pdf">http://people.lids.mit.edu/pari/cgp_preprint.pdf</a> for more details. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15a41adb3a46194a70e097f15c9848b2c97"></a>kMILP&#160;</td><td class="fielddoc"><p>Mixed-integer Linear Programming. </p>
<p>LP with some variables taking binary values. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15aa1029d46d3092d1662ee6baccbd926f8"></a>kMIQP&#160;</td><td class="fielddoc"><p>Mixed-integer Quadratic Programming. </p>
<p>QP with some variables taking binary values. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15af91d74856b95694eb9624142e4317bb4"></a>kMISOCP&#160;</td><td class="fielddoc"><p>Mixed-integer Second-order Cone Programming. </p>
<p>SOCP with some variables taking binary values. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15aea23768965b758e81bdb3e2fb62476c8"></a>kMISDP&#160;</td><td class="fielddoc"><p>Mixed-integer Semidefinite Programming. </p>
<p>SDP with some variables taking binary values. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15a914035c5bf9d877dbd17b8c476ab48a6"></a>kQuadraticCostConicConstraint&#160;</td><td class="fielddoc"><p>convex quadratic cost with nonlinear conic constraints. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15aced0324bc370cd8712746abd28ac3844"></a>kNLP&#160;</td><td class="fielddoc"><p>nonlinear programming. </p>
<p>Programs with generic costs or constraints. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15aad18a51c134b9ac1c2af4f45766761cf"></a>kLCP&#160;</td><td class="fielddoc"><p>Linear Complementarity Programs. </p>
<p>Programs with linear complementary constraints and no cost. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab09ca5e1afe9e5a4e8744ecb27839b15a25c2dc47991b3df171ed5192bcf70390"></a>kUnknown&#160;</td><td class="fielddoc"><p>Does not fall into any of the types above. </p>
</td></tr>
</table>

</div>
</div>
<a id="a121673ddbdadd10b2e3ceab52a93f5d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121673ddbdadd10b2e3ceab52a93f5d3">&#9670;&nbsp;</a></span>RemoveFreeVariableMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3">RemoveFreeVariableMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SDPA format doesn't accept free variables, namely the problem it solves is in this form P1. </p>
<pre class="fragment">max tr(C * X)
s.t tr(Aᵢ*X) = aᵢ
    X ≽ 0.
</pre><p>Notice that the decision variable X has to be in the proper cone X ≽ 0, and it doesn't accept free variable (without the conic constraint). On the other hand, most real-world applications require free variables, namely problems in this form P2 </p><pre class="fragment">max tr(C * X) + dᵀs
s.t tr(Aᵢ*X) + bᵢᵀs = aᵢ
    X ≽ 0
    s is free.
</pre><p>In order to remove the free variables, we consider three approaches.</p><ol type="1">
<li>Replace a free variable s with two variables s = p - q, p ≥ 0, q ≥ 0.</li>
<li><p class="startli">First write the dual of the problem P2 as D2 </p><pre class="fragment">min aᵀy
s.t ∑ᵢ yᵢAᵢ - C = Z
    Z ≽ 0
    Bᵀ * y = d,
</pre><p class="startli">where bᵢᵀ is the i'th row of B. The last constraint Bᵀ * y = d means y = ŷ + Nt, where Bᵀ * ŷ = d, and N is the null space of Bᵀ. Hence, D2 is equivalent to the following problem, D3 </p><pre class="fragment">min aᵀNt + aᵀŷ
s.t ∑ᵢ tᵢFᵢ - (C -∑ᵢ ŷᵢAᵢ) = Z
    Z ≽ 0,
</pre><p class="startli">where Fᵢ = ∑ⱼ NⱼᵢAⱼ. D3 is the dual of the following primal problem P3 without free variables </p><pre class="fragment">max tr((C-∑ᵢ ŷᵢAᵢ)*X̂) + aᵀŷ
s.t tr(FᵢX̂) = (Nᵀa)(i)
    X̂ ≽ 0.
</pre><p class="startli">Then (X, s) = (X̂, B⁻¹(a - tr(Aᵢ X̂))) is the solution to the original problem P2.</p>
</li>
<li>Add a slack variable t, with the Lorentz cone constraint t ≥ sqrt(sᵀs). </li>
</ol>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a121673ddbdadd10b2e3ceab52a93f5d3a268e3bfe4e48f70785a46a8d3552e552"></a>kTwoSlackVariables&#160;</td><td class="fielddoc"><p>Approach 1, replace a free variable s as s = y⁺ - y⁻, y⁺ ≥ 0, y⁻ ≥ 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="a121673ddbdadd10b2e3ceab52a93f5d3a54b9d7601ece96fc42e2ffd67aae2690"></a>kNullspace&#160;</td><td class="fielddoc"><p>Approach 2, reformulate the dual problem by considering the nullspace of the linear constraint in the dual. </p>
</td></tr>
<tr><td class="fieldname"><a id="a121673ddbdadd10b2e3ceab52a93f5d3a2992c87df2428b480924bf6c6509edec"></a>kLorentzConeSlack&#160;</td><td class="fielddoc"><p>Approach 3, add a slack variable t with the lorentz cone constraint t ≥ sqrt(sᵀs). </p>
</td></tr>
</table>

</div>
</div>
<a id="a1949f5edc628077e2d780c150de88d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1949f5edc628077e2d780c150de88d74">&#9670;&nbsp;</a></span>RollPitchYawLimitOptions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74">RollPitchYawLimitOptions</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74a34bbac4b028a742de1b931cc2694dcea"></a>kNoLimits&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74af029ec457c6dc0bdc5bee0edc2baf12d"></a>kRPYError&#160;</td><td class="fielddoc"><p>Do not use, to avoid &amp; vs. &amp;&amp; typos. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74af69f0d7bda8d330fcf89df333412794d"></a>kRoll_NegPI_2_to_PI_2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74a6973c9c90ce92aa52ce62a6e0fc4664d"></a>kRoll_0_to_PI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74adb2b51a6cdf2edf29dc2bfdcefef6ce0"></a>kPitch_NegPI_2_to_PI_2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74a56192ce118646021d72474e9520a804a"></a>kPitch_0_to_PI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74aa059fc525d6d174e5e070c7261ff8e43"></a>kYaw_NegPI_2_to_PI_2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74aca450e45c136c14aabb606a09e0775a8"></a>kYaw_0_to_PI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74a27402335e74462e03adf2c79e903705e"></a>kRoll_0_to_PI_2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74af031fdd95c7b0bd771a160bf2905eaae"></a>kPitch_0_to_PI_2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74aae2b1591bba5a77450b0df77a207be8f"></a>kYaw_0_to_PI_2&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a331f41a3139a87d16e1422bc818c136f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331f41a3139a87d16e1422bc818c136f">&#9670;&nbsp;</a></span>SolutionResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fa15e1c4845b9467d880999c78de6afe45"></a>kSolutionFound&#160;</td><td class="fielddoc"><p>Found the optimal solution. </p>
</td></tr>
<tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fa78cb430cc349315a2ba0f3602ef64b6d"></a>kInvalidInput&#160;</td><td class="fielddoc"><p>Invalid input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fa4f17cb26e989bf3f8c2990cd51fcede9"></a>kInfeasibleConstraints&#160;</td><td class="fielddoc"><p>The primal is infeasible. </p>
</td></tr>
<tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fa4b9de95ee3087851acd98262e09f0be8"></a>kUnbounded&#160;</td><td class="fielddoc"><p>The primal is unbounded. </p>
</td></tr>
<tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fa84d10e8dce3328bfb1f6761d194857f2"></a>kSolverSpecificError&#160;</td><td class="fielddoc"><p>Solver-specific error. </p>
<p>(Try <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html#a5b8dd00dcf89c4a841c058b6b4427c12" title="Gets the solver details for the Solver that solved the program.">MathematicalProgramResult::get_solver_details()</a> or enabling verbose solver output.) </p>
</td></tr>
<tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fa2bfbc12cb546f78bd0080b8df5b26520"></a>kInfeasibleOrUnbounded&#160;</td><td class="fielddoc"><p>The primal is either infeasible or unbounded. </p>
</td></tr>
<tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fa97600ae7efdb5c8fecf91e99463ef4ef"></a>kIterationLimit&#160;</td><td class="fielddoc"><p>Reaches the iteration limits. </p>
</td></tr>
<tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fae1f645d6b81b09a506f807a18d5e1d4b"></a>kDualInfeasible&#160;</td><td class="fielddoc"><p>Dual problem is infeasible. </p>
<p>In this case we cannot infer the status of the primal problem. </p>
</td></tr>
<tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fab42685181d035fb42e3da3462b4c0b55"></a>kSolutionResultNotSet&#160;</td><td class="fielddoc"><p>The initial (invalid) solution result. </p>
<p>This value should be overwritten by the solver during <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a>. </p>
</td></tr>
</table>

</div>
</div>
<a id="a8b06041d7c1fb05f379714f4312306ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b06041d7c1fb05f379714f4312306ec">&#9670;&nbsp;</a></span>SolverType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306ec">SolverType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This type only exists for backwards compatibility, and should not be used in new code. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306ecaa71a8c0a25fe7a3d777fc06d50bada13"></a>kClp&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306ecae654b0ad8f79045aff33844a0c3cdf81"></a>kCsdp&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306eca71cedba88b736e372f499099329d5173"></a>kEqualityConstrainedQP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306ecabc8ddfb8a00bb405e68545ce187ac238"></a>kGurobi&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306ecaa1f0780f88b19c3a73710b47fc57d795"></a>kIpopt&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306ecaebb0e280cb0e7da8a3868247749a4d9d"></a>kLinearSystem&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306ecabd0a61a2cf9acec23fccd41c7402ef56"></a>kMobyLCP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306eca18bc9cbd9bb764958e636263b1b53a9d"></a>kMosek&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306eca64e0ff0ce277a08ed59a9fe9140a8fd7"></a>kNlopt&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306eca6e645ae8d30d672d9800a422f4be4c9d"></a>kOsqp&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306eca6619293bd01e7ea8efb3682f16bf55c4"></a>kSnopt&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306ecad1ddb13aaaf649f197e0f6549596571c"></a>kScs&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306eca045139748552611db2ba18934b6f89f6"></a>kUnrevisedLemke&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a81f7d44186352e1090de1343d468cad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f7d44186352e1090de1343d468cad2">&#9670;&nbsp;</a></span>AddBilinearProductMcCormickEnvelopeMultipleChoice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::solvers::AddBilinearProductMcCormickEnvelopeMultipleChoice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>By</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add constraints to the optimization program, such that the bilinear product x * y is approximated by w, using Mixed Integer constraint with "Multiple
Choice" model. </p>
<p>To do so, we assume that the range of x is [x_min, x_max], and the range of y is [y_min, y_max]. We first consider two arrays φˣ, φʸ, satisfying </p><div class="fragment"><div class="line">x_min = φˣ₀ &lt; φˣ₁ &lt; ... &lt; φˣₘ = x_max</div><div class="line">y_min = φʸ₀ &lt; φʸ₁ &lt; ... &lt; φʸₙ = y_max</div></div><!-- fragment --><p> , and divide the range of x into intervals [φˣ₀, φˣ₁], [φˣ₁, φˣ₂], ... , [φˣₘ₋₁, φˣₘ] and the range of y into intervals [φʸ₀, φʸ₁], [φʸ₁, φʸ₂], ... , [φʸₙ₋₁, φʸₙ]. The xy plane is thus cut into rectangles, with each rectangle as [φˣᵢ, φˣᵢ₊₁] x [φʸⱼ, φʸⱼ₊₁]. The convex hull of the surface z = x * y for x, y in each rectangle is a tetrahedron. We then approximate the bilinear product x * y with w, such that (x, y, w) is in one of the tetrahedrons. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>The optimization problem to which the constraints will be added. </td></tr>
    <tr><td class="paramname">x</td><td>A variable in the bilinear product. </td></tr>
    <tr><td class="paramname">y</td><td>A variable in the bilinear product. </td></tr>
    <tr><td class="paramname">w</td><td>The expression that approximates the bilinear product x * y. </td></tr>
    <tr><td class="paramname">phi_x</td><td>φˣ in the documentation above. Will be used to cut the range of x into small intervals. </td></tr>
    <tr><td class="paramname">phi_y</td><td>φʸ in the documentation above. Will be used to cut the range of y into small intervals. </td></tr>
    <tr><td class="paramname">Bx</td><td>The binary-valued expression indicating which interval x is in. Bx(i) = 1 =&gt; φˣᵢ ≤ x ≤ φˣᵢ₊₁. </td></tr>
    <tr><td class="paramname">By</td><td>The binary-valued expression indicating which interval y is in. By(i) = 1 =&gt; φʸⱼ ≤ y ≤ φʸⱼ₊₁.</td></tr>
  </table>
  </dd>
</dl>
<p>One formulation of the constraint is </p><div class="fragment"><div class="line"><a class="code" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> = ∑ᵢⱼ x̂ᵢⱼ</div><div class="line">y = ∑ᵢⱼ ŷᵢⱼ</div><div class="line">Bˣʸᵢⱼ = Bˣᵢ ∧ Bʸⱼ</div><div class="line">∑ᵢⱼ Bˣʸᵢⱼ = 1</div><div class="line">φˣᵢ Bˣʸᵢⱼ ≤ x̂ᵢⱼ ≤ φˣᵢ₊₁ Bˣʸᵢⱼ</div><div class="line">φʸⱼ Bˣʸᵢⱼ ≤ ŷᵢⱼ ≤ φʸⱼ₊₁ Bˣʸᵢⱼ</div><div class="line">w ≥ ∑ᵢⱼ (x̂ᵢⱼ φʸⱼ   + φˣᵢ   ŷᵢⱼ - φˣᵢ  φʸⱼ   Bˣʸᵢⱼ)</div><div class="line">w ≥ ∑ᵢⱼ (x̂ᵢⱼ φʸⱼ₊₁ + φˣᵢ₊₁ ŷᵢⱼ - φˣᵢ₊₁ φʸⱼ₊₁ Bˣʸᵢⱼ)</div><div class="line">w ≤ ∑ᵢⱼ (x̂ᵢⱼ φʸⱼ   + φˣᵢ₊₁ ŷᵢⱼ - φˣᵢ₊₁ φʸⱼ   Bˣʸᵢⱼ)</div><div class="line">w ≤ ∑ᵢⱼ (x̂ᵢⱼ φʸⱼ₊₁ + φˣᵢ   ŷᵢⱼ - φˣᵢ   φʸⱼ₊₁ Bˣʸᵢⱼ)</div></div><!-- fragment --><p>The "logical and" constraint Bˣʸᵢⱼ = Bˣᵢ ∧ Bʸⱼ can be imposed as </p><div class="fragment"><div class="line">Bˣʸᵢⱼ ≥ Bˣᵢ + Bʸⱼ - 1</div><div class="line">Bˣʸᵢⱼ ≤ Bˣᵢ</div><div class="line">Bˣʸᵢⱼ ≤ Bʸⱼ</div><div class="line">0 ≤ Bˣʸᵢⱼ ≤ 1</div></div><!-- fragment --><p> This formulation will introduce slack variables x̂, ŷ and Bˣʸ, in total 3 * m * n variables.</p>
<p>In order to reduce the number of slack variables, we can further simplify these constraints, by defining two vectors <code>x̅ ∈ ℝⁿ</code>, <code>y̅ ∈ ℝᵐ</code> as </p><div class="fragment"><div class="line">x̅ⱼ = ∑ᵢ x̂ᵢⱼ</div><div class="line">y̅ᵢ = ∑ⱼ ŷᵢⱼ</div></div><!-- fragment --><p> and the constraints above can be re-formulated using <code>x̅</code> and <code>y̅</code> as </p><div class="fragment"><div class="line"><a class="code" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> = ∑ⱼ x̅ⱼ</div><div class="line">y = ∑ᵢ y̅ᵢ</div><div class="line">Bˣʸᵢⱼ = Bˣᵢ ∧ Bʸⱼ</div><div class="line">∑ᵢⱼ Bˣʸᵢⱼ = 1</div><div class="line">∑ᵢ φˣᵢ Bˣʸᵢⱼ ≤ x̅ⱼ ≤ ∑ᵢ φˣᵢ₊₁ Bˣʸᵢⱼ</div><div class="line">∑ⱼ φʸⱼ Bˣʸᵢⱼ ≤ y̅ᵢ ≤ ∑ⱼ φʸⱼ₊₁ Bˣʸᵢⱼ</div><div class="line">w ≥ ∑ⱼ( x̅ⱼ φʸⱼ   ) + ∑ᵢ( φˣᵢ   y̅ᵢ ) - ∑ᵢⱼ( φˣᵢ   φʸⱼ   Bˣʸᵢⱼ )</div><div class="line">w ≥ ∑ⱼ( x̅ⱼ φʸⱼ₊₁ ) + ∑ᵢ( φˣᵢ₊₁ y̅ᵢ ) - ∑ᵢⱼ( φˣᵢ₊₁ φʸⱼ₊₁ Bˣʸᵢⱼ )</div><div class="line">w ≤ ∑ⱼ( x̅ⱼ φʸⱼ   ) + ∑ᵢ( φˣᵢ₊₁ y̅ⱼ ) - ∑ᵢⱼ( φˣᵢ₊₁ φʸⱼ   Bˣʸᵢⱼ )</div><div class="line">w ≤ ∑ⱼ( x̅ⱼ φʸⱼ₊₁ ) + ∑ᵢ( φˣᵢ   y̅ᵢ ) - ∑ᵢⱼ( φˣᵢ   φʸⱼ₊₁ Bˣʸᵢⱼ ).</div></div><!-- fragment --><p> In this formulation, we introduce new continuous variables <code>x̅</code>, <code>y̅</code>, <code>Bˣʸ</code>. The total number of new variables is m + n + m * n.</p>
<p>In section 3.3 of Mixed-Integer Models for Nonseparable Piecewise Linear Optimization: Unifying Framework and Extensions by Juan P Vielma, Shabbir Ahmed and George Nemhauser, this formulation is called "Multiple Choice
Model".</p>
<dl class="section note"><dt>Note</dt><dd>We DO NOT add the constraint Bx(i) ∈ {0, 1}, By(j) ∈ {0, 1} in this function. It is the user's responsibility to ensure that these binary constraints are enforced. The users can also add cutting planes ∑ᵢBx(i) = 1, ∑ⱼBy(j) = 1. Without these two cutting planes, (x, y, w) is still in the McCormick envelope of z = x * y, but these two cutting planes "might" improve the computation speed in the mixed-integer solver. </dd></dl>

</div>
</div>
<a id="a1c2dee1da65ed555024f9d2f7ba82141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c2dee1da65ed555024f9d2f7ba82141">&#9670;&nbsp;</a></span>AddBilinearProductMcCormickEnvelopeSos2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt;DerivedPhiX, <a class="el" href="classdouble.html">double</a>&gt;::value &amp;&amp; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt;DerivedPhiY, <a class="el" href="classdouble.html">double</a>&gt;::value &amp;&amp; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt;DerivedBx, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt;::value &amp;&amp; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt;DerivedBy, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt;::value, <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt;DerivedPhiX::RowsAtCompileTime, DerivedPhiY::RowsAtCompileTime&gt; &gt; drake::solvers::AddBilinearProductMcCormickEnvelopeSos2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedPhiX &amp;&#160;</td>
          <td class="paramname"><em>phi_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedPhiY &amp;&#160;</td>
          <td class="paramname"><em>phi_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedBx &amp;&#160;</td>
          <td class="paramname"><em>Bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedBy &amp;&#160;</td>
          <td class="paramname"><em>By</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1solvers.html#a6297509967536d29159910e5c51fd285">IntervalBinning</a>&#160;</td>
          <td class="paramname"><em>binning</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add constraints to the optimization program, such that the bilinear product x * y is approximated by w, using Special Ordered Set of Type 2 (sos2) constraint. </p>
<p>To do so, we assume that the range of x is [x_min, x_max], and the range of y is [y_min, y_max]. We first consider two arrays φˣ, φʸ, satisfying </p><div class="fragment"><div class="line">x_min = φˣ₀ &lt; φˣ₁ &lt; ... &lt; φˣₘ = x_max</div><div class="line">y_min = φʸ₀ &lt; φʸ₁ &lt; ... &lt; φʸₙ = y_max</div></div><!-- fragment --><p> , and divide the range of x into intervals [φˣ₀, φˣ₁], [φˣ₁, φˣ₂], ... , [φˣₘ₋₁, φˣₘ] and the range of y into intervals [φʸ₀, φʸ₁], [φʸ₁, φʸ₂], ... , [φʸₙ₋₁, φʸₙ]. The xy plane is thus cut into rectangles, with each rectangle as [φˣᵢ, φˣᵢ₊₁] x [φʸⱼ, φʸⱼ₊₁]. The convex hull of the surface z = x * y for x, y in each rectangle is a tetrahedron. We then approximate the bilinear product x * y with w, such that (x, y, w) is in one of the tetrahedrons.</p>
<p>We use two different encoding schemes on the binary variables, to determine which interval is active. We can choose either linear or logarithmic binning. When using linear binning, for a variable with N intervals, we use N binary variables, and B(i) = 1 indicates the variable is in the i'th interval. When using logarithmic binning, we use ⌈log₂(N)⌉ binary variables. If these binary variables represent integer M in the reflected Gray code, then the continuous variable is in the M'th interval. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>The program to which the bilinear product constraint is added </td></tr>
    <tr><td class="paramname">x</td><td>The decision variable. </td></tr>
    <tr><td class="paramname">y</td><td>The decision variable. </td></tr>
    <tr><td class="paramname">w</td><td>The expression to approximate x * y </td></tr>
    <tr><td class="paramname">phi_x</td><td>The end points of the intervals for <code>x</code>. </td></tr>
    <tr><td class="paramname">phi_y</td><td>The end points of the intervals for <code>y</code>. </td></tr>
    <tr><td class="paramname">Bx</td><td>The binary variables for the interval in which x stays encoded as described above. </td></tr>
    <tr><td class="paramname">By</td><td>The binary variables for the interval in which y stays encoded as described above. </td></tr>
    <tr><td class="paramname">binning</td><td>Determine whether to use linear binning or logarithmic binning. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lambda The auxiliary continuous variables.</dd></dl>
<p>The constraints we impose are </p><div class="fragment"><div class="line"><a class="code" href="pixel__types_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a> = (φˣ)ᵀ * ∑ⱼ λᵢⱼ</div><div class="line">y = (φʸ)ᵀ * ∑ᵢ λᵢⱼ</div><div class="line">w = ∑ᵢⱼ φˣᵢ * φʸⱼ * λᵢⱼ</div><div class="line">Both ∑ⱼ λᵢⱼ = λ.rowwise().sum() and ∑ᵢ λᵢⱼ = λ.colwise().sum() satisfy SOS2</div><div class="line">constraint.</div></div><!-- fragment --><p>If x ∈ [φx(M), φx(M+1)] and y ∈ [φy(N), φy(N+1)], then only λ(M, N), λ(M + 1, N), λ(M, N + 1) and λ(M+1, N+1) can be strictly positive, all other λ(i, j) are zero.</p>
<dl class="section note"><dt>Note</dt><dd>We DO NOT add the constraint Bx(i) ∈ {0, 1}, By(j) ∈ {0, 1} in this function. It is the user's responsibility to ensure that these constraints are enforced. </dd></dl>

</div>
</div>
<a id="a0c7466e7ce1b8db6de94ad0524f8106d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7466e7ce1b8db6de94ad0524f8106d">&#9670;&nbsp;</a></span>AddBoundingBoxConstraintsImpliedByRollPitchYawLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::solvers::AddBoundingBoxConstraintsImpliedByRollPitchYawLimits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1solvers.html#a55b1b3c88fe94fd28d7564b90f50a00f">RollPitchYawLimits</a>&#160;</td>
          <td class="paramname"><em>limits</em> = <code><a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74a34bbac4b028a742de1b931cc2694dcea">kNoLimits</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies <em>very conservative</em> limits on the entries of R for the cases when rotations can be limited (for instance, if you want to search over rotations, but there is an obvious symmetry in the problem so that e.g. </p>
<p>0 &lt; pitch &lt; PI need not be considered). A matrix so constrained may still contain rotations outside of this envelope. Note: For simple rotational symmetry over PI, prefer kPitch_NegPI_2_to_PI_2 (over 0_to_PI) because it adds one more constraint (when combined with constraints on roll and yaw). Note: The Roll-Pitch-Yaw angles follow the convention in RollPitchYaw, namely extrinsic rotations about Space-fixed x-y-z axes, respectively. </p>

</div>
</div>
<a id="ab3dd262dc400586c539cd57b1bb311ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3dd262dc400586c539cd57b1bb311ed">&#9670;&nbsp;</a></span>AddLogarithmicSos1Constraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::solvers::AddLogarithmicSos1Constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>binary_encoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the special ordered set of type 1 (SOS1) constraint. </p>
<p>Namely </p><pre>
  λ(0) + ... + λ(n-1) = 1
  λ(i) ≥ 0 ∀i
  ∃ j ∈ {0, 1, ..., n-1}, s.t λ(j) = 1
</pre><p> where one and only one of λ(i) is 1, all other λ(j) are 0. We will need to add ⌈log₂(n)⌉ binary variables, where n is the number of rows in λ. For more information, please refer to Modeling Disjunctive Constraints with a Logarithmic Number of Binary Variables and Constraints by J. Vielma and G. Nemhauser, 2011. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>The program to which the SOS1 constraint is added. </td></tr>
    <tr><td class="paramname">lambda</td><td>lambda is in SOS1. </td></tr>
    <tr><td class="paramname">y</td><td>The binary variables indicating which λ is positive. For a given assignment on the binary variable <code>y</code>, if (y(0), ..., y(⌈log₂(n)⌉) represents integer M in <code>binary_encoding</code>, then only λ(M) is positive. Namely, if (y(0), ..., y(⌈log₂(n)⌉) equals to binary_encoding.row(M), then λ(M) = 1 </td></tr>
    <tr><td class="paramname">binary_encoding</td><td>A n x ⌈log₂(n)⌉ matrix. binary_encoding.row(i) represents integer i. No two rows of <code>binary_encoding</code> can be the same. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>binary_encoding</code> has a non-binary entry (0, 1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a8dc4e6bf90d7180583c31a7c06381b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a8dc4e6bf90d7180583c31a7c06381b">&#9670;&nbsp;</a></span>AddLogarithmicSos1Constraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&gt;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&gt; &gt; drake::solvers::AddLogarithmicSos1Constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the special ordered set of type 1 (SOS1) constraint. </p>
<p>Namely </p><pre>
  λ(0) + ... + λ(n-1) = 1
  λ(i) ≥ 0 ∀i
  ∃ j ∈ {0, 1, ..., n-1}, s.t λ(j) = 1
</pre><p> where one and only one of λ(i) is 1, all other λ(j) are 0. We will need to add ⌈log₂(n)⌉ binary variables, where n is the number of rows in λ. For more information, please refer to Modeling Disjunctive Constraints with a Logarithmic Number of Binary Variables and Constraints by J. Vielma and G. Nemhauser, 2011. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>The program to which the SOS1 constraint is added. </td></tr>
    <tr><td class="paramname">num_lambda</td><td>n in the documentation above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(lambda, y) lambda is λ in the documentation above. Notice that λ are declared as continuous variables, but they only admit binary solutions. y are binary variables of size ⌈log₂(n)⌉. When this sos1 constraint is satisfied, suppose that λ(i)=1 and λ(j)=0 ∀ j≠i, then y is the Reflected Gray code of i. For example, suppose n = 8, i = 5, then y is a vector of size ⌈log₂(n)⌉ = 3, and the value of y is (1, 1, 0) which equals to 5 according to reflected Gray code. </dd></dl>

</div>
</div>
<a id="a5cbd203e51076aa08e497620f11187b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbd203e51076aa08e497620f11187b4">&#9670;&nbsp;</a></span>AddLogarithmicSos2Constraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">drake::is_eigen_vector_of</a>&lt;Derived, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt;::value, typename <a class="el" href="structdrake_1_1solvers_1_1_logarithmic_sos2_new_binary_variables.html">LogarithmicSos2NewBinaryVariables</a>&lt; Derived::RowsAtCompileTime&gt;::type&gt; drake::solvers::AddLogarithmicSos2Constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>binary_variable_name</em> = <code>&quot;y&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the special ordered set 2 (SOS2) constraint,. </p>
<pre>
  λ(0) + ... + λ(n) = 1
  ∀i. λ(i) ≥ 0
  ∃ j ∈ {0, 1, ..., n-1}, s.t λ(i) = 0 if i ≠ j and i ≠ j + 1
</pre><p> Namely at most two entries in λ can be strictly positive, and these two entries have to be adjacent. All other λ should be zero. Moreover, the non-zero λ satisfies λ(j) + λ(j + 1) = 1. We will need to add ⌈log₂(n - 1)⌉ binary variables, where n is the number of rows in λ. For more information, please refer to Modeling Disjunctive Constraints with a Logarithmic Number of Binary Variables and Constraints by J. Vielma and G. Nemhauser, 2011. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>Add the SOS2 constraint to this mathematical program. </td></tr>
    <tr><td class="paramname">lambda</td><td>At most two entries in λ can be strictly positive, and these two entries have to be adjacent. All other entries are zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>y The newly added binary variables. The assignment of the binary variable y implies which two λ can be strictly positive. With a binary assignment on y, and suppose the integer M corresponds to (y(0), y(1), ..., y(⌈log₂(n - 1)⌉)) in Gray code, then only λ(M) and λ(M + 1) can be non-zero. For example, if the assignment of y = (1, 1), in Gray code, (1, 1) represents integer 2, so only λ(2) and λ(3) can be strictly positive. </dd></dl>

</div>
</div>
<a id="af49d99f80f15d8e6bdd6a6c2d2fdcc23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af49d99f80f15d8e6bdd6a6c2d2fdcc23">&#9670;&nbsp;</a></span>AddLogarithmicSos2Constraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::solvers::AddLogarithmicSos2Constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the special ordered set 2 (SOS2) constraint,. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1solvers.html#a5cbd203e51076aa08e497620f11187b4" title="Adds the special ordered set 2 (SOS2) constraint,.">AddLogarithmicSos2Constraint</a>. </dd></dl>

</div>
</div>
<a id="af86dd14a5111afdacac8ccbbd0fafc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86dd14a5111afdacac8ccbbd0fafc9a">&#9670;&nbsp;</a></span>AddRotationMatrixBoxSphereIntersectionMilpConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1solvers_1_1_add_rotation_matrix_box_sphere_intersection_return.html">AddRotationMatrixBoxSphereIntersectionReturn</a> drake::solvers::AddRotationMatrixBoxSphereIntersectionMilpConstraints </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_intervals_per_half_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds binary variables that constrain the value of the column <em>and</em> row vectors of R, in order to add the following (in some cases non-convex) constraints as an MILP. </p>
<p>Specifically, for column vectors Ri, we constrain:</p>
<ul>
<li>forall i, |Ri| = 1 ± envelope,</li>
<li>forall i,j. i ≠ j, Ri.dot(Rj) = 0 ± envelope,</li>
<li>R2 = R0.cross(R1) ± envelope, and again for R0=R1.cross(R2), and R1=R2.cross(R0).</li>
</ul>
<p>Then all of the same constraints are also added to R^T. The size of the envelope decreases quickly as num_binary_variables_per_half_axis is is increased.</p>
<dl class="section note"><dt>Note</dt><dd>Creates <code>9*2*num_binary_variables_per_half_axis binary</code> variables named "BRpos*(*,*)" and "BRneg*(*,*)", and the same number of continuous variables named "CRpos*(*,*)" and "CRneg*(*,*)".</dd>
<dd>
The particular representation/algorithm here was developed in an attempt:<ul>
<li>to enable efficient reuse of the variables between the constraints between multiple rows/columns (e.g. the constraints on Rᵀ use the same variables as the constraints on R), and</li>
<li>to facilitate branch-and-bound solution techniques &ndash; binary regions are layered so that constraining one region establishes constraints on large portions of SO(3), and confers hopefully "useful" constraints the on other binary variables. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>The rotation matrix </td></tr>
    <tr><td class="paramname">num_intervals_per_half_axis</td><td>number of intervals for a half axis. </td></tr>
    <tr><td class="paramname">prog</td><td>The mathematical program to which the constraints are added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method uses the same approach as <a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_rotation_constraint_generator.html" title="We relax the non-convex SO(3) constraint on rotation matrix R to mixed-integer linear constraints.">MixedIntegerRotationConstraintGenerator</a> with kBoxSphereIntersection, namely the feasible sets to both relaxation are the same. But they use different sets of binary variables, and thus the computation speed can be different inside optimization solvers. </dd></dl>

</div>
</div>
<a id="a6304aed086cdd57240ad1f57b66a7986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6304aed086cdd57240ad1f57b66a7986">&#9670;&nbsp;</a></span>AddRotationMatrixOrthonormalSocpConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::solvers::AddRotationMatrixOrthonormalSocpConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a set of convex constraints which approximate the set of orthogonal matrices, O(3). </p>
<p>Adds the bilinear constraints that the each column Ri has length &lt;= 1 and that Ri'Rj approx 0 via -2 + |Ri|^2 + |Rj|^2 &lt;= 2Ri'Rj &lt;= 2 - |Ri|^2 - |Rj|^2 (for all i!=j), using a second-order-cone relaxation. Additionally, the same constraints are applied to all of the rows. </p>

</div>
</div>
<a id="a9202a27d1c86559e9496ec01fde853e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9202a27d1c86559e9496ec01fde853e9">&#9670;&nbsp;</a></span>AddRotationMatrixSpectrahedralSdpConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::solvers::AddRotationMatrixSpectrahedralSdpConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraint (10) from <a href="https://arxiv.org/pdf/1403.4914.pdf">https://arxiv.org/pdf/1403.4914.pdf</a> , which exactly represents the convex hull of all rotation matrices in 3D. </p>

</div>
</div>
<a id="ab46c83406ebd077e9c93b5ea05946ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46c83406ebd077e9c93b5ea05946ee2">&#9670;&nbsp;</a></span>AddSos2Constraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::solvers::AddSos2Constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the special ordered set 2 (SOS2) constraint. </p>
<p>y(i) takes binary values (either 0 or 1). </p><pre>
  y(i) = 1 =&gt; λ(i) + λ(i + 1) = 1.
</pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1solvers.html#a5cbd203e51076aa08e497620f11187b4" title="Adds the special ordered set 2 (SOS2) constraint,.">AddLogarithmicSos2Constraint</a> for a complete explanation on SOS2 constraint. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>The optimization program to which the SOS2 constraint is added. </td></tr>
    <tr><td class="paramname">lambda</td><td>At most two entries in λ can be strictly positive, and these two entries have to be adjacent. All other entries are zero. Moreover, these two entries should sum up to 1. </td></tr>
    <tr><td class="paramname">y</td><td>y(i) takes binary value, and determines which two entries in λ can be strictly positive. Throw a runtime error if y.rows() != lambda.rows() - 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebc36100fe5dc287d0c0c41a65c31c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc36100fe5dc287d0c0c41a65c31c21">&#9670;&nbsp;</a></span>AggregateBoundingBoxConstraints() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>, <a class="el" href="structdrake_1_1solvers_1_1_bound.html">Bound</a>&gt; drake::solvers::AggregateBoundingBoxConstraints </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bounding_box_constraints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aggregates many bounding box constraints, returns the intersection (the tightest bounds) of these constraints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bounding_box_constraints</td><td>The constraints to be aggregated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">aggregated_bounds</td><td>aggregated_bounds[var.get_id()] returns the (lower, upper) bounds of that variable as the tightest bounds of <code>bounding_box_constraints</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43caa3a499b973de17213d63a006b0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43caa3a499b973de17213d63a006b0ea">&#9670;&nbsp;</a></span>AggregateBoundingBoxConstraints() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::solvers::AggregateBoundingBoxConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd *&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd *&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aggregates all the BoundingBoxConstraints inside <code>prog</code>, returns the intersection of the bounding box constraints as the lower and upper bound for each variable in <code>prog</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">prog</td><td>The optimization program containing decision variables and BoundingBoxConstraints. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lower</td><td>(*lower)[i] is the lower bound of prog.decision_variable(i). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">upper</td><td>(*upper)[i] is the upper bound of prog.decision_variable(i). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb331e49dcccbb8d9d0e63a2190685f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb331e49dcccbb8d9d0e63a2190685f2">&#9670;&nbsp;</a></span>AggregateBoundingBoxConstraints() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::solvers::AggregateBoundingBoxConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads AggregateBoundingBoxConstraints, but the type of lower and upper are std::vector&lt;double&gt;. </p>

</div>
</div>
<a id="a5999ff5df38e426f3e6c4a69aeec4305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5999ff5df38e426f3e6c4a69aeec4305">&#9670;&nbsp;</a></span>AggregateDuplicateVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::solvers::AggregateDuplicateVariables </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>A_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; *&#160;</td>
          <td class="paramname"><em>vars_new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For linear expression A * vars where <code>vars</code> might contain duplicated entries, rewrite this linear expression as A_new * vars_new where vars_new doesn't contain duplicated entries. </p>

</div>
</div>
<a id="a38b2721b2175272485def57c7a8b9c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b2721b2175272485def57c7a8b9c6a">&#9670;&nbsp;</a></span>AggregateLinearCosts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::solvers::AggregateLinearCosts </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>linear_costs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseVector&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>linear_coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; *&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>constant_cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given many linear costs, aggregate them into. </p>
<p>aᵀ*x + b, </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">linear_costs</td><td>the linear costs to be aggregated. </td></tr>
    <tr><td class="paramname">linear_coeff[out]</td><td>a in the documentation above. </td></tr>
    <tr><td class="paramname">vars[out]</td><td>x in the documentation above. </td></tr>
    <tr><td class="paramname">constant_cost[out]</td><td>b in the documentation above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd9e7d960a7e287ea283ffa9aee89d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9e7d960a7e287ea283ffa9aee89d41">&#9670;&nbsp;</a></span>AggregateQuadraticAndLinearCosts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::solvers::AggregateQuadraticAndLinearCosts </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>quadratic_costs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>linear_costs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>Q_lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; *&#160;</td>
          <td class="paramname"><em>quadratic_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseVector&lt; <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>linear_coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; *&#160;</td>
          <td class="paramname"><em>linear_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>constant_cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given many linear and quadratic costs, aggregate them into. </p>
<p>0.5*x₁ᵀQx₁ + bᵀx₂ + c where x₁ and x₂ don't need to be the same. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quadratic_costs</td><td>The quadratic costs to be aggregated. </td></tr>
    <tr><td class="paramname">linear_costs</td><td>The linear costs to be aggregated. </td></tr>
    <tr><td class="paramname">Q_lower[out]</td><td>The lower triangular part of the matrix Q. </td></tr>
    <tr><td class="paramname">quadratic_vars[out]</td><td>x₁ in the documentation above. </td></tr>
    <tr><td class="paramname">linear_coeff[out]</td><td>b in the documentation above. </td></tr>
    <tr><td class="paramname">linear_vars[out]</td><td>x₂ in the documentation above. </td></tr>
    <tr><td class="paramname">constant_cost[out]</td><td>c in the documentation above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9345a87a13b6c67ee3f98a0910b133c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9345a87a13b6c67ee3f98a0910b133c9">&#9670;&nbsp;</a></span>AreRequiredAttributesSupported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::solvers::AreRequiredAttributesSupported </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>required</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>supported</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>unsupported_message</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff <code>required</code> is a subset of <code>supported</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">unsupported_message</td><td>(Optional) When provided, if this function returns false, the message will be set to a phrase describing the unsupported attributes; or if this function returns true, the message will be set to the empty string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f7d6f23d494612f72e8efc99b87143c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7d6f23d494612f72e8efc99b87143c">&#9670;&nbsp;</a></span>CeilLog2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classint.html">int</a> drake::solvers::CeilLog2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return ⌈log₂(n)⌉, namely the minimal integer no smaller than log₂(n), with base 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A positive integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimal integer no smaller than log₂(n). </dd></dl>

</div>
</div>
<a id="af2e1d0462e0e3506873f993879d48898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e1d0462e0e3506873f993879d48898">&#9670;&nbsp;</a></span>ChooseBestSolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> drake::solvers::ChooseBestSolver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choose the best solver given the formulation in the optimization program and the availability of the solvers. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there is no available solver for <code>prog</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca547471b139de0956139286cbfe5f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca547471b139de0956139286cbfe5f10">&#9670;&nbsp;</a></span>ConcatenateIndeterminatesRefList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a> drake::solvers::ConcatenateIndeterminatesRefList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#ac27bca68509bbb001ab8073089b48031">IndeterminatesRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>var_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates each element in <code>var_list</code> into a single Eigen vector of indeterminates, returns this concatenated vector. </p>

</div>
</div>
<a id="a8f304c33d467b0bf0ad02e25a2ced143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f304c33d467b0bf0ad02e25a2ced143">&#9670;&nbsp;</a></span>ConcatenateVariableRefList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> drake::solvers::ConcatenateVariableRefList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>var_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates each element in <code>var_list</code> into a single Eigen vector of decision variables, returns this concatenated vector. </p>

</div>
</div>
<a id="a6703c1f6f99f3e06a86f6a54e7dbd63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6703c1f6f99f3e06a86f6a54e7dbd63d">&#9670;&nbsp;</a></span>ConstructMonomialBasis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">drake::VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a>&gt; drake::solvers::ConstructMonomialBasis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">drake::symbolic::Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given input polynomial p, outputs a set M of monomials with the following guarantee: if p = f1*f1 + f2*f2 + ... </p>
<ul>
<li>fn*fn for some (unknown) polynomials f1, f2, ..., fn, then the span of M contains f1, f2, ..., fn, Given M, one can then find the polynomials fi using semidefinite programming; see, e.g., Chapter 3 of Semidefinite Optimization and Convex Algebraic Geometry by G. Blekherman, P. Parrilo, R. Thomas. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector whose entries are the elements of M </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a1460b4c245321e57b234a724d774fc50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1460b4c245321e57b234a724d774fc50">&#9670;&nbsp;</a></span>CreateBinaryCodeMatchConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; drake::solvers::CreateBinaryCodeMatchConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create linear constraints such that, when these constraints are satisfied, match = 1 if and only if code == expected, otherwise match = 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>code(i) should only take binary values. </td></tr>
    <tr><td class="paramname">expected</td><td>The expected matched value for code. </td></tr>
    <tr><td class="paramname">match</td><td>an expression that takes binary value, representing if code == expected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the linear constraints.</dd></dl>
<p>This function is useful integer optimization, for example, if we have a constraint match = ((b1 == 0) &amp;&amp; (b2 == 1) &amp;&amp; (b3 == 1)), we can call the function CreateBinaryCodeMatchConstraint({b1, b2, b3}, {0, 1, 1}, match) to create the constraint. </p>

</div>
</div>
<a id="ab3ba521ece6e61a25713f11610b01d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ba521ece6e61a25713f11610b01d97">&#9670;&nbsp;</a></span>CreateLogicalAndConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; drake::solvers::CreateLogicalAndConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b1_and_b2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds linear constraints, such that when b1, b2, b1_and_b2 satisfy the constraints, and b1, b2 take binary values, it is guaranteed that b1_and_b2 = b1 ∧ b2 (b1 and b2). </p>
<p>The constraints are </p><pre>
  b1_and_b2 &gt;= b1 + b2 - 1
  b1_and_b2 &lt;= b1
  b1_and_b2 &lt;= b2
  0 &lt;= b1_and_b2 &lt;= 1
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b1</td><td>An expression that should only take a binary value. </td></tr>
    <tr><td class="paramname">b2</td><td>An expression that should only take a binary value. </td></tr>
    <tr><td class="paramname">b1_and_b2</td><td>Should be the logical and between <code>b1</code> and <code>b2</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added constraints, such that when b1, b2, b1_and_b2 satisfy the constraints, it is guaranteed that b1_and_b2 = b1 ∧ b2. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>b1, b2, b1_and_b2 are all linear expressions. </dd></dl>

</div>
</div>
<a id="ada3cfbf9597820039fe2d6c3f175731b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3cfbf9597820039fe2d6c3f175731b">&#9670;&nbsp;</a></span>CreateLogicalOrConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; drake::solvers::CreateLogicalOrConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b1_or_b2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds linear constraints, such that when b1, b2, b1_or_b2 satisfy the constraints, and b1, b2 take binary values, it is guaranteed that b1_or_b2 = b1 ∨ b2 (b1 or b2). </p>
<p>The constraints are </p><pre>
  b1_or_b2 &lt;= b1 + b2
  b1_or_b2 &gt;= b1
  b1_or_b2 &gt;= b2
  0 &lt;= b1_or_b2 &lt;= 1
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b1</td><td>An expression that should only take a binary value. </td></tr>
    <tr><td class="paramname">b2</td><td>An expression that should only take a binary value. </td></tr>
    <tr><td class="paramname">b1_or_b2</td><td>Should be the logical or between <code>b1</code> and <code>b2</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added constraints, such that when b1, b2, b1_or_b2 satisfy the constraints, it is guaranteed that b1_or_b2 = b1 ∨ b2. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>b1, b2, b1_or_b2 are all linear expressions. </dd></dl>

</div>
</div>
<a id="aa7a863c255da14a1441e3ac58d082472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a863c255da14a1441e3ac58d082472">&#9670;&nbsp;</a></span>CreateLogicalXorConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; drake::solvers::CreateLogicalXorConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b1_xor_b2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add linear constraints, such that when b1, b2, b1_xor_b2 satisfy the constraints, and b1, b2 take binary values, it is guaranteed that b1_xor_b2 = b1 ⊕ b2 (b1 exclusive xor b2). </p>
<p>The constraints are </p><pre>
  b1_xor_b2 &lt;= b1 + b2
  b1_xor_b2 &gt;= b1 - b2
  b1_xor_b2 &gt;= b2 - b1
  b1_xor_b2 &lt;= 2 - b1 - b2
  0 &lt;= b1_xor_b2 &lt;= 1
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b1</td><td>An expression that should only take a binary value. </td></tr>
    <tr><td class="paramname">b2</td><td>An expression that should only take a binary value. </td></tr>
    <tr><td class="paramname">b1_xor_b2</td><td>Should be the logical exclusive or between <code>b1</code> and <code>b2</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added constraints, such that when b1, b2, b1_xor_b2 satisfy the constraints, it is guaranteed that b1_xor_b2 = b1 ⊕ b2. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>b1, b2, b1_xor_b2 are all linear expressions. </dd></dl>

</div>
</div>
<a id="af6b2d302506a6a2fe144c79bd2598131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b2d302506a6a2fe144c79bd2598131">&#9670;&nbsp;</a></span>DecomposeNonConvexQuadraticForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;Eigen::MatrixXd, Eigen::MatrixXd&gt; drake::solvers::DecomposeNonConvexQuadraticForm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a non-convex homogeneous quadratic form xᵀQx, where Q is not necessarily a positive semidefinite matrix, we decompose it as a difference between two convex homogeneous quadratic forms xᵀQx = xᵀQ₁x - xᵀQ₂x, Q₁, Q₂ are positive semidefinite. </p>
<p>To find the optimal Q₁ and Q₂, we solve the following semidefinite programming problem min s s.t s &gt;= trace(Q₁) s &gt;= trace(Q₂) Q₁ - Q₂ = (Q + Qᵀ) / 2 Q₁, Q₂ are positive semidefinite The decomposition Q = Q₁ - Q₂ can be used later, to solve the non-convex optimization problem involving a quadratic form xᵀQx. For more information, please refer to the papers on difference of convex decomposition, for example Undominated d.c Decompositions of Quadratic Functions and Applications to Branch-and-Bound Approaches By I.M.Bomze and M. Locatelli Computational Optimization and Applications, 2004 DC Decomposition of Nonconvex Polynomials with Algebraic Techniques By A. A. Ahmadi and G. Hall Mathematical Programming, 2015 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td>A square matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if Q is not square. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The optimal decomposition (Q₁, Q₂) </dd></dl>

</div>
</div>
<a id="a897158ddd3d5fd975edd151850ecc639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897158ddd3d5fd975edd151850ecc639">&#9670;&nbsp;</a></span>EnumerateIntegerSolutions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classint.html">int</a>, -1, -1, Eigen::RowMajor&gt; drake::solvers::EnumerateIntegerSolutions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all integer solutions x to the linear inequalities. </p>
<pre>
                   Ax &lt;= b,
                   x &lt;= upper_bound,
                   x &gt;= lower_bound.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>An (m x n) integer matrix. </td></tr>
    <tr><td class="paramname">b</td><td>An (m x 1) integer vector. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>A (n x 1) integer vector. </td></tr>
    <tr><td class="paramname">lower_bound</td><td>A (n x 1) integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A (p x n) matrix whose rows are the solutions. </dd></dl>

</div>
</div>
<a id="a0d06c693e90f6849f70d4b549f015e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d06c693e90f6849f70d4b549f015e1e">&#9670;&nbsp;</a></span>ExponentiallySmoothedHingeLoss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::solvers::ExponentiallySmoothedHingeLoss </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>penalty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>dpenalty_dx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A hinge loss function smoothed by exponential function. </p>
<p>This loss function is differentiable everywhere. The formulation is described in section II.C of [2]. The penalty is </p><pre class="unicode-art">
       ⎧ 0            if x ≥ 0
φ(x) = ⎨
       ⎩ -x exp(1/x)  if x &lt; 0.
</pre><p> [2] "Whole-body Motion Planning with Centroidal Dynamics and Full
Kinematics" by Hongkai Dai, Andres Valenzuela and Russ Tedrake, IEEE-RAS International Conference on Humanoid Robots, 2014. </p>

</div>
</div>
<a id="aeb2470f8cacd8e5f5a473b10d0acf6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2470f8cacd8e5f5a473b10d0acf6cc">&#9670;&nbsp;</a></span>GenerateSDPA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::solvers::GenerateSDPA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3">RemoveFreeVariableMethod</a>&#160;</td>
          <td class="paramname"><em>method</em> = <code><a class="el" href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3a54b9d7601ece96fc42e2ffd67aae2690">RemoveFreeVariableMethod::kNullspace</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SDPA is a format to record an SDP problem. </p>
<pre class="fragment">max tr(C*X)
s.t tr(Aᵢ*X) = gᵢ
    X ≽ 0
</pre><p>or the dual of the problem </p><pre class="fragment">min gᵀy
s.t ∑ᵢ yᵢAᵢ - C ≽ 0
</pre><p>where X is a symmetric block diagonal matrix. The format is described in <a href="http://plato.asu.edu/ftp/sdpa_format.txt">http://plato.asu.edu/ftp/sdpa_format.txt</a>. Many solvers, such as CSDP, DSDP, SDPA, sedumi and SDPT3, accept an SDPA format file as the input. This function reads a <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> that can be formulated as above, and write an SDPA file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>a program that contains an optimization program. </td></tr>
    <tr><td class="paramname">file_name</td><td>The name of the file, note that the extension will be added automatically. </td></tr>
    <tr><td class="paramname">method</td><td>If <code>prog</code> contains free variables (i.e., variables without bounds), then we need to remove these free variables to write the program in the SDPA format. Please refer to RemoveFreeVariableMethod for details on how to remove the free variables. <br />
 <em>Default:</em> is <a class="el" href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3a54b9d7601ece96fc42e2ffd67aae2690" title="Approach 2, reformulate the dual problem by considering the nullspace of the linear constraint in the...">RemoveFreeVariableMethod::kNullspace</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">is_success.</td><td>Returns true if we can generate the SDPA file. The failure could be<ol type="1">
<li><code>prog</code> cannot be captured by the formulation above.</li>
<li><code>prog</code> cannot create a file with the given name, etc. </li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add46c9926ac1085abe828a7cc987cad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add46c9926ac1085abe828a7cc987cad1">&#9670;&nbsp;</a></span>GetAvailableSolvers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a>&gt; drake::solvers::GetAvailableSolvers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15">ProgramType</a>&#160;</td>
          <td class="paramname"><em>prog_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the list of available and enabled solvers that definitely accept all programs of the given program type. </p>
<p>The order of the returned SolverIds reflects an approximate order of preference, from most preferred (front) to least preferred (back). Because we are analyzing only based on the program type rather than a specific program, it's possible that solvers later in the list would perform better in certain situations. To obtain the truly best solver, using <a class="el" href="namespacedrake_1_1solvers.html#af2e1d0462e0e3506873f993879d48898" title="Choose the best solver given the formulation in the optimization program and the availability of the ...">ChooseBestSolver()</a> instead. </p><dl class="section note"><dt>Note</dt><dd>If a solver only accepts a subset of the program type, then that solver is not included in the returned results. For example <a class="el" href="classdrake_1_1solvers_1_1_equality_constrained_q_p_solver.html" title="Solves a quadratic program with equality constraint.">EqualityConstrainedQPSolver</a> doesn't accept programs with inequality linear constraints, so it doesn't show up in the return of GetAvailableSolvers(ProgramType::kQP). </dd></dl>

</div>
</div>
<a id="a55b69ef16f17a627abcbe62dde1d4807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b69ef16f17a627abcbe62dde1d4807">&#9670;&nbsp;</a></span>GetKnownSolvers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt;<a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a>&gt;&amp; drake::solvers::GetKnownSolvers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of solvers known to ChooseBestSolver. </p>

</div>
</div>
<a id="acb5fa6010c00dad4d5867183f35a2f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb5fa6010c00dad4d5867183f35a2f70">&#9670;&nbsp;</a></span>GetProgramType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15">ProgramType</a> drake::solvers::GetProgramType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the type of the optimization program (LP, QP, etc), based on the properties of its cost/constraints/variables. </p>
<p>Each mathematical program should be characterized by a unique type. If a program can be characterized as either type A or type B (for example, a program with linear constraint and linear costs can be characterized as either an LP or an SDP), then we choose the type corresponding to a smaller set of programs (LP in this case). </p>

</div>
</div>
<a id="a014d2838aa5fae12520da4ebf46005ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014d2838aa5fae12520da4ebf46005ca">&#9670;&nbsp;</a></span>GetVariableValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> drake::solvers::GetVariableValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>variable_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>variable_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the value of a single variable <code>var</code> from <code>variable_values</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The variable whose value is going to be retrieved. <code>var.get_id()</code> must be a key in <code>variable_index</code>. </td></tr>
    <tr><td class="paramname">variable_index</td><td>maps the variable ID to its index in <code>variable_values</code>. </td></tr>
    <tr><td class="paramname">variable_values</td><td>The values of all variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variable_values(variable_index[var.get_id()]) if var.get_id() is a valid key of <code>variable_index</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if var.get_id() is not a valid key of <code>variable_index</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All the mapped value in variable_index is in the range [0, variable_values.rows()) </dd></dl>

</div>
</div>
<a id="afd8c88bd4238ccc189020ed7d99b1792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8c88bd4238ccc189020ed7d99b1792">&#9670;&nbsp;</a></span>GetVariableValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt;typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&gt;, <a class="el" href="namespacedrake.html#aaadcdc21cc0c381e5879b1b7f023d82d">MatrixLikewise</a>&lt;<a class="el" href="classdouble.html">double</a>, Derived&gt; &gt; drake::solvers::GetVariableValue </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>variable_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>variable_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload <a class="el" href="namespacedrake_1_1solvers.html#a014d2838aa5fae12520da4ebf46005ca" title="Retrieve the value of a single variable var from variable_values.">GetVariableValue()</a> function, but for an Eigen matrix of decision variables. </p>

</div>
</div>
<a id="a99ce5167dfbdc1a1f84e2e7cc52cba4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ce5167dfbdc1a1f84e2e7cc52cba4e">&#9670;&nbsp;</a></span>MakeFirstAvailableSolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">SolverInterface</a>&gt; drake::solvers::MakeFirstAvailableSolver </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>solver_ids</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes the first available and enabled solver. </p>
<p>If no solvers are available, throws a std::exception. </p>

</div>
</div>
<a id="af6da6d265dcd5e959082b17d3a94258b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6da6d265dcd5e959082b17d3a94258b">&#9670;&nbsp;</a></span>MakeSemidefiniteRelaxation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a>&gt; drake::solvers::MakeSemidefiniteRelaxation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> which represents the semidefinite programming convex relaxation of the (likely nonconvex) program <code>prog</code>. </p>
<p>This method currently supports only linear and quadratic costs and constraints, but may be extended in the future with broader support.</p>
<p>See <a href="https://underactuated.mit.edu/optimization.html#sdp_relaxation">https://underactuated.mit.edu/optimization.html#sdp_relaxation</a> for references and examples.</p>
<p>Note: Currently, programs using <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html" title="Implements a constraint of the form .">LinearEqualityConstraint</a> will give tighter relaxations than programs using <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html" title="Implements a constraint of the form .">LinearConstraint</a> or <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html" title="Implements a constraint of the form .">BoundingBoxConstraint</a>, even if lower_bound == upper_bound. Prefer <a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html" title="Implements a constraint of the form .">LinearEqualityConstraint</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>prog</code> has costs and constraints which are not linear nor quadratic. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56eb3fcc2f03d972f06486730916cbf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56eb3fcc2f03d972f06486730916cbf0">&#9670;&nbsp;</a></span>MakeSemidefiniteRelaxation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a>&gt; drake::solvers::MakeSemidefiniteRelaxation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">symbolic::Variables</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>variable_groups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A version of MakeSemidefiniteRelaxation that allows for specifying the sparsity of the relaxation. </p>
<p>For each group in <code>variable_groups</code>, the costs and constraints whose variables are a subset of the group will be jointly relaxed into a single, dense semidefinite program in the same manner as MakeSemidefiniteRelaxation(prog).</p>
<p>Each of these semidefinite relaxations are aggregated into a single program, and their semidefinite variables are made to agree where the variable groups overlap.</p>
<p>The returned program will always have the same number of PSD variables as variable groups.</p>
<p>Costs and constraints whose variables are not a subset of any of the groups are not relaxed and are simply added to the aggregated program. If these costs and constraints are non-convex, then this method will throw.</p>
<p>As an example, consider the following program. min x₂ᵀ * Q * x₂ subject to x₁ + x₂ ≤ 1 x₂ + x₃ ≤ 2 x₁ + x₃ ≤ 3</p>
<p>And suppose we call MakeSemidefiniteRelaxation(prog, std::vector&lt;Variables&gt;{{x₁, x₂}, {x₂,x₃}}).</p>
<p>The resulting relaxation would have two semidefinite variables, namely: [U₁, U₂, x₁] [W₁, W₂, x₂] [U₂, U₃, x₂], [W₂, W₃, x₃] [x₁ᵀ, x₂ᵀ, 1] [x₂ᵀ, x₃ᵀ, 1]</p>
<p>The first semidefinite variable would be associated to the semidefinite relaxation of the subprogram: min x₁ᵀ * Q * x₁ subject to x₁ + x₂ ≤ 1 And the implied constraints from x₁ + x₂ ≤ 1 would be added to the first semidefinite variable. These implied constraints are additional constraints that can be placed on the matrix [U₁, U₂, x₁] [U₂, U₃, x₂] [x₁ᵀ, x₂ᵀ, 1] which are redundant in the non-convex program, but are not redundant in the semidefinite relaxation. See <a href="https://underactuated.mit.edu/optimization.html#sdp_relaxation">https://underactuated.mit.edu/optimization.html#sdp_relaxation</a> for references and examples.</p>
<p>The second semidefinite variable would be associated to the semidefinite relaxation of the subprogram: min x₂ᵀ * Q * x₂ subject to x₂ + x₃ ≤ 2 And the implied constraints from x₂ + x₃ ≤ 2 would be added to the second semidefinite variable.</p>
<p>Since the constraint x₁ + x₃ ≤ 3 is not a subset of any of the variable groups, it will be added to the overall relaxation, but will not be used to generate implied constraints on any semidefinite variable.</p>
<p>The total relaxation would also include an equality constraint that U₃ == W₁ so that the quadratic relaxation of x₂ is consistent between the two semidefinite variables.</p>
<p>Note: 1) Costs are only associated to a single variable group, so that the resulting aggregated program has a relaxed cost with the same scaling. 2) The homogenization variable "1" is re-used in every semidefinite variable.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there is a non-convex cost or constraint whose variables do not intersect with any of the variable groups. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0a32aadfdc1241e4e39f206479b6000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a32aadfdc1241e4e39f206479b6000">&#9670;&nbsp;</a></span>MakeSolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">SolverInterface</a>&gt; drake::solvers::MakeSolver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the solver ID, create the solver with the matching ID. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if there is no matching solver. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cfb56c6154dc071912945d08ee6833b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cfb56c6154dc071912945d08ee6833b">&#9670;&nbsp;</a></span>NewRotationMatrixVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt;3, 3&gt; drake::solvers::NewRotationMatrixVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;R&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a 3x3 matrix of decision variables with the trivial bounding box constraint ensuring all elements are [-1,1], and the linear constraint imposing -1 &lt;= trace(R) &lt;= 3. </p>

</div>
</div>
<a id="a710dbb02b7a2ce05760b1534cd7b32d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710dbb02b7a2ce05760b1534cd7b32d9">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::solvers::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed794af38e7da9270528fd2185861862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed794af38e7da9270528fd2185861862">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1solvers.html#ae07229124cd16e9d8b62fe359c7d0b40">CommonSolverOption</a>&#160;</td>
          <td class="paramname"><em>common_solver_option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a269b7066a168f80390ed6c496829ffcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269b7066a168f80390ed6c496829ffcd">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a>&#160;</td>
          <td class="paramname"><em>solution_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5fa3414cee7c7ef46d8549673b42e344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa3414cee7c7ef46d8549673b42e344">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af22da0124afc42f58ae6e42e1a97b724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22da0124afc42f58ae6e42e1a97b724">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d9c2c72528e25a82932f03228d9c867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9c2c72528e25a82932f03228d9c867">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adbd6047c1efdb345f4761a04b3764c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd6047c1efdb345f4761a04b3764c90">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15">ProgramType</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab097e2ddc8c73cd83a8ae0e801b9071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab097e2ddc8c73cd83a8ae0e801b9071">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out the <a class="el" href="classdrake_1_1solvers_1_1_binding.html" title="A binding on constraint type C is a mapping of the decision variables onto the inputs of C.">Binding</a>. </p>

</div>
</div>
<a id="ac9bfa8de91e5e18137f387121fb80933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9bfa8de91e5e18137f387121fb80933">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_rotation_constraint_generator.html#a50cc1069474becb0998889b417d7b4ff">MixedIntegerRotationConstraintGenerator::Approach</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c59daf7e576403f76128d2063303e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c59daf7e576403f76128d2063303e9b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a6297509967536d29159910e5c51fd285">IntervalBinning</a> &amp;&#160;</td>
          <td class="paramname"><em>binning</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad58cede9876421e050ac44deee7804ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58cede9876421e050ac44deee7804ff">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82dddde3ce550bdc321a2240ab12cec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82dddde3ce550bdc321a2240ab12cec0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_evaluator_base.html">EvaluatorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out the evaluator. </p>

</div>
</div>
<a id="abf0cd38a406880348f0c7fda298c66c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0cd38a406880348f0c7fda298c66c2">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8463238715a273b4709959e9bf23b9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8463238715a273b4709959e9bf23b9af">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::solvers::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c445985c8e0f84a2f88f2e70c8f9983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c445985c8e0f84a2f88f2e70c8f9983">&#9670;&nbsp;</a></span>QuadraticallySmoothedHingeLoss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::solvers::QuadraticallySmoothedHingeLoss </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>penalty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a> *&#160;</td>
          <td class="paramname"><em>dpenalty_dx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A linear hinge loss, smoothed with a quadratic loss near the origin. </p>
<p>The formulation is in equation (6) of [1]. The penalty is </p><pre class="unicode-art">
       ⎧  0        if x ≥ 0
φ(x) = ⎨  x²/2     if -1 &lt; x &lt; 0
       ⎩  -0.5 - x if x ≤ -1.
</pre><p> [1] "Loss Functions for Preference Levels: Regression with Discrete Ordered
Labels." by Jason Rennie and Nathan Srebro, Proceedings of IJCAI multidisciplinary workshop on Advances in Preference Handling. </p>

</div>
</div>
<a id="a07bf1722e3e347d7878ae44be98b4b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07bf1722e3e347d7878ae44be98b4b92">&#9670;&nbsp;</a></span>Solve() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> drake::solvers::Solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_guess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>solver_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves an optimization program, with optional initial guess and solver options. </p>
<p>This function first chooses the best solver depending on the availability of the solver and the program formulation; it then constructs that solver and call the Solve function of that solver. The optimization result is stored in the return argument. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>Contains the formulation of the program, and possibly solver options. </td></tr>
    <tr><td class="paramname">initial_guess</td><td>The initial guess for the decision variables. </td></tr>
    <tr><td class="paramname">solver_options</td><td>The options in addition to those stored in <code>prog</code>. For each option entry (like print out), there are 4 ways to set that option, and the priority given to the solver options is as follows (from lowest / least, to highest / most):<ol type="1">
<li>common option set on the <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> itself</li>
<li>common option passed as an argument to Solve</li>
<li>solver-specific option set on the <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> itself</li>
<li>solver-specific option passed as an argument to Solve </li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result The result of solving the program through the solver. </dd></dl>

</div>
</div>
<a id="a78328b8267370289c8c653bc67efde5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78328b8267370289c8c653bc67efde5e">&#9670;&nbsp;</a></span>Solve() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> drake::solvers::Solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_guess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves an optimization program with a given initial guess. </p>

</div>
</div>
<a id="a6f8160cf69cc8a3cd41dfec1fb08a8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8160cf69cc8a3cd41dfec1fb08a8fa">&#9670;&nbsp;</a></span>Solve() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> drake::solvers::Solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb1201a087105dc635e2bd748486171c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1201a087105dc635e2bd748486171c">&#9670;&nbsp;</a></span>to_string() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string drake::solvers::to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a>&#160;</td>
          <td class="paramname"><em>solution_result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfb26b995d486732f1b2867751dbbee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb26b995d486732f1b2867751dbbee7">&#9670;&nbsp;</a></span>to_string() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string drake::solvers::to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab3eb74236fcb577dba315f884034169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3eb74236fcb577dba315f884034169">&#9670;&nbsp;</a></span>to_string() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string drake::solvers::to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b1c2ddcf985a67cb331f1a797143081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1c2ddcf985a67cb331f1a797143081">&#9670;&nbsp;</a></span>to_string() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string drake::solvers::to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#ab09ca5e1afe9e5a4e8744ecb27839b15">ProgramType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd1311acfcf14624ea4089d19783d824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1311acfcf14624ea4089d19783d824">&#9670;&nbsp;</a></span>to_string() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string drake::solvers::to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_rotation_constraint_generator.html#a50cc1069474becb0998889b417d7b4ff">MixedIntegerRotationConstraintGenerator::Approach</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc62e1bcb70d02de2cb87f7bea20bc77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc62e1bcb70d02de2cb87f7bea20bc77">&#9670;&nbsp;</a></span>to_string() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string drake::solvers::to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1solvers.html#a6297509967536d29159910e5c51fd285">IntervalBinning</a>&#160;</td>
          <td class="paramname"><em>interval_binning</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16445fc3b260d8c58ea9082a3594f85f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16445fc3b260d8c58ea9082a3594f85f">&#9670;&nbsp;</a></span>to_string() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string drake::solvers::to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2294ac3fe1dc938852cfa11db48ba1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2294ac3fe1dc938852cfa11db48ba1c9">&#9670;&nbsp;</a></span>to_string() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string drake::solvers::to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3">RemoveFreeVariableMethod</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1solvers.html">solvers</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().value = searchBox.searchLabel;
</script>
</body>
</html>
