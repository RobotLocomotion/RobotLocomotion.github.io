<!-- HTML header for doxygen 1.14.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: MobyLcpSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1solvers_1_1_moby_lcp_solver.html','','classdrake_1_1solvers_1_1_moby_lcp_solver-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">MobyLcpSolver Class Reference<span class="mlabels"><span class="mlabel final">final</span></span></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class for solving Linear Complementarity Problems (LCPs). </p>
<p>Solving a LCP requires finding a solution to the problem:</p><pre>
Mz + q = w
z ≥ 0
w ≥ 0
zᵀw = 0
</pre><p> (where M ∈ ℝⁿˣⁿ and q ∈ ℝⁿ are problem inputs and z ∈ ℝⁿ and w ∈ ℝⁿ are unknown vectors) or correctly reporting that such a solution does not exist. In spite of their linear structure, solving LCPs is NP-Hard [Cottle 1992]. However, some LCPs are significantly easier to solve. For instance, it can be seen that the LCP is solvable in worst-case polynomial time for the case of symmetric positive-semi-definite M by formulating it as the following convex quadratic program:</p><pre>
minimize:   f(z) = zᵀw = zᵀ(Mz + q)
subject to: z ≥ 0
            Mz + q ≥ 0
</pre><p> Note that this quadratic program's (QP) objective function at the minimum z cannot be less than zero, and the LCP is only solved if the objective function at the minimum is equal to zero. Since the seminal result of Karmarkar, it has been known that convex QPs are solvable in polynomial time [Karmarkar 1984].</p>
<p>The difficulty of solving an LCP is characterized by the properties of its particular matrix, namely the class of matrices it belongs to. Classes include, for example, Q, Q₀, P, P₀, copositive, and Z matrices. [Cottle 1992] and [Murty 1998] (see pp. 224-230 in the latter) describe relevant matrix classes in more detail.</p>
<ul>
<li>[Cottle 1992] R. Cottle, J.-S. Pang, and R. Stone. The Linear Complementarity Problem. Academic Press, 1992.</li>
<li>[Karmarkar 1984] N. Karmarkar. A New Polynomial-Time Algorithm for Linear Programming. Combinatorica, 4(4), pp. 373-395.</li>
<li>[Murty 1988] K. Murty. Linear Complementarity, Linear and Nonlinear Programming. Heldermann Verlag, 1988. </li>
</ul>
</div>
<p><code>#include &lt;drake/solvers/moby_lcp_solver.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6a2c54501a39a9ef46ab7a1d5c25b8b2" id="r_a6a2c54501a39a9ef46ab7a1d5c25b8b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a2c54501a39a9ef46ab7a1d5c25b8b2">MobyLcpSolver</a> ()</td></tr>
<tr class="memitem:a8ed6a6eda73378ce752ea5a4a0990207" id="r_a8ed6a6eda73378ce752ea5a4a0990207"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ed6a6eda73378ce752ea5a4a0990207">~MobyLcpSolver</a> () final</td></tr>
<tr class="memitem:aa8f0cf0c2589fd822dcb88e257b0d002" id="r_aa8f0cf0c2589fd822dcb88e257b0d002"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8f0cf0c2589fd822dcb88e257b0d002">SolveLcpFast</a> (const Eigen::MatrixXd &amp;M, const Eigen::VectorXd &amp;q, Eigen::VectorXd *z, <a class="el" href="classdouble.html">double</a> zero_tol=-1) const</td></tr>
<tr class="memdesc:aa8f0cf0c2589fd822dcb88e257b0d002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast pivoting algorithm for LCPs of the form M = PAPᵀ, q = Pb, where b ∈ ℝᵐ, P ∈ ℝⁿˣᵐ, and A ∈ ℝᵐˣᵐ (where A is positive definite).  <br /></td></tr>
<tr class="memitem:a7fa876c5f12dd726f89ea7784599488c" id="r_a7fa876c5f12dd726f89ea7784599488c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fa876c5f12dd726f89ea7784599488c">SolveLcpFastRegularized</a> (const Eigen::MatrixXd &amp;M, const Eigen::VectorXd &amp;q, Eigen::VectorXd *z, int min_exp=-20, unsigned step_exp=4, int max_exp=20, <a class="el" href="classdouble.html">double</a> zero_tol=-1) const</td></tr>
<tr class="memdesc:a7fa876c5f12dd726f89ea7784599488c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regularized version of the fast pivoting algorithm for LCPs of the form M = PAPᵀ, q = Pb, where b ∈ ℝᵐ, P ∈ ℝⁿˣᵐ, and A ∈ ℝᵐˣᵐ (where A is positive definite).  <br /></td></tr>
<tr class="memitem:ad1c42e357e869c8705f20d62cc959fe9" id="r_ad1c42e357e869c8705f20d62cc959fe9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1c42e357e869c8705f20d62cc959fe9">SolveLcpLemke</a> (const Eigen::MatrixXd &amp;M, const Eigen::VectorXd &amp;q, Eigen::VectorXd *z, <a class="el" href="classdouble.html">double</a> piv_tol=-1, <a class="el" href="classdouble.html">double</a> zero_tol=-1) const</td></tr>
<tr class="memdesc:ad1c42e357e869c8705f20d62cc959fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lemke's Algorithm for solving LCPs in the matrix class E, which contains all strictly semimonotone matrices, all P-matrices, and all strictly copositive matrices.  <br /></td></tr>
<tr class="memitem:a0ec30fee0ef07674da86daa188cb6126" id="r_a0ec30fee0ef07674da86daa188cb6126"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ec30fee0ef07674da86daa188cb6126">SolveLcpLemkeRegularized</a> (const Eigen::MatrixXd &amp;M, const Eigen::VectorXd &amp;q, Eigen::VectorXd *z, int min_exp=-20, unsigned step_exp=1, int max_exp=1, <a class="el" href="classdouble.html">double</a> piv_tol=-1, <a class="el" href="classdouble.html">double</a> zero_tol=-1) const</td></tr>
<tr class="memdesc:a0ec30fee0ef07674da86daa188cb6126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lemke's Algorithm for solving LCPs in the matrix class E, which contains all strictly semimonotone matrices, all P-matrices, and all strictly copositive matrices.  <br /></td></tr>
<tr class="memitem:a9f2f977a2be04239fe82e5257f1970a8" id="r_a9f2f977a2be04239fe82e5257f1970a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f2f977a2be04239fe82e5257f1970a8">get_num_pivots</a> () const</td></tr>
<tr class="memdesc:a9f2f977a2be04239fe82e5257f1970a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of pivoting operations made by the last LCP solve.  <br /></td></tr>
<tr class="memitem:a940b243c1e6bc23203756a73f2c80c6b" id="r_a940b243c1e6bc23203756a73f2c80c6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a940b243c1e6bc23203756a73f2c80c6b">reset_num_pivots</a> ()</td></tr>
<tr class="memdesc:a940b243c1e6bc23203756a73f2c80c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the number of pivoting operations made by the last LCP solver to zero.  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:a09223f85c6f45ff971ac23dd1302fb74" id="r_a09223f85c6f45ff971ac23dd1302fb74"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09223f85c6f45ff971ac23dd1302fb74">MobyLcpSolver</a> (const <a class="el" href="classdrake_1_1solvers_1_1_moby_lcp_solver.html">MobyLcpSolver</a> &amp;)=delete</td></tr>
<tr class="memitem:ad5a459a1ca01292ce5d43c9ec40542b8" id="r_ad5a459a1ca01292ce5d43c9ec40542b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_moby_lcp_solver.html">MobyLcpSolver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5a459a1ca01292ce5d43c9ec40542b8">operator=</a> (const <a class="el" href="classdrake_1_1solvers_1_1_moby_lcp_solver.html">MobyLcpSolver</a> &amp;)=delete</td></tr>
<tr class="memitem:ad83152f98f135628003d9de5baeab5b0" id="r_ad83152f98f135628003d9de5baeab5b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad83152f98f135628003d9de5baeab5b0">MobyLcpSolver</a> (<a class="el" href="classdrake_1_1solvers_1_1_moby_lcp_solver.html">MobyLcpSolver</a> &amp;&amp;)=delete</td></tr>
<tr class="memitem:a59fd90a896d536e9a055d39a8269162e" id="r_a59fd90a896d536e9a055d39a8269162e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_moby_lcp_solver.html">MobyLcpSolver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59fd90a896d536e9a055d39a8269162e">operator=</a> (<a class="el" href="classdrake_1_1solvers_1_1_moby_lcp_solver.html">MobyLcpSolver</a> &amp;&amp;)=delete</td></tr>
<tr class="inherit_header pub_methods_classdrake_1_1solvers_1_1_solver_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classdrake_1_1solvers_1_1_solver_base')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Member Functions inherited from <a class="el" href="classdrake_1_1solvers_1_1_solver_base.html">SolverBase</a></td></tr>
<tr class="memitem:a6d380dcebbd2d8a52d4c44b931fec3a1 inherit pub_methods_classdrake_1_1solvers_1_1_solver_base" id="r_a6d380dcebbd2d8a52d4c44b931fec3a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_base.html#a6d380dcebbd2d8a52d4c44b931fec3a1">~SolverBase</a> () override</td></tr>
<tr class="memitem:a00b55f8b4c1c4f19b45621a84deed66c inherit pub_methods_classdrake_1_1solvers_1_1_solver_base" id="r_a00b55f8b4c1c4f19b45621a84deed66c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_base.html#a00b55f8b4c1c4f19b45621a84deed66c">Solve</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog, const std::optional&lt; Eigen::VectorXd &gt; &amp;initial_guess=std::nullopt, const std::optional&lt; <a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &gt; &amp;solver_options=std::nullopt) const</td></tr>
<tr class="memdesc:a00b55f8b4c1c4f19b45621a84deed66c inherit pub_methods_classdrake_1_1solvers_1_1_solver_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html#aec933bef2f8c7a702a6fd5c59feac5ec" title="Solves an optimization program with optional initial guess and solver options.">SolverInterface::Solve()</a>, but the result is a return value instead of an output argument.  <br /></td></tr>
<tr class="memitem:af2ff6a250a78bb79ef64f7527c51b01c inherit pub_methods_classdrake_1_1solvers_1_1_solver_base" id="r_af2ff6a250a78bb79ef64f7527c51b01c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_base.html#af2ff6a250a78bb79ef64f7527c51b01c">Solve</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;, const std::optional&lt; Eigen::VectorXd &gt; &amp;, const std::optional&lt; <a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &gt; &amp;, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> *) const override</td></tr>
<tr class="memdesc:af2ff6a250a78bb79ef64f7527c51b01c inherit pub_methods_classdrake_1_1solvers_1_1_solver_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves an optimization program with optional initial guess and solver options.  <br /></td></tr>
<tr class="memitem:ac910159108658c34a743b0806d81ab10 inherit pub_methods_classdrake_1_1solvers_1_1_solver_base" id="r_ac910159108658c34a743b0806d81ab10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_base.html#ac910159108658c34a743b0806d81ab10">available</a> () const override</td></tr>
<tr class="memdesc:ac910159108658c34a743b0806d81ab10 inherit pub_methods_classdrake_1_1solvers_1_1_solver_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff support for this solver has been compiled into Drake.  <br /></td></tr>
<tr class="memitem:a4420a962b7baa94708051d493e790797 inherit pub_methods_classdrake_1_1solvers_1_1_solver_base" id="r_a4420a962b7baa94708051d493e790797"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_base.html#a4420a962b7baa94708051d493e790797">enabled</a> () const override</td></tr>
<tr class="memdesc:a4420a962b7baa94708051d493e790797 inherit pub_methods_classdrake_1_1solvers_1_1_solver_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff this solver is properly configured for use at runtime.  <br /></td></tr>
<tr class="memitem:ac539874b9f15a8ff31c4081a32469452 inherit pub_methods_classdrake_1_1solvers_1_1_solver_base" id="r_ac539874b9f15a8ff31c4081a32469452"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_base.html#ac539874b9f15a8ff31c4081a32469452">solver_id</a> () const final</td></tr>
<tr class="memdesc:ac539874b9f15a8ff31c4081a32469452 inherit pub_methods_classdrake_1_1solvers_1_1_solver_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the identifier of this solver.  <br /></td></tr>
<tr class="memitem:a0ef97dfe948b1e50246018c3cfe8a62e inherit pub_methods_classdrake_1_1solvers_1_1_solver_base" id="r_a0ef97dfe948b1e50246018c3cfe8a62e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_base.html#a0ef97dfe948b1e50246018c3cfe8a62e">AreProgramAttributesSatisfied</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;) const override</td></tr>
<tr class="memdesc:a0ef97dfe948b1e50246018c3cfe8a62e inherit pub_methods_classdrake_1_1solvers_1_1_solver_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the program's attributes are compatible with this solver's capabilities.  <br /></td></tr>
<tr class="memitem:a9425d90e072bea5285bd14ff9675a2bc inherit pub_methods_classdrake_1_1solvers_1_1_solver_base" id="r_a9425d90e072bea5285bd14ff9675a2bc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_base.html#a9425d90e072bea5285bd14ff9675a2bc">ExplainUnsatisfiedProgramAttributes</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;) const override</td></tr>
<tr class="memdesc:a9425d90e072bea5285bd14ff9675a2bc inherit pub_methods_classdrake_1_1solvers_1_1_solver_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the reasons (if any) why the program is incompatible with this solver's capabilities.  <br /></td></tr>
<tr class="memitem:acfbd02da50f7b6eeee38cc795e4fd2e5 inherit pub_methods_classdrake_1_1solvers_1_1_solver_base" id="r_acfbd02da50f7b6eeee38cc795e4fd2e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_base.html#acfbd02da50f7b6eeee38cc795e4fd2e5">SolverBase</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_base.html">SolverBase</a> &amp;)=delete</td></tr>
<tr class="memitem:a642c05c8f046061a888d46243a8e484d inherit pub_methods_classdrake_1_1solvers_1_1_solver_base" id="r_a642c05c8f046061a888d46243a8e484d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_solver_base.html">SolverBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_base.html#a642c05c8f046061a888d46243a8e484d">operator=</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_base.html">SolverBase</a> &amp;)=delete</td></tr>
<tr class="memitem:a049180fe6d71c290a16c62f1b5d97836 inherit pub_methods_classdrake_1_1solvers_1_1_solver_base" id="r_a049180fe6d71c290a16c62f1b5d97836"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_base.html#a049180fe6d71c290a16c62f1b5d97836">SolverBase</a> (<a class="el" href="classdrake_1_1solvers_1_1_solver_base.html">SolverBase</a> &amp;&amp;)=delete</td></tr>
<tr class="memitem:a7b4139c9d760a4de4438d48e979bff5c inherit pub_methods_classdrake_1_1solvers_1_1_solver_base" id="r_a7b4139c9d760a4de4438d48e979bff5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_solver_base.html">SolverBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_base.html#a7b4139c9d760a4de4438d48e979bff5c">operator=</a> (<a class="el" href="classdrake_1_1solvers_1_1_solver_base.html">SolverBase</a> &amp;&amp;)=delete</td></tr>
<tr class="inherit_header pub_methods_classdrake_1_1solvers_1_1_solver_interface"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classdrake_1_1solvers_1_1_solver_interface')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Member Functions inherited from <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">SolverInterface</a></td></tr>
<tr class="memitem:abf3f7966f1746f4f30c609c769f8b906 inherit pub_methods_classdrake_1_1solvers_1_1_solver_interface" id="r_abf3f7966f1746f4f30c609c769f8b906"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html#abf3f7966f1746f4f30c609c769f8b906">~SolverInterface</a> ()</td></tr>
<tr class="memitem:ae9b1880991b1fc732485c99036790983 inherit pub_methods_classdrake_1_1solvers_1_1_solver_interface" id="r_ae9b1880991b1fc732485c99036790983"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html#ae9b1880991b1fc732485c99036790983">SolverInterface</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">SolverInterface</a> &amp;)=delete</td></tr>
<tr class="memitem:a1c13d92bfd97bfc6825f7de8cde8997b inherit pub_methods_classdrake_1_1solvers_1_1_solver_interface" id="r_a1c13d92bfd97bfc6825f7de8cde8997b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">SolverInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html#a1c13d92bfd97bfc6825f7de8cde8997b">operator=</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">SolverInterface</a> &amp;)=delete</td></tr>
<tr class="memitem:a417d58de5faf840e5c617c3293695c15 inherit pub_methods_classdrake_1_1solvers_1_1_solver_interface" id="r_a417d58de5faf840e5c617c3293695c15"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html#a417d58de5faf840e5c617c3293695c15">SolverInterface</a> (<a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">SolverInterface</a> &amp;&amp;)=delete</td></tr>
<tr class="memitem:a6ba09528abf019780b730111507c3ae8 inherit pub_methods_classdrake_1_1solvers_1_1_solver_interface" id="r_a6ba09528abf019780b730111507c3ae8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">SolverInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html#a6ba09528abf019780b730111507c3ae8">operator=</a> (<a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">SolverInterface</a> &amp;&amp;)=delete</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa58e376b7b5873a22bcdb6f8d3a0b42c" id="r_aa58e376b7b5873a22bcdb6f8d3a0b42c"><td class="memTemplParams" colspan="2">template&lt;class U&gt; </td></tr>
<tr class="memitem:aa58e376b7b5873a22bcdb6f8d3a0b42c template"><td class="memItemLeft" align="right" valign="top">static U&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa58e376b7b5873a22bcdb6f8d3a0b42c">ComputeZeroTolerance</a> (const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; U &gt; &amp;M)</td></tr>
<tr class="memdesc:aa58e376b7b5873a22bcdb6f8d3a0b42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the zero tolerance that the solver would compute if the user does not specify a tolerance.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-member-group" class="groupheader"><a id="member-group" name="member-group"></a>
Static versions of the instance methods with similar names.</h2></td></tr>
<tr class="memitem:a00b55f8b4c1c4f19b45621a84deed66c" id="r_a00b55f8b4c1c4f19b45621a84deed66c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00b55f8b4c1c4f19b45621a84deed66c">Solve</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog, const std::optional&lt; Eigen::VectorXd &gt; &amp;initial_guess=std::nullopt, const std::optional&lt; <a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &gt; &amp;solver_options=std::nullopt) const</td></tr>
<tr class="memdesc:a00b55f8b4c1c4f19b45621a84deed66c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html#aec933bef2f8c7a702a6fd5c59feac5ec" title="Solves an optimization program with optional initial guess and solver options.">SolverInterface::Solve()</a>, but the result is a return value instead of an output argument.  <br /></td></tr>
<tr class="memitem:af2ff6a250a78bb79ef64f7527c51b01c" id="r_af2ff6a250a78bb79ef64f7527c51b01c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2ff6a250a78bb79ef64f7527c51b01c">Solve</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;, const std::optional&lt; Eigen::VectorXd &gt; &amp;, const std::optional&lt; <a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &gt; &amp;, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> *) const override</td></tr>
<tr class="memdesc:af2ff6a250a78bb79ef64f7527c51b01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves an optimization program with optional initial guess and solver options.  <br /></td></tr>
<tr class="memitem:a4dc451b7db72a168d9f0da1746011b45" id="r_a4dc451b7db72a168d9f0da1746011b45"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4dc451b7db72a168d9f0da1746011b45">id</a> ()</td></tr>
<tr class="memitem:a277134785588d69bb461a4a402877e7a" id="r_a277134785588d69bb461a4a402877e7a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a277134785588d69bb461a4a402877e7a">is_available</a> ()</td></tr>
<tr class="memitem:a2acbb1fddaffbf52c3eaf70f6dfa41bd" id="r_a2acbb1fddaffbf52c3eaf70f6dfa41bd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2acbb1fddaffbf52c3eaf70f6dfa41bd">is_enabled</a> ()</td></tr>
<tr class="memitem:a793b4bef71b184ac87f03d80b21c04d2" id="r_a793b4bef71b184ac87f03d80b21c04d2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a793b4bef71b184ac87f03d80b21c04d2">ProgramAttributesSatisfied</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-inherited" class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classdrake_1_1solvers_1_1_solver_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classdrake_1_1solvers_1_1_solver_base')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Protected Member Functions inherited from <a class="el" href="classdrake_1_1solvers_1_1_solver_base.html">SolverBase</a></td></tr>
<tr class="memitem:a174aede98257e1c1c25dc3d5dafc4568 inherit pro_methods_classdrake_1_1solvers_1_1_solver_base" id="r_a174aede98257e1c1c25dc3d5dafc4568"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_base.html#a174aede98257e1c1c25dc3d5dafc4568">SolverBase</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;id, std::function&lt; bool()&gt; <a class="el" href="classdrake_1_1solvers_1_1_solver_base.html#ac910159108658c34a743b0806d81ab10">available</a>, std::function&lt; bool()&gt; <a class="el" href="classdrake_1_1solvers_1_1_solver_base.html#a4420a962b7baa94708051d493e790797">enabled</a>, std::function&lt; bool(const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;)&gt; are_satisfied, std::function&lt; std::string(const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;)&gt; explain_unsatisfied=nullptr)</td></tr>
<tr class="memdesc:a174aede98257e1c1c25dc3d5dafc4568 inherit pro_methods_classdrake_1_1solvers_1_1_solver_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classdrake_1_1solvers_1_1_solver_base.html" title="Abstract base class used by implementations of individual solvers.">SolverBase</a> with the given default implementations of the <a class="el" href="classdrake_1_1solvers_1_1_solver_base.html#ac539874b9f15a8ff31c4081a32469452" title="Returns the identifier of this solver.">solver_id()</a>, <a class="el" href="classdrake_1_1solvers_1_1_solver_base.html#ac910159108658c34a743b0806d81ab10" title="Returns true iff support for this solver has been compiled into Drake.">available()</a>, <a class="el" href="classdrake_1_1solvers_1_1_solver_base.html#a4420a962b7baa94708051d493e790797" title="Returns true iff this solver is properly configured for use at runtime.">enabled()</a>, <a class="el" href="classdrake_1_1solvers_1_1_solver_base.html#a0ef97dfe948b1e50246018c3cfe8a62e" title="Returns true iff the program&#39;s attributes are compatible with this solver&#39;s capabilities.">AreProgramAttributesSatisfied()</a>, and <a class="el" href="classdrake_1_1solvers_1_1_solver_base.html#a9425d90e072bea5285bd14ff9675a2bc" title="Describes the reasons (if any) why the program is incompatible with this solver&#39;s capabilities.">ExplainUnsatisfiedProgramAttributes()</a> methods.  <br /></td></tr>
<tr class="memitem:a8350f557f172064cafe074f38fe4a9a2 inherit pro_methods_classdrake_1_1solvers_1_1_solver_base" id="r_a8350f557f172064cafe074f38fe4a9a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_base.html#a8350f557f172064cafe074f38fe4a9a2">DoSolve2</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog, const Eigen::VectorXd &amp;initial_guess, internal::SpecificOptions *options, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> *result) const</td></tr>
<tr class="memdesc:a8350f557f172064cafe074f38fe4a9a2 inherit pro_methods_classdrake_1_1solvers_1_1_solver_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Internal use only) Like <a class="el" href="classdrake_1_1solvers_1_1_solver_base.html#a23607a340ac9629747514f2dbdc45198" title="Hook for subclasses to implement Solve.">DoSolve()</a> but using SpecificOptions instead of <a class="el" href="structdrake_1_1solvers_1_1_solver_options.html" title="Stores options for multiple solvers.">SolverOptions</a>.  <br /></td></tr>
<tr class="inherit_header pro_methods_classdrake_1_1solvers_1_1_solver_interface"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classdrake_1_1solvers_1_1_solver_interface')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Protected Member Functions inherited from <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">SolverInterface</a></td></tr>
<tr class="memitem:a59a2b968eced6bf266e780015416db83 inherit pro_methods_classdrake_1_1solvers_1_1_solver_interface" id="r_a59a2b968eced6bf266e780015416db83"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html#a59a2b968eced6bf266e780015416db83">SolverInterface</a> ()</td></tr>
</table>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a09223f85c6f45ff971ac23dd1302fb74" name="a09223f85c6f45ff971ac23dd1302fb74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09223f85c6f45ff971ac23dd1302fb74">&#9670;&#160;</a></span>MobyLcpSolver() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_moby_lcp_solver.html">MobyLcpSolver</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_moby_lcp_solver.html">MobyLcpSolver</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad83152f98f135628003d9de5baeab5b0" name="ad83152f98f135628003d9de5baeab5b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83152f98f135628003d9de5baeab5b0">&#9670;&#160;</a></span>MobyLcpSolver() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_moby_lcp_solver.html">MobyLcpSolver</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_moby_lcp_solver.html">MobyLcpSolver</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a2c54501a39a9ef46ab7a1d5c25b8b2" name="a6a2c54501a39a9ef46ab7a1d5c25b8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2c54501a39a9ef46ab7a1d5c25b8b2">&#9670;&#160;</a></span>MobyLcpSolver() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_moby_lcp_solver.html">MobyLcpSolver</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ed6a6eda73378ce752ea5a4a0990207" name="a8ed6a6eda73378ce752ea5a4a0990207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed6a6eda73378ce752ea5a4a0990207">&#9670;&#160;</a></span>~MobyLcpSolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classdrake_1_1solvers_1_1_moby_lcp_solver.html">MobyLcpSolver</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel final">final</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="aa58e376b7b5873a22bcdb6f8d3a0b42c" name="aa58e376b7b5873a22bcdb6f8d3a0b42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa58e376b7b5873a22bcdb6f8d3a0b42c">&#9670;&#160;</a></span>ComputeZeroTolerance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U ComputeZeroTolerance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the zero tolerance that the solver would compute if the user does not specify a tolerance. </p>

</div>
</div>
<a id="a9f2f977a2be04239fe82e5257f1970a8" name="a9f2f977a2be04239fe82e5257f1970a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2f977a2be04239fe82e5257f1970a8">&#9670;&#160;</a></span>get_num_pivots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int get_num_pivots </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of pivoting operations made by the last LCP solve. </p>

</div>
</div>
<a id="a4dc451b7db72a168d9f0da1746011b45" name="a4dc451b7db72a168d9f0da1746011b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc451b7db72a168d9f0da1746011b45">&#9670;&#160;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> id </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a277134785588d69bb461a4a402877e7a" name="a277134785588d69bb461a4a402877e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277134785588d69bb461a4a402877e7a">&#9670;&#160;</a></span>is_available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_available </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2acbb1fddaffbf52c3eaf70f6dfa41bd" name="a2acbb1fddaffbf52c3eaf70f6dfa41bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2acbb1fddaffbf52c3eaf70f6dfa41bd">&#9670;&#160;</a></span>is_enabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_enabled </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5a459a1ca01292ce5d43c9ec40542b8" name="ad5a459a1ca01292ce5d43c9ec40542b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a459a1ca01292ce5d43c9ec40542b8">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_moby_lcp_solver.html">MobyLcpSolver</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_moby_lcp_solver.html">MobyLcpSolver</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a59fd90a896d536e9a055d39a8269162e" name="a59fd90a896d536e9a055d39a8269162e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59fd90a896d536e9a055d39a8269162e">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_moby_lcp_solver.html">MobyLcpSolver</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_moby_lcp_solver.html">MobyLcpSolver</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a793b4bef71b184ac87f03d80b21c04d2" name="a793b4bef71b184ac87f03d80b21c04d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793b4bef71b184ac87f03d80b21c04d2">&#9670;&#160;</a></span>ProgramAttributesSatisfied()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ProgramAttributesSatisfied </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a940b243c1e6bc23203756a73f2c80c6b" name="a940b243c1e6bc23203756a73f2c80c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940b243c1e6bc23203756a73f2c80c6b">&#9670;&#160;</a></span>reset_num_pivots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reset_num_pivots </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the number of pivoting operations made by the last LCP solver to zero. </p>

</div>
</div>
<a id="af2ff6a250a78bb79ef64f7527c51b01c" name="af2ff6a250a78bb79ef64f7527c51b01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ff6a250a78bb79ef64f7527c51b01c">&#9670;&#160;</a></span>Solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>initial_guess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>solver_options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves an optimization program with optional initial guess and solver options. </p>
<p>Note that these initial guess and solver options are not written to <code class="param">prog</code>. If the <code class="param">prog</code> has set an initial guess, and <code class="param">initial_guess</code> is set, then <code class="param">initial_guess</code> takes priority. If the <code class="param">prog</code> has set an option for a solver, and <code class="param">solver_options</code> contains a different value for the same option on the same solver, then <code class="param">solver_options</code> takes priority. Derived implementations of this interface may elect to throw std::exception for badly formed programs. </p>

<p>Implements <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html#aec933bef2f8c7a702a6fd5c59feac5ec">SolverInterface</a>.</p>

</div>
</div>
<a id="a00b55f8b4c1c4f19b45621a84deed66c" name="a00b55f8b4c1c4f19b45621a84deed66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b55f8b4c1c4f19b45621a84deed66c">&#9670;&#160;</a></span>Solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> Solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>prog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; Eigen::VectorXd &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>initial_guess</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="structdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>solver_options</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html#aec933bef2f8c7a702a6fd5c59feac5ec" title="Solves an optimization program with optional initial guess and solver options.">SolverInterface::Solve()</a>, but the result is a return value instead of an output argument. </p>

</div>
</div>
<a id="aa8f0cf0c2589fd822dcb88e257b0d002" name="aa8f0cf0c2589fd822dcb88e257b0d002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f0cf0c2589fd822dcb88e257b0d002">&#9670;&#160;</a></span>SolveLcpFast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SolveLcpFast </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd *</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>zero_tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast pivoting algorithm for LCPs of the form M = PAPᵀ, q = Pb, where b ∈ ℝᵐ, P ∈ ℝⁿˣᵐ, and A ∈ ℝᵐˣᵐ (where A is positive definite). </p>
<p>Therefore, q is in the range of P and M is positive semi-definite. An LCP of this form is also guaranteed to have a solution [Cottle 1992].</p>
<p>This particular implementation focuses on the case where the solution requires few nonzero nonbasic variables, meaning that few z variables need be nonzero to find a solution to Mz + q = w. This algorithm, which is based off of Dantzig's Principle Pivoting Method I [Cottle 1992] is described in [Drumwright 2015]. This algorithm is able to use "warm" starting- a solution to a "nearby" LCP can be used to find the solution to a given LCP more quickly.</p>
<p>Although this solver is theoretically guaranteed to give a solution to the LCPs described above, accumulated floating point error from pivoting operations could cause the solver to fail. Additionally, the solver can be applied with some success to problems outside of its guaranteed matrix class. For these reasons, the solver returns a flag indicating success/failure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>the LCP matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>the LCP vector. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">z</td><td>the solution to the LCP on return (if the solver succeeds). If the length of z is equal to the length of q, the solver will attempt to use z's value as a starting solution. If the solver fails (returns <span class="tt">false</span>), <span class="tt">z</span> will be set to the zero vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zero_tol</td><td>The tolerance for testing against zero. If the tolerance is negative (default) the solver will determine a generally reasonable tolerance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if M is non-square or M's dimensions do not equal q's dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the solver succeeded and <span class="tt">false</span> otherwise.</dd></dl>
<ul>
<li>[Cottle 1992] R. Cottle, J.-S. Pang, and R. Stone. The Linear Complementarity Problem. Academic Press, 1992.</li>
<li>[Drumwright 2015] E. Drumwright. Rapidly computable viscous friction and no-slip rigid contact models. arXiv: 1504.00719v1. 2015. </li>
</ul>

</div>
</div>
<a id="a7fa876c5f12dd726f89ea7784599488c" name="a7fa876c5f12dd726f89ea7784599488c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa876c5f12dd726f89ea7784599488c">&#9670;&#160;</a></span>SolveLcpFastRegularized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SolveLcpFastRegularized </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd *</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>min_exp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-20</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>step_exp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">4</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max_exp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>zero_tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Regularized version of the fast pivoting algorithm for LCPs of the form M = PAPᵀ, q = Pb, where b ∈ ℝᵐ, P ∈ ℝⁿˣᵐ, and A ∈ ℝᵐˣᵐ (where A is positive definite). </p>
<p>Therefore, q is in the range of P and M is positive semi-definite. Please see <a class="el" href="#aa8f0cf0c2589fd822dcb88e257b0d002" title="Fast pivoting algorithm for LCPs of the form M = PAPᵀ, q = Pb, where b ∈ ℝᵐ, P ∈ ℝⁿˣᵐ,...">SolveLcpFast()</a> for more documentation about the particular algorithm.</p>
<p>This implementation wraps that algorithm with a Tikhonov-type regularization approach. Specifically, this implementation repeatedly attempts to solve the LCP:</p><pre>
(M + Iα)z + q = w
z ≥ 0
w ≥ 0
zᵀw = 0
</pre><p> where I is the identity matrix and α ≪ 1, using geometrically increasing values of α, until the LCP is solved. Cottle et al. describe how, for sufficiently large α, the LCP will always be solvable [Cottle 1992], p. 493.</p>
<p>Although this solver is theoretically guaranteed to give a solution to the LCPs described above, accumulated floating point error from pivoting operations could cause the solver to fail. Additionally, the solver can be applied with some success to problems outside of its guaranteed matrix class. For these reasons, the solver returns a flag indicating success/failure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>the LCP matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>the LCP vector. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">z</td><td>the solution to the LCP on return (if the solver succeeds). If the length of z is equal to the length of q, the solver will attempt to use z's value as a starting solution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_exp</td><td>The minimum exponent for computing α over [10ᵝ, 10ᵞ] in steps of 10ᵟ, where β is the minimum exponent, γ is the maximum exponent, and δ is the stepping exponent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step_exp</td><td>The stepping exponent for computing α over [10ᵝ, 10ᵞ] in steps of 10ᵟ, where β is the minimum exponent, γ is the maximum exponent, and δ is the stepping exponent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_exp</td><td>The maximum exponent for computing α over [10ᵝ, 10ᵞ] in steps of 10ᵟ, where β is the minimum exponent, γ is the maximum exponent, and δ is the stepping exponent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zero_tol</td><td>The tolerance for testing against zero. If the tolerance is negative (default) the solver will determine a generally reasonable tolerance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if M is non-square or M's dimensions do not equal q's dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the solver succeeded and <span class="tt">false</span> if the solver did not find a solution for α = 10ᵞ. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa8f0cf0c2589fd822dcb88e257b0d002" title="Fast pivoting algorithm for LCPs of the form M = PAPᵀ, q = Pb, where b ∈ ℝᵐ, P ∈ ℝⁿˣᵐ,...">SolveLcpFast()</a></dd></dl>
<ul>
<li>[Cottle, 1992] R. Cottle, J.-S. Pang, and R. Stone. The Linear Complementarity Problem. Academic Press, 1992. </li>
</ul>

</div>
</div>
<a id="ad1c42e357e869c8705f20d62cc959fe9" name="ad1c42e357e869c8705f20d62cc959fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c42e357e869c8705f20d62cc959fe9">&#9670;&#160;</a></span>SolveLcpLemke()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SolveLcpLemke </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd *</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>piv_tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>zero_tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lemke's Algorithm for solving LCPs in the matrix class E, which contains all strictly semimonotone matrices, all P-matrices, and all strictly copositive matrices. </p>
<p>Lemke's Algorithm is described in [Cottle 1992], Section 4.4. This implementation was adapted from the LEMKE Library [LEMKE] for Matlab; this particular implementation fixes a bug in LEMKE that could occur when multiple indices passed the minimum ratio test.</p>
<p>Although this solver is theoretically guaranteed to give a solution to the LCPs described above, accumulated floating point error from pivoting operations could cause the solver to fail. Additionally, the solver can be applied with some success to problems outside of its guaranteed matrix classes. For these reasons, the solver returns a flag indicating success/failure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>the LCP matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>the LCP vector. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">z</td><td>the solution to the LCP on return (if the solver succeeds). If the length of z is equal to the length of q, the solver will attempt to use z's value as a starting solution. <b>This warmstarting is generally not recommended</b>: it has a predisposition to lead to a failing pivoting sequence. If the solver fails (returns <span class="tt">false</span>), <span class="tt">z</span> will be set to the zero vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zero_tol</td><td>The tolerance for testing against zero. If the tolerance is negative (default) the solver will determine a generally reasonable tolerance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">piv_tol</td><td>The tolerance for testing against zero, specifically used for the purpose of finding variables for pivoting. If the tolerance is negative (default) the solver will determine a generally reasonable tolerance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the solver <b>believes</b> it has computed a solution (which it determines by the ability to "pivot out" the "artificial" variable (see [Cottle 1992]) and <span class="tt">false</span> otherwise. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The caller should verify that the algorithm has solved the LCP to the desired tolerances on returns indicating success. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if M is not square or the dimensions of M do not match the length of q.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>[Cottle 1992] R. Cottle, J.-S. Pang, and R. Stone. The Linear Complementarity Problem. Academic Press, 1992.</li>
<li>[LEMKE] P. Fackler and M. Miranda. LEMKE. <a href="http://people.sc.fsu.edu/~burkardt/m_src/lemke/lemke.m">http://people.sc.fsu.edu/~burkardt/m_src/lemke/lemke.m</a> </li>
</ul>

</div>
</div>
<a id="a0ec30fee0ef07674da86daa188cb6126" name="a0ec30fee0ef07674da86daa188cb6126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec30fee0ef07674da86daa188cb6126">&#9670;&#160;</a></span>SolveLcpLemkeRegularized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SolveLcpLemkeRegularized </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd *</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>min_exp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-20</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>step_exp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max_exp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>piv_tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a></td>          <td class="paramname"><span class="paramname"><em>zero_tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lemke's Algorithm for solving LCPs in the matrix class E, which contains all strictly semimonotone matrices, all P-matrices, and all strictly copositive matrices. </p>
<p>Lemke's Algorithm is described in [Cottle 1992], Section 4.4.</p>
<p>This implementation wraps that algorithm with a Tikhonov-type regularization approach. Specifically, this implementation repeatedly attempts to solve the LCP:</p><pre>
(M + Iα)z + q = w
z ≥ 0
w ≥ 0
zᵀw = 0
</pre><p> where I is the identity matrix and α ≪ 1, using geometrically increasing values of α, until the LCP is solved. See <a class="el" href="#a7fa876c5f12dd726f89ea7784599488c" title="Regularized version of the fast pivoting algorithm for LCPs of the form M = PAPᵀ, q = Pb,...">SolveLcpFastRegularized()</a> for description of the regularization process and the function parameters, which are identical. See <a class="el" href="#ad1c42e357e869c8705f20d62cc959fe9" title="Lemke&#39;s Algorithm for solving LCPs in the matrix class E, which contains all strictly semimonotone ma...">SolveLcpLemke()</a> for a description of Lemke's Algorithm. See <a class="el" href="#a7fa876c5f12dd726f89ea7784599488c" title="Regularized version of the fast pivoting algorithm for LCPs of the form M = PAPᵀ, q = Pb,...">SolveLcpFastRegularized()</a> for a description of all calling parameters other than <code class="param">z</code>, which apply equally well to this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">z</td><td>the solution to the LCP on return (if the solver succeeds). If the length of z is equal to the length of q, the solver will attempt to use z's value as a starting solution. <b>This warmstarting is generally not recommended</b>: it has a predisposition to lead to a failing pivoting sequence.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a7fa876c5f12dd726f89ea7784599488c" title="Regularized version of the fast pivoting algorithm for LCPs of the form M = PAPᵀ, q = Pb,...">SolveLcpFastRegularized()</a> </dd>
<dd>
<a class="el" href="#ad1c42e357e869c8705f20d62cc959fe9" title="Lemke&#39;s Algorithm for solving LCPs in the matrix class E, which contains all strictly semimonotone ma...">SolveLcpLemke()</a></dd></dl>
<ul>
<li>[Cottle 1992] R. Cottle, J.-S. Pang, and R. Stone. The Linear Complementarity Problem. Academic Press, 1992. </li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/solvers/<a class="el" href="moby__lcp__solver_8h.html">moby_lcp_solver.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="namespacedrake_1_1solvers.html">solvers</a></li><li class="navelem"><a href="classdrake_1_1solvers_1_1_moby_lcp_solver.html">MobyLcpSolver</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
