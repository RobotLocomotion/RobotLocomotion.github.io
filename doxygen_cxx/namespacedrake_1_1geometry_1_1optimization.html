<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake::geometry::optimization Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 </div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacedrake_1_1geometry_1_1optimization.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">drake::geometry::optimization Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_affine_ball.html">AffineBall</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements an ellipsoidal convex set represented as an affine scaling of the unit ball {Bu + center | |u|₂ ≤ 1}.  <a href="classdrake_1_1geometry_1_1optimization_1_1_affine_ball.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_affine_subspace.html">AffineSubspace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An affine subspace (also known as a "flat", a "linear variety", or a "linear
manifold") is a vector subspace of some Euclidean space, potentially translated so as to not pass through the origin.  <a href="classdrake_1_1geometry_1_1optimization_1_1_affine_subspace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html">CartesianProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Cartesian product of convex sets is a convex set: S = X₁ × X₂ × ⋯ × Xₙ = {(x₁, x₂, ..., xₙ) | x₁ ∈ X₁, x₂ ∈ X₂, ..., xₙ ∈ Xₙ}.  <a href="classdrake_1_1geometry_1_1optimization_1_1_cartesian_product.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_c_iris_collision_geometry.html">CIrisCollisionGeometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains the necessary information about the collision geometry used in C-IRIS.  <a href="classdrake_1_1geometry_1_1optimization_1_1_c_iris_collision_geometry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_hull.html">ConvexHull</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the convex hull of a set of convex sets.  <a href="classdrake_1_1geometry_1_1optimization_1_1_convex_hull.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for defining a convex set.  <a href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cspace_free_box.html">CspaceFreeBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class tries to find large axis-aligned bounding boxes in the configuration space, such that all configurations in the boxes are collision free.  <a href="classdrake_1_1geometry_1_1optimization_1_1_cspace_free_box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cspace_free_polytope.html">CspaceFreePolytope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class tries to find large convex polytopes in the tangential-configuration space, such that all configurations in the convex polytopes is collision free.  <a href="classdrake_1_1geometry_1_1optimization_1_1_cspace_free_polytope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cspace_free_polytope_base.html">CspaceFreePolytopeBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This virtual class is the base of <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cspace_free_polytope.html" title="This class tries to find large convex polytopes in the tangential-configuration space,...">CspaceFreePolytope</a> and <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_cspace_free_box.html" title="This class tries to find large axis-aligned bounding boxes in the configuration space,...">CspaceFreeBox</a>.  <a href="classdrake_1_1geometry_1_1optimization_1_1_cspace_free_polytope_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_c_space_separating_plane.html">CSpaceSeparatingPlane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the information that a pair of collision geometries are separated by a plane.  <a href="structdrake_1_1geometry_1_1optimization_1_1_c_space_separating_plane.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_find_separation_certificate_options.html">FindSeparationCertificateOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_gcs_graphviz_options.html">GcsGraphvizOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html">GraphOfConvexSets</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html" title="GraphOfConvexSets (GCS) implements the design pattern and optimization problems first introduced in t...">GraphOfConvexSets</a> (GCS) implements the design pattern and optimization problems first introduced in the paper "Shortest Paths in Graphs of Convex Sets".  <a href="classdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_graph_of_convex_sets_options.html">GraphOfConvexSetsOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">HPolyhedron</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a polyhedral convex set using the half-space representation: <code>{x| A x ≤ b}</code>.  <a href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_hyperellipsoid.html">Hyperellipsoid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements an ellipsoidal convex set represented by the quadratic form <code>{x | (x-center)ᵀAᵀA(x-center) ≤ 1}</code>.  <a href="classdrake_1_1geometry_1_1optimization_1_1_hyperellipsoid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_hyperrectangle.html">Hyperrectangle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Axis-aligned hyperrectangle in Rᵈ defined by its lower bounds and upper bounds as {x| lb ≤ x ≤ ub}.  <a href="classdrake_1_1geometry_1_1optimization_1_1_hyperrectangle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_implicit_graph_of_convex_sets.html">ImplicitGraphOfConvexSets</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class to define the interface to an implicit graph of convex sets.  <a href="classdrake_1_1geometry_1_1optimization_1_1_implicit_graph_of_convex_sets.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_implicit_graph_of_convex_sets_from_explicit.html">ImplicitGraphOfConvexSetsFromExplicit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an implicit GCS interface given an explicit GCS.  <a href="classdrake_1_1geometry_1_1optimization_1_1_implicit_graph_of_convex_sets_from_explicit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_intersection.html">Intersection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convex set that represents the intersection of multiple sets: S = X₁ ∩ X₂ ∩ ...  <a href="classdrake_1_1geometry_1_1optimization_1_1_intersection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">IrisOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration options for the IRIS algorithm.  <a href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_minkowski_sum.html">MinkowskiSum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convex set that represents the Minkowski sum of multiple sets: S = X₁ ⨁ X₂ ⨁ ...  <a href="classdrake_1_1geometry_1_1optimization_1_1_minkowski_sum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_plane_separates_geometries.html">PlaneSeparatesGeometries</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the information to enforce a pair of geometries are separated by a plane.  <a href="structdrake_1_1geometry_1_1optimization_1_1_plane_separates_geometries.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_point.html">Point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convex set that contains exactly one element.  <a href="classdrake_1_1geometry_1_1optimization_1_1_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_sampled_volume.html">SampledVolume</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of a volume calculation from CalcVolumeViaSampling().  <a href="structdrake_1_1geometry_1_1optimization_1_1_sampled_volume.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_separation_certificate_program_base.html">SeparationCertificateProgramBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_separation_certificate_result_base.html">SeparationCertificateResultBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">We certify that a pair of geometries is collision free by finding the separating plane over a range of configuration.  <a href="structdrake_1_1geometry_1_1optimization_1_1_separation_certificate_result_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_spectrahedron.html">Spectrahedron</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a spectrahedron (the feasible set of a semidefinite program).  <a href="classdrake_1_1geometry_1_1optimization_1_1_spectrahedron.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_v_polytope.html">VPolytope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A polytope described using the vertex representation.  <a href="classdrake_1_1geometry_1_1optimization_1_1_v_polytope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3c7f9b75df3ac22becb7bb5cb03bf956"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a></td></tr>
<tr class="memdesc:a3c7f9b75df3ac22becb7bb5cb03bf956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the recommended container for passing a collection of <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html" title="Abstract base class for defining a convex set.">ConvexSet</a> instances.  <a href="#a3c7f9b75df3ac22becb7bb5cb03bf956">More...</a><br /></td></tr>
<tr class="separator:a3c7f9b75df3ac22becb7bb5cb03bf956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10b0e0579060ac0afdf6344627ffabd2"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">HPolyhedron</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__planning__iris.html#ga10b0e0579060ac0afdf6344627ffabd2">IrisRegions</a></td></tr>
<tr class="memdesc:ga10b0e0579060ac0afdf6344627ffabd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a standardized representation for (named) IrisRegions, which can be serialized in both C++ and Python.  <a href="group__planning__iris.html#ga10b0e0579060ac0afdf6344627ffabd2">More...</a><br /></td></tr>
<tr class="separator:ga10b0e0579060ac0afdf6344627ffabd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a95690619e9b8d2e9047a607703cfbfff"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a95690619e9b8d2e9047a607703cfbfff">CIrisGeometryType</a> { <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a95690619e9b8d2e9047a607703cfbfffaf88bbd242f1721920aa0eb72a18767a4">kSphere</a>, 
<a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a95690619e9b8d2e9047a607703cfbfffa4373e4d7d76472e0fe9a1430bf5c9787">kPolytope</a>, 
<a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a95690619e9b8d2e9047a607703cfbfffacafcb896846646f8833912fdbfc5318e">kCylinder</a>, 
<a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a95690619e9b8d2e9047a607703cfbfffaaaccf255c56ba12dfb6ca40c34de64ef">kCapsule</a>
 }</td></tr>
<tr class="memdesc:a95690619e9b8d2e9047a607703cfbfff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The supported type of geometries in C-IRIS.  <a href="namespacedrake_1_1geometry_1_1optimization.html#a95690619e9b8d2e9047a607703cfbfff">More...</a><br /></td></tr>
<tr class="separator:a95690619e9b8d2e9047a607703cfbfff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4013454f1b2c236ff18e572d12436fef"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a4013454f1b2c236ff18e572d12436fef">PlaneSide</a> { <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a4013454f1b2c236ff18e572d12436fefafe449700ac27fbd09863263d74e7735f">kPositive</a>, 
<a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a4013454f1b2c236ff18e572d12436fefa25b105cbe0fd4622cdb36360c85e89c3">kNegative</a>
 }</td></tr>
<tr class="separator:a4013454f1b2c236ff18e572d12436fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6febb8c28b6d49e494dbe16b5ed5b089"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a6febb8c28b6d49e494dbe16b5ed5b089">SeparatingPlaneOrder</a> { <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a6febb8c28b6d49e494dbe16b5ed5b089ac3af1341756d0c5a66c8ea473dc38927">kAffine</a> = 1
 }</td></tr>
<tr class="memdesc:a6febb8c28b6d49e494dbe16b5ed5b089"><td class="mdescLeft">&#160;</td><td class="mdescRight">The separating plane aᵀx + b ≥ δ, aᵀx + b ≤ −δ has parameters a and b.  <a href="namespacedrake_1_1geometry_1_1optimization.html#a6febb8c28b6d49e494dbe16b5ed5b089">More...</a><br /></td></tr>
<tr class="separator:a6febb8c28b6d49e494dbe16b5ed5b089"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acb19d1d31dfa7158b5270096dac977a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#acb19d1d31dfa7158b5270096dac977a7">DistanceToHalfspace</a> (const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_c_iris_collision_geometry.html">CIrisCollisionGeometry</a> &amp;collision_geometry, const Eigen::Vector3d &amp;a, <a class="el" href="classdouble.html">double</a> b, <a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a> expressed_body, <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a4013454f1b2c236ff18e572d12436fef">PlaneSide</a> plane_side, const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">multibody::MultibodyPlant</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;plant, const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;plant_context)</td></tr>
<tr class="memdesc:acb19d1d31dfa7158b5270096dac977a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the signed distance from <code>collision_geometry</code> to the half space ℋ, where ℋ = {x | aᵀx+b &gt;= 0} if plane_side=<a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a4013454f1b2c236ff18e572d12436fefafe449700ac27fbd09863263d74e7735f">PlaneSide::kPositive</a>, and ℋ = {x | aᵀx+b &lt;= 0} if plane_side=<a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a4013454f1b2c236ff18e572d12436fefa25b105cbe0fd4622cdb36360c85e89c3">PlaneSide::kNegative</a>.  <a href="#acb19d1d31dfa7158b5270096dac977a7">More...</a><br /></td></tr>
<tr class="separator:acb19d1d31dfa7158b5270096dac977a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a3a5006f20615946f5b466fe9446b6"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ac9a3a5006f20615946f5b466fe9446b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#ac9a3a5006f20615946f5b466fe9446b6">MakeConvexSets</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac9a3a5006f20615946f5b466fe9446b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that allows the ConvexSets to be initialized from arguments containing <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html" title="Abstract base class for defining a convex set.">ConvexSet</a> references, or unique_ptr&lt;ConvexSet&gt; instances, or any object that can be assigned to ConvexSets::value_type.  <a href="#ac9a3a5006f20615946f5b466fe9446b6">More...</a><br /></td></tr>
<tr class="separator:ac9a3a5006f20615946f5b466fe9446b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1ae826ab17a7ccd2b08fab3222813d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a6febb8c28b6d49e494dbe16b5ed5b089">SeparatingPlaneOrder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a6d1ae826ab17a7ccd2b08fab3222813d">ToPlaneOrder</a> (<a class="el" href="classint.html">int</a> plane_degree)</td></tr>
<tr class="memdesc:a6d1ae826ab17a7ccd2b08fab3222813d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an integer degree to the SeparatingPlaneOrder.  <a href="#a6d1ae826ab17a7ccd2b08fab3222813d">More...</a><br /></td></tr>
<tr class="separator:a6d1ae826ab17a7ccd2b08fab3222813d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac176296e2c3b79a9f480c7a38b0842b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#ac176296e2c3b79a9f480c7a38b0842b0">ToPlaneDegree</a> (<a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a6febb8c28b6d49e494dbe16b5ed5b089">SeparatingPlaneOrder</a> plane_order)</td></tr>
<tr class="memdesc:ac176296e2c3b79a9f480c7a38b0842b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert SeparatingPlaneOrder to an integer degree.  <a href="#ac176296e2c3b79a9f480c7a38b0842b0">More...</a><br /></td></tr>
<tr class="separator:ac176296e2c3b79a9f480c7a38b0842b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6bfeb13bf4fc1924f61f81051d7561"><td class="memTemplParams" colspan="2">template&lt;typename D , typename S , typename V &gt; </td></tr>
<tr class="memitem:a0a6bfeb13bf4fc1924f61f81051d7561"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a0a6bfeb13bf4fc1924f61f81051d7561">CalcPlane</a> (const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; D &gt; &amp;decision_variables, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; S &gt; &amp;s_for_plane, <a class="el" href="classint.html">int</a> plane_degree, <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; V &gt; *a_val, V *b_val)</td></tr>
<tr class="memdesc:a0a6bfeb13bf4fc1924f61f81051d7561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the parameters a, b in the plane { x | aᵀx+b=0 }.  <a href="#a0a6bfeb13bf4fc1924f61f81051d7561">More...</a><br /></td></tr>
<tr class="separator:a0a6bfeb13bf4fc1924f61f81051d7561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05bd75c8b08787c334065792f8532797"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__geometry__optimization__geodesic__convexity.html#ga05bd75c8b08787c334065792f8532797">CheckIfSatisfiesConvexityRadius</a> (const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">geometry::optimization::ConvexSet</a> &amp;convex_set, const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;continuous_revolute_joints)</td></tr>
<tr class="memdesc:ga05bd75c8b08787c334065792f8532797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a convex set, and a list of indices corresponding to continuous revolute joints, checks whether or not the set satisfies the convexity radius.  <a href="group__geometry__optimization__geodesic__convexity.html#ga05bd75c8b08787c334065792f8532797">More...</a><br /></td></tr>
<tr class="separator:ga05bd75c8b08787c334065792f8532797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f945f0d43e169b238695da629d93ff7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">geometry::optimization::ConvexSets</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__geometry__optimization__geodesic__convexity.html#ga0f945f0d43e169b238695da629d93ff7">PartitionConvexSet</a> (const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">geometry::optimization::ConvexSet</a> &amp;convex_set, const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;continuous_revolute_joints, const <a class="el" href="classdouble.html">double</a> epsilon=1e-5)</td></tr>
<tr class="memdesc:ga0f945f0d43e169b238695da629d93ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions a convex set into (smaller) convex sets whose union is the original set and that each respect the convexity radius as in CheckIfSatisfiesConvexityRadius.  <a href="group__geometry__optimization__geodesic__convexity.html#ga0f945f0d43e169b238695da629d93ff7">More...</a><br /></td></tr>
<tr class="separator:ga0f945f0d43e169b238695da629d93ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeab8ca89c6e95c43cf9ec8c6284f395f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">geometry::optimization::ConvexSets</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__geometry__optimization__geodesic__convexity.html#gaeab8ca89c6e95c43cf9ec8c6284f395f">PartitionConvexSet</a> (const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">geometry::optimization::ConvexSets</a> &amp;convex_sets, const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;continuous_revolute_joints, const <a class="el" href="classdouble.html">double</a> epsilon=1e-5)</td></tr>
<tr class="memdesc:gaeab8ca89c6e95c43cf9ec8c6284f395f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function overload to take in a list of convex sets, and partition all so as to respect the convexity radius.  <a href="group__geometry__optimization__geodesic__convexity.html#gaeab8ca89c6e95c43cf9ec8c6284f395f">More...</a><br /></td></tr>
<tr class="separator:gaeab8ca89c6e95c43cf9ec8c6284f395f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e109ef92fec8f68a785b2edbd380021"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::pair&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a> &gt; &gt;, std::vector&lt; Eigen::VectorXd &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__geometry__optimization__geodesic__convexity.html#ga2e109ef92fec8f68a785b2edbd380021">ComputePairwiseIntersections</a> (const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;convex_sets_A, const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;convex_sets_B, const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;continuous_revolute_joints, bool preprocess_bbox=true, <a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a> parallelism=<a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>())</td></tr>
<tr class="memdesc:ga2e109ef92fec8f68a785b2edbd380021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the pairwise intersections between two lists of convex sets, returning a list of edges, and a list of their corresponding offsets.  <a href="group__geometry__optimization__geodesic__convexity.html#ga2e109ef92fec8f68a785b2edbd380021">More...</a><br /></td></tr>
<tr class="separator:ga2e109ef92fec8f68a785b2edbd380021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33ea6cefa0958e76eb228ecab2bbeba5"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::pair&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a> &gt; &gt;, std::vector&lt; Eigen::VectorXd &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__geometry__optimization__geodesic__convexity.html#ga33ea6cefa0958e76eb228ecab2bbeba5">ComputePairwiseIntersections</a> (const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;convex_sets_A, const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;convex_sets_B, const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;continuous_revolute_joints, const std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_hyperrectangle.html">geometry::optimization::Hyperrectangle</a> &gt; &amp;bboxes_A, const std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_hyperrectangle.html">geometry::optimization::Hyperrectangle</a> &gt; &amp;bboxes_B, <a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a> parallelism=<a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>())</td></tr>
<tr class="memdesc:ga33ea6cefa0958e76eb228ecab2bbeba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code>ComputePairwiseIntersections</code> allowing the user to supply axis- aligned bounding boxes if they're known a priori, to save on computation time.  <a href="group__geometry__optimization__geodesic__convexity.html#ga33ea6cefa0958e76eb228ecab2bbeba5">More...</a><br /></td></tr>
<tr class="separator:ga33ea6cefa0958e76eb228ecab2bbeba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c6d3fc1c7396ee8eee575958044071b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::pair&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a> &gt; &gt;, std::vector&lt; Eigen::VectorXd &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__geometry__optimization__geodesic__convexity.html#ga1c6d3fc1c7396ee8eee575958044071b">ComputePairwiseIntersections</a> (const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;convex_sets, const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;continuous_revolute_joints, bool preprocess_bbox=true, <a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a> parallelism=<a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>())</td></tr>
<tr class="memdesc:ga1c6d3fc1c7396ee8eee575958044071b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience overload to compute pairwise intersections within a list of convex sets.  <a href="group__geometry__optimization__geodesic__convexity.html#ga1c6d3fc1c7396ee8eee575958044071b">More...</a><br /></td></tr>
<tr class="separator:ga1c6d3fc1c7396ee8eee575958044071b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60002c174b2106139e2b219a0e0fb3f0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::pair&lt; <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a> &gt; &gt;, std::vector&lt; Eigen::VectorXd &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__geometry__optimization__geodesic__convexity.html#ga60002c174b2106139e2b219a0e0fb3f0">ComputePairwiseIntersections</a> (const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;convex_sets, const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;continuous_revolute_joints, const std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_hyperrectangle.html">geometry::optimization::Hyperrectangle</a> &gt; &amp;bboxes, <a class="el" href="classdrake_1_1_parallelism.html">Parallelism</a> parallelism=<a class="el" href="classdrake_1_1_parallelism.html#a5f5d962dfeec6e675996074f913df819">Parallelism::Max</a>())</td></tr>
<tr class="memdesc:ga60002c174b2106139e2b219a0e0fb3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code>ComputePairwiseIntersections</code> allowing the user to supply axis- aligned bounding boxes if they're known a priori, to save on computation time.  <a href="group__geometry__optimization__geodesic__convexity.html#ga60002c174b2106139e2b219a0e0fb3f0">More...</a><br /></td></tr>
<tr class="separator:ga60002c174b2106139e2b219a0e0fb3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd8111a93cb3461e05bec3477ee736f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">HPolyhedron</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__planning__iris.html#gafd8111a93cb3461e05bec3477ee736f6">Iris</a> (const <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> &amp;obstacles, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;sample, const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">HPolyhedron</a> &amp;domain, const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">IrisOptions</a> &amp;options=<a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">IrisOptions</a>())</td></tr>
<tr class="memdesc:gafd8111a93cb3461e05bec3477ee736f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The IRIS (Iterative Region Inflation by Semidefinite programming) algorithm, as described in.  <a href="group__planning__iris.html#gafd8111a93cb3461e05bec3477ee736f6">More...</a><br /></td></tr>
<tr class="separator:gafd8111a93cb3461e05bec3477ee736f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad54a224f37c1a0dc86eaec300ef874af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__planning__iris.html#gad54a224f37c1a0dc86eaec300ef874af">MakeIrisObstacles</a> (const <a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;query_object, std::optional&lt; <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> &gt; reference_frame=std::nullopt)</td></tr>
<tr class="memdesc:gad54a224f37c1a0dc86eaec300ef874af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html" title="Abstract base class for defining a convex set.">ConvexSet</a> representations of obstacles for IRIS in 3D using the geometry from a <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> <a class="el" href="classdrake_1_1geometry_1_1_query_object.html" title="The QueryObject serves as a mechanism to perform geometry queries on the world&#39;s geometry.">QueryObject</a>.  <a href="group__planning__iris.html#gad54a224f37c1a0dc86eaec300ef874af">More...</a><br /></td></tr>
<tr class="separator:gad54a224f37c1a0dc86eaec300ef874af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a3a8f2dcb01cc40c95f4e3afe7fed01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">HPolyhedron</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__planning__iris.html#ga3a3a8f2dcb01cc40c95f4e3afe7fed01">IrisNp</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">multibody::MultibodyPlant</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;plant, const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;context, const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">IrisOptions</a> &amp;options=<a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">IrisOptions</a>())</td></tr>
<tr class="memdesc:ga3a3a8f2dcb01cc40c95f4e3afe7fed01"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variation of the Iris (Iterative Region Inflation by Semidefinite programming) algorithm which finds collision-free regions in the <em>configuration space</em> of <code>plant</code>.  <a href="group__planning__iris.html#ga3a3a8f2dcb01cc40c95f4e3afe7fed01">More...</a><br /></td></tr>
<tr class="separator:ga3a3a8f2dcb01cc40c95f4e3afe7fed01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a51e0fec449a0abcf498f78a2a390a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">HPolyhedron</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3a51e0fec449a0abcf498f78a2a390a8">IrisInConfigurationSpace</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">multibody::MultibodyPlant</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;plant, const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;context, const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">IrisOptions</a> &amp;options=<a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">IrisOptions</a>())</td></tr>
<tr class="memdesc:a3a51e0fec449a0abcf498f78a2a390a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.)  <a href="#a3a51e0fec449a0abcf498f78a2a390a8">More...</a><br /></td></tr>
<tr class="separator:a3a51e0fec449a0abcf498f78a2a390a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f3ad49bfffd1b9a968ed7f1bf4d4c80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__planning__iris.html#ga5f3ad49bfffd1b9a968ed7f1bf4d4c80">SetEdgeContainmentTerminationCondition</a> (<a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">IrisOptions</a> *iris_options, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;x_1, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;x_2, const <a class="el" href="classdouble.html">double</a> epsilon=1e-3, const double tol=1e-6)</td></tr>
<tr class="memdesc:ga5f3ad49bfffd1b9a968ed7f1bf4d4c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the <code>iris_options</code> to facilitate finding a region that contains the edge between x_1 and x_2.  <a href="group__planning__iris.html#ga5f3ad49bfffd1b9a968ed7f1bf4d4c80">More...</a><br /></td></tr>
<tr class="separator:ga5f3ad49bfffd1b9a968ed7f1bf4d4c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6616542d5536b0f2522beb473f437a06"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a6616542d5536b0f2522beb473f437a06">GetVertices</a> (const <a class="el" href="classdrake_1_1geometry_1_1_convex.html">Convex</a> &amp;convex)</td></tr>
<tr class="memdesc:a6616542d5536b0f2522beb473f437a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains all the vertices stored in the convex object.  <a href="#a6616542d5536b0f2522beb473f437a06">More...</a><br /></td></tr>
<tr class="separator:a6616542d5536b0f2522beb473f437a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a3c7f9b75df3ac22becb7bb5cb03bf956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7f9b75df3ac22becb7bb5cb03bf956">&#9670;&nbsp;</a></span>ConvexSets</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt;<a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html">ConvexSet</a>&gt; &gt; <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the recommended container for passing a collection of <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html" title="Abstract base class for defining a convex set.">ConvexSet</a> instances. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a95690619e9b8d2e9047a607703cfbfff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95690619e9b8d2e9047a607703cfbfff">&#9670;&nbsp;</a></span>CIrisGeometryType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a95690619e9b8d2e9047a607703cfbfff">CIrisGeometryType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The supported type of geometries in C-IRIS. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a95690619e9b8d2e9047a607703cfbfffaf88bbd242f1721920aa0eb72a18767a4"></a>kSphere&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a95690619e9b8d2e9047a607703cfbfffa4373e4d7d76472e0fe9a1430bf5c9787"></a>kPolytope&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a95690619e9b8d2e9047a607703cfbfffacafcb896846646f8833912fdbfc5318e"></a>kCylinder&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a95690619e9b8d2e9047a607703cfbfffaaaccf255c56ba12dfb6ca40c34de64ef"></a>kCapsule&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a4013454f1b2c236ff18e572d12436fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4013454f1b2c236ff18e572d12436fef">&#9670;&nbsp;</a></span>PlaneSide</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a4013454f1b2c236ff18e572d12436fef">PlaneSide</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4013454f1b2c236ff18e572d12436fefafe449700ac27fbd09863263d74e7735f"></a>kPositive&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4013454f1b2c236ff18e572d12436fefa25b105cbe0fd4622cdb36360c85e89c3"></a>kNegative&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a6febb8c28b6d49e494dbe16b5ed5b089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6febb8c28b6d49e494dbe16b5ed5b089">&#9670;&nbsp;</a></span>SeparatingPlaneOrder</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a6febb8c28b6d49e494dbe16b5ed5b089">SeparatingPlaneOrder</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The separating plane aᵀx + b ≥ δ, aᵀx + b ≤ −δ has parameters a and b. </p>
<p>These parameterize a polynomial function of <code>s_for_plane</code> with the specified order. <code>s_for_plane</code> is a sub set of the configuration-space variable <code>s</code>, please refer to the RationalForwardKinematics class or the paper above on the meaning of s. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6febb8c28b6d49e494dbe16b5ed5b089ac3af1341756d0c5a66c8ea473dc38927"></a>kAffine&#160;</td><td class="fielddoc"><p>a and b are affine functions of s. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0a6bfeb13bf4fc1924f61f81051d7561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6bfeb13bf4fc1924f61f81051d7561">&#9670;&nbsp;</a></span>CalcPlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::geometry::optimization::CalcPlane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; D &gt; &amp;&#160;</td>
          <td class="paramname"><em>decision_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; S &gt; &amp;&#160;</td>
          <td class="paramname"><em>s_for_plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>plane_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; V &gt; *&#160;</td>
          <td class="paramname"><em>a_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V *&#160;</td>
          <td class="paramname"><em>b_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the parameters a, b in the plane { x | aᵀx+b=0 }. </p>
<p>a and b are both polynomials of <code>vars_for_plane</code>. The coefficients of these polynomials are in <code>decision_variables</code> in graded reverse lexicographic order.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">D,S,V</td><td>The valid combination of D, S, V are<ol type="1">
<li>D=<a class="el" href="classdrake_1_1symbolic_1_1_variable.html" title="Represents a symbolic variable.">symbolic::Variable</a>, S=<a class="el" href="classdrake_1_1symbolic_1_1_variable.html" title="Represents a symbolic variable.">symbolic::Variable</a>, V=<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html" title="Represents symbolic polynomials.">symbolic::Polynomial</a>.</li>
<li>D=double, S=<a class="el" href="classdrake_1_1symbolic_1_1_variable.html" title="Represents a symbolic variable.">symbolic::Variable</a>, V=<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html" title="Represents symbolic polynomials.">symbolic::Polynomial</a></li>
<li>D=double, S=double, V=double </li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb19d1d31dfa7158b5270096dac977a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb19d1d31dfa7158b5270096dac977a7">&#9670;&nbsp;</a></span>DistanceToHalfspace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> drake::geometry::optimization::DistanceToHalfspace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_c_iris_collision_geometry.html">CIrisCollisionGeometry</a> &amp;&#160;</td>
          <td class="paramname"><em>collision_geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a02d233e6f0ef016f5cf02e2222a22f5c">multibody::BodyIndex</a>&#160;</td>
          <td class="paramname"><em>expressed_body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a4013454f1b2c236ff18e572d12436fef">PlaneSide</a>&#160;</td>
          <td class="paramname"><em>plane_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">multibody::MultibodyPlant</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>plant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>plant_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the signed distance from <code>collision_geometry</code> to the half space ℋ, where ℋ = {x | aᵀx+b &gt;= 0} if plane_side=<a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a4013454f1b2c236ff18e572d12436fefafe449700ac27fbd09863263d74e7735f">PlaneSide::kPositive</a>, and ℋ = {x | aᵀx+b &lt;= 0} if plane_side=<a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a4013454f1b2c236ff18e572d12436fefa25b105cbe0fd4622cdb36360c85e89c3">PlaneSide::kNegative</a>. </p>
<p>The half space is measured and expressed in the expressed_body's body frame. This works for both <code>collision_geometry</code> separated from the half space, and <code>collision geometry</code> in penetration with the halfspace. </p><dl class="section note"><dt>Note</dt><dd><code>a</code> does not need to be a unit length vector (but should be non-zero). </dd></dl>

</div>
</div>
<a id="a6616542d5536b0f2522beb473f437a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6616542d5536b0f2522beb473f437a06">&#9670;&nbsp;</a></span>GetVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd drake::geometry::optimization::GetVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_convex.html">Convex</a> &amp;&#160;</td>
          <td class="paramname"><em>convex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains all the vertices stored in the convex object. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">vertices.</td><td>Each column of <code>vertices</code> is a vertex. We don't impose any specific order on the vertices. The vertices are expressed in the convex shape's own frame. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a51e0fec449a0abcf498f78a2a390a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a51e0fec449a0abcf498f78a2a390a8">&#9670;&nbsp;</a></span>IrisInConfigurationSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_h_polyhedron.html">HPolyhedron</a> drake::geometry::optimization::IrisInConfigurationSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">multibody::MultibodyPlant</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>plant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">IrisOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structdrake_1_1geometry_1_1optimization_1_1_iris_options.html">IrisOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Use IrisNp instead. <br />
 This will be removed from Drake on or after 2025-12-01.</dd></dl>

</div>
</div>
<a id="ac9a3a5006f20615946f5b466fe9446b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a3a5006f20615946f5b466fe9446b6">&#9670;&nbsp;</a></span>MakeConvexSets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a3c7f9b75df3ac22becb7bb5cb03bf956">ConvexSets</a> drake::geometry::optimization::MakeConvexSets </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function that allows the ConvexSets to be initialized from arguments containing <a class="el" href="classdrake_1_1geometry_1_1optimization_1_1_convex_set.html" title="Abstract base class for defining a convex set.">ConvexSet</a> references, or unique_ptr&lt;ConvexSet&gt; instances, or any object that can be assigned to ConvexSets::value_type. </p>

</div>
</div>
<a id="ac176296e2c3b79a9f480c7a38b0842b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac176296e2c3b79a9f480c7a38b0842b0">&#9670;&nbsp;</a></span>ToPlaneDegree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> drake::geometry::optimization::ToPlaneDegree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a6febb8c28b6d49e494dbe16b5ed5b089">SeparatingPlaneOrder</a>&#160;</td>
          <td class="paramname"><em>plane_order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert SeparatingPlaneOrder to an integer degree. </p>

</div>
</div>
<a id="a6d1ae826ab17a7ccd2b08fab3222813d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1ae826ab17a7ccd2b08fab3222813d">&#9670;&nbsp;</a></span>ToPlaneOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html#a6febb8c28b6d49e494dbe16b5ed5b089">SeparatingPlaneOrder</a> drake::geometry::optimization::ToPlaneOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>plane_degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an integer degree to the SeparatingPlaneOrder. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1geometry.html">geometry</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1geometry_1_1optimization.html">optimization</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().value = searchBox.searchLabel;
</script>
</body>
</html>
