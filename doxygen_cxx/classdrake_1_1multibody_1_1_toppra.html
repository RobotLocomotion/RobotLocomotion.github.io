<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: Toppra Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 </div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1multibody_1_1_toppra.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classdrake_1_1multibody_1_1_toppra-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Toppra Class Reference<div class="ingroups"><a class="el" href="group__algorithms.html">Algorithms</a> &raquo; <a class="el" href="group__planning.html">Planning</a> &raquo; <a class="el" href="group__planning__trajectory.html">Trajectories</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Solves a Time Optimal Path Parameterization based on Reachability Analysis (TOPPRA) to find the fastest traversal of a given path, satisfying the given constraints. </p>
<p>The approach is described in "A new approach to Time-Optimal Path
Parameterization based on Reachability Analysis" by Hung Pham and Quang Cuong Pham, IEEE Transactions on Robotics, 2018. </p>
</div>
<p><code>#include &lt;drake/multibody/optimization/toppra.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9024708d5314cf3655e2b72c5c138a39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html#a9024708d5314cf3655e2b72c5c138a39">~Toppra</a> ()</td></tr>
<tr class="separator:a9024708d5314cf3655e2b72c5c138a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9fc9da3b84296fbc0292963ecffb699"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html#ac9fc9da3b84296fbc0292963ecffb699">Toppra</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html">Trajectory</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;path, const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;plant, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;gridpoints)</td></tr>
<tr class="memdesc:ac9fc9da3b84296fbc0292963ecffb699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an inverse kinematics problem for a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>.  <a href="#ac9fc9da3b84296fbc0292963ecffb699">More...</a><br /></td></tr>
<tr class="separator:ac9fc9da3b84296fbc0292963ecffb699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ae71e801a2c27f272cf1493aaa82df"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html#a71ae71e801a2c27f272cf1493aaa82df">SolvePathParameterization</a> (<a class="el" href="classdouble.html">double</a> s_dot_start=0, <a class="el" href="classdouble.html">double</a> s_dot_end=0)</td></tr>
<tr class="memdesc:a71ae71e801a2c27f272cf1493aaa82df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the TOPPRA optimization and returns the time optimized path parameterization s(t).  <a href="#a71ae71e801a2c27f272cf1493aaa82df">More...</a><br /></td></tr>
<tr class="separator:a71ae71e801a2c27f272cf1493aaa82df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6404ed212fab2af0bad98457df07d16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html#aa6404ed212fab2af0bad98457df07d16">AddJointVelocityLimit</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lower_limit, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;upper_limit)</td></tr>
<tr class="memdesc:aa6404ed212fab2af0bad98457df07d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a velocity limit to all the degrees of freedom in the plant.  <a href="#aa6404ed212fab2af0bad98457df07d16">More...</a><br /></td></tr>
<tr class="separator:aa6404ed212fab2af0bad98457df07d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68128c4e24b7fb5ced993cc55f2453a6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html#a68128c4e24b7fb5ced993cc55f2453a6">AddJointAccelerationLimit</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lower_limit, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;upper_limit, <a class="el" href="namespacedrake_1_1multibody.html#ad8fa828762d54ed2db5efec5df1b5082">ToppraDiscretization</a> discretization=<a class="el" href="namespacedrake_1_1multibody.html#ad8fa828762d54ed2db5efec5df1b5082a9ef15c126044c94d6440bfbf02f6c55d">ToppraDiscretization::kInterpolation</a>)</td></tr>
<tr class="memdesc:a68128c4e24b7fb5ced993cc55f2453a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an acceleration limit to all the degrees of freedom in the plant.  <a href="#a68128c4e24b7fb5ced993cc55f2453a6">More...</a><br /></td></tr>
<tr class="separator:a68128c4e24b7fb5ced993cc55f2453a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e3c0664e1e847c82fb7a4eee9374cc"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html#a34e3c0664e1e847c82fb7a4eee9374cc">AddJointTorqueLimit</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;lower_limit, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;upper_limit, <a class="el" href="namespacedrake_1_1multibody.html#ad8fa828762d54ed2db5efec5df1b5082">ToppraDiscretization</a> discretization=<a class="el" href="namespacedrake_1_1multibody.html#ad8fa828762d54ed2db5efec5df1b5082a9ef15c126044c94d6440bfbf02f6c55d">ToppraDiscretization::kInterpolation</a>)</td></tr>
<tr class="memdesc:a34e3c0664e1e847c82fb7a4eee9374cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a torque limit to all the degrees of freedom in the plant.  <a href="#a34e3c0664e1e847c82fb7a4eee9374cc">More...</a><br /></td></tr>
<tr class="separator:a34e3c0664e1e847c82fb7a4eee9374cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b61c91e6284f5a884080aa045c8acd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html#a49b61c91e6284f5a884080aa045c8acd">AddFrameVelocityLimit</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraint_frame, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a44f103cf5fdeb3f539ceeeb9cd3a0a28">Vector6d</a> &gt; &amp;lower_limit, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a44f103cf5fdeb3f539ceeeb9cd3a0a28">Vector6d</a> &gt; &amp;upper_limit)</td></tr>
<tr class="memdesc:a49b61c91e6284f5a884080aa045c8acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a limit on the elements of the spatial velocity of the given frame, measured and and expressed in the world frame.  <a href="#a49b61c91e6284f5a884080aa045c8acd">More...</a><br /></td></tr>
<tr class="separator:a49b61c91e6284f5a884080aa045c8acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cee3da4435b14492b675df2a473f611"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html#a5cee3da4435b14492b675df2a473f611">AddFrameTranslationalSpeedLimit</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraint_frame, const <a class="el" href="classdouble.html">double</a> &amp;upper_limit)</td></tr>
<tr class="memdesc:a5cee3da4435b14492b675df2a473f611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a limit on the magnitude of the translational velocity of the given frame, measured and expressed in the world frame.  <a href="#a5cee3da4435b14492b675df2a473f611">More...</a><br /></td></tr>
<tr class="separator:a5cee3da4435b14492b675df2a473f611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe29e25bfa2111f89d91c19a71d618b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html#afe29e25bfa2111f89d91c19a71d618b7">AddFrameTranslationalSpeedLimit</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraint_frame, const <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html">Trajectory</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;upper_limit)</td></tr>
<tr class="memdesc:afe29e25bfa2111f89d91c19a71d618b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version of the frame translational speed limit that uses a trajectory for the limit.  <a href="#afe29e25bfa2111f89d91c19a71d618b7">More...</a><br /></td></tr>
<tr class="separator:afe29e25bfa2111f89d91c19a71d618b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4439ae2c06e737634078434d897cceaf"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html#a4439ae2c06e737634078434d897cceaf">AddFrameAccelerationLimit</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraint_frame, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a44f103cf5fdeb3f539ceeeb9cd3a0a28">Vector6d</a> &gt; &amp;lower_limit, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a44f103cf5fdeb3f539ceeeb9cd3a0a28">Vector6d</a> &gt; &amp;upper_limit, <a class="el" href="namespacedrake_1_1multibody.html#ad8fa828762d54ed2db5efec5df1b5082">ToppraDiscretization</a> discretization=<a class="el" href="namespacedrake_1_1multibody.html#ad8fa828762d54ed2db5efec5df1b5082a9ef15c126044c94d6440bfbf02f6c55d">ToppraDiscretization::kInterpolation</a>)</td></tr>
<tr class="memdesc:a4439ae2c06e737634078434d897cceaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a limit on the elements of the spatial acceleration of the given frame, measured and expressed in the world frame.  <a href="#a4439ae2c06e737634078434d897cceaf">More...</a><br /></td></tr>
<tr class="separator:a4439ae2c06e737634078434d897cceaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24c8bc5987857a75965a6ffeee1c573"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html#af24c8bc5987857a75965a6ffeee1c573">AddFrameAccelerationLimit</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraint_frame, const <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html">Trajectory</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;lower_limit, const <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html">Trajectory</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;upper_limit, <a class="el" href="namespacedrake_1_1multibody.html#ad8fa828762d54ed2db5efec5df1b5082">ToppraDiscretization</a> discretization=<a class="el" href="namespacedrake_1_1multibody.html#ad8fa828762d54ed2db5efec5df1b5082a9ef15c126044c94d6440bfbf02f6c55d">ToppraDiscretization::kInterpolation</a>)</td></tr>
<tr class="memdesc:af24c8bc5987857a75965a6ffeee1c573"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version of acceleration limit that uses a trajectory for the upper and lower limits.  <a href="#af24c8bc5987857a75965a6ffeee1c573">More...</a><br /></td></tr>
<tr class="separator:af24c8bc5987857a75965a6ffeee1c573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:ac6962da0cfeb19c216cf5920469e7926"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html#ac6962da0cfeb19c216cf5920469e7926">Toppra</a> (const <a class="el" href="classdrake_1_1multibody_1_1_toppra.html">Toppra</a> &amp;)=delete</td></tr>
<tr class="separator:ac6962da0cfeb19c216cf5920469e7926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab013d8e5872653e5d10eaae0f3daa3dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html">Toppra</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html#ab013d8e5872653e5d10eaae0f3daa3dc">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_toppra.html">Toppra</a> &amp;)=delete</td></tr>
<tr class="separator:ab013d8e5872653e5d10eaae0f3daa3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7ffb0f0acced8a28daa7bb2758f2f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html#a3a7ffb0f0acced8a28daa7bb2758f2f2">Toppra</a> (<a class="el" href="classdrake_1_1multibody_1_1_toppra.html">Toppra</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a3a7ffb0f0acced8a28daa7bb2758f2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c0c591fef12ba0135b9576f4344974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html">Toppra</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html#a57c0c591fef12ba0135b9576f4344974">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1_toppra.html">Toppra</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a57c0c591fef12ba0135b9576f4344974"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac05332bb6e89f996e9501a52af6e307f"><td class="memItemLeft" align="right" valign="top">static Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html#ac05332bb6e89f996e9501a52af6e307f">CalcGridPoints</a> (const <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html">Trajectory</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;path, const <a class="el" href="structdrake_1_1multibody_1_1_calc_grid_points_options.html">CalcGridPointsOptions</a> &amp;options)</td></tr>
<tr class="memdesc:ac05332bb6e89f996e9501a52af6e307f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a path and generates a sequence of gridpoints selected to control the interpolation error of the optimization.  <a href="#ac05332bb6e89f996e9501a52af6e307f">More...</a><br /></td></tr>
<tr class="separator:ac05332bb6e89f996e9501a52af6e307f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac6962da0cfeb19c216cf5920469e7926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6962da0cfeb19c216cf5920469e7926">&#9670;&nbsp;</a></span>Toppra() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html">Toppra</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_toppra.html">Toppra</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a7ffb0f0acced8a28daa7bb2758f2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7ffb0f0acced8a28daa7bb2758f2f2">&#9670;&nbsp;</a></span>Toppra() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html">Toppra</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html">Toppra</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9024708d5314cf3655e2b72c5c138a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9024708d5314cf3655e2b72c5c138a39">&#9670;&nbsp;</a></span>~Toppra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classdrake_1_1multibody_1_1_toppra.html">Toppra</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9fc9da3b84296fbc0292963ecffb699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9fc9da3b84296fbc0292963ecffb699">&#9670;&nbsp;</a></span>Toppra() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html">Toppra</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html">Trajectory</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>plant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>gridpoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an inverse kinematics problem for a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>. </p>
<p>This constructor will create and own a context for</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plant.</td><td></td></tr>
    <tr><td class="paramname">path</td><td>The trajectory on which the TOPPRA problem will be solved. </td></tr>
    <tr><td class="paramname">plant</td><td>The robot that will follow the solved trajectory. Used for enforcing torque and frame specific constraints. </td></tr>
    <tr><td class="paramname">gridpoints</td><td>The points along the path to discretize the problem and enforce constraints at. The first and last gridpoint must equal the path start and end time respectively. Gridpoints must also be monotonically increasing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_toppra.html" title="Solves a Time Optimal Path Parameterization based on Reachability Analysis (TOPPRA) to find the faste...">Toppra</a> does not currently support plants that contain bodies with quaternion degrees of freedom. In addition, any plant where q̇ ≠ v will have undefined behavior. </dd>
<dd>
The path velocity, ṡ(t), is limited to be between 0 and 1e8 to ensure the reachable set calculated in the backward pass is always bounded. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4439ae2c06e737634078434d897cceaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4439ae2c06e737634078434d897cceaf">&#9670;&nbsp;</a></span>AddFrameAccelerationLimit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt;, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; &gt; AddFrameAccelerationLimit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a44f103cf5fdeb3f539ceeeb9cd3a0a28">Vector6d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a44f103cf5fdeb3f539ceeeb9cd3a0a28">Vector6d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#ad8fa828762d54ed2db5efec5df1b5082">ToppraDiscretization</a>&#160;</td>
          <td class="paramname"><em>discretization</em> = <code><a class="el" href="namespacedrake_1_1multibody.html#ad8fa828762d54ed2db5efec5df1b5082a9ef15c126044c94d6440bfbf02f6c55d">ToppraDiscretization::kInterpolation</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a limit on the elements of the spatial acceleration of the given frame, measured and expressed in the world frame. </p>
<p>The limits should be given as [α_WF, a_WF], where α_WF is the frame's angular acceleration and a_WF is the frame's translational acceleration. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraint_frame</td><td>The frame to limit the acceleration of. </td></tr>
    <tr><td class="paramname">lower_limit</td><td>The lower acceleration limit for constraint_frame. </td></tr>
    <tr><td class="paramname">upper_limit</td><td>The upper acceleration limit for constraint_frame. </td></tr>
    <tr><td class="paramname">discretization</td><td>The discretization scheme to use for this linear constraint. See ToppraDiscretization for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair containing the linear constraints that will enforce the frame acceleration limit on the backward pass and forward pass respectively. </dd></dl>

</div>
</div>
<a id="af24c8bc5987857a75965a6ffeee1c573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24c8bc5987857a75965a6ffeee1c573">&#9670;&nbsp;</a></span>AddFrameAccelerationLimit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt;, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; &gt; AddFrameAccelerationLimit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html">Trajectory</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html">Trajectory</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#ad8fa828762d54ed2db5efec5df1b5082">ToppraDiscretization</a>&#160;</td>
          <td class="paramname"><em>discretization</em> = <code><a class="el" href="namespacedrake_1_1multibody.html#ad8fa828762d54ed2db5efec5df1b5082a9ef15c126044c94d6440bfbf02f6c55d">ToppraDiscretization::kInterpolation</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A version of acceleration limit that uses a trajectory for the upper and lower limits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraint_frame</td><td>The frame to limit the acceleration of. </td></tr>
    <tr><td class="paramname">lower_limit</td><td>The lower acceleration limit trajectory for constraint_frame. </td></tr>
    <tr><td class="paramname">upper_limit</td><td>The upper acceleration limit trajectory for constraint_frame. </td></tr>
    <tr><td class="paramname">discretization</td><td>The discretization scheme to use for this linear constraint. See ToppraDiscretization for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair containing the linear constraints that will enforce the frame acceleration limit on the backward pass and forward pass respectively. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Both lower_limit and upper_limit trajectories must have values in ℜ⁶. The six-dimensional column vector is interpreted as [α_WF, a_WF], where α_WF is the frame's angular acceleration and a_WF is the frame's translational acceleration. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the intervals [upper_limit.start_time(), upper_limit.end_time()] and [lower_limit.start_time(), lower_limit.end_time()] don't overlap with [path.start_time(), path.end_time()]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The constraints are only added in the constraint trajectories domains (where they overlap the path). The rest of the path is <em>not</em> constrained. </dd></dl>

</div>
</div>
<a id="a5cee3da4435b14492b675df2a473f611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cee3da4435b14492b675df2a473f611">&#9670;&nbsp;</a></span>AddFrameTranslationalSpeedLimit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a>&gt; AddFrameTranslationalSpeedLimit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>upper_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a limit on the magnitude of the translational velocity of the given frame, measured and expressed in the world frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraint_frame</td><td>The frame to limit the translational speed of. </td></tr>
    <tr><td class="paramname">upper_limit</td><td>The upper translational speed limit for constraint_frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bounding box constraint that will enforce the frame translational speed limit during the backward pass. </dd></dl>

</div>
</div>
<a id="afe29e25bfa2111f89d91c19a71d618b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe29e25bfa2111f89d91c19a71d618b7">&#9670;&nbsp;</a></span>AddFrameTranslationalSpeedLimit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a>&gt; AddFrameTranslationalSpeedLimit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html">Trajectory</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A version of the frame translational speed limit that uses a trajectory for the limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraint_frame</td><td>The frame to limit the translational speed of. </td></tr>
    <tr><td class="paramname">upper_limit</td><td>The upper translational speed limit trajectory for constraint_frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>upper_limit must have scalar values (a 1x1 matrix). </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The bounding box constraint that will enforce the frame translational speed limit during the backward pass. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the interval [upper_limit.start_time(), upper_limit.end_time()] doesn't overlap with [path.start_time(), path.end_time()]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The constraints are only added between upper_limit.start_time() and upper_limit.end_time(). The rest of the path is <em>not</em> constrained. </dd></dl>

</div>
</div>
<a id="a49b61c91e6284f5a884080aa045c8acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b61c91e6284f5a884080aa045c8acd">&#9670;&nbsp;</a></span>AddFrameVelocityLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a>&gt; AddFrameVelocityLimit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a44f103cf5fdeb3f539ceeeb9cd3a0a28">Vector6d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a44f103cf5fdeb3f539ceeeb9cd3a0a28">Vector6d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a limit on the elements of the spatial velocity of the given frame, measured and and expressed in the world frame. </p>
<p>The limits should be given as [ω_WF, v_WF], where ω_WF is the frame's angular velocity and v_WF is the frame's translational velocity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraint_frame</td><td>The frame to limit the velocity of. </td></tr>
    <tr><td class="paramname">lower_limit</td><td>The lower velocity limit for constraint_frame. </td></tr>
    <tr><td class="paramname">upper_limit</td><td>The upper velocity limit for constraint_frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bounding box constraint that will enforce the frame velocity limit during the backward pass. </dd></dl>

</div>
</div>
<a id="a68128c4e24b7fb5ced993cc55f2453a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68128c4e24b7fb5ced993cc55f2453a6">&#9670;&nbsp;</a></span>AddJointAccelerationLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt;, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; &gt; AddJointAccelerationLimit </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#ad8fa828762d54ed2db5efec5df1b5082">ToppraDiscretization</a>&#160;</td>
          <td class="paramname"><em>discretization</em> = <code><a class="el" href="namespacedrake_1_1multibody.html#ad8fa828762d54ed2db5efec5df1b5082a9ef15c126044c94d6440bfbf02f6c55d">ToppraDiscretization::kInterpolation</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an acceleration limit to all the degrees of freedom in the plant. </p>
<p>The limits must be arranged in the same order as the entries in the path. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lower_limit</td><td>The lower acceleration limit for each degree of freedom. </td></tr>
    <tr><td class="paramname">upper_limit</td><td>The upper acceleration limit for each degree of freedom. </td></tr>
    <tr><td class="paramname">discretization</td><td>The discretization scheme to use for this linear constraint. See ToppraDiscretization for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair containing the linear constraints that will enforce the acceleration limit on the backward pass and forward pass respectively. </dd></dl>

</div>
</div>
<a id="a34e3c0664e1e847c82fb7a4eee9374cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e3c0664e1e847c82fb7a4eee9374cc">&#9670;&nbsp;</a></span>AddJointTorqueLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt;, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; &gt; AddJointTorqueLimit </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#ad8fa828762d54ed2db5efec5df1b5082">ToppraDiscretization</a>&#160;</td>
          <td class="paramname"><em>discretization</em> = <code><a class="el" href="namespacedrake_1_1multibody.html#ad8fa828762d54ed2db5efec5df1b5082a9ef15c126044c94d6440bfbf02f6c55d">ToppraDiscretization::kInterpolation</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a torque limit to all the degrees of freedom in the plant. </p>
<p>The limits must be arranged in the same order as the entries in the path. This constrains the generalized torques applied to the plant and does not reason about contact forces. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lower_limit</td><td>The lower torque limit for each degree of freedom. </td></tr>
    <tr><td class="paramname">upper_limit</td><td>The upper torque limit for each degree of freedom. </td></tr>
    <tr><td class="paramname">discretization</td><td>The discretization scheme to use for this linear constraint. See ToppraDiscretization for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair containing the linear constraints that will enforce the torque limit on the backward pass and forward pass respectively. </dd></dl>

</div>
</div>
<a id="aa6404ed212fab2af0bad98457df07d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6404ed212fab2af0bad98457df07d16">&#9670;&nbsp;</a></span>AddJointVelocityLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a>&gt; AddJointVelocityLimit </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a velocity limit to all the degrees of freedom in the plant. </p>
<p>The limits must be arranged in the same order as the entries in the path. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lower_limit</td><td>The lower velocity limit for each degree of freedom. </td></tr>
    <tr><td class="paramname">upper_limit</td><td>The upper velocity limit for each degree of freedom. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac05332bb6e89f996e9501a52af6e307f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05332bb6e89f996e9501a52af6e307f">&#9670;&nbsp;</a></span>CalcGridPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Eigen::VectorXd CalcGridPoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1trajectories_1_1_trajectory.html">Trajectory</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1multibody_1_1_calc_grid_points_options.html">CalcGridPointsOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes a path and generates a sequence of gridpoints selected to control the interpolation error of the optimization. </p>
<p>The gridpoints are selected such that the distance between them is below <code>max_seg_length</code>, there are at least <code>min_points</code> number of gridpoints and the interpolation error, estimated with the equation </p><pre>
  errₑₛₜ = max(|q̈ Δₛ²|) / 2
</pre><p> where Δₛ is the distance between sequential gridpoints, is less than <code>max_err</code>. Gridpoints are selected by adding the midpoint between two gridpoints whenever the distance between them is too large or the estimated error is too high. This results in more points in parts of the path with higher curvature. All grid points will lie between path.start_time() and path.end_time(). </p>

</div>
</div>
<a id="a57c0c591fef12ba0135b9576f4344974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c0c591fef12ba0135b9576f4344974">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html">Toppra</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html">Toppra</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab013d8e5872653e5d10eaae0f3daa3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab013d8e5872653e5d10eaae0f3daa3dc">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html">Toppra</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_toppra.html">Toppra</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a71ae71e801a2c27f272cf1493aaa82df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ae71e801a2c27f272cf1493aaa82df">&#9670;&nbsp;</a></span>SolvePathParameterization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="classdrake_1_1trajectories_1_1_piecewise_polynomial.html">PiecewisePolynomial</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; SolvePathParameterization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>s_dot_start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>s_dot_end</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the TOPPRA optimization and returns the time optimized path parameterization s(t). </p>
<p>This can be used with the original path q(s) to generate a time parameterized trajectory. The path parameterization has the same start time as the original path's starting break. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s_dot_start</td><td>ṡ(0). The default value is zero (trajectory starts at zero velocity). </td></tr>
    <tr><td class="paramname">s_dot_end</td><td>ṡ(T), where T is the end break of the path. The default value is zero (trajectory ends at zero velocity). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/multibody/optimization/<a class="el" href="toppra_8h.html">toppra.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a class="el" href="classdrake_1_1multibody_1_1_toppra.html">Toppra</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().value = searchBox.searchLabel;
</script>
</body>
</html>
