<!-- HTML header for doxygen 1.15.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: Polynomial&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<header class="site-header">
 <div class="site-header-inner contain">
  <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
  <div class="menu-mobile-toggle">
   <span></span>
  </div>
  <nav class="site-menu">
   <ul>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/">Home</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/installation.html">Installation</a>
    </li>
    <li class="site-menu-item site-menu-item-main">
     <a class="site-menu-item" href="/gallery.html">Gallery</a>
    </li>
    <li class="site-menu-item site-menu-item-main">API Documentation
     <div class="sub">
      <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a>
      <a class="site-menu-item" href="/pydrake/index.html">Python</a>
     </div>
    </li>
    <li class="site-menu-item site-menu-item-main">Resources
     <div class="sub">
      <a class="site-menu-item" href="/getting_help.html">Getting Help</a>
      <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a>
      <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a>
      <a class="site-menu-item" href="/developers.html">For Developers</a>
      <a class="site-menu-item" href="/credits.html">Credits</a>
     </div>
    </li>
    <li class="github-link">
     <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
    </li>
   </ul>
  </nav>
 </div>
</header>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="title-banner">
 <div class="title-banner__title">
  Drake C++ Documentation
 </div>
 <div id="DDGSearch">
  <form id="search_form_cpp" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search C++ API only…">
   <input type="hidden" name="q" value="site:drake.mit.edu/doxygen_cxx">
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
   <input type="text" name="q" placeholder="Search all of Drake…">
   <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu">
  </form>
 </div>
 <div id="MSearchBoxContainer">
  <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classdrake_1_1_polynomial.html','','classdrake_1_1_polynomial-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Polynomial&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T = double&gt;<br />
class drake::Polynomial&lt; T &gt;</div><p>A scalar multi-variate polynomial, modeled after the msspoly in spotless. </p>
<p><a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> represents a list of additive Monomials, each one of which is a product of a constant coefficient (of T, which by default is double) and any number of distinct Terms (variables raised to positive integer powers).</p>
<p>Variables are identified by integer indices rather than symbolic names, but an automatic facility is provided to convert variable names up to four characters into unique integers, provided those variables are named using only lowercase letters and the "@#_." characters followed by a number. For example, valid names include "dx4" and "m_x".</p>
<p>Monomials which have the same variables and powers may be constructed but will be automatically combined: (3 * a * b * a) + (1.5 * b * a**2) will be reduced to (4.5 * b * a**2) internally after construction.</p>
<p>Polynomials can be added, subtracted, and multiplied. They may only be divided by scalars (of T) because Polynomials are not closed under division.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/common/polynomial.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:Monomial" id="r_Monomial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html">Monomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An additive atom of a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>: The product of any number of Terms and a coefficient.  <a href="classdrake_1_1_polynomial_1_1_monomial.html#details">More...</a><br /></td></tr>
<tr class="memitem:Product" id="r_Product"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1_polynomial_1_1_product.html">Product</a></td></tr>
<tr class="memitem:Term" id="r_Term"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial_1_1_term.html">Term</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An individual variable raised to an integer power; e.g. x**2.  <a href="classdrake_1_1_polynomial_1_1_term.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:adb36a6e938f851b1a5d1a443c2dadb8a" id="r_adb36a6e938f851b1a5d1a443c2dadb8a"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a></td></tr>
<tr class="memitem:a6b2fc1d3e138053b9dc8864815059fe0" id="r_a6b2fc1d3e138053b9dc8864815059fe0"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b2fc1d3e138053b9dc8864815059fe0">PowerType</a></td></tr>
<tr class="memdesc:a6b2fc1d3e138053b9dc8864815059fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This should be 'unsigned int' but MSVC considers a call to std::pow(...,
unsigned int) ambiguous because it won't cast unsigned int to int.  <br /></td></tr>
<tr class="memitem:a48c24f8f3b4b14f7e4bb9fbde3748fe8" id="r_a48c24f8f3b4b14f7e4bb9fbde3748fe8"><td class="memItemLeft" align="right" valign="top">typedef Eigen::NumTraits&lt; T &gt;::Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48c24f8f3b4b14f7e4bb9fbde3748fe8">RealScalar</a></td></tr>
<tr class="memitem:a81b4c054beeae81d6d01bfd5412a89cd" id="r_a81b4c054beeae81d6d01bfd5412a89cd"><td class="memItemLeft" align="right" valign="top">typedef std::complex&lt; <a class="el" href="#a48c24f8f3b4b14f7e4bb9fbde3748fe8">RealScalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81b4c054beeae81d6d01bfd5412a89cd">RootType</a></td></tr>
<tr class="memitem:ac85a9dd1caea93fdcdbffd1432f70060" id="r_ac85a9dd1caea93fdcdbffd1432f70060"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; <a class="el" href="#a81b4c054beeae81d6d01bfd5412a89cd">RootType</a>, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac85a9dd1caea93fdcdbffd1432f70060">RootsType</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a925044e356137ea2d1ee6af62fea4156" id="r_a925044e356137ea2d1ee6af62fea4156"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a925044e356137ea2d1ee6af62fea4156">Polynomial</a> (void)</td></tr>
<tr class="memdesc:a925044e356137ea2d1ee6af62fea4156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the vacuous polynomial, "0".  <br /></td></tr>
<tr class="memitem:a2f4e320eb4e56b74c4e212067ae9fbf0" id="r_a2f4e320eb4e56b74c4e212067ae9fbf0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f4e320eb4e56b74c4e212067ae9fbf0">Polynomial</a> (const T &amp;scalar)</td></tr>
<tr class="memdesc:a2f4e320eb4e56b74c4e212067ae9fbf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> of a single constant. e.g. "5".  <br /></td></tr>
<tr class="memitem:a113f39750edd840d2f269940e5ca1cb6" id="r_a113f39750edd840d2f269940e5ca1cb6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a113f39750edd840d2f269940e5ca1cb6">Polynomial</a> (const T coeff, const std::vector&lt; <a class="el" href="classdrake_1_1_polynomial_1_1_term.html">Term</a> &gt; &amp;terms)</td></tr>
<tr class="memdesc:a113f39750edd840d2f269940e5ca1cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> consisting of a single <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html" title="An additive atom of a Polynomial: The product of any number of Terms and a coefficient.">Monomial</a>, e.g. "5xy**3".  <br /></td></tr>
<tr class="memitem:afcb80fce8585dd54f26ea753fb3fa4ac" id="r_afcb80fce8585dd54f26ea753fb3fa4ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcb80fce8585dd54f26ea753fb3fa4ac">Polynomial</a> (typename std::vector&lt; <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html">Monomial</a> &gt;::const_iterator start, typename std::vector&lt; <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html">Monomial</a> &gt;::const_iterator finish)</td></tr>
<tr class="memdesc:afcb80fce8585dd54f26ea753fb3fa4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> from a sequence of Monomials.  <br /></td></tr>
<tr class="memitem:ab2d984c6a3f814a0cfe120febe762139" id="r_ab2d984c6a3f814a0cfe120febe762139"><td class="memTemplParams" colspan="2">template&lt;typename U = T&gt; </td></tr>
<tr class="memitem:ab2d984c6a3f814a0cfe120febe762139 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2d984c6a3f814a0cfe120febe762139">Polynomial</a> (const std::enable_if_t&lt; std::is_same_v&lt; U, double &gt;, std::string &gt; &amp;varname)</td></tr>
<tr class="memdesc:ab2d984c6a3f814a0cfe120febe762139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a polynomial consisting of a single <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html" title="An additive atom of a Polynomial: The product of any number of Terms and a coefficient.">Monomial</a> of the variable named <span class="tt">varname1</span>.  <br /></td></tr>
<tr class="memitem:ab0f5130d25206fac74ef07d81bf8ec23" id="r_ab0f5130d25206fac74ef07d81bf8ec23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0f5130d25206fac74ef07d81bf8ec23">Polynomial</a> (const std::string &amp;varname, unsigned int num)</td></tr>
<tr class="memdesc:ab0f5130d25206fac74ef07d81bf8ec23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a polynomial consisting of a single <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html" title="An additive atom of a Polynomial: The product of any number of Terms and a coefficient.">Monomial</a> of the variable named varname + num.  <br /></td></tr>
<tr class="memitem:a5d1a539c279243b61fdc12c6cfeaed57" id="r_a5d1a539c279243b61fdc12c6cfeaed57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d1a539c279243b61fdc12c6cfeaed57">Polynomial</a> (const T &amp;coeff, const <a class="el" href="#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> &amp;v)</td></tr>
<tr class="memdesc:a5d1a539c279243b61fdc12c6cfeaed57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a single <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html" title="An additive atom of a Polynomial: The product of any number of Terms and a coefficient.">Monomial</a> of the given coefficient and variable.  <br /></td></tr>
<tr class="memitem:a3e8ad3a8b81ea18e3f8f5faba26495de" id="r_a3e8ad3a8b81ea18e3f8f5faba26495de"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a3e8ad3a8b81ea18e3f8f5faba26495de template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e8ad3a8b81ea18e3f8f5faba26495de">Polynomial</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;coefficients)</td></tr>
<tr class="memdesc:a3e8ad3a8b81ea18e3f8f5faba26495de"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constructor for univariate polynomials: takes a vector of coefficients for the x**0, x**1, x**2, x**3... Monomials.  <br /></td></tr>
<tr class="memitem:a3d04328e0ea4df22f47e1651c706082d" id="r_a3d04328e0ea4df22f47e1651c706082d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d04328e0ea4df22f47e1651c706082d">GetNumberOfCoefficients</a> () const</td></tr>
<tr class="memdesc:a3d04328e0ea4df22f47e1651c706082d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of unique Monomials (and thus the number of coefficients) in this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>.  <br /></td></tr>
<tr class="memitem:a8d2a0b0dd246af6385d78567af484840" id="r_a8d2a0b0dd246af6385d78567af484840"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d2a0b0dd246af6385d78567af484840">GetDegree</a> () const</td></tr>
<tr class="memdesc:a8d2a0b0dd246af6385d78567af484840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest degree of any <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html" title="An additive atom of a Polynomial: The product of any number of Terms and a coefficient.">Monomial</a> in this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>.  <br /></td></tr>
<tr class="memitem:a0a83f7960aa020c56d20f435dba4d3cd" id="r_a0a83f7960aa020c56d20f435dba4d3cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a83f7960aa020c56d20f435dba4d3cd">IsAffine</a> () const</td></tr>
<tr class="memdesc:a0a83f7960aa020c56d20f435dba4d3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff this is a sum of terms of degree 1, plus a constant.  <br /></td></tr>
<tr class="memitem:aa3b70bcbd72aedf09e5dad6e5e5d8b9f" id="r_aa3b70bcbd72aedf09e5dad6e5e5d8b9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3b70bcbd72aedf09e5dad6e5e5d8b9f">GetSimpleVariable</a> () const</td></tr>
<tr class="memdesc:aa3b70bcbd72aedf09e5dad6e5e5d8b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the polynomial is "simple" &ndash; e.g.  <br /></td></tr>
<tr class="memitem:a42c0495deb652146f10152b3db9269b9" id="r_a42c0495deb652146f10152b3db9269b9"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html">Monomial</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42c0495deb652146f10152b3db9269b9">GetMonomials</a> () const</td></tr>
<tr class="memitem:a9087ceeeacb503464704042fe7bee668" id="r_a9087ceeeacb503464704042fe7bee668"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9087ceeeacb503464704042fe7bee668">GetCoefficients</a> () const</td></tr>
<tr class="memdesc:a9087ceeeacb503464704042fe7bee668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vector of the coefficients of the polynomial in the order of powers of the variable - the [i]th element is the coefficient of the variable raised to the ith power.  <br /></td></tr>
<tr class="memitem:afc6a66a1cf630a22d608363877a16c05" id="r_afc6a66a1cf630a22d608363877a16c05"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc6a66a1cf630a22d608363877a16c05">GetVariables</a> () const</td></tr>
<tr class="memdesc:afc6a66a1cf630a22d608363877a16c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a set of all of the variables present in this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>.  <br /></td></tr>
<tr class="memitem:a1df25989c473cd56f415001ab45f9ca8" id="r_a1df25989c473cd56f415001ab45f9ca8"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:a1df25989c473cd56f415001ab45f9ca8 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1_polynomial_1_1_product.html">Product</a>&lt; T, U &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1df25989c473cd56f415001ab45f9ca8">EvaluateUnivariate</a> (const U &amp;x, int derivative_order=0) const</td></tr>
<tr class="memdesc:a1df25989c473cd56f415001ab45f9ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a univariate <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> at a specific point.  <br /></td></tr>
<tr class="memitem:a98083b69296b5c9e0e0a8b9abc4c0527" id="r_a98083b69296b5c9e0e0a8b9abc4c0527"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:a98083b69296b5c9e0e0a8b9abc4c0527 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1_polynomial_1_1_product.html">Product</a>&lt; T, U &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98083b69296b5c9e0e0a8b9abc4c0527">EvaluateMultivariate</a> (const std::map&lt; <a class="el" href="#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a>, U &gt; &amp;var_values) const</td></tr>
<tr class="memdesc:a98083b69296b5c9e0e0a8b9abc4c0527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a multivariate <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> at a specific point.  <br /></td></tr>
<tr class="memitem:a981a524ccda4902bff9380c48fd2714a" id="r_a981a524ccda4902bff9380c48fd2714a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a981a524ccda4902bff9380c48fd2714a">EvaluatePartial</a> (const std::map&lt; <a class="el" href="#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a>, T &gt; &amp;var_values) const</td></tr>
<tr class="memdesc:a981a524ccda4902bff9380c48fd2714a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute values for some but not necessarily all variables of a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>.  <br /></td></tr>
<tr class="memitem:a5590d23d37495f26e4e0226674af2436" id="r_a5590d23d37495f26e4e0226674af2436"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5590d23d37495f26e4e0226674af2436">Subs</a> (const <a class="el" href="#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> &amp;orig, const <a class="el" href="#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> &amp;replacement)</td></tr>
<tr class="memdesc:a5590d23d37495f26e4e0226674af2436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all instances of variable orig with replacement.  <br /></td></tr>
<tr class="memitem:ad69112ea5f074512671136b4aa3748ee" id="r_ad69112ea5f074512671136b4aa3748ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad69112ea5f074512671136b4aa3748ee">Substitute</a> (const <a class="el" href="#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> &amp;orig, const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;replacement) const</td></tr>
<tr class="memdesc:ad69112ea5f074512671136b4aa3748ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all instances of variable orig with replacement.  <br /></td></tr>
<tr class="memitem:ae1c8fa5ca0a531f3bfc388ba5b13f6c8" id="r_ae1c8fa5ca0a531f3bfc388ba5b13f6c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1c8fa5ca0a531f3bfc388ba5b13f6c8">Derivative</a> (int derivative_order=1) const</td></tr>
<tr class="memdesc:ae1c8fa5ca0a531f3bfc388ba5b13f6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes the derivative of this (univariate) <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>.  <br /></td></tr>
<tr class="memitem:a03a34972aa2903d7210d0bda55e5c157" id="r_a03a34972aa2903d7210d0bda55e5c157"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03a34972aa2903d7210d0bda55e5c157">Integral</a> (const T &amp;integration_constant=0.0) const</td></tr>
<tr class="memdesc:a03a34972aa2903d7210d0bda55e5c157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes the integral of this (univariate, non-constant) <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>.  <br /></td></tr>
<tr class="memitem:a50429ee79a9044de390501c26d0f0e23" id="r_a50429ee79a9044de390501c26d0f0e23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50429ee79a9044de390501c26d0f0e23">is_univariate</a> () const</td></tr>
<tr class="memdesc:a50429ee79a9044de390501c26d0f0e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is a univariate polynomial.  <br /></td></tr>
<tr class="memitem:aaebc4cbcf8fd3bf18645752aaf7ef737" id="r_aaebc4cbcf8fd3bf18645752aaf7ef737"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaebc4cbcf8fd3bf18645752aaf7ef737">operator==</a> (const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;other) const</td></tr>
<tr class="memitem:aee380f5bef984dd5dcc143a0842eab8b" id="r_aee380f5bef984dd5dcc143a0842eab8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee380f5bef984dd5dcc143a0842eab8b">operator+=</a> (const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;other)</td></tr>
<tr class="memitem:ab9a78de8f3161a0c62e383791d11f62f" id="r_ab9a78de8f3161a0c62e383791d11f62f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9a78de8f3161a0c62e383791d11f62f">operator-=</a> (const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;other)</td></tr>
<tr class="memitem:ae2d5c3edc702c41343d72562e0604319" id="r_ae2d5c3edc702c41343d72562e0604319"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2d5c3edc702c41343d72562e0604319">operator*=</a> (const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;other)</td></tr>
<tr class="memitem:a30d8fcbada3c48ba1674f578b34a3de3" id="r_a30d8fcbada3c48ba1674f578b34a3de3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30d8fcbada3c48ba1674f578b34a3de3">operator+=</a> (const T &amp;scalar)</td></tr>
<tr class="memitem:a910cad1992d7df3505bafeae091e8cb9" id="r_a910cad1992d7df3505bafeae091e8cb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a910cad1992d7df3505bafeae091e8cb9">operator-=</a> (const T &amp;scalar)</td></tr>
<tr class="memitem:adb47d0015db17c03c3afd59ebf657b55" id="r_adb47d0015db17c03c3afd59ebf657b55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb47d0015db17c03c3afd59ebf657b55">operator*=</a> (const T &amp;scalar)</td></tr>
<tr class="memitem:a9fcc1a389ccec8efe11cb7adef400616" id="r_a9fcc1a389ccec8efe11cb7adef400616"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fcc1a389ccec8efe11cb7adef400616">operator/=</a> (const T &amp;scalar)</td></tr>
<tr class="memitem:aa0c1c5c8ea58b29b87ca1a7f240c7664" id="r_aa0c1c5c8ea58b29b87ca1a7f240c7664"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0c1c5c8ea58b29b87ca1a7f240c7664">operator+</a> (const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;other) const</td></tr>
<tr class="memitem:ac86fb56fd075f1c1442883c77f200792" id="r_ac86fb56fd075f1c1442883c77f200792"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac86fb56fd075f1c1442883c77f200792">operator-</a> (const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;other) const</td></tr>
<tr class="memitem:a93f813cb8ff8e450366e4e2f353bd7e6" id="r_a93f813cb8ff8e450366e4e2f353bd7e6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93f813cb8ff8e450366e4e2f353bd7e6">operator-</a> () const</td></tr>
<tr class="memitem:a4fb9d0b2269ab915f93bb26e1fcd7b9f" id="r_a4fb9d0b2269ab915f93bb26e1fcd7b9f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fb9d0b2269ab915f93bb26e1fcd7b9f">operator*</a> (const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;other) const</td></tr>
<tr class="memitem:a7443b8380cfcd753611a5b9d91753a2f" id="r_a7443b8380cfcd753611a5b9d91753a2f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7443b8380cfcd753611a5b9d91753a2f">operator/</a> (const T &amp;scalar) const</td></tr>
<tr class="memitem:aa2b38df08e0829d532b692c75e955437" id="r_aa2b38df08e0829d532b692c75e955437"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2b38df08e0829d532b692c75e955437">operator&lt;</a> (const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;other) const</td></tr>
<tr class="memdesc:aa2b38df08e0829d532b692c75e955437"><td class="mdescLeft">&#160;</td><td class="mdescRight">A comparison to allow std::lexicographical_compare on this class; does not reflect any sort of mathematical total order.  <br /></td></tr>
<tr class="memitem:a7f7703398f420e19d121b92c13e2b416" id="r_a7f7703398f420e19d121b92c13e2b416"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac85a9dd1caea93fdcdbffd1432f70060">RootsType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f7703398f420e19d121b92c13e2b416">Roots</a> () const</td></tr>
<tr class="memdesc:a7f7703398f420e19d121b92c13e2b416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the roots of this (univariate) <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>.  <br /></td></tr>
<tr class="memitem:ad96f76c37313cb0d62582faccf358345" id="r_ad96f76c37313cb0d62582faccf358345"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad96f76c37313cb0d62582faccf358345">CoefficientsAlmostEqual</a> (const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; T &gt; &amp;other, const <a class="el" href="#a48c24f8f3b4b14f7e4bb9fbde3748fe8">RealScalar</a> &amp;tol=0.0, const <a class="el" href="namespacedrake.html#af8777bc10296f9d39d52753861110e26">ToleranceType</a> &amp;tol_type=<a class="el" href="namespacedrake.html#af8777bc10296f9d39d52753861110e26abab0767e88027de9944aa55c24c8387a">ToleranceType::kAbsolute</a>) const</td></tr>
<tr class="memdesc:ad96f76c37313cb0d62582faccf358345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> is approximately equal to this one.  <br /></td></tr>
<tr class="memitem:aac993ecccd3d88aafefb6b8e3caa1dee" id="r_aac993ecccd3d88aafefb6b8e3caa1dee"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac993ecccd3d88aafefb6b8e3caa1dee">to_string</a> () const</td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:ad4fc8f2e6a67575f78cb74e9163fd5e3" id="r_ad4fc8f2e6a67575f78cb74e9163fd5e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> (const Polynomial &amp;)=default</td></tr>
<tr class="memitem:a964d6ac2b576fb2d6963cd7e19109114" id="r_a964d6ac2b576fb2d6963cd7e19109114"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a964d6ac2b576fb2d6963cd7e19109114">operator=</a> (const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;)=default</td></tr>
<tr class="memitem:aa280c0fba0d2e78def19c2d4827f6733" id="r_aa280c0fba0d2e78def19c2d4827f6733"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa280c0fba0d2e78def19c2d4827f6733">Polynomial</a> (Polynomial &amp;&amp;)=default</td></tr>
<tr class="memitem:a36b55001dc20b0197f226a6f9281adb0" id="r_a36b55001dc20b0197f226a6f9281adb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36b55001dc20b0197f226a6f9281adb0">operator=</a> (<a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;&amp;)=default</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab280606b42c866742fee1c708c6598d9" id="r_ab280606b42c866742fee1c708c6598d9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab280606b42c866742fee1c708c6598d9">FromExpression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">drake::symbolic::Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ab280606b42c866742fee1c708c6598d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> representing the symbolic expression <span class="tt">e</span>.  <br /></td></tr>
<tr class="memitem:ada60946d276f79e555d32badc0d8a91f" id="r_ada60946d276f79e555d32badc0d8a91f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada60946d276f79e555d32badc0d8a91f">IsValidVariableName</a> (const std::string name)</td></tr>
<tr class="memdesc:ada60946d276f79e555d32badc0d8a91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable name/ID conversion facility.  <br /></td></tr>
<tr class="memitem:aeaeacfff3d087ad400147e605269ad3c" id="r_aeaeacfff3d087ad400147e605269ad3c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeaeacfff3d087ad400147e605269ad3c">VariableNameToId</a> (const std::string name, unsigned int m=1)</td></tr>
<tr class="memitem:a96a10bc725a30f1296033f5d26188af1" id="r_a96a10bc725a30f1296033f5d26188af1"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96a10bc725a30f1296033f5d26188af1">IdToVariableName</a> (const <a class="el" href="#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> id)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-friends" class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3b8ee5b634b35a7c4db1cddc532d177c" id="r_a3b8ee5b634b35a7c4db1cddc532d177c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b8ee5b634b35a7c4db1cddc532d177c">operator+</a> (const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;p, const T &amp;scalar)</td></tr>
<tr class="memitem:aa14fcd10f0a5683e9778d1ad46b869a6" id="r_aa14fcd10f0a5683e9778d1ad46b869a6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa14fcd10f0a5683e9778d1ad46b869a6">operator+</a> (const T &amp;scalar, const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;p)</td></tr>
<tr class="memitem:acf2f5dc8759b0683d649a356e1c23bc8" id="r_acf2f5dc8759b0683d649a356e1c23bc8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf2f5dc8759b0683d649a356e1c23bc8">operator-</a> (const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;p, const T &amp;scalar)</td></tr>
<tr class="memitem:a30d861d1bfde004747d8a90c6e61e728" id="r_a30d861d1bfde004747d8a90c6e61e728"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30d861d1bfde004747d8a90c6e61e728">operator-</a> (const T &amp;scalar, const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;p)</td></tr>
<tr class="memitem:aee29171ff87a19fb6b13351d3f23084f" id="r_aee29171ff87a19fb6b13351d3f23084f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee29171ff87a19fb6b13351d3f23084f">operator*</a> (const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;p, const T &amp;scalar)</td></tr>
<tr class="memitem:aebc58e51a6b249b2891f431682ad0749" id="r_aebc58e51a6b249b2891f431682ad0749"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebc58e51a6b249b2891f431682ad0749">operator*</a> (const T &amp;scalar, const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp;p)</td></tr>
<tr class="memitem:abacc19a0640ec7027ded784410817053" id="r_abacc19a0640ec7027ded784410817053"><td class="memTemplParams" colspan="2">template&lt;typename U&gt; </td></tr>
<tr class="memitem:abacc19a0640ec7027ded784410817053 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; U &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abacc19a0640ec7027ded784410817053">pow</a> (const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; U &gt; &amp;p, typename <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; U &gt;<a class="el" href="#a6b2fc1d3e138053b9dc8864815059fe0">::PowerType</a> n)</td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a6b2fc1d3e138053b9dc8864815059fe0" name="a6b2fc1d3e138053b9dc8864815059fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2fc1d3e138053b9dc8864815059fe0">&#9670;&#160;</a></span>PowerType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="#a6b2fc1d3e138053b9dc8864815059fe0">PowerType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This should be 'unsigned int' but MSVC considers a call to std::pow(...,
unsigned int) ambiguous because it won't cast unsigned int to int. </p>

</div>
</div>
<a id="a48c24f8f3b4b14f7e4bb9fbde3748fe8" name="a48c24f8f3b4b14f7e4bb9fbde3748fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c24f8f3b4b14f7e4bb9fbde3748fe8">&#9670;&#160;</a></span>RealScalar</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::NumTraits&lt;T&gt;::Real <a class="el" href="#a48c24f8f3b4b14f7e4bb9fbde3748fe8">RealScalar</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac85a9dd1caea93fdcdbffd1432f70060" name="ac85a9dd1caea93fdcdbffd1432f70060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85a9dd1caea93fdcdbffd1432f70060">&#9670;&#160;</a></span>RootsType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;<a class="el" href="#a81b4c054beeae81d6d01bfd5412a89cd">RootType</a>, Eigen::Dynamic, 1&gt; <a class="el" href="#ac85a9dd1caea93fdcdbffd1432f70060">RootsType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81b4c054beeae81d6d01bfd5412a89cd" name="a81b4c054beeae81d6d01bfd5412a89cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b4c054beeae81d6d01bfd5412a89cd">&#9670;&#160;</a></span>RootType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::complex&lt;<a class="el" href="#a48c24f8f3b4b14f7e4bb9fbde3748fe8">RealScalar</a>&gt; <a class="el" href="#a81b4c054beeae81d6d01bfd5412a89cd">RootType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb36a6e938f851b1a5d1a443c2dadb8a" name="adb36a6e938f851b1a5d1a443c2dadb8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb36a6e938f851b1a5d1a443c2dadb8a">&#9670;&#160;</a></span>VarType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad4fc8f2e6a67575f78cb74e9163fd5e3" name="ad4fc8f2e6a67575f78cb74e9163fd5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">&#9670;&#160;</a></span>Polynomial() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Polynomial </td>
          <td>(</td>
          <td class="paramtype">const Polynomial&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa280c0fba0d2e78def19c2d4827f6733" name="aa280c0fba0d2e78def19c2d4827f6733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa280c0fba0d2e78def19c2d4827f6733">&#9670;&#160;</a></span>Polynomial() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Polynomial </td>
          <td>(</td>
          <td class="paramtype">Polynomial&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a925044e356137ea2d1ee6af62fea4156" name="a925044e356137ea2d1ee6af62fea4156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925044e356137ea2d1ee6af62fea4156">&#9670;&#160;</a></span>Polynomial() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Polynomial </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the vacuous polynomial, "0". </p>

</div>
</div>
<a id="a2f4e320eb4e56b74c4e212067ae9fbf0" name="a2f4e320eb4e56b74c4e212067ae9fbf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4e320eb4e56b74c4e212067ae9fbf0">&#9670;&#160;</a></span>Polynomial() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Polynomial </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> of a single constant. e.g. "5". </p>

</div>
</div>
<a id="a113f39750edd840d2f269940e5ca1cb6" name="a113f39750edd840d2f269940e5ca1cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113f39750edd840d2f269940e5ca1cb6">&#9670;&#160;</a></span>Polynomial() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Polynomial </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>coeff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1_polynomial_1_1_term.html">Term</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>terms</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> consisting of a single <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html" title="An additive atom of a Polynomial: The product of any number of Terms and a coefficient.">Monomial</a>, e.g. "5xy**3". </p>

</div>
</div>
<a id="afcb80fce8585dd54f26ea753fb3fa4ac" name="afcb80fce8585dd54f26ea753fb3fa4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb80fce8585dd54f26ea753fb3fa4ac">&#9670;&#160;</a></span>Polynomial() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Polynomial </td>
          <td>(</td>
          <td class="paramtype">typename std::vector&lt; <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html">Monomial</a> &gt;::const_iterator</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::vector&lt; <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html">Monomial</a> &gt;::const_iterator</td>          <td class="paramname"><span class="paramname"><em>finish</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> from a sequence of Monomials. </p>

</div>
</div>
<a id="ab2d984c6a3f814a0cfe120febe762139" name="ab2d984c6a3f814a0cfe120febe762139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d984c6a3f814a0cfe120febe762139">&#9670;&#160;</a></span>Polynomial() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
<div class="memtemplate">
template&lt;typename U = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Polynomial </td>
          <td>(</td>
          <td class="paramtype">const std::enable_if_t&lt; std::is_same_v&lt; U, double &gt;, std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>varname</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a polynomial consisting of a single <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html" title="An additive atom of a Polynomial: The product of any number of Terms and a coefficient.">Monomial</a> of the variable named <span class="tt">varname1</span>. </p>
<dl class="section note"><dt>Note</dt><dd>: This constructor is only provided for T = double. For the other cases, a user should use the constructor with two arguments below (taking std::string and unsigned int). If we provided this constructor for T = <a class="el" href="namespacedrake.html#a3d6302a0051e9403c9df3ed6808f3854" title="A scalar type that performs automatic differentiation.">AutoDiffXd</a> and T = <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>, there would be compiler errors for <span class="tt"><a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>&lt;T&gt;(0)</span> as the following candidates are ambiguous:<ul>
<li><a class="el" href="#a2f4e320eb4e56b74c4e212067ae9fbf0" title="Construct a Polynomial of a single constant. e.g. &quot;5&quot;.">Polynomial(const T&amp; scalar)</a></li>
<li><a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>(const std::string&amp; varname, const unsigned int num = 1) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab0f5130d25206fac74ef07d81bf8ec23" name="ab0f5130d25206fac74ef07d81bf8ec23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f5130d25206fac74ef07d81bf8ec23">&#9670;&#160;</a></span>Polynomial() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Polynomial </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>varname</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>num</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a polynomial consisting of a single <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html" title="An additive atom of a Polynomial: The product of any number of Terms and a coefficient.">Monomial</a> of the variable named varname + num. </p>

</div>
</div>
<a id="a5d1a539c279243b61fdc12c6cfeaed57" name="a5d1a539c279243b61fdc12c6cfeaed57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1a539c279243b61fdc12c6cfeaed57">&#9670;&#160;</a></span>Polynomial() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Polynomial </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>coeff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a single <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html" title="An additive atom of a Polynomial: The product of any number of Terms and a coefficient.">Monomial</a> of the given coefficient and variable. </p>

</div>
</div>
<a id="a3e8ad3a8b81ea18e3f8f5faba26495de" name="a3e8ad3a8b81ea18e3f8f5faba26495de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8ad3a8b81ea18e3f8f5faba26495de">&#9670;&#160;</a></span>Polynomial() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Polynomial </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>coefficients</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A constructor for univariate polynomials: takes a vector of coefficients for the x**0, x**1, x**2, x**3... Monomials. </p>
<p>All terms are always added, even if a coefficient is zero. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ad96f76c37313cb0d62582faccf358345" name="ad96f76c37313cb0d62582faccf358345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96f76c37313cb0d62582faccf358345">&#9670;&#160;</a></span>CoefficientsAlmostEqual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt; CoefficientsAlmostEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a48c24f8f3b4b14f7e4bb9fbde3748fe8">RealScalar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#af8777bc10296f9d39d52753861110e26">ToleranceType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tol_type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespacedrake.html#af8777bc10296f9d39d52753861110e26abab0767e88027de9944aa55c24c8387a">ToleranceType::kAbsolute</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> is approximately equal to this one. </p>
<p>Checks that every coefficient of <span class="tt">other</span> is within <span class="tt">tol</span> of the corresponding coefficient of this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>.</p>
<p>Note: When <span class="tt">tol_type</span> is kRelative, if any monomials appear in <span class="tt">this</span> or <span class="tt">other</span> but not both, then the method returns false (since the comparison is relative to a missing zero coefficient). Use kAbsolute if you want to ignore non-matching monomials with coefficients less than <span class="tt">tol</span>. </p>

</div>
</div>
<a id="ae1c8fa5ca0a531f3bfc388ba5b13f6c8" name="ae1c8fa5ca0a531f3bfc388ba5b13f6c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c8fa5ca0a531f3bfc388ba5b13f6c8">&#9670;&#160;</a></span>Derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> Derivative </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>derivative_order</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes the derivative of this (univariate) <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>
<p>Returns a new <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> that is the derivative of this one in its sole variable. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> is not univariate.</td></tr>
  </table>
  </dd>
</dl>
<p>If derivative_order is given, takes the nth derivative of this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>

</div>
</div>
<a id="a98083b69296b5c9e0e0a8b9abc4c0527" name="a98083b69296b5c9e0e0a8b9abc4c0527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98083b69296b5c9e0e0a8b9abc4c0527">&#9670;&#160;</a></span>EvaluateMultivariate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1_polynomial_1_1_product.html">Product</a>&lt; T, U &gt;::type EvaluateMultivariate </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a>, U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>var_values</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a multivariate <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> at a specific point. </p>
<p>Evaluates a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> with the given values for each variable. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> contains variables for which values were not provided.</td></tr>
  </table>
  </dd>
</dl>
<p>The provided values may be of any type which is std::is_arithmetic (supporting the std::pow, *, and + operations) and need not be CoefficientsType or <a class="el" href="#a48c24f8f3b4b14f7e4bb9fbde3748fe8">RealScalar</a>) </p>

</div>
</div>
<a id="a981a524ccda4902bff9380c48fd2714a" name="a981a524ccda4902bff9380c48fd2714a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981a524ccda4902bff9380c48fd2714a">&#9670;&#160;</a></span>EvaluatePartial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> EvaluatePartial </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a>, T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>var_values</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute values for some but not necessarily all variables of a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>
<p>Analogous to EvaluateMultivariate, but: (1) Restricted to T, and (2) Need not map every variable in var_values.</p>
<p>Returns a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in which each variable in var_values has been replaced with its value and constants appropriately combined. </p>

</div>
</div>
<a id="a1df25989c473cd56f415001ab45f9ca8" name="a1df25989c473cd56f415001ab45f9ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df25989c473cd56f415001ab45f9ca8">&#9670;&#160;</a></span>EvaluateUnivariate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1_polynomial_1_1_product.html">Product</a>&lt; T, U &gt;::type EvaluateUnivariate </td>
          <td>(</td>
          <td class="paramtype">const U &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>derivative_order</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a univariate <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> at a specific point. </p>
<p>Evaluates a univariate <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> at the given x. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> is not univariate.</td></tr>
  </table>
  </dd>
</dl>
<p><code class="param">x</code> may be of any type supporting the ** and + operations (which can be different from both CoefficientsType and <a class="el" href="#a48c24f8f3b4b14f7e4bb9fbde3748fe8">RealScalar</a>).</p>
<p>This method may also be used for efficient evaluation of the derivatives of the univariate polynomial, evaluated at <code class="param">x</code>. <code class="param">derivative_order</code> = 0 (the default) returns the polynomial value without differentiation. <code class="param">derivative_order</code> = 1 returns the first derivative, etc.</p>
<dl class="section pre"><dt>Precondition</dt><dd>derivative_order must be non-negative. </dd></dl>

</div>
</div>
<a id="ab280606b42c866742fee1c708c6598d9" name="ab280606b42c866742fee1c708c6598d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab280606b42c866742fee1c708c6598d9">&#9670;&#160;</a></span>FromExpression()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; T &gt; FromExpression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">drake::symbolic::Expression</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> representing the symbolic expression <span class="tt">e</span>. </p>
<p>Note that the ID of a variable is preserved in this translation.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <span class="tt">e</span> is not polynomial-convertible. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>e.is_polynomial() is true. </dd></dl>

</div>
</div>
<a id="a9087ceeeacb503464704042fe7bee668" name="a9087ceeeacb503464704042fe7bee668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9087ceeeacb503464704042fe7bee668">&#9670;&#160;</a></span>GetCoefficients()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; GetCoefficients </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vector of the coefficients of the polynomial in the order of powers of the variable - the [i]th element is the coefficient of the variable raised to the ith power. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> is not univariate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d2a0b0dd246af6385d78567af484840" name="a8d2a0b0dd246af6385d78567af484840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2a0b0dd246af6385d78567af484840">&#9670;&#160;</a></span>GetDegree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int GetDegree </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the highest degree of any <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html" title="An additive atom of a Polynomial: The product of any number of Terms and a coefficient.">Monomial</a> in this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>
<p>The degree of a multivariate <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html" title="An additive atom of a Polynomial: The product of any number of Terms and a coefficient.">Monomial</a> is the product of the degrees of each of its terms. </p>

</div>
</div>
<a id="a42c0495deb652146f10152b3db9269b9" name="a42c0495deb652146f10152b3db9269b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c0495deb652146f10152b3db9269b9">&#9670;&#160;</a></span>GetMonomials()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html">Monomial</a> &gt; &amp; GetMonomials </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d04328e0ea4df22f47e1651c706082d" name="a3d04328e0ea4df22f47e1651c706082d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d04328e0ea4df22f47e1651c706082d">&#9670;&#160;</a></span>GetNumberOfCoefficients()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int GetNumberOfCoefficients </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of unique Monomials (and thus the number of coefficients) in this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>

</div>
</div>
<a id="aa3b70bcbd72aedf09e5dad6e5e5d8b9f" name="aa3b70bcbd72aedf09e5dad6e5e5d8b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b70bcbd72aedf09e5dad6e5e5d8b9f">&#9670;&#160;</a></span>GetSimpleVariable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> GetSimpleVariable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the polynomial is "simple" &ndash; e.g. </p>
<p>just a single term with coefficient 1 &ndash; then returns that variable; otherwise returns 0. </p>

</div>
</div>
<a id="afc6a66a1cf630a22d608363877a16c05" name="afc6a66a1cf630a22d608363877a16c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6a66a1cf630a22d608363877a16c05">&#9670;&#160;</a></span>GetVariables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; <a class="el" href="#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> &gt; GetVariables </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a set of all of the variables present in this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>

</div>
</div>
<a id="a96a10bc725a30f1296033f5d26188af1" name="a96a10bc725a30f1296033f5d26188af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a10bc725a30f1296033f5d26188af1">&#9670;&#160;</a></span>IdToVariableName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string IdToVariableName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a03a34972aa2903d7210d0bda55e5c157" name="a03a34972aa2903d7210d0bda55e5c157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a34972aa2903d7210d0bda55e5c157">&#9670;&#160;</a></span>Integral()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> Integral </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>integration_constant</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes the integral of this (univariate, non-constant) <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>
<p>Returns a new <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> that is the indefinite integral of this one in its sole variable. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> is not univariate, or if it has no variables.</td></tr>
  </table>
  </dd>
</dl>
<p>If integration_constant is given, adds that constant as the constant term (zeroth-order coefficient) of the resulting <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>

</div>
</div>
<a id="a50429ee79a9044de390501c26d0f0e23" name="a50429ee79a9044de390501c26d0f0e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50429ee79a9044de390501c26d0f0e23">&#9670;&#160;</a></span>is_univariate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_univariate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this is a univariate polynomial. </p>

</div>
</div>
<a id="a0a83f7960aa020c56d20f435dba4d3cd" name="a0a83f7960aa020c56d20f435dba4d3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a83f7960aa020c56d20f435dba4d3cd">&#9670;&#160;</a></span>IsAffine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool IsAffine </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff this is a sum of terms of degree 1, plus a constant. </p>

</div>
</div>
<a id="ada60946d276f79e555d32badc0d8a91f" name="ada60946d276f79e555d32badc0d8a91f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada60946d276f79e555d32badc0d8a91f">&#9670;&#160;</a></span>IsValidVariableName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IsValidVariableName </td>
          <td>(</td>
          <td class="paramtype">const std::string</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable name/ID conversion facility. </p>

</div>
</div>
<a id="a4fb9d0b2269ab915f93bb26e1fcd7b9f" name="a4fb9d0b2269ab915f93bb26e1fcd7b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb9d0b2269ab915f93bb26e1fcd7b9f">&#9670;&#160;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2d5c3edc702c41343d72562e0604319" name="ae2d5c3edc702c41343d72562e0604319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d5c3edc702c41343d72562e0604319">&#9670;&#160;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb47d0015db17c03c3afd59ebf657b55" name="adb47d0015db17c03c3afd59ebf657b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb47d0015db17c03c3afd59ebf657b55">&#9670;&#160;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0c1c5c8ea58b29b87ca1a7f240c7664" name="aa0c1c5c8ea58b29b87ca1a7f240c7664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c1c5c8ea58b29b87ca1a7f240c7664">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee380f5bef984dd5dcc143a0842eab8b" name="aee380f5bef984dd5dcc143a0842eab8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee380f5bef984dd5dcc143a0842eab8b">&#9670;&#160;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30d8fcbada3c48ba1674f578b34a3de3" name="a30d8fcbada3c48ba1674f578b34a3de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d8fcbada3c48ba1674f578b34a3de3">&#9670;&#160;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93f813cb8ff8e450366e4e2f353bd7e6" name="a93f813cb8ff8e450366e4e2f353bd7e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f813cb8ff8e450366e4e2f353bd7e6">&#9670;&#160;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac86fb56fd075f1c1442883c77f200792" name="ac86fb56fd075f1c1442883c77f200792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86fb56fd075f1c1442883c77f200792">&#9670;&#160;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9a78de8f3161a0c62e383791d11f62f" name="ab9a78de8f3161a0c62e383791d11f62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a78de8f3161a0c62e383791d11f62f">&#9670;&#160;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a910cad1992d7df3505bafeae091e8cb9" name="a910cad1992d7df3505bafeae091e8cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910cad1992d7df3505bafeae091e8cb9">&#9670;&#160;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7443b8380cfcd753611a5b9d91753a2f" name="a7443b8380cfcd753611a5b9d91753a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7443b8380cfcd753611a5b9d91753a2f">&#9670;&#160;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9fcc1a389ccec8efe11cb7adef400616" name="a9fcc1a389ccec8efe11cb7adef400616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fcc1a389ccec8efe11cb7adef400616">&#9670;&#160;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2b38df08e0829d532b692c75e955437" name="aa2b38df08e0829d532b692c75e955437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b38df08e0829d532b692c75e955437">&#9670;&#160;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A comparison to allow std::lexicographical_compare on this class; does not reflect any sort of mathematical total order. </p>

</div>
</div>
<a id="a964d6ac2b576fb2d6963cd7e19109114" name="a964d6ac2b576fb2d6963cd7e19109114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964d6ac2b576fb2d6963cd7e19109114">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a36b55001dc20b0197f226a6f9281adb0" name="a36b55001dc20b0197f226a6f9281adb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b55001dc20b0197f226a6f9281adb0">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> &amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; T &gt; &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaebc4cbcf8fd3bf18645752aaf7ef737" name="aaebc4cbcf8fd3bf18645752aaf7ef737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaebc4cbcf8fd3bf18645752aaf7ef737">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f7703398f420e19d121b92c13e2b416" name="a7f7703398f420e19d121b92c13e2b416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7703398f420e19d121b92c13e2b416">&#9670;&#160;</a></span>Roots()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac85a9dd1caea93fdcdbffd1432f70060">RootsType</a> Roots </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the roots of this (univariate) <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>
<p>Returns the roots of a univariate <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> as an Eigen column vector of complex numbers whose components are of the <a class="el" href="#a48c24f8f3b4b14f7e4bb9fbde3748fe8">RealScalar</a> type. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>of this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> is not univariate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5590d23d37495f26e4e0226674af2436" name="a5590d23d37495f26e4e0226674af2436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5590d23d37495f26e4e0226674af2436">&#9670;&#160;</a></span>Subs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Subs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>orig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>replacement</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all instances of variable orig with replacement. </p>

</div>
</div>
<a id="ad69112ea5f074512671136b4aa3748ee" name="ad69112ea5f074512671136b4aa3748ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69112ea5f074512671136b4aa3748ee">&#9670;&#160;</a></span>Substitute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> Substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>orig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>replacement</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all instances of variable orig with replacement. </p>

</div>
</div>
<a id="aac993ecccd3d88aafefb6b8e3caa1dee" name="aac993ecccd3d88aafefb6b8e3caa1dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac993ecccd3d88aafefb6b8e3caa1dee">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeaeacfff3d087ad400147e605269ad3c" name="aeaeacfff3d087ad400147e605269ad3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaeacfff3d087ad400147e605269ad3c">&#9670;&#160;</a></span>VariableNameToId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> VariableNameToId </td>
          <td>(</td>
          <td class="paramtype">const std::string</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>m</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-related-members" id="doc-related-members"></a><h2 id="header-doc-related-members" class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="aee29171ff87a19fb6b13351d3f23084f" name="aee29171ff87a19fb6b13351d3f23084f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee29171ff87a19fb6b13351d3f23084f">&#9670;&#160;</a></span>operator* <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aebc58e51a6b249b2891f431682ad0749" name="aebc58e51a6b249b2891f431682ad0749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc58e51a6b249b2891f431682ad0749">&#9670;&#160;</a></span>operator* <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b8ee5b634b35a7c4db1cddc532d177c" name="a3b8ee5b634b35a7c4db1cddc532d177c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8ee5b634b35a7c4db1cddc532d177c">&#9670;&#160;</a></span>operator+ <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa14fcd10f0a5683e9778d1ad46b869a6" name="aa14fcd10f0a5683e9778d1ad46b869a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14fcd10f0a5683e9778d1ad46b869a6">&#9670;&#160;</a></span>operator+ <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acf2f5dc8759b0683d649a356e1c23bc8" name="acf2f5dc8759b0683d649a356e1c23bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf2f5dc8759b0683d649a356e1c23bc8">&#9670;&#160;</a></span>operator- <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a30d861d1bfde004747d8a90c6e61e728" name="a30d861d1bfde004747d8a90c6e61e728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d861d1bfde004747d8a90c6e61e728">&#9670;&#160;</a></span>operator- <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abacc19a0640ec7027ded784410817053" name="abacc19a0640ec7027ded784410817053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abacc19a0640ec7027ded784410817053">&#9670;&#160;</a></span>pow</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = double&gt; </div>
<div class="memtemplate">
template&lt;typename U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; U &gt; pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; U &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a>&lt; U &gt;<a class="el" href="#a6b2fc1d3e138053b9dc8864815059fe0">::PowerType</a></td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/common/<a class="el" href="polynomial_8h.html">polynomial.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- footer -->
<div class="navpath">
  <ul>
    <li class="navelem"><a href="namespacedrake.html">drake</a></li><li class="navelem"><a href="classdrake_1_1_polynomial.html">Polynomial</a></li>
  </ul>
</div>
<footer id="nav-path", class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg"/>
    </a>
    <div class="footer-menu">
      <ul>    
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>    
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"/></a>
        </li>
      </ul>
    </div>
  </div>
</footer>
<script type="text/javascript">
searchBox.searchLabel = 'Go to name…';
searchBox.DOMSearchField().placeholder = searchBox.searchLabel;
searchBox.DOMSearchField().value = '';
</script>
</body>
</html>
