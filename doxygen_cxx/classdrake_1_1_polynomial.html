<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: Polynomial&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1_polynomial.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdrake_1_1_polynomial-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Polynomial&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T = double&gt;<br />
class drake::Polynomial&lt; T &gt;</h3>

<p>A scalar multi-variate polynomial, modeled after the msspoly in spotless. </p>
<p><a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> represents a list of additive Monomials, each one of which is a product of a constant coefficient (of T, which by default is double) and any number of distinct Terms (variables raised to positive integer powers).</p>
<p>Variables are identified by integer indices rather than symbolic names, but an automatic facility is provided to covert variable names up to four characters into unique integers, provided those variables are named using only lowercase letters and the "@#_." characters followed by a number. For example, valid names include "dx4" and "m_x".</p>
<p>Monomials which have the same variables and powers may be constructed but will be automatically combined: (3 * a * b * a) + (1.5 * b * a**2) will be reduced to (4.5 * b * a**2) internally after construction.</p>
<p>Polynomials can be added, subtracted, and multiplied. They may only be divided by scalars (of T) because Polynomials are not closed under division.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/common/polynomial.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html">Monomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An additive atom of a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>: The product of any number of Terms and a coefficient.  <a href="classdrake_1_1_polynomial_1_1_monomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1_polynomial_1_1_product.html">Product</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial_1_1_term.html">Term</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An individual variable raised to an integer power; e.g. x**2.  <a href="classdrake_1_1_polynomial_1_1_term.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:adb36a6e938f851b1a5d1a443c2dadb8a"><td class="memItemLeft" align="right" valign="top">typedef unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a></td></tr>
<tr class="separator:adb36a6e938f851b1a5d1a443c2dadb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2fc1d3e138053b9dc8864815059fe0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a6b2fc1d3e138053b9dc8864815059fe0">PowerType</a></td></tr>
<tr class="memdesc:a6b2fc1d3e138053b9dc8864815059fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This should be 'unsigned int' but MSVC considers a call to std::pow(..., unsigned int) ambiguous because it won't cast unsigned int to int.  <a href="#a6b2fc1d3e138053b9dc8864815059fe0">More...</a><br /></td></tr>
<tr class="separator:a6b2fc1d3e138053b9dc8864815059fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c24f8f3b4b14f7e4bb9fbde3748fe8"><td class="memItemLeft" align="right" valign="top">typedef Eigen::NumTraits&lt; T &gt;::Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a48c24f8f3b4b14f7e4bb9fbde3748fe8">RealScalar</a></td></tr>
<tr class="separator:a48c24f8f3b4b14f7e4bb9fbde3748fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b4c054beeae81d6d01bfd5412a89cd"><td class="memItemLeft" align="right" valign="top">typedef std::complex&lt; <a class="el" href="classdrake_1_1_polynomial.html#a48c24f8f3b4b14f7e4bb9fbde3748fe8">RealScalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a81b4c054beeae81d6d01bfd5412a89cd">RootType</a></td></tr>
<tr class="separator:a81b4c054beeae81d6d01bfd5412a89cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85a9dd1caea93fdcdbffd1432f70060"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Matrix&lt; <a class="el" href="classdrake_1_1_polynomial.html#a81b4c054beeae81d6d01bfd5412a89cd">RootType</a>, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#ac85a9dd1caea93fdcdbffd1432f70060">RootsType</a></td></tr>
<tr class="separator:ac85a9dd1caea93fdcdbffd1432f70060"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a925044e356137ea2d1ee6af62fea4156"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a925044e356137ea2d1ee6af62fea4156">Polynomial</a> (void)</td></tr>
<tr class="memdesc:a925044e356137ea2d1ee6af62fea4156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the vacuous polynomial, "0".  <a href="#a925044e356137ea2d1ee6af62fea4156">More...</a><br /></td></tr>
<tr class="separator:a925044e356137ea2d1ee6af62fea4156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4e320eb4e56b74c4e212067ae9fbf0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a2f4e320eb4e56b74c4e212067ae9fbf0">Polynomial</a> (const T &amp;scalar)</td></tr>
<tr class="memdesc:a2f4e320eb4e56b74c4e212067ae9fbf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> of a single constant. e.g. "5".  <a href="#a2f4e320eb4e56b74c4e212067ae9fbf0">More...</a><br /></td></tr>
<tr class="separator:a2f4e320eb4e56b74c4e212067ae9fbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113f39750edd840d2f269940e5ca1cb6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a113f39750edd840d2f269940e5ca1cb6">Polynomial</a> (const T coeff, const std::vector&lt; <a class="el" href="classdrake_1_1_polynomial_1_1_term.html">Term</a> &gt; &amp;terms)</td></tr>
<tr class="memdesc:a113f39750edd840d2f269940e5ca1cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> consisting of a single <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html" title="An additive atom of a Polynomial: The product of any number of Terms and a coefficient.">Monomial</a>, e.g. "5xy**3".  <a href="#a113f39750edd840d2f269940e5ca1cb6">More...</a><br /></td></tr>
<tr class="separator:a113f39750edd840d2f269940e5ca1cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb80fce8585dd54f26ea753fb3fa4ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#afcb80fce8585dd54f26ea753fb3fa4ac">Polynomial</a> (typename std::vector&lt; <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html">Monomial</a> &gt;::const_iterator start, typename std::vector&lt; <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html">Monomial</a> &gt;::const_iterator finish)</td></tr>
<tr class="memdesc:afcb80fce8585dd54f26ea753fb3fa4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> from a sequence of Monomials.  <a href="#afcb80fce8585dd54f26ea753fb3fa4ac">More...</a><br /></td></tr>
<tr class="separator:afcb80fce8585dd54f26ea753fb3fa4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d984c6a3f814a0cfe120febe762139"><td class="memTemplParams" colspan="2">template&lt;typename U  = T&gt; </td></tr>
<tr class="memitem:ab2d984c6a3f814a0cfe120febe762139"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#ab2d984c6a3f814a0cfe120febe762139">Polynomial</a> (const std::enable_if_t&lt; std::is_same_v&lt; U, double &gt;, std::string &gt; &amp;varname)</td></tr>
<tr class="memdesc:ab2d984c6a3f814a0cfe120febe762139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a polynomial consisting of a single <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html" title="An additive atom of a Polynomial: The product of any number of Terms and a coefficient.">Monomial</a> of the variable named <code>varname1</code>.  <a href="#ab2d984c6a3f814a0cfe120febe762139">More...</a><br /></td></tr>
<tr class="separator:ab2d984c6a3f814a0cfe120febe762139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f5130d25206fac74ef07d81bf8ec23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#ab0f5130d25206fac74ef07d81bf8ec23">Polynomial</a> (const std::string &amp;varname, unsigned <a class="el" href="classint.html">int</a> num)</td></tr>
<tr class="memdesc:ab0f5130d25206fac74ef07d81bf8ec23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a polynomial consisting of a single <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html" title="An additive atom of a Polynomial: The product of any number of Terms and a coefficient.">Monomial</a> of the variable named varname + num.  <a href="#ab0f5130d25206fac74ef07d81bf8ec23">More...</a><br /></td></tr>
<tr class="separator:ab0f5130d25206fac74ef07d81bf8ec23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1a539c279243b61fdc12c6cfeaed57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a5d1a539c279243b61fdc12c6cfeaed57">Polynomial</a> (const T &amp;coeff, const <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> &amp;v)</td></tr>
<tr class="memdesc:a5d1a539c279243b61fdc12c6cfeaed57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a single <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html" title="An additive atom of a Polynomial: The product of any number of Terms and a coefficient.">Monomial</a> of the given coefficient and variable.  <a href="#a5d1a539c279243b61fdc12c6cfeaed57">More...</a><br /></td></tr>
<tr class="separator:a5d1a539c279243b61fdc12c6cfeaed57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadeb111fed29f32b77bc86e66356b7c"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:adadeb111fed29f32b77bc86e66356b7c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#adadeb111fed29f32b77bc86e66356b7c">Polynomial</a> (Eigen::MatrixBase&lt; Derived &gt; const &amp;coefficients)</td></tr>
<tr class="memdesc:adadeb111fed29f32b77bc86e66356b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A legacy constructor for univariate polynomials: Takes a vector of coefficients for the constant, x, x**2, x**3...  <a href="#adadeb111fed29f32b77bc86e66356b7c">More...</a><br /></td></tr>
<tr class="separator:adadeb111fed29f32b77bc86e66356b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d04328e0ea4df22f47e1651c706082d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a3d04328e0ea4df22f47e1651c706082d">GetNumberOfCoefficients</a> () const</td></tr>
<tr class="memdesc:a3d04328e0ea4df22f47e1651c706082d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of unique Monomials (and thus the number of coefficients) in this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>.  <a href="#a3d04328e0ea4df22f47e1651c706082d">More...</a><br /></td></tr>
<tr class="separator:a3d04328e0ea4df22f47e1651c706082d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2a0b0dd246af6385d78567af484840"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a8d2a0b0dd246af6385d78567af484840">GetDegree</a> () const</td></tr>
<tr class="memdesc:a8d2a0b0dd246af6385d78567af484840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest degree of any <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html" title="An additive atom of a Polynomial: The product of any number of Terms and a coefficient.">Monomial</a> in this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>.  <a href="#a8d2a0b0dd246af6385d78567af484840">More...</a><br /></td></tr>
<tr class="separator:a8d2a0b0dd246af6385d78567af484840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a83f7960aa020c56d20f435dba4d3cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a0a83f7960aa020c56d20f435dba4d3cd">IsAffine</a> () const</td></tr>
<tr class="memdesc:a0a83f7960aa020c56d20f435dba4d3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff this is a sum of terms of degree 1, plus a constant.  <a href="#a0a83f7960aa020c56d20f435dba4d3cd">More...</a><br /></td></tr>
<tr class="separator:a0a83f7960aa020c56d20f435dba4d3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b70bcbd72aedf09e5dad6e5e5d8b9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#aa3b70bcbd72aedf09e5dad6e5e5d8b9f">GetSimpleVariable</a> () const</td></tr>
<tr class="memdesc:aa3b70bcbd72aedf09e5dad6e5e5d8b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the polynomial is "simple" &ndash; e.g.  <a href="#aa3b70bcbd72aedf09e5dad6e5e5d8b9f">More...</a><br /></td></tr>
<tr class="separator:aa3b70bcbd72aedf09e5dad6e5e5d8b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb360c5667c073fe8f1b8a1271e56ba"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html">Monomial</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a3cb360c5667c073fe8f1b8a1271e56ba">GetMonomials</a> () const</td></tr>
<tr class="separator:a3cb360c5667c073fe8f1b8a1271e56ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6473058f53a0de07ff25ee02988aefea"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a6473058f53a0de07ff25ee02988aefea">GetCoefficients</a> () const</td></tr>
<tr class="separator:a6473058f53a0de07ff25ee02988aefea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f06a2189317404f196cec68b81fac4"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#ac8f06a2189317404f196cec68b81fac4">GetVariables</a> () const</td></tr>
<tr class="memdesc:ac8f06a2189317404f196cec68b81fac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a set of all of the variables present in this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>.  <a href="#ac8f06a2189317404f196cec68b81fac4">More...</a><br /></td></tr>
<tr class="separator:ac8f06a2189317404f196cec68b81fac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270da73b23ef39efde1f1848d6349434"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a270da73b23ef39efde1f1848d6349434"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1_polynomial_1_1_product.html">Product</a>&lt; T, U &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a270da73b23ef39efde1f1848d6349434">EvaluateUnivariate</a> (const U &amp;x, <a class="el" href="classint.html">int</a> derivative_order=0) const</td></tr>
<tr class="memdesc:a270da73b23ef39efde1f1848d6349434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a univariate <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> at a specific point.  <a href="#a270da73b23ef39efde1f1848d6349434">More...</a><br /></td></tr>
<tr class="separator:a270da73b23ef39efde1f1848d6349434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ba53803e4244c1878ed9ad381854a7"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a96ba53803e4244c1878ed9ad381854a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1_polynomial_1_1_product.html">Product</a>&lt; T, U &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a96ba53803e4244c1878ed9ad381854a7">EvaluateMultivariate</a> (const std::map&lt; <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a>, U &gt; &amp;var_values) const</td></tr>
<tr class="memdesc:a96ba53803e4244c1878ed9ad381854a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a multivariate <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> at a specific point.  <a href="#a96ba53803e4244c1878ed9ad381854a7">More...</a><br /></td></tr>
<tr class="separator:a96ba53803e4244c1878ed9ad381854a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981a524ccda4902bff9380c48fd2714a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a981a524ccda4902bff9380c48fd2714a">EvaluatePartial</a> (const std::map&lt; <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a>, T &gt; &amp;var_values) const</td></tr>
<tr class="memdesc:a981a524ccda4902bff9380c48fd2714a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute values for some but not necessarily all variables of a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>.  <a href="#a981a524ccda4902bff9380c48fd2714a">More...</a><br /></td></tr>
<tr class="separator:a981a524ccda4902bff9380c48fd2714a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5590d23d37495f26e4e0226674af2436"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a5590d23d37495f26e4e0226674af2436">Subs</a> (const <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> &amp;orig, const <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> &amp;replacement)</td></tr>
<tr class="memdesc:a5590d23d37495f26e4e0226674af2436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all instances of variable orig with replacement.  <a href="#a5590d23d37495f26e4e0226674af2436">More...</a><br /></td></tr>
<tr class="separator:a5590d23d37495f26e4e0226674af2436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69112ea5f074512671136b4aa3748ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#ad69112ea5f074512671136b4aa3748ee">Substitute</a> (const <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> &amp;orig, const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;replacement) const</td></tr>
<tr class="memdesc:ad69112ea5f074512671136b4aa3748ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all instances of variable orig with replacement.  <a href="#ad69112ea5f074512671136b4aa3748ee">More...</a><br /></td></tr>
<tr class="separator:ad69112ea5f074512671136b4aa3748ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c8fa5ca0a531f3bfc388ba5b13f6c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#ae1c8fa5ca0a531f3bfc388ba5b13f6c8">Derivative</a> (<a class="el" href="classint.html">int</a> derivative_order=1) const</td></tr>
<tr class="memdesc:ae1c8fa5ca0a531f3bfc388ba5b13f6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes the derivative of this (univariate) <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>.  <a href="#ae1c8fa5ca0a531f3bfc388ba5b13f6c8">More...</a><br /></td></tr>
<tr class="separator:ae1c8fa5ca0a531f3bfc388ba5b13f6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a34972aa2903d7210d0bda55e5c157"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a03a34972aa2903d7210d0bda55e5c157">Integral</a> (const T &amp;integration_constant=0.0) const</td></tr>
<tr class="memdesc:a03a34972aa2903d7210d0bda55e5c157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes the integral of this (univariate, non-constant) <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>.  <a href="#a03a34972aa2903d7210d0bda55e5c157">More...</a><br /></td></tr>
<tr class="separator:a03a34972aa2903d7210d0bda55e5c157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebc4cbcf8fd3bf18645752aaf7ef737"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#aaebc4cbcf8fd3bf18645752aaf7ef737">operator==</a> (const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;other) const</td></tr>
<tr class="separator:aaebc4cbcf8fd3bf18645752aaf7ef737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349fd2f5f3296a57e503bf9f2f25bc55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a349fd2f5f3296a57e503bf9f2f25bc55">operator+=</a> (const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;other)</td></tr>
<tr class="separator:a349fd2f5f3296a57e503bf9f2f25bc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56dea1c182be53c20a023d0491bd232c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a56dea1c182be53c20a023d0491bd232c">operator-=</a> (const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;other)</td></tr>
<tr class="separator:a56dea1c182be53c20a023d0491bd232c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b48b4297791d2a4f9cbb45f14ed94c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a0b48b4297791d2a4f9cbb45f14ed94c7">operator *=</a> (const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;other)</td></tr>
<tr class="separator:a0b48b4297791d2a4f9cbb45f14ed94c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b60c8127846337517b619abdbebb9ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a9b60c8127846337517b619abdbebb9ab">operator+=</a> (const T &amp;scalar)</td></tr>
<tr class="separator:a9b60c8127846337517b619abdbebb9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5f08c6ad942153599928b9c7f9d0fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#abe5f08c6ad942153599928b9c7f9d0fa">operator-=</a> (const T &amp;scalar)</td></tr>
<tr class="separator:abe5f08c6ad942153599928b9c7f9d0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91ac7cbc8938ee546f9db5317b4a479"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#ac91ac7cbc8938ee546f9db5317b4a479">operator *=</a> (const T &amp;scalar)</td></tr>
<tr class="separator:ac91ac7cbc8938ee546f9db5317b4a479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30704361ad1820a0a54f5127830d92a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#ab30704361ad1820a0a54f5127830d92a">operator/=</a> (const T &amp;scalar)</td></tr>
<tr class="separator:ab30704361ad1820a0a54f5127830d92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c1c5c8ea58b29b87ca1a7f240c7664"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#aa0c1c5c8ea58b29b87ca1a7f240c7664">operator+</a> (const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;other) const</td></tr>
<tr class="separator:aa0c1c5c8ea58b29b87ca1a7f240c7664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86fb56fd075f1c1442883c77f200792"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#ac86fb56fd075f1c1442883c77f200792">operator-</a> (const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;other) const</td></tr>
<tr class="separator:ac86fb56fd075f1c1442883c77f200792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f813cb8ff8e450366e4e2f353bd7e6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a93f813cb8ff8e450366e4e2f353bd7e6">operator-</a> () const</td></tr>
<tr class="separator:a93f813cb8ff8e450366e4e2f353bd7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9756e806e687de4b2e572193034a9fc1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a9756e806e687de4b2e572193034a9fc1">operator *</a> (const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;other) const</td></tr>
<tr class="separator:a9756e806e687de4b2e572193034a9fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7443b8380cfcd753611a5b9d91753a2f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a7443b8380cfcd753611a5b9d91753a2f">operator/</a> (const T &amp;scalar) const</td></tr>
<tr class="separator:a7443b8380cfcd753611a5b9d91753a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b38df08e0829d532b692c75e955437"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#aa2b38df08e0829d532b692c75e955437">operator&lt;</a> (const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;other) const</td></tr>
<tr class="memdesc:aa2b38df08e0829d532b692c75e955437"><td class="mdescLeft">&#160;</td><td class="mdescRight">A comparison to allow std::lexicographical_compare on this class; does not reflect any sort of mathematical total order.  <a href="#aa2b38df08e0829d532b692c75e955437">More...</a><br /></td></tr>
<tr class="separator:aa2b38df08e0829d532b692c75e955437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7703398f420e19d121b92c13e2b416"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1_polynomial.html#ac85a9dd1caea93fdcdbffd1432f70060">RootsType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a7f7703398f420e19d121b92c13e2b416">Roots</a> () const</td></tr>
<tr class="memdesc:a7f7703398f420e19d121b92c13e2b416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the roots of this (univariate) <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>.  <a href="#a7f7703398f420e19d121b92c13e2b416">More...</a><br /></td></tr>
<tr class="separator:a7f7703398f420e19d121b92c13e2b416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cf4226b2a620c6cbe8d4f953de0891"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a11cf4226b2a620c6cbe8d4f953de0891">CoefficientsAlmostEqual</a> (const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;other, const <a class="el" href="classdrake_1_1_polynomial.html#a48c24f8f3b4b14f7e4bb9fbde3748fe8">RealScalar</a> &amp;tol=0.0, const <a class="el" href="namespacedrake.html#af8777bc10296f9d39d52753861110e26">ToleranceType</a> &amp;tol_type=<a class="el" href="namespacedrake.html#af8777bc10296f9d39d52753861110e26abab0767e88027de9944aa55c24c8387a">ToleranceType::kAbsolute</a>) const</td></tr>
<tr class="memdesc:a11cf4226b2a620c6cbe8d4f953de0891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> is approximately equal to this one.  <a href="#a11cf4226b2a620c6cbe8d4f953de0891">More...</a><br /></td></tr>
<tr class="separator:a11cf4226b2a620c6cbe8d4f953de0891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:ad4fc8f2e6a67575f78cb74e9163fd5e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#ad4fc8f2e6a67575f78cb74e9163fd5e3">Polynomial</a> (const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;)=default</td></tr>
<tr class="separator:ad4fc8f2e6a67575f78cb74e9163fd5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab168243ddedae6540dc7fe18e0fd6f53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#ab168243ddedae6540dc7fe18e0fd6f53">operator=</a> (const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;)=default</td></tr>
<tr class="separator:ab168243ddedae6540dc7fe18e0fd6f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa280c0fba0d2e78def19c2d4827f6733"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#aa280c0fba0d2e78def19c2d4827f6733">Polynomial</a> (<a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;&amp;)=default</td></tr>
<tr class="separator:aa280c0fba0d2e78def19c2d4827f6733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeaa4f722744d397b42ff26f50f443bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#adeaa4f722744d397b42ff26f50f443bf">operator=</a> (<a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;&amp;)=default</td></tr>
<tr class="separator:adeaa4f722744d397b42ff26f50f443bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a38f4b1afcc5a0f495caad64cbf8688d3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a38f4b1afcc5a0f495caad64cbf8688d3">FromExpression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">drake::symbolic::Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a38f4b1afcc5a0f495caad64cbf8688d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> representing the symbolic expression <code>e</code>.  <a href="#a38f4b1afcc5a0f495caad64cbf8688d3">More...</a><br /></td></tr>
<tr class="separator:a38f4b1afcc5a0f495caad64cbf8688d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ada60946d276f79e555d32badc0d8a91f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#ada60946d276f79e555d32badc0d8a91f">IsValidVariableName</a> (const std::string name)</td></tr>
<tr class="memdesc:ada60946d276f79e555d32badc0d8a91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable name/ID conversion facility.  <a href="#ada60946d276f79e555d32badc0d8a91f">More...</a><br /></td></tr>
<tr class="separator:ada60946d276f79e555d32badc0d8a91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaeacfff3d087ad400147e605269ad3c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#aeaeacfff3d087ad400147e605269ad3c">VariableNameToId</a> (const std::string name, unsigned <a class="el" href="classint.html">int</a> m=1)</td></tr>
<tr class="separator:aeaeacfff3d087ad400147e605269ad3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a10bc725a30f1296033f5d26188af1"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a96a10bc725a30f1296033f5d26188af1">IdToVariableName</a> (const <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> id)</td></tr>
<tr class="separator:a96a10bc725a30f1296033f5d26188af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3b8ee5b634b35a7c4db1cddc532d177c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a3b8ee5b634b35a7c4db1cddc532d177c">operator+</a> (const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;p, const T &amp;scalar)</td></tr>
<tr class="separator:a3b8ee5b634b35a7c4db1cddc532d177c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14fcd10f0a5683e9778d1ad46b869a6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#aa14fcd10f0a5683e9778d1ad46b869a6">operator+</a> (const T &amp;scalar, const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:aa14fcd10f0a5683e9778d1ad46b869a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2f5dc8759b0683d649a356e1c23bc8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#acf2f5dc8759b0683d649a356e1c23bc8">operator-</a> (const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;p, const T &amp;scalar)</td></tr>
<tr class="separator:acf2f5dc8759b0683d649a356e1c23bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d861d1bfde004747d8a90c6e61e728"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a30d861d1bfde004747d8a90c6e61e728">operator-</a> (const T &amp;scalar, const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:a30d861d1bfde004747d8a90c6e61e728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0839a4ea39ab4780de70e5913107d6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a9e0839a4ea39ab4780de70e5913107d6">operator *</a> (const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;p, const T &amp;scalar)</td></tr>
<tr class="separator:a9e0839a4ea39ab4780de70e5913107d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2987c7f3ad9e1181254639ea91939d9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#aa2987c7f3ad9e1181254639ea91939d9">operator *</a> (const T &amp;scalar, const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:aa2987c7f3ad9e1181254639ea91939d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd692da2aab783313611876753b0b3f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a3dd692da2aab783313611876753b0b3f">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:a3dd692da2aab783313611876753b0b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268b9f8605e7fc2cca049db6c64182cf"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a268b9f8605e7fc2cca049db6c64182cf">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> &amp;poly)</td></tr>
<tr class="separator:a268b9f8605e7fc2cca049db6c64182cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2144bf3acf165a2a921d7df87ac4eafe"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a2144bf3acf165a2a921d7df87ac4eafe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1_polynomial.html#a2144bf3acf165a2a921d7df87ac4eafe">pow</a> (const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; U &gt; &amp;p, typename <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; U &gt;::<a class="el" href="classdrake_1_1_polynomial.html#a6b2fc1d3e138053b9dc8864815059fe0">PowerType</a> n)</td></tr>
<tr class="separator:a2144bf3acf165a2a921d7df87ac4eafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a6b2fc1d3e138053b9dc8864815059fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2fc1d3e138053b9dc8864815059fe0">&#9670;&nbsp;</a></span>PowerType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classint.html">int</a> <a class="el" href="classdrake_1_1_polynomial.html#a6b2fc1d3e138053b9dc8864815059fe0">PowerType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This should be 'unsigned int' but MSVC considers a call to std::pow(..., unsigned int) ambiguous because it won't cast unsigned int to int. </p>

</div>
</div>
<a id="a48c24f8f3b4b14f7e4bb9fbde3748fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c24f8f3b4b14f7e4bb9fbde3748fe8">&#9670;&nbsp;</a></span>RealScalar</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::NumTraits&lt;T&gt;::Real <a class="el" href="classdrake_1_1_polynomial.html#a48c24f8f3b4b14f7e4bb9fbde3748fe8">RealScalar</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac85a9dd1caea93fdcdbffd1432f70060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85a9dd1caea93fdcdbffd1432f70060">&#9670;&nbsp;</a></span>RootsType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Matrix&lt;<a class="el" href="classdrake_1_1_polynomial.html#a81b4c054beeae81d6d01bfd5412a89cd">RootType</a>, Eigen::Dynamic, 1&gt; <a class="el" href="classdrake_1_1_polynomial.html#ac85a9dd1caea93fdcdbffd1432f70060">RootsType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81b4c054beeae81d6d01bfd5412a89cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b4c054beeae81d6d01bfd5412a89cd">&#9670;&nbsp;</a></span>RootType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::complex&lt;<a class="el" href="classdrake_1_1_polynomial.html#a48c24f8f3b4b14f7e4bb9fbde3748fe8">RealScalar</a>&gt; <a class="el" href="classdrake_1_1_polynomial.html#a81b4c054beeae81d6d01bfd5412a89cd">RootType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb36a6e938f851b1a5d1a443c2dadb8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb36a6e938f851b1a5d1a443c2dadb8a">&#9670;&nbsp;</a></span>VarType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad4fc8f2e6a67575f78cb74e9163fd5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4fc8f2e6a67575f78cb74e9163fd5e3">&#9670;&nbsp;</a></span>Polynomial() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa280c0fba0d2e78def19c2d4827f6733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa280c0fba0d2e78def19c2d4827f6733">&#9670;&nbsp;</a></span>Polynomial() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a925044e356137ea2d1ee6af62fea4156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925044e356137ea2d1ee6af62fea4156">&#9670;&nbsp;</a></span>Polynomial() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the vacuous polynomial, "0". </p>

</div>
</div>
<a id="a2f4e320eb4e56b74c4e212067ae9fbf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4e320eb4e56b74c4e212067ae9fbf0">&#9670;&nbsp;</a></span>Polynomial() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> of a single constant. e.g. "5". </p>

</div>
</div>
<a id="a113f39750edd840d2f269940e5ca1cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113f39750edd840d2f269940e5ca1cb6">&#9670;&nbsp;</a></span>Polynomial() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1_polynomial_1_1_term.html">Term</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>terms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> consisting of a single <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html" title="An additive atom of a Polynomial: The product of any number of Terms and a coefficient.">Monomial</a>, e.g. "5xy**3". </p>

</div>
</div>
<a id="afcb80fce8585dd54f26ea753fb3fa4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb80fce8585dd54f26ea753fb3fa4ac">&#9670;&nbsp;</a></span>Polynomial() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> </td>
          <td>(</td>
          <td class="paramtype">typename std::vector&lt; <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html">Monomial</a> &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::vector&lt; <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html">Monomial</a> &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>finish</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> from a sequence of Monomials. </p>

</div>
</div>
<a id="ab2d984c6a3f814a0cfe120febe762139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d984c6a3f814a0cfe120febe762139">&#9670;&nbsp;</a></span>Polynomial() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> </td>
          <td>(</td>
          <td class="paramtype">const std::enable_if_t&lt; std::is_same_v&lt; U, double &gt;, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>varname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a polynomial consisting of a single <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html" title="An additive atom of a Polynomial: The product of any number of Terms and a coefficient.">Monomial</a> of the variable named <code>varname1</code>. </p>
<dl class="section note"><dt>Note</dt><dd>: This constructor is only provided for T = double. For the other cases, a user should use the constructor with two arguments below (taking std::string and unsigned int). If we provided this constructor for T = AutoDiffXd and T = <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">symbolic::Expression</a>, there would be compiler errors for <code><a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>&lt;T&gt;(0)</code> as the following candidates are ambiguous:<ul>
<li><a class="el" href="classdrake_1_1_polynomial.html#a2f4e320eb4e56b74c4e212067ae9fbf0" title="Construct a Polynomial of a single constant. e.g. &quot;5&quot;.">Polynomial(const T&amp; scalar)</a></li>
<li><a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>(const std::string&amp; varname, const unsigned int num = 1) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab0f5130d25206fac74ef07d81bf8ec23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f5130d25206fac74ef07d81bf8ec23">&#9670;&nbsp;</a></span>Polynomial() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>varname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a polynomial consisting of a single <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html" title="An additive atom of a Polynomial: The product of any number of Terms and a coefficient.">Monomial</a> of the variable named varname + num. </p>

</div>
</div>
<a id="a5d1a539c279243b61fdc12c6cfeaed57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1a539c279243b61fdc12c6cfeaed57">&#9670;&nbsp;</a></span>Polynomial() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a single <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html" title="An additive atom of a Polynomial: The product of any number of Terms and a coefficient.">Monomial</a> of the given coefficient and variable. </p>

</div>
</div>
<a id="adadeb111fed29f32b77bc86e66356b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adadeb111fed29f32b77bc86e66356b7c">&#9670;&nbsp;</a></span>Polynomial() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; Derived &gt; const &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A legacy constructor for univariate polynomials: Takes a vector of coefficients for the constant, x, x**2, x**3... </p>
<p>Monomials. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a11cf4226b2a620c6cbe8d4f953de0891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11cf4226b2a620c6cbe8d4f953de0891">&#9670;&nbsp;</a></span>CoefficientsAlmostEqual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a1f1c657c4d2cf400649123a7c2573d5b">boolean</a>&lt;T&gt; CoefficientsAlmostEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html#a48c24f8f3b4b14f7e4bb9fbde3748fe8">RealScalar</a> &amp;&#160;</td>
          <td class="paramname"><em>tol</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#af8777bc10296f9d39d52753861110e26">ToleranceType</a> &amp;&#160;</td>
          <td class="paramname"><em>tol_type</em> = <code><a class="el" href="namespacedrake.html#af8777bc10296f9d39d52753861110e26abab0767e88027de9944aa55c24c8387a">ToleranceType::kAbsolute</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> is approximately equal to this one. </p>
<p>Checks that every coefficient of <code>other</code> is within <code>tol</code> of the corresponding coefficient of this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>.</p>
<p>Note: When <code>tol_type</code> is kRelative, if any monomials appear in <code>this</code> or <code>other</code> but not both, then the method returns false (since the comparison is relative to a missing zero coefficient). Use kAbsolute if you want to ignore non-matching monomials with coefficients less than <code>tol</code>. </p>

</div>
</div>
<a id="ae1c8fa5ca0a531f3bfc388ba5b13f6c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c8fa5ca0a531f3bfc388ba5b13f6c8">&#9670;&nbsp;</a></span>Derivative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> Derivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>derivative_order</em> = <code>1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes the derivative of this (univariate) <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>
<p>Returns a new <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> that is the derivative of this one in its sole variable. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> is not univariate.</td></tr>
  </table>
  </dd>
</dl>
<p>If derivative_order is given, takes the nth derivative of this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>

</div>
</div>
<a id="a96ba53803e4244c1878ed9ad381854a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ba53803e4244c1878ed9ad381854a7">&#9670;&nbsp;</a></span>EvaluateMultivariate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1_polynomial_1_1_product.html">Product</a>&lt;T, U&gt;::type EvaluateMultivariate </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a>, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>var_values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a multivariate <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> at a specific point. </p>
<p>Evaluates a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> with the given values for each variable. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> contains variables for which values were not provided.</td></tr>
  </table>
  </dd>
</dl>
<p>The provided values may be of any type which is std::is_arithmetic (supporting the std::pow, *, and + operations) and need not be CoefficientsType or RealScalar) </p>

</div>
</div>
<a id="a981a524ccda4902bff9380c48fd2714a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981a524ccda4902bff9380c48fd2714a">&#9670;&nbsp;</a></span>EvaluatePartial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> EvaluatePartial </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a>, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>var_values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute values for some but not necessarily all variables of a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>
<p>Analogous to EvaluateMultivariate, but: (1) Restricted to T, and (2) Need not map every variable in var_values.</p>
<p>Returns a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> in which each variable in var_values has been replaced with its value and constants appropriately combined. </p>

</div>
</div>
<a id="a270da73b23ef39efde1f1848d6349434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a270da73b23ef39efde1f1848d6349434">&#9670;&nbsp;</a></span>EvaluateUnivariate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1_polynomial_1_1_product.html">Product</a>&lt;T, U&gt;::type EvaluateUnivariate </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>derivative_order</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a univariate <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> at a specific point. </p>
<p>Evaluates a univariate <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> at the given x. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> is not univariate.</td></tr>
  </table>
  </dd>
</dl>
<p><code>x</code> may be of any type supporting the ** and + operations (which can be different from both CoefficientsType and RealScalar).</p>
<p>This method may also be used for efficient evaluation of the derivatives of the univariate polynomial, evaluated at <code>x</code>. <code>derivative_order</code> = 0 (the default) returns the polynomial value without differentiation. <code>derivative_order</code> = 1 returns the first derivative, etc.</p>
<dl class="section pre"><dt>Precondition</dt><dd>derivative_order must be non-negative. </dd></dl>

</div>
</div>
<a id="a38f4b1afcc5a0f495caad64cbf8688d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f4b1afcc5a0f495caad64cbf8688d3">&#9670;&nbsp;</a></span>FromExpression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt;T&gt; FromExpression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">drake::symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> representing the symbolic expression <code>e</code>. </p>
<p>Note that the ID of a variable is preserved in this translation.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>e</code> is not polynomial-convertible. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>e.is_polynomial() is true. </dd></dl>

</div>
</div>
<a id="a6473058f53a0de07ff25ee02988aefea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6473058f53a0de07ff25ee02988aefea">&#9670;&nbsp;</a></span>GetCoefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; GetCoefficients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d2a0b0dd246af6385d78567af484840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2a0b0dd246af6385d78567af484840">&#9670;&nbsp;</a></span>GetDegree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> GetDegree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the highest degree of any <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html" title="An additive atom of a Polynomial: The product of any number of Terms and a coefficient.">Monomial</a> in this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>
<p>The degree of a multivariate <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html" title="An additive atom of a Polynomial: The product of any number of Terms and a coefficient.">Monomial</a> is the product of the degrees of each of its terms. </p>

</div>
</div>
<a id="a3cb360c5667c073fe8f1b8a1271e56ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb360c5667c073fe8f1b8a1271e56ba">&#9670;&nbsp;</a></span>GetMonomials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html">Monomial</a>&gt;&amp; GetMonomials </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d04328e0ea4df22f47e1651c706082d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d04328e0ea4df22f47e1651c706082d">&#9670;&nbsp;</a></span>GetNumberOfCoefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> GetNumberOfCoefficients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of unique Monomials (and thus the number of coefficients) in this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>

</div>
</div>
<a id="aa3b70bcbd72aedf09e5dad6e5e5d8b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b70bcbd72aedf09e5dad6e5e5d8b9f">&#9670;&nbsp;</a></span>GetSimpleVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> GetSimpleVariable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the polynomial is "simple" &ndash; e.g. </p>
<p>just a single term with coefficient 1 &ndash; then returns that variable; otherwise returns 0. </p>

</div>
</div>
<a id="ac8f06a2189317404f196cec68b81fac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f06a2189317404f196cec68b81fac4">&#9670;&nbsp;</a></span>GetVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a>&gt; GetVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a set of all of the variables present in this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>

</div>
</div>
<a id="a96a10bc725a30f1296033f5d26188af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a10bc725a30f1296033f5d26188af1">&#9670;&nbsp;</a></span>IdToVariableName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string IdToVariableName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a03a34972aa2903d7210d0bda55e5c157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a34972aa2903d7210d0bda55e5c157">&#9670;&nbsp;</a></span>Integral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> Integral </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>integration_constant</em> = <code>0.0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes the integral of this (univariate, non-constant) <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>
<p>Returns a new <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> that is the indefinite integral of this one in its sole variable. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> is not univariate, or if it has no variables.</td></tr>
  </table>
  </dd>
</dl>
<p>If integration_constant is given, adds that constant as the constant term (zeroth-order coefficient) of the resulting <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>

</div>
</div>
<a id="a0a83f7960aa020c56d20f435dba4d3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a83f7960aa020c56d20f435dba4d3cd">&#9670;&nbsp;</a></span>IsAffine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsAffine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff this is a sum of terms of degree 1, plus a constant. </p>

</div>
</div>
<a id="ada60946d276f79e555d32badc0d8a91f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada60946d276f79e555d32badc0d8a91f">&#9670;&nbsp;</a></span>IsValidVariableName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool IsValidVariableName </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variable name/ID conversion facility. </p>

</div>
</div>
<a id="a9756e806e687de4b2e572193034a9fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9756e806e687de4b2e572193034a9fc1">&#9670;&nbsp;</a></span>operator *()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b48b4297791d2a4f9cbb45f14ed94c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b48b4297791d2a4f9cbb45f14ed94c7">&#9670;&nbsp;</a></span>operator *=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&amp; operator *= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac91ac7cbc8938ee546f9db5317b4a479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91ac7cbc8938ee546f9db5317b4a479">&#9670;&nbsp;</a></span>operator *=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&amp; operator *= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0c1c5c8ea58b29b87ca1a7f240c7664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c1c5c8ea58b29b87ca1a7f240c7664">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a349fd2f5f3296a57e503bf9f2f25bc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a349fd2f5f3296a57e503bf9f2f25bc55">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b60c8127846337517b619abdbebb9ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b60c8127846337517b619abdbebb9ab">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac86fb56fd075f1c1442883c77f200792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86fb56fd075f1c1442883c77f200792">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93f813cb8ff8e450366e4e2f353bd7e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f813cb8ff8e450366e4e2f353bd7e6">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56dea1c182be53c20a023d0491bd232c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56dea1c182be53c20a023d0491bd232c">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe5f08c6ad942153599928b9c7f9d0fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5f08c6ad942153599928b9c7f9d0fa">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7443b8380cfcd753611a5b9d91753a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7443b8380cfcd753611a5b9d91753a2f">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab30704361ad1820a0a54f5127830d92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30704361ad1820a0a54f5127830d92a">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2b38df08e0829d532b692c75e955437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b38df08e0829d532b692c75e955437">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A comparison to allow std::lexicographical_compare on this class; does not reflect any sort of mathematical total order. </p>

</div>
</div>
<a id="adeaa4f722744d397b42ff26f50f443bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeaa4f722744d397b42ff26f50f443bf">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab168243ddedae6540dc7fe18e0fd6f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab168243ddedae6540dc7fe18e0fd6f53">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaebc4cbcf8fd3bf18645752aaf7ef737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaebc4cbcf8fd3bf18645752aaf7ef737">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f7703398f420e19d121b92c13e2b416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7703398f420e19d121b92c13e2b416">&#9670;&nbsp;</a></span>Roots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html#ac85a9dd1caea93fdcdbffd1432f70060">RootsType</a> Roots </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the roots of this (univariate) <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a>. </p>
<p>Returns the roots of a univariate <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> as an Eigen column vector of complex numbers whose components are of the RealScalar type. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>of this <a class="el" href="classdrake_1_1_polynomial.html" title="A scalar multi-variate polynomial, modeled after the msspoly in spotless.">Polynomial</a> is not univariate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5590d23d37495f26e4e0226674af2436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5590d23d37495f26e4e0226674af2436">&#9670;&nbsp;</a></span>Subs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Subs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> &amp;&#160;</td>
          <td class="paramname"><em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all instances of variable orig with replacement. </p>

</div>
</div>
<a id="ad69112ea5f074512671136b4aa3748ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69112ea5f074512671136b4aa3748ee">&#9670;&nbsp;</a></span>Substitute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> Substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> &amp;&#160;</td>
          <td class="paramname"><em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all instances of variable orig with replacement. </p>

</div>
</div>
<a id="aeaeacfff3d087ad400147e605269ad3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaeacfff3d087ad400147e605269ad3c">&#9670;&nbsp;</a></span>VariableNameToId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdrake_1_1_polynomial.html#adb36a6e938f851b1a5d1a443c2dadb8a">VarType</a> VariableNameToId </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>m</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a9e0839a4ea39ab4780de70e5913107d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0839a4ea39ab4780de70e5913107d6">&#9670;&nbsp;</a></span>operator * <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2987c7f3ad9e1181254639ea91939d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2987c7f3ad9e1181254639ea91939d9">&#9670;&nbsp;</a></span>operator * <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> operator * </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b8ee5b634b35a7c4db1cddc532d177c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8ee5b634b35a7c4db1cddc532d177c">&#9670;&nbsp;</a></span>operator+ <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa14fcd10f0a5683e9778d1ad46b869a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14fcd10f0a5683e9778d1ad46b869a6">&#9670;&nbsp;</a></span>operator+ <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acf2f5dc8759b0683d649a356e1c23bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf2f5dc8759b0683d649a356e1c23bc8">&#9670;&nbsp;</a></span>operator- <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a30d861d1bfde004747d8a90c6e61e728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d861d1bfde004747d8a90c6e61e728">&#9670;&nbsp;</a></span>operator- <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3dd692da2aab783313611876753b0b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd692da2aab783313611876753b0b3f">&#9670;&nbsp;</a></span>operator&lt;&lt; <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a268b9f8605e7fc2cca049db6c64182cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268b9f8605e7fc2cca049db6c64182cf">&#9670;&nbsp;</a></span>operator&lt;&lt; <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2144bf3acf165a2a921d7df87ac4eafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2144bf3acf165a2a921d7df87ac4eafe">&#9670;&nbsp;</a></span>pow</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt;U&gt; pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a>&lt; U &gt;::<a class="el" href="classdrake_1_1_polynomial.html#a6b2fc1d3e138053b9dc8864815059fe0">PowerType</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/common/<a class="el" href="polynomial_8h.html">polynomial.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="classdrake_1_1_polynomial.html">Polynomial</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
